/*
==============
RBT_Tonemap_Filter
==============
*/

void __fastcall RBT_Tonemap_Filter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Tonemap_Filter@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Tonemap_Filter_Common
==============
*/

void __fastcall RBT_Tonemap_Filter_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, unsigned int attachmentOffset)
{
  ?RBT_Tonemap_Filter_Common@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@I@Z(gfxContext, taskInfo, viewInfo, data, attachmentOffset);
}

/*
==============
RBT_Tonemap_CalculateExposure
==============
*/

void __fastcall RBT_Tonemap_CalculateExposure(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Tonemap_CalculateExposure@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_Tonemap_Filter_SMAA
==============
*/

void __fastcall RBT_Tonemap_Filter_SMAA(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Tonemap_Filter_SMAA@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_UniversalClut<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_UniversalClut<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_UniversalClut@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_Tonemap_Filter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Tonemap_Filter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>)
{
  return ??$cRBT_Tonemap_Filter@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>);
}

/*
==============
cRBT_Tonemap_Filter_TemporalSMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Tonemap_Filter_TemporalSMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  return ??$cRBT_Tonemap_Filter_TemporalSMAA@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBT_Tonemap_Filter_SMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Tonemap_Filter_SMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  return ??$cRBT_Tonemap_Filter_SMAA@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
RBTD_Screenshot_CaptureHiResScreenshot
==============
*/

void __fastcall RBTD_Screenshot_CaptureHiResScreenshot(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Screenshot_CaptureHiResScreenshot@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Tonemap_CalculateExposure<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Tonemap_CalculateExposure<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_Tonemap_CalculateExposure@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
RBTD_RefShaderOverlay
==============
*/

void __fastcall RBTD_RefShaderOverlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_RefShaderOverlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_RefShaderOverlay<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_RefShaderOverlay<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_RefShaderOverlay@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBTD_Screenshot_CapturePipelineStage
==============
*/

void __fastcall RBTD_Screenshot_CapturePipelineStage(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Screenshot_CapturePipelineStage@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Tonemap_Filter_TemporalSMAA
==============
*/

void __fastcall RBT_Tonemap_Filter_TemporalSMAA(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Tonemap_Filter_TemporalSMAA@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_UniversalClut
==============
*/

void __fastcall RBT_UniversalClut(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_UniversalClut@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_RefShaderOverlay<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_RefShaderOverlay<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_RefShaderOverlay.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Tonemap_CalculateExposure<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Tonemap_CalculateExposure<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Tonemap_CalculateExposure.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Tonemap_Filter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Tonemap_Filter<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_Tonemap_Filter.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>);
}

/*
==============
cRBT_Tonemap_Filter_SMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Tonemap_Filter_SMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_Tonemap_Filter_SMAA.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBT_Tonemap_Filter_TemporalSMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Tonemap_Filter_TemporalSMAA<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_Tonemap_Filter_TemporalSMAA.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBT_UniversalClut<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_UniversalClut<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_UniversalClut.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBTD_RefShaderOverlay
==============
*/
void RBTD_RefShaderOverlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const dvar_t *v4; 
  const R_RT_Surface *Surface; 
  GfxCmdBufContext v10; 

  v4 = DVARINT_r_refShaderRenderStage;
  _RSI = gfxContext;
  if ( !DVARINT_r_refShaderRenderStage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_refShaderRenderStage") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.integer )
  {
    Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups xmmword ptr [rsp+58h+var_18.source], xmm0
    }
    R_UniversalClut_SetParametersImage(&v10, viewInfo, &Surface->m_image.m_base, &Surface->m_image.m_base);
    R_RefShader_Draw(_RSI, viewInfo);
  }
}

/*
==============
RBTD_Screenshot_CaptureHiResScreenshot
==============
*/
void RBTD_Screenshot_CaptureHiResScreenshot(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v8; 
  R_RT_ColorHandle v9; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v8);
    if ( (R_RT_Handle::GetSurface(&v8)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+78h+var_28.baseclass_0.m_surfaceID], ymm0 }
  RB_TakeScreenshot(&v9, 0, 0, -1, -1);
}

/*
==============
RBTD_Screenshot_CapturePipelineStage
==============
*/
void RBTD_Screenshot_CapturePipelineStage(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v8; 
  R_RT_Handle v13; 
  R_RT_ColorHandle v14; 

  _RSI = gfxContext;
  v8 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+78h+var_28], ymm0
    vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v13);
    if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+78h+var_48.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+78h+var_28] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups [rsp+78h+var_28], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+78h+var_48.m_surfaceID], xmm0
  }
  R_Screenshot_CapturePipelineStage((GfxCmdBufContext *)&v13, viewInfo, data, (GfxScreenshotPipelineStage)v8, &v14);
}

/*
==============
RBT_Tonemap_CalculateExposure
==============
*/
void RBT_Tonemap_CalculateExposure(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v11; 
  bool v19; 
  bool v28; 
  bool v33; 
  bool v34; 
  R_RT_Image *blackImage; 
  bool v39; 
  R_RT_Handle v44; 
  R_RT_Handle v45; 
  R_RT_Handle v46; 
  R_RT_ColorHandle v47; 
  R_RT_ColorHandle v49; 
  R_RT_Handle v50; 
  R_RT_ColorHandle v51; 

  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
  _RCX = taskInfo->attachments;
  v11 = WrappedBuffer;
  __asm
  {
    vmovups ymm1, ymmword ptr [rcx+20h]
    vmovd   ecx, xmm1
    vmovups [rbp+90h+var_E0], ymm1
    vmovups ymmword ptr [rsp+190h+var_120.m_surfaceID], ymm1
  }
  if ( (_WORD)_RCX )
  {
    R_RT_Handle::GetSurface(&v45);
    if ( (R_RT_Handle::GetSurface(&v45)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+190h+var_120.m_surfaceID]
        vmovups [rbp+90h+var_E0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+190h+var_120.m_surfaceID]
        vmovups [rbp+90h+var_E0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+190h+var_120.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+190h+var_140.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID]
        vmovups ymmword ptr [rsp+190h+var_120.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID]
        vmovups ymmword ptr [rsp+190h+var_120.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+190h+var_120.m_surfaceID] }
      if ( v19 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups [rbp+90h+var_60], ymm0
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+90h+var_C0], ymm1
    vmovups ymmword ptr [rsp+190h+var_140.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID]
        vmovups [rbp+90h+var_C0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID]
        vmovups [rbp+90h+var_C0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+190h+var_140.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+90h+var_80.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+90h+var_80.m_surfaceID]
        vmovups ymmword ptr [rsp+190h+var_140.m_surfaceID], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+90h+var_80.m_surfaceID]
        vmovups ymmword ptr [rsp+190h+var_140.m_surfaceID], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID] }
      if ( v28 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups [rbp+90h+var_A0], ymm0
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   edi, xmm0
    vmovups ymmword ptr [rbp+90h+var_100.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+90h+var_80.m_surfaceID], ymm0
  }
  if ( (_WORD)_EDI )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LOWORD(_EDI) = v50.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rbp+90h+var_80.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      LOWORD(_EDI) = v50.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rbp+90h+var_80.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v33 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+90h+var_100.m_surfaceID] }
      if ( v33 )
        __debugbreak();
    }
  }
  v34 = (_WORD)_EDI == 0;
  blackImage = (R_RT_Image *)rgp.blackImage;
  _RBX = &v51;
  if ( !v34 )
    _RBX = (R_RT_ColorHandle *)&v50;
  v34 = viewInfo->taskGraphViewInfo.temporalFrameIndex == 0;
  __asm
  {
    vmovups ymmword ptr [rbp+90h+var_80.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rsp+190h+var_140.m_surfaceID]
    vmovd   eax, xmm0
  }
  v39 = !v34;
  __asm { vmovups ymmword ptr [rbp+90h+var_100.m_surfaceID], ymm0 }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v46);
    blackImage = &R_RT_Handle::GetSurface(&v46)->m_image;
  }
  else if ( v49.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  __asm
  {
    vmovups ymm0, [rbp+90h+var_C0]
    vmovups ymm1, ymmword ptr [rbx]
    vmovups [rbp+90h+var_A0], ymm0
    vmovups ymm0, [rbp+90h+var_E0]
    vmovups ymmword ptr [rbp+90h+var_100.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rsp+190h+var_120.m_surfaceID]
    vmovups [rbp+90h+var_E0], ymm0
    vmovups [rbp+90h+var_60], ymm1
  }
  R_Tonemap_CalculateExposureCS(computeState, viewInfo, &v47, (const R_RT_ColorHandle *)&v46, &v51, &v49, &blackImage->m_base, v11, v39);
}

/*
==============
RBT_Tonemap_Filter
==============
*/
void RBT_Tonemap_Filter(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  RBT_Tonemap_Filter_Common(&v5, taskInfo, viewInfo, data, 0);
}

/*
==============
RBT_Tonemap_Filter_Common
==============
*/
void RBT_Tonemap_Filter_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, unsigned int attachmentOffset)
{
  const GfxTaskInfo *v11; 
  R_RT_Handle *v12; 
  const R_RT_Surface *Surface; 
  R_RT_Image *v17; 
  R_RT_Image *blackImage; 
  R_RT_Image *v22; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Image *v25; 
  R_RT_Image *v29; 
  const GfxImage *p_m_base; 
  __int64 p_input; 
  GfxImage *v38; 
  GfxCmdBufSourceState *source; 
  bool v40; 
  GfxCmdBufInput *v41; 
  bool v42; 
  GfxImage *v43; 
  GfxCmdBufSourceState *v44; 
  GfxCmdBufInput *v46; 
  GfxCmdBufSourceState *v47; 
  GfxCmdBufInput *v48; 
  GfxCmdBufSourceState *v49; 
  GfxCmdBufInput *v50; 
  unsigned __int8 v60; 
  R_RT_Image *v68; 
  GfxCmdBufSourceState *v69; 
  GfxCmdBufInput *v70; 
  unsigned int height; 
  const R_RT_Surface *v73; 
  unsigned int width; 
  bool v80; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v86; 
  R_RT_Handle v87; 
  void *retaddr; 
  const GfxWrappedBuffer *v90; 
  const GfxTaskInfo *v91; 

  _RAX = &retaddr;
  v91 = taskInfo;
  __asm { vmovups ymm0, ymmword ptr [rdx+38h] }
  _RSI = gfxContext;
  __asm { vmovaps xmmword ptr [rax-58h], xmm6 }
  v11 = taskInfo;
  v12 = &taskInfo->attachments[attachmentOffset];
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovups ymmword ptr [rbp-31h], ymm0
  }
  p_m_image = &R_RT_Handle::GetSurface(v12)->m_image;
  Surface = R_RT_Handle::GetSurface(&v11->attachments[attachmentOffset + 1]);
  _RAX = v11->attachments;
  _RCX = 32i64 * (attachmentOffset + 2);
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v86);
    v17 = &R_RT_Handle::GetSurface(&v86)->m_image;
  }
  else
  {
    if ( v86.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", p_m_image) )
      __debugbreak();
    v17 = &Surface->m_image;
  }
  _RAX = v11->attachments;
  blackImage = (R_RT_Image *)rgp.blackImage;
  _RCX = 32i64 * (attachmentOffset + 3);
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v86);
    blackImage = &R_RT_Handle::GetSurface(&v86)->m_image;
  }
  else if ( v86.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v22 = &R_RT_Handle::GetSurface(&v11->attachments[attachmentOffset + 4])->m_image;
  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(&v11->attachments[attachmentOffset + 5]);
  _RCX = v11->attachments;
  v25 = (R_RT_Image *)rgp.blackImage;
  _RDX = 32i64 * (attachmentOffset + 6);
  v90 = WrappedBuffer;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdx+rcx]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_ECX )
  {
    R_RT_Handle::GetSurface(&v86);
    v25 = &R_RT_Handle::GetSurface(&v86)->m_image;
  }
  else if ( v86.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v29 = (R_RT_Image *)rgp.blackImage;
  _RDX = 32i64 * (attachmentOffset + 7);
  _RCX = v91->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdx+rcx]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v86);
    v29 = &R_RT_Handle::GetSurface(&v86)->m_image;
  }
  else if ( v86.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  p_m_base = &Surface->m_image.m_base;
  _R14 = viewInfo;
  __asm { vmovups xmmword ptr [rbp+4Fh+var_A0.m_surfaceID], xmm0 }
  R_UniversalClut_SetParametersImage((const GfxCmdBufContext *)&v86, viewInfo, p_m_base, &v17->m_base);
  p_input = (__int64)&_RSI->source->input;
  if ( _RSI->source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1494, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  *(_QWORD *)(p_input + 7424) = v90;
  v38 = rgp.blackImage;
  if ( viewInfo->perceptual.veilEnabled )
    v38 = &blackImage->m_base;
  source = _RSI->source;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v40 = __CFADD__(source, 1792i64);
  v41 = &source->input;
  if ( !v41 )
  {
    v42 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input");
    v40 = 0;
    if ( v42 )
      __debugbreak();
  }
  v41->codeImages[21] = v38;
  v43 = rgp.blackImage;
  v44 = _RSI->source;
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm7, dword ptr [r14+3840h]
  }
  if ( v40 )
    v43 = &v22->m_base;
  if ( !v44 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v46 = &v44->input;
  if ( !v46 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v46->codeImages[22] = v43;
  v47 = _RSI->source;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v48 = &v47->input;
  if ( !v48 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v48->codeImages[80] = &v25->m_base;
  v49 = _RSI->source;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v50 = &v49->input;
  if ( !v50 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  v50->codeImages[0] = &v29->m_base;
  __asm { vmovss  xmm0, dword ptr [r14+3860h] }
  _RAX = _RSI->source;
  __asm
  {
    vmovss  xmm2, dword ptr [r14+3844h]
    vmovss  xmm1, dword ptr [r14+3840h]
  }
  _RCX = 32i64 * (attachmentOffset + 8);
  __asm
  {
    vmovss  dword ptr [rax+0EC0h], xmm0
    vmovss  dword ptr [rax+0EC8h], xmm1
    vmovss  dword ptr [rax+0ECCh], xmm2
    vsubss  xmm0, xmm6, xmm0
    vmovss  dword ptr [rax+0EC4h], xmm0
  }
  ++_RAX->constVersions[124];
  _RAX = v91->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+rax]
    vmovups ymmword ptr [rbp+4Fh+var_A0.m_surfaceID], ymm0
  }
  if ( !R_HudOutline_Enabled(viewInfo) )
    goto LABEL_58;
  if ( !v86.m_surfaceID )
  {
    if ( v86.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
LABEL_58:
    v60 = 0;
    goto LABEL_59;
  }
  R_RT_Handle::GetSurface(&v86);
  v60 = 1;
LABEL_59:
  _RCX = _RSI->source;
  _ER8 = 0;
  _EAX = v60;
  __asm
  {
    vmovd   xmm0, eax
    vmovd   xmm1, r8d
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm0, xmm6, xmm7, xmm2
    vmovss  dword ptr [rcx+7F0h], xmm0
  }
  *(_QWORD *)&_RCX->input.consts[15].xyz.y = 0i64;
  _RCX->input.consts[15].v[3] = 0.0;
  ++_RCX->constVersions[15];
  if ( v60 )
    v68 = &R_RT_Handle::GetSurface(&v86)->m_image;
  else
    v68 = (R_RT_Image *)rgp.blackImage;
  v69 = _RSI->source;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v70 = &v69->input;
  if ( !v70 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v70->codeImages[23] = &v68->m_base;
  R_SetPersistentTables(_RSI, data, PERSISTENT_TABLE_SCENE);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rbp+4Fh+var_A0.m_surfaceID], xmm0
  }
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v86, viewInfo);
  height = R_RT_Handle::GetSurface(&v87)->m_image.m_base.height;
  v73 = R_RT_Handle::GetSurface(&v87);
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  width = v73->m_image.m_base.width;
  __asm { vmovups xmmword ptr [rbp+4Fh+var_A0.m_surfaceID], xmm0 }
  R_Tonemap_Filter((GfxCmdBufContext *)&v86, viewInfo, &p_m_image->m_base, width, height);
  _RAX = v91->attachments;
  _RCX = 32i64 * attachmentOffset;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+4Fh+var_80.m_surfaceID], ymm0
    vmovups ymmword ptr [rbp+4Fh+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v86);
    if ( (R_RT_Handle::GetSurface(&v86)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+4Fh+var_A0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+4Fh+var_A0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v80 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+4Fh+var_80.m_surfaceID] }
      if ( v80 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymmword ptr [rbp+4Fh+var_80.m_surfaceID], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rbp+4Fh+var_A0.m_surfaceID], xmm0
  }
  R_Screenshot_CapturePipelineStage((GfxCmdBufContext *)&v86, viewInfo, data, EASE_IN_CUBIC, (R_RT_ColorHandle *)&v87);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rbp+4Fh+var_A0.m_surfaceID], xmm0
  }
  R_Tonemap_ReadExposureInfoFromGpu((GfxCmdBufContext *)&v86, viewInfo, v90);
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+0E0h+var_58+8]
    vmovaps xmm7, xmmword ptr [rsp+80h]
  }
}

/*
==============
RBT_Tonemap_Filter_SMAA
==============
*/
void RBT_Tonemap_Filter_SMAA(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  RBT_Tonemap_Filter_Common(&v5, taskInfo, viewInfo, data, 0);
}

/*
==============
RBT_Tonemap_Filter_TemporalSMAA
==============
*/
void RBT_Tonemap_Filter_TemporalSMAA(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  RBT_Tonemap_Filter_Common(&v5, taskInfo, viewInfo, data, 4u);
}

/*
==============
RBT_UniversalClut
==============
*/
void RBT_UniversalClut(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v9; 

  Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
  v9 = R_RT_Handle::GetSurface(taskInfo->attachments + 1);
  if ( R_UniversalClut_Update(viewInfo, &Surface->m_image.m_base, viewInfo->taskGraphViewInfo.temporalFrameIndex == 0) )
  {
    R_UniversalClut_GenerateImage(computeState, viewInfo, data, &Surface->m_image.m_base, MOVEMENT);
    R_UniversalClut_GenerateImage(computeState, viewInfo, data, &v9->m_image.m_base, DODGE);
  }
}

