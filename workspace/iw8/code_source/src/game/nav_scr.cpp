/*
==============
Scr_GetClosestReachablePointOnNavmesh
==============
*/

void __fastcall Scr_GetClosestReachablePointOnNavmesh(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetClosestReachablePointOnNavmesh@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetModifierLocationBetween
==============
*/

void __fastcall Scr_GetModifierLocationBetween(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetModifierLocationBetween@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_IsPointOnNavMesh3d
==============
*/

void __fastcall Scr_IsPointOnNavMesh3d(scrContext_t *scrContext)
{
  ?Scr_IsPointOnNavMesh3d@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByBounds
==============
*/

void __fastcall Scr_CreateNavObstacleByBounds(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByBounds@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNavSpaceEnt
==============
*/

void __fastcall Scr_GetNavSpaceEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetNavSpaceEnt@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_FindPathCustom
==============
*/

void __fastcall Scr_FindPathCustom(scrContext_t *scrContext)
{
  ?Scr_FindPathCustom@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_FindPath
==============
*/

void __fastcall Scr_FindPath(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_FindPath@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_CreateNavObstacleByEnt
==============
*/

void __fastcall Scr_CreateNavObstacleByEnt(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByEnt@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_NavIsStraightLineReachable
==============
*/

void __fastcall Scr_NavIsStraightLineReachable(scrContext_t *scrContext)
{
  ?Scr_NavIsStraightLineReachable@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetModifierLocationOnPath
==============
*/

void __fastcall Scr_GetModifierLocationOnPath(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetModifierLocationOnPath@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_NavTrace
==============
*/

void __fastcall Scr_NavTrace(scrContext_t *scrContext)
{
  ?Scr_NavTrace@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetRandomNavPoint
==============
*/

void __fastcall Scr_GetRandomNavPoint(scrContext_t *scrContext)
{
  ?Scr_GetRandomNavPoint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByShapeForLayer
==============
*/

void __fastcall Scr_CreateNavObstacleByShapeForLayer(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByShapeForLayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_UndockMovingPlatform
==============
*/

void __fastcall Scr_UndockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_UndockMovingPlatform@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_CreateNavBadplaceByEnt
==============
*/

void __fastcall Scr_CreateNavBadplaceByEnt(scrContext_t *scrContext)
{
  ?Scr_CreateNavBadplaceByEnt@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavBadplaceByBounds
==============
*/

void __fastcall Scr_CreateNavBadplaceByBounds(scrContext_t *scrContext)
{
  ?Scr_CreateNavBadplaceByBounds@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_IsNavMeshLoaded
==============
*/

void __fastcall Scr_IsNavMeshLoaded(scrContext_t *scrContext)
{
  ?Scr_IsNavMeshLoaded@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetClosestPointOnNavmesh3d
==============
*/

void __fastcall Scr_GetClosestPointOnNavmesh3d(scrContext_t *scrContext)
{
  ?Scr_GetClosestPointOnNavmesh3d@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavBadplaceByShape
==============
*/

void __fastcall Scr_CreateNavBadplaceByShape(scrContext_t *scrContext)
{
  ?Scr_CreateNavBadplaceByShape@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByEntForLayer
==============
*/

void __fastcall Scr_CreateNavObstacleByEntForLayer(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByEntForLayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
NAV_GetModifierFlagsFromString
==============
*/

unsigned int __fastcall NAV_GetModifierFlagsFromString(const char *flagString)
{
  return ?NAV_GetModifierFlagsFromString@@YAIPEBD@Z(flagString);
}

/*
==============
Scr_AreAnyNavVolumesLoaded
==============
*/

void __fastcall Scr_AreAnyNavVolumesLoaded(scrContext_t *scrContext)
{
  ?Scr_AreAnyNavVolumesLoaded@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_NavIsStraightLineReachable3D
==============
*/

void __fastcall Scr_NavIsStraightLineReachable3D(scrContext_t *scrContext)
{
  ?Scr_NavIsStraightLineReachable3D@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByShape
==============
*/

void __fastcall Scr_CreateNavObstacleByShape(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByShape@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DestroyNavObstacle
==============
*/

void __fastcall Scr_DestroyNavObstacle(scrContext_t *scrContext)
{
  ?Scr_DestroyNavObstacle@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DestroyNavRepulsor
==============
*/

void __fastcall Scr_DestroyNavRepulsor(scrContext_t *scrContext)
{
  ?Scr_DestroyNavRepulsor@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetRandomNavPoints
==============
*/

void __fastcall Scr_GetRandomNavPoints(scrContext_t *scrContext)
{
  ?Scr_GetRandomNavPoints@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavLink
==============
*/

void __fastcall Scr_CreateNavLink(scrContext_t *scrContext)
{
  ?Scr_CreateNavLink@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_FindPath3D
==============
*/

void __fastcall Scr_FindPath3D(scrContext_t *scrContext)
{
  ?Scr_FindPath3D@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavObstacleByBoundsForLayer
==============
*/

void __fastcall Scr_CreateNavObstacleByBoundsForLayer(scrContext_t *scrContext)
{
  ?Scr_CreateNavObstacleByBoundsForLayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavRepulsor
==============
*/

void __fastcall Scr_CreateNavRepulsor(scrContext_t *scrContext)
{
  ?Scr_CreateNavRepulsor@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DestroyNavLink
==============
*/

void __fastcall Scr_DestroyNavLink(scrContext_t *scrContext)
{
  ?Scr_DestroyNavLink@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_IsPointOnNavMesh
==============
*/

void __fastcall Scr_IsPointOnNavMesh(scrContext_t *scrContext)
{
  ?Scr_IsPointOnNavMesh@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNavPosition
==============
*/

void __fastcall Scr_GetNavPosition(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetNavPosition@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetClosestPointOnNavmesh
==============
*/

void __fastcall Scr_GetClosestPointOnNavmesh(scrContext_t *scrContext)
{
  ?Scr_GetClosestPointOnNavmesh@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_CreateNavModifier
==============
*/

void __fastcall Scr_CreateNavModifier(scrContext_t *scrContext)
{
  ?Scr_CreateNavModifier@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_NavTrace3D
==============
*/

void __fastcall Scr_NavTrace3D(scrContext_t *scrContext)
{
  ?Scr_NavTrace3D@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_DockMovingPlatform
==============
*/

void __fastcall Scr_DockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_DockMovingPlatform@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GetLayerFromName
==============
*/
__int64 GetLayerFromName(scrContext_t *scrContext, const scr_string_t layerName)
{
  const char *v4; 
  const char *v5; 

  if ( layerName == scr_const.tank_med )
    return 2i64;
  if ( layerName != scr_const.human && layerName != scr_const.soldier )
  {
    v4 = SL_ConvertToString(layerName);
    v5 = j_va("Unsupported layer name %s", v4);
    Scr_Error(COM_ERR_1496, scrContext, v5);
  }
  return 0i64;
}

/*
==============
NAV_GetModifierFlagsFromString
==============
*/
__int64 NAV_GetModifierFlagsFromString(const char *flagString)
{
  __int64 result; 
  bool v3; 

  if ( !flagString )
    return 0xFFFFFFFFi64;
  if ( !I_stricmp(flagString, "door") )
    return 0x10000000i64;
  if ( !I_stricmp(flagString, "prone") )
    return 0x40000000i64;
  v3 = I_stricmp(flagString, "crouch") == 0;
  result = 0x20000000i64;
  if ( !v3 )
    return 0xFFFFFFFFi64;
  return result;
}

/*
==============
Scr_AreAnyNavVolumesLoaded
==============
*/
void Scr_AreAnyNavVolumesLoaded(scrContext_t *scrContext)
{
  bool v2; 

  v2 = Nav_AnyVolumesLoaded();
  Scr_AddBool(scrContext, v2);
}

/*
==============
Scr_CreateNavBadplaceByBounds
==============
*/
void Scr_CreateNavBadplaceByBounds(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByBounds_Internal(scrContext, 0, 0xFFFFFFFF, 0, 0);
}

/*
==============
Scr_CreateNavBadplaceByEnt
==============
*/
void Scr_CreateNavBadplaceByEnt(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByEnt_Internal(scrContext, 0, 0xFFFFFFFF, 0, 0);
}

/*
==============
Scr_CreateNavBadplaceByShape
==============
*/
void Scr_CreateNavBadplaceByShape(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByShape_Internal(scrContext, 0, 0xFFFFFFFF, 0, 0);
}

/*
==============
Scr_CreateNavLink
==============
*/
void Scr_CreateNavLink(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v8; 
  pathnode_t *Pathnode; 
  unsigned int Int; 
  int v11; 
  const gentity_s *Entity; 
  nav_space_s *DefaultSpace; 
  const char *v14; 
  signed int v16; 
  unsigned __int16 v17; 
  bfx::LinkDat pLinkDat; 
  vec3_t targetPos; 
  vec3_t vectorValue; 
  bfx::PathSpec pPathSpec; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+130h+pLinkDat.m_penaltyMult], xmm0
  }
  pLinkDat.m_type = JUMP_LINK;
  pLinkDat.m_userData = 0i64;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  pLinkDat.m_layerMask = -1;
  *(_WORD *)&pLinkDat.m_bidirectional = 1;
  *(_QWORD *)&pLinkDat.m_forwardLinkUsageFlags = -1i64;
  *(float *)&_XMM0 = bfx::GetScale();
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@40800000
    vmovss  [rsp+130h+pLinkDat.m_maxSnapDist], xmm1
  }
  *(float *)&_XMM0 = bfx::GetScale();
  __asm { vxorps  xmm6, xmm6, xmm6 }
  pLinkDat.m_flowTune.m_maxSimultaneous = 0;
  __asm
  {
    vmovss  [rsp+130h+pLinkDat.m_mustUseDist], xmm6
    vmovss  [rsp+130h+pLinkDat.m_flowTune.m_delayBeforeNextUser], xmm6
    vmovss  [rsp+130h+pLinkDat.m_mayUseDist], xmm0
  }
  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_1501, scrContext, "CreateNavLink( linkName, startPos, endPos, animscript ): invalid number of arguments.");
  if ( *Scr_GetString(scrContext, 0) )
    ConstString = Scr_GetConstString(scrContext, 0);
  else
    ConstString = 0;
  v8 = 1;
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &targetPos);
  if ( Scr_GetType(scrContext, 3u) == VAR_STRING )
  {
    Scr_GetString(scrContext, 3u);
    v17 = -1;
  }
  else
  {
    Pathnode = Scr_GetPathnode(scrContext, 3u);
    v17 = Path_ConvertNodeToIndex(Pathnode);
    if ( ((1 << LOBYTE(Pathnode->constant.type)) & 0x68010000) == 0 )
      Scr_Error(COM_ERR_1502, scrContext, "CreateNavLink: pathnode (arg4) must be a negotiation begin node.");
  }
  Int = 2047;
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) == VAR_INTEGER )
    Int = Scr_GetInt(scrContext, 4u);
  v11 = -1;
  if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) == VAR_INTEGER )
    v11 = Scr_GetInt(scrContext, 5u);
  if ( Scr_GetNumParam(scrContext) <= 6 || Scr_GetType(scrContext, 6u) != VAR_POINTER )
  {
    DefaultSpace = Nav_GetDefaultSpace();
    if ( DefaultSpace )
      goto LABEL_26;
    goto LABEL_24;
  }
  Entity = GScr_GetEntity(6u);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 369, ASSERT_TYPE_ASSERT, "( pSpaceEnt )", (const char *)&queryFormat, "pSpaceEnt") )
    __debugbreak();
  DefaultSpace = Nav_GetSpaceByEntity(Entity);
  if ( !DefaultSpace )
  {
    v14 = j_va("CreateNavLink: unable to find navigational space associated with entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1504, scrContext, v14);
LABEL_24:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 379, ASSERT_TYPE_ASSERT, "( pSpace )", (const char *)&queryFormat, "pSpace") )
      __debugbreak();
  }
LABEL_26:
  Nav_SetLinkDatToDefault(&pLinkDat);
  pLinkDat.m_forwardLinkUsageFlags = Int;
  pLinkDat.m_backwardLinkUsageFlags = Int;
  pLinkDat.m_userData = Nav_ConstructLinkUserData(v17, 0xFFFFu);
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  pPathSpec.m_usePathSharingPenalty = 0;
  __asm
  {
    vmovss  [rbp+30h+pPathSpec.m_pathSharingPenalty], xmm6
    vmovss  [rbp+30h+pPathSpec.m_maxPathSharingPenalty], xmm6
    vmovss  [rbp+30h+pPathSpec.m_maxSearchDist], xmm6
  }
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  __asm { vmovaps xmm6, xmmword ptr [rsp+130h+var_38+8] }
  v16 = 0;
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  pPathSpec.m_obstacleBlockageFlags = 0;
  do
  {
    if ( (v8 & v11) != 0 )
    {
      pLinkDat.m_layerMask = v8;
      Nav_GetClosestVerticalPos(&vectorValue, &g_navUp, v16, &DefaultSpace->hSpace, &pPathSpec, &vectorValue, NULL);
      Nav_GetClosestVerticalPos(&targetPos, &g_navUp, v16, &DefaultSpace->hSpace, &pPathSpec, &targetPos, NULL);
      Nav_CreateLink(DefaultSpace, &vectorValue, &targetPos, ConstString, -1, &pLinkDat);
    }
    ++v16;
    v8 = __ROL4__(v8, 1);
  }
  while ( v16 < 3 );
}

/*
==============
Scr_CreateNavModifier
==============
*/
void Scr_CreateNavModifier(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int outModifierID; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString )
    Scr_Error(COM_ERR_1536, scrContext, "CreateNavModifier: invalid name.");
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = v3;
  if ( v3 != scr_const.target && v3 != scr_const.targetname && v3 != scr_const.script_linkname && v3 != scr_const.script_noteworthy )
    Scr_Error(COM_ERR_1537, scrContext, "CreateNavModifier: invalid key provided.  Must be target, targetname, script_linkname, or script_noteworthy");
  if ( !Nav_CreateModifierByName(v4, ConstString, &outModifierID) )
    Scr_Error(COM_ERR_1538, scrContext, "CreateNavModifier: creation failed for some reason.  Possible causes: no modifier found by that name, no modifier found that was marked NOT_ON_LOAD.");
  Scr_AddInt(scrContext, outModifierID);
}

/*
==============
Scr_CreateNavObstacleByBounds
==============
*/
void Scr_CreateNavObstacleByBounds(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByBounds_Internal(scrContext, 0, 0xFFFFFFFF, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByBoundsForLayer
==============
*/
void Scr_CreateNavObstacleByBoundsForLayer(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.tank_med )
  {
    v3 = 4;
  }
  else
  {
    if ( ConstString != scr_const.human && ConstString != scr_const.soldier )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("Unsupported layer name %s", v4);
      Scr_Error(COM_ERR_1496, scrContext, v5);
    }
    v3 = 1;
  }
  Scr_CreateNavObstacleByBounds_Internal(scrContext, 1, v3, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByBounds_Internal
==============
*/
void Scr_CreateNavObstacleByBounds_Internal(scrContext_t *scrContext, int argOffset, unsigned int layermask, bool bSolid, int customBlockageFlags)
{
  int v14; 
  int ObstacleBlockageFlagsFromTeamFlags; 
  int NumParam; 
  char v18; 
  unsigned int v19; 
  bitarray<224> *p_result; 
  int v26; 
  int blockageFlags; 
  int v28; 
  nav_space_s *MostLikelySpaceWithRadius; 
  int v32; 
  Bounds vectorValue; 
  bitarray<224> result; 
  vec3_t angles; 
  char v39; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  Scr_GetVector(scrContext, argOffset, &vectorValue.midPoint);
  Scr_GetVector(scrContext, argOffset + 1, &vectorValue.halfSize);
  Scr_GetVector(scrContext, argOffset + 2, &angles);
  __asm { vmovss  xmm6, cs:__real@41700000 }
  v14 = 3;
  __asm { vmovaps xmm7, xmm6 }
  ObstacleBlockageFlagsFromTeamFlags = customBlockageFlags;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= 3 || (unsigned __int8)(Scr_GetType(scrContext, 3u) - 5) > 1u )
    goto LABEL_11;
  if ( bSolid )
    Scr_Error(COM_ERR_6161, scrContext, "weight arg can only be used with non-solid obstacles.");
  if ( customBlockageFlags )
    Scr_Error(COM_ERR_6162, scrContext, "weight arg cannot be used with any blockage flags");
  if ( NumParam > 4 )
    Scr_Error(COM_ERR_6163, scrContext, "weight arg cannot be used with team blockage flags");
  v14 = 4;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovaps xmm7, xmm0
  }
  if ( v18 )
  {
    ObstacleBlockageFlagsFromTeamFlags = 0x2000;
  }
  else
  {
LABEL_11:
    if ( !customBlockageFlags )
    {
      Scr_GetTeamFlags(&result, scrContext, argOffset + v14);
      v19 = 0;
      p_result = &result;
      while ( !p_result->array[0] )
      {
        ++v19;
        p_result = (bitarray<224> *)((char *)p_result + 4);
        if ( v19 >= 7 )
        {
          if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
            _RAX = Com_TeamsSP_GetAllCombatTeamFlags();
          else
            _RAX = Com_TeamsMP_GetAllTeamFlags();
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rsp+0D8h+result.array], xmm0
            vmovsd  xmm1, qword ptr [rax+10h]
            vmovsd  qword ptr [rsp+0D8h+result.array+10h], xmm1
          }
          result.array[6] = _RAX->array[6];
          break;
        }
      }
      ObstacleBlockageFlagsFromTeamFlags = Nav_GetObstacleBlockageFlagsFromTeamFlags(&result);
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+0D8h+var_9C]
    vmaxss  xmm6, xmm0, dword ptr [rsp+0D8h+var_9C+4]
  }
  v26 = 0;
  blockageFlags = ObstacleBlockageFlagsFromTeamFlags | 1;
  if ( !bSolid )
    blockageFlags = ObstacleBlockageFlagsFromTeamFlags;
  v28 = 1;
  while ( 1 )
  {
    if ( (v28 & layermask) != 0 )
    {
      __asm { vmovaps xmm1, xmm6; radius }
      MostLikelySpaceWithRadius = Nav_FindMostLikelySpaceWithRadius(&vectorValue.midPoint, *(float *)&_XMM1, (const AINavLayer)v26, NULL);
      if ( MostLikelySpaceWithRadius )
        break;
    }
    ++v26;
    v28 = __ROL4__(v28, 1);
    if ( v26 >= 3 )
    {
      MostLikelySpaceWithRadius = Nav_GetDefaultSpace();
      break;
    }
  }
  __asm { vmovaps xmm3, xmm7; penalty }
  v32 = Nav_CreateObstacleByBounds(MostLikelySpaceWithRadius, &vectorValue, &angles, *(float *)&_XMM3, layermask, blockageFlags);
  Scr_AddInt(scrContext, v32);
  _R11 = &v39;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Scr_CreateNavObstacleByEnt
==============
*/
void Scr_CreateNavObstacleByEnt(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByEnt_Internal(scrContext, 0, 0xFFFFFFFF, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByEntForLayer
==============
*/
void Scr_CreateNavObstacleByEntForLayer(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.tank_med )
  {
    v3 = 4;
  }
  else
  {
    if ( ConstString != scr_const.human && ConstString != scr_const.soldier )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("Unsupported layer name %s", v4);
      Scr_Error(COM_ERR_1496, scrContext, v5);
    }
    v3 = 1;
  }
  Scr_CreateNavObstacleByEnt_Internal(scrContext, 1, v3, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByEnt_Internal
==============
*/
void Scr_CreateNavObstacleByEnt_Internal(scrContext_t *scrContext, int argOffset, unsigned int layermask, bool bSolid, int customBlockageFlags)
{
  int v12; 
  int v13; 
  int ObstacleBlockageFlagsFromTeamFlags; 
  int NumParam; 
  char v18; 
  unsigned int v19; 
  bitarray<224> *p_result; 
  int blockageFlags; 
  int v27; 
  nav_space_s *MostLikelySpaceWithRadius; 
  bitarray<224> result; 

  __asm
  {
    vmovaps [rsp+0C8h+var_48], xmm6
    vmovaps [rsp+0C8h+var_58], xmm7
    vmovss  xmm6, cs:__real@41700000
  }
  v12 = 1;
  v13 = 1;
  _RBP = GScr_GetEntity(argOffset);
  __asm { vmovaps xmm7, xmm6 }
  ObstacleBlockageFlagsFromTeamFlags = customBlockageFlags;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= 1 || (unsigned __int8)(Scr_GetType(scrContext, 1u) - 5) > 1u )
    goto LABEL_11;
  if ( bSolid )
    Scr_Error(COM_ERR_6158, scrContext, "weight arg can only be used with non-solid obstacles.");
  if ( customBlockageFlags )
    Scr_Error(COM_ERR_6159, scrContext, "weight arg cannot be used with any other blockage flags.");
  if ( NumParam > 2 )
    Scr_Error(COM_ERR_6160, scrContext, "weight arg cannot be used with team blockage flags.");
  v13 = 2;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovaps xmm7, xmm0
  }
  if ( v18 )
  {
    ObstacleBlockageFlagsFromTeamFlags = 0x2000;
  }
  else
  {
LABEL_11:
    if ( !customBlockageFlags )
    {
      Scr_GetTeamFlags(&result, scrContext, argOffset + v13);
      v19 = 0;
      p_result = &result;
      while ( !p_result->array[0] )
      {
        ++v19;
        p_result = (bitarray<224> *)((char *)p_result + 4);
        if ( v19 >= 7 )
        {
          if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
            _RAX = Com_TeamsSP_GetAllCombatTeamFlags();
          else
            _RAX = Com_TeamsMP_GetAllTeamFlags();
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rsp+0C8h+result.array], xmm0
            vmovsd  xmm1, qword ptr [rax+10h]
            vmovsd  qword ptr [rsp+0C8h+result.array+10h], xmm1
          }
          result.array[6] = _RAX->array[6];
          break;
        }
      }
      ObstacleBlockageFlagsFromTeamFlags = Nav_GetObstacleBlockageFlagsFromTeamFlags(&result);
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+110h]
    vmaxss  xmm6, xmm0, dword ptr [rbp+10Ch]
  }
  blockageFlags = ObstacleBlockageFlagsFromTeamFlags | 1;
  if ( !bSolid )
    blockageFlags = ObstacleBlockageFlagsFromTeamFlags;
  v27 = 0;
  while ( 1 )
  {
    if ( (v12 & layermask) != 0 )
    {
      __asm { vmovaps xmm1, xmm6; radius }
      MostLikelySpaceWithRadius = Nav_FindMostLikelySpaceWithRadius(&_RBP->r.currentOrigin, *(float *)&_XMM1, (const AINavLayer)v27, NULL);
      if ( MostLikelySpaceWithRadius )
        break;
    }
    ++v27;
    v12 = __ROL4__(v12, 1);
    if ( v27 >= 3 )
    {
      MostLikelySpaceWithRadius = Nav_GetDefaultSpace();
      break;
    }
  }
  __asm { vmovaps xmm2, xmm7; penalty }
  Nav_CreateObstacleByEnt(MostLikelySpaceWithRadius, _RBP, *(float *)&_XMM2, layermask, blockageFlags, 0, 0);
  Scr_AddInt(scrContext, _RBP->s.number);
  __asm
  {
    vmovaps xmm6, [rsp+0C8h+var_48]
    vmovaps xmm7, [rsp+0C8h+var_58]
  }
}

/*
==============
Scr_CreateNavObstacleByShape
==============
*/
void Scr_CreateNavObstacleByShape(scrContext_t *scrContext)
{
  Scr_CreateNavObstacleByShape_Internal(scrContext, 0, 0xFFFFFFFF, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByShapeForLayer
==============
*/
void Scr_CreateNavObstacleByShapeForLayer(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.tank_med )
  {
    v3 = 4;
  }
  else
  {
    if ( ConstString != scr_const.human && ConstString != scr_const.soldier )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("Unsupported layer name %s", v4);
      Scr_Error(COM_ERR_1496, scrContext, v5);
    }
    v3 = 1;
  }
  Scr_CreateNavObstacleByShape_Internal(scrContext, 1, v3, 1, 0);
}

/*
==============
Scr_CreateNavObstacleByShape_Internal
==============
*/
void Scr_CreateNavObstacleByShape_Internal(scrContext_t *scrContext, int argOffset, unsigned int layermask, bool bSolid, int customBlockageFlags)
{
  int v12; 
  int Int; 
  int v15; 
  signed int v17; 
  bool v19; 
  const char *v20; 
  const char *v24; 
  int ObstacleBlockageFlagsFromTeamFlags; 
  signed int NumParam; 
  unsigned int v28; 
  bitarray<224> *p_result; 
  int v33; 
  int blockageFlags; 
  int v35; 
  nav_space_s *MostLikelySpaceWithRadius; 
  int v39; 
  float v44; 
  float v45; 
  vec3_t vectorValue; 
  bitarray<224> result; 
  char v48; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
  }
  v12 = argOffset;
  Scr_GetVector(scrContext, argOffset, &vectorValue);
  Int = Scr_GetInt(scrContext, v12 + 1);
  v12 += 2;
  v15 = Int;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, v12);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, v12 + 1);
  v17 = v12 + 2;
  __asm { vmovaps xmm9, xmm0 }
  v19 = (unsigned int)(v15 - 2) < 8;
  if ( (unsigned int)(v15 - 2) > 8 )
  {
    v20 = j_va("Number of sides must be greater than 2 and no more than %d", 10i64);
    Scr_Error(COM_ERR_6402, scrContext, v20);
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v19 )
  {
    __asm
    {
      vcvtss2sd xmm1, xmm6, xmm6
      vmovq   rdx, xmm1
    }
    v24 = j_va("distFromCenter ( %.f ) must be greater than 0", _RDX);
    Scr_Error(COM_ERR_6403, scrContext, v24);
  }
  __asm { vmovss  xmm8, cs:__real@41700000 }
  ObstacleBlockageFlagsFromTeamFlags = customBlockageFlags;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= v17 || (unsigned __int8)(Scr_GetType(scrContext, v17) - 5) > 1u )
    goto LABEL_15;
  if ( bSolid )
    Scr_Error(COM_ERR_6404, scrContext, "weight arg can only be used with non-solid obstacles.");
  if ( customBlockageFlags )
    Scr_Error(COM_ERR_6405, scrContext, "weight arg cannot be used with any other blockage flags.");
  if ( NumParam > v17 + 1 )
    Scr_Error(COM_ERR_6406, scrContext, "weight arg cannot be used with team blockage flags.");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, v17);
  __asm
  {
    vcomiss xmm0, cs:__real@41700000
    vmovaps xmm8, xmm0
  }
  ++v17;
  if ( v19 )
  {
    ObstacleBlockageFlagsFromTeamFlags = 0x2000;
  }
  else
  {
LABEL_15:
    if ( !customBlockageFlags )
    {
      Scr_GetTeamFlags(&result, scrContext, v17);
      v28 = 0;
      p_result = &result;
      while ( !p_result->array[0] )
      {
        ++v28;
        p_result = (bitarray<224> *)((char *)p_result + 4);
        if ( v28 >= 7 )
        {
          if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
            _RAX = Com_TeamsSP_GetAllCombatTeamFlags();
          else
            _RAX = Com_TeamsMP_GetAllTeamFlags();
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rsp+0F8h+result.array], xmm0
            vmovsd  xmm1, qword ptr [rax+10h]
            vmovsd  qword ptr [rsp+0F8h+result.array+10h], xmm1
          }
          result.array[6] = _RAX->array[6];
          break;
        }
      }
      ObstacleBlockageFlagsFromTeamFlags = Nav_GetObstacleBlockageFlagsFromTeamFlags(&result);
    }
  }
  v33 = 1;
  blockageFlags = ObstacleBlockageFlagsFromTeamFlags | 1;
  if ( !bSolid )
    blockageFlags = ObstacleBlockageFlagsFromTeamFlags;
  v35 = 0;
  while ( 1 )
  {
    if ( (v33 & layermask) != 0 )
    {
      __asm { vmovaps xmm1, xmm6; radius }
      MostLikelySpaceWithRadius = Nav_FindMostLikelySpaceWithRadius(&vectorValue, *(float *)&_XMM1, (const AINavLayer)v35, NULL);
      if ( MostLikelySpaceWithRadius )
        break;
    }
    ++v35;
    v33 = __ROL4__(v33, 1);
    if ( v35 >= 3 )
    {
      MostLikelySpaceWithRadius = Nav_GetDefaultSpace();
      break;
    }
  }
  __asm
  {
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovaps xmm3, xmm6; distFromCenter
    vmovss  [rsp+0F8h+var_D8], xmm9
  }
  v39 = Nav_CreateObstacleByShape(MostLikelySpaceWithRadius, &vectorValue, v15, *(float *)&_XMM3, v44, v45, layermask, blockageFlags, 0, 0);
  Scr_AddInt(scrContext, v39);
  _R11 = &v48;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-20h]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
}

/*
==============
Scr_CreateNavRepulsor
==============
*/

void __fastcall Scr_CreateNavRepulsor(scrContext_t *scrContext, double _XMM1_8)
{
  bool bBadplace; 
  unsigned int v8; 
  scr_string_t name; 
  unsigned int v18; 
  int entNum; 
  nav_space_s *m_pSpace; 
  const char *v21; 
  const char *v22; 
  bitarray<224> *p_result; 
  VariableType Type; 
  bool v31; 
  bool v32; 
  AINavigator *Navigator; 
  int usageFlags; 
  nav_repulsor_s *v39; 
  const char *v41; 
  float v42; 
  vec3_t vectorValue; 
  bitarray<224> result; 
  void *retaddr; 

  _R11 = &retaddr;
  bBadplace = 0;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  v8 = 0;
  if ( *Scr_GetString(scrContext, 0) )
    name = Scr_GetConstString(scrContext, 0);
  else
    name = 0;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm2, xmm0, cs:__real@447a0000
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm3, xmm1, xmm2
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm3, 2
    vcvttss2si r13d, xmm4
  }
  if ( Scr_GetType(scrContext, 2u) == VAR_VECTOR )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
      vmovaps xmm6, xmm0
    }
    v18 = 4;
    if ( v31 )
      Scr_Error(COM_ERR_1506, scrContext, "CreateNavRepulsor: cannot create repulsor with non-positive radius.");
    entNum = 2047;
  }
  else
  {
    __asm { vmovaps [rsp+0D8h+var_48], xmm7 }
    _RBP = GScr_GetEntity(2u);
    v18 = 3;
    if ( !_RBP )
      Scr_Error(COM_ERR_1507, scrContext, "CreateNavRepulsor requires a valid entity. If no entity is desired, then create a repulsor with a point/radius instead.");
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+130h]
      vmovss  dword ptr [rsp+0D8h+vectorValue], xmm0
      vmovss  xmm1, dword ptr [rbp+134h]
      vmovss  dword ptr [rsp+0D8h+vectorValue+4], xmm1
      vmovss  xmm0, dword ptr [rbp+138h]
      vmovss  dword ptr [rsp+0D8h+vectorValue+8], xmm0
      vxorps  xmm7, xmm7, xmm7
    }
    if ( Scr_GetType(scrContext, 3u) != VAR_INTEGER )
    {
      Type = Scr_GetType(scrContext, 3u);
      v31 = (unsigned __int8)Type < VAR_FLOAT;
      v32 = Type == VAR_FLOAT;
      if ( Type != VAR_FLOAT )
        goto LABEL_34;
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vcomiss xmm0, xmm7
      vmovaps xmm6, xmm0
    }
    v18 = 4;
    if ( v31 || v32 )
    {
LABEL_34:
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+110h]
        vmaxss  xmm6, xmm0, dword ptr [rbp+10Ch]
        vcomiss xmm6, xmm7
      }
      if ( v31 || v32 )
        Scr_Error(COM_ERR_1508, scrContext, "CreateNavRepulsor: entity has non-positive radius.");
    }
    entNum = _RBP->s.number;
    Navigator = Nav_GetNavigator(_RBP);
    __asm { vmovaps xmm7, [rsp+0D8h+var_48] }
    if ( Navigator )
    {
      m_pSpace = Navigator->m_pSpace;
      goto LABEL_9;
    }
  }
  m_pSpace = Nav_FindMostLikelySpace(&vectorValue, NAV_LAYER_HUMAN, NULL);
LABEL_9:
  if ( !m_pSpace )
  {
    v21 = vtos(&vectorValue);
    v22 = j_va("CreateNavRepulsor: unable to create repulsor in non-navigable space at %s.", v21);
    Scr_Error(COM_ERR_1509, scrContext, v22);
  }
  if ( v18 < Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, v18) == VAR_INTEGER )
    bBadplace = Scr_GetInt(scrContext, v18++) != 0;
  Scr_GetTeamFlags(&result, scrContext, v18);
  p_result = &result;
  while ( !p_result->array[0] )
  {
    ++v8;
    p_result = (bitarray<224> *)((char *)p_result + 4);
    if ( v8 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        _RAX = Com_TeamsSP_GetAllCombatTeamFlags();
      else
        _RAX = Com_TeamsMP_GetAllTeamFlags();
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rsp+0D8h+result.array], xmm0
        vmovsd  xmm1, qword ptr [rax+10h]
        vmovsd  qword ptr [rsp+0D8h+result.array+10h], xmm1
      }
      result.array[6] = _RAX->array[6];
      break;
    }
  }
  usageFlags = Nav_TranslateTeamFlagsToRepulsorUsageFlags(&result);
  __asm { vmovss  [rsp+0D8h+var_B8], xmm6 }
  v39 = Nav_CreateRepulsor(m_pSpace, &vectorValue, &vec3_origin, _ER13, v42, entNum, usageFlags, name, bBadplace);
  __asm { vmovaps xmm6, [rsp+0D8h+var_38] }
  if ( !v39 )
  {
    v41 = j_va("CreateNavRepulsor: unable to alloc repulsor.  Exceeded max (%d)?", 256i64);
    Scr_Error(COM_ERR_1510, scrContext, v41);
  }
}

/*
==============
Scr_DestroyNavLink
==============
*/
void Scr_DestroyNavLink(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const pathnode_t *Pathnode; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1505, scrContext, "DestroyNavLink( linkName ): invalid number of parameters.");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Nav_DestroyLinkByName(ConstString);
  }
  else
  {
    Pathnode = Scr_GetPathnode(scrContext, 0);
    Nav_DestroyLinkByNode(Pathnode);
  }
}

/*
==============
Scr_DestroyNavObstacle
==============
*/
void Scr_DestroyNavObstacle(scrContext_t *scrContext)
{
  unsigned int Int; 

  Int = Scr_GetInt(scrContext, 0);
  Nav_DestroyObstacleByID(Int);
}

/*
==============
Scr_DestroyNavRepulsor
==============
*/
void Scr_DestroyNavRepulsor(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  nav_repulsor_s *RepulsorByName; 
  gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    RepulsorByName = Nav_FindRepulsorByName(ConstString);
  }
  else
  {
    Entity = GScr_GetEntity(0);
    if ( !Entity )
      Scr_Error(COM_ERR_1511, scrContext, "DestroyNavRepulsor: Invalid entity.");
    RepulsorByName = Nav_FindRepulsorByEntNum(Entity->s.number);
  }
  if ( RepulsorByName )
    Nav_DestroyRepulsor(RepulsorByName);
}

/*
==============
Scr_DockMovingPlatform
==============
*/
void Scr_DockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  nav_resource_s *ResourceByEntNum; 
  const char *v6; 
  const char *v7; 
  nav_space_s *SpaceByEntity; 
  const char *v9; 
  nav_space_s *v10; 
  nav_space_s *v11; 
  const char *v12; 
  vec4_t quat; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1037, ASSERT_TYPE_ASSERT, "( pPlatform )", (const char *)&queryFormat, "pPlatform") )
    __debugbreak();
  v4 = NULL;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) == VAR_POINTER )
    v4 = GScr_GetEntity(0);
  ResourceByEntNum = Nav_GetResourceByEntNum(Entity->s.number);
  if ( !ResourceByEntNum )
  {
    v6 = j_va("DockMovingPlatform: No mesh found attached to entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1512, scrContext, v6);
  }
  if ( !ResourceByEntNum->bDockable )
  {
    v7 = j_va("DockMovingPlatform: Mesh attached to entity %d is not dockable.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1513, scrContext, v7);
  }
  if ( v4 )
  {
    SpaceByEntity = Nav_GetSpaceByEntity(v4);
    if ( !SpaceByEntity )
    {
      v9 = j_va("DockMovingPlatform: Unable to find navigational space associated with entity %d.", (unsigned int)v4->s.number);
      Scr_Error(COM_ERR_1514, scrContext, v9);
    }
  }
  else
  {
    SpaceByEntity = Nav_GetDefaultSpace();
  }
  v10 = Nav_GetSpaceByEntity(Entity);
  v11 = v10;
  if ( v10 )
  {
    if ( v10->numResources == 1 )
    {
      Nav_ClearSpace(v10, 0, SpaceByEntity);
      Nav_RemoveResourceFromSpace(v11, ResourceByEntNum);
      Nav_DestroySpace(v11);
    }
    else
    {
      Nav_RemoveResourceFromSpace(v10, ResourceByEntNum);
    }
  }
  else
  {
    v12 = j_va("DockMovingPlatform: Unable to find navigational space associated with entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1515, scrContext, v12);
  }
  if ( !SpaceByEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1080, ASSERT_TYPE_ASSERT, "( pSpace2 )", (const char *)&queryFormat, "pSpace2") )
    __debugbreak();
  AnglesToQuat(&Entity->r.currentAngles, &quat);
  Nav_AddResourceToOldSpace(SpaceByEntity, ResourceByEntNum, &Entity->r.currentOrigin, &quat, 0);
}

/*
==============
Scr_FindPath3D
==============
*/
void Scr_FindPath3D(scrContext_t *scrContext)
{
  nav_space_s *DefaultSpace; 
  bfx::PolylinePath3DRCPtr v3; 
  unsigned int v4; 
  __int64 v5; 
  vec3_t *p_outPath; 
  bfx::PolylinePath3DRCPtr result; 
  bfx::PolylinePath3DRCPtr v8; 
  __int64 v9; 
  vec3_t vectorValue; 
  vec3_t endPos; 
  vec3_t outPath; 

  v9 = -2i64;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  Nav_FindPath3D(&result, &vectorValue, &endPos);
  if ( !bfx::PolylinePath3DRCPtr::IsValid(&result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1312, ASSERT_TYPE_ASSERT, "( path.IsValid() )", (const char *)&queryFormat, "path.IsValid()") )
    __debugbreak();
  if ( bfx::PolylinePath3DRCPtr::GetNumSegments(&result) )
  {
    DefaultSpace = Nav_GetDefaultSpace();
    bfx::PolylinePath3DRCPtr::PolylinePath3DRCPtr(&v8, &result);
    v4 = Nav_Simplify3DPath(DefaultSpace, &vectorValue, v3, 128, &outPath);
    v5 = v4;
    if ( v4 - 1 > 0x7F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1326, ASSERT_TYPE_ASSERT, "( numPathPoints > 0 && numPathPoints <= cMaxPathPoints )", (const char *)&queryFormat, "numPathPoints > 0 && numPathPoints <= cMaxPathPoints") )
      __debugbreak();
    Scr_MakeArray(scrContext);
    if ( (int)v5 > 0 )
    {
      p_outPath = &outPath;
      do
      {
        Scr_AddVector(scrContext, p_outPath->v);
        Scr_AddArray(scrContext);
        ++p_outPath;
        --v5;
      }
      while ( v5 );
    }
  }
  bfx::PolylinePath3DRCPtr::~PolylinePath3DRCPtr(&result);
}

/*
==============
Scr_FindPath
==============
*/
void Scr_FindPath(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  AINavLayer layer; 
  nav_repulsor_s *RepulsorByEntNum; 
  nav_space_s *pSpace; 
  AINavigator *Navigator; 
  AINavLayer v11; 
  AINavigator2D *v12; 
  int Int; 
  unsigned int m_obstacleBlockageFlags; 
  int v19; 
  unsigned int m_linkUsageFlags; 
  bfx::PathSpec pathSpec; 
  vec3_t endPt; 
  vec3_t vectorValue; 

  __asm { vxorps  xmm0, xmm0, xmm0 }
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  __asm
  {
    vmovss  [rbp+57h+var_A0.m_pathSharingPenalty], xmm0
    vmovss  [rbp+57h+var_A0.m_maxPathSharingPenalty], xmm0
    vmovss  [rbp+57h+var_A0.m_maxSearchDist], xmm0
  }
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    layer = NAV_LAYER_HUMAN;
    RepulsorByEntNum = Nav_FindRepulsorByEntNum(Entity->s.number);
    if ( RepulsorByEntNum )
      pSpace = RepulsorByEntNum->pSpace;
    else
      pSpace = Nav_GetDefaultSpace();
  }
  else
  {
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
      Scr_Error(COM_ERR_1519, scrContext, "Unsupported ent type.  Currently supporting player, actor, and bot.");
    v11 = Nav_GetLayer(Navigator);
    pSpace = Navigator->m_pSpace;
    layer = v11;
    v12 = Navigator->Get2DNavigator(Navigator);
    if ( v12 )
    {
      _RAX = AINavigator2D::GetPathSpec(v12);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rbp+57h+var_A0.m_obstacleMode], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rbp+57h+var_A0.m_maxSearchDist], ymm1
        vmovups xmm0, xmmword ptr [rax+40h]
        vmovups xmmword ptr [rbp-9], xmm0
      }
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPt);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) == VAR_INTEGER )
  {
    Int = Scr_GetInt(scrContext, 2u);
    m_obstacleBlockageFlags = pathSpec.m_obstacleBlockageFlags;
    if ( Int > 0 )
      m_obstacleBlockageFlags = 0;
    pathSpec.m_obstacleBlockageFlags = m_obstacleBlockageFlags;
  }
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) == VAR_INTEGER )
  {
    v19 = Scr_GetInt(scrContext, 3u);
    m_linkUsageFlags = pathSpec.m_linkUsageFlags;
    if ( v19 > 0 )
      m_linkUsageFlags = 0;
    pathSpec.m_linkUsageFlags = m_linkUsageFlags;
  }
  Scr_FindPathInternal(scrContext, pSpace, &vectorValue, &endPt, layer, &pathSpec);
}

/*
==============
Scr_FindPathCustom
==============
*/
void Scr_FindPathCustom(scrContext_t *scrContext)
{
  AINavLayer layer; 
  int NumParam; 
  int Int; 
  unsigned int m_obstacleBlockageFlags; 
  int v8; 
  unsigned int m_linkUsageFlags; 
  scr_string_t ConstString; 
  nav_space_s *DefaultSpace; 
  vec3_t vectorValue; 
  bfx::PathSpec pathSpec; 
  vec3_t endPt; 

  __asm { vxorps  xmm0, xmm0, xmm0 }
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  layer = NAV_LAYER_HUMAN;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  __asm
  {
    vmovss  [rsp+0B8h+var_78.m_pathSharingPenalty], xmm0
    vmovss  [rsp+0B8h+var_78.m_maxPathSharingPenalty], xmm0
    vmovss  [rsp+0B8h+var_78.m_maxSearchDist], xmm0
  }
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPt);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) == VAR_INTEGER )
  {
    Int = Scr_GetInt(scrContext, 2u);
    m_obstacleBlockageFlags = pathSpec.m_obstacleBlockageFlags;
    if ( Int > 0 )
      m_obstacleBlockageFlags = 0;
    pathSpec.m_obstacleBlockageFlags = m_obstacleBlockageFlags;
  }
  if ( NumParam > 3 && Scr_GetType(scrContext, 3u) == VAR_INTEGER )
  {
    v8 = Scr_GetInt(scrContext, 3u);
    m_linkUsageFlags = pathSpec.m_linkUsageFlags;
    if ( v8 > 0 )
      m_linkUsageFlags = 0;
    pathSpec.m_linkUsageFlags = m_linkUsageFlags;
  }
  if ( NumParam > 4 && Scr_GetType(scrContext, 4u) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 4u);
    layer = (unsigned int)GetLayerFromName(scrContext, ConstString);
  }
  DefaultSpace = Nav_GetDefaultSpace();
  if ( NumParam > 5 && Scr_GetType(scrContext, 5u) == VAR_INTEGER && Scr_GetInt(scrContext, 5u) )
    DefaultSpace = Nav_FindMostLikelySpace(&vectorValue, layer, NULL);
  Scr_FindPathInternal(scrContext, DefaultSpace, &vectorValue, &endPt, layer, &pathSpec);
}

/*
==============
Scr_FindPathInternal
==============
*/
void Scr_FindPathInternal(scrContext_t *scrContext, nav_space_s *pSpace, const vec3_t *startPt, const vec3_t *endPt, AINavLayer layer, const bfx::PathSpec *pathSpec)
{
  int NumSegments; 
  const dvar_t *v11; 
  int v12; 
  bfx::SurfaceSegment *SurfaceSegment; 
  bfx::PolylinePathRCPtr v24; 
  unsigned int v25; 
  __int64 v26; 
  vec3_t *p_outPath; 
  bfx::PolylinePathRCPtr result; 
  __int64 v30; 
  vec3_t end; 
  vec3_t start; 
  vec3_t outPath; 

  v30 = -2i64;
  __asm { vmovaps [rsp+6D8h+var_58], xmm6 }
  Nav_FindPathCustom(&result, pSpace, startPt, endPt, layer, pathSpec->m_areaUsageFlags, pathSpec->m_linkUsageFlags, pathSpec->m_obstacleBlockageFlags);
  if ( !bfx::PolylinePathRCPtr::IsValid(&result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1133, ASSERT_TYPE_ASSERT, "( path.IsValid() )", (const char *)&queryFormat, "path.IsValid()") )
    __debugbreak();
  NumSegments = bfx::PolylinePathRCPtr::GetNumSegments(&result);
  if ( NumSegments )
  {
    v11 = DVARINT_ai_showPaths;
    if ( !DVARINT_ai_showPaths && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_showPaths") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    if ( v11->current.integer > 0 )
    {
      v12 = 0;
      if ( NumSegments > 0 )
      {
        __asm { vmovss  xmm6, cs:__real@40c00000 }
        do
        {
          if ( bfx::PolylinePathRCPtr::GetSegmentType(&result, v12) == SURFACE_SEGMENT )
          {
            SurfaceSegment = bfx::PolylinePathRCPtr::GetSurfaceSegment(&result, v12);
            _RAX = bfx::SurfaceSegment::GetStartPos(SurfaceSegment);
            __asm
            {
              vmovss  xmm2, dword ptr [rax+8]
              vmovss  xmm1, dword ptr [rax+4]
              vmovss  xmm0, dword ptr [rax]
              vmovss  dword ptr [rsp+6D8h+start], xmm0
              vmovss  dword ptr [rsp+6D8h+start+4], xmm1
              vmovss  dword ptr [rsp+6D8h+start+8], xmm2
            }
            _RAX = bfx::SurfaceSegment::GetEndPos(SurfaceSegment);
            __asm
            {
              vmovss  xmm2, dword ptr [rax+8]
              vmovss  xmm1, dword ptr [rax+4]
              vmovss  xmm0, dword ptr [rax]
              vmovss  dword ptr [rsp+6D8h+end], xmm0
              vmovss  dword ptr [rsp+6D8h+end+4], xmm1
              vmovss  dword ptr [rsp+6D8h+end+8], xmm2
            }
            G_DebugLineWithDuration(&start, &end, &colorBlue, 0, 60);
            __asm { vmovaps xmm1, xmm6; radius }
            G_DebugCircle(&end, *(float *)&_XMM1, &colorBlue, 0, 1, 60);
          }
          ++v12;
        }
        while ( v12 < NumSegments );
      }
    }
    bfx::PolylinePathRCPtr::PolylinePathRCPtr((bfx::PolylinePathRCPtr *)&end, &result);
    v25 = Nav_SimplifyPath(pSpace, startPt, v24, layer, pathSpec, 128, &outPath);
    v26 = v25;
    if ( v25 - 1 > 0x7F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1164, ASSERT_TYPE_ASSERT, "( numPathPoints > 0 && numPathPoints <= cMaxPathPoints )", (const char *)&queryFormat, "numPathPoints > 0 && numPathPoints <= cMaxPathPoints") )
      __debugbreak();
    Scr_MakeArray(scrContext);
    if ( (int)v26 > 0 )
    {
      p_outPath = &outPath;
      do
      {
        Scr_AddVector(scrContext, p_outPath->v);
        Scr_AddArray(scrContext);
        ++p_outPath;
        --v26;
      }
      while ( v26 );
    }
  }
  bfx::PolylinePathRCPtr::~PolylinePathRCPtr(&result);
  __asm { vmovaps xmm6, [rsp+6D8h+var_58] }
}

/*
==============
Scr_GetClosestPointOnNavmesh3d
==============
*/
void Scr_GetClosestPointOnNavmesh3d(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  nav_space_s *m_pSpace; 
  bfx::Path3DSpec pathSpec; 
  vec3_t vectorValue; 
  vec3_t outClosestPos; 

  if ( !Nav_AnyVolumesLoaded() )
    Scr_Error(COM_ERR_1526, scrContext, "GetClosestPointOnNavmesh3d can only be used when navmesh is loaded!");
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) > 1 && (Entity = GScr_GetEntity(1u), (Navigator = Nav_GetNavigator(Entity)) != NULL) )
    m_pSpace = Navigator->m_pSpace;
  else
    m_pSpace = Nav_GetDefaultSpace();
  __asm { vxorps  xmm0, xmm0, xmm0 }
  *(_QWORD *)&pathSpec.m_volumeUsageFlags = -1i64;
  __asm { vmovss  [rsp+68h+pathSpec.m_maxSearchDist], xmm0 }
  if ( !Nav3D_GetClosestPointOnMesh(m_pSpace, &pathSpec, &vectorValue, &outClosestPos) )
    Scr_Error(COM_ERR_1527, scrContext, "Either NavMesh is not loaded or no 3d volumes found!");
  Scr_AddVector(scrContext, outClosestPos.v);
}

/*
==============
Scr_GetClosestPointOnNavmesh
==============
*/
void Scr_GetClosestPointOnNavmesh(scrContext_t *scrContext)
{
  int NumParam; 
  char v6; 
  const AINavigator *Navigator; 
  AINavigator *v8; 
  AINavLayer Layer; 
  nav_space_s *m_pSpace; 
  AINavLayer LayerFromName; 
  AINavigator2D *v12; 
  scr_string_t ConstString; 
  unsigned int LayersLoaded; 
  const char *v19; 
  const char *v20; 
  bool v22; 
  vec3_t outClosestPos; 
  vec3_t vectorValue; 
  bfx::PathSpec pPathSpec; 
  vec3_t outUp; 

  __asm { vxorps  xmm0, xmm0, xmm0 }
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  _RSI = NULL;
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  __asm
  {
    vmovss  [rbp+57h+pPathSpec.m_pathSharingPenalty], xmm0
    vmovss  [rbp+57h+pPathSpec.m_maxPathSharingPenalty], xmm0
    vmovss  [rbp+57h+pPathSpec.m_maxSearchDist], xmm0
  }
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  if ( !Nav_MeshLoaded() )
    Scr_Error(COM_ERR_1524, scrContext, "GetClosestPointOnNavmesh can only be used when navmesh is loaded!");
  Scr_GetVector(scrContext, 0, &vectorValue);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    v6 = 1;
    if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
    {
      _RSI = GScr_GetEntity(1u);
      Navigator = Nav_GetNavigator(_RSI);
      v8 = (AINavigator *)Navigator;
      if ( Navigator )
      {
        Layer = Nav_GetLayer(Navigator);
        m_pSpace = v8->m_pSpace;
        LayerFromName = Layer;
        if ( NumParam > 3 )
        {
          if ( Scr_GetType(scrContext, 3u) )
          {
            if ( Scr_GetInt(scrContext, 3u) )
            {
              v12 = v8->Get2DNavigator(v8);
              if ( v12 )
              {
                _RAX = AINavigator2D::GetPathSpec(v12);
                __asm
                {
                  vmovups ymm0, ymmword ptr [rax]
                  vmovups ymmword ptr [rbp+57h+pPathSpec.m_obstacleMode], ymm0
                  vmovups ymm1, ymmword ptr [rax+20h]
                  vmovups ymmword ptr [rbp+57h+pPathSpec.m_maxSearchDist], ymm1
                  vmovups xmm0, xmmword ptr [rax+40h]
                  vmovups xmmword ptr [rbp+7], xmm0
                }
              }
            }
          }
        }
        goto LABEL_18;
      }
    }
  }
  else
  {
    v6 = 0;
  }
  LayerFromName = NAV_LAYER_HUMAN;
  if ( v6 )
  {
    if ( Scr_GetType(scrContext, 1u) == VAR_STRING )
    {
      ConstString = Scr_GetConstString(scrContext, 1u);
      LayerFromName = (unsigned int)GetLayerFromName(scrContext, ConstString);
      LayersLoaded = bfx::GetLayersLoaded();
      if ( !_bittest((const int *)&LayersLoaded, LayerFromName) )
      {
        v19 = SL_ConvertToString(ConstString);
        v20 = j_va("GetClosestPointOnNavmesh: No navmesh loaded in layer %s", v19);
        Scr_Error(COM_ERR_1525, scrContext, v20);
      }
    }
  }
  m_pSpace = Nav_GetDefaultSpace();
LABEL_18:
  if ( NumParam > 2 && Scr_GetInt(scrContext, 2u) )
  {
    if ( _RSI )
      __asm { vmovss  xmm2, dword ptr [rsi+10Ch] }
    else
      __asm { vmovss  xmm2, cs:__real@bf800000; radius }
    v22 = Nav_GetClosestVerticalPosInMostLikelySpace(&vectorValue, LayerFromName, *(float *)&_XMM2, &pPathSpec, &outClosestPos, NULL) == NULL;
  }
  else
  {
    Nav_GetSpaceUp(m_pSpace, &outUp);
    v22 = !Nav_GetClosestVerticalPos(&vectorValue, &outUp, LayerFromName, &m_pSpace->hSpace, &pPathSpec, &outClosestPos, NULL);
  }
  if ( !v22 )
    Scr_AddVector(scrContext, outClosestPos.v);
}

/*
==============
Scr_GetClosestReachablePointOnNavmesh
==============
*/
void Scr_GetClosestReachablePointOnNavmesh(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v5; 
  AINavigator_vtbl *v7; 
  __int64 v8; 
  float v9; 
  vec3_t vectorValue; 
  float value[4]; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_5789, scrContext, "GetClosestReachablePointOnNavmesh : invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v5 = j_va("GetClosestReachablePointOnNavmesh : Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_5790, scrContext, v5);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  __asm { vmovsd  xmm0, qword ptr [rsp+68h+vectorValue] }
  v9 = vectorValue.v[2];
  v7 = Navigator->__vftable;
  __asm { vmovsd  [rsp+68h+var_48], xmm0 }
  ((void (__fastcall *)(AINavigator *, __int64 *, float *))v7->GetClosestReachablePoint)(Navigator, &v8, value);
  Scr_AddVector(scrContext, value);
}

/*
==============
Scr_GetModifierLocationBetween
==============
*/
void Scr_GetModifierLocationBetween(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int v7; 
  nav_repulsor_s *RepulsorByEntNum; 
  nav_space_s *pSpace; 
  AINavigator *Navigator; 
  unsigned int ModifierFlagsFromString; 
  const char *String; 
  float layer; 
  bfx::PolylinePathRCPtr result; 
  __int64 v30; 
  vec3_t outEndPoint; 
  vec3_t outStartPoint; 
  float value[4]; 
  vec3_t goalPos; 
  vec3_t vectorValue; 
  char v36; 
  void *retaddr; 

  _RAX = &retaddr;
  v30 = -2i64;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    v7 = 0;
    RepulsorByEntNum = Nav_FindRepulsorByEntNum(Entity->s.number);
    if ( RepulsorByEntNum )
      pSpace = RepulsorByEntNum->pSpace;
    else
      pSpace = Nav_GetDefaultSpace();
  }
  else
  {
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
      Scr_Error(COM_ERR_1532, scrContext, "Unsupported ent type.  Currently supporting player, actor, scripted agents, and bot.");
    v7 = Nav_GetLayer(Navigator);
    pSpace = Navigator->m_pSpace;
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &goalPos);
  Nav_FindPath(&result, pSpace, &vectorValue, &goalPos, v7);
  if ( !bfx::PolylinePathRCPtr::IsValid(&result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1819, ASSERT_TYPE_ASSERT, "( path.IsValid() )", (const char *)&queryFormat, "path.IsValid()") )
    __debugbreak();
  if ( bfx::PolylinePathRCPtr::GetNumSegments(&result) )
  {
    ModifierFlagsFromString = -1;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    if ( Scr_GetNumParam(scrContext) >= 3 )
    {
      String = Scr_GetString(scrContext, 2u);
      ModifierFlagsFromString = NAV_GetModifierFlagsFromString(String);
    }
    if ( Scr_GetNumParam(scrContext) >= 4 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
      __asm { vmovaps xmm6, xmm0 }
    }
    __asm
    {
      vmovss  xmm1, cs:__real@7f7fffff
      vmovss  [rsp+0C8h+layer], xmm1
      vmovaps xmm3, xmm6; minCheckDist
    }
    if ( Nav_GetModifierLocationOnPath(&result, ModifierFlagsFromString, 0, *(float *)&_XMM3, layer, &outStartPoint, &outEndPoint) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+0C8h+var_78]
        vaddss  xmm1, xmm0, dword ptr [rsp+0C8h+var_68]
        vmovss  xmm3, cs:__real@3f000000
        vmulss  xmm1, xmm1, xmm3
        vmovss  [rsp+0C8h+value], xmm1
        vmovss  xmm0, dword ptr [rsp+0C8h+var_78+4]
        vaddss  xmm2, xmm0, dword ptr [rsp+0C8h+var_68+4]
        vmulss  xmm1, xmm2, xmm3
        vmovss  [rsp+0C8h+var_54], xmm1
        vmovss  xmm0, dword ptr [rsp+0C8h+var_78+8]
        vaddss  xmm2, xmm0, dword ptr [rsp+0C8h+var_68+8]
        vmulss  xmm1, xmm2, xmm3
        vmovss  [rsp+0C8h+var_50], xmm1
      }
      Scr_AddVector(scrContext, value);
    }
  }
  bfx::PolylinePathRCPtr::~PolylinePathRCPtr(&result);
  _R11 = &v36;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
Scr_GetModifierLocationOnPath
==============
*/
void Scr_GetModifierLocationOnPath(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int NumParam; 
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v9; 
  AINavigator2D *v10; 
  const char *v11; 
  unsigned int ModifierFlagsFromString; 
  unsigned int v14; 
  const char *String; 
  vec3_t outEndPoint; 
  vec3_t outStartPoint; 
  float value[4]; 

  __asm { vmovaps [rsp+98h+var_28], xmm6 }
  NumParam = Scr_GetNumParam(scrContext);
  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_1533, scrContext, "GetModifierLocationOnPath: invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v9 = j_va("GetModifierLocationOnPath: Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1534, scrContext, v9);
  }
  v10 = Navigator->Get2DNavigator(Navigator);
  if ( !v10 )
  {
    v11 = j_va("GetModifierLocationOnPath: Entity %d does not have a 2D navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1535, scrContext, v11);
  }
  ModifierFlagsFromString = -1;
  __asm { vmovss  xmm6, cs:__real@7f7fffff }
  v14 = NumParam - 1;
  if ( v14 )
  {
    if ( v14 != 1 )
      goto LABEL_11;
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
  }
  String = Scr_GetString(scrContext, 0);
  ModifierFlagsFromString = NAV_GetModifierFlagsFromString(String);
LABEL_11:
  __asm { vmovaps xmm2, xmm6; checkDist }
  if ( AINavigator2D::GetModifierLocationOnEntPath(v10, ModifierFlagsFromString, *(float *)&_XMM2, &outStartPoint, &outEndPoint) )
  {
    __asm
    {
      vmovss  xmm3, cs:__real@3f000000
      vmovss  xmm0, dword ptr [rsp+98h+outStartPoint]
      vaddss  xmm1, xmm0, dword ptr [rsp+98h+var_68]
      vmovss  xmm0, dword ptr [rsp+98h+var_68+4]
      vaddss  xmm2, xmm0, dword ptr [rsp+98h+outStartPoint+4]
      vmovss  xmm0, dword ptr [rsp+98h+var_68+8]
      vmulss  xmm1, xmm1, xmm3
      vmovss  [rsp+98h+value], xmm1
      vmulss  xmm1, xmm2, xmm3
      vaddss  xmm2, xmm0, dword ptr [rsp+98h+outStartPoint+8]
      vmovss  [rsp+98h+var_44], xmm1
      vmulss  xmm1, xmm2, xmm3
      vmovss  [rsp+98h+var_40], xmm1
    }
    Scr_AddVector(scrContext, value);
  }
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
}

/*
==============
Scr_GetNavPosition
==============
*/
void Scr_GetNavPosition(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  const AINavigator *Navigator; 
  const char *v5; 
  vec3_t outCurPos; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_1539, scrContext, "GetNavPosition: invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v5 = j_va("GetNavPosition: Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1540, scrContext, v5);
  }
  Nav_GetPos(Navigator, &outCurPos);
  Scr_AddVector(scrContext, outCurPos.v);
}

/*
==============
Scr_GetNavSpaceEnt
==============
*/
void Scr_GetNavSpaceEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v5; 
  nav_space_s *m_pSpace; 
  const char *v7; 
  int parentEntNum; 
  const char *v9; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_1528, scrContext, "GetNavSpaceEnt : invalid entity.");
  Navigator = Nav_GetNavigator(Entity);
  if ( !Navigator )
  {
    v5 = j_va("GetNavSpaceEnt : Entity %d does not have a navigator.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1529, scrContext, v5);
  }
  m_pSpace = Navigator->m_pSpace;
  if ( !m_pSpace )
  {
    v7 = j_va("GetNavSpaceEnt : Navigator (ent %d) is not in any space!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1530, scrContext, v7);
  }
  parentEntNum = m_pSpace->parentEntNum;
  if ( parentEntNum != 2047 )
  {
    if ( !G_IsEntityInUse(parentEntNum) )
    {
      v9 = j_va("GetNavSpaceEnt : Space has invalid parent ent %d.", (unsigned int)m_pSpace->parentEntNum);
      Scr_Error(COM_ERR_1531, scrContext, v9);
    }
    GScr_AddEntity(&g_entities[m_pSpace->parentEntNum]);
  }
}

/*
==============
Scr_GetRandomNavPoint
==============
*/

void __fastcall Scr_GetRandomNavPoint(scrContext_t *scrContext, double _XMM1_8)
{
  int v7; 
  nav_space_s *DefaultSpace; 
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v12; 
  AINavLayer Layer; 
  AINavigator2D *v14; 
  int KindaRandomReachablePoints; 
  bfx::PathSpec pathSpec; 
  vec3_t origin; 
  vec3_t outPoints; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-18h], xmm6 }
  Scr_GetVector(scrContext, 0, &origin);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  v7 = 0;
  __asm { vxorps  xmm1, xmm1, xmm1 }
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  __asm
  {
    vmovss  [rsp+0D8h+var_98.m_pathSharingPenalty], xmm1
    vmovss  [rsp+0D8h+var_98.m_maxPathSharingPenalty], xmm1
    vmovss  [rsp+0D8h+var_98.m_maxSearchDist], xmm1
  }
  DefaultSpace = Nav_GetDefaultSpace();
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
    {
      v12 = j_va("GetRandomNavPoint: Ref ent %d must have a navigator.", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_1520, scrContext, v12);
    }
    Layer = Nav_GetLayer(Navigator);
    DefaultSpace = Navigator->m_pSpace;
    v7 = Layer;
    v14 = Navigator->Get2DNavigator(Navigator);
    if ( v14 )
    {
      _RAX = AINavigator2D::GetPathSpec(v14);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+0D8h+var_98.m_obstacleMode], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+0D8h+var_98.m_maxSearchDist], ymm1
        vmovups xmm0, xmmword ptr [rax+40h]
        vmovups xmmword ptr [rsp+80h], xmm0
      }
    }
  }
  __asm { vmovaps xmm2, xmm6; radius }
  KindaRandomReachablePoints = Nav_GetKindaRandomReachablePoints(DefaultSpace, &origin, *(float *)&_XMM2, v7, &pathSpec, 1, &outPoints);
  __asm { vmovaps xmm6, [rsp+0D8h+var_18] }
  if ( KindaRandomReachablePoints )
    Scr_AddVector(scrContext, outPoints.v);
}

/*
==============
Scr_GetRandomNavPoints
==============
*/
void Scr_GetRandomNavPoints(scrContext_t *scrContext)
{
  int Int; 
  int numPoints; 
  const char *v8; 
  int v9; 
  nav_space_s *DefaultSpace; 
  int NumParam; 
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  const char *v15; 
  AINavLayer Layer; 
  AINavigator2D *v17; 
  unsigned int KindaRandomReachablePoints; 
  __int64 v25; 
  vec3_t *p_outPoints; 
  bfx::PathSpec pathSpec; 
  vec3_t origin; 
  vec3_t vectorValue; 
  vec3_t outPoints; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-28h], xmm6 }
  Scr_GetVector(scrContext, 0, &origin);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  Int = Scr_GetInt(scrContext, 2u);
  numPoints = Int;
  if ( Int > 64 )
  {
    v8 = j_va("GetRandomNavPoints: Can only find %d points at a time.  User requested %d.", 64i64, (unsigned int)Int);
    Scr_Error(COM_ERR_1521, scrContext, v8);
  }
  v9 = 0;
  __asm { vxorps  xmm0, xmm0, xmm0 }
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  __asm
  {
    vmovss  [rsp+3E8h+var_3A8.m_pathSharingPenalty], xmm0
    vmovss  [rsp+3E8h+var_3A8.m_maxPathSharingPenalty], xmm0
    vmovss  [rsp+3E8h+var_3A8.m_maxSearchDist], xmm0
  }
  DefaultSpace = Nav_GetDefaultSpace();
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
  {
    Entity = GScr_GetEntity(3u);
    Navigator = Nav_GetNavigator(Entity);
    if ( !Navigator )
    {
      v15 = j_va("GetRandomNavPoints: ref ent %d must have a navigator.", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_1522, scrContext, v15);
    }
    Layer = Nav_GetLayer(Navigator);
    DefaultSpace = Navigator->m_pSpace;
    v9 = Layer;
    v17 = Navigator->Get2DNavigator(Navigator);
    if ( v17 )
    {
      _RAX = AINavigator2D::GetPathSpec(v17);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+3E8h+var_3A8.m_obstacleMode], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+3E8h+var_3A8.m_maxSearchDist], ymm1
        vmovups xmm0, xmmword ptr [rax+40h]
        vmovups xmmword ptr [rsp+80h], xmm0
      }
    }
  }
  if ( NumParam > 4 )
  {
    if ( NumParam < 6 )
      Scr_Error(COM_ERR_1523, scrContext, "GetRandomNavPoints: origin2 must be accompanied by radius2.");
    Scr_GetVector(scrContext, 4u, &vectorValue);
    Scr_GetFloat(scrContext, 5u);
  }
  __asm { vmovaps xmm2, xmm6; radius }
  KindaRandomReachablePoints = Nav_GetKindaRandomReachablePoints(DefaultSpace, &origin, *(float *)&_XMM2, v9, &pathSpec, numPoints, &outPoints);
  __asm { vmovaps xmm6, [rsp+3E8h+var_28] }
  v25 = KindaRandomReachablePoints;
  if ( KindaRandomReachablePoints )
  {
    Scr_MakeArray(scrContext);
    if ( (int)v25 > 0 )
    {
      p_outPoints = &outPoints;
      do
      {
        Scr_AddVector(scrContext, p_outPoints->v);
        Scr_AddArray(scrContext);
        ++p_outPoints;
        --v25;
      }
      while ( v25 );
    }
  }
}

/*
==============
Scr_IsNavMeshLoaded
==============
*/
void Scr_IsNavMeshLoaded(scrContext_t *scrContext)
{
  if ( Nav_MeshLoaded() || Nav_MeshWillBeLoaded() )
    Scr_AddBool(scrContext, 1);
  else
    Scr_AddBool(scrContext, 0);
}

/*
==============
Scr_IsPointOnNavMesh3d
==============
*/
void Scr_IsPointOnNavMesh3d(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  AINavigator *Navigator; 
  nav_space_s *m_pSpace; 
  bool IsPointOnMesh; 
  bfx::Path3DSpec pPathSpec; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  *(_QWORD *)&pPathSpec.m_volumeUsageFlags = -1i64;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+58h+pPathSpec.m_maxSearchDist], xmm0
  }
  if ( (int)Scr_GetNumParam(scrContext) > 1 && (Entity = GScr_GetEntity(1u), (Navigator = Nav_GetNavigator(Entity)) != NULL) )
  {
    m_pSpace = Navigator->m_pSpace;
    _RAX = (__int64)Navigator->Get3DNavigator(Navigator);
    if ( _RAX )
    {
      __asm
      {
        vmovsd  xmm0, qword ptr [rax+0DCh]
        vmovsd  qword ptr [rsp+58h+pPathSpec.m_volumeUsageFlags], xmm0
      }
      pPathSpec.m_maxSearchDist = *(float *)(_RAX + 228);
    }
  }
  else
  {
    m_pSpace = Nav_GetDefaultSpace();
  }
  IsPointOnMesh = Nav3D_IsPointOnMesh(m_pSpace, &vectorValue, &pPathSpec);
  Scr_AddBool(scrContext, IsPointOnMesh);
}

/*
==============
Scr_IsPointOnNavMesh
==============
*/
void Scr_IsPointOnNavMesh(scrContext_t *scrContext)
{
  AINavLayer Layer; 
  int NumParam; 
  AINavigator *Navigator; 
  const gentity_s *Entity; 
  bool v7; 
  nav_space_s *m_pSpace; 
  AINavigator2D *v10; 
  bool IsPointOnMeshCustom; 
  bfx::PathSpec pPathSpec; 
  vec3_t vectorValue; 
  vec3_t outSnappedPos; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Layer = NAV_LAYER_HUMAN;
  NumParam = Scr_GetNumParam(scrContext);
  Navigator = NULL;
  if ( NumParam > 1 )
  {
    Entity = GScr_GetEntity(1u);
    Navigator = Nav_GetNavigator(Entity);
  }
  v7 = 0;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    v7 = Scr_GetInt(scrContext, 2u) != 0;
  __asm { vxorps  xmm0, xmm0, xmm0 }
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  __asm
  {
    vmovss  [rsp+0C8h+pPathSpec.m_pathSharingPenalty], xmm0
    vmovss  [rsp+0C8h+pPathSpec.m_maxPathSharingPenalty], xmm0
    vmovss  [rsp+0C8h+pPathSpec.m_maxSearchDist], xmm0
  }
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  if ( Navigator )
  {
    m_pSpace = Navigator->m_pSpace;
    Layer = Nav_GetLayer(Navigator);
    v10 = Navigator->Get2DNavigator(Navigator);
    if ( v7 && v10 )
    {
      _RAX = AINavigator2D::GetPathSpec(v10);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+0C8h+pPathSpec.m_obstacleMode], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+0C8h+pPathSpec.m_maxSearchDist], ymm1
        vmovups xmm0, xmmword ptr [rax+40h]
        vmovups xmmword ptr [rsp+70h], xmm0
      }
    }
  }
  else
  {
    m_pSpace = Nav_GetDefaultSpace();
  }
  IsPointOnMeshCustom = Nav_IsPointOnMeshCustom(m_pSpace, &vectorValue, Layer, &pPathSpec, &outSnappedPos);
  Scr_AddBool(scrContext, IsPointOnMeshCustom);
}

/*
==============
Scr_NavIsStraightLineReachable3D
==============
*/
void Scr_NavIsStraightLineReachable3D(scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  const gentity_s *Entity; 
  nav_space_s *DefaultSpace; 
  bool IsStraightLineReachable; 
  bfx::Path3DSpec pPathSpec; 
  vec3_t endPos; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  Navigator = NULL;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
  }
  DefaultSpace = Nav_GetDefaultSpace();
  if ( Navigator )
    DefaultSpace = Navigator->m_pSpace;
  *(_QWORD *)&pPathSpec.m_volumeUsageFlags = -1i64;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+68h+pPathSpec.m_maxSearchDist], xmm0
  }
  if ( Navigator )
  {
    _RAX = (__int64)Navigator->Get3DNavigator(Navigator);
    if ( _RAX )
    {
      __asm
      {
        vmovsd  xmm0, qword ptr [rax+0DCh]
        vmovsd  qword ptr [rsp+68h+pPathSpec.m_volumeUsageFlags], xmm0
      }
      pPathSpec.m_maxSearchDist = *(float *)(_RAX + 228);
    }
  }
  IsStraightLineReachable = Nav3D_IsStraightLineReachable(DefaultSpace, &vectorValue, &endPos, &pPathSpec);
  Scr_AddBool(scrContext, IsStraightLineReachable);
}

/*
==============
Scr_NavIsStraightLineReachable
==============
*/
void Scr_NavIsStraightLineReachable(scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  const gentity_s *Entity; 
  nav_space_s *DefaultSpace; 
  AINavLayer Layer; 
  AINavigator2D *v8; 
  bool IsStraightLineReachable; 
  bfx::PathSpec pPathSpec; 
  vec3_t vectorValue; 
  vec3_t startPos; 

  Scr_GetVector(scrContext, 0, &startPos);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Navigator = NULL;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
  }
  DefaultSpace = Nav_GetDefaultSpace();
  if ( Navigator )
  {
    DefaultSpace = Navigator->m_pSpace;
    Layer = Nav_GetLayer(Navigator);
  }
  else
  {
    Layer = NAV_LAYER_HUMAN;
  }
  __asm { vxorps  xmm0, xmm0, xmm0 }
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  __asm
  {
    vmovss  [rsp+0B8h+var_88.m_pathSharingPenalty], xmm0
    vmovss  [rsp+0B8h+var_88.m_maxPathSharingPenalty], xmm0
    vmovss  [rsp+0B8h+var_88.m_maxSearchDist], xmm0
  }
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  if ( Navigator )
  {
    v8 = Navigator->Get2DNavigator(Navigator);
    if ( v8 )
    {
      _RAX = AINavigator2D::GetPathSpec(v8);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+0B8h+var_88.m_obstacleMode], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+0B8h+var_88.m_maxSearchDist], ymm1
        vmovups xmm0, xmmword ptr [rax+40h]
        vmovups xmmword ptr [rsp+70h], xmm0
      }
    }
  }
  IsStraightLineReachable = Nav_IsStraightLineReachable(DefaultSpace, &startPos, &vectorValue, Layer, &pPathSpec);
  Scr_AddBool(scrContext, IsStraightLineReachable);
}

/*
==============
Scr_NavTrace3D
==============
*/
void Scr_NavTrace3D(scrContext_t *scrContext)
{
  bool v3; 
  nav_space_s *DefaultSpace; 
  bool v6; 
  bool v7; 
  char v20; 
  char v21; 
  bfx::Path3DSpec pathSpec; 
  vec3_t endPos; 
  vec3_t vectorValue; 
  nav_probe_results_3D_s pOutResults; 
  char v37; 

  __asm { vmovaps [rsp+0A8h+var_18], xmm6 }
  if ( !Nav_AnyVolumesLoaded() )
    Scr_Error(COM_ERR_1500, scrContext, "NavTrace3D: No nav volumes loaded!");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  v3 = Scr_GetNumParam(scrContext) >= 3 && Scr_GetInt(scrContext, 2u);
  DefaultSpace = Nav_GetDefaultSpace();
  *(_QWORD *)&pathSpec.m_volumeUsageFlags = -1i64;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rsp+0A8h+pathSpec.m_maxSearchDist], xmm6
  }
  v6 = Nav_Trace3D(DefaultSpace, &vectorValue, &endPos, &pathSpec, &pOutResults);
  v7 = v6;
  if ( v3 )
  {
    Scr_MakeArray(scrContext);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+0A8h+endPos]
      vsubss  xmm3, xmm0, dword ptr [rsp+0A8h+vectorValue]
      vmovss  xmm1, dword ptr [rsp+0A8h+endPos+4]
      vsubss  xmm2, xmm1, dword ptr [rsp+0A8h+vectorValue+4]
      vmovss  xmm0, dword ptr [rsp+0A8h+endPos+8]
      vsubss  xmm4, xmm0, dword ptr [rsp+0A8h+vectorValue+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm0
      vsqrtss xmm1, xmm2, xmm2
      vcomiss xmm1, xmm6
    }
    if ( v20 | v21 )
    {
      _EAX = 0;
      __asm { vmovd   xmm1, eax }
      _EAX = v7;
      __asm
      {
        vmovd   xmm0, eax
        vpcmpeqd xmm2, xmm0, xmm1
        vmovss  xmm1, cs:__real@3f800000
        vblendvps xmm1, xmm6, xmm1, xmm2; value
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, [rsp+0A8h+var_40.m_DistTraveled]
        vdivss  xmm1, xmm0, xmm1
      }
    }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
    Scr_AddArrayStringIndexed(scrContext, scr_const.fraction);
    Scr_AddVector(scrContext, pOutResults.m_EndPos.v);
    Scr_AddArrayStringIndexed(scrContext, scr_const.position);
    Scr_AddVector(scrContext, pOutResults.m_Normal.v);
    Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
  }
  else
  {
    Scr_AddBool(scrContext, v6);
  }
  _R11 = &v37;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
Scr_NavTrace
==============
*/
void Scr_NavTrace(scrContext_t *scrContext)
{
  int NumParam; 
  const AINavigator *Navigator; 
  const gentity_s *Entity; 
  bool v11; 
  nav_space_s *m_pSpace; 
  AINavigator2D *v14; 
  AINavLayer Layer; 
  bool v20; 
  bool v21; 
  bool v48; 
  bool v49; 
  bool v75; 
  int v97; 
  int v98; 
  int v99; 
  int v100; 
  int v101; 
  int v102; 
  int v103; 
  int v104; 
  int v105; 
  float value; 
  vec3_t vectorValue; 
  vec3_t endPos; 
  nav_probe_results_s pOutResults; 
  bfx::PathSpec pathSpec; 
  char v113; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &endPos);
  NumParam = Scr_GetNumParam(scrContext);
  _ER15 = 0;
  Navigator = NULL;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
  {
    Entity = GScr_GetEntity(2u);
    Navigator = Nav_GetNavigator(Entity);
  }
  v11 = NumParam > 3 && Scr_GetInt(scrContext, 3u) != 0;
  pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
  pathSpec.m_usePathSharingPenalty = 0;
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vmovss  [rbp+70h+var_B0.m_pathSharingPenalty], xmm7
    vmovss  [rbp+70h+var_B0.m_maxPathSharingPenalty], xmm7
    vmovss  [rbp+70h+var_B0.m_maxSearchDist], xmm7
  }
  bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
  pathSpec.m_snapMode = SNAP_CLOSEST;
  bfx::AreaHandle::AreaHandle(&pOutResults.m_hEndArea);
  if ( Navigator )
  {
    m_pSpace = Navigator->m_pSpace;
    v14 = Navigator->Get2DNavigator(Navigator);
    if ( v14 )
    {
      _RAX = AINavigator2D::GetPathSpec(v14);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rbp+70h+var_B0.m_obstacleMode], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rbp+70h+var_B0.m_maxSearchDist], ymm1
        vmovups xmm0, xmmword ptr [rax+40h]
        vmovups xmmword ptr [rbp+0], xmm0
      }
    }
    Layer = Nav_GetLayer(Navigator);
  }
  else
  {
    m_pSpace = Nav_GetDefaultSpace();
    Layer = NAV_LAYER_HUMAN;
  }
  v20 = Nav_Trace(m_pSpace, &vectorValue, &endPos, Layer, &pathSpec, &pOutResults);
  v21 = v20;
  if ( v11 )
  {
    Scr_MakeArray(scrContext);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+170h+endPos]
      vsubss  xmm3, xmm0, dword ptr [rsp+170h+vectorValue]
      vmovss  xmm1, dword ptr [rsp+170h+endPos+4]
      vsubss  xmm2, xmm1, dword ptr [rsp+170h+vectorValue+4]
      vmovss  xmm0, dword ptr [rsp+170h+endPos+8]
      vsubss  xmm4, xmm0, dword ptr [rsp+170h+vectorValue+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm0
      vsqrtss xmm1, xmm2, xmm2
      vmovss  xmm6, cs:__real@3f800000
      vcomiss xmm1, xmm7
    }
    if ( v48 || v49 )
    {
      __asm { vmovd   xmm1, r15d }
      _EAX = v21;
      __asm
      {
        vmovd   xmm0, eax
        vpcmpeqd xmm2, xmm0, xmm1
        vblendvps xmm0, xmm7, xmm6, xmm2
        vmovaps xmm1, xmm0; value
        vmovss  dword ptr [rsp+170h+var_140], xmm0
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, [rbp+70h+var_100.m_DistTraveled]
        vdivss  xmm1, xmm0, xmm1
      }
    }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
    Scr_AddArrayStringIndexed(scrContext, scr_const.fraction);
    Scr_AddVector(scrContext, pOutResults.m_EndPos.v);
    Scr_AddArrayStringIndexed(scrContext, scr_const.position);
    if ( v21 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+170h+var_100.m_edgeStartPos]
        vmovss  dword ptr [rsp+170h+var_140], xmm0
      }
      if ( (v97 & 0x7F800000) == 2139095040 )
        goto LABEL_20;
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+70h+var_100.m_edgeStartPos+4]
        vmovss  dword ptr [rsp+170h+var_140], xmm0
      }
      if ( (v98 & 0x7F800000) == 2139095040 )
        goto LABEL_20;
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+70h+var_100.m_edgeStartPos+8]
        vmovss  dword ptr [rsp+170h+var_140], xmm0
      }
      if ( (v99 & 0x7F800000) == 2139095040 )
LABEL_20:
        Scr_Error(COM_ERR_1497, scrContext, "NavTrace: edge start pos NAN");
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+70h+var_100.m_edgeEndPos]
        vmovss  dword ptr [rsp+170h+var_140], xmm0
      }
      if ( (v100 & 0x7F800000) == 2139095040 )
        goto LABEL_24;
      __asm
      {
        vmovss  xmm1, dword ptr [rbp+70h+var_100.m_edgeEndPos+4]
        vmovss  dword ptr [rsp+170h+var_140], xmm1
      }
      if ( (v101 & 0x7F800000) == 2139095040 )
        goto LABEL_24;
      __asm
      {
        vmovss  xmm2, dword ptr [rbp+70h+var_100.m_edgeEndPos+8]
        vmovss  dword ptr [rsp+170h+var_140], xmm2
      }
      v48 = (v102 & 0x7F800000u) < 0x7F800000;
      v49 = (v102 & 0x7F800000) == 2139095040;
      if ( (v102 & 0x7F800000) == 2139095040 )
      {
LABEL_24:
        Scr_Error(COM_ERR_1498, scrContext, "NavTrace: edge end pos NAN");
        __asm
        {
          vmovss  xmm2, dword ptr [rbp+70h+var_100.m_edgeEndPos+8]
          vmovss  xmm1, dword ptr [rbp+70h+var_100.m_edgeEndPos+4]
          vmovss  xmm0, dword ptr [rbp+70h+var_100.m_edgeEndPos]
        }
      }
      __asm
      {
        vsubss  xmm3, xmm0, dword ptr [rsp+170h+var_100.m_edgeStartPos]
        vsubss  xmm4, xmm1, dword ptr [rbp+70h+var_100.m_edgeStartPos+4]
        vsubss  xmm8, xmm2, dword ptr [rbp+70h+var_100.m_edgeStartPos+8]
        vmulss  xmm1, xmm4, xmm4
        vmulss  xmm0, xmm3, xmm3
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm8, xmm8
        vaddss  xmm5, xmm2, xmm1
        vcomiss xmm5, xmm7
      }
      if ( !v48 && !v49 )
      {
        __asm
        {
          vsqrtss xmm1, xmm5, xmm5
          vcmpless xmm0, xmm1, cs:__real@80000000
          vblendvps xmm1, xmm1, xmm6, xmm0
          vmovss  dword ptr [rsp+170h+var_140], xmm1
          vdivss  xmm0, xmm6, xmm1
          vmulss  xmm6, xmm3, xmm0
          vmulss  xmm5, xmm4, xmm0
          vmulss  xmm3, xmm8, xmm0
          vmulss  xmm1, xmm3, dword ptr [rbp+70h+var_100.m_areaNormal+4]
          vmulss  xmm0, xmm5, dword ptr [rbp+70h+var_100.m_areaNormal+8]
          vsubss  xmm9, xmm1, xmm0
          vmovss  [rsp+170h+value], xmm9
          vmulss  xmm2, xmm6, dword ptr [rbp+70h+var_100.m_areaNormal+8]
          vmulss  xmm0, xmm3, dword ptr [rbp+70h+var_100.m_areaNormal]
          vsubss  xmm8, xmm2, xmm0
          vmovss  [rsp+170h+var_12C], xmm8
          vmulss  xmm1, xmm5, dword ptr [rbp+70h+var_100.m_areaNormal]
          vmulss  xmm0, xmm6, dword ptr [rbp+70h+var_100.m_areaNormal+4]
          vsubss  xmm5, xmm1, xmm0
          vmovss  [rsp+170h+var_128], xmm5
          vmovss  dword ptr [rsp+170h+var_140], xmm9
        }
        if ( (v103 & 0x7F800000) == 2139095040 )
          goto LABEL_29;
        __asm { vmovss  dword ptr [rsp+170h+var_140], xmm8 }
        if ( (v104 & 0x7F800000) == 2139095040 )
          goto LABEL_29;
        __asm { vmovss  dword ptr [rsp+170h+var_140], xmm5 }
        v75 = (v105 & 0x7F800000u) < 0x7F800000;
        if ( (v105 & 0x7F800000) == 2139095040 )
        {
LABEL_29:
          Scr_Error(COM_ERR_1499, scrContext, "NavTrace: normal NAN");
          __asm
          {
            vmovss  xmm5, [rsp+170h+var_128]
            vmovss  xmm8, [rsp+170h+var_12C]
            vmovss  xmm9, [rsp+170h+value]
          }
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+170h+vectorValue]
          vsubss  xmm3, xmm0, dword ptr [rsp+170h+var_100.m_edgeStartPos]
          vmovss  xmm1, dword ptr [rsp+170h+vectorValue+4]
          vsubss  xmm2, xmm1, dword ptr [rbp+70h+var_100.m_edgeStartPos+4]
          vmovss  xmm0, dword ptr [rsp+170h+vectorValue+8]
          vsubss  xmm4, xmm0, dword ptr [rbp+70h+var_100.m_edgeStartPos+8]
          vmulss  xmm2, xmm8, xmm2
          vmulss  xmm1, xmm9, xmm3
          vaddss  xmm3, xmm2, xmm1
          vmulss  xmm0, xmm5, xmm4
          vaddss  xmm4, xmm3, xmm0
          vcomiss xmm4, xmm7
        }
        if ( v75 )
        {
          __asm
          {
            vmovss  xmm2, dword ptr cs:__xmm@80000000800000008000000080000000
            vxorps  xmm0, xmm9, xmm2
            vmovss  [rsp+170h+value], xmm0
            vxorps  xmm1, xmm8, xmm2
            vmovss  [rsp+170h+var_12C], xmm1
            vxorps  xmm0, xmm5, xmm2
            vmovss  [rsp+170h+var_128], xmm0
          }
        }
        Scr_AddVector(scrContext, &value);
        Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
      }
    }
  }
  else
  {
    Scr_AddBool(scrContext, v20);
  }
  bfx::AreaHandle::~AreaHandle(&pOutResults.m_hEndArea);
  _R11 = &v113;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
Scr_UndockMovingPlatform
==============
*/
void Scr_UndockMovingPlatform(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  nav_resource_s *ResourceByEntNum; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  nav_space_s *Space; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1104, ASSERT_TYPE_ASSERT, "( pPlatform )", (const char *)&queryFormat, "pPlatform") )
    __debugbreak();
  ResourceByEntNum = Nav_GetResourceByEntNum(Entity->s.number);
  if ( !ResourceByEntNum )
  {
    v5 = j_va("UndockMovingPlatform: Unable to find navmesh associated with platform entity %d.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1516, scrContext, v5);
  }
  if ( !ResourceByEntNum->bDockable )
  {
    v6 = j_va("UndockMovingPlatform: mesh associated with platform entity %d is not marked dockable.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1517, scrContext, v6);
  }
  if ( !ResourceByEntNum->pSpace && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\nav_scr.cpp", 1113, ASSERT_TYPE_ASSERT, "( pResource->pSpace )", (const char *)&queryFormat, "pResource->pSpace") )
    __debugbreak();
  if ( Nav_GetSpaceByEntNum(Entity->s.number) )
  {
    v7 = j_va("UndockMovingPlatform: space attached to ent %d already exists. Calling UndockMovingPlatform on something that is not currently docked?", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1518, scrContext, v7);
  }
  Nav_RemoveResourceFromSpace(ResourceByEntNum->pSpace, ResourceByEntNum);
  Space = Nav_CreateSpace(Entity->s.number);
  Nav_AddResourceToNewSpace(Space, ResourceByEntNum, &vec3_origin, &quat_identity, 0);
  Nav_UpdateSpace(Space);
  Nav_TransferObjsToSpace(Space);
}

