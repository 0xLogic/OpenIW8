/*
==============
CL_TransientsWorldMP_DrawOverlay
==============
*/

void __fastcall CL_TransientsWorldMP_DrawOverlay(LocalClientNum_t screenLocalClient)
{
  ?CL_TransientsWorldMP_DrawOverlay@@YAXW4LocalClientNum_t@@@Z(screenLocalClient);
}

/*
==============
CL_TransientsWorldMP_GetBudgetBytes
==============
*/

unsigned __int64 __fastcall CL_TransientsWorldMP_GetBudgetBytes()
{
  return ?CL_TransientsWorldMP_GetBudgetBytes@@YA_KXZ();
}

/*
==============
CL_TransientsWorldMP_SoakTestUpdate
==============
*/

void CL_TransientsWorldMP_SoakTestUpdate(void)
{
  ?CL_TransientsWorldMP_SoakTestUpdate@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnPlayAgainRestart
==============
*/

void CL_TransientsWorldMP_OnPlayAgainRestart(void)
{
  ?CL_TransientsWorldMP_OnPlayAgainRestart@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnLevelLoad
==============
*/

void CL_TransientsWorldMP_OnLevelLoad(void)
{
  ?CL_TransientsWorldMP_OnLevelLoad@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_IsLOD0
==============
*/

bool __fastcall CL_TransientsWorldMP_IsLOD0(unsigned int transientIndex)
{
  return ?CL_TransientsWorldMP_IsLOD0@@YA_NI@Z(transientIndex);
}

/*
==============
CL_TransientsWorldMP_OnLobbyToGameStart
==============
*/

void CL_TransientsWorldMP_OnLobbyToGameStart(void)
{
  ?CL_TransientsWorldMP_OnLobbyToGameStart@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadAllowed
==============
*/

void CL_TransientsWorldMP_OnLevelPreloadAllowed(void)
{
  ?CL_TransientsWorldMP_OnLevelPreloadAllowed@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance
==============
*/

bool __fastcall CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  return ?Advance@CL_TransientsWorldMP_TransientChangedVisibleIterator@@QEAA_NXZ(this);
}

/*
==============
CL_TransientsWorldMP_OnFirstSnapshot
==============
*/

void CL_TransientsWorldMP_OnFirstSnapshot(void)
{
  ?CL_TransientsWorldMP_OnFirstSnapshot@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_IsBRMode
==============
*/

bool __fastcall CL_TransientsWorldMP_IsBRMode()
{
  return ?CL_TransientsWorldMP_IsBRMode@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds
==============
*/

const Bounds *__fastcall CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  return ?GetCurrentBounds@CL_TransientsWorldMP_TransientChangedVisibleIterator@@QEAAAEBUBounds@@XZ(this);
}

/*
==============
CL_TransientsWorldMP_ErrorCleanup
==============
*/

void CL_TransientsWorldMP_ErrorCleanup(void)
{
  ?CL_TransientsWorldMP_ErrorCleanup@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_SetGridStreamingClientStreamViews
==============
*/

void __fastcall CL_TransientsWorldMP_SetGridStreamingClientStreamViews(LocalClientNum_t localClientNum)
{
  ?CL_TransientsWorldMP_SetGridStreamingClientStreamViews@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadCancel
==============
*/

void CL_TransientsWorldMP_OnLevelPreloadCancel(void)
{
  ?CL_TransientsWorldMP_OnLevelPreloadCancel@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnServerShutdown
==============
*/

void CL_TransientsWorldMP_OnServerShutdown(void)
{
  ?CL_TransientsWorldMP_OnServerShutdown@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_AnyTilesVisibleAtLOD
==============
*/

bool __fastcall CL_TransientsWorldMP_AnyTilesVisibleAtLOD(const LocalClientNum_t localClientNum, const unsigned int lodLevel)
{
  return ?CL_TransientsWorldMP_AnyTilesVisibleAtLOD@@YA_NW4LocalClientNum_t@@I@Z(localClientNum, lodLevel);
}

/*
==============
CL_TransientsWorldMP_AddLobbyStreamPositions
==============
*/

void __fastcall CL_TransientsWorldMP_AddLobbyStreamPositions(const vec3_t *pos)
{
  ?CL_TransientsWorldMP_AddLobbyStreamPositions@@YAXAEBTvec3_t@@@Z(pos);
}

/*
==============
CL_TransientsWorldMP_DrawBounds
==============
*/

void CL_TransientsWorldMP_DrawBounds(void)
{
  ?CL_TransientsWorldMP_DrawBounds@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_RegisterFileIndex
==============
*/

void __fastcall CL_TransientsWorldMP_RegisterFileIndex(unsigned __int16 mpSystemFileIndex, const char *name)
{
  ?CL_TransientsWorldMP_RegisterFileIndex@@YAXGPEBD@Z(mpSystemFileIndex, name);
}

/*
==============
CL_TransientsWorldMP_GetLODFileCount
==============
*/

unsigned int __fastcall CL_TransientsWorldMP_GetLODFileCount(unsigned int lodLevel)
{
  return ?CL_TransientsWorldMP_GetLODFileCount@@YAII@Z(lodLevel);
}

/*
==============
CL_TransientsWorldMP_BeginListenServerStall
==============
*/

void CL_TransientsWorldMP_BeginListenServerStall(void)
{
  ?CL_TransientsWorldMP_BeginListenServerStall@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_IsZoomLoadActive
==============
*/

bool __fastcall CL_TransientsWorldMP_IsZoomLoadActive(const LocalClientNum_t localClientNum)
{
  return ?CL_TransientsWorldMP_IsZoomLoadActive@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CL_TransientsWorldMP_ResetLobbyStreamPositions
==============
*/

void CL_TransientsWorldMP_ResetLobbyStreamPositions(void)
{
  ?CL_TransientsWorldMP_ResetLobbyStreamPositions@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_DrawPriorityGraph
==============
*/

void __fastcall CL_TransientsWorldMP_DrawPriorityGraph(const LocalClientNum_t screenLocalClient)
{
  ?CL_TransientsWorldMP_DrawPriorityGraph@@YAXW4LocalClientNum_t@@@Z(screenLocalClient);
}

/*
==============
CL_TransientsWorldMP_ProcessFastfiles
==============
*/

void CL_TransientsWorldMP_ProcessFastfiles(void)
{
  ?CL_TransientsWorldMP_ProcessFastfiles@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Init
==============
*/

void __fastcall CL_TransientsWorldMP_TransientChangedVisibleIterator::Init(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  ?Init@CL_TransientsWorldMP_TransientChangedVisibleIterator@@QEAAXXZ(this);
}

/*
==============
CL_TransientsWorldMP_HasLobbyStreamPositions
==============
*/

bool __fastcall CL_TransientsWorldMP_HasLobbyStreamPositions()
{
  return ?CL_TransientsWorldMP_HasLobbyStreamPositions@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_UpdateMissingModels
==============
*/

void CL_TransientsWorldMP_UpdateMissingModels(void)
{
  ?CL_TransientsWorldMP_UpdateMissingModels@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_GetChangeVisible
==============
*/

const bitarray<1536> *__fastcall CL_TransientsWorldMP_GetChangeVisible()
{
  return ?CL_TransientsWorldMP_GetChangeVisible@@YAPEBV?$bitarray@$0GAA@@@XZ();
}

/*
==============
CL_TransientsWorldMP_UseLowAlwaysloadedFlagging
==============
*/

bool __fastcall CL_TransientsWorldMP_UseLowAlwaysloadedFlagging()
{
  return ?CL_TransientsWorldMP_UseLowAlwaysloadedFlagging@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_AnyMissingModels
==============
*/

bool __fastcall CL_TransientsWorldMP_AnyMissingModels()
{
  return ?CL_TransientsWorldMP_AnyMissingModels@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_UpdateIgnoreTransientSkip
==============
*/

void CL_TransientsWorldMP_UpdateIgnoreTransientSkip(void)
{
  ?CL_TransientsWorldMP_UpdateIgnoreTransientSkip@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_HasGridStreamingCompletedForPosition
==============
*/

bool __fastcall CL_TransientsWorldMP_HasGridStreamingCompletedForPosition(const LocalClientNum_t localClientNum, const vec3_t *pos)
{
  return ?CL_TransientsWorldMP_HasGridStreamingCompletedForPosition@@YA_NW4LocalClientNum_t@@AEBTvec3_t@@@Z(localClientNum, pos);
}

/*
==============
CL_TransientsWorldMP_OnLevelUnload
==============
*/

void CL_TransientsWorldMP_OnLevelUnload(void)
{
  ?CL_TransientsWorldMP_OnLevelUnload@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles
==============
*/

void __fastcall CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles(const char *name, const TransientInfo *transientInfo)
{
  ?CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles@@YAXPEBDPEBUTransientInfo@@@Z(name, transientInfo);
}

/*
==============
InterleavedPriorities::GetPriority
==============
*/

unsigned __int16 __fastcall InterleavedPriorities::GetPriority(InterleavedPriorities *this, const unsigned __int64 tileIndex, const unsigned __int16 lod1Index, const bool insideLod0Cell)
{
  return ?GetPriority@InterleavedPriorities@@QEAAG_KG_N@Z(this, tileIndex, lod1Index, insideLod0Cell);
}

/*
==============
CL_TransientsWorldMP_UnregisterGridStreamingInfo
==============
*/

void __fastcall CL_TransientsWorldMP_UnregisterGridStreamingInfo(const TransientInfo *transientInfo)
{
  ?CL_TransientsWorldMP_UnregisterGridStreamingInfo@@YAXPEBUTransientInfo@@@Z(transientInfo);
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfo
==============
*/

void __fastcall CL_TransientsWorldMP_RegisterGridStreamingInfo(const char *name, const TransientInfo *transientInfo)
{
  ?CL_TransientsWorldMP_RegisterGridStreamingInfo@@YAXPEBDPEBUTransientInfo@@@Z(name, transientInfo);
}

/*
==============
CL_TransientsWorldMP_ResetGridStreaming
==============
*/

void __fastcall CL_TransientsWorldMP_ResetGridStreaming(bool useSplitscreenRadius)
{
  ?CL_TransientsWorldMP_ResetGridStreaming@@YAX_N@Z(useSplitscreenRadius);
}

/*
==============
CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading
==============
*/

void CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading(void)
{
  ?CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_GetXB3BudgetBytes
==============
*/

unsigned __int64 __fastcall CL_TransientsWorldMP_GetXB3BudgetBytes()
{
  return ?CL_TransientsWorldMP_GetXB3BudgetBytes@@YA_KXZ();
}

/*
==============
CL_TransientsWorldMP_GetLobbyStreamPositions
==============
*/

unsigned int __fastcall CL_TransientsWorldMP_GetLobbyStreamPositions(vec3_t *outPos, unsigned int outPosSize)
{
  return ?CL_TransientsWorldMP_GetLobbyStreamPositions@@YAIPEATvec3_t@@I@Z(outPos, outPosSize);
}

/*
==============
CL_TransientsWorldMP_IsActive
==============
*/

bool __fastcall CL_TransientsWorldMP_IsActive()
{
  return ?CL_TransientsWorldMP_IsActive@@YA_NXZ();
}

/*
==============
CL_TransientsWorldMP_GetMemoryMaxMB
==============
*/

__int64 __fastcall CL_TransientsWorldMP_GetMemoryMaxMB(WorldStreamingQuality qualityLevel)
{
  return ?CL_TransientsWorldMP_GetMemoryMaxMB@@YA_JW4WorldStreamingQuality@@@Z(qualityLevel);
}

/*
==============
InterleavedPriorities::Insert
==============
*/

unsigned __int16 __fastcall InterleavedPriorities::Insert(InterleavedPriorities *this, const unsigned int trIndex, const bool insideCell)
{
  return ?Insert@InterleavedPriorities@@QEAAGI_N@Z(this, trIndex, insideCell);
}

/*
==============
CL_TransientsWorldMP_EndListenServerStall
==============
*/

void CL_TransientsWorldMP_EndListenServerStall(void)
{
  ?CL_TransientsWorldMP_EndListenServerStall@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_OnFrontendPreload
==============
*/

void CL_TransientsWorldMP_OnFrontendPreload(void)
{
  ?CL_TransientsWorldMP_OnFrontendPreload@@YAXXZ();
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance
==============
*/
bool CL_TransientsWorldMP_TransientChangedVisibleIterator::Advance(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  unsigned int m_currentBits; 
  unsigned int m_wordCount; 
  __int64 v4; 
  unsigned int v5; 
  unsigned int v6; 
  bool result; 

  m_currentBits = this->m_currentBits;
  if ( !m_currentBits )
  {
    m_wordCount = this->m_wordCount;
    LODWORD(v4) = this->m_wordIndex;
    do
    {
      v4 = (unsigned int)(v4 + 1);
      if ( (unsigned int)v4 >= m_wordCount )
        break;
      this->m_wordIndex = v4;
      m_currentBits = s_transientsWorldMP.changedVisible.array[v4];
      this->m_currentBits = m_currentBits;
    }
    while ( !m_currentBits );
    if ( !m_currentBits )
      return 0;
  }
  v5 = __lzcnt(m_currentBits);
  this->m_currentTransientIndex = v5 + 32 * this->m_wordIndex;
  v6 = m_currentBits & ~(0x80000000 >> (v5 & 0x1F));
  result = 1;
  this->m_currentBits = v6;
  return result;
}

/*
==============
CL_TransientsWorldMPValidateVisibilityState
==============
*/
char CL_TransientsWorldMPValidateVisibilityState()
{
  bitarray<1536> *visibleTarget; 
  __int64 v1; 
  unsigned int v2; 
  unsigned int v3; 
  bitarray<1536> *v4; 
  unsigned int v5; 
  bitarray<1536> *v6; 
  unsigned int v7; 
  bitarray<1536> *v8; 
  unsigned int v9; 
  bitarray<1536> *p_changedVisible; 
  bitarray<1536> *p_wantVisibleButNotLoaded; 

  visibleTarget = s_transientsWorldMP.visibleTarget;
  v1 = 2i64;
  v2 = 0;
  do
  {
    v3 = 0;
    v4 = visibleTarget - 2;
    while ( !v4->array[0] )
    {
      ++v3;
      v4 = (bitarray<1536> *)((char *)v4 + 4);
      if ( v3 >= 0x30 )
        goto LABEL_8;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1864, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.visibleCurrent[i].anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.visibleCurrent[i].anyBitsOn()") )
      __debugbreak();
LABEL_8:
    v5 = 0;
    v6 = visibleTarget;
    while ( !v6->array[0] )
    {
      ++v5;
      v6 = (bitarray<1536> *)((char *)v6 + 4);
      if ( v5 >= 0x30 )
        goto LABEL_14;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1865, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.visibleTarget[i].anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.visibleTarget[i].anyBitsOn()") )
      __debugbreak();
LABEL_14:
    v7 = 0;
    v8 = visibleTarget + 2;
    while ( !v8->array[0] )
    {
      ++v7;
      v8 = (bitarray<1536> *)((char *)v8 + 4);
      if ( v7 >= 0x30 )
        goto LABEL_20;
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1866, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.visibleHint[i].anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.visibleHint[i].anyBitsOn()") )
      __debugbreak();
LABEL_20:
    ++visibleTarget;
    --v1;
  }
  while ( v1 );
  v9 = 0;
  p_changedVisible = &s_transientsWorldMP.changedVisible;
  while ( !p_changedVisible->array[0] )
  {
    ++v9;
    p_changedVisible = (bitarray<1536> *)((char *)p_changedVisible + 4);
    if ( v9 >= 0x30 )
      goto LABEL_27;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1868, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.changedVisible.anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.changedVisible.anyBitsOn()") )
    __debugbreak();
LABEL_27:
  p_wantVisibleButNotLoaded = &s_transientsWorldMP.wantVisibleButNotLoaded;
  while ( !p_wantVisibleButNotLoaded->array[0] )
  {
    ++v2;
    p_wantVisibleButNotLoaded = (bitarray<1536> *)((char *)p_wantVisibleButNotLoaded + 4);
    if ( v2 >= 0x30 )
      return (char)p_wantVisibleButNotLoaded;
  }
  LOBYTE(p_wantVisibleButNotLoaded) = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1870, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.wantVisibleButNotLoaded.anyBitsOn())", (const char *)&queryFormat, "!s_transientsWorldMP.wantVisibleButNotLoaded.anyBitsOn()");
  if ( (_BYTE)p_wantVisibleButNotLoaded )
    __debugbreak();
  return (char)p_wantVisibleButNotLoaded;
}

/*
==============
CL_TransientsWorldMP_AddGridStreamingPosInternal
==============
*/
__int64 CL_TransientsWorldMP_AddGridStreamingPosInternal(const LocalClientNum_t localClientNum, const vec3_t *pos, const vec3_t *angles, const bool streamRender, const vec3_t *velocity, const bool mainCamera, const bool nextCamera, const float loadDist)
{
  __int64 numStreamPositions; 
  __int128 v13; 
  WorldStreamPosition *v15; 
  float v16; 
  __int64 v20; 
  const dvar_t *v21; 
  WorldStreamPosition *v22; 
  unsigned int localClientIndex; 
  bool v24; 
  __int64 v26; 
  __int64 v27; 

  if ( s_transientsWorldMP.numStreamPositions >= 0xE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3300, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.numStreamPositions ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "s_transientsWorldMP.numStreamPositions doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", s_transientsWorldMP.numStreamPositions, 14) )
    __debugbreak();
  if ( mainCamera && mainCamera == nextCamera && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3302, ASSERT_TYPE_ASSERT, "( (!mainCamera && !nextCamera) || (mainCamera != nextCamera) )", "Can't have both 'main' and 'next' cameras set") )
    __debugbreak();
  numStreamPositions = s_transientsWorldMP.numStreamPositions;
  v13 = LODWORD(loadDist);
  *(float *)&v13 = loadDist * loadDist;
  _XMM2 = v13 ^ _xmm;
  ++s_transientsWorldMP.numStreamPositions;
  v15 = &s_transientsWorldMP.streamPositions[numStreamPositions];
  *(double *)v15->pos.v = *(double *)pos->v;
  v15->pos.v[2] = pos->v[2];
  *(double *)v15->angles.v = *(double *)angles->v;
  v16 = angles->v[2];
  _XMM0 = 0i64;
  __asm
  {
    vcmpless xmm1, xmm0, xmm1
    vblendvps xmm1, xmm2, xmm3, xmm1
  }
  v15->loadDistLimitSq = *(float *)&_XMM1;
  v15->angles.v[2] = v16;
  v15->streamRender = streamRender;
  v15->mainCamera = mainCamera;
  v15->nextCamera = nextCamera;
  v15->localClientIndex = localClientNum;
  v15->fallingHint = 0;
  CL_TransientsWorldMP_FillGridStreamingPosViewInfo(localClientNum, streamRender, mainCamera, v15);
  if ( localClientNum == LOCAL_CLIENT_0 && mainCamera )
    s_transientsWorldMP.lastVelocityClient0 = *velocity;
  v20 = s_transientsWorldMP.numStreamPositions;
  if ( s_transientsWorldMP.numStreamPositions >= 0xE )
  {
    LODWORD(v27) = 14;
    LODWORD(v26) = s_transientsWorldMP.numStreamPositions;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3327, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.numStreamPositions ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "s_transientsWorldMP.numStreamPositions doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", v26, v27) )
      __debugbreak();
    v20 = s_transientsWorldMP.numStreamPositions;
  }
  v21 = DVARBOOL_cl_transientWorldStreamLookAheadEnabled;
  v22 = &s_transientsWorldMP.streamPositions[v20];
  if ( !DVARBOOL_cl_transientWorldStreamLookAheadEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v21);
  if ( v21->current.enabled )
  {
    localClientIndex = v15->localClientIndex;
    if ( localClientIndex >= 2 )
    {
      LODWORD(v27) = 2;
      LODWORD(v26) = v15->localClientIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1193, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v26, v27) )
        __debugbreak();
    }
    if ( (int)localClientIndex < cg_t::ms_allocatedCount )
    {
      v24 = v15->nextCamera;
      if ( v15->mainCamera )
      {
        if ( v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1087, ASSERT_TYPE_ASSERT, "( !playerPos.nextCamera )", "Shouldn't be both main and next cameras") )
          __debugbreak();
        if ( !v15->streamRender || v15->zoomLoad || !CL_TransientsWorldMP_AddVelocityHintPos_Internal(&s_transientsWorldMP.streamPositions[numStreamPositions], v22, velocity, 1) )
          return (unsigned int)numStreamPositions;
      }
      else if ( !v24 || !CL_TransientsWorldMP_AddVelocityHintPos_Internal(&s_transientsWorldMP.streamPositions[numStreamPositions], v22, velocity, 0) )
      {
        return (unsigned int)numStreamPositions;
      }
      ++s_transientsWorldMP.numStreamPositions;
    }
  }
  return (unsigned int)numStreamPositions;
}

/*
==============
CL_TransientsWorldMP_AddLobbyStreamPositions
==============
*/
void CL_TransientsWorldMP_AddLobbyStreamPositions(const vec3_t *pos)
{
  __int64 lobbyStreamPosCount; 
  __int64 v3; 

  lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
  if ( s_transientsWorldMP.lobbyStreamPosCount >= 2 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3431, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.lobbyStreamPosCount ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lobbyStreamPos ) ) + 0 ) )", "s_transientsWorldMP.lobbyStreamPosCount doesn't index ARRAY_COUNT( s_transientsWorldMP.lobbyStreamPos )\n\t%i not in [0, %i)", s_transientsWorldMP.lobbyStreamPosCount, 2) )
      __debugbreak();
    lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
  }
  v3 = lobbyStreamPosCount;
  *(double *)s_transientsWorldMP.lobbyStreamPos[v3].v = *(double *)pos->v;
  s_transientsWorldMP.lobbyStreamPos[v3].v[2] = pos->v[2];
  ++s_transientsWorldMP.lobbyStreamPosCount;
}

/*
==============
CL_TransientsWorldMP_AddVelocityHintPos_Internal
==============
*/
char CL_TransientsWorldMP_AddVelocityHintPos_Internal(WorldStreamPosition *playerPos, WorldStreamPosition *outHintPos, const vec3_t *velocity, const bool mainCamera)
{
  const dvar_t *v4; 
  float v7; 
  float v8; 
  __int128 v9; 
  float value; 
  const dvar_t *v11; 
  float v12; 
  float v13; 
  float v14; 
  __int128 v15; 
  const dvar_t *v16; 
  const dvar_t *v17; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  __m256i v25; 
  int v26; 
  __m256i v27; 
  __m256i v28; 
  vec4_t v29; 
  double v30; 
  _BYTE v32[128]; 
  vec4_t v33; 
  double v34; 
  int v35; 

  v4 = DVARFLT_cl_transientWorldStreamLookAheadTime;
  v7 = velocity->v[2];
  v8 = velocity->v[0];
  v9 = LODWORD(velocity->v[1]);
  if ( !DVARFLT_cl_transientWorldStreamLookAheadTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  value = v4->current.value;
  v11 = DVARFLT_cl_transientWorldStreamLookAheadMinDist;
  v15 = v9;
  v12 = *(float *)&v9 * value;
  v13 = v7 * value;
  v14 = v8 * value;
  *(float *)&v15 = (float)((float)(v12 * v12) + (float)(v14 * v14)) + (float)(v13 * v13);
  if ( !DVARFLT_cl_transientWorldStreamLookAheadMinDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMinDist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  if ( *(float *)&v15 <= (float)(v11->current.value * v11->current.value) )
    return 0;
  v16 = DVARFLT_cl_transientWorldStreamLookAheadMaxDist;
  if ( !DVARFLT_cl_transientWorldStreamLookAheadMaxDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMaxDist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v16);
  if ( *(float *)&v15 > (float)(v16->current.value * v16->current.value) )
  {
    v17 = DVARFLT_cl_transientWorldStreamLookAheadMaxDist;
    *(float *)&v15 = fsqrt(*(float *)&v15);
    _XMM2 = v15;
    __asm
    {
      vcmpless xmm0, xmm2, cs:__real@80000000
      vblendvps xmm0, xmm2, xmm1, xmm0
    }
    v21 = v14 * (float)(1.0 / *(float *)&_XMM0);
    v22 = v12 * (float)(1.0 / *(float *)&_XMM0);
    v23 = v13 * (float)(1.0 / *(float *)&_XMM0);
    if ( !DVARFLT_cl_transientWorldStreamLookAheadMaxDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMaxDist") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v17);
    v24 = v17->current.value;
    v14 = v21 * v24;
    v12 = v22 * v24;
    v13 = v23 * v24;
  }
  memset_0(v32, 0, 0x9Cui64);
  v25 = *(__m256i *)&v32[32];
  v26 = v35;
  *(__m256i *)outHintPos->pos.v = *(__m256i *)v32;
  v27 = *(__m256i *)&v32[64];
  *(__m256i *)outHintPos->viewDir3D.v = v25;
  v28 = *(__m256i *)&v32[96];
  *(__m256i *)outHintPos->frustumPlanes[0].v = v27;
  v29 = v33;
  *(__m256i *)outHintPos->frustumPlanes[2].v = v28;
  v30 = v34;
  outHintPos->frustumPlanes[4] = v29;
  *(double *)&outHintPos->loadDistLimitSq = v30;
  *(_DWORD *)&outHintPos->zoomLoad = v26;
  outHintPos->pos.v[0] = v14 + playerPos->pos.v[0];
  outHintPos->pos.v[1] = v12 + playerPos->pos.v[1];
  outHintPos->pos.v[2] = v13 + playerPos->pos.v[2];
  outHintPos->loadDistLimitSq = playerPos->loadDistLimitSq;
  return 1;
}

/*
==============
CL_TransientsWorldMP_AnyMissingModels
==============
*/
_BOOL8 CL_TransientsWorldMP_AnyMissingModels()
{
  return s_transientsWorldMP.anyMissingModels;
}

/*
==============
CL_TransientsWorldMP_AnyTilesVisibleAtLOD
==============
*/
char CL_TransientsWorldMP_AnyTilesVisibleAtLOD(const LocalClientNum_t localClientNum, const unsigned int lodLevel)
{
  __int64 v2; 
  bitarray<1536> *v4; 
  unsigned int v5; 
  unsigned int v6; 
  const unsigned __int16 *HighLODLookups; 
  unsigned int v8; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  v2 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3772, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
      __debugbreak();
    LODWORD(v13) = 2;
    LODWORD(v11) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3773, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.visibleCurrent ) ) + 0 ) )", "localClientNum doesn't index s_transientsWorldMP.visibleCurrent\n\t%i not in [0, %i)", v11, v13) )
      __debugbreak();
  }
  if ( lodLevel >= 2 )
  {
    LODWORD(v12) = 2;
    LODWORD(v10) = lodLevel;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3774, ASSERT_TYPE_ASSERT, "(unsigned)( lodLevel ) < (unsigned)( CL_TRANSIENT_WORLD_LOD_LEVELS )", "lodLevel doesn't index CL_TRANSIENT_WORLD_LOD_LEVELS\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  v4 = &s_transientsWorldMP.visibleCurrent[v2];
  v5 = 1;
  v6 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  if ( v6 <= 1 )
    return 0;
  while ( 1 )
  {
    HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v5);
    v8 = lodLevel ? HighLODLookups[lodLevel - 1] : v5;
    if ( v8 >= 0x600 )
    {
      LODWORD(v12) = 1536;
      LODWORD(v10) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v10, v12) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v8 & 0x1F)) & v4->array[(unsigned __int64)v8 >> 5]) != 0 )
      break;
    if ( ++v5 >= v6 )
      return 0;
  }
  return 1;
}

/*
==============
CL_TransientsWorldMP_AreAllRequestedZonesNearPositionLoaded
==============
*/
char CL_TransientsWorldMP_AreAllRequestedZonesNearPositionLoaded(const LocalClientNum_t localClientNum, const vec3_t *visPos)
{
  signed __int64 v2; 
  __int128 v3; 
  void *v4; 
  unsigned __int64 v5; 
  bool v6; 
  const vec3_t *v7; 
  __int64 v8; 
  float v9; 
  const dvar_t *v10; 
  float v11; 
  const dvar_t *v12; 
  __int128 v14; 
  const dvar_t *v16; 
  TransientWorldStreamSyncDrawRequest *v17; 
  int integer; 
  int v19; 
  __int128 v20; 
  SpatialPartition_Tree *transientWorldGridSpatial; 
  float v22; 
  float v23; 
  unsigned int v24; 
  unsigned int v25; 
  unsigned int v26; 
  Bounds *transientWorldGridBounds; 
  float v28; 
  const unsigned __int16 *HighLODLookups; 
  float *v30; 
  unsigned int v31; 
  const dvar_t *v32; 
  unsigned int v33; 
  unsigned __int64 v34; 
  unsigned int v35; 
  __int64 v37; 
  __int64 v38; 
  __int64 v39; 
  char v40[4464]; 

  v4 = alloca(v2);
  v5 = (unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64;
  *(_QWORD *)(v5 + 4448) = (unsigned __int64)&v37 ^ _security_cookie;
  v6 = s_transientsWorldMP.worldGridInfo == NULL;
  v7 = visPos;
  *(_QWORD *)v5 = visPos;
  v8 = localClientNum;
  if ( v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3507, ASSERT_TYPE_ASSERT, "(CL_TransientsWorldMP_IsActive())", (const char *)&queryFormat, "CL_TransientsWorldMP_IsActive()") )
    __debugbreak();
  v9 = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(0) * s_transientsWorldMP.radiusMultiplier;
  *(float *)&v3 = CL_TransientsWorldMP_GetVisibilityRadius(1u, v7);
  v10 = DCONST_DVARFLT_cl_transientWorldStreamSyncRadiusMulLv0;
  if ( !DCONST_DVARFLT_cl_transientWorldStreamSyncRadiusMulLv0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamSyncRadiusMulLv0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  v11 = v9 * v10->current.value;
  v12 = DCONST_DVARFLT_cl_transientWorldStreamSyncRadiusMulLv1;
  *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = v11;
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamSyncRadiusMulLv1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  v14 = v3;
  *(float *)&v14 = *(float *)&v3 * v12->current.value;
  _XMM0 = v14;
  __asm { vmaxss  xmm1, xmm0, xmm6 }
  *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x3C) = *(float *)&_XMM1;
  CL_TransientsWorldMP_GetWorldStreamParamsInternal((WorldStreamParameters *)(v5 + 48), v7);
  if ( (unsigned int)v8 >= 2 )
  {
    LODWORD(v39) = 2;
    LODWORD(v38) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3512, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamSyncDraw ) ) + 0 ) )", "localClientNum doesn't index s_transientsWorldMP.streamSyncDraw\n\t%i not in [0, %i)", v38, v39) )
      __debugbreak();
  }
  v16 = DCONST_DVARINT_cl_transientWorldOverlayStreamSyncTimeout;
  v17 = &s_transientsWorldMP.streamSyncDraw[v8];
  if ( !DCONST_DVARINT_cl_transientWorldOverlayStreamSyncTimeout && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayStreamSyncTimeout") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v16);
  integer = v16->current.integer;
  v19 = Sys_Milliseconds();
  v20 = *(_OWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50);
  *(__m256i *)v17->params.visZMultipliers = *(__m256i *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30);
  *(_OWORD *)&v17->params.visHintRadius[1] = v20;
  v17->requestEndTime = integer + v19;
  v17->params.visRadiusMaxSq = *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60);
  v17->pos.v[0] = v7->v[0];
  v17->pos.v[1] = v7->v[1];
  v17->pos.v[2] = v7->v[2];
  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3519, ASSERT_TYPE_ASSERT, "( ( s_transientsWorldMP.worldGridInfo != nullptr ) )", "( s_transientsWorldMP.worldGridInfo ) = %p", NULL) )
    __debugbreak();
  transientWorldGridSpatial = s_transientsWorldMP.worldGridInfo->transientWorldGridSpatial;
  if ( !transientWorldGridSpatial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3521, ASSERT_TYPE_ASSERT, "( ( spatial != nullptr ) )", "( spatial ) = %p", NULL) )
    __debugbreak();
  v22 = *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x5C);
  *(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x140) = 0i64;
  *(_DWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x148) = 0;
  *(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) = 0i64;
  *(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) = 0i64;
  SpatialPartition_Tree_SphereIterator::Init((SpatialPartition_Tree_SphereIterator *)(v5 + 128), transientWorldGridSpatial, v7, v22);
  if ( !SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(v5 + 128)) )
    return 1;
  v23 = *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60);
  while ( 1 )
  {
    if ( !*(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 16, ASSERT_TYPE_ASSERT, "(m_spatialTree)", (const char *)&queryFormat, "m_spatialTree") )
      __debugbreak();
    v24 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) + 20i64);
    v25 = *(_DWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x148);
    if ( v25 == v24 )
    {
      if ( !*(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 19, ASSERT_TYPE_ASSERT, "(m_currentNode)", (const char *)&queryFormat, "m_currentNode") )
        __debugbreak();
      if ( (**(_BYTE **)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 20, ASSERT_TYPE_ASSERT, "(m_currentNode->containsLeaves)", (const char *)&queryFormat, "m_currentNode->containsLeaves") )
        __debugbreak();
      if ( *(_DWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x140) >= **(unsigned __int8 **)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) >> 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 21, ASSERT_TYPE_ASSERT, "(m_leafIndex < m_currentNode->childCount)", (const char *)&queryFormat, "m_leafIndex < m_currentNode->childCount") )
        __debugbreak();
      v26 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x158) + 4i64 * *(unsigned int *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x140) + 4);
    }
    else
    {
      if ( v25 >= v24 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 26, ASSERT_TYPE_ASSERT, "(m_alwaysIndex < m_spatialTree->alwaysListLength)", (const char *)&queryFormat, "m_alwaysIndex < m_spatialTree->alwaysListLength") )
          __debugbreak();
        v25 = *(_DWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x148);
      }
      v26 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x150) + 8i64) + 4i64 * v25);
    }
    if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3528, ASSERT_TYPE_ASSERT, "(baseTransientIndex > 0)", (const char *)&queryFormat, "baseTransientIndex > 0") )
      __debugbreak();
    if ( v26 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
    {
      LODWORD(v39) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
      LODWORD(v38) = v26;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3529, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "baseTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v38, v39) )
        __debugbreak();
    }
    transientWorldGridBounds = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
    *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = transientWorldGridBounds[v26].midPoint.v[0] - transientWorldGridBounds[v26].halfSize.v[0];
    *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1C) = transientWorldGridBounds[v26].midPoint.v[1] - transientWorldGridBounds[v26].halfSize.v[1];
    *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = transientWorldGridBounds[v26].midPoint.v[2] - transientWorldGridBounds[v26].halfSize.v[2];
    *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24) = transientWorldGridBounds[v26].midPoint.v[0] + transientWorldGridBounds[v26].halfSize.v[0];
    *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = transientWorldGridBounds[v26].halfSize.v[1] + transientWorldGridBounds[v26].midPoint.v[1];
    *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x2C) = transientWorldGridBounds[v26].halfSize.v[2] + transientWorldGridBounds[v26].midPoint.v[2];
    PointToClosestAABBPoint((const vec3_t *)(v5 + 24), (const vec3_t *)(v5 + 36), v7, (vec3_t *)(v5 + 8));
    v28 = (float)((float)(*(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 8) * *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 8)) + (float)(*(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) * *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC))) + (float)(*(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) * *(float *)(((unsigned __int64)v40 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
    if ( v28 <= v23 )
      break;
LABEL_70:
    if ( !SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(v5 + 128)) )
      return 1;
  }
  HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v26);
  v30 = (float *)(v5 + 64);
  v31 = 0;
  while ( 1 )
  {
    v32 = DCONST_DVARINT_cl_transientWorldLimitVisibleLOD;
    if ( !DCONST_DVARINT_cl_transientWorldLimitVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLimitVisibleLOD") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v32);
    if ( (signed int)v31 >= v32->current.integer && v28 <= *v30 )
    {
      if ( v31 )
        v33 = HighLODLookups[v31 - 1];
      else
        v33 = v26;
      if ( v33 >= 0x600 )
      {
        LODWORD(v39) = 1536;
        LODWORD(v38) = v33;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v38, v39) )
          __debugbreak();
      }
      v34 = (unsigned __int64)v33 >> 5;
      v35 = 0x80000000 >> (v33 & 0x1F);
      if ( (v35 & s_transientsWorldMP.requested.array[v34]) != 0 )
        break;
    }
    ++v31;
    ++v30;
    if ( v31 >= 2 )
      goto LABEL_69;
  }
  if ( v33 >= 0x600 )
  {
    LODWORD(v39) = 1536;
    LODWORD(v38) = v33;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v38, v39) )
      __debugbreak();
  }
  if ( (v35 & s_transientsWorldMP.loaded.array[v34]) != 0 )
  {
LABEL_69:
    v7 = *(const vec3_t **)v5;
    goto LABEL_70;
  }
  return 0;
}

/*
==============
CL_TransientsWorldMP_BeginListenServerStall
==============
*/
void CL_TransientsWorldMP_BeginListenServerStall(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3743, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_CancelInFlightLoads();
  if ( s_transientsWorldMP.listenServerStall && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3748, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.listenServerStall)", (const char *)&queryFormat, "!s_transientsWorldMP.listenServerStall") )
    __debugbreak();
  s_transientsWorldMP.listenServerStall = 1;
}

/*
==============
CL_TransientsWorldMP_CalcLoadPriorityDistance
==============
*/
float CL_TransientsWorldMP_CalcLoadPriorityDistance(const WorldStreamPosition *worldStreamPos, float distSqXY, float distZ, const unsigned int lod, const Bounds *bounds, const float cellSize, const bool useZoomedDistances, const bool isStreamingHint, const bool lod0Missing, const float viewDot, const float cellExteriorAddition, const float lod0VisRadiusSq, const float lod1FalloffDistSq, const bool lod1BoostBRMethod)
{
  float v16; 
  float v17; 
  float v18; 
  double Float_Internal_DebugName; 
  float v21; 
  __int128 v22; 
  float v23; 
  __int128 v24; 
  const dvar_t *v27; 
  float v28; 
  const dvar_t *v29; 
  float v30; 
  const dvar_t *v31; 
  float v32; 
  float value; 
  const dvar_t *v34; 
  float v35; 
  const dvar_t *v36; 
  float v37; 
  float v38; 
  const dvar_t *v39; 
  float v40; 
  double v41; 
  double v42; 

  v16 = distZ;
  v17 = distSqXY;
  if ( distSqXY == 0.0 && distZ == 0.0 )
  {
    if ( !lod )
    {
      v18 = bounds->midPoint.v[1] - worldStreamPos->pos.v[1];
      return (float)(v18 * v18) + (float)((float)(bounds->midPoint.v[0] - worldStreamPos->pos.v[0]) * (float)(bounds->midPoint.v[0] - worldStreamPos->pos.v[0]));
    }
    if ( !isStreamingHint && !lod0Missing )
    {
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_cl_transientWorldOnTopOfHighLODFactor, "cl_transientWorldOnTopOfHighLODFactor");
      v17 = distSqXY + (float)((float)(*(float *)&Float_Internal_DebugName * cellSize) * (float)(*(float *)&Float_Internal_DebugName * cellSize));
    }
  }
  v21 = cellExteriorAddition;
  if ( !lod )
  {
    v31 = DVARFLT_cl_transientWorldLoadZLOD0AdjustEndZ;
    v32 = worldStreamPos->pos.v[2];
    if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustEndZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustEndZ") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v31);
    value = v31->current.value;
    v34 = DVARFLT_cl_transientWorldLoadZLOD0AdjustStartZ;
    if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustStartZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustStartZ") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v34);
    v35 = LinearRamp(v32, v34->current.value, value);
    if ( v35 > 0.0 )
    {
      v36 = DVARFLT_cl_transientWorldLoadZLOD0AdjustEndDist;
      v37 = fsqrt((float)(distZ * distZ) + v17);
      if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustEndDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustEndDist") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v36);
      v38 = v36->current.value;
      v39 = DVARFLT_cl_transientWorldLoadZLOD0AdjustStartDist;
      if ( !DVARFLT_cl_transientWorldLoadZLOD0AdjustStartDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadZLOD0AdjustStartDist") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v39);
      v40 = LinearRamp(v37, v39->current.value, v38);
      if ( v40 > 0.0 )
      {
        v41 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldLoadZLOD0AdjustMaxAddition, "cl_transientWorldLoadZLOD0AdjustMaxAddition");
        v21 = (float)((float)((float)(*(float *)&v41 * *(float *)&v41) * v35) * v40) + cellExteriorAddition;
      }
    }
    if ( !useZoomedDistances )
      return (float)((float)(v16 * v16) + v17) + v21;
    v28 = lod0VisRadiusSq;
    if ( v17 <= lod0VisRadiusSq || v17 >= (float)(worldStreamPos->zoomLODDist[0] * worldStreamPos->zoomLODDist[0]) )
      return (float)((float)(v16 * v16) + v17) + v21;
    goto LABEL_50;
  }
  if ( lod != 1 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1013, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Bad LOD %d", lod) )
      __debugbreak();
    return (float)((float)(v16 * v16) + v17) + v21;
  }
  if ( !useZoomedDistances && !isStreamingHint )
  {
    v22 = LODWORD(worldStreamPos->pos.v[2]);
    v23 = CL_TransientsWorldMP_CalcViewDotBoostInAir(*(const float *)&v22, worldStreamPos->viewDir3D.v[2], v17, viewDot);
    if ( v23 > 0.0 )
    {
      if ( lod1BoostBRMethod )
      {
        *(double *)&v22 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirBRDistance, "cl_transientWorldLoadXYLOD1BoostInAirBRDistance");
        v24 = v22;
        *(float *)&v24 = (float)(*(float *)&v22 * *(float *)&v22) * v23;
        _XMM2 = v24;
        __asm { vminss  xmm3, xmm2, xmm9 }
        v21 = cellExteriorAddition - *(float *)&_XMM3;
      }
      else
      {
        v17 = v17 * (float)(1.0 - v23);
        v16 = distZ * (float)(1.0 - v23);
      }
    }
  }
  if ( v17 > lod1FalloffDistSq )
  {
    v27 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffMultiplier;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1FalloffMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v27);
    v21 = v21 + (float)((float)(v17 - lod1FalloffDistSq) * v27->current.value);
  }
  v28 = lod0VisRadiusSq;
  if ( useZoomedDistances )
  {
    if ( v17 <= lod0VisRadiusSq )
      return (float)((float)(v16 * v16) + v17) + v21;
    if ( v17 > (float)(worldStreamPos->zoomLODDist[0] * worldStreamPos->zoomLODDist[0]) && v17 < (float)(worldStreamPos->zoomLODDist[1] * worldStreamPos->zoomLODDist[1]) )
    {
LABEL_50:
      v42 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldLoadXYMultiplierZoomLOD, "cl_transientWorldLoadXYMultiplierZoomLOD");
      v30 = *(float *)&v42 * (float)(v17 - v28);
LABEL_51:
      v17 = v30 + v28;
      return (float)((float)(v16 * v16) + v17) + v21;
    }
  }
  if ( v17 > lod0VisRadiusSq )
  {
    v29 = DCONST_DVARFLT_cl_transientWorldLoadXYMultiplierAddLOD1;
    if ( !DCONST_DVARFLT_cl_transientWorldLoadXYMultiplierAddLOD1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYMultiplierAddLOD1") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v29);
    v30 = (float)(v17 - lod0VisRadiusSq) * v29->current.value;
    goto LABEL_51;
  }
  return (float)((float)(v16 * v16) + v17) + v21;
}

/*
==============
CL_TransientsWorldMP_CalcViewDotBoostInAir
==============
*/

float __fastcall CL_TransientsWorldMP_CalcViewDotBoostInAir(double viewZPos, const float viewZDir, const float distSqXY, const float viewDot)
{
  const dvar_t *v4; 
  __int128 v6; 
  const dvar_t *v7; 
  float value; 
  const dvar_t *v9; 
  const dvar_t *v10; 
  float v11; 
  const dvar_t *v12; 
  float v13; 
  const dvar_t *v14; 
  __int128 v16; 
  float v17; 
  const dvar_t *v18; 
  float v19; 
  float v21; 
  const dvar_t *v22; 
  float v23; 
  const dvar_t *v24; 
  const dvar_t *v25; 
  __int128 v26; 
  const dvar_t *v27; 
  float v28; 
  const dvar_t *v29; 
  float v30; 
  const dvar_t *v31; 
  float v34; 
  const dvar_t *v35; 
  float v36; 
  const dvar_t *v37; 
  float v38; 
  const dvar_t *v39; 

  v4 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
  v6 = *(_OWORD *)&viewZPos;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( *(float *)&viewZPos <= v4->current.value )
    return 0.0;
  v7 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotEnd;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirDotEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  value = v7->current.value;
  v9 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirDotStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirDotStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  LinearRamp(viewDot, v9->current.value, value);
  v10 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistEnd;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirNearDistEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  v11 = v10->current.value;
  v12 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirNearDistStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirNearDistStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  v13 = LinearRampSq(distSqXY, v12->current.value, v11);
  v14 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistEnd;
  v16 = LODWORD(FLOAT_1_0);
  *(float *)&v16 = 1.0 - v13;
  _XMM8 = v16;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirFarDistEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  v17 = v14->current.value;
  v18 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirFarDistStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirFarDistStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v18);
  v19 = 1.0 - LinearRampSq(distSqXY, v18->current.value, v17);
  __asm { vmaxss  xmm0, xmm8, xmm9 }
  v21 = v19 * *(float *)&_XMM0;
  if ( (float)(v19 * *(float *)&_XMM0) <= 0.0 )
    return 0.0;
  v22 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v22);
  v23 = v22->current.value;
  v24 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v24);
  if ( v23 <= v24->current.value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 860, ASSERT_TYPE_ASSERT, "(Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd, \"cl_transientWorldLoadXYLOD1BoostInAirZEnd\" ) > Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart, \"cl_transientWorldLoadXYLOD1BoostInAirZStart\" ))", (const char *)&queryFormat, "Dconst_GetFloat( cl_transientWorldLoadXYLOD1BoostInAirZEnd ) > Dconst_GetFloat( cl_transientWorldLoadXYLOD1BoostInAirZStart )") )
    __debugbreak();
  v25 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v25);
  v26 = v6;
  *(float *)&v26 = *(float *)&v6 - v25->current.value;
  v27 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v27);
  v28 = v27->current.value;
  v29 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v29);
  v30 = v28 - v29->current.value;
  v31 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinishViewZ;
  *(float *)&v26 = *(float *)&v26 / v30;
  _XMM1 = v26;
  __asm { vminss  xmm8, xmm1, xmm11 }
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinishViewZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinishViewZ") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v31);
  v34 = v31->current.value;
  v35 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStartViewZ;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStartViewZ && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierStartViewZ") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v35);
  v36 = LinearRamp(viewZDir, v35->current.value, v34);
  v37 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinish;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinish && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierFinish") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v37);
  v38 = v37->current.value;
  v39 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStart;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1BoostInAirMultiplierStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirMultiplierStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v39);
  return (float)((float)((float)(1.0 - v36) * v39->current.value) + (float)(v38 * v36)) * (float)(*(float *)&_XMM8 * v21);
}

/*
==============
CL_TransientsWorldMP_CancelInFlightLoads
==============
*/
void CL_TransientsWorldMP_CancelInFlightLoads()
{
  unsigned int v0; 
  unsigned __int64 v1; 
  unsigned int v2; 
  unsigned __int64 v3; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3597, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  v0 = 0;
  v1 = 0i64;
  do
  {
    v2 = 0x80000000 >> (v0 & 0x1F);
    v3 = v1 >> 5;
    if ( (v2 & s_transientsWorldMP.loaded.array[v3]) == 0 && (v2 & s_transientsWorldMP.requested.array[v3]) != 0 )
    {
      CL_TransientsWorldMP_UnloadIndex(v0);
      if ( (v2 & s_transientsWorldMP.requested.array[v3]) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3605, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.requested.testBit( i ))", (const char *)&queryFormat, "!s_transientsWorldMP.requested.testBit( i )") )
        __debugbreak();
    }
    ++v0;
    ++v1;
  }
  while ( v0 < 0x600 );
}

/*
==============
CL_TransientsWorldMP_ClearLoadState
==============
*/
__int64 CL_TransientsWorldMP_ClearLoadState()
{
  __int64 v0; 
  bitarray<1536> *p_requested; 
  __int64 v2; 
  bitarray<1536> *p_loaded; 
  __int64 result; 

  v0 = 3i64;
  p_requested = &s_transientsWorldMP.requested;
  v2 = 3i64;
  do
  {
    *(_QWORD *)p_requested->array = 0i64;
    *(_QWORD *)&p_requested->array[2] = 0i64;
    *(_QWORD *)&p_requested->array[4] = 0i64;
    p_requested = (bitarray<1536> *)((char *)p_requested + 64);
    *(_QWORD *)&p_requested[-1].array[38] = 0i64;
    *(_QWORD *)&p_requested[-1].array[40] = 0i64;
    *(_QWORD *)&p_requested[-1].array[42] = 0i64;
    *(_QWORD *)&p_requested[-1].array[44] = 0i64;
    *(_QWORD *)&p_requested[-1].array[46] = 0i64;
    --v2;
  }
  while ( v2 );
  s_transientsWorldMP.requestedCount = 0;
  p_loaded = &s_transientsWorldMP.loaded;
  do
  {
    *(_QWORD *)p_loaded->array = 0i64;
    *(_QWORD *)&p_loaded->array[2] = 0i64;
    *(_QWORD *)&p_loaded->array[4] = 0i64;
    p_loaded = (bitarray<1536> *)((char *)p_loaded + 64);
    *(_QWORD *)&p_loaded[-1].array[38] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[40] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[42] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[44] = 0i64;
    *(_QWORD *)&p_loaded[-1].array[46] = 0i64;
    --v0;
  }
  while ( v0 );
  CL_TransientsWorldMP_ClearVisibilityState(0i64, 0i64, 0i64);
  TransientCostCalc_Reset(&s_transientsWorldMP.worldCost);
  result = 0i64;
  *(_DWORD *)&s_transientsWorldMP.lastFastfileState.backtoFE = 0;
  s_transientsWorldMP.lastFastfileState.inLobbyState = 0;
  return result;
}

/*
==============
CL_TransientsWorldMP_ClearVisibilityState
==============
*/
bitarray<1536> *CL_TransientsWorldMP_ClearVisibilityState()
{
  unsigned int *v0; 
  __int64 v1; 
  __int64 v2; 
  bitarray<1536> *p_changedVisible; 
  __int64 v4; 
  bitarray<1536> *result; 

  v0 = &s_transientsWorldMP.visibleCurrent[0].array[2];
  v1 = 2i64;
  do
  {
    *((_QWORD *)v0 - 1) = 0i64;
    *(_QWORD *)v0 = 0i64;
    *((_QWORD *)v0 + 1) = 0i64;
    *((_QWORD *)v0 + 2) = 0i64;
    *((_QWORD *)v0 + 3) = 0i64;
    *((_QWORD *)v0 + 4) = 0i64;
    *((_QWORD *)v0 + 5) = 0i64;
    *((_QWORD *)v0 + 6) = 0i64;
    *((_QWORD *)v0 + 7) = 0i64;
    *((_QWORD *)v0 + 8) = 0i64;
    *((_QWORD *)v0 + 9) = 0i64;
    *((_QWORD *)v0 + 10) = 0i64;
    *((_QWORD *)v0 + 11) = 0i64;
    *((_QWORD *)v0 + 12) = 0i64;
    *((_QWORD *)v0 + 13) = 0i64;
    *((_QWORD *)v0 + 14) = 0i64;
    *((_QWORD *)v0 + 15) = 0i64;
    *((_QWORD *)v0 + 16) = 0i64;
    *((_QWORD *)v0 + 17) = 0i64;
    *((_QWORD *)v0 + 18) = 0i64;
    *((_QWORD *)v0 + 19) = 0i64;
    *((_QWORD *)v0 + 20) = 0i64;
    *((_QWORD *)v0 + 21) = 0i64;
    *((_QWORD *)v0 + 22) = 0i64;
    *((_QWORD *)v0 + 47) = 0i64;
    *((_QWORD *)v0 + 48) = 0i64;
    *((_QWORD *)v0 + 49) = 0i64;
    *((_QWORD *)v0 + 50) = 0i64;
    *((_QWORD *)v0 + 51) = 0i64;
    *((_QWORD *)v0 + 52) = 0i64;
    *((_QWORD *)v0 + 53) = 0i64;
    *((_QWORD *)v0 + 54) = 0i64;
    *((_QWORD *)v0 + 55) = 0i64;
    *((_QWORD *)v0 + 56) = 0i64;
    *((_QWORD *)v0 + 57) = 0i64;
    *((_QWORD *)v0 + 58) = 0i64;
    *((_QWORD *)v0 + 59) = 0i64;
    *((_QWORD *)v0 + 60) = 0i64;
    *((_QWORD *)v0 + 61) = 0i64;
    *((_QWORD *)v0 + 62) = 0i64;
    *((_QWORD *)v0 + 63) = 0i64;
    *((_QWORD *)v0 + 64) = 0i64;
    *((_QWORD *)v0 + 65) = 0i64;
    *((_QWORD *)v0 + 66) = 0i64;
    *((_QWORD *)v0 + 67) = 0i64;
    *((_QWORD *)v0 + 68) = 0i64;
    *((_QWORD *)v0 + 69) = 0i64;
    *((_QWORD *)v0 + 70) = 0i64;
    *((_QWORD *)v0 + 95) = 0i64;
    *((_QWORD *)v0 + 96) = 0i64;
    *((_QWORD *)v0 + 97) = 0i64;
    *((_QWORD *)v0 + 98) = 0i64;
    *((_QWORD *)v0 + 99) = 0i64;
    *((_QWORD *)v0 + 100) = 0i64;
    *((_QWORD *)v0 + 101) = 0i64;
    *((_QWORD *)v0 + 102) = 0i64;
    *((_QWORD *)v0 + 103) = 0i64;
    *((_QWORD *)v0 + 104) = 0i64;
    *((_QWORD *)v0 + 105) = 0i64;
    *((_QWORD *)v0 + 106) = 0i64;
    *((_QWORD *)v0 + 107) = 0i64;
    *((_QWORD *)v0 + 108) = 0i64;
    *((_QWORD *)v0 + 109) = 0i64;
    *((_QWORD *)v0 + 110) = 0i64;
    *((_QWORD *)v0 + 111) = 0i64;
    *((_QWORD *)v0 + 112) = 0i64;
    *((_QWORD *)v0 + 113) = 0i64;
    *((_QWORD *)v0 + 114) = 0i64;
    *((_QWORD *)v0 + 115) = 0i64;
    *((_QWORD *)v0 + 116) = 0i64;
    *((_QWORD *)v0 + 117) = 0i64;
    *((_QWORD *)v0 + 118) = 0i64;
    v0 += 48;
    --v1;
  }
  while ( v1 );
  v2 = 3i64;
  p_changedVisible = &s_transientsWorldMP.changedVisible;
  v4 = 3i64;
  do
  {
    *(_QWORD *)p_changedVisible->array = 0i64;
    *(_QWORD *)&p_changedVisible->array[2] = 0i64;
    *(_QWORD *)&p_changedVisible->array[4] = 0i64;
    p_changedVisible = (bitarray<1536> *)((char *)p_changedVisible + 64);
    *(_QWORD *)&p_changedVisible[-1].array[38] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[40] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[42] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[44] = 0i64;
    *(_QWORD *)&p_changedVisible[-1].array[46] = 0i64;
    --v4;
  }
  while ( v4 );
  result = &s_transientsWorldMP.wantVisibleButNotLoaded;
  do
  {
    *(_QWORD *)result->array = 0i64;
    *(_QWORD *)&result->array[2] = 0i64;
    *(_QWORD *)&result->array[4] = 0i64;
    result = (bitarray<1536> *)((char *)result + 64);
    *(_QWORD *)&result[-1].array[38] = 0i64;
    *(_QWORD *)&result[-1].array[40] = 0i64;
    *(_QWORD *)&result[-1].array[42] = 0i64;
    *(_QWORD *)&result[-1].array[44] = 0i64;
    *(_QWORD *)&result[-1].array[46] = 0i64;
    --v2;
  }
  while ( v2 );
  return result;
}

/*
==============
CL_TransientsWorldMP_DrawBounds
==============
*/
void CL_TransientsWorldMP_DrawBounds(void)
{
  unsigned int v0; 
  unsigned __int64 v1; 
  __int64 v2; 
  vec4_t v3; 
  vec3_t origin; 
  vec4_t color; 

  v0 = 0;
  v1 = 0i64;
  v2 = 0i64;
  do
  {
    if ( ((0x80000000 >> (v0 & 0x1F)) & s_transientsWorldMP.transientsHighestLOD.array[v1 >> 5]) == 0 && v0 < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
    {
      v3 = CELL_STATE_COLORS[CL_TransientsWorldMP_GetCellState(v0)];
      *(_QWORD *)origin.v = 0i64;
      origin.v[2] = 0.0;
      color = v3;
      CG_DebugBox(&origin, &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v2], 0.0, &color, 0, 1);
    }
    ++v0;
    ++v1;
    ++v2;
  }
  while ( v0 < 0x600 );
}

/*
==============
CL_TransientsWorldMP_DrawCell
==============
*/
void CL_TransientsWorldMP_DrawCell(CL_DebugMapOverlay *context, const unsigned int gridX, const unsigned int gridY, const unsigned int tileMapIndex, const unsigned int numRequestedTiles)
{
  __int128 v5; 
  CL_DebugMapOverlay *v6; 
  __int64 v7; 
  __int64 v8; 
  unsigned int transientWorldGridTileMapCount; 
  __int64 v10; 
  TransientWorldGridTileMap *v11; 
  CL_DebugMapOverlay::ClipMode OverlayClipMode; 
  float cellSize; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  CL_DebugMapOverlay::ClipMode v18; 
  const dvar_t *v19; 
  float v20; 
  float v21; 
  unsigned int unsignedInt; 
  bool ShouldDrawCellIndexLabel; 
  float v24; 
  unsigned int v25; 
  float v26; 
  unsigned __int16 TransientIndex; 
  const dvar_t *v28; 
  const dvar_t *v29; 
  CellState CellState; 
  float v31; 
  unsigned int fileBackedTransientCount; 
  bool v33; 
  unsigned int v34; 
  const dvar_t *v35; 
  bool enabled; 
  int v37; 
  __int128 v38; 
  int v42; 
  float v43; 
  float v44; 
  __int64 v45; 
  float v46; 
  float v47; 
  float v48; 
  float v49; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  const dvar_t *v54; 
  float v55; 
  float v56; 
  CL_DebugMapOverlay::ClipMode v57; 
  const dvar_t *v58; 
  const Bounds *TileBounds; 
  float v60; 
  const dvar_t *v61; 
  const dvar_t *v62; 
  int CellDelayRemaining; 
  const dvar_t *v64; 
  int v65; 
  const unsigned __int16 *HighLODLookups; 
  const vec4_t *v67; 
  float v68; 
  float v69; 
  __int64 v70; 
  float v71; 
  __int64 clipMode; 
  __int64 clipModea; 
  __int64 clipModeb; 
  char *v75; 
  char *v76; 
  char *v77; 
  __int64 v78; 
  CL_DebugMapOverlay::ClipMode v79; 
  unsigned __int16 v80; 
  int outLodNumber; 
  unsigned int gridYa; 
  unsigned int gridXa; 
  CL_DebugMapOverlay *v84; 
  TransientWorldGridTileMap *tileMap; 
  vec2_t v86; 
  vec2_t pos2D; 
  vec4_t color; 
  vec2_t outMin2D; 
  vec3_t inMax3D; 
  vec2_t outMax2D; 
  vec3_t inMin3D; 
  vec2_t maxPos2D; 
  vec2_t minPos2D; 
  vec2_t v95; 
  vec2_t v96; 
  vec2_t v97; 
  __int128 v98; 

  v6 = context;
  v84 = context;
  v7 = tileMapIndex;
  v8 = gridY;
  transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  v10 = gridX;
  outLodNumber = tileMapIndex;
  gridYa = gridY;
  gridXa = gridX;
  if ( tileMapIndex >= transientWorldGridTileMapCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4132, ASSERT_TYPE_ASSERT, "(unsigned)( tileMapIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount )", "tileMapIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount\n\t%i not in [0, %i)", tileMapIndex, transientWorldGridTileMapCount) )
    __debugbreak();
  tileMap = &s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps[v7];
  v11 = tileMap;
  OverlayClipMode = CL_TransientsWorldMP_GetOverlayClipMode();
  cellSize = tileMap->cellSize;
  v14 = (float)v10;
  v15 = (float)(v14 * cellSize) + tileMap->minX;
  v16 = (float)v8;
  v17 = (float)(v16 * cellSize) + tileMap->minY;
  v18 = OverlayClipMode;
  v79 = OverlayClipMode;
  inMax3D.v[1] = cellSize + v17;
  inMax3D.v[0] = cellSize + v15;
  inMax3D.v[2] = 0.0;
  inMin3D.v[0] = v15;
  inMin3D.v[1] = v17;
  inMin3D.v[2] = 0.0;
  CL_DebugMapOverlay::TransformBox(v6, &inMin3D, &inMax3D, &outMin2D, &outMax2D);
  v19 = DCONST_DVARINT_cl_transientWorldOverlayLodCount;
  v20 = outMax2D.v[0] - outMin2D.v[0];
  v21 = outMax2D.v[1] - outMin2D.v[1];
  if ( !DCONST_DVARINT_cl_transientWorldOverlayLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayLodCount") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v19);
  unsignedInt = v19->current.unsignedInt;
  if ( (signed int)tileMap->lodCount < (signed int)unsignedInt )
    unsignedInt = tileMap->lodCount;
  ShouldDrawCellIndexLabel = 0;
  v24 = (float)unsignedInt;
  v80 = 0;
  v25 = 0;
  v26 = 0.5 / v24;
  if ( !unsignedInt )
    return;
  v98 = v5;
  do
  {
    TransientIndex = CL_TransientsWorldMP_GetTransientIndex(v11, gridXa, gridYa, v25);
    LOWORD(v11) = TransientIndex;
    if ( v25 )
    {
      if ( v25 == 2 )
        goto LABEL_16;
    }
    else
    {
      v80 = TransientIndex;
    }
    if ( !ShouldDrawCellIndexLabel )
      ShouldDrawCellIndexLabel = CL_TransientsWorldMP_ShouldDrawCellIndexLabel(TransientIndex);
LABEL_16:
    v28 = DVARBOOL_cl_transientWorldOverlayPriorityColors;
    if ( !DVARBOOL_cl_transientWorldOverlayPriorityColors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityColors") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v28);
    if ( v28->current.enabled )
      goto LABEL_26;
    v29 = DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested;
    if ( !DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityColorsRequested") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v29);
    if ( v29->current.enabled )
    {
LABEL_26:
      if ( v25 == 2 || !(_WORD)v11 )
        goto LABEL_57;
      fileBackedTransientCount = s_transientsWorldMP.fileBackedTransientCount;
      v33 = 0;
      v34 = 0;
      if ( s_transientsWorldMP.fileBackedTransientCount )
      {
        while ( s_transientsWorldMP.priorityOrder[v34] != (_WORD)v11 )
        {
          if ( ++v34 >= s_transientsWorldMP.fileBackedTransientCount )
            goto LABEL_35;
        }
        v11 = (TransientWorldGridTileMap *)(unsigned __int16)v11;
        if ( (unsigned __int16)v11 >= 0x600u )
        {
          LODWORD(v75) = 1536;
          LODWORD(clipMode) = (_DWORD)v11;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", clipMode, v75) )
            __debugbreak();
        }
        fileBackedTransientCount = v34;
        v33 = ((0x80000000 >> ((unsigned __int8)v11 & 0x1F)) & s_transientsWorldMP.requested.array[(unsigned __int64)v11 >> 5]) != 0;
      }
LABEL_35:
      v35 = DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested;
      if ( !DCONST_DVARBOOL_cl_transientWorldOverlayPriorityColorsRequested && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityColorsRequested") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v35);
      enabled = v35->current.enabled;
      v37 = s_transientsWorldMP.fileBackedTransientCount;
      if ( enabled )
        v37 = numRequestedTiles;
      if ( v37 < 1 )
        v37 = 1;
      v38 = 0i64;
      *(float *)&v38 = (float)fileBackedTransientCount;
      *(float *)&v38 = *(float *)&v38 / (float)v37;
      _XMM1 = v38;
      __asm
      {
        vmaxss  xmm1, xmm1, xmm11
        vminss  xmm0, xmm1, xmm10
      }
      if ( v33 || !enabled )
      {
        color.v[0] = 1.0 - *(float *)&_XMM0;
        color.v[1] = 1.0 - *(float *)&_XMM0;
        color.v[2] = 1.0 - *(float *)&_XMM0;
      }
      else
      {
        color.v[0] = (float)((float)(1.0 - *(float *)&_XMM0) * 0.75) + 0.25;
        color.v[1] = 0.0;
        color.v[2] = 0.0;
      }
      v18 = v79;
      v6 = v84;
      v31 = FLOAT_1_0;
      color.v[3] = FLOAT_1_0;
    }
    else
    {
      CellState = CL_TransientsWorldMP_GetCellState((unsigned __int16)v11);
      LODWORD(v31) = _mm_shuffle_ps((__m128)CELL_STATE_COLORS[CellState], (__m128)CELL_STATE_COLORS[CellState], 255).m128_u32[0];
      color = CELL_STATE_COLORS[CellState];
    }
    if ( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount > 1 )
    {
      v42 = outLodNumber;
      if ( outLodNumber > 1 )
        v42 = 1;
      if ( v42 < 0 )
        v42 = 0;
      v31 = v31 * OVERLAPPED_TILEMAP_ALPHAS[v42];
      color.v[3] = v31;
    }
    if ( v31 != 0.0 )
    {
      v43 = (float)v25;
      pos2D.v[0] = (float)(v43 * (float)(v20 * v26)) + outMin2D.v[0];
      v44 = 1.0 - (float)(v43 * v26);
      pos2D.v[1] = (float)((float)(v21 * v26) * v43) + outMin2D.v[1];
      v45 = v25 + 1;
      v46 = (float)(v44 * v20) + outMin2D.v[0];
      v47 = (float)(v44 * v21) + outMin2D.v[1];
      v86.v[0] = v46;
      v86.v[1] = v47;
      if ( (unsigned int)v45 >= unsignedInt )
      {
        CL_DebugMapOverlay::DrawFilledRect2D(v6, &pos2D, &v86, &color, v18);
      }
      else
      {
        v48 = (float)v45;
        v49 = (float)(v48 * (float)(v20 * v26)) + outMin2D.v[0];
        v50 = (float)(v48 * (float)(v21 * v26)) + outMin2D.v[1];
        v51 = 1.0 - (float)(v48 * v26);
        *(vec2_t *)inMax3D.v = pos2D;
        v52 = (float)(v51 * v21) + outMin2D.v[1];
        maxPos2D.v[0] = v49;
        maxPos2D.v[1] = v47;
        v53 = (float)(v51 * v20) + outMin2D.v[0];
        CL_DebugMapOverlay::DrawFilledRect2D(v6, (const vec2_t *)&inMax3D, &maxPos2D, &color, v18);
        *(vec2_t *)inMax3D.v = v86;
        minPos2D.v[1] = pos2D.v[1];
        minPos2D.v[0] = v53;
        CL_DebugMapOverlay::DrawFilledRect2D(v6, &minPos2D, (const vec2_t *)&inMax3D, &color, v18);
        v96.v[1] = pos2D.v[1];
        v95.v[0] = v53;
        v95.v[1] = v50;
        v96.v[0] = v49;
        CL_DebugMapOverlay::DrawFilledRect2D(v6, &v96, &v95, &color, v18);
        v97.v[1] = v86.v[1];
        v97.v[0] = v53;
        inMin3D.v[0] = v49;
        inMin3D.v[1] = v52;
        CL_DebugMapOverlay::DrawFilledRect2D(v6, (const vec2_t *)&inMin3D, &v97, &color, v18);
      }
    }
LABEL_57:
    v11 = tileMap;
    ++v25;
  }
  while ( v25 < unsignedInt );
  if ( ShouldDrawCellIndexLabel && v80 )
  {
    v54 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawCellNumbers;
    v56 = COERCE_FLOAT(LODWORD(v20) & _xmm) * 0.0125;
    v55 = v56;
    pos2D.v[0] = (float)(outMax2D.v[0] + outMin2D.v[0]) * 0.5;
    pos2D.v[1] = (float)(outMax2D.v[1] + outMin2D.v[1]) * 0.5;
    if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawCellNumbers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawCellNumbers") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v54);
    if ( v54->current.enabled )
    {
      CL_DebugMapOverlay::DrawTextf2D(v6, &pos2D, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, v56, &colorWhite, v18, "%u", v80);
      goto LABEL_65;
    }
    v62 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawDelayValues;
    if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawDelayValues && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawDelayValues") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v62);
    if ( !v62->current.enabled )
      goto LABEL_65;
    CellDelayRemaining = DB_TransientsWorldMP_GetCellDelayRemaining(0, v80, &outLodNumber);
    v64 = DCONST_DVARBOOL_cl_transientWorldDebugDelay;
    v65 = CellDelayRemaining;
    if ( !DCONST_DVARBOOL_cl_transientWorldDebugDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v64);
    if ( v64->current.enabled )
    {
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v80);
      if ( !HighLODLookups && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4269, ASSERT_TYPE_ASSERT, "(highLodLookups)", (const char *)&queryFormat, "highLodLookups") )
        __debugbreak();
      v57 = v79;
      v86.v[0] = pos2D.v[0];
      v86.v[1] = pos2D.v[1] - (float)(v21 * 0.33333334);
      v67 = &colorYellow;
      v69 = v56 * 0.5;
      v68 = v69;
      if ( v65 )
        v67 = &colorRed;
      CL_DebugMapOverlay::DrawTextf2D(v6, &v86, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, v69, v67, v79, "%.1f", (float)((float)v65 * 0.001));
      if ( v80 >= 0x600u )
      {
        LODWORD(v76) = 1536;
        LODWORD(clipModea) = v80;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4279, ASSERT_TYPE_ASSERT, "(unsigned)( drawCellNumber ) < (unsigned)( ( sizeof( *array_counter( delayTargetArray.data ) ) + 0 ) )", "drawCellNumber doesn't index delayTargetArray.data\n\t%i not in [0, %i)", clipModea, v76) )
          __debugbreak();
      }
      *(vec2_t *)inMax3D.v = pos2D;
      CL_DebugMapOverlay::DrawTextf2D(v6, (const vec2_t *)&inMax3D, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, v69, &colorWhite, v79, "%.1f", (float)((float)s_transientsWorldMP.switchDelayTarget[0].data[v80] * 0.001));
      v70 = *HighLODLookups;
      if ( *HighLODLookups )
      {
        if ( (unsigned int)v70 >= 0x600 )
        {
          LODWORD(v77) = 1536;
          LODWORD(clipModeb) = *HighLODLookups;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4288, ASSERT_TYPE_ASSERT, "(unsigned)( lod1Index ) < (unsigned)( ( sizeof( *array_counter( delayTargetArray.data ) ) + 0 ) )", "lod1Index doesn't index delayTargetArray.data\n\t%i not in [0, %i)", clipModeb, v77) )
            __debugbreak();
        }
        v86 = pos2D;
        v71 = (float)s_transientsWorldMP.switchDelayTarget[0].data[v70];
        v86.v[1] = (float)(v21 * 0.33333334) + pos2D.v[1];
        CL_DebugMapOverlay::DrawTextf2D(v6, &v86, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, v68, &colorWhite, v79, "%.1f", (float)(v71 * 0.001));
      }
      goto LABEL_66;
    }
    if ( outLodNumber < 0 )
    {
LABEL_65:
      v57 = v79;
      goto LABEL_66;
    }
    v57 = v79;
    if ( v65 )
      CL_DebugMapOverlay::DrawTextf2D(v6, &pos2D, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, v56, &colorWhite, v79, "%.1f", (float)((float)v65 * 0.001));
LABEL_66:
    if ( v55 > 0.30000001 )
    {
      v58 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawZBoundsTopValue;
      if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawZBoundsTopValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawZBoundsTopValue") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v58);
      if ( v58->current.enabled )
      {
        TileBounds = CL_TransientsWorldMP_GetTileBounds(tileMap, gridXa, gridYa, 0);
        v60 = TileBounds->halfSize.v[2] + TileBounds->midPoint.v[2];
        v86.v[0] = pos2D.v[0];
        v86.v[1] = (float)(v21 * -0.33333334) + pos2D.v[1];
        CL_DebugMapOverlay::DrawTextf2D(v6, &v86, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, v55 * 0.33333334, &colorOrange, v57, "z=%.0f", v60);
      }
      v61 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawLOD1Indices;
      if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawLOD1Indices && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawLOD1Indices") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v61);
      if ( v61->current.enabled )
      {
        v86.v[0] = pos2D.v[0];
        v86.v[1] = (float)(v21 * 0.33333334) + pos2D.v[1];
        LODWORD(v78) = *CL_TransientsWorldMP_GetHighLODLookups(v80);
        CL_DebugMapOverlay::DrawTextf2D(v6, &v86, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, v55 * 0.33333334, &colorBlue, v57, "L1:%u", v78);
      }
    }
  }
}

/*
==============
CL_TransientsWorldMP_DrawCellOutline
==============
*/
void CL_TransientsWorldMP_DrawCellOutline(CL_DebugMapOverlay *context, const unsigned int gridX, const unsigned int gridY, const unsigned int tileMapIndex, bool insideCell)
{
  __int64 v6; 
  __int64 v7; 
  unsigned int transientWorldGridTileMapCount; 
  __int64 v9; 
  TransientWorldGridTileMap *v10; 
  CL_DebugMapOverlay::ClipMode OverlayClipMode; 
  const dvar_t *v12; 
  CL_DebugMapOverlay::ClipMode v13; 
  char v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned __int16 TransientIndex; 
  unsigned int v18; 
  vec4_t v19; 
  unsigned __int16 v20; 
  const unsigned __int16 *HighLODLookups; 
  int v22; 
  unsigned __int16 v23; 
  unsigned int v24; 
  unsigned int v25; 
  unsigned int *v26; 
  unsigned int v27; 
  unsigned __int16 v28; 
  unsigned int v29; 
  char v30; 
  unsigned int v31; 
  unsigned int *v32; 
  bool v33; 
  __m256i *v34; 
  CL_DebugMapOverlay::ClipMode v35; 
  unsigned __int16 v36; 
  unsigned __int16 v37; 
  float v38; 
  float v39; 
  int v40; 
  int v41; 
  int v42; 
  float cellSize; 
  float v44; 
  float v45; 
  float v46; 
  int v47; 
  __int64 v48; 
  __int64 v49; 
  char *v50; 
  char *v51; 
  char v52; 
  unsigned __int16 v53; 
  unsigned int v55; 
  const unsigned __int16 *v56; 
  Bounds *bounds; 
  vec2_t gridXa; 
  vec2_t clipMode; 
  vec4_t color; 
  __m256i v62; 
  __int128 v63; 
  __m256i v64; 
  __int128 v65; 

  v6 = gridY;
  v7 = gridX;
  transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  v9 = tileMapIndex;
  LODWORD(gridXa.v[0]) = gridX;
  if ( tileMapIndex >= transientWorldGridTileMapCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4331, ASSERT_TYPE_ASSERT, "(unsigned)( tileMapIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount )", "tileMapIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount\n\t%i not in [0, %i)", tileMapIndex, transientWorldGridTileMapCount) )
    __debugbreak();
  v10 = &s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps[v9];
  OverlayClipMode = CL_TransientsWorldMP_GetOverlayClipMode();
  v12 = DVARBOOL_cl_transientWorldOverlayBounds;
  v13 = OverlayClipMode;
  LODWORD(clipMode.v[0]) = OverlayClipMode;
  if ( !DVARBOOL_cl_transientWorldOverlayBounds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayBounds") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  if ( v12->current.enabled )
  {
    v62 = _ymm;
    v64 = _ymm;
    v63 = _xmm;
    v65 = _xmm;
    v14 = 0;
    bounds = (Bounds *)CL_TransientsWorldMP_GetTileBounds(v10, v7, v6, 0);
    v15 = 0;
    v52 = 0;
    v16 = 0;
    if ( v10->lodCount )
    {
      do
      {
        TransientIndex = CL_TransientsWorldMP_GetTransientIndex(v10, v7, v6, v16);
        v18 = TransientIndex;
        v14 |= CL_TransientsWorldMP_ShouldDrawCellIndexLabel(TransientIndex);
        if ( ((CL_TransientsWorldMP_GetCellState(v18) - 9) & 0xFFFFFFFD) == 0 )
          break;
        ++v16;
      }
      while ( v16 < v10->lodCount );
      v52 = v14;
    }
    if ( insideCell )
    {
      v19 = (vec4_t)_xmm;
    }
    else
    {
      v20 = CL_TransientsWorldMP_GetTransientIndex(v10, v7, v6, 0);
      v53 = v20;
      v55 = 2;
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v20);
      v56 = HighLODLookups;
      v22 = 0;
      if ( v10->lodCount )
      {
        while ( 1 )
        {
          v23 = v22 ? HighLODLookups[v22 - 1] : v20;
          v24 = v23;
          if ( v23 )
            break;
LABEL_26:
          if ( ++v22 >= v10->lodCount )
          {
            LODWORD(v6) = gridY;
            goto LABEL_30;
          }
        }
        v25 = 0;
        v26 = &s_transientsWorldMP.visibleCurrent[0].array[(unsigned __int64)v23 >> 5];
        while ( 1 )
        {
          if ( v24 >= 0x600 )
          {
            LODWORD(v50) = 1536;
            LODWORD(v48) = v24;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v48, v50) )
              __debugbreak();
          }
          if ( ((0x80000000 >> (v24 & 0x1F)) & *v26) != 0 )
            break;
          ++v25;
          v26 += 48;
          if ( v25 >= 2 )
          {
            v20 = v53;
            HighLODLookups = v56;
            goto LABEL_26;
          }
        }
        LODWORD(v6) = gridY;
        v55 = v22;
      }
      else
      {
LABEL_30:
        v22 = 2;
      }
      v27 = v22;
      *(float *)&v7 = gridXa.v[0];
      v28 = CL_TransientsWorldMP_GetTransientIndex(v10, LODWORD(gridXa.v[0]), v6, v27);
      v29 = v28;
      v30 = 0;
      v31 = 0x80000000 >> (v28 & 0x1F);
      v32 = &s_transientsWorldMP.zoomTransients[0].array[(unsigned __int64)v28 >> 5];
      while ( 1 )
      {
        if ( v29 >= 0x600 )
        {
          LODWORD(v50) = 1536;
          LODWORD(v48) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v48, v50) )
            __debugbreak();
        }
        if ( (v31 & *v32) != 0 )
          break;
        ++v15;
        v32 += 48;
        if ( v15 >= 2 )
          goto LABEL_39;
      }
      v30 = 1;
LABEL_39:
      if ( v55 >= 3 )
      {
        LODWORD(v50) = 3;
        LODWORD(v48) = v55;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4407, ASSERT_TYPE_ASSERT, "(unsigned)( firstVisibleLod ) < (unsigned)( ( sizeof( *array_counter( BOUNDS_LOD_COLOR ) ) + 0 ) )", "firstVisibleLod doesn't index ARRAY_COUNT( BOUNDS_LOD_COLOR )\n\t%i not in [0, %i)", v48, v50) )
          __debugbreak();
        LODWORD(v51) = 3;
        LODWORD(v49) = v55;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4408, ASSERT_TYPE_ASSERT, "(unsigned)( firstVisibleLod ) < (unsigned)( ( sizeof( *array_counter( BOUNDS_LOD_COLOR_ZOOM ) ) + 0 ) )", "firstVisibleLod doesn't index ARRAY_COUNT( BOUNDS_LOD_COLOR_ZOOM )\n\t%i not in [0, %i)", v49, v51) )
          __debugbreak();
      }
      v14 = v52;
      v33 = v30 == 0;
      v34 = &v62;
      LODWORD(v6) = gridY;
      if ( !v33 )
        v34 = &v64;
      v19 = *(vec4_t *)&v34->m256i_i8[16 * v55];
    }
    v35 = LODWORD(clipMode.v[0]);
    color = v19;
    CL_DebugMapOverlay::DrawBox(context, bounds, 0, &color, SLODWORD(clipMode.v[0]));
    v36 = CL_TransientsWorldMP_GetTransientIndex(v10, v7, v6, 0);
    v37 = v36;
    if ( v14 )
    {
      if ( v36 != 2 )
      {
        v38 = bounds->midPoint.v[1];
        v39 = bounds->midPoint.v[2];
        *(float *)&v40 = bounds->midPoint.v[0] + bounds->halfSize.v[0];
        *(float *)v62.m256i_i32 = bounds->midPoint.v[0] - bounds->halfSize.v[0];
        *(float *)&v62.m256i_i32[1] = v38 - bounds->halfSize.v[1];
        *(float *)&v62.m256i_i32[2] = v39 - bounds->halfSize.v[2];
        *(float *)&v41 = v38 + bounds->halfSize.v[1];
        v62.m256i_i32[3] = v40;
        *(float *)&v42 = v39 + bounds->halfSize.v[2];
        v62.m256i_i32[4] = v41;
        v62.m256i_i32[5] = v42;
        CL_DebugMapOverlay::TransformBox(context, (const vec3_t *)&v62, (const vec3_t *)((char *)&v62.m256i_u64[1] + 4), &clipMode, (vec2_t *)&bounds);
        gridXa.v[0] = (float)(*(float *)&bounds + clipMode.v[0]) * 0.5;
        gridXa.v[1] = (float)(*((float *)&bounds + 1) + clipMode.v[1]) * 0.5;
        CL_DebugMapOverlay::DrawTextf2D(context, &gridXa, &CL_DebugMapOverlay::TEXT_ANCHOR_CENTRE, COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)&bounds - clipMode.v[0]) & _xmm) * 0.0125, &color, v35, "%u", v37);
      }
    }
  }
  else
  {
    cellSize = v10->cellSize;
    v44 = (float)v7;
    v45 = (float)(v44 * cellSize) + v10->minX;
    v46 = (float)v6;
    *(float *)&v47 = (float)(v46 * cellSize) + v10->minY;
    *(float *)&v62.m256i_i32[4] = cellSize + *(float *)&v47;
    *(float *)v62.m256i_i32 = v45;
    v62.m256i_i32[1] = v47;
    *(float *)&v62.m256i_i32[2] = 0.0;
    *(float *)&v62.m256i_i32[3] = cellSize + v45;
    *(float *)&v62.m256i_i32[5] = 0.0;
    CL_DebugMapOverlay::DrawExtBox(context, (const ExtentBounds *)&v62, 0, &CL_DebugMapOverlay::WHITE_COLOR, v13);
    if ( insideCell )
      CL_DebugMapOverlay::DrawExtBox(context, (const ExtentBounds *)&v62, -1, &CL_DebugMapOverlay::WHITE_COLOR, v13);
  }
}

/*
==============
CL_TransientsWorldMP_DrawLegend
==============
*/
void CL_TransientsWorldMP_DrawLegend(CL_DebugMapOverlay *context, const float xoffset, const float yoffset, const vec4_t *color, const char *const label)
{
  const dvar_t *v5; 
  float v8; 
  float v9; 
  vec2_t minPos2D; 
  vec2_t maxPos2D; 

  v5 = DVARVEC2_cl_transientWorldOverlayOffset;
  if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v8 = xoffset + v5->current.value;
  v9 = yoffset + v5->current.vector.v[1];
  maxPos2D.v[1] = v9 + 10.0;
  maxPos2D.v[0] = v8 + 10.0;
  minPos2D.v[0] = v8;
  minPos2D.v[1] = v9;
  CL_DebugMapOverlay::DrawFilledRect2D(context, &minPos2D, &maxPos2D, color, Unclipped);
  minPos2D.v[0] = (float)(v8 + 10.0) + 2.0;
  minPos2D.v[1] = v9 + 8.0;
  CL_DebugMapOverlay::DrawText2D(context, &minPos2D, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, 0.15000001, &colorWhite, Unclipped, label);
}

/*
==============
CL_TransientsWorldMP_DrawOverlay
==============
*/
void CL_TransientsWorldMP_DrawOverlay(LocalClientNum_t screenLocalClient)
{
  const dvar_t *v2; 
  const dvar_t *v3; 
  const dvar_t *v4; 
  const dvar_t *v5; 
  unsigned int v6; 
  unsigned __int64 v7; 
  __int64 v8; 
  vec4_t v9; 
  vec3_t origin; 
  vec4_t color; 

  if ( !Sys_IsUpdateScreenThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5504, ASSERT_TYPE_ASSERT, "(Sys_IsUpdateScreenThread())", (const char *)&queryFormat, "Sys_IsUpdateScreenThread()") )
    __debugbreak();
  v2 = DCONST_DVARBOOL_cl_transientWorldStreamProgress;
  if ( !DCONST_DVARBOOL_cl_transientWorldStreamProgress && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamProgress") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    ++s_transientsWorldMP.streamProgressCurrentFrame;
    CL_TransientsWorldMP_UpdateStreamProgress(1);
  }
  if ( s_transientsWorldMP.worldGridInfo )
  {
    v3 = DVARBOOL_cl_transientWorldOverlay;
    if ( !DVARBOOL_cl_transientWorldOverlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    if ( v3->current.enabled )
      CL_TransientsWorldMP_DrawScreenOverlay(screenLocalClient);
    v4 = DCONST_DVARINT_cl_transientWorldPriorityGraph;
    if ( !DCONST_DVARINT_cl_transientWorldPriorityGraph && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraph") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v4);
    if ( v4->current.integer )
      CL_TransientsWorldMP_DrawPriorityGraph(screenLocalClient);
    v5 = DCONST_DVARBOOL_cl_transientWorldDrawBounds;
    if ( !DCONST_DVARBOOL_cl_transientWorldDrawBounds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDrawBounds") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    if ( v5->current.enabled )
    {
      v6 = 0;
      v7 = 0i64;
      v8 = 0i64;
      do
      {
        if ( ((0x80000000 >> (v6 & 0x1F)) & s_transientsWorldMP.transientsHighestLOD.array[v7 >> 5]) == 0 && v6 < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
        {
          v9 = CELL_STATE_COLORS[CL_TransientsWorldMP_GetCellState(v6)];
          *(_QWORD *)origin.v = 0i64;
          origin.v[2] = 0.0;
          color = v9;
          CG_DebugBox(&origin, &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v8], 0.0, &color, 0, 1);
        }
        ++v6;
        ++v7;
        ++v8;
      }
      while ( v6 < 0x600 );
    }
  }
}

/*
==============
CL_TransientsWorldMP_DrawPlayerFOV
==============
*/
void CL_TransientsWorldMP_DrawPlayerFOV(CL_DebugMapOverlay *context, const WorldStreamPosition *worldStreamPos)
{
  LocalClientNum_t localClientIndex; 
  const dvar_t *v5; 
  float v6; 
  const vec4_t *v7; 
  const vec4_t *v8; 
  float v9; 
  const dvar_t *v10; 
  float v11; 
  const dvar_t *v12; 
  float v13; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  const dvar_t *v19; 
  float value; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  __int64 v28; 
  LocalClientNum_t v29; 
  __int64 v30; 
  int v31; 
  vec3_t forward; 
  vec3_t up; 
  vec3_t dst; 
  vec3_t v35; 
  vec3_t v36; 
  vec3_t v37; 
  vec3_t v38; 
  vec3_t v39; 
  vec3_t v40; 
  vec3_t v41; 
  vec3_t startPos; 
  vec3_t v43; 
  vec3_t v44; 
  vec3_t v45; 
  vec3_t endPos; 
  vec3_t v47; 
  vec3_t v48; 
  vec4_t v49; 
  vec4_t v50; 
  vec4_t v51; 
  vec4_t v52; 
  vec4_t color; 
  vec3_t right; 
  vec4_t v55[2]; 
  vec4_t v56[2]; 

  localClientIndex = worldStreamPos->localClientIndex;
  *(__m256i *)v55[0].v = _ymm;
  *(__m256i *)v56[0].v = _ymm;
  v49 = (vec4_t)_xmm;
  v50 = (vec4_t)_xmm;
  v51 = (vec4_t)_xmm;
  v52 = (vec4_t)_xmm;
  if ( (unsigned int)localClientIndex >= LOCAL_CLIENT_COUNT )
  {
    v31 = 2;
    v29 = localClientIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4498, ASSERT_TYPE_ASSERT, "(unsigned)( worldStreamPos.localClientIndex ) < (unsigned)( ( sizeof( *array_counter( FOV_COLOR ) ) + 0 ) )", "worldStreamPos.localClientIndex doesn't index ARRAY_COUNT( FOV_COLOR )\n\t%i not in [0, %i)", v29, v31) )
      __debugbreak();
  }
  if ( worldStreamPos->localClientIndex >= (unsigned int)LOCAL_CLIENT_COUNT )
  {
    LODWORD(v30) = 2;
    LODWORD(v28) = worldStreamPos->localClientIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4499, ASSERT_TYPE_ASSERT, "(unsigned)( worldStreamPos.localClientIndex ) < (unsigned)( ( sizeof( *array_counter( FOV_TARGET_COLOR ) ) + 0 ) )", "worldStreamPos.localClientIndex doesn't index ARRAY_COUNT( FOV_TARGET_COLOR )\n\t%i not in [0, %i)", v28, v30) )
      __debugbreak();
  }
  v5 = DVARFLT_cg_fov;
  v6 = 0.5 * worldStreamPos->fovLerpTarget;
  v7 = &v55[worldStreamPos->localClientIndex];
  v8 = &v56[worldStreamPos->localClientIndex];
  if ( !DVARFLT_cg_fov && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_fov") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v9 = 0.5 * v5->current.value;
  v10 = DVARFLT_cl_transientWorldZoomCutoffLoad;
  if ( !DVARFLT_cl_transientWorldZoomCutoffLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldZoomCutoffLoad") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  v11 = (float)(v9 - v6) * v10->current.value;
  v12 = DVARFLT_cl_transientWorldZoomCutoffVisibility;
  v13 = v9 - v11;
  if ( !DVARFLT_cl_transientWorldZoomCutoffVisibility && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldZoomCutoffVisibility") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  v14 = v9 - (float)((float)(v9 - v6) * v12->current.value);
  v15 = 0.5 * worldStreamPos->fovCurrent;
  AngleVectors(&worldStreamPos->angles, &forward, &right, &up);
  RotatePointAroundVector(&dst, &up, &forward, COERCE_FLOAT(LODWORD(v15) ^ _xmm));
  RotatePointAroundVector(&v35, &up, &forward, v15);
  RotatePointAroundVector(&v36, &up, &forward, COERCE_FLOAT(LODWORD(v6) ^ _xmm));
  RotatePointAroundVector(&v37, &up, &forward, v6);
  RotatePointAroundVector(&v38, &up, &forward, COERCE_FLOAT(LODWORD(v13) ^ _xmm));
  RotatePointAroundVector(&v39, &up, &forward, v13);
  RotatePointAroundVector(&v40, &up, &forward, COERCE_FLOAT(LODWORD(v14) ^ _xmm));
  RotatePointAroundVector(&v41, &up, &forward, v14);
  v16 = worldStreamPos->pos.v[0];
  v17 = worldStreamPos->pos.v[1];
  v18 = worldStreamPos->pos.v[2];
  endPos.v[0] = (float)(999999.0 * forward.v[0]) + worldStreamPos->pos.v[0];
  endPos.v[1] = (float)(999999.0 * forward.v[1]) + v17;
  endPos.v[2] = (float)(999999.0 * forward.v[2]) + v18;
  dst.v[0] = (float)(999999.0 * dst.v[0]) + v16;
  dst.v[1] = (float)(999999.0 * dst.v[1]) + v17;
  dst.v[2] = (float)(999999.0 * dst.v[2]) + v18;
  v35.v[0] = (float)(999999.0 * v35.v[0]) + v16;
  v35.v[1] = (float)(999999.0 * v35.v[1]) + v17;
  v35.v[2] = (float)(999999.0 * v35.v[2]) + v18;
  v36.v[0] = (float)(999999.0 * v36.v[0]) + v16;
  v36.v[1] = (float)(999999.0 * v36.v[1]) + v17;
  v36.v[2] = (float)(999999.0 * v36.v[2]) + v18;
  v37.v[0] = (float)(999999.0 * v37.v[0]) + v16;
  v37.v[1] = (float)(999999.0 * v37.v[1]) + v17;
  v37.v[2] = (float)(999999.0 * v37.v[2]) + v18;
  v38.v[0] = (float)(999999.0 * v38.v[0]) + v16;
  v38.v[1] = (float)(999999.0 * v38.v[1]) + v17;
  v38.v[2] = (float)(999999.0 * v38.v[2]) + v18;
  v39.v[0] = (float)(999999.0 * v39.v[0]) + v16;
  v39.v[1] = (float)(999999.0 * v39.v[1]) + v17;
  v39.v[2] = (float)(999999.0 * v39.v[2]) + v18;
  v40.v[0] = (float)(999999.0 * v40.v[0]) + v16;
  v40.v[1] = (float)(999999.0 * v40.v[1]) + v17;
  v40.v[2] = (float)(999999.0 * v40.v[2]) + v18;
  v41.v[0] = (float)(999999.0 * v41.v[0]) + v16;
  v41.v[1] = (float)(999999.0 * v41.v[1]) + v17;
  v41.v[2] = (float)(999999.0 * v41.v[2]) + v18;
  color = (vec4_t)_xmm;
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &endPos, &color, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &dst, v7, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v35, v7, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v36, v8, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v37, v8, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v38, &v51, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v39, &v51, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v40, &v52, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v41, &v52, Unclipped);
  v19 = DVARFLT_cl_transientWorldZoomFovXPadding;
  if ( !DVARFLT_cl_transientWorldZoomFovXPadding && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldZoomFovXPadding") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v19);
  value = v19->current.value;
  RotatePointAroundVector(&v47, &up, &forward, COERCE_FLOAT(LODWORD(v6) ^ _xmm) - value);
  RotatePointAroundVector(&v48, &up, &forward, v6 + value);
  v21 = worldStreamPos->zoomLODDist[0];
  v22 = worldStreamPos->pos.v[0];
  v23 = worldStreamPos->pos.v[1];
  v24 = worldStreamPos->pos.v[2];
  startPos.v[0] = (float)(v21 * v47.v[0]) + worldStreamPos->pos.v[0];
  startPos.v[1] = (float)(v21 * v47.v[1]) + v23;
  startPos.v[2] = (float)(v21 * v47.v[2]) + v24;
  v43.v[0] = (float)(v21 * v48.v[0]) + v22;
  v25 = (float)(v21 * v48.v[1]) + v23;
  v26 = v21 * v48.v[2];
  v27 = worldStreamPos->zoomLODDist[1];
  v43.v[1] = v25;
  v43.v[2] = v26 + v24;
  v45.v[0] = (float)(v27 * v47.v[0]) + v22;
  v45.v[1] = (float)(v27 * v47.v[1]) + v23;
  v45.v[2] = (float)(v27 * v47.v[2]) + v24;
  v44.v[0] = (float)(v27 * v48.v[0]) + v22;
  v44.v[2] = (float)(v27 * v48.v[2]) + v24;
  v44.v[1] = (float)(v27 * v48.v[1]) + v23;
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &startPos, &v49, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &worldStreamPos->pos, &v43, &v49, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &startPos, &v43, &v49, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &startPos, &v45, &v50, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &v43, &v44, &v50, Unclipped);
  CL_DebugMapOverlay::DrawLine(context, &v45, &v44, &v50, Unclipped);
}

/*
==============
CL_TransientsWorldMP_DrawPriorityGraph
==============
*/
void CL_TransientsWorldMP_DrawPriorityGraph(const LocalClientNum_t screenLocalClient)
{
  signed __int64 v1; 
  void *v2; 
  const ScreenPlacement *ActivePlacement; 
  const dvar_t *v4; 
  const dvar_t *v5; 
  const dvar_t *v6; 
  __int128 unsignedInt; 
  const dvar_t *v8; 
  unsigned int v11; 
  const dvar_t *v12; 
  int v13; 
  char *v14; 
  __int64 v15; 
  unsigned __int8 *transientLODIndex; 
  float *priorityDistXY; 
  __int64 v18; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 *v23; 
  unsigned int *v24; 
  __int64 v25; 
  unsigned int *v26; 
  const dvar_t *v27; 
  __int64 v28; 
  const dvar_t *v29; 
  const dvar_t *v31; 
  unsigned int *v32; 
  __int64 *v33; 
  unsigned int *v34; 
  __int64 v35; 
  __int128 v38; 
  float v40; 
  __int128 v41; 
  __int128 v42; 
  __int128 v43; 
  const dvar_t *v44; 
  unsigned int v45; 
  unsigned int numStreamPositions; 
  int v47; 
  WorldStreamPosition *v48; 
  const cg_t *v49; 
  const dvar_t *v50; 
  float v51; 
  float v52; 
  float v53; 
  unsigned int v54; 
  unsigned int *v55; 
  __int64 *v56; 
  char v57; 
  bool v58; 
  __int64 v59; 
  unsigned int *v60; 
  __int64 v61; 
  float v62; 
  __int128 v63; 
  float v64; 
  float v65; 
  bool v66; 
  float v67; 
  float v68; 
  CellState CellState; 
  const vec4_t *v70; 
  float v71; 
  __int128 v72; 
  Bounds *transientWorldGridBounds; 
  int v74; 
  float v75; 
  float v76; 
  __int128 v77; 
  float v78; 
  float v79; 
  float v80; 
  float *v81; 
  float v82; 
  __int128 v83; 
  __int128 v84; 
  __int64 v85; 
  const vec4_t *v86; 
  __int128 v87; 
  double v88; 
  __int128 v89; 
  __int128 v90; 
  __int128 v91; 
  __int128 v92; 
  __int128 v93; 
  __int64 clipMode; 
  vec4_t *frustumPlanes; 
  vec4_t *frustumPlanesa; 
  WorldTransientPriorityGraphOrder v97; 
  char v98; 
  unsigned int v99; 
  int v100; 
  unsigned int v101; 
  float v102; 
  int integer; 
  __int64 v104; 
  float v105; 
  float v106; 
  float value; 
  float v108; 
  int v109; 
  __int64 v110; 
  __int64 *v111; 
  __int64 v112; 
  vec2_t anchor; 
  vec2_t screenBoundsMin; 
  vec2_t endPos; 
  vec2_t pos2D; 
  vec3_t forward; 
  vec2_t startPos; 
  vec2_t v119; 
  vec2_t v120; 
  vec2_t v121; 
  vec2_t v122; 
  vec2_t v123; 
  vec2_t v124; 
  vec2_t v125; 
  vec2_t v126; 
  vec2_t screenBoundsMax; 
  vec2_t maxPos; 
  vec2_t minPos; 
  vec2_t v130; 
  CL_DebugMapOverlay v131; 
  Bounds worldBounds; 
  vec4_t v133; 
  unsigned int _First[3072]; 
  char dest[256]; 

  v2 = alloca(v1);
  v112 = -2i64;
  ActivePlacement = ScrPlace_GetActivePlacement(screenLocalClient);
  if ( !ActivePlacement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4983, ASSERT_TYPE_ASSERT, "(scrPlace)", (const char *)&queryFormat, "scrPlace") )
    __debugbreak();
  CL_DebugMapOverlay::CL_DebugMapOverlay(&v131);
  v4 = DCONST_DVARVEC2_cl_transientWorldPriorityScreenOffset;
  if ( !DCONST_DVARVEC2_cl_transientWorldPriorityScreenOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityScreenOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  screenBoundsMin = *(vec2_t *)&v4->current.enabled;
  v5 = DCONST_DVARVEC2_cl_transientWorldPriorityScreenSize;
  if ( !DCONST_DVARVEC2_cl_transientWorldPriorityScreenSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityScreenSize") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  value = v5->current.value;
  v108 = v5->current.vector.v[1];
  screenBoundsMax.v[0] = value + screenBoundsMin.v[0];
  screenBoundsMax.v[1] = v108 + screenBoundsMin.v[1];
  *(_OWORD *)worldBounds.midPoint.v = _xmm;
  worldBounds.halfSize.v[1] = FLOAT_1_0;
  worldBounds.halfSize.v[2] = FLOAT_1_0;
  CL_DebugMapOverlay::Init(&v131, ActivePlacement, &screenBoundsMin, &screenBoundsMax, &worldBounds);
  endPos.v[0] = screenBoundsMin.v[0];
  endPos.v[1] = v108 + screenBoundsMin.v[1];
  pos2D.v[0] = value + screenBoundsMin.v[0];
  pos2D.v[1] = v108 + screenBoundsMin.v[1];
  CL_DebugMapOverlay::DrawLine2D(&v131, &screenBoundsMin, &endPos, &colorWhite, Unclipped);
  CL_DebugMapOverlay::DrawLine2D(&v131, &endPos, &pos2D, &colorWhite, Unclipped);
  v6 = DCONST_DVARFLT_cl_transientWorldPriorityGraphXMin;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphXMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphXMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  unsignedInt = v6->current.unsignedInt;
  integer = v6->current.integer;
  v8 = DCONST_DVARFLT_cl_transientWorldPriorityGraphXMax;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphXMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphXMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  _XMM0 = v8->current.unsignedInt;
  __asm { vmaxss  xmm8, xmm0, xmm1 }
  v105 = *(float *)&_XMM8;
  v11 = 0;
  v104 = 0i64;
  v12 = DCONST_DVARINT_cl_transientWorldPriorityGraphLod;
  if ( !DCONST_DVARINT_cl_transientWorldPriorityGraphLod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphLod") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  v13 = v12->current.integer;
  v14 = dest;
  v15 = 3i64;
  do
  {
    *(_QWORD *)v14 = 0i64;
    *((_QWORD *)v14 + 1) = 0i64;
    *((_QWORD *)v14 + 2) = 0i64;
    v14 += 64;
    *((_QWORD *)v14 - 5) = 0i64;
    *((_QWORD *)v14 - 4) = 0i64;
    *((_QWORD *)v14 - 3) = 0i64;
    *((_QWORD *)v14 - 2) = 0i64;
    *((_QWORD *)v14 - 1) = 0i64;
    --v15;
  }
  while ( v15 );
  transientLODIndex = s_transientsWorldMP.transientLODIndex;
  priorityDistXY = s_transientsWorldMP.priorityDistXY;
  v18 = 2i64;
  do
  {
    _XMM0 = *(unsigned int *)priorityDistXY;
    if ( *(float *)&_XMM0 <= *(float *)&_XMM8 )
    {
      v20 = *transientLODIndex;
      if ( (unsigned int)v20 >= 2 )
      {
        LODWORD(frustumPlanes) = 2;
        LODWORD(clipMode) = *transientLODIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5017, ASSERT_TYPE_ASSERT, "(unsigned)( lod ) < (unsigned)( CL_TRANSIENT_WORLD_LOD_LEVELS )", "lod doesn't index CL_TRANSIENT_WORLD_LOD_LEVELS\n\t%i not in [0, %i)", clipMode, frustumPlanes) )
          __debugbreak();
      }
      if ( (_DWORD)v20 == v13 || v13 == 2 )
      {
        v21 = *((unsigned int *)&v104 + v20);
        _First[1536 * v20 + v21] = v11;
        *((_DWORD *)&v104 + v20) = v21 + 1;
      }
    }
    ++v11;
    ++priorityDistXY;
    ++transientLODIndex;
  }
  while ( v11 < 0x600 );
  v22 = 0i64;
  v23 = &v104;
  v24 = _First;
  v25 = 2i64;
  do
  {
    v26 = &_First[v22 + *(unsigned int *)v23];
    std::_Sort_unchecked<unsigned int *,WorldTransientPriorityGraphOrder>(v24, v26, v26 - v24, v97);
    v22 += 1536i64;
    v24 += 1536;
    v23 = (__int64 *)((char *)v23 + 4);
    --v25;
  }
  while ( v25 );
  v27 = DCONST_DVARINT_cl_transientWorldPriorityGraph;
  if ( !DCONST_DVARINT_cl_transientWorldPriorityGraph && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraph") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v27);
  v28 = v27->current.integer;
  v100 = v27->current.integer;
  v29 = DCONST_DVARFLT_cl_transientWorldPriorityGraphYMin;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphYMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphYMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v29);
  _XMM11 = v29->current.unsignedInt;
  v102 = v29->current.value;
  v31 = DCONST_DVARFLT_cl_transientWorldPriorityGraphYMax;
  if ( !DCONST_DVARFLT_cl_transientWorldPriorityGraphYMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphYMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v31);
  if ( v31->current.value == 0.0 )
  {
    v32 = _First;
    v33 = &v104;
    do
    {
      if ( *(_DWORD *)v33 )
      {
        v34 = v32;
        v35 = *(unsigned int *)v33;
        do
        {
          *(float *)&_XMM0 = CL_TransientsWorldMP_GetPriorityGraphValueY(*v34, (TransientWorldPriorityGraphType)v28);
          __asm
          {
            vmaxss  xmm6, xmm0, xmm6
            vminss  xmm11, xmm0, xmm11
          }
          ++v34;
          --v35;
        }
        while ( v35 );
        v102 = *(float *)&_XMM11;
      }
      v33 = (__int64 *)((char *)v33 + 4);
      v32 += 1536;
      --v18;
    }
    while ( v18 );
  }
  v38 = _XMM11;
  *(float *)&v38 = *(float *)&_XMM11 + 0.00000011920929;
  _XMM0 = v38;
  __asm { vmaxss  xmm0, xmm0, xmm6 }
  v106 = *(float *)&_XMM0;
  anchor.v[0] = 0.0;
  anchor.v[1] = FLOAT_1_0;
  v40 = FLOAT_0_2;
  CL_DebugMapOverlay::DrawTextf2D(&v131, &screenBoundsMin, &anchor, 0.2, &colorWhite, Unclipped, "%s (%.0f)", cl_transientWorldPriorityGraphType[v28], *(float *)&_XMM0);
  v41 = LODWORD(FLOAT_0_5);
  anchor.v[0] = FLOAT_0_5;
  anchor.v[1] = 0.0;
  CL_DebugMapOverlay::DrawTextf2D(&v131, &pos2D, &anchor, 0.2, &colorWhite, Unclipped, "DistXY (%.0f)", *(float *)&_XMM8);
  if ( *(float *)&unsignedInt != 0.0 )
  {
    anchor.v[0] = 0.0;
    anchor.v[1] = 0.0;
    *((_QWORD *)&v42 + 1) = *((_QWORD *)&unsignedInt + 1);
    *(double *)&v42 = *(float *)&unsignedInt;
    v41 = v42;
    CL_DebugMapOverlay::DrawTextf2D(&v131, &endPos, &anchor, 0.2, &colorWhite, Unclipped, "%.0f", *(float *)&unsignedInt);
  }
  if ( *(float *)&_XMM11 != 0.0 )
  {
    anchor.v[0] = FLOAT_1_0;
    anchor.v[1] = FLOAT_1_0;
    *((_QWORD *)&v43 + 1) = *((_QWORD *)&_XMM11 + 1);
    *(double *)&v43 = *(float *)&_XMM11;
    v41 = v43;
    CL_DebugMapOverlay::DrawTextf2D(&v131, &endPos, &anchor, 0.2, &colorWhite, Unclipped, "%.0f", *(float *)&_XMM11);
  }
  v98 = 0;
  v44 = DCONST_DVARBOOL_cl_transientWorldPriorityGraphHighlightInFrustum;
  if ( !DCONST_DVARBOOL_cl_transientWorldPriorityGraphHighlightInFrustum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphHighlightInFrustum") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v44);
  if ( v44->current.enabled )
  {
    v45 = 0;
    numStreamPositions = s_transientsWorldMP.numStreamPositions;
    if ( s_transientsWorldMP.numStreamPositions )
    {
      v47 = cg_t::ms_allocatedCount;
      do
      {
        v48 = &s_transientsWorldMP.streamPositions[v45];
        if ( v48->localClientIndex == LOCAL_CLIENT_0 && v48->streamRender && v47 > 0 )
        {
          if ( !cg_t::ms_cgArray[0] )
          {
            LODWORD(frustumPlanesa) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", frustumPlanesa) )
              __debugbreak();
          }
          if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
          {
            LODWORD(frustumPlanesa) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", frustumPlanesa) )
              __debugbreak();
          }
          v49 = cg_t::ms_cgArray[0];
          AngleVectors(&v48->angles, &forward, NULL, NULL);
          CL_TransientsWorldMP_GetFrustumPlanes(v49, &s_transientsWorldMP.streamPositions[v45].pos, &forward, 1000000000.0, 0.0, 0.0, &v133);
          v98 = 1;
          numStreamPositions = s_transientsWorldMP.numStreamPositions;
          v47 = cg_t::ms_allocatedCount;
        }
        ++v45;
      }
      while ( v45 < numStreamPositions );
      LODWORD(v28) = v100;
    }
  }
  v50 = DCONST_DVARINT_cl_transientWorldPriorityGraphLabels;
  if ( !DCONST_DVARINT_cl_transientWorldPriorityGraphLabels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldPriorityGraphLabels") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v50);
  v109 = v50->current.integer;
  v101 = 0;
  v51 = FLOAT_2_0;
  v52 = FLOAT_4_0;
  v53 = FLOAT_9_5367432eN7;
  do
  {
    v54 = 0;
    v99 = 0;
    v55 = _First;
    *(_QWORD *)forward.v = _First;
    v56 = &v104;
    v111 = &v104;
    do
    {
      v126 = 0i64;
      v57 = 0;
      v58 = 0;
      v59 = *(unsigned int *)v56;
      if ( !(_DWORD)v59 )
        goto LABEL_101;
      v60 = v55;
      v110 = v59;
      do
      {
        v61 = *v60;
        if ( !(_DWORD)v61 )
          goto LABEL_99;
        v62 = s_transientsWorldMP.priorityDistZ[v61 - 1536];
        *(float *)&v41 = CL_TransientsWorldMP_GetPriorityGraphValueY(v61, (TransientWorldPriorityGraphType)v28);
        v63 = v41;
        v64 = (float)(v62 - *(float *)&unsignedInt) / (float)(v105 - *(float *)&unsignedInt);
        v65 = (float)(*(float *)&v63 - *(float *)&_XMM11) / (float)(v106 - *(float *)&_XMM11);
        v66 = v64 >= 0.0 && v64 <= 1.0 && v65 >= 0.0 && v65 <= 1.0;
        v67 = (float)(v64 * value) + endPos.v[0];
        anchor.v[0] = v67;
        v41 = LODWORD(endPos.v[1]);
        v68 = endPos.v[1] - (float)(v65 * v108);
        anchor.v[1] = v68;
        if ( !v101 )
        {
          if ( v66 )
          {
            CellState = CL_TransientsWorldMP_GetCellState(v61);
            v70 = &CELL_STATE_COLORS[CellState];
            maxPos.v[0] = v51 + anchor.v[0];
            maxPos.v[1] = v51 + anchor.v[1];
            minPos.v[0] = anchor.v[0] - v51;
            minPos.v[1] = anchor.v[1] - v51;
            CL_DebugMapOverlay::DrawRect2D(&v131, &minPos, &maxPos, v70, Unclipped);
            v71 = v99 ? anchor.v[1] + v52 : anchor.v[1] - v52;
            v72 = LODWORD(FLOAT_1_0);
            *(float *)&v72 = anchor.v[0] + 1.0;
            v41 = v72;
            v130.v[0] = anchor.v[0] + 1.0;
            v130.v[1] = v71;
            startPos.v[0] = anchor.v[0] - 1.0;
            startPos.v[1] = v71;
            CL_DebugMapOverlay::DrawLine2D(&v131, &startPos, &v130, v70, Unclipped);
            if ( v98 )
            {
              if ( (unsigned int)v61 < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
              {
                transientWorldGridBounds = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
                v74 = 0;
                v75 = transientWorldGridBounds[v61].midPoint.v[0];
                v76 = transientWorldGridBounds[v61].midPoint.v[1];
                v77 = LODWORD(transientWorldGridBounds[v61].midPoint.v[2]);
                v78 = transientWorldGridBounds[v61].halfSize.v[0];
                v79 = transientWorldGridBounds[v61].halfSize.v[1];
                v80 = transientWorldGridBounds[v61].halfSize.v[2];
                v81 = &v133.v[1];
                while ( 1 )
                {
                  v82 = v81[1];
                  v83 = v77;
                  *(float *)&v83 = *(float *)&v77 * v82;
                  v41 = v83;
                  if ( (float)((float)((float)((float)((float)((float)((float)(v75 * *(v81 - 1)) + v81[2]) + (float)(v78 * COERCE_FLOAT(*(_DWORD *)(v81 - 1) & _xmm))) + (float)(v76 * *v81)) + (float)(COERCE_FLOAT(*(_DWORD *)v81 & _xmm) * v79)) + (float)(*(float *)&v77 * v82)) + (float)(COERCE_FLOAT(LODWORD(v82) & _xmm) * v80)) <= 0.0 )
                    break;
                  ++v74;
                  v81 += 4;
                  if ( v74 >= 5 )
                  {
                    if ( CellState == NormalSpace )
                      v70 = &colorBlack;
                    *(vec4_t *)worldBounds.midPoint.v = *v70;
                    v119.v[0] = anchor.v[0] + 3.0;
                    v119.v[1] = anchor.v[1] + 3.0;
                    v120.v[0] = anchor.v[0] - 3.0;
                    v84 = LODWORD(anchor.v[1]);
                    *(float *)&v84 = anchor.v[1] - 3.0;
                    v41 = v84;
                    v120.v[1] = anchor.v[1] - 3.0;
                    CL_DebugMapOverlay::DrawRect2D(&v131, &v120, &v119, (const vec4_t *)&worldBounds, Unclipped);
                    break;
                  }
                }
                v40 = FLOAT_0_2;
                LODWORD(unsignedInt) = integer;
                *(float *)&_XMM11 = v102;
                v52 = FLOAT_4_0;
                v51 = FLOAT_2_0;
                v53 = FLOAT_9_5367432eN7;
              }
            }
          }
          goto LABEL_98;
        }
        if ( v57 && (v58 || v66) )
        {
          v85 = v99;
          CL_DebugMapOverlay::DrawLine2D(&v131, &v126, &anchor, &LOD_LINE_COLORS[v99], Unclipped);
          v68 = anchor.v[1];
          v67 = anchor.v[0];
        }
        else
        {
          v85 = v99;
        }
        if ( v66 )
        {
          v121.v[0] = v67 + 1.0;
          v121.v[1] = v68;
          v122.v[0] = v67 - 1.0;
          v122.v[1] = v68;
          v86 = &LOD_LINE_COLORS[v85];
          CL_DebugMapOverlay::DrawLine2D(&v131, &v122, &v121, v86, Unclipped);
          v123.v[0] = anchor.v[0];
          v87 = LODWORD(FLOAT_1_0);
          *(float *)&v87 = anchor.v[1] + 1.0;
          v41 = v87;
          v123.v[1] = anchor.v[1] + 1.0;
          v124.v[0] = anchor.v[0];
          v124.v[1] = anchor.v[1] - 1.0;
          CL_DebugMapOverlay::DrawLine2D(&v131, &v124, &v123, v86, Unclipped);
          switch ( v109 )
          {
            case 1:
              Com_sprintf(dest, 0x100ui64, "%u", (unsigned int)v61);
              goto LABEL_124;
            case 2:
              if ( (_DWORD)v28 == 7 )
              {
                v93 = v63;
                *(float *)&v93 = *(float *)&v63 * v53;
                v41 = v93;
                Com_sprintf(dest, 0x100ui64, "%.3f MB", (float)(*(float *)&v63 * v53));
              }
              else
              {
                Com_sprintf(dest, 0x100ui64, "%.1f", *(float *)&v63);
              }
LABEL_124:
              if ( dest[0] )
              {
                v125.v[0] = 0.0;
                v125.v[1] = FLOAT_1_0;
                CL_DebugMapOverlay::DrawText2D(&v131, &anchor, &v125, v40, v86, Unclipped, dest);
              }
              break;
            case 3:
              if ( (_DWORD)v28 == 7 )
              {
                v91 = v63;
                *(float *)&v91 = *(float *)&v63 * v53;
                v41 = v91;
                Com_sprintf(dest, 0x100ui64, "%u: %.3f MB", (unsigned int)v61, (float)(*(float *)&v63 * v53));
              }
              else
              {
                *((_QWORD *)&v92 + 1) = *((_QWORD *)&v63 + 1);
                *(double *)&v92 = *(float *)&v63;
                v41 = v92;
                Com_sprintf(dest, 0x100ui64, "%u: %.1f", (unsigned int)v61, *(float *)&v63);
              }
              goto LABEL_124;
            case 4:
              v88 = v62;
              if ( (_DWORD)v28 == 7 )
              {
                v89 = v63;
                *(float *)&v89 = *(float *)&v63 * v53;
                v41 = v89;
                Com_sprintf(dest, 0x100ui64, "(%.1f: %.3f MB)", v88, (float)(*(float *)&v63 * v53));
              }
              else
              {
                *((_QWORD *)&v90 + 1) = *((_QWORD *)&v63 + 1);
                *(double *)&v90 = *(float *)&v63;
                v41 = v90;
                Com_sprintf(dest, 0x100ui64, "(%.1f, %.1f)", v88, *(float *)&v63);
              }
              goto LABEL_124;
          }
        }
LABEL_98:
        v126 = anchor;
        v57 = 1;
        v58 = v66;
        v59 = v110;
LABEL_99:
        ++v60;
        v110 = --v59;
      }
      while ( v59 );
      v54 = v99;
      v55 = *(unsigned int **)forward.v;
LABEL_101:
      v99 = ++v54;
      v56 = (__int64 *)((char *)v111 + 4);
      v111 = (__int64 *)((char *)v111 + 4);
      v55 += 1536;
      *(_QWORD *)forward.v = v55;
    }
    while ( v54 < 2 );
    ++v101;
  }
  while ( v101 < 2 );
  CL_DebugMapOverlay::~CL_DebugMapOverlay(&v131);
}

/*
==============
CL_TransientsWorldMP_DrawScreenOverlay
==============
*/
void CL_TransientsWorldMP_DrawScreenOverlay(const LocalClientNum_t screenLocalClient)
{
  signed __int64 v1; 
  void *v2; 
  const ScreenPlacement *ActivePlacement; 
  __int128 v5; 
  unsigned int v6; 
  unsigned int v7; 
  unsigned __int64 v8; 
  char v9; 
  float v10; 
  cg_t *LocalClientGlobals; 
  RefdefView *p_view; 
  unsigned int refdefViewOrg_aab; 
  _DWORD *v; 
  int v15; 
  double v16; 
  const dvar_t *v17; 
  __int128 v18; 
  TransientWorldGridTileMap *v19; 
  float v20; 
  float v21; 
  __int128 v22; 
  __int128 v23; 
  float v24; 
  const dvar_t *v27; 
  float value; 
  const dvar_t *v29; 
  const dvar_t *v30; 
  TransientWorldGridTileMap *transientWorldGridTileMaps; 
  float gridCountX; 
  float v33; 
  __int128 v34; 
  float v37; 
  __int128 v38; 
  __int128 v39; 
  __int128 v40; 
  __int128 v41; 
  __int128 v43; 
  __int128 v45; 
  const dvar_t *v48; 
  unsigned __int64 v49; 
  const TransientInfo *worldGridInfo; 
  unsigned int transientWorldGridTileMapCount; 
  __int64 v52; 
  __int64 v53; 
  const TransientWorldGridTileMap *v54; 
  unsigned int v55; 
  unsigned int i; 
  unsigned __int16 v57; 
  __int64 v58; 
  const unsigned __int16 *HighLODLookups; 
  const XModel *ProxyModel; 
  __int64 v61; 
  const dvar_t *v62; 
  float v63; 
  float v64; 
  unsigned __int16 j; 
  const dvar_t *v66; 
  float v67; 
  float v68; 
  const dvar_t *v69; 
  float v70; 
  const dvar_t *v71; 
  float v72; 
  const dvar_t *v73; 
  __int128 unsignedInt; 
  __int128 v76; 
  const dvar_t *v78; 
  float v79; 
  float v80; 
  unsigned int v81; 
  vec2_t v82; 
  const TransientWorldGridTileMap *v83; 
  const dvar_t *v84; 
  unsigned int v85; 
  unsigned int k; 
  unsigned int m; 
  unsigned int n; 
  unsigned __int16 TransientIndex; 
  bool v90; 
  __int64 v91; 
  __int128 v92; 
  bool IsLoadModeInFrontend; 
  unsigned __int64 CurCost; 
  const dvar_t *v95; 
  int v96; 
  unsigned __int64 tileBudget; 
  const char *v98; 
  const char *v99; 
  __int128 v100; 
  unsigned int v101; 
  unsigned int ii; 
  __int64 v103; 
  const char *v104; 
  const char *v105; 
  const char *v106; 
  __int128 v107; 
  unsigned int jj; 
  const dvar_t *v109; 
  TransientWorldStreamSyncDrawRequest *v110; 
  unsigned int v111; 
  const vec3_t *p_pos; 
  float *visRadius; 
  const dvar_t *v114; 
  unsigned int v115; 
  unsigned __int16 *priorityOrder; 
  __int64 v117; 
  unsigned __int64 v118; 
  unsigned __int64 v119; 
  unsigned int v120; 
  const char *v121; 
  const dvar_t *v122; 
  const char *v123; 
  __int128 v124; 
  const vec4_t *v125; 
  __int128 v126; 
  const char *v127; 
  char *fmt; 
  __int64 clipMode; 
  char *label; 
  unsigned int v131; 
  unsigned int v132; 
  vec2_t screenBoundsMin[2]; 
  vec4_t color; 
  vec2_t screenBoundsMax; 
  CL_DebugMapOverlay context; 
  Bounds worldBounds; 
  vec4_t v139; 
  MemBudget_PollData dest; 
  vec4_t v141[2]; 
  __int64 v142; 
  __int64 v143; 
  __int64 v144; 
  __int64 v145; 

  v2 = alloca(v1);
  *(__m256i *)v141[0].v = _ymm;
  v139 = (vec4_t)_xmm;
  ActivePlacement = ScrPlace_GetActivePlacement(screenLocalClient);
  if ( !ActivePlacement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5186, ASSERT_TYPE_ASSERT, "(scrPlace)", (const char *)&queryFormat, "scrPlace") )
    __debugbreak();
  v5 = LODWORD(FLOAT_N15_0);
  v6 = 0;
  v131 = 0;
  v7 = 0;
  if ( s_transientsWorldMP.fileBackedTransientCount )
  {
    do
    {
      v8 = s_transientsWorldMP.priorityOrder[v7];
      if ( s_transientsWorldMP.priorityOrder[v7] )
      {
        if ( (unsigned int)v8 >= 0x600 )
        {
          LODWORD(label) = 1536;
          LODWORD(clipMode) = s_transientsWorldMP.priorityOrder[v7];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", clipMode, label) )
            __debugbreak();
        }
        if ( ((0x80000000 >> (v8 & 0x1F)) & s_transientsWorldMP.requested.array[v8 >> 5]) != 0 )
          ++v6;
      }
      ++v7;
    }
    while ( v7 < s_transientsWorldMP.fileBackedTransientCount );
    v131 = v6;
  }
  v9 = 0;
  v10 = 0.0;
  *(_QWORD *)color.v = 0i64;
  color.v[2] = 0.0;
  if ( (unsigned int)screenLocalClient >= LOCAL_CLIENT_COUNT )
  {
    LODWORD(label) = 2;
    LODWORD(clipMode) = screenLocalClient;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1193, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", clipMode, label) )
      __debugbreak();
  }
  if ( screenLocalClient >= cg_t::ms_allocatedCount )
  {
    v16 = *(double *)color.v;
  }
  else
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(screenLocalClient);
    p_view = &LocalClientGlobals->refdef.view;
    if ( LocalClientGlobals == (cg_t *)-26928i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\renderer\\tr_types.h", 1316, ASSERT_TYPE_ASSERT, "(refdefView)", (const char *)&queryFormat, "refdefView") )
      __debugbreak();
    refdefViewOrg_aab = p_view->refdefViewOrg_aab;
    v = (_DWORD *)p_view->org.org.v;
    if ( !v && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\renderer\\tr_types.h", 1284, ASSERT_TYPE_ASSERT, "(viewOrg)", (const char *)&queryFormat, "viewOrg") )
      __debugbreak();
    LODWORD(screenBoundsMin[0].v[0]) = *v ^ ((refdefViewOrg_aab ^ (unsigned int)v) * ((refdefViewOrg_aab ^ (unsigned int)v) + 2));
    LODWORD(screenBoundsMin[0].v[1]) = v[1] ^ ((refdefViewOrg_aab ^ ((_DWORD)v + 4)) * ((refdefViewOrg_aab ^ ((_DWORD)v + 4)) + 2));
    LODWORD(screenBoundsMax.v[0]) = refdefViewOrg_aab ^ ((_DWORD)v + 8);
    v15 = v[2] ^ (LODWORD(screenBoundsMax.v[0]) * (LODWORD(screenBoundsMax.v[0]) + 2));
    v16 = *(double *)screenBoundsMin;
    *(double *)color.v = *(double *)screenBoundsMin;
    v10 = *(float *)&v15;
    LODWORD(color.v[2]) = v15;
    v9 = 1;
    memset(screenBoundsMin, 0, 0xCui64);
  }
  CL_DebugMapOverlay::CL_DebugMapOverlay(&context);
  v17 = DVARFLT_cl_transientWorldOverlayZoom;
  if ( !DVARFLT_cl_transientWorldOverlayZoom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v17);
  v18 = 0i64;
  if ( v17->current.value == 0.0 || !v9 )
  {
    if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3887, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo") )
      __debugbreak();
    transientWorldGridTileMaps = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps;
    gridCountX = (float)transientWorldGridTileMaps->gridCountX;
    v33 = gridCountX * transientWorldGridTileMaps->cellSize;
    v34 = 0i64;
    *(float *)&v34 = (float)transientWorldGridTileMaps->gridCountY;
    *(float *)&v34 = *(float *)&v34 * transientWorldGridTileMaps->cellSize;
    _XMM5 = v34;
    __asm { vmaxss  xmm1, xmm5, xmm4 }
    if ( *(float *)&_XMM1 <= 100000.0 )
      v37 = FLOAT_0_003;
    else
      v37 = 300.0 / *(float *)&_XMM1;
    v142 = *(_QWORD *)&transientWorldGridTileMaps->minX;
    *(float *)&v143 = 0.0;
    v39 = (unsigned int)v142;
    *(float *)&v39 = *(float *)&v142 + v33;
    v38 = v39;
    *((float *)&v143 + 1) = *(float *)&v142 + v33;
    v41 = _XMM5;
    *(float *)&v41 = *(float *)&_XMM5 + *((float *)&v142 + 1);
    v40 = v41;
    *(float *)&v144 = *(float *)&_XMM5 + *((float *)&v142 + 1);
    *((float *)&v144 + 1) = 0.0;
    worldBounds.midPoint.v[0] = (float)(*(float *)&v142 + (float)(*(float *)&v142 + v33)) * 0.5;
    worldBounds.midPoint.v[1] = (float)(*((float *)&v142 + 1) + (float)(*(float *)&_XMM5 + *((float *)&v142 + 1))) * 0.5;
    worldBounds.midPoint.v[2] = 0.0;
    v43 = v38;
    *(float *)&v43 = *(float *)&v38 - worldBounds.midPoint.v[0];
    _XMM0 = v43;
    v45 = v40;
    *(float *)&v45 = *(float *)&v40 - worldBounds.midPoint.v[1];
    _XMM1 = v45;
    __asm { vmaxss  xmm0, xmm0, xmm2 }
    worldBounds.halfSize.v[0] = *(float *)&_XMM0;
    __asm { vmaxss  xmm1, xmm1, xmm3 }
    worldBounds.halfSize.v[1] = *(float *)&_XMM1;
    worldBounds.halfSize.v[2] = 0.0;
    v48 = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v48);
    screenBoundsMin[0] = *(vec2_t *)&v48->current.enabled;
    CL_DebugMapOverlay::InitFromScale(&context, ActivePlacement, screenBoundsMin, v37, &worldBounds);
  }
  else
  {
    v19 = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps;
    v20 = (float)v19->gridCountX;
    v21 = (float)(v20 * 0.5) * v19->cellSize;
    v22 = 0i64;
    *(float *)&v22 = (float)v19->gridCountY;
    *(float *)&v22 = *(float *)&v22 * 0.5;
    v23 = v22;
    v24 = *(float *)&v22 * v19->cellSize;
    *(float *)&v23 = CL_TransientsWorldMP_GetVisibilityRadius(1u, (const vec3_t *)&color);
    _XMM6 = v23;
    CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(0);
    __asm { vmaxss  xmm6, xmm6, xmm2 }
    v27 = DVARFLT_cl_transientWorldOverlayZoom;
    if ( !DVARFLT_cl_transientWorldOverlayZoom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoom") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v27);
    value = v27->current.value;
    *(double *)worldBounds.midPoint.v = v16;
    worldBounds.midPoint.v[2] = v10;
    worldBounds.halfSize.v[0] = (float)(v21 * (float)(1.0 - value)) + (float)(value * *(float *)&_XMM6);
    worldBounds.halfSize.v[1] = (float)((float)(1.0 - value) * v24) + (float)(value * *(float *)&_XMM6);
    worldBounds.halfSize.v[2] = 0.0;
    v29 = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v29);
    screenBoundsMin[0] = *(vec2_t *)&v29->current.enabled;
    v30 = DVARVEC2_cl_transientWorldOverlayZoomScreenSize;
    if ( !DVARVEC2_cl_transientWorldOverlayZoomScreenSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoomScreenSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v30);
    screenBoundsMax = *(vec2_t *)&v30->current.enabled;
    CL_DebugMapOverlay::Init(&context, ActivePlacement, screenBoundsMin, &screenBoundsMax, &worldBounds);
  }
  v142 = 0i64;
  v143 = 0i64;
  v144 = 0i64;
  v145 = 0i64;
  v49 = 0i64;
  if ( v9 )
  {
    worldGridInfo = s_transientsWorldMP.worldGridInfo;
    transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
    if ( !transientWorldGridTileMapCount )
      goto LABEL_65;
    v52 = 0i64;
    v53 = transientWorldGridTileMapCount;
    do
    {
      v54 = &worldGridInfo->transientWorldGridTileMaps[v52];
      if ( v54->indexCount )
      {
        if ( v54->lodCount )
        {
          v55 = 0;
          if ( v54->gridCountY )
          {
            do
            {
              for ( i = 0; i < v54->gridCountX; ++i )
              {
                if ( CL_TransientsWorldMP_GridContainsPos((const vec3_t *)&color, v54, i, v55, 0) && v49 < 0x10 )
                  *((_WORD *)&v142 + v49++) = CL_TransientsWorldMP_GetTransientIndex(v54, i, v55, 0);
              }
              ++v55;
            }
            while ( v55 < v54->gridCountY );
            worldGridInfo = s_transientsWorldMP.worldGridInfo;
          }
        }
      }
      ++v52;
      --v53;
    }
    while ( v53 );
    if ( !v49 )
    {
LABEL_65:
      LOWORD(v142) = 0;
      v49 = 1i64;
    }
    memset_0(&dest, 0, 0x400ui64);
    Core_strcpy((char *)&dest, 0x400ui64, "Current model(s): ");
    v57 = 0;
    v58 = 0i64;
    do
    {
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(*((unsigned __int16 *)&v142 + v58));
      ProxyModel = CL_TransientsWorldMP_FindProxyModel(*HighLODLookups);
      if ( ProxyModel )
      {
        if ( v57 )
          I_strcat_truncate((char *)&dest, 0x400ui64, ", ");
        I_strcat_truncate((char *)&dest, 0x400ui64, ProxyModel->name);
      }
      v58 = ++v57;
    }
    while ( v57 < v49 );
    v61 = 0i64;
    v62 = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v62);
    v63 = v62->current.value;
    v64 = v62->current.vector.v[1] - 15.0;
    screenBoundsMin[0].v[0] = v63 + 10.0;
    screenBoundsMin[0].v[1] = v64 + 10.0;
    screenBoundsMax.v[0] = v63;
    screenBoundsMax.v[1] = v64;
    CL_DebugMapOverlay::DrawFilledRect2D(&context, &screenBoundsMax, screenBoundsMin, &WORLDMP_INVIS_COLOR, Unclipped);
    screenBoundsMin[0].v[0] = (float)(v63 + 10.0) + 2.0;
    screenBoundsMin[0].v[1] = v64 + 8.0;
    CL_DebugMapOverlay::DrawText2D(&context, screenBoundsMin, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, 0.15000001, &colorWhite, Unclipped, (const char *)&dest);
    Core_strcpy((char *)&dest, 0x400ui64, "Current zone(s): ");
    for ( j = 0; j < v49; v61 = ++j )
    {
      if ( j )
        I_strcat_truncate((char *)&dest, 0x400ui64, ", ");
      I_strcat_truncate((char *)&dest, 0x400ui64, s_transientsWorldMP.worldGridInfo->transientFiles[*((unsigned __int16 *)&v142 + v61)].name);
    }
    v66 = DVARVEC2_cl_transientWorldOverlayOffset;
    if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v66);
    v67 = v66->current.value;
    v68 = v66->current.vector.v[1] - 25.0;
    screenBoundsMin[0].v[0] = v67 + 10.0;
    screenBoundsMin[0].v[1] = v68 + 10.0;
    screenBoundsMax.v[0] = v67;
    screenBoundsMax.v[1] = v68;
    CL_DebugMapOverlay::DrawFilledRect2D(&context, &screenBoundsMax, screenBoundsMin, &WORLDMP_INVIS_COLOR, Unclipped);
    screenBoundsMin[0].v[0] = (float)(v67 + 10.0) + 2.0;
    screenBoundsMin[0].v[1] = v68 + 8.0;
    CL_DebugMapOverlay::DrawText2D(&context, screenBoundsMin, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, 0.15000001, &colorWhite, Unclipped, (const char *)&dest);
    v5 = LODWORD(FLOAT_N35_0);
    v69 = DVARBOOL_cl_transientWorldStreamLookAheadEnabled;
    if ( !DVARBOOL_cl_transientWorldStreamLookAheadEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v69);
    if ( v69->current.enabled )
    {
      v70 = fsqrt((float)((float)(s_transientsWorldMP.lastVelocityClient0.v[0] * s_transientsWorldMP.lastVelocityClient0.v[0]) + (float)(s_transientsWorldMP.lastVelocityClient0.v[1] * s_transientsWorldMP.lastVelocityClient0.v[1])) + (float)(s_transientsWorldMP.lastVelocityClient0.v[2] * s_transientsWorldMP.lastVelocityClient0.v[2]));
      v71 = DVARFLT_cl_transientWorldStreamLookAheadMaxDist;
      if ( !DVARFLT_cl_transientWorldStreamLookAheadMaxDist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadMaxDist") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v71);
      v72 = v71->current.value;
      v73 = DVARFLT_cl_transientWorldStreamLookAheadTime;
      if ( !DVARFLT_cl_transientWorldStreamLookAheadTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldStreamLookAheadTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v73);
      unsignedInt = v73->current.unsignedInt;
      v76 = unsignedInt;
      *(float *)&v76 = *(float *)&unsignedInt * v70;
      _XMM1 = v76;
      __asm { vminss  xmm0, xmm1, xmm6 }
      Com_sprintf<1024>((char (*)[1024])&dest, "LookAhead Vel=%.0f Time=%.2f Lookahead=%.0f Cap=%.0f Result=%.0f", v70, *(float *)&unsignedInt, (float)(*(float *)&unsignedInt * v70), v72, *(float *)&_XMM0);
      v78 = DVARVEC2_cl_transientWorldOverlayOffset;
      if ( !DVARVEC2_cl_transientWorldOverlayOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayOffset") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v78);
      v79 = v78->current.value;
      v80 = v78->current.vector.v[1] - 35.0;
      screenBoundsMin[0].v[0] = v79 + 10.0;
      screenBoundsMin[0].v[1] = v80 + 10.0;
      screenBoundsMax.v[0] = v79;
      screenBoundsMax.v[1] = v80;
      CL_DebugMapOverlay::DrawFilledRect2D(&context, &screenBoundsMax, screenBoundsMin, &WORLDMP_INVIS_COLOR, Unclipped);
      screenBoundsMin[0].v[0] = (float)(v79 + 10.0) + 2.0;
      screenBoundsMin[0].v[1] = v80 + 8.0;
      CL_DebugMapOverlay::DrawText2D(&context, screenBoundsMin, &CL_DebugMapOverlay::TEXT_ANCHOR_BOTTOMLEFT, 0.15000001, &colorWhite, Unclipped, (const char *)&dest);
      v5 = LODWORD(FLOAT_N45_0);
    }
    v6 = v131;
  }
  v132 = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  v81 = 0;
  if ( v132 )
  {
    v82 = 0i64;
    screenBoundsMin[0] = 0i64;
    do
    {
      v83 = (TransientWorldGridTileMap *)((char *)s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps + *(_QWORD *)&v82);
      if ( v83->indexCount )
      {
        v84 = DVARBOOL_cl_transientWorldOverlayBounds;
        if ( !DVARBOOL_cl_transientWorldOverlayBounds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayBounds") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v84);
        if ( !v84->current.enabled )
        {
          v85 = 0;
          if ( v83->gridCountY )
          {
            do
            {
              for ( k = 0; k < v83->gridCountX; ++k )
              {
                if ( CL_TransientsWorldMP_GetTransientIndex(v83, k, v85, 0) )
                  CL_TransientsWorldMP_DrawCell(&context, k, v85, v81, v6);
              }
              ++v85;
            }
            while ( v85 < v83->gridCountY );
            v82 = screenBoundsMin[0];
          }
        }
        for ( m = 0; m < v83->gridCountY; ++m )
        {
          for ( n = 0; n < v83->gridCountX; ++n )
          {
            TransientIndex = CL_TransientsWorldMP_GetTransientIndex(v83, n, m, 0);
            if ( TransientIndex )
            {
              v90 = 0;
              v91 = 0i64;
              if ( v49 )
              {
                while ( *((_WORD *)&v142 + v91) != TransientIndex )
                {
                  if ( ++v91 >= v49 )
                    goto LABEL_119;
                }
                v90 = 1;
              }
LABEL_119:
              CL_TransientsWorldMP_DrawCellOutline(&context, n, m, v81, v90);
            }
          }
        }
      }
      ++v81;
      *(_QWORD *)&v82 += 40i64;
      screenBoundsMin[0] = v82;
    }
    while ( v81 < v132 );
  }
  color = CELL_STATE_COLORS[12];
  CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(const float *)&v5, &color, "Visible Falling Hint");
  color = CELL_STATE_COLORS[7];
  CL_TransientsWorldMP_DrawLegend(&context, 85.0, *(const float *)&v5, &color, "Want visibility, no mem for tile");
  v92 = v5;
  color = CELL_STATE_COLORS[10];
  CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(float *)&v5 + -10.0, &color, "Visible Bad Quality");
  color = CELL_STATE_COLORS[6];
  CL_TransientsWorldMP_DrawLegend(&context, 85.0, *(float *)&v5 + -10.0, &color, "Want visibility, tile not loaded yet");
  *(float *)&v92 = (float)(*(float *)&v5 + -10.0) + -10.0;
  color = CELL_STATE_COLORS[9];
  CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(const float *)&v92, &color, "Visible Good Quality");
  color = CELL_STATE_COLORS[8];
  CL_TransientsWorldMP_DrawLegend(&context, 85.0, *(const float *)&v92, &color, "Want visibility, waiting for quality bar or timeout");
  *(float *)&v92 = *(float *)&v92 + -10.0;
  color = CELL_STATE_COLORS[3];
  CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(const float *)&v92, &color, "Loaded");
  color = CELL_STATE_COLORS[4];
  CL_TransientsWorldMP_DrawLegend(&context, 85.0, *(const float *)&v92, &color, "Hinted, not wanting visibility yet. Bad Quality.");
  *(float *)&v92 = *(float *)&v92 + -10.0;
  color = CELL_STATE_COLORS[2];
  CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(const float *)&v92, &color, "Loading");
  color = CELL_STATE_COLORS[5];
  CL_TransientsWorldMP_DrawLegend(&context, 85.0, *(const float *)&v92, &color, "Hinted, not wanting visibility yet. Good Quality.");
  *(float *)&v92 = *(float *)&v92 + -10.0;
  IsLoadModeInFrontend = CL_TransientsMP_IsLoadModeInFrontend();
  CurCost = TransientCostCalc_GetCurCost(&s_transientsWorldMP.worldCost, IsLoadModeInFrontend);
  if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    goto LABEL_129;
  v95 = DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB;
  if ( !DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverrideTileBudgetMB") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v95);
  v96 = v95->current.integer << 20;
  tileBudget = v96;
  if ( !v96 )
LABEL_129:
    tileBudget = s_transientsWorldMP.tileBudget;
  v98 = j_va("%zu / %zu mb worldtilemem used", CurCost >> 20, tileBudget >> 20);
  CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(const float *)&v92, &WORLDMP_INVIS_COLOR, v98);
  *(float *)&v92 = *(float *)&v92 + -10.0;
  if ( MemBudget_Poll_FramesSinceLastUpdate() <= 0x3C )
  {
    MemBudget_Poll_GetLastUpdateForHUD(&dest);
    v99 = j_va("%zu mb streamer slop", (unsigned __int64)(dest.readings.pollValues[8] + dest.readings.pollValues[9]) >> 20);
  }
  else
  {
    v99 = "? streamer slop";
  }
  CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(const float *)&v92, &WORLDMP_INVIS_COLOR, v99);
  *(float *)&v92 = *(float *)&v92 + -10.0;
  v100 = v92;
  v101 = 0;
  for ( ii = 0; ii < s_transientsWorldMP.numStreamPositions; ++ii )
  {
    if ( ii >= 0xE )
    {
      LODWORD(label) = 14;
      LODWORD(clipMode) = ii;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5410, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "i doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", clipMode, label) )
        __debugbreak();
    }
    v103 = ii;
    if ( s_transientsWorldMP.streamPositions[v103].mainCamera )
    {
      if ( v101 >= 2 )
      {
        LODWORD(label) = 2;
        LODWORD(clipMode) = v101;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 5413, ASSERT_TYPE_ASSERT, "(unsigned)( renderIndex ) < (unsigned)( ( sizeof( *array_counter( ARROW_COLOR ) ) + 0 ) )", "renderIndex doesn't index ARRAY_COUNT( ARROW_COLOR )\n\t%i not in [0, %i)", clipMode, label) )
          __debugbreak();
      }
      CL_DebugMapOverlay::DrawArrow(&context, &s_transientsWorldMP.streamPositions[v103].pos, &s_transientsWorldMP.streamPositions[v103].angles, 10.0, &v141[v101], Unclipped);
      if ( s_transientsWorldMP.streamPositions[v103].zoomLoad )
      {
        CL_TransientsWorldMP_DrawPlayerFOV(&context, &s_transientsWorldMP.streamPositions[v103]);
        v104 = "false";
        if ( s_transientsWorldMP.streamPositions[v103].zoomLoad )
          v104 = "true";
        v105 = "false";
        if ( s_transientsWorldMP.streamPositions[v103].zoomVisibility )
          v105 = "true";
        v106 = j_va("FOV: %.2f, Distance0: %.2f, Distance1: %.2f, ZoomVisibility: %s, ZoomLoad: %s", s_transientsWorldMP.streamPositions[v103].fovLerpTarget, s_transientsWorldMP.streamPositions[v103].zoomLODDist[0], s_transientsWorldMP.streamPositions[v103].zoomLODDist[1], v105, v104);
        CL_TransientsWorldMP_DrawLegend(&context, 0.0, *(const float *)&v100, &WORLDMP_INVIS_COLOR, v106);
        v107 = v100;
        *(float *)&v107 = *(float *)&v100 + -10.0;
        v100 = v107;
      }
      ++v101;
    }
  }
  for ( jj = 0; jj < s_transientsWorldMP.numStreamPositions; ++jj )
    CL_TransientsWorldMP_DrawStreamingPos(&context, &v139, &s_transientsWorldMP.streamPositions[jj]);
  v109 = DCONST_DVARBOOL_cl_transientWorldOverlayStreamSync;
  if ( !DCONST_DVARBOOL_cl_transientWorldOverlayStreamSync && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayStreamSync") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v109);
  if ( v109->current.enabled )
  {
    if ( (unsigned int)screenLocalClient >= LOCAL_CLIENT_COUNT )
    {
      LODWORD(label) = 2;
      LODWORD(clipMode) = screenLocalClient;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4685, ASSERT_TYPE_ASSERT, "(unsigned)( screenLocalClient ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamSyncDraw ) ) + 0 ) )", "screenLocalClient doesn't index s_transientsWorldMP.streamSyncDraw\n\t%i not in [0, %i)", clipMode, label) )
        __debugbreak();
    }
    v110 = &s_transientsWorldMP.streamSyncDraw[screenLocalClient];
    if ( v110->requestEndTime > Sys_Milliseconds() )
    {
      v111 = 0;
      p_pos = &v110->pos;
      visRadius = v110->params.visRadius;
      do
      {
        CL_DebugMapOverlay::DrawCircle(&context, p_pos, *visRadius, &colorRed, Unclipped);
        ++v111;
        ++visRadius;
      }
      while ( v111 < 2 );
    }
  }
  v114 = DVARBOOL_cl_transientWorldOverlayPriorityList;
  if ( !DVARBOOL_cl_transientWorldOverlayPriorityList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityList") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v114);
  if ( v114->current.enabled )
  {
    v115 = 0;
    priorityOrder = s_transientsWorldMP.priorityOrder;
    v117 = 200i64;
    do
    {
      v118 = *priorityOrder;
      if ( (unsigned int)v118 >= 0x600 )
      {
        LODWORD(label) = 1536;
        LODWORD(clipMode) = *priorityOrder;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", clipMode, label) )
          __debugbreak();
      }
      v119 = v118;
      if ( ((0x80000000 >> (v118 & 0x1F)) & s_transientsWorldMP.requested.array[v118 >> 5]) != 0 )
      {
        v120 = s_transientsWorldMP.lastTrPriority[v118];
        LODWORD(fmt) = v120;
        v121 = j_va("%d (LOD%u) %.3f Pri=%u", (unsigned int)v118, s_transientsWorldMP.transientLODIndex[v118], s_transientsWorldMP.priorityList[v118].loadDistanceSq, fmt);
        v122 = DCONST_DVARBOOL_cl_transientWorldOverlayPriorityListSkipLod1;
        if ( !DCONST_DVARBOOL_cl_transientWorldOverlayPriorityListSkipLod1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayPriorityListSkipLod1") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v122);
        if ( v122->current.enabled && s_transientsWorldMP.transientLODIndex[v119] )
        {
          ++v115;
        }
        else
        {
          if ( v115 )
          {
            v123 = j_va("%u LOD1 tiles", v115);
            CL_TransientsWorldMP_DrawLegend(&context, 250.0, *(const float *)&v18, &WORLDMP_INVIS_COLOR, v123);
            v124 = v18;
            *(float *)&v124 = *(float *)&v18 + 7.5;
            v18 = v124;
            v115 = 0;
          }
          v125 = &WORLDMP_INVIS_COLOR;
          if ( v120 - 5976 <= 5 )
            v125 = &colorRed;
          CL_TransientsWorldMP_DrawLegend(&context, 250.0, *(const float *)&v18, v125, v121);
          v126 = v18;
          *(float *)&v126 = *(float *)&v18 + 7.5;
          v18 = v126;
        }
      }
      ++priorityOrder;
      --v117;
    }
    while ( v117 );
    if ( v115 )
    {
      v127 = j_va("%u LOD1 tiles", v115);
      CL_TransientsWorldMP_DrawLegend(&context, 250.0, *(const float *)&v18, &WORLDMP_INVIS_COLOR, v127);
    }
  }
  CL_DebugMapOverlay::~CL_DebugMapOverlay(&context);
}

/*
==============
CL_TransientsWorldMP_DrawStreamingPos
==============
*/
void CL_TransientsWorldMP_DrawStreamingPos(CL_DebugMapOverlay *context, const vec4_t *color, const WorldStreamPosition *streamPos)
{
  const dvar_t *v3; 
  const vec4_t *v5; 
  float value; 
  const dvar_t *v8; 
  __int64 transientWorldGridTileMapCount; 
  __int64 v11; 
  const TransientWorldGridTileMap *v12; 
  unsigned int v13; 
  float v14; 
  unsigned int i; 
  const Bounds *TileBounds; 
  unsigned __int128 v18; 
  unsigned int v19; 
  float *v20; 
  float loadDistLimitSq; 
  unsigned __int128 v22; 
  float v23; 
  float v24; 
  float v25; 
  const dvar_t *v26; 
  float v27; 
  const dvar_t *v28; 
  unsigned __int128 v29; 
  float v30; 
  const dvar_t *v31; 
  bool v32; 
  int v33[2]; 
  const vec4_t *v34; 
  __int64 v35; 
  __int64 v36; 
  vec3_t outCenter; 
  vec3_t outPointToClosestVec; 
  vec3_t angles; 
  vec3_t mins; 
  vec3_t maxs; 

  v3 = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0;
  v34 = color;
  v5 = color;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  value = v3->current.value;
  v8 = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1;
  *(float *)v33 = value;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  _XMM0 = v8->current.unsignedInt;
  v33[1] = v8->current.integer;
  transientWorldGridTileMapCount = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount;
  if ( !(_DWORD)transientWorldGridTileMapCount )
    return;
  v11 = 0i64;
  v35 = 0i64;
  v36 = transientWorldGridTileMapCount;
  do
  {
    v12 = (TransientWorldGridTileMap *)((char *)s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps + v11);
    if ( !v12->indexCount )
      goto LABEL_48;
    if ( !streamPos->mainCamera )
    {
      angles.v[0] = 0.0;
      angles.v[1] = 0.0;
      angles.v[2] = 0.0;
      CL_DebugMapOverlay::DrawImage(context, &streamPos->pos, &angles, 10.0, v5, Unclipped, cgMedia.objectiveMaterials[0]);
      goto LABEL_48;
    }
    CL_TransientsWorldMP_GetVisibilityCenterPos(streamPos, &outCenter);
    v13 = 0;
    v14 = FLOAT_3_4028235e38;
    for ( LODWORD(_XMM7) = 0; v13 < v12->gridCountY; ++v13 )
    {
      for ( i = 0; i < v12->gridCountX; ++i )
      {
        TileBounds = CL_TransientsWorldMP_GetTileBounds(v12, i, v13, 0);
        mins.v[0] = TileBounds->midPoint.v[0] - TileBounds->halfSize.v[0];
        mins.v[1] = TileBounds->midPoint.v[1] - TileBounds->halfSize.v[1];
        mins.v[2] = TileBounds->midPoint.v[2] - TileBounds->halfSize.v[2];
        maxs.v[0] = TileBounds->midPoint.v[0] + TileBounds->halfSize.v[0];
        maxs.v[1] = TileBounds->halfSize.v[1] + TileBounds->midPoint.v[1];
        maxs.v[2] = TileBounds->halfSize.v[2] + TileBounds->midPoint.v[2];
        PointToClosestAABBPoint(&mins, &maxs, &outCenter, &outPointToClosestVec);
        v18 = LODWORD(outPointToClosestVec.v[1]);
        *(float *)&v18 = (float)(outPointToClosestVec.v[1] * outPointToClosestVec.v[1]) + (float)(outPointToClosestVec.v[0] * outPointToClosestVec.v[0]);
        _XMM0 = v18;
        if ( *(float *)&v18 <= v14 )
        {
          v14 = (float)(outPointToClosestVec.v[1] * outPointToClosestVec.v[1]) + (float)(outPointToClosestVec.v[0] * outPointToClosestVec.v[0]);
          _XMM0 = LODWORD(outPointToClosestVec.v[2]) & (unsigned __int128)(unsigned int)_xmm;
          __asm { vmaxss  xmm7, xmm0, xmm7 }
        }
      }
    }
    v19 = 0;
    v20 = (float *)v33;
    do
    {
      if ( v12->level && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4626, ASSERT_TYPE_ASSERT, "(tileMap.level == 0)", (const char *)&queryFormat, "tileMap.level == 0") )
        __debugbreak();
      *(float *)&_XMM0 = CL_TransientsWorldMP_GetVisibilityRadius(v19, &streamPos->pos);
      loadDistLimitSq = streamPos->loadDistLimitSq;
      v22 = _XMM0;
      v23 = *(float *)&_XMM0 * *(float *)&_XMM0;
      v24 = (float)(*(float *)&_XMM7 * *v20) * (float)(*(float *)&_XMM7 * *v20);
      if ( (loadDistLimitSq == 0.0 || v23 < loadDistLimitSq) && v23 > (float)((float)(*(float *)&_XMM7 * *v20) * (float)(*(float *)&_XMM7 * *v20)) )
      {
        v25 = fsqrt(v23 - v24);
        CL_DebugMapOverlay::DrawCircle(context, &outCenter, v25, &CL_DebugMapOverlay::WHITE_COLOR, Unclipped);
        if ( v19 )
        {
          v31 = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1;
          if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl1") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v31);
          _XMM0 = v31->current.unsignedInt;
          if ( *(float *)&_XMM0 != 0.0 && v25 > *(float *)&_XMM0 )
          {
            v30 = v25 - *(float *)&_XMM0;
LABEL_42:
            CL_DebugMapOverlay::DrawCircle(context, &outCenter, v30, &colorBlue, Unclipped);
          }
        }
        else
        {
          v26 = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0;
          if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl0") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v26);
          v27 = v26->current.value;
          if ( v27 != 0.0 && v25 > v27 )
            CL_DebugMapOverlay::DrawCircle(context, &outCenter, v25 - v27, &colorBlue, Unclipped);
          v28 = DVARFLT_cl_transientWorldVisibleHintLOD0Addition;
          if ( !DVARFLT_cl_transientWorldVisibleHintLOD0Addition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLOD0Addition") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v28);
          v29 = v22;
          *(float *)&v29 = *(float *)&v22 + v28->current.value;
          _XMM0 = v29;
          v30 = fsqrt((float)(*(float *)&v29 * *(float *)&v29) - v24);
          if ( v30 != 0.0 )
            goto LABEL_42;
        }
      }
      ++v19;
      ++v20;
    }
    while ( v19 < 2 );
    _XMM0 = LODWORD(streamPos->loadDistLimitSq);
    v11 = v35;
    if ( *(float *)&_XMM0 != 0.0 )
    {
      _XMM0 &= (unsigned int)_xmm;
      CL_DebugMapOverlay::DrawCircle(context, &outCenter, fsqrt(*(float *)&_XMM0), &colorRed, Unclipped);
    }
    v5 = v34;
LABEL_48:
    v11 += 40i64;
    v32 = v36-- == 1;
    v35 = v11;
  }
  while ( !v32 );
}

/*
==============
CL_TransientsWorldMP_EndListenServerStall
==============
*/
void CL_TransientsWorldMP_EndListenServerStall(void)
{
  if ( !Sys_IsServerThread() && !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3755, ASSERT_TYPE_ASSERT, "(Sys_IsServerThread() || Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsServerThread() || Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.listenServerStall = 0;
}

/*
==============
CL_TransientsWorldMP_ErrorCleanup
==============
*/
void CL_TransientsWorldMP_ErrorCleanup(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3763, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  *(_WORD *)&s_transientsWorldMP.lobbyPreloadStopped = 0;
}

/*
==============
CL_TransientsWorldMP_FillGridStreamingPosViewInfo
==============
*/
void CL_TransientsWorldMP_FillGridStreamingPosViewInfo(const LocalClientNum_t localClientNum, const bool streamRender, const bool mainCamera, WorldStreamPosition *worldStreamPos)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  cg_t *v10; 
  CgWeaponMap *v11; 
  bool IsUsingOffhandGestureWeaponADSSupport; 
  const Weapon *OffhandGestureWeapon; 
  const Weapon *v14; 
  __int64 p_weapFlags; 
  bool v16; 
  double OffhandAdsFrac; 
  float correctedWeaponPosFrac; 
  bool v19; 
  bool v20; 
  double WeaponZoom; 
  float v22; 
  double Float_Internal_DebugName; 
  double v24; 
  CgHandler *Handler; 
  double v26; 
  float v27; 
  double v28; 
  bool v29; 
  double v30; 
  bool v31; 
  bool v32; 
  double v33; 
  double v34; 
  double v35; 
  float v36; 
  double v37; 
  double v38; 
  float v39; 
  double v40; 
  __int128 v41; 
  float v42; 
  float v43; 
  __int128 v44; 
  float fovYPadding; 
  float adsZoomOutFrac; 
  ClientFov result; 
  vec3_t forward; 
  __int64 v52; 

  v4 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1193, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (int)v4 >= cg_t::ms_allocatedCount || !streamRender || !mainCamera )
  {
    *(_QWORD *)&worldStreamPos->fovCurrent = 0i64;
    *(_WORD *)&worldStreamPos->zoomVisibility = 0;
    worldStreamPos->viewDir = 0i64;
    *(_QWORD *)worldStreamPos->viewDir3D.v = 0i64;
    worldStreamPos->viewDir3D.v[2] = 0.0;
    return;
  }
  v52 = *(_QWORD *)&CG_GetViewFovBySpace(&result, (const LocalClientNum_t)v4, CG_FovSpace_Scene, 1)->finalFov;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3206, ASSERT_TYPE_ASSERT, "(predictedPlayerState)", (const char *)&queryFormat, "predictedPlayerState") )
    __debugbreak();
  v10 = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v11 = CgWeaponMap::ms_instance[v4];
  IsUsingOffhandGestureWeaponADSSupport = BG_IsUsingOffhandGestureWeaponADSSupport(v11, p_predictedPlayerState);
  if ( IsUsingOffhandGestureWeaponADSSupport )
    OffhandGestureWeapon = BG_GetOffhandGestureWeapon(v11, p_predictedPlayerState);
  else
    OffhandGestureWeapon = BG_GetCurrentWeaponForPlayer(v11, p_predictedPlayerState);
  v14 = OffhandGestureWeapon;
  if ( p_predictedPlayerState )
  {
    p_weapFlags = (__int64)&p_predictedPlayerState->weapCommon.weapFlags;
    if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x22u) )
      goto LABEL_18;
  }
  else
  {
    p_weapFlags = 1832i64;
  }
  if ( p_predictedPlayerState && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)p_weapFlags, ACTIVE, 0x11u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)p_weapFlags, ACTIVE, 0x1Bu)) && !IsUsingOffhandGestureWeaponADSSupport )
  {
    v16 = 1;
    goto LABEL_26;
  }
LABEL_18:
  v16 = 0;
  if ( IsUsingOffhandGestureWeaponADSSupport )
  {
    OffhandAdsFrac = BG_GetOffhandAdsFrac(p_predictedPlayerState);
    correctedWeaponPosFrac = *(float *)&OffhandAdsFrac;
    goto LABEL_27;
  }
LABEL_26:
  correctedWeaponPosFrac = v10->weaponPosFracAnimData.correctedWeaponPosFrac;
LABEL_27:
  BG_GetADSZoomInFracs(v11, p_predictedPlayerState, v14, v16, 0, &fovYPadding, &adsZoomOutFrac);
  if ( fovYPadding == 0.0 && adsZoomOutFrac == 0.0 )
  {
    v19 = 1;
    v20 = 1;
  }
  else
  {
    WeaponZoom = CG_GetWeaponZoom(v10, v14, correctedWeaponPosFrac, CG_FovSpace_Scene);
    v22 = *(float *)&WeaponZoom;
    Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomCutoffLoad, "cl_transientWorldZoomCutoffLoad");
    v19 = v22 >= *(float *)&Float_Internal_DebugName;
    v24 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomCutoffVisibility, "cl_transientWorldZoomCutoffVisibility");
    v20 = v22 >= *(float *)&v24;
  }
  AngleVectors(&worldStreamPos->angles, &forward, NULL, NULL);
  Handler = CgHandler::getHandler((LocalClientNum_t)v4);
  v26 = BG_ADSZoomFov(Handler, p_predictedPlayerState, v14, v16);
  worldStreamPos->fovCurrent = *(float *)&v52;
  worldStreamPos->fovLerpTarget = *(float *)&v26;
  v27 = *(float *)&v26;
  v29 = 0;
  if ( v20 )
  {
    v28 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomVisibilityFovCutoff, "cl_transientWorldZoomVisibilityFovCutoff");
    if ( v27 <= *(float *)&v28 )
      v29 = 1;
  }
  worldStreamPos->zoomVisibility = v29;
  v31 = 0;
  if ( v19 )
  {
    v30 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLoadFovCutoff, "cl_transientWorldZoomLoadFovCutoff");
    if ( v27 <= *(float *)&v30 )
      v31 = 1;
  }
  v32 = !worldStreamPos->zoomVisibility;
  worldStreamPos->zoomLoad = v31;
  if ( !v32 )
  {
    if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_cl_transientWorldZoomFixedDist, "cl_transientWorldZoomFixedDist") )
    {
      v33 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD0FixedDist, "cl_transientWorldZoomLOD0FixedDist");
      worldStreamPos->zoomLODDist[0] = *(float *)&v33;
      v34 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD1FixedDist, "cl_transientWorldZoomLOD1FixedDist");
    }
    else
    {
      v35 = I_fclamp(v27, 1.0, 180.0);
      v36 = 60.0 / *(float *)&v35;
      v37 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD0Dist, "cl_transientWorldZoomLOD0Dist");
      worldStreamPos->zoomLODDist[0] = *(float *)&v37 * v36;
      v34 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomLOD1Dist, "cl_transientWorldZoomLOD1Dist");
      *(float *)&v34 = *(float *)&v34 * v36;
    }
    worldStreamPos->zoomLODDist[1] = *(float *)&v34;
    v38 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomFovYPadding, "cl_transientWorldZoomFovYPadding");
    v39 = *(float *)&v38;
    v40 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cl_transientWorldZoomFovXPadding, "cl_transientWorldZoomFovXPadding");
    CL_TransientsWorldMP_GetFrustumPlanes(v10, &worldStreamPos->pos, &forward, worldStreamPos->zoomLODDist[1], *(float *)&v40, v39, worldStreamPos->frustumPlanes);
  }
  v41 = LODWORD(forward.v[0]);
  v42 = forward.v[1];
  v43 = forward.v[2];
  *(double *)worldStreamPos->viewDir3D.v = *(double *)forward.v;
  v44 = v41;
  *(float *)&v44 = fsqrt((float)(*(float *)&v41 * *(float *)&v41) + (float)(v42 * v42));
  _XMM2 = v44;
  __asm
  {
    vcmpless xmm0, xmm2, cs:__real@80000000
    vblendvps xmm0, xmm2, xmm7, xmm0
  }
  worldStreamPos->viewDir3D.v[2] = v43;
  worldStreamPos->viewDir.v[1] = v42 * (float)(1.0 / *(float *)&_XMM0);
  worldStreamPos->viewDir.v[0] = *(float *)&v41 * (float)(1.0 / *(float *)&_XMM0);
}

/*
==============
CL_TransientsWorldMP_FindProxyModel
==============
*/
XModel *CL_TransientsWorldMP_FindProxyModel(const unsigned int transientIndex)
{
  GfxWorld *world; 
  unsigned __int16 *v3; 
  unsigned __int16 v4; 
  unsigned __int64 v5; 
  unsigned int v6; 
  int v7; 
  GfxStaticModelCollection *v8; 
  __int64 v10; 
  __int64 v11; 

  world = rgp.world;
  if ( !rgp.world )
    return 0i64;
  v3 = &s_transientsWorldMP.debugProxyModelIndex[transientIndex];
  v4 = *v3;
  if ( *v3 == 0xFFFF )
  {
    if ( transientIndex )
    {
      if ( transientIndex >= 0x600 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", transientIndex, 1536) )
          __debugbreak();
        world = rgp.world;
      }
      v5 = (unsigned __int64)transientIndex >> 5;
      v6 = 0x80000000 >> (transientIndex & 0x1F);
      if ( (v6 & s_transientsWorldMP.loaded.array[v5]) != 0 )
        goto LABEL_14;
      if ( transientIndex >= 0x600 )
      {
        LODWORD(v11) = 1536;
        LODWORD(v10) = transientIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v10, v11) )
          __debugbreak();
        world = rgp.world;
      }
      if ( (v6 & s_transientsWorldMP.transientsHighestLOD.array[v5]) != 0 )
      {
LABEL_14:
        v7 = 0;
        *v3 = -2;
        v4 = -2;
        if ( !world->smodels.collectionCount )
          goto LABEL_28;
        while ( 1 )
        {
          v8 = &world->smodels.collections[v7];
          if ( v8->firstInstance >= world->smodels.instanceCount )
          {
            LODWORD(v11) = world->smodels.instanceCount;
            LODWORD(v10) = v8->firstInstance;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2385, ASSERT_TYPE_ASSERT, "(unsigned)( collection.firstInstance ) < (unsigned)( rgp.world->smodels.instanceCount )", "collection.firstInstance doesn't index rgp.world->smodels.instanceCount\n\t%i not in [0, %i)", v10, v11) )
              __debugbreak();
            world = rgp.world;
          }
          if ( world->smodels.modelStaticIndirection[v8->firstInstance].worldTransient == transientIndex )
            break;
          if ( ++v7 >= world->smodels.collectionCount )
            goto LABEL_27;
        }
        if ( v8->smodelIndex >= world->smodels.modelCount )
        {
          LODWORD(v11) = world->smodels.modelCount;
          LODWORD(v10) = v8->smodelIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2389, ASSERT_TYPE_ASSERT, "(unsigned)( collection.smodelIndex ) < (unsigned)( rgp.world->smodels.modelCount )", "collection.smodelIndex doesn't index rgp.world->smodels.modelCount\n\t%i not in [0, %i)", v10, v11) )
            __debugbreak();
          world = rgp.world;
        }
        *v3 = v8->smodelIndex;
      }
    }
LABEL_27:
    v4 = *v3;
    if ( *v3 == 0xFFFF )
      return 0i64;
  }
LABEL_28:
  if ( v4 == 0xFFFE )
    return 0i64;
  if ( v4 >= world->smodels.modelCount )
  {
    LODWORD(v11) = world->smodels.modelCount;
    LODWORD(v10) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2397, ASSERT_TYPE_ASSERT, "(unsigned)( foundModelIndex ) < (unsigned)( rgp.world->smodels.modelCount )", "foundModelIndex doesn't index rgp.world->smodels.modelCount\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
    world = rgp.world;
  }
  return world->smodels.models[*v3].model;
}

/*
==============
CL_TransientsWorldMP_GetBudgetBytes
==============
*/
unsigned __int64 CL_TransientsWorldMP_GetBudgetBytes()
{
  const dvar_t *v0; 
  unsigned __int64 result; 

  if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    return s_transientsWorldMP.tileBudget;
  v0 = DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB;
  if ( !DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverrideTileBudgetMB") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  result = v0->current.integer << 20;
  if ( !(_DWORD)result )
    return s_transientsWorldMP.tileBudget;
  return result;
}

/*
==============
CL_TransientsWorldMP_GetCellState
==============
*/
__int64 CL_TransientsWorldMP_GetCellState(const unsigned int transientIndex)
{
  unsigned __int64 v1; 
  unsigned int v2; 
  unsigned __int64 v3; 
  int v4; 
  unsigned int *v5; 
  unsigned int i; 
  int v7; 
  unsigned int *j; 
  __int64 result; 
  bool v10; 
  unsigned int v11; 
  __int64 v12; 
  __int64 v13; 

  v1 = transientIndex;
  if ( !transientIndex || !s_transientsWorldMP.ignoreTransientSkip && transientIndex < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount && bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, transientIndex) )
    return 0i64;
  if ( (unsigned int)v1 >= 0x600 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v1, 1536) )
    __debugbreak();
  v2 = 0x80000000 >> (v1 & 0x1F);
  v3 = v1 >> 5;
  if ( (v2 & s_transientsWorldMP.missingModelTransients.array[v3]) != 0 )
    return 11i64;
  if ( (unsigned int)v1 >= 0x600 )
  {
    LODWORD(v13) = 1536;
    LODWORD(v12) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
      __debugbreak();
  }
  if ( (v2 & s_transientsWorldMP.requested.array[v3]) != 0 )
  {
    v4 = 0;
    v5 = &s_transientsWorldMP.visibleCurrent[0].array[v3];
    for ( i = 0; i < 2; ++i )
    {
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      if ( (v2 & *v5) != 0 )
      {
        if ( (unsigned int)v1 < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount && bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v1) )
          return 11i64;
        if ( (unsigned int)v1 >= 0x600 )
        {
          LODWORD(v13) = 1536;
          LODWORD(v12) = v1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
            __debugbreak();
        }
        if ( (v2 & s_transientsWorldMP.fallingHinted.array[v3]) != 0 )
          return 12i64;
        else
          return 10 - (unsigned int)Stream_TransientZoneStreamingQualitySufficient(v1);
      }
      v5 += 48;
    }
    if ( (unsigned int)v1 >= 0x600 )
    {
      LODWORD(v13) = 1536;
      LODWORD(v12) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
        __debugbreak();
    }
    if ( (v2 & s_transientsWorldMP.loaded.array[v3]) == 0 )
    {
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      v10 = (v2 & s_transientsWorldMP.wantVisibleButNotLoaded.array[v3]) == 0;
      result = 2i64;
      v11 = 6;
      goto LABEL_40;
    }
    v7 = 0;
    for ( j = &s_transientsWorldMP.visibleHint[0].array[v3]; ; j += 48 )
    {
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      if ( (v2 & *(j - 96)) != 0 )
        break;
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v13) = 1536;
        LODWORD(v12) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
          __debugbreak();
      }
      if ( (v2 & *j) != 0 )
      {
        LOBYTE(v4) = Stream_TransientZoneStreamingQualitySufficient(v1);
        return (unsigned int)(v4 + 4);
      }
      if ( (unsigned int)++v7 >= 2 )
        return 3i64;
    }
    return 8i64;
  }
  else
  {
    if ( (unsigned int)v1 >= 0x600 )
    {
      LODWORD(v13) = 1536;
      LODWORD(v12) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v12, v13) )
        __debugbreak();
    }
    v10 = (v2 & s_transientsWorldMP.wantVisibleButNotLoaded.array[v3]) == 0;
    result = 1i64;
    v11 = 7;
LABEL_40:
    if ( !v10 )
      return v11;
  }
  return result;
}

/*
==============
CL_TransientsWorldMP_GetChangeVisible
==============
*/
bitarray<1536> *CL_TransientsWorldMP_GetChangeVisible()
{
  if ( s_transientsWorldMP.systemEnabled )
    return &s_transientsWorldMP.changedVisible;
  else
    return 0i64;
}

/*
==============
CL_TransientsWorldMP_GetFacingDistAdd
==============
*/
float CL_TransientsWorldMP_GetFacingDistAdd()
{
  const dvar_t *v0; 
  const dvar_t *v1; 

  v0 = DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride;
  if ( !DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleRadiusOverride") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( !v0->current.enabled )
    return comWorld.trVisFacingDistAdd;
  v1 = DCONST_DVARFLT_cl_transientWorldVisibleFacingDistAdd;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleFacingDistAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleFacingDistAdd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  return v1->current.value;
}

/*
==============
CL_TransientsWorldMP_GetFrustumPlanes
==============
*/
void CL_TransientsWorldMP_GetFrustumPlanes(const cg_t *const cgameGlob, const vec3_t *currentPos, const vec3_t *forwardDir, float farDistance, float fovXPadding, float fovYPadding, vec4_t *frustumPlanes)
{
  float v10; 
  float v11; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  __m128 *v16; 
  unsigned __int128 v17; 
  vec4_t result; 
  vec3_t dir; 
  vec3_t pt; 
  GfxCamera camera; 
  tmat44_t<vec4_t> in2; 
  tmat44_t<vec4_t> mtx; 
  tmat44_t<vec4_t> out; 

  R_SetCameraForView(&cgameGlob->refdef.view, &camera);
  v10 = atanf_0(camera.tanHalfFovX);
  camera.tanHalfFovX = tanf_0((float)((float)(v10 * 57.295776) + fovXPadding) * 0.017453292);
  v11 = atanf_0(camera.tanHalfFovY);
  camera.tanHalfFovY = tanf_0((float)((float)(v11 * 57.295776) + fovYPadding) * 0.017453292);
  MatrixForViewerOrthogonal(&camera.origin, &camera.axis, &mtx);
  InfinitePerspectiveMatrix(camera.tanHalfFovX, camera.tanHalfFovY, camera.zPlanes[2], &in2);
  MatrixMultiply44Aligned(&mtx, &in2, &out);
  R_FrustumClipPlanes((const GfxMatrix *)&out, STANDARD_FRUSTUM_SIDE_PLANES, 4, (DpvsPlane *)frustumPlanes);
  v12 = forwardDir->v[0];
  v13 = forwardDir->v[1];
  v14 = forwardDir->v[2];
  pt.v[0] = (float)(farDistance * forwardDir->v[0]) + currentPos->v[0];
  pt.v[1] = (float)(farDistance * v13) + currentPos->v[1];
  v15 = (float)(farDistance * v14) + currentPos->v[2];
  LODWORD(dir.v[0]) = LODWORD(v12) ^ _xmm;
  pt.v[2] = v15;
  LODWORD(dir.v[2]) = LODWORD(v14) ^ _xmm;
  LODWORD(dir.v[1]) = LODWORD(v13) ^ _xmm;
  v16 = (__m128 *)PlaneFromPoint(&result, &pt, &dir);
  v17 = *(unsigned __int128 *)&_mm_shuffle_ps(*v16, *v16, 255) ^ (unsigned int)_xmm;
  frustumPlanes[4] = *(vec4_t *)v16;
  frustumPlanes[4].v[3] = *(float *)&v17;
}

/*
==============
CL_TransientsWorldMP_GetGridTransientMPIndex
==============
*/
__int64 CL_TransientsWorldMP_GetGridTransientMPIndex(const unsigned int worldMapIndex)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = worldMapIndex;
  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1792, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x600 )
  {
    v4 = 1536;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1793, ASSERT_TYPE_ASSERT, "(unsigned)( worldMapIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientToMPIndexMapping ) ) + 0 ) )", "worldMapIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientToMPIndexMapping )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return s_transientsWorldMP.transientToMPIndexMapping[v1];
}

/*
==============
CL_TransientsWorldMP_GetHighLODLookups
==============
*/
unsigned __int16 *CL_TransientsWorldMP_GetHighLODLookups(unsigned int baseTransientIndex)
{
  __int64 v2; 
  __int64 v4; 

  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1111, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo") )
    __debugbreak();
  v2 = baseTransientIndex * s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  if ( (unsigned int)v2 >= s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount )
  {
    LODWORD(v4) = baseTransientIndex * s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1113, ASSERT_TYPE_ASSERT, "(unsigned)( lodhighLodLookupIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount )", "lodhighLodLookupIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount\n\t%i not in [0, %i)", v4, s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount) )
      __debugbreak();
  }
  return &s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookup[v2];
}

/*
==============
CL_TransientsWorldMP_GetLODFileCount
==============
*/
__int64 CL_TransientsWorldMP_GetLODFileCount(unsigned int lodLevel)
{
  __int64 v1; 
  int v4; 

  v1 = lodLevel;
  if ( lodLevel >= 3 )
  {
    v4 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3819, ASSERT_TYPE_ASSERT, "(unsigned)( lodLevel ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lodFileCount ) ) + 0 ) )", "lodLevel doesn't index ARRAY_COUNT( s_transientsWorldMP.lodFileCount )\n\t%i not in [0, %i)", lodLevel, v4) )
      __debugbreak();
  }
  return s_transientsWorldMP.lodFileCount[v1];
}

/*
==============
CL_TransientsWorldMP_GetLobbyStreamPositions
==============
*/
__int64 CL_TransientsWorldMP_GetLobbyStreamPositions(vec3_t *outPos, unsigned int outPosSize)
{
  unsigned int lobbyStreamPosCount; 
  const dvar_t *v5; 
  unsigned int v7; 
  signed __int64 v8; 

  lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
  if ( s_transientsWorldMP.lobbyStreamPosCount )
  {
    v7 = 0;
    if ( outPosSize )
    {
      v8 = (char *)s_transientsWorldMP.lobbyStreamPos - (char *)outPos;
      while ( v7 < lobbyStreamPosCount )
      {
        *(double *)outPos->v = *(double *)((char *)outPos->v + v8);
        ++v7;
        outPos->v[2] = *(float *)((char *)&outPos->v[2] + v8);
        ++outPos;
        if ( v7 >= outPosSize )
          return 0i64;
        lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
      }
      return v7;
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    if ( !outPosSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3443, ASSERT_TYPE_ASSERT, "(outPosSize >= 1)", (const char *)&queryFormat, "outPosSize >= 1") )
      __debugbreak();
    v5 = DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos;
    if ( !DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 734, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDefaultPos") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    LODWORD(outPos->v[0]) = v5->current.integer;
    outPos->v[1] = v5->current.vector.v[1];
    outPos->v[2] = v5->current.vector.v[2];
    return 1i64;
  }
}

/*
==============
CL_TransientsWorldMP_GetMemoryMaxMB
==============
*/
unsigned __int64 CL_TransientsWorldMP_GetMemoryMaxMB(WorldStreamingQuality qualityLevel)
{
  __int64 v1; 
  const dvar_t *v2; 
  float v3; 
  __int64 v5; 
  __int64 v6; 
  int v7[2]; 

  v1 = qualityLevel;
  if ( qualityLevel >= WORLD_STREAM_QUALITY_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2250, ASSERT_TYPE_ASSERT, "(qualityLevel < 2)", (const char *)&queryFormat, "qualityLevel < 2") )
    __debugbreak();
  v2 = DVARVEC2_cl_transientWorldMemoryMaxMB;
  if ( !DVARVEC2_cl_transientWorldMemoryMaxMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryMaxMB") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  v3 = v2->current.vector.v[1];
  v7[0] = v2->current.integer;
  *(float *)&v7[1] = v3;
  if ( (unsigned int)v1 >= 2 )
  {
    LODWORD(v6) = 2;
    LODWORD(v5) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  return (unsigned __int64)(unsigned int)(int)*(float *)&v7[v1] << 20;
}

/*
==============
CL_TransientsWorldMP_GetOverlayClipMode
==============
*/
_BOOL8 CL_TransientsWorldMP_GetOverlayClipMode()
{
  const dvar_t *v0; 

  v0 = DVARFLT_cl_transientWorldOverlayZoom;
  if ( !DVARFLT_cl_transientWorldOverlayZoom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayZoom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.value == 0.0;
}

/*
==============
CL_TransientsWorldMP_GetPriorityGraphValueY
==============
*/
double CL_TransientsWorldMP_GetPriorityGraphValueY(unsigned int transientIndex, TransientWorldPriorityGraphType graphType)
{
  __int64 v2; 
  double result; 
  double v4; 
  unsigned int v5; 
  unsigned __int16 *i; 
  double v7; 
  Bounds *transientWorldGridBounds; 
  double v9; 
  unsigned int v10; 
  __int64 v11; 
  __int64 CostToLoad; 
  double v13; 

  v2 = transientIndex;
  switch ( graphType )
  {
    case TRANSIENT_WORLD_PRIORITY_GRAPH_LOAD_DISTANCE:
      *(_QWORD *)&v4 = LODWORD(s_transientsWorldMP.priorityList[transientIndex].loadDistanceSq);
      *(float *)&v4 = fsqrt(s_transientsWorldMP.priorityList[transientIndex].loadDistanceSq);
      result = v4;
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_LOAD_ORDER:
      v5 = 0;
      for ( i = s_transientsWorldMP.priorityOrder; *i != (_DWORD)v2; ++i )
      {
        if ( ++v5 >= 0x600 )
          return 0.0;
      }
      HIDWORD(v7) = 0;
      *(float *)&v7 = (float)v5;
      result = v7;
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_ZDIST:
      *(_QWORD *)&result = LODWORD(s_transientsWorldMP.priorityDistZ[transientIndex]);
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_ZTOP:
      if ( transientIndex >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
        goto LABEL_23;
      transientWorldGridBounds = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
      *(_QWORD *)&v9 = LODWORD(transientWorldGridBounds[transientIndex].halfSize.v[2]);
      *(float *)&v9 = transientWorldGridBounds[transientIndex].halfSize.v[2] + transientWorldGridBounds[transientIndex].midPoint.v[2];
      result = v9;
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_VIEW_DOT:
      *(_QWORD *)&result = LODWORD(s_transientsWorldMP.priorityViewDot[transientIndex]);
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_BOOST_IN_AIR:
      if ( s_transientsWorldMP.transientLODIndex[transientIndex] != 1 )
        goto LABEL_23;
      v10 = 0;
      if ( !s_transientsWorldMP.numStreamPositions )
        goto LABEL_23;
      while ( 1 )
      {
        v11 = v10;
        if ( s_transientsWorldMP.streamPositions[v11].localClientIndex == LOCAL_CLIENT_0 && s_transientsWorldMP.streamPositions[v11].streamRender )
          break;
        if ( ++v10 >= s_transientsWorldMP.numStreamPositions )
          goto LABEL_23;
      }
      *(_QWORD *)&result = LODWORD(s_transientsWorldMP.streamPositions[v11].pos.v[2]);
      *(float *)&result = CL_TransientsWorldMP_CalcViewDotBoostInAir(result, s_transientsWorldMP.streamPositions[v11].viewDir3D.v[2], s_transientsWorldMP.priorityDistZ[v2 - 1536] * s_transientsWorldMP.priorityDistZ[v2 - 1536], s_transientsWorldMP.priorityViewDot[v2]);
      break;
    case TRANSIENT_WORLD_PRIORITY_GRAPH_MEMORY:
      CostToLoad = TransientCostCalc_GetCostToLoad(&s_transientsWorldMP.worldCost, transientIndex, 0);
      HIDWORD(v13) = 0;
      *(float *)&v13 = (float)CostToLoad;
      result = v13;
      if ( CostToLoad < 0 )
      {
        *(float *)&v13 = *(float *)&v13 + 1.8446744e19;
        result = v13;
      }
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4921, ASSERT_TYPE_ASSERT, "(0)", (const char *)&queryFormat, "0") )
        __debugbreak();
LABEL_23:
      result = 0.0;
      break;
  }
  return result;
}

/*
==============
CL_TransientsWorldMP_GetTileBounds
==============
*/
Bounds *CL_TransientsWorldMP_GetTileBounds(const TransientWorldGridTileMap *tileMap, const unsigned int gridX, const unsigned int gridY, const unsigned int lod)
{
  __int64 v8; 
  __int64 v10; 
  __int64 v12; 
  unsigned int gridCountX; 

  if ( gridX >= tileMap->gridCountX )
  {
    gridCountX = tileMap->gridCountX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 797, ASSERT_TYPE_ASSERT, "(unsigned)( gridX ) < (unsigned)( tileMap.gridCountX )", "gridX doesn't index tileMap.gridCountX\n\t%i not in [0, %i)", gridX, gridCountX) )
      __debugbreak();
  }
  if ( gridY >= tileMap->gridCountY )
  {
    LODWORD(v12) = tileMap->gridCountY;
    LODWORD(v10) = gridY;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 798, ASSERT_TYPE_ASSERT, "(unsigned)( gridY ) < (unsigned)( tileMap.gridCountY )", "gridY doesn't index tileMap.gridCountY\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  if ( lod >= tileMap->lodCount )
  {
    LODWORD(v12) = tileMap->lodCount;
    LODWORD(v10) = lod;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 799, ASSERT_TYPE_ASSERT, "(unsigned)( lod ) < (unsigned)( tileMap.lodCount )", "lod doesn't index tileMap.lodCount\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  v8 = tileMap->spaceToTransientIndex[lod + tileMap->lodCount * (gridX + tileMap->gridCountX * gridY)];
  if ( (unsigned int)v8 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 803, ASSERT_TYPE_ASSERT, "(transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount)", (const char *)&queryFormat, "transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount") )
    __debugbreak();
  return &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v8];
}

/*
==============
CL_TransientsWorldMP_GetTransientIndex
==============
*/
__int64 CL_TransientsWorldMP_GetTransientIndex(const TransientWorldGridTileMap *tileMap, const unsigned int gridX, const unsigned int gridY, const unsigned int lod)
{
  __int64 v8; 
  __int64 v10; 
  __int64 v12; 
  unsigned int gridCountX; 

  if ( gridX >= tileMap->gridCountX )
  {
    gridCountX = tileMap->gridCountX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 774, ASSERT_TYPE_ASSERT, "(unsigned)( gridX ) < (unsigned)( tileMap.gridCountX )", "gridX doesn't index tileMap.gridCountX\n\t%i not in [0, %i)", gridX, gridCountX) )
      __debugbreak();
  }
  if ( gridY >= tileMap->gridCountY )
  {
    LODWORD(v12) = tileMap->gridCountY;
    LODWORD(v10) = gridY;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 775, ASSERT_TYPE_ASSERT, "(unsigned)( gridY ) < (unsigned)( tileMap.gridCountY )", "gridY doesn't index tileMap.gridCountY\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  if ( lod >= tileMap->lodCount )
  {
    LODWORD(v12) = tileMap->lodCount;
    LODWORD(v10) = lod;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 776, ASSERT_TYPE_ASSERT, "(unsigned)( lod ) < (unsigned)( tileMap.lodCount )", "lod doesn't index tileMap.lodCount\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  v8 = lod + tileMap->lodCount * (gridX + tileMap->gridCountX * gridY);
  if ( (unsigned int)v8 >= tileMap->indexCount )
  {
    LODWORD(v12) = tileMap->indexCount;
    LODWORD(v10) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 779, ASSERT_TYPE_ASSERT, "(unsigned)( spaceIndex ) < (unsigned)( tileMap.indexCount )", "spaceIndex doesn't index tileMap.indexCount\n\t%i not in [0, %i)", v10, v12) )
      __debugbreak();
  }
  return tileMap->spaceToTransientIndex[v8];
}

/*
==============
CL_TransientsWorldMP_GetVisibilityCenterPos
==============
*/
void CL_TransientsWorldMP_GetVisibilityCenterPos(const WorldStreamPosition *worldPos, vec3_t *outCenter)
{
  const dvar_t *v4; 
  float FacingDistAdd; 
  float v6; 
  float v7; 
  float c; 
  float s[5]; 

  if ( !worldPos->mainCamera )
    goto LABEL_7;
  v4 = DVARBOOL_cl_transientWorldVisibleFacingCircleSweep;
  if ( !DVARBOOL_cl_transientWorldVisibleFacingCircleSweep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleFacingCircleSweep") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    FastSinCos(worldPos->angles.v[1] * 0.017453292, s, &c);
    FacingDistAdd = CL_TransientsWorldMP_GetFacingDistAdd();
    v6 = FacingDistAdd * s[0];
    outCenter->v[0] = (float)(FacingDistAdd * c) + worldPos->pos.v[0];
    v7 = v6 + worldPos->pos.v[1];
  }
  else
  {
LABEL_7:
    outCenter->v[0] = worldPos->pos.v[0];
    v7 = worldPos->pos.v[1];
  }
  outCenter->v[1] = v7;
  outCenter->v[2] = worldPos->pos.v[2];
}

/*
==============
CL_TransientsWorldMP_GetVisibilityRadius
==============
*/
float CL_TransientsWorldMP_GetVisibilityRadius(const unsigned int level, const vec3_t *streamPos)
{
  float VisibilityRadiusWithoutPos; 
  float v5; 
  const dvar_t *v6; 
  __int128 v7; 
  const dvar_t *v8; 
  float value; 
  const dvar_t *v10; 
  const dvar_t *v11; 
  __int128 v12; 
  const dvar_t *v13; 
  float v14; 
  const dvar_t *v15; 
  float v16; 
  const dvar_t *v17; 

  VisibilityRadiusWithoutPos = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(level);
  v5 = VisibilityRadiusWithoutPos;
  if ( level != 1 )
    return VisibilityRadiusWithoutPos * s_transientsWorldMP.radiusMultiplier;
  v6 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
  v7 = LODWORD(streamPos->v[2]);
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( *(float *)&v7 <= v6->current.value )
    return VisibilityRadiusWithoutPos * s_transientsWorldMP.radiusMultiplier;
  v8 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  value = v8->current.value;
  v10 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( value <= v10->current.value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 634, ASSERT_TYPE_ASSERT, "(Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd, \"cl_transientWorldVisibleLOD1BoostInAirZEnd\" ) > Dvar_GetFloat_Internal_DebugName( DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart, \"cl_transientWorldVisibleLOD1BoostInAirZStart\" ))", (const char *)&queryFormat, "Dconst_GetFloat( cl_transientWorldVisibleLOD1BoostInAirZEnd ) > Dconst_GetFloat( cl_transientWorldVisibleLOD1BoostInAirZStart )") )
    __debugbreak();
  v11 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  v12 = v7;
  *(float *)&v12 = *(float *)&v7 - v11->current.value;
  v13 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZEnd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v13);
  v14 = v13->current.value;
  v15 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirZStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirZStart") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  v16 = v14 - v15->current.value;
  v17 = DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirMaxAdd;
  *(float *)&v12 = *(float *)&v12 / v16;
  _XMM1 = v12;
  __asm { vminss  xmm7, xmm1, cs:__real@3f800000 }
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleLOD1BoostInAirMaxAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleLOD1BoostInAirMaxAdd") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v17);
  return (float)(v5 + (float)(*(float *)&_XMM7 * v17->current.value)) * s_transientsWorldMP.radiusMultiplier;
}

/*
==============
CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos
==============
*/
float CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(const unsigned int level)
{
  __int64 v1; 
  const dvar_t *v3; 
  float value; 
  const dvar_t *v5; 
  __int64 v6; 
  __int64 v7; 

  v1 = level;
  if ( level >= 2 )
    return FLOAT_3_4028235e38;
  v3 = DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride;
  if ( !DCONST_DVARBOOL_cl_transientWorldVisibleRadiusOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleRadiusOverride") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( v3->current.enabled )
  {
    if ( !TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 601, ASSERT_TYPE_ASSERT, "(TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level])", (const char *)&queryFormat, "TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level]") )
      __debugbreak();
    if ( !*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 602, ASSERT_TYPE_ASSERT, "(*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level])", (const char *)&queryFormat, "*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[level]") )
      __debugbreak();
    value = (*TRANSIENTWORLDMP_VISIBLE_RADIUS_DVARS[v1])->current.value;
  }
  else
  {
    if ( (unsigned int)v1 >= 5 )
    {
      LODWORD(v7) = 5;
      LODWORD(v6) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 610, ASSERT_TYPE_ASSERT, "(unsigned)( level ) < (unsigned)( ( sizeof( *array_counter( comWorld.trVisRadii ) ) + 0 ) )", "level doesn't index comWorld.trVisRadii\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    value = comWorld.trVisRadii[v1];
  }
  v5 = DVARBOOL_cl_transientWorldVisibleFacingCircleSweep;
  if ( !DVARBOOL_cl_transientWorldVisibleFacingCircleSweep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleFacingCircleSweep") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( !v5->current.enabled )
    return value + CL_TransientsWorldMP_GetFacingDistAdd();
  return value;
}

/*
==============
CL_TransientsWorldMP_GetWorldStreamParamsInternal
==============
*/
void CL_TransientsWorldMP_GetWorldStreamParamsInternal(WorldStreamParameters *params, const vec3_t *streamPos)
{
  const dvar_t *v2; 
  const dvar_t *v4; 
  const dvar_t *v5; 
  __int128 v7; 
  float v8; 
  const dvar_t *v10; 
  __int128 v11; 
  __int128 v13; 
  float v14; 
  const dvar_t *v16; 
  float value; 
  float v18; 

  v2 = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  LODWORD(params->visZMultipliers[0]) = v2->current.integer;
  v4 = DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleZMultiplierLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleZMultiplierLvl1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  LODWORD(params->visZMultipliers[1]) = v4->current.integer;
  v5 = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl0") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v7 = LODWORD(params->visRadius[0]);
  *(float *)&v7 = params->visRadius[0] - v5->current.value;
  _XMM1 = v7;
  v8 = 0.0;
  __asm { vmaxss  xmm0, xmm1, xmm6 }
  params->visHintRadius[0] = *(float *)&_XMM0;
  v10 = DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1;
  if ( !DCONST_DVARFLT_cl_transientWorldVisibleHintLvl1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLvl1") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  v11 = LODWORD(params->visRadius[1]);
  v13 = v11;
  *(float *)&v13 = *(float *)&v11 - v10->current.value;
  _XMM0 = v13;
  v14 = params->visRadius[0];
  __asm { vmaxss  xmm0, xmm0, xmm6 }
  params->visHintRadius[1] = *(float *)&_XMM0;
  params->visRadiusSqs[1] = *(float *)&v11 * *(float *)&v11;
  params->visRadiusSqs[0] = v14 * v14;
  v16 = DVARFLT_cl_transientWorldVisibleHintLOD0Addition;
  if ( !DVARFLT_cl_transientWorldVisibleHintLOD0Addition && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleHintLOD0Addition") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v16);
  value = v16->current.value;
  if ( value != 0.0 )
    v8 = (float)(value + params->visRadius[0]) * (float)(value + params->visRadius[0]);
  params->lod0HintRadiusSq = v8;
  v18 = params->visHintRadius[0] * params->visHintRadius[0];
  params->visHintRadiusSqs[1] = params->visHintRadius[1] * params->visHintRadius[1];
  _XMM0 = LODWORD(params->visZMultipliers[1]);
  __asm { vminss  xmm2, xmm0, dword ptr [rbx] }
  params->visHintRadiusSqs[0] = v18;
  _XMM1 = LODWORD(params->visRadius[0]);
  __asm { vmaxss  xmm3, xmm1, dword ptr [rbx+0Ch] }
  params->visRadiusMaxSq = (float)(*(float *)&_XMM3 / *(float *)&_XMM2) * (float)(*(float *)&_XMM3 / *(float *)&_XMM2);
  params->visRadiusMax = *(float *)&_XMM3 / *(float *)&_XMM2;
}

/*
==============
CL_TransientsWorldMP_GetWorldTileBudgetMultiplier
==============
*/
float CL_TransientsWorldMP_GetWorldTileBudgetMultiplier()
{
  const dvar_t *v0; 
  const char *v2; 
  const char *mapName; 
  __int64 v4; 
  signed __int64 v5; 
  int v6; 
  __int64 v7; 
  int v8; 
  int v9; 
  int v10; 
  const char *v11; 

  if ( s_transientsWorldMP.isBRMap )
  {
    if ( s_transientsWorldMP.inLobbyState )
    {
      v0 = DVARFLT_cl_transientWorldMemoryFreeMulBRLobby;
      if ( !DVARFLT_cl_transientWorldMemoryFreeMulBRLobby && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryFreeMulBRLobby") )
        __debugbreak();
    }
    else
    {
      v0 = DVARFLT_cl_transientWorldMemoryFreeMulBR;
      if ( !DVARFLT_cl_transientWorldMemoryFreeMulBR && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryFreeMulBR") )
        __debugbreak();
    }
  }
  else
  {
    v2 = "cp_";
    mapName = s_transientsWorldMP.mapName;
    v4 = 3i64;
    if ( !s_transientsWorldMP.mapName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    v5 = mapName - "cp_";
    while ( 1 )
    {
      v6 = (unsigned __int8)v2[v5];
      v7 = v4;
      v8 = *(unsigned __int8 *)v2++;
      --v4;
      if ( !v7 )
      {
LABEL_23:
        v0 = DVARFLT_cl_transientWorldMemoryFreeMulCP;
        if ( DVARFLT_cl_transientWorldMemoryFreeMulCP )
          goto LABEL_6;
        v11 = "cl_transientWorldMemoryFreeMulCP";
        goto LABEL_25;
      }
      if ( v6 != v8 )
      {
        v9 = v6 + 32;
        if ( (unsigned int)(v6 - 65) > 0x19 )
          v9 = v6;
        v6 = v9;
        v10 = v8 + 32;
        if ( (unsigned int)(v8 - 65) > 0x19 )
          v10 = v8;
        if ( v6 != v10 )
          break;
      }
      if ( !v6 )
        goto LABEL_23;
    }
    v0 = DVARFLT_cl_transientWorldMemoryFreeMulMP;
    if ( DVARFLT_cl_transientWorldMemoryFreeMulMP )
      goto LABEL_6;
    v11 = "cl_transientWorldMemoryFreeMulMP";
LABEL_25:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v11) )
      __debugbreak();
  }
LABEL_6:
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.value;
}

/*
==============
CL_TransientsWorldMP_GetXB3BudgetBytes
==============
*/
unsigned __int64 CL_TransientsWorldMP_GetXB3BudgetBytes()
{
  if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    return 0i64;
  else
    return 419430400i64;
}

/*
==============
CL_TransientsWorldMP_GridContainsPos
==============
*/
bool CL_TransientsWorldMP_GridContainsPos(const vec3_t *pos, const TransientWorldGridTileMap *tileMap, const unsigned int gridX, const unsigned int gridY, const unsigned int lod)
{
  __int64 v9; 
  __int64 v10; 
  Bounds *v11; 
  bool result; 
  __int64 v13; 
  __int64 v14; 

  if ( gridX >= tileMap->gridCountX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 785, ASSERT_TYPE_ASSERT, "(unsigned)( gridX ) < (unsigned)( tileMap.gridCountX )", "gridX doesn't index tileMap.gridCountX\n\t%i not in [0, %i)", gridX, tileMap->gridCountX) )
    __debugbreak();
  if ( gridY >= tileMap->gridCountY )
  {
    LODWORD(v14) = tileMap->gridCountY;
    LODWORD(v13) = gridY;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 786, ASSERT_TYPE_ASSERT, "(unsigned)( gridY ) < (unsigned)( tileMap.gridCountY )", "gridY doesn't index tileMap.gridCountY\n\t%i not in [0, %i)", v13, v14) )
      __debugbreak();
  }
  v9 = lod + tileMap->lodCount * (gridX + tileMap->gridCountX * gridY);
  if ( (unsigned int)v9 >= tileMap->indexCount )
  {
    LODWORD(v14) = tileMap->indexCount;
    LODWORD(v13) = v9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 789, ASSERT_TYPE_ASSERT, "(unsigned)( spaceIndex ) < (unsigned)( tileMap.indexCount )", "spaceIndex doesn't index tileMap.indexCount\n\t%i not in [0, %i)", v13, v14) )
      __debugbreak();
  }
  v10 = tileMap->spaceToTransientIndex[v9];
  if ( (unsigned int)v10 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 791, ASSERT_TYPE_ASSERT, "(transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount)", (const char *)&queryFormat, "transientIndex < s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount") )
    __debugbreak();
  v11 = &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[v10];
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\bounds_inline.h", 510, ASSERT_TYPE_ASSERT, "(bounds)", (const char *)&queryFormat, "bounds") )
    __debugbreak();
  result = 0;
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(pos->v[0] - v11->midPoint.v[0]) & _xmm) < v11->halfSize.v[0] )
    return COERCE_FLOAT(COERCE_UNSIGNED_INT(pos->v[1] - v11->midPoint.v[1]) & _xmm) < v11->halfSize.v[1];
  return result;
}

/*
==============
CL_TransientsWorldMP_HasGridStreamingCompletedForPosition
==============
*/
__int64 CL_TransientsWorldMP_HasGridStreamingCompletedForPosition(const LocalClientNum_t localClientNum, const vec3_t *pos)
{
  unsigned __int8 v4; 

  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3557, ASSERT_TYPE_ASSERT, "(CL_TransientsWorldMP_IsActive())", (const char *)&queryFormat, "CL_TransientsWorldMP_IsActive()", -2i64) )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFF808080, "CL_TransientsWorldMP_HasGridStreamingCompletedForPosition");
  v4 = CL_TransientsWorldMP_AreAllRequestedZonesNearPositionLoaded(localClientNum, pos);
  Sys_ProfEndNamedEvent();
  return v4;
}

/*
==============
CL_TransientsWorldMP_HasLobbyStreamPositions
==============
*/
bool CL_TransientsWorldMP_HasLobbyStreamPositions()
{
  return s_transientsWorldMP.lobbyStreamPosCount != 0;
}

/*
==============
CL_TransientsWorldMP_IsActive
==============
*/
bool CL_TransientsWorldMP_IsActive()
{
  return s_transientsWorldMP.worldGridInfo != NULL;
}

/*
==============
CL_TransientsWorldMP_IsBRMode
==============
*/
_BOOL8 CL_TransientsWorldMP_IsBRMode()
{
  return s_transientsWorldMP.isBRMap;
}

/*
==============
CL_TransientsWorldMP_IsLOD0
==============
*/
bool CL_TransientsWorldMP_IsLOD0(unsigned int transientIndex)
{
  const TransientInfo *worldGridInfo; 

  if ( !transientIndex )
    return 0;
  worldGridInfo = s_transientsWorldMP.worldGridInfo;
  if ( !s_transientsWorldMP.worldGridInfo )
    return 0;
  if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3806, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount") )
      __debugbreak();
    worldGridInfo = s_transientsWorldMP.worldGridInfo;
  }
  return transientIndex < (unsigned int)(worldGridInfo->transientWorldGridHighLodLookupCount / worldGridInfo->transientWorldGridHighLodCount);
}

/*
==============
CL_TransientsWorldMP_IsZoomLoadActive
==============
*/
char CL_TransientsWorldMP_IsZoomLoadActive(const LocalClientNum_t localClientNum)
{
  unsigned int numStreamPositions; 
  unsigned int v3; 
  __int64 v4; 
  unsigned int v6; 

  numStreamPositions = s_transientsWorldMP.numStreamPositions;
  if ( s_transientsWorldMP.numStreamPositions > 0xE )
  {
    v6 = s_transientsWorldMP.numStreamPositions;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3283, ASSERT_TYPE_ASSERT, "( s_transientsWorldMP.numStreamPositions <= ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "NumStreamPositions %u is out of range %zu", v6, 0xEui64) )
      __debugbreak();
    numStreamPositions = s_transientsWorldMP.numStreamPositions;
  }
  v3 = 0;
  if ( !numStreamPositions )
    return 0;
  while ( 1 )
  {
    v4 = v3;
    if ( s_transientsWorldMP.streamPositions[v4].localClientIndex == localClientNum && s_transientsWorldMP.streamPositions[v4].zoomLoad )
      break;
    if ( ++v3 >= numStreamPositions )
      return 0;
  }
  return 1;
}

/*
==============
CL_TransientsWorldMP_LoadIndex
==============
*/
void CL_TransientsWorldMP_LoadIndex(const unsigned int worldIndex, const unsigned int priority)
{
  unsigned __int64 v3; 
  unsigned __int16 GridTransientMPIndex; 
  unsigned int v5; 
  unsigned int *v6; 
  __int64 v7; 
  __int64 v8; 

  v3 = worldIndex;
  GridTransientMPIndex = CL_TransientsWorldMP_GetGridTransientMPIndex(worldIndex);
  if ( !GridTransientMPIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1808, ASSERT_TYPE_ASSERT, "(mpIndex != MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "mpIndex != MPINDEX_ALWAYSLOADED") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x600 )
  {
    LODWORD(v7) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v7, 1536) )
      __debugbreak();
  }
  v5 = 0x80000000 >> (v3 & 0x1F);
  v6 = &s_transientsWorldMP.requested.array[v3 >> 5];
  if ( (v5 & *v6) != 0 )
  {
    CL_TransientsMP_SetLoadPriorityByFileIndex(GridTransientMPIndex, priority);
  }
  else
  {
    ++s_transientsWorldMP.requestedCount;
    if ( (unsigned int)v3 >= 0x600 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v3, 1536) )
      __debugbreak();
    *v6 |= v5;
    CL_TransientsMP_LoadByFileIndex(GridTransientMPIndex, priority);
    TransientCostCalc_Load(&s_transientsWorldMP.worldCost, v3);
  }
  if ( (unsigned int)v3 >= 0x600 )
  {
    LODWORD(v8) = 1536;
    LODWORD(v7) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1826, ASSERT_TYPE_ASSERT, "(unsigned)( worldIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lastTrPriority ) ) + 0 ) )", "worldIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.lastTrPriority )\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  s_transientsWorldMP.lastTrPriority[v3] = priority;
}

/*
==============
CL_TransientsWorldMP_OnFirstSnapshot
==============
*/
void CL_TransientsWorldMP_OnFirstSnapshot(void)
{
  if ( s_transientsWorldMP.worldGridInfo && !s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3703, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "s_transientsWorldMP.systemEnabled") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyToGameStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3705, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyToGameStart)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyToGameStart") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyPreloadStopped && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3706, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyPreloadStopped)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyPreloadStopped") )
    __debugbreak();
  if ( s_transientsWorldMP.preloadingBackToFE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3707, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.preloadingBackToFE)", (const char *)&queryFormat, "!s_transientsWorldMP.preloadingBackToFE") )
    __debugbreak();
  s_transientsWorldMP.inLobbyState = 0;
}

/*
==============
CL_TransientsWorldMP_OnFrontendPreload
==============
*/
void CL_TransientsWorldMP_OnFrontendPreload(void)
{
  unsigned int v0; 
  unsigned __int64 v1; 
  unsigned __int16 *transientToMPIndexMapping; 
  unsigned int v3; 
  unsigned __int64 v4; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3567, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( CL_PlayAgain_IsActive() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3568, ASSERT_TYPE_ASSERT, "(!CL_PlayAgain_IsActive())", (const char *)&queryFormat, "!CL_PlayAgain_IsActive()") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    v0 = 0;
    v1 = 0i64;
    transientToMPIndexMapping = s_transientsWorldMP.transientToMPIndexMapping;
    do
    {
      if ( *transientToMPIndexMapping )
      {
        v3 = 0x80000000 >> (v0 & 0x1F);
        v4 = v1 >> 5;
        if ( (v3 & s_transientsWorldMP.requested.array[v4]) != 0 && (v3 & s_transientsWorldMP.loaded.array[v4]) == 0 )
          CL_TransientsWorldMP_UnloadIndex(v0);
      }
      ++v0;
      ++v1;
      ++transientToMPIndexMapping;
    }
    while ( v0 < 0x600 );
    s_transientsWorldMP.preloadingBackToFE = 1;
    CL_TransientsWorldMP_ProcessFastfiles();
  }
}

/*
==============
CL_TransientsWorldMP_OnLevelLoad
==============
*/
void CL_TransientsWorldMP_OnLevelLoad(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3668, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_ValidateGameStartAssumptions();
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 0;
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadAllowed
==============
*/
void CL_TransientsWorldMP_OnLevelPreloadAllowed(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3648, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.lobbyPreloadStopped = 0;
}

/*
==============
CL_TransientsWorldMP_OnLevelPreloadCancel
==============
*/
void CL_TransientsWorldMP_OnLevelPreloadCancel(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3657, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_CancelInFlightLoads();
  s_transientsWorldMP.lobbyPreloadStopped = 1;
}

/*
==============
CL_TransientsWorldMP_OnLevelUnload
==============
*/
void CL_TransientsWorldMP_OnLevelUnload(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3681, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.systemEnabled = 0;
  CL_TransientsWorldMP_ClearLoadState();
}

/*
==============
CL_TransientsWorldMP_OnLobbyToGameStart
==============
*/
void CL_TransientsWorldMP_OnLobbyToGameStart(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3631, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsWorldMP_ValidateGameStartAssumptions();
  CL_TransientsWorldMP_CancelInFlightLoads();
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 1;
}

/*
==============
CL_TransientsWorldMP_OnPlayAgainRestart
==============
*/
void CL_TransientsWorldMP_OnPlayAgainRestart(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3715, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo && !s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3719, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "s_transientsWorldMP.systemEnabled") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyToGameStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3721, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyToGameStart)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyToGameStart") )
    __debugbreak();
  if ( s_transientsWorldMP.lobbyPreloadStopped && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3722, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.lobbyPreloadStopped)", (const char *)&queryFormat, "!s_transientsWorldMP.lobbyPreloadStopped") )
    __debugbreak();
  if ( s_transientsWorldMP.preloadingBackToFE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3723, ASSERT_TYPE_ASSERT, "( !s_transientsWorldMP.preloadingBackToFE )", "If this fires, you need to unload the preloaded UI+Frontend fastfiles, before we playagain.") )
    __debugbreak();
  CL_TransientsWorldMP_ClearVisibilityState();
  s_transientsWorldMP.radiusMultiplier = FLOAT_1_0;
  s_transientsWorldMP.numStreamPositions = 0;
  s_transientsWorldMP.inLobbyState = 1;
  CL_TransientsWorldMP_ValidateGameStartAssumptions();
}

/*
==============
CL_TransientsWorldMP_OnServerShutdown
==============
*/
void CL_TransientsWorldMP_OnServerShutdown(void)
{
  if ( !Sys_IsServerThread() && !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3693, ASSERT_TYPE_ASSERT, "(Sys_IsServerThread() || Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsServerThread() || Sys_IsMainThread()") )
    __debugbreak();
  s_transientsWorldMP.listenServerStall = 0;
}

/*
==============
CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading
==============
*/
void CL_TransientsWorldMP_PostLoadUpdateAllowWorldLoading(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1927, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !s_transientsWorldMP.systemEnabled && s_transientsWorldMP.worldGridInfo )
  {
    if ( !s_transientsWorldMP.mapName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1930, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.mapName != nullptr)", (const char *)&queryFormat, "s_transientsWorldMP.mapName != nullptr") )
      __debugbreak();
    s_transientsWorldMP.radiusMultiplier = FLOAT_1_0;
    s_transientsWorldMP.systemEnabled = 1;
    s_transientsWorldMP.numStreamPositions = 0;
  }
}

/*
==============
CL_TransientsWorldMP_ProcessFastfiles
==============
*/
void CL_TransientsWorldMP_ProcessFastfiles(void)
{
  unsigned int v0; 
  unsigned __int64 v1; 
  unsigned int v2; 
  unsigned __int64 v3; 
  unsigned int *v4; 
  unsigned __int16 GridTransientMPIndex; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3098, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_ProcessFastfiles");
  if ( !s_transientsWorldMP.finishedLoading )
    s_transientsWorldMP.finishedLoading = DB_Zones_IsFinishedLoadingByIndex(s_transientsWorldMP.zoneIndex);
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    if ( !r_lockPvs->current.enabled )
    {
      CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions();
      Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_CheckForLoadCompletion");
      v0 = 0;
      v1 = 0i64;
      do
      {
        v2 = 0x80000000 >> (v0 & 0x1F);
        v3 = v1 >> 5;
        v4 = &s_transientsWorldMP.loaded.array[v3];
        if ( (v2 & *v4) == 0 && (v2 & s_transientsWorldMP.requested.array[v3]) != 0 )
        {
          GridTransientMPIndex = CL_TransientsWorldMP_GetGridTransientMPIndex(v0);
          if ( !GridTransientMPIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2934, ASSERT_TYPE_ASSERT, "(mpIndex != MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "mpIndex != MPINDEX_ALWAYSLOADED") )
            __debugbreak();
          if ( CL_TransientsMP_IsLoadedByFileIndex(GridTransientMPIndex) )
            *v4 |= v2;
        }
        ++v0;
        ++v1;
      }
      while ( v0 < 0x600 );
      Sys_ProfEndNamedEvent();
      if ( s_transientsWorldMP.numStreamPositions )
        CL_TransientsWorldMP_UpdateAllVisibility();
    }
    CL_TransientsWorldMP_UpdateIgnoreTransientSkip();
    if ( s_transientsWorldMP.anyMissingModelsDirty )
      CL_TransientsWorldMP_UpdateMissingModels();
    TransientCostCalc_ValidateUsage(&s_transientsWorldMP.worldCost);
    CL_TransientsWorldMP_SoakTestUpdate();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_RegisterFileIndex
==============
*/
void CL_TransientsWorldMP_RegisterFileIndex(unsigned __int16 mpSystemFileIndex, const char *name)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 
  unsigned int v8; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2141, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2142, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  if ( mpSystemFileIndex == 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2143, ASSERT_TYPE_ASSERT, "(mpSystemFileIndex != 0xffff)", (const char *)&queryFormat, "mpSystemFileIndex != USHRT_MAX") )
    __debugbreak();
  if ( !s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2144, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo") )
    __debugbreak();
  if ( !s_transientsWorldMP.mapName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2145, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.mapName)", (const char *)&queryFormat, "s_transientsWorldMP.mapName") )
    __debugbreak();
  v4 = -1i64;
  v5 = -1i64;
  do
    ++v5;
  while ( s_transientsWorldMP.mapName[v5] );
  do
    ++v4;
  while ( name[v4] );
  if ( (unsigned int)v4 <= (int)v5 + 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2148, ASSERT_TYPE_ASSERT, "( ( I_strlen( name ) > ( mapNameLen + CHARS_AFTER_MAPNAME ) ) )", "( name ) = %s", name) )
    __debugbreak();
  if ( j_sscanf_s(&name[(unsigned int)v5 + 1], "%05u_tr", &v8) != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2155, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Transient world file '%s' doesn't match our '%s' format", name, "%s_%05u_tr") )
    __debugbreak();
  if ( v8 >= 0x600 )
  {
    LODWORD(v7) = 1536;
    LODWORD(v6) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2158, ASSERT_TYPE_ASSERT, "(unsigned)( savedTransientIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientToMPIndexMapping ) ) + 0 ) )", "savedTransientIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientToMPIndexMapping )\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  if ( s_transientsWorldMP.transientToMPIndexMapping[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2159, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.transientToMPIndexMapping[savedTransientIndex] == MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "s_transientsWorldMP.transientToMPIndexMapping[savedTransientIndex] == MPINDEX_ALWAYSLOADED") )
    __debugbreak();
  s_transientsWorldMP.transientToMPIndexMapping[v8] = mpSystemFileIndex;
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfo
==============
*/
void CL_TransientsWorldMP_RegisterGridStreamingInfo(const char *name, const TransientInfo *transientInfo)
{
  __int64 v4; 
  bitarray<1536> *p_transientsHighestLOD; 
  __int64 v6; 
  bitarray<1536> *p_transientsBaseLOD; 
  __int64 v8; 
  bitarray<1536> *p_missingModelTransients; 
  unsigned int *v10; 
  __int64 v11; 
  int ZoneIndexFromName; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1956, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1957, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  if ( !transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1958, ASSERT_TYPE_ASSERT, "(transientInfo)", (const char *)&queryFormat, "transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1960, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo == nullptr)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo == nullptr") )
    __debugbreak();
  s_transientsWorldMP.worldGridInfo = transientInfo;
  s_transientsWorldMP.mapName = name;
  if ( s_transientsWorldMP.isLowFlaggingMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1964, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.isLowFlaggingMap == false)", (const char *)&queryFormat, "s_transientsWorldMP.isLowFlaggingMap == false") )
    __debugbreak();
  s_transientsWorldMP.isLowFlaggingMap = (transientInfo->transientInfoFlags & 2) != 0;
  if ( s_transientsWorldMP.isBRMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1967, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.isBRMap == false)", (const char *)&queryFormat, "s_transientsWorldMP.isBRMap == false") )
    __debugbreak();
  s_transientsWorldMP.isBRMap = (transientInfo->transientInfoFlags & 4) != 0;
  if ( s_transientsWorldMP.isAlwaysloadedTRWorldMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1970, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.isAlwaysloadedTRWorldMap == false)", (const char *)&queryFormat, "s_transientsWorldMP.isAlwaysloadedTRWorldMap == false") )
    __debugbreak();
  s_transientsWorldMP.isAlwaysloadedTRWorldMap = (transientInfo->transientInfoFlags & 8) != 0;
  if ( s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1974, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "!s_transientsWorldMP.systemEnabled") )
    __debugbreak();
  CL_TransientsWorldMP_ClearLoadState();
  memset_0(s_transientsWorldMP.transientToMPIndexMapping, 0, sizeof(s_transientsWorldMP.transientToMPIndexMapping));
  s_transientsWorldMP.tileBudget = 0i64;
  s_transientsWorldMP.lod1FalloffBeginSq = FLOAT_3_4028235e38;
  s_transientsWorldMP.preloadingBackToFE = 0;
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 0;
  TransientCostCalc_Init(&s_transientsWorldMP.worldCost, &transientInfo->transientCosts);
  v4 = 3i64;
  p_transientsHighestLOD = &s_transientsWorldMP.transientsHighestLOD;
  v6 = 3i64;
  do
  {
    *(_QWORD *)p_transientsHighestLOD->array = 0i64;
    *(_QWORD *)&p_transientsHighestLOD->array[2] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD->array[4] = 0i64;
    p_transientsHighestLOD = (bitarray<1536> *)((char *)p_transientsHighestLOD + 64);
    *(_QWORD *)&p_transientsHighestLOD[-1].array[38] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[40] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[42] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[44] = 0i64;
    *(_QWORD *)&p_transientsHighestLOD[-1].array[46] = 0i64;
    --v6;
  }
  while ( v6 );
  p_transientsBaseLOD = &s_transientsWorldMP.transientsBaseLOD;
  v8 = 3i64;
  do
  {
    *(_QWORD *)p_transientsBaseLOD->array = 0i64;
    *(_QWORD *)&p_transientsBaseLOD->array[2] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD->array[4] = 0i64;
    p_transientsBaseLOD = (bitarray<1536> *)((char *)p_transientsBaseLOD + 64);
    *(_QWORD *)&p_transientsBaseLOD[-1].array[38] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[40] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[42] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[44] = 0i64;
    *(_QWORD *)&p_transientsBaseLOD[-1].array[46] = 0i64;
    --v8;
  }
  while ( v8 );
  memset_0(s_transientsWorldMP.transientLODIndex, 0, sizeof(s_transientsWorldMP.transientLODIndex));
  memset_0(s_transientsWorldMP.baseLODIndex, 0, sizeof(s_transientsWorldMP.baseLODIndex));
  *(_QWORD *)&s_transientsWorldMP.fileBackedTransientCount = 0i64;
  *(_DWORD *)s_transientsWorldMP.lodFileCount = 0;
  s_transientsWorldMP.lodFileCount[2] = 0;
  s_transientsWorldMP.ignoreTransientSkip = 0;
  memset_0(s_transientsWorldMP.debugProxyModelIndex, 255, sizeof(s_transientsWorldMP.debugProxyModelIndex));
  p_missingModelTransients = &s_transientsWorldMP.missingModelTransients;
  do
  {
    *(_QWORD *)p_missingModelTransients->array = 0i64;
    *(_QWORD *)&p_missingModelTransients->array[2] = 0i64;
    *(_QWORD *)&p_missingModelTransients->array[4] = 0i64;
    p_missingModelTransients = (bitarray<1536> *)((char *)p_missingModelTransients + 64);
    *(_QWORD *)&p_missingModelTransients[-1].array[38] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[40] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[42] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[44] = 0i64;
    *(_QWORD *)&p_missingModelTransients[-1].array[46] = 0i64;
    --v4;
  }
  while ( v4 );
  *(_WORD *)&s_transientsWorldMP.anyMissingModels = 256;
  memset_0(s_transientsWorldMP.streamSyncDraw, 0, sizeof(s_transientsWorldMP.streamSyncDraw));
  if ( SLODWORD(cl_maxLocalClients) > 0 )
  {
    v10 = &s_transientsWorldMP.visibleCurrent[0].array[2];
    v11 = LODWORD(cl_maxLocalClients);
    do
    {
      *(v10 - 2) = s_transientsWorldMP.transientsHighestLOD.array[0];
      *(v10 - 1) = s_transientsWorldMP.transientsHighestLOD.array[1];
      *v10 = s_transientsWorldMP.transientsHighestLOD.array[2];
      v10[1] = s_transientsWorldMP.transientsHighestLOD.array[3];
      v10[2] = s_transientsWorldMP.transientsHighestLOD.array[4];
      v10[3] = s_transientsWorldMP.transientsHighestLOD.array[5];
      v10[4] = s_transientsWorldMP.transientsHighestLOD.array[6];
      v10[5] = s_transientsWorldMP.transientsHighestLOD.array[7];
      v10[6] = s_transientsWorldMP.transientsHighestLOD.array[8];
      v10[7] = s_transientsWorldMP.transientsHighestLOD.array[9];
      v10[8] = s_transientsWorldMP.transientsHighestLOD.array[10];
      v10[9] = s_transientsWorldMP.transientsHighestLOD.array[11];
      v10[10] = s_transientsWorldMP.transientsHighestLOD.array[12];
      v10[11] = s_transientsWorldMP.transientsHighestLOD.array[13];
      v10[12] = s_transientsWorldMP.transientsHighestLOD.array[14];
      v10[13] = s_transientsWorldMP.transientsHighestLOD.array[15];
      v10[14] = s_transientsWorldMP.transientsHighestLOD.array[16];
      v10[15] = s_transientsWorldMP.transientsHighestLOD.array[17];
      v10[16] = s_transientsWorldMP.transientsHighestLOD.array[18];
      v10[17] = s_transientsWorldMP.transientsHighestLOD.array[19];
      v10[18] = s_transientsWorldMP.transientsHighestLOD.array[20];
      v10[19] = s_transientsWorldMP.transientsHighestLOD.array[21];
      v10[20] = s_transientsWorldMP.transientsHighestLOD.array[22];
      v10[21] = s_transientsWorldMP.transientsHighestLOD.array[23];
      v10[22] = s_transientsWorldMP.transientsHighestLOD.array[24];
      v10[23] = s_transientsWorldMP.transientsHighestLOD.array[25];
      v10[24] = s_transientsWorldMP.transientsHighestLOD.array[26];
      v10[25] = s_transientsWorldMP.transientsHighestLOD.array[27];
      v10[26] = s_transientsWorldMP.transientsHighestLOD.array[28];
      v10[27] = s_transientsWorldMP.transientsHighestLOD.array[29];
      v10[28] = s_transientsWorldMP.transientsHighestLOD.array[30];
      v10[29] = s_transientsWorldMP.transientsHighestLOD.array[31];
      v10[30] = s_transientsWorldMP.transientsHighestLOD.array[32];
      v10[31] = s_transientsWorldMP.transientsHighestLOD.array[33];
      v10[32] = s_transientsWorldMP.transientsHighestLOD.array[34];
      v10[33] = s_transientsWorldMP.transientsHighestLOD.array[35];
      v10[34] = s_transientsWorldMP.transientsHighestLOD.array[36];
      v10[35] = s_transientsWorldMP.transientsHighestLOD.array[37];
      v10[36] = s_transientsWorldMP.transientsHighestLOD.array[38];
      v10[37] = s_transientsWorldMP.transientsHighestLOD.array[39];
      v10[38] = s_transientsWorldMP.transientsHighestLOD.array[40];
      v10[39] = s_transientsWorldMP.transientsHighestLOD.array[41];
      v10[40] = s_transientsWorldMP.transientsHighestLOD.array[42];
      v10[41] = s_transientsWorldMP.transientsHighestLOD.array[43];
      v10[42] = s_transientsWorldMP.transientsHighestLOD.array[44];
      v10[43] = s_transientsWorldMP.transientsHighestLOD.array[45];
      v10[44] = s_transientsWorldMP.transientsHighestLOD.array[46];
      v10[45] = s_transientsWorldMP.transientsHighestLOD.array[47];
      v10[94] = s_transientsWorldMP.transientsHighestLOD.array[0];
      v10[95] = s_transientsWorldMP.transientsHighestLOD.array[1];
      v10[96] = s_transientsWorldMP.transientsHighestLOD.array[2];
      v10[97] = s_transientsWorldMP.transientsHighestLOD.array[3];
      v10[98] = s_transientsWorldMP.transientsHighestLOD.array[4];
      v10[99] = s_transientsWorldMP.transientsHighestLOD.array[5];
      v10[100] = s_transientsWorldMP.transientsHighestLOD.array[6];
      v10[101] = s_transientsWorldMP.transientsHighestLOD.array[7];
      v10[102] = s_transientsWorldMP.transientsHighestLOD.array[8];
      v10[103] = s_transientsWorldMP.transientsHighestLOD.array[9];
      v10[104] = s_transientsWorldMP.transientsHighestLOD.array[10];
      v10[105] = s_transientsWorldMP.transientsHighestLOD.array[11];
      v10[106] = s_transientsWorldMP.transientsHighestLOD.array[12];
      v10[107] = s_transientsWorldMP.transientsHighestLOD.array[13];
      v10[108] = s_transientsWorldMP.transientsHighestLOD.array[14];
      v10[109] = s_transientsWorldMP.transientsHighestLOD.array[15];
      v10[110] = s_transientsWorldMP.transientsHighestLOD.array[16];
      v10[111] = s_transientsWorldMP.transientsHighestLOD.array[17];
      v10[112] = s_transientsWorldMP.transientsHighestLOD.array[18];
      v10[113] = s_transientsWorldMP.transientsHighestLOD.array[19];
      v10[114] = s_transientsWorldMP.transientsHighestLOD.array[20];
      v10[115] = s_transientsWorldMP.transientsHighestLOD.array[21];
      v10[116] = s_transientsWorldMP.transientsHighestLOD.array[22];
      v10[117] = s_transientsWorldMP.transientsHighestLOD.array[23];
      v10[118] = s_transientsWorldMP.transientsHighestLOD.array[24];
      v10[119] = s_transientsWorldMP.transientsHighestLOD.array[25];
      v10[120] = s_transientsWorldMP.transientsHighestLOD.array[26];
      v10[121] = s_transientsWorldMP.transientsHighestLOD.array[27];
      v10[122] = s_transientsWorldMP.transientsHighestLOD.array[28];
      v10[123] = s_transientsWorldMP.transientsHighestLOD.array[29];
      v10[124] = s_transientsWorldMP.transientsHighestLOD.array[30];
      v10[125] = s_transientsWorldMP.transientsHighestLOD.array[31];
      v10[126] = s_transientsWorldMP.transientsHighestLOD.array[32];
      v10[127] = s_transientsWorldMP.transientsHighestLOD.array[33];
      v10[128] = s_transientsWorldMP.transientsHighestLOD.array[34];
      v10[129] = s_transientsWorldMP.transientsHighestLOD.array[35];
      v10[130] = s_transientsWorldMP.transientsHighestLOD.array[36];
      v10[131] = s_transientsWorldMP.transientsHighestLOD.array[37];
      v10[132] = s_transientsWorldMP.transientsHighestLOD.array[38];
      v10[133] = s_transientsWorldMP.transientsHighestLOD.array[39];
      v10[134] = s_transientsWorldMP.transientsHighestLOD.array[40];
      v10[135] = s_transientsWorldMP.transientsHighestLOD.array[41];
      v10[136] = s_transientsWorldMP.transientsHighestLOD.array[42];
      v10[137] = s_transientsWorldMP.transientsHighestLOD.array[43];
      v10[138] = s_transientsWorldMP.transientsHighestLOD.array[44];
      v10[139] = s_transientsWorldMP.transientsHighestLOD.array[45];
      v10[140] = s_transientsWorldMP.transientsHighestLOD.array[46];
      v10[141] = s_transientsWorldMP.transientsHighestLOD.array[47];
      v10[190] = s_transientsWorldMP.transientsHighestLOD.array[0];
      v10[191] = s_transientsWorldMP.transientsHighestLOD.array[1];
      v10[192] = s_transientsWorldMP.transientsHighestLOD.array[2];
      v10[193] = s_transientsWorldMP.transientsHighestLOD.array[3];
      v10[194] = s_transientsWorldMP.transientsHighestLOD.array[4];
      v10[195] = s_transientsWorldMP.transientsHighestLOD.array[5];
      v10[196] = s_transientsWorldMP.transientsHighestLOD.array[6];
      v10[197] = s_transientsWorldMP.transientsHighestLOD.array[7];
      v10[198] = s_transientsWorldMP.transientsHighestLOD.array[8];
      v10[199] = s_transientsWorldMP.transientsHighestLOD.array[9];
      v10[200] = s_transientsWorldMP.transientsHighestLOD.array[10];
      v10[201] = s_transientsWorldMP.transientsHighestLOD.array[11];
      v10[202] = s_transientsWorldMP.transientsHighestLOD.array[12];
      v10[203] = s_transientsWorldMP.transientsHighestLOD.array[13];
      v10[204] = s_transientsWorldMP.transientsHighestLOD.array[14];
      v10[205] = s_transientsWorldMP.transientsHighestLOD.array[15];
      v10[206] = s_transientsWorldMP.transientsHighestLOD.array[16];
      v10[207] = s_transientsWorldMP.transientsHighestLOD.array[17];
      v10[208] = s_transientsWorldMP.transientsHighestLOD.array[18];
      v10[209] = s_transientsWorldMP.transientsHighestLOD.array[19];
      v10[210] = s_transientsWorldMP.transientsHighestLOD.array[20];
      v10[211] = s_transientsWorldMP.transientsHighestLOD.array[21];
      v10[212] = s_transientsWorldMP.transientsHighestLOD.array[22];
      v10[213] = s_transientsWorldMP.transientsHighestLOD.array[23];
      v10[214] = s_transientsWorldMP.transientsHighestLOD.array[24];
      v10[215] = s_transientsWorldMP.transientsHighestLOD.array[25];
      v10 += 48;
      v10[168] = s_transientsWorldMP.transientsHighestLOD.array[26];
      v10[169] = s_transientsWorldMP.transientsHighestLOD.array[27];
      v10[170] = s_transientsWorldMP.transientsHighestLOD.array[28];
      v10[171] = s_transientsWorldMP.transientsHighestLOD.array[29];
      v10[172] = s_transientsWorldMP.transientsHighestLOD.array[30];
      v10[173] = s_transientsWorldMP.transientsHighestLOD.array[31];
      v10[174] = s_transientsWorldMP.transientsHighestLOD.array[32];
      v10[175] = s_transientsWorldMP.transientsHighestLOD.array[33];
      v10[176] = s_transientsWorldMP.transientsHighestLOD.array[34];
      v10[177] = s_transientsWorldMP.transientsHighestLOD.array[35];
      v10[178] = s_transientsWorldMP.transientsHighestLOD.array[36];
      v10[179] = s_transientsWorldMP.transientsHighestLOD.array[37];
      v10[180] = s_transientsWorldMP.transientsHighestLOD.array[38];
      v10[181] = s_transientsWorldMP.transientsHighestLOD.array[39];
      v10[182] = s_transientsWorldMP.transientsHighestLOD.array[40];
      v10[183] = s_transientsWorldMP.transientsHighestLOD.array[41];
      v10[184] = s_transientsWorldMP.transientsHighestLOD.array[42];
      v10[185] = s_transientsWorldMP.transientsHighestLOD.array[43];
      v10[186] = s_transientsWorldMP.transientsHighestLOD.array[44];
      v10[187] = s_transientsWorldMP.transientsHighestLOD.array[45];
      v10[188] = s_transientsWorldMP.transientsHighestLOD.array[46];
      v10[189] = s_transientsWorldMP.transientsHighestLOD.array[47];
      --v11;
    }
    while ( v11 );
  }
  ZoneIndexFromName = DB_Zones_GetZoneIndexFromName(s_transientsWorldMP.mapName);
  s_transientsWorldMP.zoneIndex = ZoneIndexFromName;
  if ( ZoneIndexFromName == 0xFFFF )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2013, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.zoneIndex != INVALID_ZONE_INDEX)", (const char *)&queryFormat, "s_transientsWorldMP.zoneIndex != INVALID_ZONE_INDEX") )
      __debugbreak();
    ZoneIndexFromName = s_transientsWorldMP.zoneIndex;
  }
  if ( !ZoneIndexFromName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2014, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX)", (const char *)&queryFormat, "s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX") )
    __debugbreak();
  s_transientsWorldMP.streamProgressCurrentFrame = 0;
  memset_0(s_transientsWorldMP.streamProgressStartTime, 0, sizeof(s_transientsWorldMP.streamProgressStartTime));
  memset_0(s_transientsWorldMP.streamProgressStartFrame, 0, sizeof(s_transientsWorldMP.streamProgressStartFrame));
  memset_0(s_transientsWorldMP.streamProgressTextureState, 0, sizeof(s_transientsWorldMP.streamProgressTextureState));
  *(_WORD *)&s_transientsWorldMP.inLobbyState = 1;
}

/*
==============
CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles
==============
*/
void CL_TransientsWorldMP_RegisterGridStreamingInfoPostFiles(const char *name, const TransientInfo *transientInfo)
{
  unsigned int transientWorldGridHighLodCount; 
  unsigned int v5; 
  unsigned __int64 v6; 
  unsigned int v7; 
  unsigned __int64 v8; 
  unsigned int fileBackedTransientMax; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  unsigned __int16 *transientWorldGridHighLodLookup; 
  __int64 v14; 
  unsigned int v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  unsigned int v21; 

  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2030, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2031, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  if ( !transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2032, ASSERT_TYPE_ASSERT, "(transientInfo)", (const char *)&queryFormat, "transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo != transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2034, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo == transientInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo == transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.mapName != name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2035, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.mapName == name)", (const char *)&queryFormat, "s_transientsWorldMP.mapName == name") )
    __debugbreak();
  if ( s_transientsWorldMP.fileBackedTransientCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2037, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientCount == 0)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientCount == 0") )
    __debugbreak();
  if ( s_transientsWorldMP.fileBackedTransientMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2038, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientMax == 0)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientMax == 0") )
    __debugbreak();
  transientWorldGridHighLodCount = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  v20 = transientWorldGridHighLodCount;
  if ( transientWorldGridHighLodCount )
  {
    if ( transientWorldGridHighLodCount != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2043, ASSERT_TYPE_ASSERT, "( highLODCount ) == ( STREAMINGINFO_WORLD_LOD_COUNT - 1 )", "%s == %s\n\t%i, %i", "highLODCount", "STREAMINGINFO_WORLD_LOD_COUNT - 1", s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount, 2) )
      __debugbreak();
    v5 = 0;
    v21 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / transientWorldGridHighLodCount;
    if ( v21 )
    {
      v6 = 0i64;
      do
      {
        v7 = v5 + 1;
        v8 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookup[transientWorldGridHighLodCount * (v5 + 1) - 1];
        if ( v5 >= 0x600 )
        {
          LODWORD(v19) = 1536;
          LODWORD(v18) = v5;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v18, v19) )
            __debugbreak();
        }
        s_transientsWorldMP.transientsBaseLOD.array[v6 >> 5] |= 0x80000000 >> (v5 & 0x1F);
        if ( (unsigned int)v8 >= 0x600 )
        {
          LODWORD(v19) = 1536;
          LODWORD(v18) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v18, v19) )
            __debugbreak();
        }
        s_transientsWorldMP.transientsHighestLOD.array[v8 >> 5] |= 0x80000000 >> (v8 & 0x1F);
        s_transientsWorldMP.transientLODIndex[v6] = 0;
        if ( v5 )
        {
          if ( v5 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
          {
            LODWORD(v17) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
            LODWORD(v16) = v5;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2057, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "entryIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v16, v17) )
              __debugbreak();
          }
          if ( (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(v5) )
          {
            fileBackedTransientMax = v5 + 1;
            if ( s_transientsWorldMP.fileBackedTransientMax > v7 )
              fileBackedTransientMax = s_transientsWorldMP.fileBackedTransientMax;
            s_transientsWorldMP.fileBackedTransientMax = fileBackedTransientMax;
            if ( s_transientsWorldMP.ignoreTransientSkip || v5 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount || !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v5) )
            {
              s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount++] = truncate_cast<unsigned short,unsigned int>(v5);
              ++s_transientsWorldMP.lodFileCount[0];
            }
          }
          if ( transientWorldGridHighLodCount != 1 )
          {
            v10 = transientWorldGridHighLodCount - 1;
            v11 = 1;
            do
            {
              v12 = transientWorldGridHighLodCount * v5 + v11 - 1;
              transientWorldGridHighLodLookup = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookup;
              v14 = transientWorldGridHighLodLookup[v12];
              if ( transientWorldGridHighLodLookup[v12] )
              {
                if ( (unsigned int)v14 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
                {
                  LODWORD(v17) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
                  LODWORD(v16) = transientWorldGridHighLodLookup[v12];
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2078, ASSERT_TYPE_ASSERT, "(unsigned)( highLODTransient ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "highLODTransient doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v16, v17) )
                    __debugbreak();
                }
                if ( v11 > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)v11, "unsigned", v11) )
                  __debugbreak();
                s_transientsWorldMP.transientLODIndex[v14] = v11;
                if ( v5 > 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)v5, "unsigned", v6) )
                  __debugbreak();
                s_transientsWorldMP.baseLODIndex[v14] = v5;
                if ( (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(v14) )
                {
                  v15 = v14 + 1;
                  if ( s_transientsWorldMP.fileBackedTransientMax > (unsigned int)(v14 + 1) )
                    v15 = s_transientsWorldMP.fileBackedTransientMax;
                  s_transientsWorldMP.fileBackedTransientMax = v15;
                  if ( s_transientsWorldMP.ignoreTransientSkip || (unsigned int)v14 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount || !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v14) )
                  {
                    s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount++] = truncate_cast<unsigned short,unsigned int>(v14);
                    if ( v11 >= 3 )
                    {
                      LODWORD(v17) = 3;
                      LODWORD(v16) = v11;
                      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2091, ASSERT_TYPE_ASSERT, "(unsigned)( highLODNum + 1 ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.lodFileCount ) ) + 0 ) )", "highLODNum + 1 doesn't index s_transientsWorldMP.lodFileCount\n\t%i not in [0, %i)", v16, v17) )
                        __debugbreak();
                    }
                    ++s_transientsWorldMP.lodFileCount[v11];
                  }
                }
              }
              ++v11;
              --v10;
            }
            while ( v10 );
            transientWorldGridHighLodCount = v20;
            v7 = v5 + 1;
          }
        }
        ++v6;
        v5 = v7;
      }
      while ( v7 < v21 );
    }
  }
  if ( s_transientsWorldMP.fileBackedTransientCount > s_transientsWorldMP.fileBackedTransientMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2102, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientCount <= s_transientsWorldMP.fileBackedTransientMax)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientCount <= s_transientsWorldMP.fileBackedTransientMax") )
    __debugbreak();
  if ( s_transientsWorldMP.fileBackedTransientMax > s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2103, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientMax <= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientMax <= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount") )
    __debugbreak();
}

/*
==============
CL_TransientsWorldMP_ResetGridStreaming
==============
*/
void CL_TransientsWorldMP_ResetGridStreaming(bool useSplitscreenRadius)
{
  const dvar_t *v2; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3148, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) )
  {
    if ( s_transientsWorldMP.worldGridInfo )
    {
      if ( s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
      {
        s_transientsWorldMP.numStreamPositions = 0;
        s_transientsWorldMP.radiusMultiplier = FLOAT_1_0;
        if ( useSplitscreenRadius )
        {
          v2 = DCONST_DVARFLT_cl_transientWorldVisibleSplit2Multiplier;
          if ( !DCONST_DVARFLT_cl_transientWorldVisibleSplit2Multiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldVisibleSplit2Multiplier") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v2);
          LODWORD(s_transientsWorldMP.radiusMultiplier) = v2->current.integer;
        }
      }
    }
  }
}

/*
==============
CL_TransientsWorldMP_ResetLobbyStreamPositions
==============
*/
void CL_TransientsWorldMP_ResetLobbyStreamPositions(void)
{
  s_transientsWorldMP.lobbyStreamPosCount = 0;
}

/*
==============
CL_TransientsWorldMP_SetGridStreamingClientStreamViews
==============
*/
void CL_TransientsWorldMP_SetGridStreamingClientStreamViews(LocalClientNum_t localClientNum)
{
  __int128 v1; 
  __int128 v2; 
  LocalClientNum_t v3; 
  unsigned __int64 v4; 
  const dvar_t *v5; 
  const dvar_t *v6; 
  float value; 
  unsigned __int8 v8; 
  double LoadDist; 
  const dvar_t *v10; 
  const dvar_t *v11; 
  const vec3_t *ManualViewVelocity; 
  bool ManualViewStreamRender; 
  const vec3_t *ManualViewAngles; 
  const vec3_t *ManualViewOrigin; 
  __int64 v16; 
  BgWorldStreamingViewMode ManualViewMode; 
  const dvar_t *v18; 
  unsigned int numStreamPositions; 
  __int64 v20; 
  __int64 v21; 
  unsigned __int64 v22; 
  bool *p_streamRender; 
  const dvar_t *v24; 
  __int64 v25; 
  WorldStreamPosition *v26; 
  __m256i v27; 
  const dvar_t *v28; 
  int v29; 
  __m256i v30; 
  __m256i v31; 
  __int128 v32; 
  double v33; 
  __int64 mainCamera; 
  __int64 nextCamera; 
  _BYTE v36[128]; 
  __int128 v37; 
  double v38; 
  int v39; 
  __int128 v40; 
  __int128 v41; 
  unsigned __int64 v43; 

  v3 = localClientNum;
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3338, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    v4 = 0i64;
    v40 = v2;
    v41 = v1;
    v43 = 0i64;
    do
    {
      if ( CL_StreamViews_IsManualViewSet((StreamManualViewType)v4, v3) )
      {
        v5 = DCONST_DVARBOOL_cl_transientWorldIgnoreStreamHints;
        if ( !DCONST_DVARBOOL_cl_transientWorldIgnoreStreamHints && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldIgnoreStreamHints") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v5);
        if ( !v5->current.enabled || !(_DWORD)v4 )
        {
          v6 = DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled;
          value = 0.0;
          if ( !DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistEnabled") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v6);
          if ( v6->current.enabled )
          {
            v8 = CG_WorldStreaming_ConvertManualViewTypeToViewType((const StreamManualViewType)v4);
            LoadDist = CG_WorldStreaming_GetLoadDist(v3, (const BgWorldStreamingViewType)v8);
            v10 = DCONST_DVARFLT_cl_transientWorldLoadDistForceValue;
            value = *(float *)&LoadDist;
            if ( !DCONST_DVARFLT_cl_transientWorldLoadDistForceValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistForceValue") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v10);
            if ( v10->current.value != 0.0 )
            {
              v11 = DCONST_DVARFLT_cl_transientWorldLoadDistForceValue;
              if ( !DCONST_DVARFLT_cl_transientWorldLoadDistForceValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistForceValue") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v11);
              value = v11->current.value;
            }
          }
          ManualViewVelocity = CL_StreamViews_GetManualViewVelocity((StreamManualViewType)v4, v3);
          ManualViewStreamRender = CL_StreamViews_GetManualViewStreamRender((StreamManualViewType)v4, v3);
          ManualViewAngles = CL_StreamViews_GetManualViewAngles((StreamManualViewType)v4, v3);
          ManualViewOrigin = CL_StreamViews_GetManualViewOrigin((StreamManualViewType)v4, v3);
          v16 = (unsigned int)CL_TransientsWorldMP_AddGridStreamingPosInternal(v3, ManualViewOrigin, ManualViewAngles, ManualViewStreamRender, ManualViewVelocity, (_DWORD)v4 == 0, (_DWORD)v4 == 2, value);
          ManualViewMode = CL_StreamViews_GetManualViewMode((StreamManualViewType)v4, v3);
          if ( (_DWORD)v4 && ManualViewMode == EASE_OUT_QUAD )
          {
            v18 = DVARBOOL_cl_transientWorldFallingHintEnabled;
            if ( !DVARBOOL_cl_transientWorldFallingHintEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldFallingHintEnabled") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v18);
            if ( v18->current.enabled )
            {
              numStreamPositions = s_transientsWorldMP.numStreamPositions;
              v20 = v16;
              v21 = v16;
              v22 = 0i64;
              if ( s_transientsWorldMP.numStreamPositions )
              {
                p_streamRender = &s_transientsWorldMP.streamPositions[0].streamRender;
                do
                {
                  if ( *((_DWORD *)p_streamRender - 26) == s_transientsWorldMP.streamPositions[v21].localClientIndex && *p_streamRender )
                  {
                    if ( v22 == v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3394, ASSERT_TYPE_ASSERT, "(baseIndex != index)", (const char *)&queryFormat, "baseIndex != index") )
                      __debugbreak();
                    p_streamRender[5] = 1;
                    numStreamPositions = s_transientsWorldMP.numStreamPositions;
                  }
                  ++v22;
                  p_streamRender += 156;
                }
                while ( v22 < numStreamPositions );
                v4 = v43;
                v3 = localClientNum;
              }
            }
          }
        }
      }
      v43 = ++v4;
    }
    while ( v4 < 5 );
    v24 = DCONST_DVARBOOL_cl_transientWorldDebugHintPosActive;
    if ( !DCONST_DVARBOOL_cl_transientWorldDebugHintPosActive && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugHintPosActive") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v24);
    if ( v24->current.enabled )
    {
      v25 = s_transientsWorldMP.numStreamPositions;
      if ( s_transientsWorldMP.numStreamPositions >= 0xE )
      {
        LODWORD(nextCamera) = 14;
        LODWORD(mainCamera) = s_transientsWorldMP.numStreamPositions;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3407, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.numStreamPositions ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.streamPositions ) ) + 0 ) )", "s_transientsWorldMP.numStreamPositions doesn't index ARRAY_COUNT( s_transientsWorldMP.streamPositions )\n\t%i not in [0, %i)", mainCamera, nextCamera) )
          __debugbreak();
        v25 = s_transientsWorldMP.numStreamPositions;
      }
      v26 = &s_transientsWorldMP.streamPositions[v25];
      memset_0(v36, 0, 0x9Cui64);
      v27 = *(__m256i *)&v36[32];
      v28 = DCONST_DVARVEC3_cl_transientWorldDebugHintPos;
      v29 = v39;
      *(__m256i *)v26->pos.v = *(__m256i *)v36;
      v30 = *(__m256i *)&v36[64];
      *(__m256i *)v26->viewDir3D.v = v27;
      v31 = *(__m256i *)&v36[96];
      *(__m256i *)v26->frustumPlanes[0].v = v30;
      v32 = v37;
      *(__m256i *)v26->frustumPlanes[2].v = v31;
      v33 = v38;
      v26->frustumPlanes[4] = (vec4_t)v32;
      *(double *)&v26->loadDistLimitSq = v33;
      *(_DWORD *)&v26->zoomLoad = v29;
      if ( !v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 734, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugHintPos") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v28);
      LODWORD(v26->pos.v[0]) = v28->current.integer;
      v26->pos.v[1] = v28->current.vector.v[1];
      v26->pos.v[2] = v28->current.vector.v[2];
      ++s_transientsWorldMP.numStreamPositions;
    }
  }
}

/*
==============
CL_TransientsWorldMP_ShouldDrawCellIndexLabel
==============
*/
char CL_TransientsWorldMP_ShouldDrawCellIndexLabel(const unsigned __int16 transientIndex)
{
  const dvar_t *v1; 
  const dvar_t *v3; 
  __int64 v4; 

  v1 = DVARBOOL_cl_transientWorldOverlayTransientIndex;
  if ( !DVARBOOL_cl_transientWorldOverlayTransientIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayTransientIndex") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( !v1->current.enabled || !transientIndex || !s_transientsWorldMP.ignoreTransientSkip && transientIndex < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount && bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, transientIndex) )
    return 0;
  v3 = DCONST_DVARBOOL_cl_transientWorldOverlayDrawAllCellNumbers;
  if ( !DCONST_DVARBOOL_cl_transientWorldOverlayDrawAllCellNumbers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverlayDrawAllCellNumbers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( !v3->current.enabled && !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_cl_transientWorldOverlayDrawDelayValues, "cl_transientWorldOverlayDrawDelayValues") )
  {
    if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_cl_transientWorldOverlayDrawCellNumbers, "cl_transientWorldOverlayDrawCellNumbers") && bitarray_base<bitarray<1536>>::testBit(&s_transientsWorldMP.requested, transientIndex) )
    {
      v4 = 0i64;
      while ( !bitarray_base<bitarray<1536>>::testBit(&s_transientsWorldMP.visibleCurrent[v4], transientIndex) )
      {
        v4 = (unsigned int)(v4 + 1);
        if ( (unsigned int)v4 >= 2 )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

/*
==============
CL_TransientsWorldMP_SoakTestUpdate
==============
*/
void CL_TransientsWorldMP_SoakTestUpdate(void)
{
  const dvar_t *v0; 
  unsigned int soakCurTileIndex; 
  Bounds *transientWorldGridBounds; 
  long double v5; 
  unsigned int v8; 
  __int64 v9; 
  int v10; 
  unsigned int v11; 
  __int64 v12; 
  __int64 v13; 
  char dest[128]; 

  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x80) && s_transientsWorldMP.worldGridInfo && s_transientsWorldMP.systemEnabled && !s_transientsWorldMP.lobbyToGameStart && !s_transientsWorldMP.lobbyPreloadStopped && !s_transientsWorldMP.listenServerStall && s_transientsWorldMP.finishedLoading )
  {
    v0 = DCONST_DVARBOOL_cl_transientWorldSoakTest;
    if ( !DCONST_DVARBOOL_cl_transientWorldSoakTest && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSoakTest") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v0);
    if ( v0->current.enabled )
    {
      if ( s_transientsWorldMP.inSoakTest )
      {
        soakCurTileIndex = s_transientsWorldMP.soakCurTileIndex;
      }
      else
      {
        Cbuf_ExecuteBufferInternal(LOCAL_CLIENT_0, 0, "ufo on\n", 1, 0);
        soakCurTileIndex = 0;
        s_transientsWorldMP.inSoakTest = 1;
        *(_QWORD *)&s_transientsWorldMP.soakCurTileIndex = 0i64;
        s_transientsWorldMP.soakLastTime = __rdtsc();
      }
      if ( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
      {
        transientWorldGridBounds = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
        if ( !transientWorldGridBounds )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3048, ASSERT_TYPE_ASSERT, "(cellBounds)", (const char *)&queryFormat, "cellBounds") )
            __debugbreak();
          soakCurTileIndex = s_transientsWorldMP.soakCurTileIndex;
        }
        _XMM0 = 0i64;
        __asm { vcvtsi2sd xmm0, xmm0, rax }
        if ( (__int64)(__rdtsc() - s_transientsWorldMP.soakLastTime) < 0 )
          *(double *)&_XMM0 = *(double *)&_XMM0 + 1.844674407370955e19;
        v5 = *(double *)&_XMM0 * msecPerRawTimerTick;
        _XMM0 = 0i64;
        __asm { vcvtsi2sd xmm0, xmm0, rcx }
        if ( v5 > *(double *)&_XMM0 )
        {
          v8 = s_transientsWorldMP.lodFileCount[0];
          v9 = 0i64;
          v10 = 0;
          s_transientsWorldMP.soakLastTime = __rdtsc();
          if ( s_transientsWorldMP.lodFileCount[0] )
          {
            while ( 1 )
            {
              v11 = soakCurTileIndex + 1;
              s_transientsWorldMP.soakCurTileIndex = v11;
              if ( v11 == v8 )
              {
                v11 = 0;
                s_transientsWorldMP.soakCurTileIndex = 0;
                s_transientsWorldMP.soakPhase = (s_transientsWorldMP.soakPhase + 1) % 3ui64;
              }
              v9 = v11 + 1;
              if ( (unsigned int)v9 >= 0x600 )
              {
                LODWORD(v13) = 1536;
                LODWORD(v12) = v11 + 1;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3071, ASSERT_TYPE_ASSERT, "(unsigned)( trIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientLODIndex ) ) + 0 ) )", "trIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientLODIndex )\n\t%i not in [0, %i)", v12, v13) )
                  __debugbreak();
              }
              if ( (unsigned int)v9 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
              {
                LODWORD(v13) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
                LODWORD(v12) = v9;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3072, ASSERT_TYPE_ASSERT, "(unsigned)( trIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "trIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v12, v13) )
                  __debugbreak();
              }
              if ( (unsigned int)v9 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
                break;
              if ( !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v9) )
                break;
              if ( ++v10 >= v8 )
                break;
              soakCurTileIndex = s_transientsWorldMP.soakCurTileIndex;
            }
          }
          Com_sprintf<128>((char (*)[128])dest, "setviewpos %.2f %.2f %.2f 0\n", transientWorldGridBounds[v9].midPoint.v[0], transientWorldGridBounds[v9].midPoint.v[1], transientWorldGridBounds[v9].midPoint.v[2]);
          Cbuf_ExecuteBufferInternal(LOCAL_CLIENT_0, 0, dest, 1, 0);
        }
      }
    }
    else if ( s_transientsWorldMP.inSoakTest )
    {
      Cbuf_ExecuteBufferInternal(LOCAL_CLIENT_0, 0, "ufo off\n", 1, 0);
      s_transientsWorldMP.inSoakTest = 0;
    }
  }
}

/*
==============
CL_TransientsWorldMP_UnloadIndex
==============
*/
void CL_TransientsWorldMP_UnloadIndex(const unsigned int worldIndex)
{
  unsigned __int64 v1; 
  unsigned __int16 GridTransientMPIndex; 
  unsigned int v3; 
  unsigned __int64 v4; 
  int v5; 
  LocalClientNum_t v6; 
  unsigned int *v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 

  v1 = worldIndex;
  GridTransientMPIndex = CL_TransientsWorldMP_GetGridTransientMPIndex(worldIndex);
  if ( !GridTransientMPIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1835, ASSERT_TYPE_ASSERT, "(mpIndex != MPINDEX_ALWAYSLOADED)", (const char *)&queryFormat, "mpIndex != MPINDEX_ALWAYSLOADED") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x600 )
  {
    LODWORD(v8) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v8, 1536) )
      __debugbreak();
  }
  v3 = 0x80000000 >> (v1 & 0x1F);
  v4 = v1 >> 5;
  if ( (v3 & s_transientsWorldMP.requested.array[v4]) != 0 )
  {
    if ( !s_transientsWorldMP.requestedCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1839, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.requestedCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.requestedCount > 0") )
      __debugbreak();
    --s_transientsWorldMP.requestedCount;
    if ( (unsigned int)v1 >= 0x600 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v1, 1536) )
      __debugbreak();
    v5 = ~v3;
    s_transientsWorldMP.requested.array[v4] &= v5;
    CL_TransientsMP_UnloadByFileIndex(GridTransientMPIndex);
    if ( (unsigned int)v1 >= 0x600 )
    {
      LODWORD(v10) = 1536;
      LODWORD(v9) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
        __debugbreak();
    }
    s_transientsWorldMP.loaded.array[v4] &= v5;
    TransientCostCalc_Unload(&s_transientsWorldMP.worldCost, v1);
    v6 = LOCAL_CLIENT_0;
    v7 = &s_transientsWorldMP.visibleTarget[0].array[v4];
    do
    {
      CL_TransientsWorld_SetVisibility(v6, v1, 0);
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v10) = 1536;
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
          __debugbreak();
      }
      *(v7 - 96) &= v5;
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v10) = 1536;
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
          __debugbreak();
      }
      *v7 &= v5;
      if ( (unsigned int)v1 >= 0x600 )
      {
        LODWORD(v10) = 1536;
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
          __debugbreak();
      }
      v7[96] &= v5;
      ++v6;
      v7 += 48;
    }
    while ( (unsigned int)v6 < LOCAL_CLIENT_COUNT );
  }
}

/*
==============
CL_TransientsWorldMP_UnregisterGridStreamingInfo
==============
*/
void CL_TransientsWorldMP_UnregisterGridStreamingInfo(const TransientInfo *transientInfo)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2109, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2110, ASSERT_TYPE_ASSERT, "(transientInfo)", (const char *)&queryFormat, "transientInfo") )
    __debugbreak();
  if ( s_transientsWorldMP.worldGridInfo != transientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2112, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo == transientInfo)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo == transientInfo") )
    __debugbreak();
  *(_DWORD *)&s_transientsWorldMP.isLowFlaggingMap = 0x1000000;
  s_transientsWorldMP.worldGridInfo = NULL;
  s_transientsWorldMP.systemEnabled = 0;
  s_transientsWorldMP.mapName = NULL;
  s_transientsWorldMP.zoneIndex = 0;
  s_transientsWorldMP.finishedLoading = 0;
  s_transientsWorldMP.lobbyStreamPosCount = 0;
  *(_DWORD *)s_transientsWorldMP.lodFileCount = 0;
  s_transientsWorldMP.lodFileCount[2] = 0;
  memset_0(s_transientsWorldMP.lastTrPriority, 0, sizeof(s_transientsWorldMP.lastTrPriority));
  CL_TransientsWorldMP_ClearLoadState();
  memset_0(s_transientsWorldMP.transientToMPIndexMapping, 0, sizeof(s_transientsWorldMP.transientToMPIndexMapping));
  s_transientsWorldMP.lod1FalloffBeginSq = FLOAT_3_4028235e38;
  s_transientsWorldMP.tileBudget = 0i64;
  s_transientsWorldMP.preloadingBackToFE = 0;
  *(_WORD *)&s_transientsWorldMP.lobbyToGameStart = 0;
  CL_TransientsWorldMP_ClearVisibilityState();
  s_transientsWorldMP.numStreamPositions = 0;
  s_transientsWorldMP.listenServerStall = 0;
  s_transientsWorldMP.radiusMultiplier = FLOAT_1_0;
}

/*
==============
CL_TransientsWorldMP_UpdateAllVisibility
==============
*/
void CL_TransientsWorldMP_UpdateAllVisibility()
{
  unsigned __int64 v0; 
  bitarray<1536> *p_wantVisibleButNotLoaded; 
  __int64 v2; 
  __int64 v3; 
  bitarray<1536> *p_changedVisible; 
  unsigned int *v5; 
  int v6; 
  unsigned int *v7; 
  signed __int64 v8; 
  __int64 v9; 
  __int64 v10; 
  LocalClientNum_t v21; 
  signed __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v35; 
  unsigned int *v44; 
  __int64 v53; 
  __int128 v54[12]; 
  bitarray_base<bitarray<1536> > v55[200]; 

  v53 = -2i64;
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateAllVisibility");
  v0 = 0i64;
  p_wantVisibleButNotLoaded = &s_transientsWorldMP.wantVisibleButNotLoaded;
  v2 = 3i64;
  v3 = 3i64;
  do
  {
    *(_QWORD *)p_wantVisibleButNotLoaded->array = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded->array[2] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded->array[4] = 0i64;
    p_wantVisibleButNotLoaded = (bitarray<1536> *)((char *)p_wantVisibleButNotLoaded + 64);
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[38] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[40] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[42] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[44] = 0i64;
    *(_QWORD *)&p_wantVisibleButNotLoaded[-1].array[46] = 0i64;
    --v3;
  }
  while ( v3 );
  if ( LODWORD(cl_maxLocalClients) )
  {
    bitarray_base<bitarray<1536>>::copyBitArray(v55, s_transientsWorldMP.visibleCurrent);
    v5 = &s_transientsWorldMP.visibleCurrent[1].array[2];
    v6 = LODWORD(cl_maxLocalClients);
    if ( SLODWORD(cl_maxLocalClients) > 1 )
    {
      v7 = &s_transientsWorldMP.visibleCurrent[1].array[2];
      v8 = (char *)v54 - (char *)&s_transientsWorldMP.visibleCurrent[0].array[2];
      v9 = (unsigned int)(LODWORD(cl_maxLocalClients) - 1);
      do
      {
        v10 = 6i64;
        do
        {
          _XMM1 = *(v7 - 2);
          __asm
          {
            vpinsrd xmm1, xmm1, dword ptr [rcx-4], 1
            vpinsrd xmm1, xmm1, dword ptr [rcx], 2
            vpinsrd xmm1, xmm1, dword ptr [rcx+4], 3
            vpor    xmm1, xmm1, xmmword ptr [rdx+rcx]
          }
          *(_OWORD *)((char *)v7 + v8) = _XMM1;
          _XMM1 = v7[2];
          __asm
          {
            vpinsrd xmm1, xmm1, dword ptr [rcx+0Ch], 1
            vpinsrd xmm1, xmm1, dword ptr [rcx+10h], 2
            vpinsrd xmm1, xmm1, dword ptr [rcx+14h], 3
            vpor    xmm1, xmm1, xmmword ptr [rdx+rcx+10h]
          }
          *(_OWORD *)((char *)v7 + v8 + 16) = _XMM1;
          v7 += 8;
          --v10;
        }
        while ( v10 );
        v8 -= 192i64;
        --v9;
      }
      while ( v9 );
    }
    v21 = LOCAL_CLIENT_0;
    if ( v6 > 0 )
    {
      do
        CL_TransientsWorldMP_UpdateLocalClientVisibility(v21++);
      while ( v21 < SLODWORD(cl_maxLocalClients) );
    }
    bitarray_base<bitarray<1536>>::copyBitArray((bitarray_base<bitarray<1536> > *)v54, s_transientsWorldMP.visibleCurrent);
    if ( SLODWORD(cl_maxLocalClients) > 1 )
    {
      v22 = (char *)v54 - (char *)&s_transientsWorldMP.visibleCurrent[0].array[2] - 192;
      v23 = (unsigned int)(LODWORD(cl_maxLocalClients) - 1);
      do
      {
        v24 = 6i64;
        do
        {
          _XMM1 = *(v5 - 2);
          __asm
          {
            vpinsrd xmm1, xmm1, dword ptr [rbx-4], 1
            vpinsrd xmm1, xmm1, dword ptr [rbx], 2
            vpinsrd xmm1, xmm1, dword ptr [rbx+4], 3
            vpor    xmm1, xmm1, xmmword ptr [rcx+rbx]
          }
          *(_OWORD *)((char *)v5 + v22) = _XMM1;
          _XMM1 = v5[2];
          __asm
          {
            vpinsrd xmm1, xmm1, dword ptr [rbx+0Ch], 1
            vpinsrd xmm1, xmm1, dword ptr [rbx+10h], 2
            vpinsrd xmm1, xmm1, dword ptr [rbx+14h], 3
            vpor    xmm1, xmm1, xmmword ptr [rcx+rbx+10h]
          }
          *(_OWORD *)((char *)v5 + v22 + 16) = _XMM1;
          v5 += 8;
          --v24;
        }
        while ( v24 );
        v22 -= 192i64;
        --v23;
      }
      while ( v23 );
    }
    bitarray_base<bitarray<1536>>::copyBitArray(&s_transientsWorldMP.changedVisible, v55);
    v35 = 3i64;
    do
    {
      _XMM1 = v54[v0 / 0x10];
      __asm { vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AB0h] }
      *(_OWORD *)&s_transientsWorldMP.changedVisible.array[v0 / 4] = _XMM1;
      _XMM1 = v54[v0 / 0x10 + 1];
      __asm { vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AC0h] }
      *(_OWORD *)&s_transientsWorldMP.changedVisible.array[v0 / 4 + 4] = _XMM1;
      _XMM1 = v54[v0 / 0x10 + 2];
      __asm { vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AD0h] }
      *(_OWORD *)&s_transientsWorldMP.changedVisible.array[v0 / 4 + 8] = _XMM1;
      _XMM1 = v54[v0 / 0x10 + 3];
      __asm { vpxor   xmm1, xmm1, xmmword ptr [rdi+rcx+1AE0h] }
      *(_OWORD *)&s_transientsWorldMP.changedVisible.array[v0 / 4 + 12] = _XMM1;
      v0 += 64i64;
      --v35;
    }
    while ( v35 );
    v44 = &s_transientsWorldMP.changedVisible.array[4];
    do
    {
      _XMM1 = *((_OWORD *)v44 + 23);
      __asm { vpand   xmm1, xmm1, xmmword ptr [rax-10h] }
      *((_OWORD *)v44 - 1) = _XMM1;
      _XMM2 = *((_OWORD *)v44 + 24);
      __asm { vpand   xmm1, xmm2, xmmword ptr [rax] }
      *(_OWORD *)v44 = _XMM1;
      _XMM1 = *((_OWORD *)v44 + 25);
      __asm { vpand   xmm1, xmm1, xmmword ptr [rax+10h] }
      *((_OWORD *)v44 + 1) = _XMM1;
      _XMM1 = *((_OWORD *)v44 + 26);
      __asm { vpand   xmm1, xmm1, xmmword ptr [rax+20h] }
      *((_OWORD *)v44 + 2) = _XMM1;
      v44 += 16;
      --v2;
    }
    while ( v2 );
  }
  else
  {
    p_changedVisible = &s_transientsWorldMP.changedVisible;
    do
    {
      *(_QWORD *)p_changedVisible->array = 0i64;
      *(_QWORD *)&p_changedVisible->array[2] = 0i64;
      *(_QWORD *)&p_changedVisible->array[4] = 0i64;
      p_changedVisible = (bitarray<1536> *)((char *)p_changedVisible + 64);
      *(_QWORD *)&p_changedVisible[-1].array[38] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[40] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[42] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[44] = 0i64;
      *(_QWORD *)&p_changedVisible[-1].array[46] = 0i64;
      --v2;
    }
    while ( v2 );
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_UpdateIgnoreTransientSkip
==============
*/
void CL_TransientsWorldMP_UpdateIgnoreTransientSkip(void)
{
  const dvar_t *v0; 
  bool enabled; 
  unsigned int v2; 
  const TransientInfo *worldGridInfo; 
  unsigned int i; 
  const TransientInfo *v5; 
  unsigned int v6; 
  unsigned __int64 v7; 
  unsigned int v8; 
  __int64 v9; 
  __int64 v10; 

  v0 = DCONST_DVARBOOL_cl_transientWorldIgnoreTransientSkip;
  if ( !DCONST_DVARBOOL_cl_transientWorldIgnoreTransientSkip && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldIgnoreTransientSkip") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  enabled = v0->current.enabled;
  if ( s_transientsWorldMP.ignoreTransientSkip != enabled )
  {
    v2 = 0;
    if ( enabled )
    {
      if ( s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
      {
        do
        {
          worldGridInfo = s_transientsWorldMP.worldGridInfo;
          if ( v2 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
          {
            LODWORD(v10) = s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount;
            LODWORD(v9) = v2;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, v10) )
              __debugbreak();
          }
          if ( ((0x80000000 >> (v2 & 0x1F)) & worldGridInfo->transientSkipLoading.array[(unsigned __int64)v2 >> 5]) != 0 && (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(v2) )
          {
            if ( s_transientsWorldMP.fileBackedTransientCount >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = s_transientsWorldMP.fileBackedTransientCount;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2961, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.fileBackedTransientCount ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "s_transientsWorldMP.fileBackedTransientCount doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount++] = truncate_cast<unsigned short,unsigned int>(v2);
          }
          ++v2;
        }
        while ( v2 < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount );
      }
    }
    else
    {
      for ( i = 0; i < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount; ++i )
      {
        v5 = s_transientsWorldMP.worldGridInfo;
        if ( i >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount )
        {
          LODWORD(v10) = s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount;
          LODWORD(v9) = i;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, v10) )
            __debugbreak();
        }
        v6 = 0x80000000 >> (i & 0x1F);
        v7 = (unsigned __int64)i >> 5;
        if ( (v6 & v5->transientSkipLoading.array[v7]) != 0 && (unsigned __int16)CL_TransientsWorldMP_GetGridTransientMPIndex(i) )
        {
          if ( i >= 0x600 )
          {
            LODWORD(v10) = 1536;
            LODWORD(v9) = i;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, v10) )
              __debugbreak();
          }
          if ( (v6 & s_transientsWorldMP.requested.array[v7]) != 0 )
            CL_TransientsWorldMP_UnloadIndex(i);
          v8 = 0;
          if ( !s_transientsWorldMP.fileBackedTransientCount )
            goto LABEL_37;
          while ( 1 )
          {
            if ( v8 >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = v8;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2985, ASSERT_TYPE_ASSERT, "(unsigned)( orderIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "orderIndex doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            if ( s_transientsWorldMP.priorityOrder[v8] == i )
              break;
            if ( ++v8 >= s_transientsWorldMP.fileBackedTransientCount )
              goto LABEL_37;
          }
          if ( v8 >= s_transientsWorldMP.fileBackedTransientCount )
          {
LABEL_37:
            LODWORD(v10) = s_transientsWorldMP.fileBackedTransientCount;
            LODWORD(v9) = v8;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2991, ASSERT_TYPE_ASSERT, "(unsigned)( orderIndex ) < (unsigned)( s_transientsWorldMP.fileBackedTransientCount )", "orderIndex doesn't index s_transientsWorldMP.fileBackedTransientCount\n\t%i not in [0, %i)", v9, v10) )
              __debugbreak();
          }
          if ( v8 < s_transientsWorldMP.fileBackedTransientCount - 1 )
          {
            if ( v8 >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = v8;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2994, ASSERT_TYPE_ASSERT, "(unsigned)( orderIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "orderIndex doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            if ( s_transientsWorldMP.fileBackedTransientCount - 1 >= 0x600 )
            {
              LODWORD(v10) = 1536;
              LODWORD(v9) = s_transientsWorldMP.fileBackedTransientCount - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2995, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.fileBackedTransientCount - 1 ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "s_transientsWorldMP.fileBackedTransientCount - 1 doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", v9, v10) )
                __debugbreak();
            }
            s_transientsWorldMP.priorityOrder[v8] = s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount - 1];
          }
          if ( !s_transientsWorldMP.fileBackedTransientCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2999, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.fileBackedTransientCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.fileBackedTransientCount > 0") )
            __debugbreak();
          --s_transientsWorldMP.fileBackedTransientCount;
        }
      }
    }
    s_transientsWorldMP.ignoreTransientSkip = enabled;
  }
}

/*
==============
CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions
==============
*/
void CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions()
{
  float v0; 
  __int64 numStreamPositions; 
  char *v2; 
  vec3_t *lobbyStreamPos; 
  __int64 v4; 
  char *v5; 
  const dvar_t *v6; 
  const dvar_t *v7; 
  const char *v8; 
  float *priorityDistXY; 
  __int64 v10; 
  __int64 v11; 
  float *priorityDistZ; 
  float *v13; 
  __int64 v14; 
  float *priorityViewDot; 
  float v16; 
  float VisibilityRadiusWithoutPos; 
  float v18; 
  Bounds *transientWorldGridBounds; 
  unsigned int v20; 
  unsigned __int64 v21; 
  unsigned __int8 *transientLODIndex; 
  unsigned __int16 *baseLODIndex; 
  float *v24; 
  float v26; 
  float v27; 
  float v28; 
  unsigned __int64 v29; 
  unsigned int v30; 
  int v31; 
  unsigned int *v32; 
  char v33; 
  float *p_loadDistLimitSq; 
  __int128 v35; 
  __int128 v36; 
  float v37; 
  __int128 v38; 
  __int128 v39; 
  float v40; 
  bool v41; 
  bitarray<1536> *v42; 
  float v43; 
  __int128 v44; 
  bool v48; 
  const dvar_t *v49; 
  bool v50; 
  __int128 unsignedInt; 
  const dvar_t *v53; 
  const dvar_t *v54; 
  __int128 v56; 
  const dvar_t *v57; 
  bool lod1BoostBRMethod; 
  __int128 v61; 
  int v65; 
  unsigned int v66; 
  unsigned __int64 v67; 
  unsigned __int16 *transientToMPIndexMapping; 
  unsigned int v69; 
  int v70; 
  unsigned int fileBackedTransientCount; 
  unsigned int *lastTrPriority; 
  unsigned __int64 BudgetBytes; 
  __int64 v74; 
  unsigned __int64 v75; 
  unsigned __int64 v76; 
  unsigned __int8 v77; 
  int v78; 
  __int64 v79; 
  __int64 v80; 
  unsigned __int64 v81; 
  bool v82; 
  const dvar_t *v83; 
  unsigned int v84; 
  unsigned int v85; 
  unsigned int v86; 
  unsigned int v87; 
  unsigned int v88; 
  unsigned __int64 v89; 
  bool v90; 
  unsigned __int64 CurCost; 
  unsigned __int16 v92; 
  unsigned __int64 v93; 
  int v94; 
  int v95; 
  int v96; 
  const dvar_t *v97; 
  const dvar_t *v98; 
  const dvar_t *v99; 
  int v100; 
  unsigned __int64 tileBudget; 
  unsigned __int64 v102; 
  const dvar_t *v103; 
  const char *v104; 
  const char *v105; 
  __int64 cellSize; 
  __int64 useZoomedDistances; 
  __int64 isStreamingHint; 
  __int64 lod0Missing; 
  bool v110; 
  char v111; 
  bool IsLoadModeInFrontend; 
  int value; 
  unsigned int lobbyStreamPosCount; 
  unsigned int fileBackedTransientMax; 
  unsigned int v116; 
  unsigned int lod; 
  unsigned int v118; 
  float v119; 
  unsigned __int8 *v120; 
  unsigned __int64 v121; 
  InterleavedPriorities v122; 
  unsigned __int64 v123; 
  float *v124; 
  unsigned int v125; 
  WorldStreamPosition *streamPositions; 
  float *v127; 
  unsigned __int16 *v128; 
  Bounds *bounds; 
  __int64 v130; 
  __m256i v131; 
  __m256i v132; 
  __m256i v133; 
  __m256i v134; 
  __int128 v135; 
  double v136; 
  int v137; 
  vec3_t outPointToClosestVec; 
  vec3_t mins; 
  vec3_t maxs; 
  _BYTE v141[128]; 
  __int128 v142; 
  double v143; 
  int v144; 
  char v145[328]; 

  v130 = -2i64;
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateLoadAndUnloadDecisions");
  value = 0;
  *(_DWORD *)&v122.nextEmptyTileIndex = 0;
  *(_DWORD *)&v122.nextLod1SubTileIndex = 190185472;
  v122.spilloverIndex = 0;
  IsLoadModeInFrontend = CL_TransientsMP_IsLoadModeInFrontend();
  CL_TransientsWorldMP_UpdatePageBudget();
  if ( s_transientsWorldMP.worldGridInfo->transientWorldGridTileMapCount )
    v0 = s_transientsWorldMP.worldGridInfo->transientWorldGridTileMaps->cellSize;
  else
    v0 = 0.0;
  numStreamPositions = s_transientsWorldMP.numStreamPositions;
  lobbyStreamPosCount = s_transientsWorldMP.numStreamPositions;
  streamPositions = s_transientsWorldMP.streamPositions;
  if ( !s_transientsWorldMP.numStreamPositions )
  {
    numStreamPositions = s_transientsWorldMP.lobbyStreamPosCount;
    lobbyStreamPosCount = s_transientsWorldMP.lobbyStreamPosCount;
    if ( s_transientsWorldMP.lobbyStreamPosCount )
    {
      v2 = v145;
      lobbyStreamPos = s_transientsWorldMP.lobbyStreamPos;
      v4 = s_transientsWorldMP.lobbyStreamPosCount;
      do
      {
        memset_0(&v131, 0, 0x9Cui64);
        *(__m256i *)v2 = v131;
        *((__m256i *)v2 + 1) = v132;
        *((__m256i *)v2 + 2) = v133;
        *((__m256i *)v2 + 3) = v134;
        *((_OWORD *)v2 + 8) = v135;
        *((double *)v2 + 18) = v136;
        *((_DWORD *)v2 + 38) = v137;
        *(double *)v2 = *(double *)lobbyStreamPos->v;
        *((_DWORD *)v2 + 2) = LODWORD(lobbyStreamPos->v[2]);
        ++lobbyStreamPos;
        v2 += 156;
        --v4;
      }
      while ( v4 );
      v5 = v145;
    }
    else
    {
      memset_0(&v131, 0, 0x9Cui64);
      *(__m256i *)v141 = v131;
      *(__m256i *)&v141[32] = v132;
      *(__m256i *)&v141[64] = v133;
      *(__m256i *)&v141[96] = v134;
      v142 = v135;
      v143 = v136;
      v144 = v137;
      v6 = DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos;
      if ( !DCONST_DVARVEC3_cl_transientWorldLoadDefaultPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 734, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDefaultPos") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v6);
      *(_DWORD *)v141 = v6->current.integer;
      *(float *)&v141[4] = v6->current.vector.v[1];
      *(float *)&v141[8] = v6->current.vector.v[2];
      numStreamPositions = 1i64;
      lobbyStreamPosCount = 1;
      v5 = v141;
    }
    streamPositions = (WorldStreamPosition *)v5;
  }
  if ( !s_transientsWorldMP.isBRMap )
  {
    v7 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBegin;
    if ( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBegin )
      goto LABEL_24;
    v8 = "cl_transientWorldLoadXYLOD1FalloffBegin";
LABEL_22:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v8) )
      __debugbreak();
    goto LABEL_24;
  }
  if ( !s_transientsWorldMP.inLobbyState )
  {
    v7 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBR;
    if ( DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBR )
      goto LABEL_24;
    v8 = "cl_transientWorldLoadXYLOD1FalloffBeginBR";
    goto LABEL_22;
  }
  v7 = DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRLobby;
  if ( !DCONST_DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRLobby )
  {
    v8 = "cl_transientWorldLoadXYLOD1FalloffBeginBRLobby";
    goto LABEL_22;
  }
LABEL_24:
  Dvar_CheckFrontendServerThread(v7);
  s_transientsWorldMP.lod1FalloffBeginSq = v7->current.value * v7->current.value;
  priorityDistXY = s_transientsWorldMP.priorityDistXY;
  v10 = 96i64;
  v11 = 96i64;
  do
  {
    *(_QWORD *)priorityDistXY = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY + 1) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY + 2) = 0x7F7FFFFF7F7FFFFFi64;
    priorityDistXY += 16;
    *((_QWORD *)priorityDistXY - 5) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 4) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 3) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 2) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)priorityDistXY - 1) = 0x7F7FFFFF7F7FFFFFi64;
    --v11;
  }
  while ( v11 );
  priorityDistZ = s_transientsWorldMP.priorityDistZ;
  v124 = s_transientsWorldMP.priorityDistZ;
  v13 = s_transientsWorldMP.priorityDistZ;
  v14 = 96i64;
  do
  {
    *(_QWORD *)v13 = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v13 + 1) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v13 + 2) = 0x7F7FFFFF7F7FFFFFi64;
    v13 += 16;
    *((_QWORD *)v13 - 5) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v13 - 4) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v13 - 3) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v13 - 2) = 0x7F7FFFFF7F7FFFFFi64;
    *((_QWORD *)v13 - 1) = 0x7F7FFFFF7F7FFFFFi64;
    --v14;
  }
  while ( v14 );
  priorityViewDot = s_transientsWorldMP.priorityViewDot;
  do
  {
    *(_QWORD *)priorityViewDot = 0i64;
    *((_QWORD *)priorityViewDot + 1) = 0i64;
    *((_QWORD *)priorityViewDot + 2) = 0i64;
    priorityViewDot += 16;
    *((_QWORD *)priorityViewDot - 5) = 0i64;
    *((_QWORD *)priorityViewDot - 4) = 0i64;
    *((_QWORD *)priorityViewDot - 3) = 0i64;
    *((_QWORD *)priorityViewDot - 2) = 0i64;
    *((_QWORD *)priorityViewDot - 1) = 0i64;
    --v10;
  }
  while ( v10 );
  v16 = (float)(v0 * v0) * 4.0;
  v119 = v16;
  VisibilityRadiusWithoutPos = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(0);
  v18 = VisibilityRadiusWithoutPos * VisibilityRadiusWithoutPos;
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "TransientWorldPopulatePriorityList");
  transientWorldGridBounds = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
  fileBackedTransientMax = s_transientsWorldMP.fileBackedTransientMax;
  v20 = 0;
  v118 = 0;
  if ( !s_transientsWorldMP.fileBackedTransientMax )
    goto LABEL_96;
  v21 = 0i64;
  v123 = 0i64;
  transientLODIndex = s_transientsWorldMP.transientLODIndex;
  v120 = s_transientsWorldMP.transientLODIndex;
  baseLODIndex = s_transientsWorldMP.baseLODIndex;
  v128 = s_transientsWorldMP.baseLODIndex;
  v24 = &transientWorldGridBounds->halfSize.v[2];
  v127 = v24;
  do
  {
    lod = *transientLODIndex;
    *(float *)&_XMM11 = FLOAT_3_4028235e38;
    bounds = (Bounds *)(v24 - 5);
    v26 = *(v24 - 5);
    mins.v[0] = v26 - *(v24 - 2);
    v27 = *(v24 - 4);
    mins.v[1] = v27 - *(v24 - 1);
    v28 = *(v24 - 3);
    mins.v[2] = v28 - *v24;
    maxs.v[0] = v26 + *(v24 - 2);
    maxs.v[1] = v27 + *(v24 - 1);
    maxs.v[2] = v28 + *v24;
    v110 = 0;
    if ( lod )
    {
      v29 = *baseLODIndex;
      if ( *baseLODIndex )
      {
        if ( (unsigned int)v29 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = *baseLODIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        v30 = 0x80000000 >> (v29 & 0x1F);
        v110 = 1;
        if ( (v30 & s_transientsWorldMP.loaded.array[v29 >> 5]) != 0 )
        {
          v31 = 0;
          v110 = 1;
          if ( SLODWORD(cl_maxLocalClients) > 0 )
          {
            v32 = &s_transientsWorldMP.visibleCurrent[0].array[v29 >> 5];
            while ( 1 )
            {
              if ( (unsigned int)v29 >= 0x600 )
              {
                LODWORD(useZoomedDistances) = 1536;
                LODWORD(cellSize) = v29;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                  __debugbreak();
              }
              if ( (v30 & *v32) != 0 )
                break;
              ++v31;
              v32 += 48;
              if ( v31 >= SLODWORD(cl_maxLocalClients) )
              {
                v110 = 1;
                goto LABEL_48;
              }
            }
            v110 = 0;
LABEL_48:
            priorityDistZ = v124;
          }
        }
        v24 = v127;
        v21 = v123;
        baseLODIndex = v128;
      }
      else
      {
        v110 = 1;
      }
    }
    if ( !(_DWORD)numStreamPositions )
      goto LABEL_94;
    v33 = v20 & 0x1F;
    v125 = v20 & 0x1F;
    p_loadDistLimitSq = &streamPositions->loadDistLimitSq;
    do
    {
      PointToClosestAABBPoint(&mins, &maxs, (const vec3_t *)p_loadDistLimitSq - 12, &outPointToClosestVec);
      v35 = LODWORD(outPointToClosestVec.v[1]);
      v36 = v35;
      v37 = outPointToClosestVec.v[0];
      *(float *)&v36 = (float)(*(float *)&v35 * *(float *)&v35) + (float)(v37 * v37);
      v38 = v36;
      v39 = LODWORD(outPointToClosestVec.v[2]);
      v40 = (float)(*(float *)&v39 * *(float *)&v39) + *(float *)&v36;
      if ( *p_loadDistLimitSq != 0.0 && v40 > *p_loadDistLimitSq )
        goto LABEL_92;
      v41 = 0;
      if ( *((_BYTE *)p_loadDistLimitSq + 8) )
      {
        if ( *((_DWORD *)p_loadDistLimitSq - 25) >= 2u )
        {
          LODWORD(useZoomedDistances) = 2;
          *(float *)&cellSize = *(p_loadDistLimitSq - 25);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2667, ASSERT_TYPE_ASSERT, "(unsigned)( streamPos.localClientIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.zoomTransients ) ) + 0 ) )", "streamPos.localClientIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.zoomTransients )\n\t%i not in [0, %i)", cellSize, useZoomedDistances) )
            __debugbreak();
          v37 = outPointToClosestVec.v[0];
          v35 = LODWORD(outPointToClosestVec.v[1]);
        }
        v42 = &s_transientsWorldMP.zoomTransients[*((int *)p_loadDistLimitSq - 25)];
        if ( v20 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = v20;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
            __debugbreak();
          v37 = outPointToClosestVec.v[0];
          v35 = LODWORD(outPointToClosestVec.v[1]);
        }
        v41 = ((0x80000000 >> v33) & v42->array[v123 >> 5]) != 0;
      }
      v43 = 0.0;
      if ( lod == 1 )
      {
        v44 = v35;
        *(float *)&v44 = fsqrt((float)(*(float *)&v35 * *(float *)&v35) + (float)(v37 * v37));
        _XMM2 = v44;
        __asm
        {
          vcmpless xmm0, xmm2, cs:__real@80000000
          vblendvps xmm1, xmm2, xmm13, xmm0
        }
        v43 = (float)((float)((float)(1.0 / *(float *)&_XMM1) * *(float *)&v35) * *(p_loadDistLimitSq - 29)) + (float)((float)((float)(1.0 / *(float *)&_XMM1) * v37) * *(p_loadDistLimitSq - 30));
      }
      v48 = *((_BYTE *)p_loadDistLimitSq + 5) == 0;
      if ( s_transientsWorldMP.isBRMap )
      {
        v49 = DVARFLT_cl_transientWorldBRPlaneZThreshold;
        if ( !DVARFLT_cl_transientWorldBRPlaneZThreshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBRPlaneZThreshold") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v49);
        v50 = v49->current.value <= *(p_loadDistLimitSq - 34);
      }
      else
      {
        v50 = 0;
      }
      *(float *)&_XMM6 = s_transientsWorldMP.lod1FalloffBeginSq;
      if ( v41 )
      {
        unsignedInt = *((unsigned int *)p_loadDistLimitSq - 21);
      }
      else
      {
        v53 = DVARBOOL_cl_transientWorldLoadXYLOD1FalloffPlaneEnabled;
        if ( !DVARBOOL_cl_transientWorldLoadXYLOD1FalloffPlaneEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1FalloffPlaneEnabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v53);
        if ( !v53->current.enabled || !v50 )
          goto LABEL_84;
        v54 = DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRPlane;
        if ( !DVARFLT_cl_transientWorldLoadXYLOD1FalloffBeginBRPlane && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1FalloffBeginBRPlane") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v54);
        unsignedInt = v54->current.unsignedInt;
      }
      v56 = unsignedInt;
      *(float *)&v56 = *(float *)&unsignedInt * *(float *)&unsignedInt;
      _XMM1 = v56;
      __asm { vmaxss  xmm6, xmm1, xmm6 }
LABEL_84:
      v57 = DVARBOOL_cl_transientWorldLoadXYLOD1BoostInAirBRMethodEnabled;
      if ( !DVARBOOL_cl_transientWorldLoadXYLOD1BoostInAirBRMethodEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadXYLOD1BoostInAirBRMethodEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v57);
      lod1BoostBRMethod = v57->current.enabled && v50;
      _XMM0 = LODWORD(v119);
      *(float *)&_XMM0 = CL_TransientsWorldMP_CalcLoadPriorityDistance((const WorldStreamPosition *)(p_loadDistLimitSq - 36), *(float *)&v38, *(float *)&v39, lod, bounds, v0, v41, v48, v110, v43, v119, v18, *(const float *)&_XMM6, lod1BoostBRMethod);
      __asm { vminss  xmm11, xmm0, xmm11 }
      v61 = v38;
      *(float *)&v61 = fsqrt(*(float *)&v38);
      _XMM1 = v61;
      priorityDistZ = v124;
      __asm { vminss  xmm0, xmm1, dword ptr [rbx-1800h] }
      *(v124 - 1536) = *(float *)&_XMM0;
      _XMM8 = v39 & (unsigned int)_xmm;
      __asm { vminss  xmm0, xmm8, dword ptr [rbx] }
      *priorityDistZ = *(float *)&_XMM0;
      priorityDistZ[1536] = v43;
      v33 = v125;
      v20 = v118;
LABEL_92:
      p_loadDistLimitSq += 39;
      --numStreamPositions;
    }
    while ( numStreamPositions );
    v24 = v127;
    v21 = v123;
    numStreamPositions = lobbyStreamPosCount;
    baseLODIndex = v128;
LABEL_94:
    *(priorityDistZ - 6538) = *(float *)&_XMM11;
    v118 = ++v20;
    v123 = ++v21;
    transientLODIndex = ++v120;
    v24 += 6;
    v127 = v24;
    v128 = ++baseLODIndex;
    v124 = ++priorityDistZ;
  }
  while ( v20 < fileBackedTransientMax );
  v16 = (float)(v0 * v0) * 4.0;
LABEL_96:
  Sys_ProfEndNamedEvent();
  v65 = 0;
  v66 = 0;
  v67 = 0i64;
  transientToMPIndexMapping = s_transientsWorldMP.transientToMPIndexMapping;
  do
  {
    if ( *transientToMPIndexMapping )
    {
      if ( ((0x80000000 >> (v66 & 0x1F)) & s_transientsWorldMP.requested.array[v67 >> 5]) != 0 )
        ++v65;
    }
    else
    {
      v69 = 0x80000000 >> (v66 & 0x1F);
      s_transientsWorldMP.loaded.array[v67 >> 5] |= v69;
      s_transientsWorldMP.requested.array[v67 >> 5] |= v69;
    }
    ++v66;
    ++v67;
    ++transientToMPIndexMapping;
  }
  while ( v66 < 0x600 );
  v70 = 0;
  if ( v65 != s_transientsWorldMP.requestedCount )
  {
    LODWORD(lod0Missing) = s_transientsWorldMP.requestedCount;
    LODWORD(isStreamingHint) = v65;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2738, ASSERT_TYPE_ASSERT, "( validateCount ) == ( s_transientsWorldMP.requestedCount )", "%s == %s\n\t%u, %u", "validateCount", "s_transientsWorldMP.requestedCount", isStreamingHint, lod0Missing) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "TransientWorldSortPriorityList");
  std::_Sort_unchecked<unsigned short *,WorldStreamOrderSort>(s_transientsWorldMP.priorityOrder, &s_transientsWorldMP.priorityOrder[s_transientsWorldMP.fileBackedTransientCount], s_transientsWorldMP.fileBackedTransientCount, (WorldStreamOrderSort)IsLoadModeInFrontend);
  Sys_ProfEndNamedEvent();
  fileBackedTransientCount = s_transientsWorldMP.fileBackedTransientCount;
  lastTrPriority = s_transientsWorldMP.lastTrPriority;
  if ( s_transientsWorldMP.fileBackedTransientCount )
  {
    Sys_ProfBeginNamedEvent(0xFFFFFFFF, "TransientWorldIssueLoadAndUnloads");
    BudgetBytes = CL_TransientsWorldMP_GetBudgetBytes();
    v121 = BudgetBytes;
    v74 = fileBackedTransientCount - 1;
    if ( (unsigned int)v74 < fileBackedTransientCount )
    {
      v75 = BudgetBytes;
      do
      {
        if ( TransientCostCalc_GetCurCost(&s_transientsWorldMP.worldCost, IsLoadModeInFrontend) <= v75 )
          break;
        if ( (unsigned int)v74 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = v74;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2764, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.priorityOrder ) ) + 0 ) )", "i doesn't index s_transientsWorldMP.priorityOrder\n\t%i not in [0, %i)", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        v76 = s_transientsWorldMP.priorityOrder[v74];
        v77 = s_transientsWorldMP.transientLODIndex[v76];
        if ( v77 >= 3u )
        {
          LODWORD(useZoomedDistances) = 3;
          LODWORD(cellSize) = v77;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2766, ASSERT_TYPE_ASSERT, "(unsigned)( s_transientsWorldMP.transientLODIndex[freeWorldIndex] ) < (unsigned)( STREAMINGINFO_WORLD_LOD_COUNT )", "s_transientsWorldMP.transientLODIndex[freeWorldIndex] doesn't index STREAMINGINFO_WORLD_LOD_COUNT\n\t%i not in [0, %i)", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        if ( (unsigned int)v76 >= 0x600 )
        {
          LODWORD(useZoomedDistances) = 1536;
          LODWORD(cellSize) = v76;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
            __debugbreak();
        }
        if ( ((0x80000000 >> (v76 & 0x1F)) & s_transientsWorldMP.requested.array[v76 >> 5]) != 0 )
          CL_TransientsWorldMP_UnloadIndex(v76);
        v74 = (unsigned int)(v74 - 1);
      }
      while ( (unsigned int)v74 < fileBackedTransientCount );
      lastTrPriority = s_transientsWorldMP.lastTrPriority;
      v70 = 0;
    }
    v116 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
    if ( !s_transientsWorldMP.inLobbyState || (v111 = 1, !s_transientsWorldMP.isBRMap) )
      v111 = 0;
    v78 = fileBackedTransientCount - 1;
    memset_0(s_transientsWorldMP.lastTrPriority, 0, sizeof(s_transientsWorldMP.lastTrPriority));
    if ( !s_transientsWorldMP.preloadingBackToFE )
    {
      v79 = v78;
      if ( v78 >= 0 )
      {
        v80 = 0i64;
        while ( 1 )
        {
          v81 = s_transientsWorldMP.priorityOrder[v80];
          v82 = v16 > s_transientsWorldMP.priorityList[v81].loadDistanceSq;
          v83 = DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled;
          if ( !DCONST_DVARBOOL_cl_transientWorldLoadDistEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLoadDistEnabled") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v83);
          if ( !v83->current.enabled || s_transientsWorldMP.priorityList[v81].loadDistanceSq < 3.4028235e38 )
            goto LABEL_215;
          if ( (unsigned int)v81 >= 0x600 )
          {
            LODWORD(useZoomedDistances) = 1536;
            LODWORD(cellSize) = v81;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
              __debugbreak();
          }
          v84 = 0x80000000 >> (v81 & 0x1F);
          if ( (v84 & s_transientsWorldMP.loaded.array[v81 >> 5]) != 0 )
          {
LABEL_215:
            if ( (unsigned int)v81 >= 0x600 )
            {
              LODWORD(useZoomedDistances) = 1536;
              LODWORD(cellSize) = v81;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                __debugbreak();
            }
            if ( ((0x80000000 >> (v81 & 0x1F)) & s_transientsWorldMP.requested.array[v81 >> 5]) == 0 && ((CurCost = TransientCostCalc_GetCurCost(&s_transientsWorldMP.worldCost, IsLoadModeInFrontend), TransientCostCalc_GetCostToLoad(&s_transientsWorldMP.worldCost, v81, IsLoadModeInFrontend) + CurCost > v121) || s_transientsWorldMP.requestedCount >= 0x400 || (unsigned int)v81 < v116 && v111) )
            {
              if ( v79 > v80 )
              {
                while ( 1 )
                {
                  v93 = s_transientsWorldMP.priorityOrder[v79];
                  if ( (unsigned int)v93 >= 0x600 )
                  {
                    LODWORD(useZoomedDistances) = 1536;
                    LODWORD(cellSize) = s_transientsWorldMP.priorityOrder[v79];
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                      __debugbreak();
                  }
                  if ( ((0x80000000 >> (v93 & 0x1F)) & s_transientsWorldMP.requested.array[v93 >> 5]) != 0 )
                    break;
                  if ( --v79 <= v80 )
                    goto LABEL_142;
                }
                CL_TransientsWorldMP_UnloadIndex(v93);
                goto LABEL_143;
              }
            }
            else
            {
              v92 = InterleavedPriorities::Insert(&v122, v81, v82);
              CL_TransientsWorldMP_LoadIndex(v81, v92);
            }
          }
          else
          {
            if ( (unsigned int)v81 >= 0x600 )
            {
              LODWORD(useZoomedDistances) = 1536;
              LODWORD(cellSize) = v81;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", cellSize, useZoomedDistances) )
                __debugbreak();
            }
            if ( (v84 & s_transientsWorldMP.requested.array[v81 >> 5]) != 0 )
              CL_TransientsWorldMP_UnloadIndex(v81);
          }
LABEL_142:
          ++v80;
LABEL_143:
          if ( v80 > v79 )
          {
            lastTrPriority = s_transientsWorldMP.lastTrPriority;
            v70 = 0;
            break;
          }
        }
      }
    }
    Sys_ProfEndNamedEvent();
  }
  v85 = 0;
  v86 = 0;
  v87 = 0;
  while ( 2 )
  {
    if ( *lastTrPriority <= 0xB56 )
      goto LABEL_189;
    v88 = 0x80000000 >> (v87 & 0x1F);
    v89 = (unsigned __int64)v87 >> 5;
    if ( (v88 & s_transientsWorldMP.requested.array[v89]) != 0 )
    {
      if ( *lastTrPriority > 0x1389 )
      {
        ++v85;
        if ( (v88 & s_transientsWorldMP.loaded.array[v89]) != 0 )
          ++v86;
      }
      if ( v87 && s_transientsWorldMP.worldGridInfo )
      {
        if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3806, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount") )
          __debugbreak();
        v90 = v87 < (unsigned int)(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount);
      }
      else
      {
        v90 = 0;
      }
      v94 = v70 + 1;
      if ( !v90 )
        v94 = v70;
      v70 = v94;
      v95 = value + 1;
      if ( !v90 )
        v95 = value;
      v96 = v95;
      value = v95;
      goto LABEL_190;
    }
    if ( *((float *)lastTrPriority - 3465) >= 3.4028235e38 || !v87 || !s_transientsWorldMP.worldGridInfo )
    {
LABEL_189:
      v96 = value;
      goto LABEL_190;
    }
    if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3806, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount") )
      __debugbreak();
    v96 = value;
    if ( v87 < (unsigned int)(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount) )
      v96 = ++value;
LABEL_190:
    ++v87;
    ++lastTrPriority;
    if ( v87 < 0x600 )
      continue;
    break;
  }
  v97 = DCONST_DVARINT_cl_transientWorldBudgetLod0Memory;
  if ( !DCONST_DVARINT_cl_transientWorldBudgetLod0Memory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBudgetLod0Memory") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v97);
  if ( v70 < v97->current.integer )
  {
    v98 = DCONST_DVARINT_cl_transientWorldBudgetLod0Memory;
    if ( !DCONST_DVARINT_cl_transientWorldBudgetLod0Memory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBudgetLod0Memory") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v98);
    if ( v96 >= v98->current.integer )
    {
      if ( !s_transientsWorldMP.worldGridInfo || s_transientsWorldMP.isAlwaysloadedTRWorldMap )
        goto LABEL_205;
      v99 = DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB;
      if ( !DCONST_DVARINT_cl_transientWorldOverrideTileBudgetMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldOverrideTileBudgetMB") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v99);
      v100 = v99->current.integer << 20;
      tileBudget = v100;
      if ( !v100 )
LABEL_205:
        tileBudget = s_transientsWorldMP.tileBudget;
      v102 = tileBudget >> 20;
      v103 = DCONST_DVARINT_cl_transientWorldBudgetLod0Memory;
      if ( !DCONST_DVARINT_cl_transientWorldBudgetLod0Memory && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldBudgetLod0Memory") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v103);
      v104 = j_va("LOD0 tiles we'd want are too large, we can only load %d. %d target. %d total wanted. %zumb tilemem.", (unsigned int)v70, v103->current.unsignedInt, (unsigned int)v96, v102);
      StatMon_Warning(STATMON_CLASS_BUDGET, STATMON_TYPE_TRWORLD_MEMORY, 166, v104, v96);
    }
  }
  if ( v86 < v85 )
  {
    v105 = j_va("High priority tiles around the player are struggling to load in time, %u loaded, %u target, %u loading.", v86, v85, v85 - v86);
    StatMon_Warning(STATMON_CLASS_WARNING, STATMON_TYPE_TRWORLD_LOADED, 166, v105, v86);
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_UpdateLocalClientVisibility
==============
*/
void CL_TransientsWorldMP_UpdateLocalClientVisibility(const LocalClientNum_t localClient)
{
  signed __int64 v1; 
  void *v3; 
  __int64 v4; 
  bitarray_base<bitarray<1536> > *v5; 
  bitarray_base<bitarray<1536> > *v6; 
  bitarray<1536> *v7; 
  TransientZoneIntArray *v8; 
  bitarray<1536> *v9; 
  __int64 v10; 
  __int64 v11; 
  bitarray<1536> *p_fallingHinted; 
  __int64 v13; 
  char v14; 
  unsigned int v15; 
  __int64 v16; 
  char *v17; 
  const dvar_t *v18; 
  int integer; 
  bitarray_base<bitarray<1536> > *v20; 
  __int64 v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v25; 
  __int64 v26; 
  unsigned int v27; 
  unsigned __int64 v28; 
  unsigned int i; 
  WorldStreamPosition *v30; 
  const dvar_t *v31; 
  bitarray<1536> *p_visibleHintBitArray; 
  __int64 v33; 
  bitarray<1536> *v34; 
  __int64 v35; 
  unsigned int *v36; 
  char *v37; 
  __int64 v38; 
  const dvar_t *v47; 
  bitarray_base<bitarray<1536> > *v48; 
  __int64 v49; 
  const dvar_t *v50; 
  const dvar_t *v51; 
  const dvar_t *v52; 
  const dvar_t *v53; 
  const dvar_t *v54; 
  const dvar_t *v55; 
  const dvar_t *v56; 
  const dvar_t *v57; 
  const dvar_t *v58; 
  const dvar_t *v59; 
  const dvar_t *v60; 
  const dvar_t *v61; 
  const dvar_t *v62; 
  const dvar_t *v63; 
  const dvar_t *v64; 
  const dvar_t *v65; 
  int *v66; 
  int *v67; 
  int *v68; 
  int *v69; 
  const dvar_t *v70; 
  const dvar_t *v71; 
  unsigned int v72; 
  unsigned int v73; 
  __int64 v74; 
  unsigned __int16 *v76; 
  unsigned int v77; 
  __int64 v78; 
  unsigned int v79; 
  int v80; 
  unsigned int v81; 
  int v82; 
  float v83; 
  float v84; 
  float v85; 
  float v86; 
  float v87; 
  float v88; 
  float v89; 
  float v90; 
  __int128 v91; 
  float v95; 
  bool v96; 
  bool v97; 
  double v98; 
  float v99; 
  bool v100; 
  bool v101; 
  int v102; 
  unsigned int v103; 
  unsigned int v104; 
  unsigned int v105; 
  unsigned int v106; 
  unsigned __int64 v107; 
  unsigned __int64 v108; 
  unsigned int v109; 
  unsigned int v110; 
  unsigned int v111; 
  char v112; 
  unsigned int *v113; 
  bitarray<1536> *v114; 
  __int64 v115; 
  __int64 v116; 
  __int64 v117; 
  unsigned int *v118; 
  signed __int64 v119; 
  __int64 v120; 
  bitarray<1536> *v129; 
  bitarray<1536> *v130; 
  unsigned int *v131; 
  signed __int64 v132; 
  __int64 v141; 
  __int64 v142; 
  __int64 v143; 
  __int64 v144; 
  bool enabled; 
  bool v146; 
  unsigned int v147; 
  char v148; 
  int v149; 
  unsigned int v151; 
  bitarray<1536> *visibleBitArray; 
  int v153; 
  unsigned int v154; 
  TransientZoneIntArray *v155; 
  bitarray_base<bitarray<1536> > *v156; 
  int v157; 
  unsigned int v158; 
  __int64 v159; 
  __int64 v160; 
  bitarray<1536> *v161; 
  float *v162; 
  int *v163; 
  unsigned __int16 *v164; 
  int v165; 
  unsigned int v166; 
  int *v167; 
  int v168[2]; 
  int v169[2]; 
  int v170[2]; 
  int v171[2]; 
  int v172[2]; 
  int v173[2]; 
  int v174[2]; 
  int v175[2]; 
  int *v176; 
  unsigned __int64 v177; 
  __int64 v178; 
  bitarray<1536> v179; 
  bitarray<1536> visibleHintBitArray; 
  float distanceSqToStreamPos; 
  char v182; 
  __int128 v183; 

  v3 = alloca(v1);
  v178 = -2i64;
  v183 = _XMM14;
  v4 = localClient;
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateLocalClientVisibility");
  v5 = &s_transientsWorldMP.visibleTarget[v4];
  visibleBitArray = (bitarray<1536> *)v5;
  v6 = &s_transientsWorldMP.visibleCurrent[v4];
  v156 = v6;
  v7 = &s_transientsWorldMP.visibleHint[v4];
  v161 = v7;
  v8 = &s_transientsWorldMP.switchDelayStarted[v4];
  v155 = v8;
  bitarray_base<bitarray<1536>>::copyBitArray(v5, &s_transientsWorldMP.transientsHighestLOD);
  *(_DWORD *)v5 |= 0x80000000;
  v9 = v7;
  v10 = 3i64;
  do
  {
    *(_QWORD *)v9->array = 0i64;
    *(_QWORD *)&v9->array[2] = 0i64;
    *(_QWORD *)&v9->array[4] = 0i64;
    v9 = (bitarray<1536> *)((char *)v9 + 64);
    *(_QWORD *)&v9[-1].array[38] = 0i64;
    *(_QWORD *)&v9[-1].array[40] = 0i64;
    *(_QWORD *)&v9[-1].array[42] = 0i64;
    *(_QWORD *)&v9[-1].array[44] = 0i64;
    *(_QWORD *)&v9[-1].array[46] = 0i64;
    --v10;
  }
  while ( v10 );
  v11 = v4;
  *(_QWORD *)s_transientsWorldMP.zoomTransients[v11].array = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[2] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[4] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[6] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[8] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[10] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[12] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[14] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[16] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[18] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[20] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[22] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[24] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[26] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[28] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[30] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[32] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[34] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[36] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[38] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[40] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[42] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[44] = 0i64;
  *(_QWORD *)&s_transientsWorldMP.zoomTransients[v11].array[46] = 0i64;
  p_fallingHinted = &s_transientsWorldMP.fallingHinted;
  v13 = 3i64;
  do
  {
    *(_QWORD *)p_fallingHinted->array = 0i64;
    *(_QWORD *)&p_fallingHinted->array[2] = 0i64;
    *(_QWORD *)&p_fallingHinted->array[4] = 0i64;
    p_fallingHinted = (bitarray<1536> *)((char *)p_fallingHinted + 64);
    *(_QWORD *)&p_fallingHinted[-1].array[38] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[40] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[42] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[44] = 0i64;
    *(_QWORD *)&p_fallingHinted[-1].array[46] = 0i64;
    --v13;
  }
  while ( v13 );
  v14 = 0;
  v15 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
  v158 = v15;
  if ( v15 > 1 )
  {
    v16 = v15 - 1;
    v17 = &v182;
    while ( v16 )
    {
      *(_DWORD *)v17 = 2139095039;
      v17 += 4;
      --v16;
    }
  }
  v18 = DCONST_DVARINT_cl_transientWorldForceVisibleLOD;
  if ( !DCONST_DVARINT_cl_transientWorldForceVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldForceVisibleLOD") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v18);
  integer = v18->current.integer;
  if ( integer < 0 )
  {
    for ( i = 0; i < s_transientsWorldMP.numStreamPositions; ++i )
    {
      v30 = &s_transientsWorldMP.streamPositions[i];
      if ( v30->localClientIndex == localClient )
      {
        if ( v30->streamRender )
        {
          v14 |= v30->zoomVisibility;
          CL_TransientsWorldMP_UpdateLocalClientVisibilityPos(localClient, visibleBitArray, v7, &s_transientsWorldMP.streamPositions[i], &distanceSqToStreamPos);
        }
        else
        {
          v31 = DVARBOOL_cl_transientWorldHintPredictedStreamPositions;
          if ( !DVARBOOL_cl_transientWorldHintPredictedStreamPositions && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldHintPredictedStreamPositions") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v31);
          if ( v31->current.enabled )
          {
            v179.array[1] = s_transientsWorldMP.transientsHighestLOD.array[1];
            v179.array[2] = s_transientsWorldMP.transientsHighestLOD.array[2];
            v179.array[3] = s_transientsWorldMP.transientsHighestLOD.array[3];
            v179.array[4] = s_transientsWorldMP.transientsHighestLOD.array[4];
            v179.array[5] = s_transientsWorldMP.transientsHighestLOD.array[5];
            v179.array[6] = s_transientsWorldMP.transientsHighestLOD.array[6];
            v179.array[7] = s_transientsWorldMP.transientsHighestLOD.array[7];
            v179.array[8] = s_transientsWorldMP.transientsHighestLOD.array[8];
            v179.array[9] = s_transientsWorldMP.transientsHighestLOD.array[9];
            v179.array[10] = s_transientsWorldMP.transientsHighestLOD.array[10];
            v179.array[11] = s_transientsWorldMP.transientsHighestLOD.array[11];
            v179.array[12] = s_transientsWorldMP.transientsHighestLOD.array[12];
            v179.array[13] = s_transientsWorldMP.transientsHighestLOD.array[13];
            v179.array[14] = s_transientsWorldMP.transientsHighestLOD.array[14];
            v179.array[15] = s_transientsWorldMP.transientsHighestLOD.array[15];
            v179.array[16] = s_transientsWorldMP.transientsHighestLOD.array[16];
            v179.array[17] = s_transientsWorldMP.transientsHighestLOD.array[17];
            v179.array[18] = s_transientsWorldMP.transientsHighestLOD.array[18];
            v179.array[19] = s_transientsWorldMP.transientsHighestLOD.array[19];
            v179.array[20] = s_transientsWorldMP.transientsHighestLOD.array[20];
            v179.array[21] = s_transientsWorldMP.transientsHighestLOD.array[21];
            v179.array[22] = s_transientsWorldMP.transientsHighestLOD.array[22];
            v179.array[23] = s_transientsWorldMP.transientsHighestLOD.array[23];
            v179.array[24] = s_transientsWorldMP.transientsHighestLOD.array[24];
            v179.array[25] = s_transientsWorldMP.transientsHighestLOD.array[25];
            v179.array[26] = s_transientsWorldMP.transientsHighestLOD.array[26];
            v179.array[27] = s_transientsWorldMP.transientsHighestLOD.array[27];
            v179.array[28] = s_transientsWorldMP.transientsHighestLOD.array[28];
            v179.array[29] = s_transientsWorldMP.transientsHighestLOD.array[29];
            v179.array[30] = s_transientsWorldMP.transientsHighestLOD.array[30];
            v179.array[31] = s_transientsWorldMP.transientsHighestLOD.array[31];
            v179.array[32] = s_transientsWorldMP.transientsHighestLOD.array[32];
            v179.array[33] = s_transientsWorldMP.transientsHighestLOD.array[33];
            v179.array[34] = s_transientsWorldMP.transientsHighestLOD.array[34];
            v179.array[35] = s_transientsWorldMP.transientsHighestLOD.array[35];
            v179.array[36] = s_transientsWorldMP.transientsHighestLOD.array[36];
            v179.array[37] = s_transientsWorldMP.transientsHighestLOD.array[37];
            v179.array[38] = s_transientsWorldMP.transientsHighestLOD.array[38];
            v179.array[39] = s_transientsWorldMP.transientsHighestLOD.array[39];
            v179.array[40] = s_transientsWorldMP.transientsHighestLOD.array[40];
            v179.array[41] = s_transientsWorldMP.transientsHighestLOD.array[41];
            v179.array[42] = s_transientsWorldMP.transientsHighestLOD.array[42];
            v179.array[43] = s_transientsWorldMP.transientsHighestLOD.array[43];
            v179.array[44] = s_transientsWorldMP.transientsHighestLOD.array[44];
            v179.array[45] = s_transientsWorldMP.transientsHighestLOD.array[45];
            v179.array[46] = s_transientsWorldMP.transientsHighestLOD.array[46];
            v179.array[47] = s_transientsWorldMP.transientsHighestLOD.array[47];
            v179.array[0] = s_transientsWorldMP.transientsHighestLOD.array[0] | 0x80000000;
            p_visibleHintBitArray = &visibleHintBitArray;
            v33 = 3i64;
            do
            {
              *(_QWORD *)p_visibleHintBitArray->array = 0i64;
              *(_QWORD *)&p_visibleHintBitArray->array[2] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray->array[4] = 0i64;
              p_visibleHintBitArray = (bitarray<1536> *)((char *)p_visibleHintBitArray + 64);
              *(_QWORD *)&p_visibleHintBitArray[-1].array[38] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[40] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[42] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[44] = 0i64;
              *(_QWORD *)&p_visibleHintBitArray[-1].array[46] = 0i64;
              --v33;
            }
            while ( v33 );
            if ( v30->zoomVisibility && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1459, ASSERT_TYPE_ASSERT, "( !worldStreamPos.zoomVisibility )", "Zoom visibility is not supported for predicted transient world hinting") )
              __debugbreak();
            CL_TransientsWorldMP_UpdateLocalClientVisibilityPos(localClient, &v179, &visibleHintBitArray, v30, NULL);
            v7 = v161;
            if ( v161 > (bitarray<1536> *)&v179.array[47] || &v161->array[47] < (unsigned int *)&v179 )
            {
              v36 = &v161->array[4];
              v37 = (char *)((char *)&v179 - (char *)v161);
              v38 = 3i64;
              do
              {
                _XMM1 = *(_OWORD *)((char *)v36 + (_QWORD)v37 - 16);
                __asm { vpor    xmm1, xmm1, xmmword ptr [rax-10h] }
                *((_OWORD *)v36 - 1) = _XMM1;
                _XMM2 = *(_OWORD *)((char *)v36 + (_QWORD)v37);
                __asm { vpor    xmm1, xmm2, xmmword ptr [rax] }
                *(_OWORD *)v36 = _XMM1;
                _XMM1 = *(_OWORD *)((char *)v36 + (char *)&v179.array[4] - (char *)v161);
                __asm { vpor    xmm1, xmm1, xmmword ptr [rax+10h] }
                *((_OWORD *)v36 + 1) = _XMM1;
                _XMM1 = *(_OWORD *)((char *)v36 + (char *)&v179.array[8] - (char *)v161);
                __asm { vpor    xmm1, xmm1, xmmword ptr [rax+20h] }
                *((_OWORD *)v36 + 2) = _XMM1;
                v36 += 16;
                --v38;
              }
              while ( v38 );
            }
            else
            {
              v34 = v161;
              v35 = 48i64;
              do
              {
                v34->array[0] |= *(unsigned int *)((char *)v34->array + (char *)&v179 - (char *)v161);
                v34 = (bitarray<1536> *)((char *)v34 + 4);
                --v35;
              }
              while ( v35 );
            }
          }
          else
          {
            v7 = v161;
          }
        }
      }
    }
    v5 = visibleBitArray;
  }
  else
  {
    v20 = v5;
    v21 = 3i64;
    do
    {
      *(_QWORD *)v20 = 0i64;
      *(_QWORD *)&v20[8] = 0i64;
      *(_QWORD *)&v20[16] = 0i64;
      v20 += 64;
      *(_QWORD *)&v20[-40] = 0i64;
      *(_QWORD *)&v20[-32] = 0i64;
      *(_QWORD *)&v20[-24] = 0i64;
      *(_QWORD *)&v20[-16] = 0i64;
      *(_QWORD *)&v20[-8] = 0i64;
      --v21;
    }
    while ( v21 );
    *(_DWORD *)v5 = 0x80000000;
    if ( (unsigned int)integer <= 2 )
    {
      v22 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount / s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
      v23 = 1;
      if ( v22 > 1 )
      {
        do
        {
          HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v23);
          v25 = v23;
          if ( integer > 0 )
          {
            v26 = (unsigned int)(integer - 1);
            if ( (unsigned int)v26 >= s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
            {
              LODWORD(v142) = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount;
              LODWORD(v141) = integer - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1377, ASSERT_TYPE_ASSERT, "(unsigned)( highLodLookupIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )", "highLodLookupIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount\n\t%i not in [0, %i)", v141, v142) )
                __debugbreak();
            }
            v25 = HighLODLookups[v26];
          }
          if ( v25 )
          {
            if ( v25 >= 0x600 )
            {
              LODWORD(v142) = 1536;
              LODWORD(v141) = v25;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v141, v142) )
                __debugbreak();
            }
            v27 = 0x80000000 >> (v25 & 0x1F);
            v28 = (unsigned __int64)v25 >> 5;
            if ( (v27 & s_transientsWorldMP.loaded.array[v28]) != 0 )
            {
              if ( v25 >= 0x600 )
              {
                LODWORD(v144) = 1536;
                LODWORD(v143) = v25;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v143, v144) )
                  __debugbreak();
              }
              visibleBitArray->array[v28] |= v27;
            }
          }
          ++v23;
        }
        while ( v23 < v22 );
        v14 = 0;
        v8 = v155;
        v7 = v161;
      }
      v5 = visibleBitArray;
      v6 = v156;
    }
    bitarray_base<bitarray<1536>>::copyBitArray(v7, v5);
  }
  if ( *(_DWORD *)v5 >= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1470, ASSERT_TYPE_ASSERT, "(visibleTargetBitArray.testBit( TRANSIENT_ZONE_ALWAYSLOADED ))", (const char *)&queryFormat, "visibleTargetBitArray.testBit( TRANSIENT_ZONE_ALWAYSLOADED )") )
    __debugbreak();
  v47 = DCONST_DVARINT_cl_transientWorldLimitVisibleLOD;
  if ( !DCONST_DVARINT_cl_transientWorldLimitVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLimitVisibleLOD") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v47);
  if ( v47->current.integer >= 3u )
  {
    v48 = v5;
    v49 = 3i64;
    do
    {
      *(_QWORD *)v48 = 0i64;
      *(_QWORD *)&v48[8] = 0i64;
      *(_QWORD *)&v48[16] = 0i64;
      v48 += 64;
      *(_QWORD *)&v48[-40] = 0i64;
      *(_QWORD *)&v48[-32] = 0i64;
      *(_QWORD *)&v48[-24] = 0i64;
      *(_QWORD *)&v48[-16] = 0i64;
      *(_QWORD *)&v48[-8] = 0i64;
      --v49;
    }
    while ( v49 );
    *(_DWORD *)v5 = 0x80000000;
  }
  v50 = DVARFLT_cl_transientWorldSwitchDelayLOD0Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v50);
  *(float *)v169 = 1000.0 * v50->current.value;
  v51 = DVARFLT_cl_transientWorldSwitchDelayLOD1Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v51);
  *(float *)&v169[1] = 1000.0 * v51->current.value;
  v52 = DVARFLT_cl_transientWorldSwitchDelayLOD0MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v52);
  v173[0] = v52->current.integer;
  v53 = DVARFLT_cl_transientWorldSwitchDelayLOD1MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v53);
  v173[1] = v53->current.integer;
  v54 = DVARFLT_cl_transientWorldSwitchDelayLOD0Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v54);
  *(float *)v171 = 1000.0 * v54->current.value;
  v55 = DVARFLT_cl_transientWorldSwitchDelayLOD1Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v55);
  *(float *)&v171[1] = 1000.0 * v55->current.value;
  v56 = DVARFLT_cl_transientWorldSwitchDelayLOD0MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD0MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD0MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v56);
  v175[0] = v56->current.integer;
  v57 = DVARFLT_cl_transientWorldSwitchDelayLOD1MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLOD1MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLOD1MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v57);
  v175[1] = v57->current.integer;
  v58 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v58);
  *(float *)v168 = 1000.0 * v58->current.value;
  v59 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Min;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Min && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1Min") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v59);
  *(float *)&v168[1] = 1000.0 * v59->current.value;
  v60 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v60);
  v172[0] = v60->current.integer;
  v61 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MinDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MinDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1MinDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v61);
  v172[1] = v61->current.integer;
  v62 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v62);
  *(float *)v170 = 1000.0 * v62->current.value;
  v63 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Max;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1Max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1Max") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v63);
  *(float *)&v170[1] = 1000.0 * v63->current.value;
  v64 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD0MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD0MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v64);
  v174[0] = v64->current.integer;
  v65 = DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MaxDistance;
  if ( !DVARFLT_cl_transientWorldSwitchDelayZoomLOD1MaxDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayZoomLOD1MaxDistance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v65);
  v174[1] = v65->current.integer;
  v66 = v168;
  if ( !v14 )
    v66 = v169;
  v163 = v66;
  v67 = v170;
  if ( !v14 )
    v67 = v171;
  v162 = (float *)v67;
  v68 = v172;
  if ( !v14 )
    v68 = v173;
  v167 = v68;
  v69 = v174;
  if ( !v14 )
    v69 = v175;
  v176 = v69;
  v70 = DVARFLT_cl_transientWorldSwitchDelayLowerLod;
  if ( !DVARFLT_cl_transientWorldSwitchDelayLowerLod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSwitchDelayLowerLod") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v70);
  v165 = float_to_integral_cast<int,float>(1000.0 * v70->current.value);
  if ( integer >= 0 || *(float *)v66 == 0.0 && *((float *)v66 + 1) == 0.0 && *v162 == 0.0 && v162[1] == 0.0 )
  {
    v129 = visibleBitArray;
    bitarray_base<bitarray<1536>>::copyBitArray(v6, visibleBitArray);
    bitarray_base<bitarray<1536>>::orAllBits(v7, visibleBitArray);
    memset_0(v8, 0, sizeof(TransientZoneIntArray));
  }
  else
  {
    v157 = Sys_Milliseconds();
    v71 = DCONST_DVARBOOL_cl_transientWorldDebugDelay;
    if ( !DCONST_DVARBOOL_cl_transientWorldDebugDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldDebugDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v71);
    enabled = v71->current.enabled;
    if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1554, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodLookupCount > 0") )
      __debugbreak();
    if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1555, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0") )
      __debugbreak();
    v146 = !Stream_CanStreamMore();
    v72 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount + 1;
    v147 = v72;
    v73 = 1;
    v149 = 1;
    if ( v158 > 1 )
    {
      v74 = 1i64;
      v160 = 1i64;
      __asm { vxorpd  xmm14, xmm14, xmm14 }
      while ( 1 )
      {
        v148 = 0;
        v76 = CL_TransientsWorldMP_GetHighLODLookups(v73);
        v164 = v76;
        v77 = 0;
        v154 = 0;
        if ( !v72 )
          goto LABEL_274;
        v78 = 0i64;
        v159 = 0i64;
        do
        {
          if ( v77 )
          {
            v79 = v76[v77 - 1];
            v151 = v79;
            v78 = v159;
          }
          else
          {
            v79 = v73;
            v151 = v73;
          }
          if ( v79 )
          {
            if ( v79 >= 0x600 )
            {
              LODWORD(v142) = 1536;
              LODWORD(v141) = v79;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1570, ASSERT_TYPE_ASSERT, "(unsigned)( curTransient ) < (unsigned)( ( sizeof( *array_counter( switchDelayStartedArray.data ) ) + 0 ) )", "curTransient doesn't index ARRAY_COUNT( switchDelayStartedArray.data )\n\t%i not in [0, %i)", v141, v142) )
                __debugbreak();
            }
            if ( v79 >= 0x600 )
            {
              LODWORD(v142) = 1536;
              LODWORD(v141) = v79;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v141, v142) )
                __debugbreak();
            }
            v166 = 0x80000000 >> (v79 & 0x1F);
            v177 = (unsigned __int64)v79 >> 5;
            v80 = *(_DWORD *)&v6[4 * v177] & v166;
            v153 = v80;
            if ( v79 >= 0x600 )
            {
              LODWORD(v142) = 1536;
              LODWORD(v141) = v79;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v141, v142) )
                __debugbreak();
              v80 = v153;
            }
            v81 = (0x80000000 >> (v79 & 0x1F)) & visibleBitArray->array[(unsigned __int64)v79 >> 5];
            if ( !enabled && (!v81 || v80) )
            {
              v155->data[v79] = 0;
              goto LABEL_268;
            }
            if ( v77 != 2 )
            {
              if ( v77 && v148 )
                goto LABEL_169;
              if ( v77 >= 2 )
              {
                LODWORD(v142) = 2;
                LODWORD(v141) = v77;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1601, ASSERT_TYPE_ASSERT, "(unsigned)( curLod ) < (unsigned)( ( sizeof( *array_counter( switchPeriodMinDistance ) ) + 0 ) )", "curLod doesn't index switchPeriodMinDistance\n\t%i not in [0, %i)", v141, v142) )
                  __debugbreak();
              }
              v83 = *(float *)&v167[v159] * *(float *)&v167[v159];
              if ( v73 >= 0x600 )
              {
                LODWORD(v142) = 1536;
                LODWORD(v141) = v73;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1608, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransient ) < (unsigned)( ( sizeof( *array_counter( distanceSqToStreamPos ) ) + 0 ) )", "baseTransient doesn't index distanceSqToStreamPos\n\t%i not in [0, %i)", v141, v142) )
                  __debugbreak();
              }
              if ( v83 >= *(&distanceSqToStreamPos + v160) || (v84 = *(float *)&v163[v159], v85 = v162[v159], v84 == v85) )
              {
                v99 = *(float *)&v163[v159];
                v82 = (int)v99;
                v100 = v99 >= -16777216.0 && v99 <= 16777216.0;
                v101 = v99 >= -2147483600.0 && v99 <= 2147483600.0;
                if ( v100 && v101 )
                  goto LABEL_211;
                v98 = v99;
              }
              else
              {
                v86 = *(float *)&v163[v159];
                if ( v84 < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1611, ASSERT_TYPE_ASSERT, "( switchPeriodMsMin[curLod] ) >= ( 0.0f )", "%s >= %s\n\t%g, %g", "switchPeriodMsMin[curLod]", "0.0f", v84, *(double *)&_XMM14) )
                {
                  __debugbreak();
                  v86 = *(float *)&v163[v159];
                  v85 = v162[v159];
                }
                if ( v86 >= v85 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1612, ASSERT_TYPE_ASSERT, "( switchPeriodMsMin[curLod] ) < ( switchPeriodMsMax[curLod] )", "%s < %s\n\t%g, %g", "switchPeriodMsMin[curLod]", "switchPeriodMsMax[curLod]", v86, v85) )
                  __debugbreak();
                v87 = *(float *)&v167[v159];
                v88 = *(float *)&v176[v159];
                v89 = v87;
                v90 = v88;
                if ( v87 >= v88 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1613, ASSERT_TYPE_ASSERT, "( switchPeriodMinDistance[curLod] ) < ( switchPeriodMaxDistance[curLod] )", "%s < %s\n\t%g, %g", "switchPeriodMinDistance[curLod]", "switchPeriodMaxDistance[curLod]", v87, v88) )
                {
                  __debugbreak();
                  v89 = *(float *)&v167[v159];
                  v90 = *(float *)&v176[v159];
                }
                v91 = *((unsigned int *)&distanceSqToStreamPos + v160);
                *(float *)&v91 = (float)(fsqrt(*(&distanceSqToStreamPos + v160)) - v89) / (float)(v90 - v89);
                _XMM3 = v91;
                __asm
                {
                  vmaxss  xmm0, xmm3, xmm11
                  vminss  xmm4, xmm0, xmm13
                }
                v95 = (float)((float)(1.0 - *(float *)&_XMM4) * *(float *)&v163[v159]) + (float)(*(float *)&_XMM4 * v162[v159]);
                v82 = (int)v95;
                v96 = v95 >= -16777216.0 && v95 <= 16777216.0;
                v97 = v95 >= -2147483600.0 && v95 <= 2147483600.0;
                if ( v96 && v97 )
                  goto LABEL_211;
                v98 = v95;
              }
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 437, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (IntegralType) 0x%jx == (FloatType) %f", "int __cdecl float_to_integral_cast<int,float>(float)", v82, v98) )
                __debugbreak();
              goto LABEL_211;
            }
            if ( !v148 )
            {
              v82 = 0;
              goto LABEL_214;
            }
LABEL_169:
            v82 = v165;
LABEL_211:
            if ( v82 < 0 )
            {
              LODWORD(v143) = v82;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1625, ASSERT_TYPE_ASSERT, "( desiredSwitchPeriod ) >= ( 0 )", "%s >= %s\n\t%i, %i", "desiredSwitchPeriod", "0", v143, 0i64) )
                __debugbreak();
            }
LABEL_214:
            s_transientsWorldMP.switchDelayTarget[localClient].data[v79] = v82;
            if ( enabled && !v81 )
              goto LABEL_271;
            if ( !v82 )
            {
              v155->data[v79] = 0;
LABEL_247:
              if ( v79 >= 0x600 )
              {
                LODWORD(v142) = 1536;
                LODWORD(v141) = v79;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v141, v142) )
                  __debugbreak();
              }
              v108 = v177;
              if ( (v166 & s_transientsWorldMP.loaded.array[v177]) == 0 )
              {
                LODWORD(v141) = v79;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1704, ASSERT_TYPE_ASSERT, "( ( s_transientsWorldMP.loaded.testBit( curTransient ) ) )", "( curTransient ) = %u", v141) )
                  __debugbreak();
              }
              if ( v79 >= 0x600 )
              {
                LODWORD(v144) = 1536;
                LODWORD(v143) = v79;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v143, v144) )
                  __debugbreak();
              }
              v6 = v156;
              *(_DWORD *)&v156[4 * v108] |= v166;
              v109 = 0;
              v77 = v154;
              v110 = v147;
              do
              {
                if ( v109 != v154 )
                {
                  if ( v109 )
                    v111 = v164[v109 - 1];
                  else
                    v111 = v149;
                  if ( v111 )
                  {
                    if ( v111 >= 0x600 )
                    {
                      LODWORD(v144) = 1536;
                      LODWORD(v143) = v111;
                      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v143, v144) )
                        __debugbreak();
                    }
                    *(_DWORD *)&v156[4 * ((unsigned __int64)v111 >> 5)] &= ~(0x80000000 >> (v111 & 0x1F));
                  }
                  v110 = v147;
                }
                ++v109;
              }
              while ( v109 < v110 );
LABEL_268:
              v112 = v148;
              if ( v153 )
                v112 = 1;
              v148 = v112;
              v73 = v149;
LABEL_271:
              v76 = v164;
              v78 = v159;
              goto LABEL_272;
            }
            v102 = v155->data[v79];
            if ( !v102 )
            {
              v155->data[v79] = v157;
              if ( !v157 )
                v155->data[v79] = -1;
              goto LABEL_221;
            }
            if ( v157 - v102 < v82 )
            {
LABEL_221:
              if ( !v146 && !Stream_TransientZoneStreamingQualitySufficient(v79) )
              {
                v103 = 0;
                v104 = 0;
                do
                {
                  if ( v104 )
                    v105 = v164[v104 - 1];
                  else
                    v105 = v149;
                  if ( v105 )
                  {
                    if ( v105 >= 0x600 )
                    {
                      LODWORD(v142) = 1536;
                      LODWORD(v141) = v105;
                      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v141, v142) )
                        __debugbreak();
                    }
                    v106 = 0x80000000 >> (v105 & 0x1F);
                    v107 = (unsigned __int64)v105 >> 5;
                    if ( (v106 & *(_DWORD *)&v156[4 * v107]) != 0 )
                    {
                      if ( v105 >= 0x600 )
                      {
                        LODWORD(v142) = 1536;
                        LODWORD(v141) = v105;
                        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v141, v142) )
                          __debugbreak();
                      }
                      if ( (v106 & s_transientsWorldMP.loaded.array[v107]) != 0 )
                        ++v103;
                    }
                  }
                  ++v104;
                }
                while ( v104 < v147 );
                v79 = v151;
                if ( v103 > 1 )
                {
                  LODWORD(v144) = 1;
                  LODWORD(v143) = v103;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1692, ASSERT_TYPE_ASSERT, "( visibleCount ) <= ( 1 )", "%s <= %s\n\t%u, %u", "visibleCount", "1", v143, v144) )
                    __debugbreak();
                }
                if ( !v103 )
                {
                  v155->data[v151] = 0;
                  goto LABEL_247;
                }
                v77 = v154;
                v6 = v156;
                if ( !v155->data[v151] )
                  goto LABEL_247;
                goto LABEL_268;
              }
            }
            v155->data[v79] = 0;
            goto LABEL_247;
          }
LABEL_272:
          v154 = ++v77;
          v159 = ++v78;
          v72 = v147;
        }
        while ( v77 < v147 );
        v74 = v160;
LABEL_274:
        v149 = ++v73;
        v160 = ++v74;
        if ( v73 >= v158 )
        {
          v7 = v161;
          break;
        }
      }
    }
    v113 = &v7->array[47];
    if ( v7 > &v6[188] || v113 < (unsigned int *)v6 )
    {
      v118 = &v7->array[4];
      v119 = (bitarray<1536> *)v6 - v7;
      v117 = 3i64;
      v120 = 3i64;
      do
      {
        _XMM1 = *(_OWORD *)((char *)v118 + v119 - 16);
        __asm { vpor    xmm1, xmm1, xmmword ptr [rax-10h] }
        *((_OWORD *)v118 - 1) = _XMM1;
        _XMM2 = *(_OWORD *)((char *)v118 + v119);
        __asm { vpor    xmm1, xmm2, xmmword ptr [rax] }
        *(_OWORD *)v118 = _XMM1;
        _XMM1 = *(_OWORD *)((char *)v118 + v119 + 16);
        __asm { vpor    xmm1, xmm1, xmmword ptr [rax+10h] }
        *((_OWORD *)v118 + 1) = _XMM1;
        _XMM1 = *(_OWORD *)((char *)v118 + v119 + 32);
        __asm { vpor    xmm1, xmm1, xmmword ptr [rax+20h] }
        *((_OWORD *)v118 + 2) = _XMM1;
        v118 += 16;
        --v120;
      }
      while ( v120 );
      v115 = 48i64;
    }
    else
    {
      v114 = v7;
      v115 = 48i64;
      v116 = 48i64;
      do
      {
        v114->array[0] |= *(unsigned int *)((char *)v114->array + (bitarray<1536> *)v6 - v7);
        v114 = (bitarray<1536> *)((char *)v114 + 4);
        --v116;
      }
      while ( v116 );
      v117 = 3i64;
    }
    v129 = visibleBitArray;
    if ( v7 > (bitarray<1536> *)&visibleBitArray->array[47] || v113 < (unsigned int *)visibleBitArray )
    {
      v131 = &v7->array[4];
      v132 = (char *)visibleBitArray - (char *)v7;
      do
      {
        _XMM1 = *(_OWORD *)((char *)v131 + v132 - 16);
        __asm { vpor    xmm1, xmm1, xmmword ptr [rax-10h] }
        *((_OWORD *)v131 - 1) = _XMM1;
        _XMM2 = *(_OWORD *)((char *)v131 + v132);
        __asm { vpor    xmm1, xmm2, xmmword ptr [rax] }
        *(_OWORD *)v131 = _XMM1;
        _XMM1 = *(_OWORD *)((char *)v131 + v132 + 16);
        __asm { vpor    xmm1, xmm1, xmmword ptr [rax+10h] }
        *((_OWORD *)v131 + 1) = _XMM1;
        _XMM1 = *(_OWORD *)((char *)v131 + v132 + 32);
        __asm { vpor    xmm1, xmm1, xmmword ptr [rax+20h] }
        *((_OWORD *)v131 + 2) = _XMM1;
        v131 += 16;
        --v117;
      }
      while ( v117 );
    }
    else
    {
      v130 = v7;
      do
      {
        v130->array[0] |= *(unsigned int *)((char *)v130->array + (char *)visibleBitArray - (char *)v7);
        v130 = (bitarray<1536> *)((char *)v130 + 4);
        --v115;
      }
      while ( v115 );
    }
  }
  *(_DWORD *)v6 |= 0x80000000;
  v129->array[0] |= 0x80000000;
  v7->array[0] |= 0x80000000;
  CL_TransientsWorld_SetVisibilityBitArray(localClient, (const bitarray<1536> *)v6, v7);
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_UpdateLocalClientVisibilityPos
==============
*/
void CL_TransientsWorldMP_UpdateLocalClientVisibilityPos(const LocalClientNum_t localClient, bitarray<1536> *visibleBitArray, bitarray<1536> *visibleHintBitArray, const WorldStreamPosition *streamPos, float *distanceSqToStreamPos)
{
  signed __int64 v5; 
  void *v6; 
  unsigned __int64 v7; 
  const WorldStreamPosition *v8; 
  __int64 v9; 
  float *v10; 
  SpatialPartition_Tree *transientWorldGridSpatial; 
  __int128 v12; 
  __int128 v14; 
  vec4_t *frustumPlanes; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  Bounds *transientWorldGridBounds; 
  int v21; 
  float *v22; 
  float v23; 
  float v24; 
  float v25; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v27; 
  float *v28; 
  unsigned int v29; 
  bitarray_base<bitarray<1536> > *v30; 
  unsigned int i; 
  __int64 v32; 
  __int64 v33; 
  float v34; 
  float v35; 
  unsigned int v36; 
  unsigned int v37; 
  unsigned int v38; 
  Bounds *v39; 
  __int64 v40; 
  bitarray<1536> *v41; 
  unsigned int v42; 
  unsigned __int64 v43; 
  bitarray<1536> *v44; 
  float v45; 
  float v46; 
  unsigned __int16 *v49; 
  char v50; 
  __int64 v51; 
  float *v52; 
  const dvar_t *v53; 
  unsigned int v54; 
  unsigned int v55; 
  unsigned __int64 v56; 
  float v57; 
  float v58; 
  __int64 v59; 
  float v60; 
  float v61; 
  float v62; 
  unsigned __int16 *v63; 
  unsigned int v64; 
  bitarray_base<bitarray<1536> > *v65; 
  unsigned int j; 
  __int64 v67; 
  bool v68; 
  __int64 v69; 
  __int64 v70; 
  __int64 v71; 
  __int64 v72; 
  __int64 v73; 
  char v74[9104]; 
  __int64 v75; 

  v6 = alloca(v5);
  v75 = -2i64;
  v7 = (unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64;
  *(_QWORD *)(v7 + 9096) = (unsigned __int64)&v69 ^ _security_cookie;
  v8 = streamPos;
  *(_QWORD *)(v7 + 16) = streamPos;
  *(_QWORD *)(v7 + 32) = visibleHintBitArray;
  *(_QWORD *)(v7 + 24) = visibleBitArray;
  v9 = localClient;
  v10 = distanceSqToStreamPos;
  *(_QWORD *)(v7 + 8) = distanceSqToStreamPos;
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdateLocalClientVisibilityPos");
  CL_TransientsWorldMP_GetVisibilityCenterPos(v8, (vec3_t *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 88));
  *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = CL_TransientsWorldMP_GetVisibilityRadiusWithoutPos(0) * s_transientsWorldMP.radiusMultiplier;
  *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x74) = CL_TransientsWorldMP_GetVisibilityRadius(1u, &v8->pos);
  CL_TransientsWorldMP_GetWorldStreamParamsInternal((WorldStreamParameters *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 104), &v8->pos);
  transientWorldGridSpatial = s_transientsWorldMP.worldGridInfo->transientWorldGridSpatial;
  if ( !transientWorldGridSpatial )
    goto LABEL_152;
  if ( v8->zoomVisibility )
  {
    *(float *)v7 = v8->zoomLODDist[0] * v8->zoomLODDist[0];
    v12 = LODWORD(v8->zoomLODDist[1]);
    v14 = v12;
    *(float *)&v14 = *(float *)&v12 * *(float *)&v12;
    _XMM0 = v14;
    *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = *(float *)&v12 * *(float *)&v12;
    __asm { vmaxss  xmm15, xmm0, xmm2 }
    *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1240) = 0i64;
    *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1248) = 0;
    *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) = 0i64;
    *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) = 0i64;
    frustumPlanes = v8->frustumPlanes;
    SpatialPartition_Tree_FrustumIterator::Init((SpatialPartition_Tree_FrustumIterator *)(v7 + 4480), transientWorldGridSpatial, v8->frustumPlanes, 5u);
    if ( SpatialPartition_Tree_FrustumIterator::Advance((SpatialPartition_Tree_FrustumIterator *)(v7 + 4480)) )
    {
      do
      {
        if ( !*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 16, ASSERT_TYPE_ASSERT, "(m_spatialTree)", (const char *)&queryFormat, "m_spatialTree") )
          __debugbreak();
        v17 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) + 20i64);
        v18 = *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1248);
        if ( v18 == v17 )
        {
          if ( !*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 19, ASSERT_TYPE_ASSERT, "(m_currentNode)", (const char *)&queryFormat, "m_currentNode") )
            __debugbreak();
          if ( (**(_BYTE **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 20, ASSERT_TYPE_ASSERT, "(m_currentNode->containsLeaves)", (const char *)&queryFormat, "m_currentNode->containsLeaves") )
            __debugbreak();
          if ( *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1240) >= **(unsigned __int8 **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) >> 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 21, ASSERT_TYPE_ASSERT, "(m_leafIndex < m_currentNode->childCount)", (const char *)&queryFormat, "m_leafIndex < m_currentNode->childCount") )
            __debugbreak();
          v19 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1258) + 4i64 * *(unsigned int *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1240) + 4);
        }
        else
        {
          if ( v18 >= v17 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 26, ASSERT_TYPE_ASSERT, "(m_alwaysIndex < m_spatialTree->alwaysListLength)", (const char *)&queryFormat, "m_alwaysIndex < m_spatialTree->alwaysListLength") )
              __debugbreak();
            v18 = *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1248);
          }
          v19 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1250) + 8i64) + 4i64 * v18);
        }
        if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1141, ASSERT_TYPE_ASSERT, "(baseTransientIndex > 0)", (const char *)&queryFormat, "baseTransientIndex > 0") )
          __debugbreak();
        if ( v19 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
        {
          LODWORD(v71) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
          LODWORD(v70) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1142, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "baseTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v70, v71) )
            __debugbreak();
        }
        transientWorldGridBounds = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
        v21 = 0;
        v22 = (float *)frustumPlanes;
        v23 = transientWorldGridBounds[v19].midPoint.v[0];
        v24 = transientWorldGridBounds[v19].halfSize.v[0];
        while ( (float)((float)((float)((float)((float)((float)((float)(v23 * *v22) + v22[3]) + (float)(v24 * COERCE_FLOAT(*(_DWORD *)v22 & _xmm))) + (float)(transientWorldGridBounds[v19].midPoint.v[1] * v22[1])) + (float)(COERCE_FLOAT((_DWORD)v22[1] & _xmm) * transientWorldGridBounds[v19].halfSize.v[1])) + (float)(transientWorldGridBounds[v19].midPoint.v[2] * v22[2])) + (float)(COERCE_FLOAT((_DWORD)v22[2] & _xmm) * transientWorldGridBounds[v19].halfSize.v[2])) > 0.0 )
        {
          ++v21;
          v22 += 4;
          if ( v21 >= 5 )
          {
            *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = v23 - v24;
            *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x44) = transientWorldGridBounds[v19].midPoint.v[1] - transientWorldGridBounds[v19].halfSize.v[1];
            *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x48) = transientWorldGridBounds[v19].midPoint.v[2] - transientWorldGridBounds[v19].halfSize.v[2];
            *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x4C) = transientWorldGridBounds[v19].midPoint.v[0] + transientWorldGridBounds[v19].halfSize.v[0];
            *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = transientWorldGridBounds[v19].halfSize.v[1] + transientWorldGridBounds[v19].midPoint.v[1];
            *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x54) = transientWorldGridBounds[v19].halfSize.v[2] + transientWorldGridBounds[v19].midPoint.v[2];
            PointToClosestAABBPoint((const vec3_t *)(v7 + 64), (const vec3_t *)(v7 + 76), &v8->pos, (vec3_t *)(v7 + 48));
            v25 = (float)((float)(*(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30)) + (float)(*(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x34) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x34))) + (float)(*(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38));
            if ( v25 <= *(float *)&_XMM15 )
            {
              HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v19);
              bitarray_base<bitarray<1536>>::setBit(&s_transientsWorldMP.zoomTransients[v9], v19);
              bitarray_base<bitarray<1536>>::setBit(&s_transientsWorldMP.zoomTransients[v9], *HighLODLookups);
              v27 = 0;
              v28 = (float *)((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64);
              while ( 1 )
              {
                v29 = v27 ? HighLODLookups[v27 - 1] : v19;
                if ( v29 )
                {
                  if ( bitarray_base<bitarray<1536>>::testBit(*(bitarray_base<bitarray<1536> > **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18), v29) )
                    goto LABEL_53;
                  if ( v29 >= 0x600 )
                  {
                    LODWORD(v71) = 1536;
                    LODWORD(v70) = v29;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v70, v71) )
                      __debugbreak();
                  }
                  if ( ((0x80000000 >> (v29 & 0x1F)) & s_transientsWorldMP.loaded.array[(unsigned __int64)v29 >> 5]) != 0 && (s_transientsWorldMP.ignoreTransientSkip || v29 >= s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount || !bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v29)) && v25 <= *v28 )
                    break;
                }
                ++v27;
                ++v28;
                if ( v27 >= 2 )
                  goto LABEL_53;
              }
              v30 = *(bitarray_base<bitarray<1536> > **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18);
              bitarray_base<bitarray<1536>>::setBit(v30, v29);
              for ( i = v27 + 1; i < 3; ++i )
              {
                v32 = i - 1;
                if ( HighLODLookups[v32] )
                  bitarray_base<bitarray<1536>>::resetBit(v30, HighLODLookups[v32]);
              }
LABEL_53:
              v8 = *(const WorldStreamPosition **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10);
            }
            break;
          }
        }
      }
      while ( SpatialPartition_Tree_FrustumIterator::Advance((SpatialPartition_Tree_FrustumIterator *)(v7 + 4480)) );
      v10 = *(float **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 8);
    }
  }
  *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x160) = 0i64;
  *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x168) = 0;
  *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) = 0i64;
  *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) = 0i64;
  SpatialPartition_Tree_SphereIterator::Init((SpatialPartition_Tree_SphereIterator *)(v7 + 160), s_transientsWorldMP.worldGridInfo->transientWorldGridSpatial, (const vec3_t *)(v7 + 88), *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x94));
  if ( !SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(v7 + 160)) )
    goto LABEL_152;
  v33 = v9;
  *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = v9;
  v34 = *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x98);
  v35 = *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80);
  do
  {
    if ( !*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 16, ASSERT_TYPE_ASSERT, "(m_spatialTree)", (const char *)&queryFormat, "m_spatialTree") )
      __debugbreak();
    v36 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) + 20i64);
    v37 = *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x168);
    if ( v37 == v36 )
    {
      if ( !*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 19, ASSERT_TYPE_ASSERT, "(m_currentNode)", (const char *)&queryFormat, "m_currentNode") )
        __debugbreak();
      if ( (**(_BYTE **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 20, ASSERT_TYPE_ASSERT, "(m_currentNode->containsLeaves)", (const char *)&queryFormat, "m_currentNode->containsLeaves") )
        __debugbreak();
      if ( *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x160) >= **(unsigned __int8 **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) >> 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 21, ASSERT_TYPE_ASSERT, "(m_leafIndex < m_currentNode->childCount)", (const char *)&queryFormat, "m_leafIndex < m_currentNode->childCount") )
        __debugbreak();
      v38 = *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x178) + 4i64 * *(unsigned int *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x160) + 4);
    }
    else
    {
      if ( v37 >= v36 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\spatialpartition\\spatialpartition_tree.h", 26, ASSERT_TYPE_ASSERT, "(m_alwaysIndex < m_spatialTree->alwaysListLength)", (const char *)&queryFormat, "m_alwaysIndex < m_spatialTree->alwaysListLength") )
          __debugbreak();
        v37 = *(_DWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x168);
      }
      v38 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x170) + 8i64) + 4i64 * v37);
    }
    if ( !v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1209, ASSERT_TYPE_ASSERT, "(baseTransientIndex > 0)", (const char *)&queryFormat, "baseTransientIndex > 0") )
      __debugbreak();
    if ( v38 >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
    {
      LODWORD(v71) = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
      LODWORD(v70) = v38;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1210, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "baseTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v70, v71) )
        __debugbreak();
    }
    v39 = s_transientsWorldMP.worldGridInfo->transientWorldGridBounds;
    *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = v39[v38].midPoint.v[0] - v39[v38].halfSize.v[0];
    *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x44) = v39[v38].midPoint.v[1] - v39[v38].halfSize.v[1];
    *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x48) = v39[v38].midPoint.v[2] - v39[v38].halfSize.v[2];
    *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x4C) = v39[v38].midPoint.v[0] + v39[v38].halfSize.v[0];
    *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = v39[v38].halfSize.v[1] + v39[v38].midPoint.v[1];
    *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x54) = v39[v38].halfSize.v[2] + v39[v38].midPoint.v[2];
    PointToClosestAABBPoint((const vec3_t *)(v7 + 64), (const vec3_t *)(v7 + 76), (const vec3_t *)(v7 + 88), (vec3_t *)(v7 + 48));
    if ( v8->fallingHint )
    {
      v40 = v33;
      v41 = &s_transientsWorldMP.visibleCurrent[v33];
      if ( v38 >= 0x600 )
      {
        LODWORD(v71) = 1536;
        LODWORD(v70) = v38;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v70, v71) )
          __debugbreak();
      }
      v42 = 0x80000000 >> (v38 & 0x1F);
      v43 = (unsigned __int64)v38 >> 5;
      if ( (v42 & v41->array[v43]) != 0 )
        goto LABEL_92;
      v44 = &s_transientsWorldMP.visibleTarget[v40];
      if ( v38 >= 0x600 )
      {
        LODWORD(v71) = 1536;
        LODWORD(v70) = v38;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v70, v71) )
          __debugbreak();
      }
      if ( (v42 & v44->array[v43]) != 0 )
      {
LABEL_92:
        *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = 0;
        if ( v38 >= 0x600 )
        {
          LODWORD(v73) = 1536;
          LODWORD(v72) = v38;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v72, v73) )
            __debugbreak();
        }
        s_transientsWorldMP.fallingHinted.array[v43] |= v42;
      }
      v10 = *(float **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 8);
    }
    v45 = (float)(*(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x34) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x34)) + (float)(*(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30));
    v46 = (float)(*(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38)) + v45;
    if ( v10 )
    {
      _XMM0 = LODWORD(v10[v38]);
      __asm { vminss  xmm1, xmm0, xmm2 }
      v10[v38] = *(float *)&_XMM1;
    }
    if ( v46 > v34 )
      goto LABEL_151;
    v49 = CL_TransientsWorldMP_GetHighLODLookups(v38);
    *(_QWORD *)v7 = v49;
    v50 = 0;
    v51 = 0i64;
    v52 = (float *)(v7 + 120);
    while ( 1 )
    {
      v53 = DCONST_DVARINT_cl_transientWorldLimitVisibleLOD;
      if ( !DCONST_DVARINT_cl_transientWorldLimitVisibleLOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldLimitVisibleLOD") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v53);
      if ( (int)v51 < v53->current.integer )
        goto LABEL_136;
      v54 = (_DWORD)v51 ? v49[(unsigned int)(v51 - 1)] : v38;
      if ( !v54 )
        goto LABEL_136;
      if ( v54 >= 0x600 )
      {
        LODWORD(v71) = 1536;
        LODWORD(v70) = v54;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v70, v71) )
          __debugbreak();
      }
      v55 = 0x80000000 >> (v54 & 0x1F);
      v56 = (unsigned __int64)v54 >> 5;
      if ( (v55 & *(_DWORD *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) + 4 * v56)) != 0 )
        goto LABEL_150;
      if ( v54 >= 0x600 )
      {
        LODWORD(v71) = 1536;
        LODWORD(v70) = v54;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v70, v71) )
          __debugbreak();
      }
      if ( (v55 & s_transientsWorldMP.loaded.array[v56]) == 0 || !s_transientsWorldMP.ignoreTransientSkip && v54 < s_transientsWorldMP.worldGridInfo->transientSkipLoading.bitCount && bitarray_base<bitarray_dynamic>::testBit(&s_transientsWorldMP.worldGridInfo->transientSkipLoading, v54) )
      {
        if ( !v50 )
        {
          v59 = *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10);
          if ( *(_BYTE *)(v59 + 149) )
          {
            if ( *(_BYTE *)(v59 + 148) )
            {
              if ( *(float *)(v59 + 144) >= 0.0 )
              {
                v60 = *(v52 - 4) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38);
                v61 = (float)(v60 * v60) + v45;
                if ( *v52 >= v61 )
                {
                  v62 = *(float *)(v59 + 144);
                  if ( v62 == 0.0 || v61 <= v62 )
                  {
                    bitarray_base<bitarray<1536>>::setBit(&s_transientsWorldMP.wantVisibleButNotLoaded, v54);
                    v50 = 1;
                  }
                }
              }
            }
          }
        }
        goto LABEL_135;
      }
      v57 = *(v52 - 4) * *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38);
      v58 = (float)(v57 * v57) + v45;
      if ( *v52 >= v58 )
        break;
      if ( *(_BYTE *)(*(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) + 149i64) != *v52 >= v58 && !(_DWORD)v51 && v35 != 0.0 && v35 >= v58 )
        bitarray_base<bitarray<1536>>::setBit(*(bitarray_base<bitarray<1536> > **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20), v38);
LABEL_135:
      v49 = *(unsigned __int16 **)v7;
LABEL_136:
      v51 = (unsigned int)(v51 + 1);
      ++v52;
      if ( (unsigned int)v51 >= 2 )
        goto LABEL_150;
    }
    if ( v58 < *(float *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 4 * v51 + 0x8C) || (unsigned int)(v51 + 1) >= 3 )
    {
      v63 = *(unsigned __int16 **)v7;
    }
    else
    {
      v63 = *(unsigned __int16 **)v7;
      if ( *(_WORD *)(*(_QWORD *)v7 + 2 * v51) )
        bitarray_base<bitarray<1536>>::setBit(*(bitarray_base<bitarray<1536> > **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20), *(unsigned __int16 *)(*(_QWORD *)v7 + 2 * v51));
    }
    v64 = v54;
    v65 = *(bitarray_base<bitarray<1536> > **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18);
    bitarray_base<bitarray<1536>>::setBit(v65, v64);
    for ( j = v51 + 1; j < 3; ++j )
    {
      v67 = j - 1;
      if ( (unsigned int)v67 >= 2 )
      {
        LODWORD(v71) = 2;
        LODWORD(v70) = j - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 1300, ASSERT_TYPE_ASSERT, "(unsigned)( highLod - 1 ) < (unsigned)( STREAMINGINFO_WORLD_LOD_COUNT - 1 )", "highLod - 1 doesn't index STREAMINGINFO_WORLD_LOD_COUNT - 1\n\t%i not in [0, %i)", v70, v71) )
          __debugbreak();
      }
      if ( v63[v67] )
        bitarray_base<bitarray<1536>>::resetBit(v65, v63[v67]);
    }
LABEL_150:
    v10 = *(float **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 8);
LABEL_151:
    v68 = SpatialPartition_Tree_SphereIterator::Advance((SpatialPartition_Tree_SphereIterator *)(v7 + 160));
    v8 = *(const WorldStreamPosition **)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10);
    v33 = *(_QWORD *)(((unsigned __int64)v74 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28);
  }
  while ( v68 );
LABEL_152:
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_UpdateMissingModels
==============
*/
void CL_TransientsWorldMP_UpdateMissingModels(void)
{
  __int64 v0; 
  bitarray<1536> *p_missingModelTransients; 
  unsigned int v2; 
  unsigned __int64 v3; 
  const char *v4; 
  unsigned int v5; 
  unsigned __int64 v6; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v8; 
  XModel *ProxyModel; 
  const char *name; 
  __int64 v11; 
  signed __int64 v12; 
  char v13; 
  __int64 v14; 
  char v15; 
  __int64 v16; 
  unsigned __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  __int64 v21; 

  if ( rgp.world )
  {
    v0 = 3i64;
    p_missingModelTransients = &s_transientsWorldMP.missingModelTransients;
    *(_WORD *)&s_transientsWorldMP.anyMissingModels = 0;
    do
    {
      *(_QWORD *)p_missingModelTransients->array = 0i64;
      *(_QWORD *)&p_missingModelTransients->array[2] = 0i64;
      *(_QWORD *)&p_missingModelTransients->array[4] = 0i64;
      p_missingModelTransients = (bitarray<1536> *)((char *)p_missingModelTransients + 64);
      *(_QWORD *)&p_missingModelTransients[-1].array[38] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[40] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[42] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[44] = 0i64;
      *(_QWORD *)&p_missingModelTransients[-1].array[46] = 0i64;
      --v0;
    }
    while ( v0 );
    v20 = 0;
    v2 = 0;
    v21 = 0i64;
    v3 = 0i64;
    v4 = "default_static_model";
    do
    {
      v5 = 0x80000000 >> (v2 & 0x1F);
      v6 = v3 >> 5;
      if ( (v5 & s_transientsWorldMP.transientsBaseLOD.array[v6]) != 0 )
      {
        HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v2);
        if ( !s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2422, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0)", (const char *)&queryFormat, "s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount > 0") )
          __debugbreak();
        v8 = HighLODLookups[s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount - 1];
        ProxyModel = CL_TransientsWorldMP_FindProxyModel(v8);
        if ( ProxyModel )
        {
          name = ProxyModel->name;
          v11 = 0x7FFFFFFFi64;
          if ( !ProxyModel->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
            __debugbreak();
          v12 = name - "default_static_model";
          do
          {
            v13 = v4[v12];
            v14 = v11;
            v15 = *v4++;
            --v11;
            if ( !v14 )
              break;
            if ( v13 != v15 )
              goto LABEL_23;
          }
          while ( v13 );
          Com_PrintWarning(16, "Proxy for transient %u is using default model, need to recompile d3dbsp!\n", v8);
          s_transientsWorldMP.anyMissingModels = 1;
          v16 = 0i64;
          s_transientsWorldMP.missingModelTransients.array[v6] |= v5;
          if ( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
          {
            do
            {
              v17 = HighLODLookups[v16];
              if ( (unsigned int)v17 >= 0x600 )
              {
                LODWORD(v19) = 1536;
                LODWORD(v18) = HighLODLookups[v16];
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v18, v19) )
                  __debugbreak();
              }
              v16 = (unsigned int)(v16 + 1);
              s_transientsWorldMP.missingModelTransients.array[v17 >> 5] |= 0x80000000 >> (v17 & 0x1F);
            }
            while ( (unsigned int)v16 < s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount );
            v2 = v20;
          }
LABEL_23:
          v4 = "default_static_model";
        }
      }
      v3 = v21 + 1;
      v20 = ++v2;
      ++v21;
    }
    while ( v2 < 0x600 );
  }
}

/*
==============
CL_TransientsWorldMP_UpdatePageBudget
==============
*/
void CL_TransientsWorldMP_UpdatePageBudget()
{
  signed __int64 v0; 
  void *v1; 
  int v2; 
  bool inLobbyState; 
  unsigned int ZoneFlagsFromIndex; 
  char IsAnyLocalServerRunning; 
  char finishedLoading; 
  char v7; 
  unsigned __int64 v8; 
  __int64 v9; 
  const dvar_t *v10; 
  __int64 integer; 
  const dvar_t *v12; 
  signed __int64 v13; 
  const dvar_t *v14; 
  signed __int64 v15; 
  float WorldTileBudgetMultiplier; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  const dvar_t *v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 uiSize; 
  __int64 v24; 
  float v25; 
  __int64 v26; 
  __int64 v27; 
  int v28[2]; 
  MemBudget_PollData outPoll; 

  v1 = alloca(v0);
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CL_TransientsWorldMP_UpdatePageBudget");
  v2 = 0;
  v28[0] = 0;
  inLobbyState = 0;
  if ( s_transientsWorldMP.worldGridInfo )
  {
    if ( !s_transientsWorldMP.zoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 532, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX)", (const char *)&queryFormat, "s_transientsWorldMP.zoneIndex != DEFAULT_ZONE_INDEX") )
      __debugbreak();
    ZoneFlagsFromIndex = DB_Zones_GetZoneFlagsFromIndex(s_transientsWorldMP.zoneIndex);
    IsAnyLocalServerRunning = Com_IsAnyLocalServerRunning();
    HIBYTE(v28[0]) = IsAnyLocalServerRunning;
    if ( (ZoneFlagsFromIndex & 0x100000) != 0 )
    {
      finishedLoading = s_transientsWorldMP.finishedLoading;
    }
    else
    {
      finishedLoading = 1;
      BYTE2(v28[0]) = s_transientsWorldMP.finishedLoading;
    }
    BYTE1(v28[0]) = finishedLoading;
    if ( Com_FrontEndScene_IsActive() || Com_FrontEnd_IsInFrontEnd() || !s_transientsWorldMP.preloadingBackToFE )
    {
      v7 = 0;
      LOBYTE(v28[0]) = 0;
      inLobbyState = s_transientsWorldMP.inLobbyState;
      v2 = v28[0];
    }
    else
    {
      v7 = 1;
      LOBYTE(v28[0]) = 1;
      inLobbyState = s_transientsWorldMP.inLobbyState;
      v2 = v28[0];
    }
  }
  else
  {
    IsAnyLocalServerRunning = HIBYTE(v28[0]);
    finishedLoading = BYTE1(v28[0]);
    v7 = v28[0];
  }
  if ( finishedLoading != s_transientsWorldMP.lastFastfileState.preloaded || BYTE2(v28[0]) != s_transientsWorldMP.lastFastfileState.loaded || IsAnyLocalServerRunning != s_transientsWorldMP.lastFastfileState.hasServer || v7 != s_transientsWorldMP.lastFastfileState.backtoFE || inLobbyState != s_transientsWorldMP.lastFastfileState.inLobbyState )
  {
    v8 = 0i64;
    v9 = 0i64;
    MemBudget_BudgetFile_Update();
    if ( !s_transientsWorldMP.isAlwaysloadedTRWorldMap )
    {
      MemBudget_Poll_Oneoff(&outPoll);
      v10 = DVARINT_cl_worldStreamingQuality;
      if ( !DVARINT_cl_worldStreamingQuality && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_worldStreamingQuality") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v10);
      integer = v10->current.integer;
      if ( (int)integer >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 2250, ASSERT_TYPE_ASSERT, "(qualityLevel < 2)", (const char *)&queryFormat, "qualityLevel < 2") )
        __debugbreak();
      v12 = DVARVEC2_cl_transientWorldMemoryMaxMB;
      if ( !DVARVEC2_cl_transientWorldMemoryMaxMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 727, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryMaxMB") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v12);
      v28[0] = v12->current.integer;
      v28[1] = LODWORD(v12->current.vector.v[1]);
      if ( (unsigned int)integer >= 2 )
      {
        LODWORD(v27) = 2;
        LODWORD(v26) = integer;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v26, v27) )
          __debugbreak();
      }
      v13 = (unsigned __int64)(unsigned int)(int)*(float *)&v28[integer] << 20;
      v14 = DVARINT_cl_transientWorldMemoryMinMB;
      if ( !DVARINT_cl_transientWorldMemoryMinMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryMinMB") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v14);
      v15 = v14->current.integer << 20;
      WorldTileBudgetMultiplier = CL_TransientsWorldMP_GetWorldTileBudgetMultiplier();
      v17 = outPoll.readings.pollValues[2];
      v18 = MemBudget_BudgetFile_GetCurrentBudgets()->pollValues[27];
      if ( Com_FrontEndScene_IsActive() || Com_FrontEnd_IsInFrontEnd() )
      {
        uiSize = outPoll.readings.pollValues[22];
        if ( s_transientsWorldMP.uiSize > (unsigned __int64)outPoll.readings.pollValues[22] )
          uiSize = s_transientsWorldMP.uiSize;
        s_transientsWorldMP.uiSize = uiSize;
      }
      else if ( s_transientsWorldMP.preloadingBackToFE )
      {
        v19 = s_transientsWorldMP.uiSize;
        if ( !s_transientsWorldMP.uiSize )
        {
          v20 = DCONST_DVARINT_cl_transientWorldMemoryFrontendEstimateMB;
          if ( !DCONST_DVARINT_cl_transientWorldMemoryFrontendEstimateMB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldMemoryFrontendEstimateMB") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v20);
          v19 = v20->current.integer << 20;
        }
        v21 = v19 - (outPoll.readings.pollValues[20] + outPoll.readings.pollValues[22]);
        v22 = 0i64;
        if ( v21 > 0 )
          v22 = v21;
        v17 -= v22;
      }
      v24 = v18 - v15 + v17;
      if ( v24 > 0 )
      {
        v25 = (float)v24;
        v24 = (unsigned int)(int)(float)(v25 * WorldTileBudgetMultiplier);
      }
      v9 = v15 + v24;
      if ( v15 > v13 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 773, ASSERT_TYPE_SANITY, "( min <= max )", (const char *)&queryFormat, "min <= max") )
        __debugbreak();
      if ( v13 < v9 )
        v9 = v13;
      if ( v15 > v9 )
        v9 = v15;
    }
    if ( v9 > 0 )
      v8 = v9;
    if ( v8 != s_transientsWorldMP.tileBudget )
    {
      s_transientsWorldMP.tileBudget = v8;
      MemBudget_BudgetFile_Update();
    }
    *(_DWORD *)&s_transientsWorldMP.lastFastfileState.backtoFE = v2;
    s_transientsWorldMP.lastFastfileState.inLobbyState = inLobbyState;
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CL_TransientsWorldMP_UpdateStreamProgress
==============
*/
void CL_TransientsWorldMP_UpdateStreamProgress(bool printProgress)
{
  unsigned int v1; 
  unsigned __int64 v2; 
  unsigned int v3; 
  unsigned __int16 *HighLODLookups; 
  unsigned int v5; 
  unsigned __int64 v6; 
  unsigned int v7; 
  unsigned __int64 v8; 
  XModel *ProxyModel; 
  Material **materialHandles; 
  __int64 v11; 
  Material *v12; 
  unsigned int v13; 
  const char **v14; 
  __int64 v15; 
  unsigned __int8 *v16; 
  const GfxImage *image; 
  int v18; 
  int v19; 
  unsigned __int8 v20; 
  __int128 v23; 
  __int128 v25; 
  __int128 v29; 
  __int128 v31; 
  __int128 v35; 
  __int128 v37; 
  bool v39; 
  __int64 v40; 
  __int64 v41; 
  int v42; 
  XModel *v43; 
  unsigned __int16 *v44; 
  __int64 v45; 
  Material **v46; 
  __int64 v47[3]; 
  unsigned int v49; 
  unsigned int v50; 
  unsigned int v51; 

  v1 = 1;
  v51 = 1;
  v45 = 1i64;
  v2 = 1i64;
  do
  {
    if ( ((0x80000000 >> (v1 & 0x1F)) & s_transientsWorldMP.transientsBaseLOD.array[v2 >> 5]) != 0 )
    {
      v3 = s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount + 1;
      v49 = v3;
      HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v1);
      v5 = 1;
      v44 = HighLODLookups;
      v50 = 1;
      if ( v3 > 1 )
      {
        while ( 1 )
        {
          v6 = *HighLODLookups;
          if ( !*HighLODLookups )
            goto LABEL_52;
          if ( (unsigned int)v6 >= 0x600 )
          {
            LODWORD(v41) = 1536;
            LODWORD(v40) = *HighLODLookups;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v40, v41) )
              __debugbreak();
          }
          v7 = 0x80000000 >> (v6 & 0x1F);
          v8 = v6;
          if ( (v7 & s_transientsWorldMP.loaded.array[v6 >> 5]) == 0 )
            break;
          if ( (unsigned int)v6 >= 0x600 )
          {
            LODWORD(v41) = 1536;
            LODWORD(v40) = v6;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v40, v41) )
              __debugbreak();
          }
          if ( (v7 & s_transientsWorldMP.visibleHint[0].array[v6 >> 5]) == 0 )
            break;
          if ( !s_transientsWorldMP.streamProgressStartTime[v6] )
          {
            s_transientsWorldMP.streamProgressStartTime[v6] = __rdtsc();
            s_transientsWorldMP.streamProgressStartFrame[v6] = s_transientsWorldMP.streamProgressCurrentFrame;
          }
          ProxyModel = CL_TransientsWorldMP_FindProxyModel(v6);
          v43 = ProxyModel;
          if ( ProxyModel )
          {
            materialHandles = ProxyModel->materialHandles;
            v11 = 0i64;
            v42 = 0;
            v46 = materialHandles;
            if ( ProxyModel->numsurfs )
            {
              do
              {
                v12 = materialHandles[v11];
                if ( v12 )
                {
                  v13 = 0;
                  v47[0] = (__int64)"color";
                  v14 = (const char **)v47;
                  v15 = 0i64;
                  v47[1] = (__int64)"normal";
                  v16 = s_transientsWorldMP.streamProgressTextureState[v8];
                  do
                  {
                    if ( v13 < v12->textureCount )
                    {
                      image = v12->textureTable[v15].image;
                      if ( image )
                      {
                        v18 = Stream_Debug_CalcWantedBytesForImage(image);
                        v19 = Stream_Debug_CalcBytesLoadedForImage(v12->textureTable[v15].image);
                        if ( v18 > 0 )
                        {
                          v20 = *v16;
                          if ( (*v16 & 1) == 0 )
                          {
                            if ( printProgress )
                            {
                              _XMM0 = 0i64;
                              __asm { vcvtsi2sd xmm0, xmm0, rax }
                              if ( (__int64)(__rdtsc() - s_transientsWorldMP.streamProgressStartTime[v8]) < 0 )
                              {
                                *((_QWORD *)&v23 + 1) = *((_QWORD *)&_XMM0 + 1);
                                *(double *)&v23 = *(double *)&_XMM0 + 1.844674407370955e19;
                                _XMM0 = v23;
                              }
                              *((_QWORD *)&v25 + 1) = *((_QWORD *)&_XMM0 + 1);
                              *(double *)&v25 = *(double *)&_XMM0 * msecPerRawTimerTick;
                              _XMM0 = v25;
                              LODWORD(v41) = s_transientsWorldMP.streamProgressCurrentFrame - s_transientsWorldMP.streamProgressStartFrame[v8];
                              __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
                              Sys_Printf("Transient %u lod %u (%u) %s wanted data after %.3f ms (%d frames)\n", v51, v50, (unsigned int)v8, *v14, *(float *)&_XMM1, v41);
                              v20 = *v16;
                            }
                            v20 |= 1u;
                            *v16 = v20;
                          }
                          if ( v19 == v18 )
                          {
                            if ( (v20 & 4) == 0 )
                            {
                              if ( printProgress )
                              {
                                _XMM0 = 0i64;
                                __asm { vcvtsi2sd xmm0, xmm0, rax }
                                if ( (__int64)(__rdtsc() - s_transientsWorldMP.streamProgressStartTime[v8]) < 0 )
                                {
                                  *((_QWORD *)&v29 + 1) = *((_QWORD *)&_XMM0 + 1);
                                  *(double *)&v29 = *(double *)&_XMM0 + 1.844674407370955e19;
                                  _XMM0 = v29;
                                }
                                *((_QWORD *)&v31 + 1) = *((_QWORD *)&_XMM0 + 1);
                                *(double *)&v31 = *(double *)&_XMM0 * msecPerRawTimerTick;
                                _XMM0 = v31;
                                LODWORD(v41) = s_transientsWorldMP.streamProgressCurrentFrame - s_transientsWorldMP.streamProgressStartFrame[v8];
                                __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
                                Sys_Printf("Transient %u lod %u (%u) %s completed data after %.3f ms (%d frames)\n", v51, v50, (unsigned int)v8, *v14, *(float *)&_XMM1, v41);
                                v20 = *v16;
                              }
                              *v16 = v20 | 6;
                            }
                          }
                          else if ( v19 > 0 && (v20 & 2) == 0 )
                          {
                            if ( printProgress )
                            {
                              _XMM0 = 0i64;
                              __asm { vcvtsi2sd xmm0, xmm0, rax }
                              if ( (__int64)(__rdtsc() - s_transientsWorldMP.streamProgressStartTime[v8]) < 0 )
                              {
                                *((_QWORD *)&v35 + 1) = *((_QWORD *)&_XMM0 + 1);
                                *(double *)&v35 = *(double *)&_XMM0 + 1.844674407370955e19;
                                _XMM0 = v35;
                              }
                              *((_QWORD *)&v37 + 1) = *((_QWORD *)&_XMM0 + 1);
                              *(double *)&v37 = *(double *)&_XMM0 * msecPerRawTimerTick;
                              _XMM0 = v37;
                              LODWORD(v41) = s_transientsWorldMP.streamProgressCurrentFrame - s_transientsWorldMP.streamProgressStartFrame[v8];
                              __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
                              Sys_Printf("Transient %u lod %u (%u) %s got some data after %.3f ms (%d frames)\n", v51, v50, (unsigned int)v8, *v14, *(float *)&_XMM1, v41);
                              v20 = *v16;
                            }
                            *v16 = v20 | 2;
                          }
                        }
                      }
                    }
                    ++v13;
                    ++v15;
                    ++v16;
                    ++v14;
                  }
                  while ( v13 < 2 );
                  ProxyModel = v43;
                  materialHandles = v46;
                }
                v11 = (unsigned int)(v42 + 1);
                v39 = (unsigned int)v11 < ProxyModel->numsurfs;
                ++v42;
                ProxyModel = v43;
              }
              while ( v39 );
              v5 = v50;
            }
          }
          v3 = v49;
LABEL_47:
          HighLODLookups = v44 + 1;
          v50 = ++v5;
          ++v44;
          if ( v5 >= v3 )
          {
            v1 = v51;
            v2 = v45;
            goto LABEL_49;
          }
        }
        v3 = v49;
LABEL_52:
        if ( s_transientsWorldMP.streamProgressStartTime[v6] )
        {
          s_transientsWorldMP.streamProgressStartTime[v6] = 0i64;
          s_transientsWorldMP.streamProgressStartFrame[v6] = 0;
          *(_WORD *)&s_transientsWorldMP.streamProgressTextureState[v6][0] = 0;
        }
        goto LABEL_47;
      }
    }
LABEL_49:
    ++v1;
    ++v2;
    v51 = v1;
    v45 = v2;
  }
  while ( v1 < 0x600 );
}

/*
==============
CL_TransientsWorldMP_UseLowAlwaysloadedFlagging
==============
*/
_BOOL8 CL_TransientsWorldMP_UseLowAlwaysloadedFlagging()
{
  return s_transientsWorldMP.isLowFlaggingMap;
}

/*
==============
CL_TransientsWorldMP_ValidateGameStartAssumptions
==============
*/
char CL_TransientsWorldMP_ValidateGameStartAssumptions()
{
  char result; 
  unsigned int numStreamPositions; 

  if ( s_transientsWorldMP.worldGridInfo )
  {
    if ( !s_transientsWorldMP.systemEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3618, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.systemEnabled)", (const char *)&queryFormat, "s_transientsWorldMP.systemEnabled") )
      __debugbreak();
    if ( !s_transientsWorldMP.inLobbyState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3619, ASSERT_TYPE_ASSERT, "(s_transientsWorldMP.inLobbyState)", (const char *)&queryFormat, "s_transientsWorldMP.inLobbyState") )
      __debugbreak();
  }
  if ( s_transientsWorldMP.preloadingBackToFE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3621, ASSERT_TYPE_ASSERT, "(!s_transientsWorldMP.preloadingBackToFE)", (const char *)&queryFormat, "!s_transientsWorldMP.preloadingBackToFE") )
    __debugbreak();
  CL_TransientsWorldMPValidateVisibilityState();
  result = s_transientsWorldMP.numStreamPositions;
  if ( s_transientsWorldMP.numStreamPositions )
  {
    numStreamPositions = s_transientsWorldMP.numStreamPositions;
    result = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3625, ASSERT_TYPE_ASSERT, "( s_transientsWorldMP.numStreamPositions ) == ( 0 )", "%s == %s\n\t%u, %u", "s_transientsWorldMP.numStreamPositions", "0", numStreamPositions, 0i64);
    if ( result )
      __debugbreak();
  }
  return result;
}

/*
==============
DB_TransientsWorldMP_GetCellDelayRemaining
==============
*/
__int64 DB_TransientsWorldMP_GetCellDelayRemaining(const unsigned int clientNum, const unsigned int baseTransient, int *outLodNumber)
{
  __int64 v3; 
  __int64 v5; 
  int v6; 
  int v7; 
  TransientZoneIntArray *v8; 
  bitarray_base<bitarray<1536> > *v9; 
  unsigned __int16 *HighLODLookups; 
  int v11; 
  unsigned __int16 v12; 
  unsigned __int64 v13; 
  int v14; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  TransientZoneIntArray *v20; 

  v3 = baseTransient;
  v5 = clientNum;
  if ( clientNum >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4067, ASSERT_TYPE_ASSERT, "(unsigned)( clientNum ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.switchDelayStarted ) ) + 0 ) )", "clientNum doesn't index s_transientsWorldMP.switchDelayStarted\n\t%i not in [0, %i)", clientNum, 2) )
    __debugbreak();
  *outLodNumber = -1;
  v6 = 0;
  v7 = 0;
  v20 = &s_transientsWorldMP.switchDelayTarget[v5];
  v8 = &s_transientsWorldMP.switchDelayStarted[v5];
  if ( (unsigned int)v3 >= 0x600 )
  {
    LODWORD(v18) = 1536;
    LODWORD(v16) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4078, ASSERT_TYPE_ASSERT, "(unsigned)( baseTransient ) < (unsigned)( ( sizeof( *array_counter( delayStartedArray.data ) ) + 0 ) )", "baseTransient doesn't index ARRAY_COUNT( delayStartedArray.data )\n\t%i not in [0, %i)", v16, v18) )
      __debugbreak();
  }
  v9 = &s_transientsWorldMP.visibleTarget[v5];
  if ( bitarray_base<bitarray<1536>>::testBit(v9, v3) )
  {
    *outLodNumber = 0;
    v6 = v8->data[v3];
    v7 = s_transientsWorldMP.switchDelayTarget[v5].data[v3];
  }
  else
  {
    HighLODLookups = CL_TransientsWorldMP_GetHighLODLookups(v3);
    v11 = 0;
    if ( s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
    {
      while ( 1 )
      {
        v12 = HighLODLookups[v11];
        if ( v12 )
        {
          v13 = v12;
          if ( v12 >= 0x600u )
          {
            LODWORD(v18) = 1536;
            LODWORD(v16) = v12;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 4094, ASSERT_TYPE_ASSERT, "(unsigned)( transientIndex ) < (unsigned)( ( sizeof( *array_counter( delayStartedArray.data ) ) + 0 ) )", "transientIndex doesn't index ARRAY_COUNT( delayStartedArray.data )\n\t%i not in [0, %i)", v16, v18) )
              __debugbreak();
            LODWORD(v19) = 1536;
            LODWORD(v17) = v13;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v17, v19) )
              __debugbreak();
          }
          if ( ((0x80000000 >> (v13 & 0x1F)) & *(_DWORD *)&v9[4 * (v13 >> 5)]) != 0 )
            break;
        }
        if ( ++v11 >= s_transientsWorldMP.worldGridInfo->transientWorldGridHighLodCount )
          goto LABEL_20;
      }
      *outLodNumber = v11 + 1;
      v6 = v8->data[v13];
      v7 = v20->data[v13];
    }
LABEL_20:
    if ( *outLodNumber < 0 )
      return 0i64;
  }
  v14 = Sys_Milliseconds() - v6;
  if ( v14 > 0 && v14 < v7 )
    return (unsigned int)(v7 - v14);
  return 0i64;
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds
==============
*/
Bounds *CL_TransientsWorldMP_TransientChangedVisibleIterator::GetCurrentBounds(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  unsigned int m_currentTransientIndex; 
  unsigned int v4; 
  unsigned int transientWorldGridBoundsCount; 

  m_currentTransientIndex = this->m_currentTransientIndex;
  if ( m_currentTransientIndex >= s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )
  {
    transientWorldGridBoundsCount = s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount;
    v4 = m_currentTransientIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 3878, ASSERT_TYPE_ASSERT, "(unsigned)( m_currentTransientIndex ) < (unsigned)( s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount )", "m_currentTransientIndex doesn't index s_transientsWorldMP.worldGridInfo->transientWorldGridBoundsCount\n\t%i not in [0, %i)", v4, transientWorldGridBoundsCount) )
      __debugbreak();
  }
  return &s_transientsWorldMP.worldGridInfo->transientWorldGridBounds[this->m_currentTransientIndex];
}

/*
==============
InterleavedPriorities::GetPriority
==============
*/
unsigned __int16 InterleavedPriorities::GetPriority(InterleavedPriorities *this, const unsigned __int64 tileIndex, const unsigned __int16 lod1Index, const bool insideLod0Cell)
{
  unsigned __int16 v8; 
  const dvar_t *v9; 
  unsigned __int16 v10; 
  unsigned __int16 spilloverIndex; 
  unsigned __int16 result; 
  __int64 v13; 
  int v14; 
  __int64 v15; 
  int v16; 

  if ( (unsigned int)tileIndex >= 0x15 )
  {
    v16 = 21;
    v14 = tileIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 433, ASSERT_TYPE_ASSERT, "(unsigned)( tileIndex ) < (unsigned)( ( sizeof( *array_counter( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES ) ) + 0 ) )", "tileIndex doesn't index ARRAY_COUNT( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES )\n\t%i not in [0, %i)", v14, v16) )
      __debugbreak();
  }
  if ( lod1Index >= 4u )
  {
    LODWORD(v15) = 4;
    LODWORD(v13) = lod1Index;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 434, ASSERT_TYPE_ASSERT, "(unsigned)( lod1Index ) < (unsigned)( TRWORLD_LOD1TILES_IN_SLOT )", "lod1Index doesn't index TRWORLD_LOD1TILES_IN_SLOT\n\t%i not in [0, %i)", v13, v15) )
      __debugbreak();
  }
  v8 = truncate_cast<unsigned short,unsigned int>(CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES[tileIndex] - lod1Index);
  v9 = DCONST_DVARBOOL_cl_transientWorldSpilloverPriorities;
  v10 = v8;
  if ( !DCONST_DVARBOOL_cl_transientWorldSpilloverPriorities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cl_transientWorldSpilloverPriorities") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( !v9->current.enabled || !insideLod0Cell )
    return v10;
  if ( lod1Index && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 440, ASSERT_TYPE_ASSERT, "(lod1Index == 0)", (const char *)&queryFormat, "lod1Index == 0") )
    __debugbreak();
  if ( v10 > 0xF9Fu )
    return v10;
  spilloverIndex = this->spilloverIndex;
  if ( spilloverIndex >= 6u )
    return v10;
  result = truncate_cast<unsigned short,unsigned int>(CL_TRANSIENT_WORLD_CLOSE_SPILLOVER_PRIORITIES[spilloverIndex]);
  ++this->spilloverIndex;
  return result;
}

/*
==============
CL_TransientsWorldMP_TransientChangedVisibleIterator::Init
==============
*/
void CL_TransientsWorldMP_TransientChangedVisibleIterator::Init(CL_TransientsWorldMP_TransientChangedVisibleIterator *this)
{
  if ( s_transientsWorldMP.systemEnabled )
  {
    this->m_wordIndex = 0;
    *(_QWORD *)&this->m_wordCount = 48i64;
    this->m_currentBits = s_transientsWorldMP.changedVisible.array[0];
  }
  else
  {
    *(_QWORD *)&this->m_wordIndex = 0i64;
    *(_QWORD *)&this->m_currentTransientIndex = 0i64;
  }
}

/*
==============
InterleavedPriorities::Insert
==============
*/
unsigned __int16 InterleavedPriorities::Insert(InterleavedPriorities *this, const unsigned int trIndex, const bool insideCell)
{
  __int64 v3; 
  bool v6; 
  unsigned __int16 result; 
  unsigned __int16 curLod1TileIndex; 
  unsigned __int16 Priority; 
  unsigned __int16 nextEmptyTileIndex; 
  __int64 v11; 
  __int64 v12; 

  v3 = trIndex;
  if ( trIndex )
  {
    if ( trIndex < 0x600 )
      goto LABEL_7;
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 462, ASSERT_TYPE_ASSERT, "(unsigned)( trIndex ) < (unsigned)( ( sizeof( *array_counter( s_transientsWorldMP.transientLODIndex ) ) + 0 ) )", "trIndex doesn't index ARRAY_COUNT( s_transientsWorldMP.transientLODIndex )\n\t%i not in [0, %i)", trIndex, 1536);
  }
  else
  {
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 460, ASSERT_TYPE_ASSERT, "(trIndex != TRANSIENT_ZONE_ALWAYSLOADED)", (const char *)&queryFormat, "trIndex != TRANSIENT_ZONE_ALWAYSLOADED");
  }
  if ( v6 )
    __debugbreak();
LABEL_7:
  if ( !s_transientsWorldMP.transientLODIndex[v3] )
  {
    if ( this->nextEmptyTileIndex < 0x15u )
    {
      result = InterleavedPriorities::GetPriority(this, this->nextEmptyTileIndex, 0, insideCell);
      ++this->nextEmptyTileIndex;
      return result;
    }
    goto LABEL_27;
  }
  if ( !this->nextLod1SubTileIndex )
  {
    if ( this->nextEmptyTileIndex < 0x15u )
    {
      Priority = InterleavedPriorities::GetPriority(this, this->nextEmptyTileIndex, 0, 0);
      if ( this->curLod1TileIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 498, ASSERT_TYPE_ASSERT, "(curLod1TileIndex == 0)", (const char *)&queryFormat, "curLod1TileIndex == 0") )
        __debugbreak();
      if ( this->nextLod1SubTileIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 499, ASSERT_TYPE_ASSERT, "(nextLod1SubTileIndex == 0)", (const char *)&queryFormat, "nextLod1SubTileIndex == 0") )
        __debugbreak();
      nextEmptyTileIndex = this->nextEmptyTileIndex;
      this->curLod1TileIndex = this->nextEmptyTileIndex;
      this->nextEmptyTileIndex = nextEmptyTileIndex + 1;
      this->nextLod1SubTileIndex = 1;
      return Priority;
    }
LABEL_27:
    Priority = this->nextFarIndex;
    if ( Priority < 0x356u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 512, ASSERT_TYPE_ASSERT, "( priority ) >= ( TRANSIENT_PRIORITY_VERY_FAR_GFX_TILES_LOW )", "%s >= %s\n\t%u, %u", "priority", "TRANSIENT_PRIORITY_VERY_FAR_GFX_TILES_LOW", Priority, 854) )
      __debugbreak();
    --this->nextFarIndex;
    return Priority;
  }
  curLod1TileIndex = this->curLod1TileIndex;
  if ( curLod1TileIndex >= 0x15u )
  {
    LODWORD(v12) = 21;
    LODWORD(v11) = curLod1TileIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 480, ASSERT_TYPE_ASSERT, "(unsigned)( curLod1TileIndex ) < (unsigned)( ( sizeof( *array_counter( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES ) ) + 0 ) )", "curLod1TileIndex doesn't index ARRAY_COUNT( CL_TRANSIENT_WORLD_INTERLEAVED_PRIORITIES )\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  if ( this->curLod1TileIndex >= this->nextEmptyTileIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 481, ASSERT_TYPE_ASSERT, "(curLod1TileIndex < nextEmptyTileIndex)", (const char *)&queryFormat, "curLod1TileIndex < nextEmptyTileIndex") )
    __debugbreak();
  result = InterleavedPriorities::GetPriority(this, this->curLod1TileIndex, this->nextLod1SubTileIndex, 0);
  if ( ++this->nextLod1SubTileIndex == 4 )
    *(_DWORD *)&this->curLod1TileIndex = 0;
  return result;
}

/*
==============
LinearRamp
==============
*/
float LinearRamp(const float value, const float rampStart, const float rampEnd)
{
  if ( rampStart > rampEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 813, ASSERT_TYPE_ASSERT, "(rampStart <= rampEnd)", (const char *)&queryFormat, "rampStart <= rampEnd") )
    __debugbreak();
  if ( value <= rampStart )
    return 0.0;
  if ( value < rampEnd )
    return (float)(value - rampStart) / (float)(rampEnd - rampStart);
  return FLOAT_1_0;
}

/*
==============
LinearRampSq
==============
*/
float LinearRampSq(const float valueSq, const float rampStart, const float rampEnd)
{
  if ( rampStart > rampEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client_mp\\cl_transients_world_mp.cpp", 831, ASSERT_TYPE_ASSERT, "(rampStart <= rampEnd)", (const char *)&queryFormat, "rampStart <= rampEnd") )
    __debugbreak();
  if ( valueSq <= (float)(rampStart * rampStart) )
    return 0.0;
  if ( valueSq < (float)(rampEnd * rampEnd) )
    return (float)(fsqrt(valueSq) - rampStart) / (float)(rampEnd - rampStart);
  return FLOAT_1_0;
}

