/*
==============
FindDominantContextTypeNoBlend
==============
*/

unsigned int __fastcall FindDominantContextTypeNoBlend(const unsigned int contextType, const ZoneDef *zone, const SndEntState *entState)
{
  return ?FindDominantContextTypeNoBlend@@YAIIPEBUZoneDef@@PEBUSndEntState@@@Z(contextType, zone, entState);
}

/*
==============
SND_ResetTimeScaleDefaults
==============
*/

void SND_ResetTimeScaleDefaults(void)
{
  ?SND_ResetTimeScaleDefaults@@YAXXZ();
}

/*
==============
SND_GetVolModName
==============
*/

const char *__fastcall SND_GetVolModName(unsigned int volmodIndex)
{
  return ?SND_GetVolModName@@YAPEBDI@Z(volmodIndex);
}

/*
==============
SND_IsChannelMissionVOChannel
==============
*/

bool __fastcall SND_IsChannelMissionVOChannel(unsigned int entChannel)
{
  return ?SND_IsChannelMissionVOChannel@@YA_NI@Z(entChannel);
}

/*
==============
SND_GetSoundOverlay
==============
*/

int __fastcall SND_GetSoundOverlay(snd_overlay_type_t type, snd_overlay_info_t *info, int maxcount, int *cpu)
{
  return ?SND_GetSoundOverlay@@YAHW4snd_overlay_type_t@@QEAUsnd_overlay_info_t@@HPEAH@Z(type, info, maxcount, cpu);
}

/*
==============
SND_UpdateDebug
==============
*/

void SND_UpdateDebug(void)
{
  ?SND_UpdateDebug@@YAXXZ();
}

/*
==============
SND_GetDryLevel
==============
*/

double __fastcall SND_GetDryLevel(const SndVoice *voice, bool useReverbDryLevel)
{
  double result; 

  *(float *)&result = ?SND_GetDryLevel@@YAMPEBUSndVoice@@_N@Z(voice, useReverbDryLevel);
  return result;
}

/*
==============
SND_GetVolumeFalloffGain
==============
*/

double __fastcall SND_GetVolumeFalloffGain(const SndVoice *voice, const float dist, const float distFrac, const SndCurve *vfCurve)
{
  double result; 

  *(float *)&result = ?SND_GetVolumeFalloffGain@@YAMPEBUSndVoice@@MMPEBUSndCurve@@@Z(voice, dist, distFrac, vfCurve);
  return result;
}

/*
==============
SND_GetWhizbyData
==============
*/

bool __fastcall SND_GetWhizbyData(const LocalClientNum_t localClientNum, const WeaponSFXPackage *sfxPackage, const vec3_t *inSndCenterPt, const vec3_t *inBulletDir, const float shooterDist, const bool isBallistic, const float ballisticTimeSecToTarget, float radius, SndWhizbyData *outWhizbyData)
{
  return ?SND_GetWhizbyData@@YA_NW4LocalClientNum_t@@PEBUWeaponSFXPackage@@AEBTvec3_t@@2M_NMMAEAUSndWhizbyData@@@Z(localClientNum, sfxPackage, inSndCenterPt, inBulletDir, shooterDist, isBallistic, ballisticTimeSecToTarget, radius, outWhizbyData);
}

/*
==============
SND_VoiceSetStartSync
==============
*/

void __fastcall SND_VoiceSetStartSync(SndVoice *voice, bool startSync, float syncPeriodFrames, int meter, int offsetFrames, int delayBeats, int fadeBeats)
{
  ?SND_VoiceSetStartSync@@YAXPEAUSndVoice@@_NMHHHH@Z(voice, startSync, syncPeriodFrames, meter, offsetFrames, delayBeats, fadeBeats);
}

/*
==============
SND_ScalePitchOnEnt
==============
*/

void __fastcall SND_ScalePitchOnEnt(unsigned __int64 sndEnt, float pitch, int msec)
{
  ?SND_ScalePitchOnEnt@@YAX_KMH@Z(sndEnt, pitch, msec);
}

/*
==============
SND_InitAliasGroupTracking
==============
*/

void __fastcall SND_InitAliasGroupTracking(SndAliasGroupTracking *inOutTracking)
{
  ?SND_InitAliasGroupTracking@@YAXAEAUSndAliasGroupTracking@@@Z(inOutTracking);
}

/*
==============
SND_ProcessPendingRestore
==============
*/

void SND_ProcessPendingRestore(void)
{
  ?SND_ProcessPendingRestore@@YAXXZ();
}

/*
==============
SND_GetLengthMS
==============
*/

bool __fastcall SND_GetLengthMS(unsigned int playbackId, int *msec)
{
  return ?SND_GetLengthMS@@YA_NIPEAH@Z(playbackId, msec);
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const char *aliasName, const unsigned __int64 sndEnt, const float volumeScale, const float pitch, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  return ?SND_PlayScaledSoundAlias@@YAIPEBD_KMMAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasName, sndEnt, volumeScale, pitch, org, timeshift, system);
}

/*
==============
SND_ClearSoloChannel_f
==============
*/

void __fastcall SND_ClearSoloChannel_f()
{
  ?SND_ClearSoloChannel_f@@YAXXZ();
}

/*
==============
SND_GetSlavePercent
==============
*/

double __fastcall SND_GetSlavePercent(const SndAlias *alias)
{
  double result; 

  *(float *)&result = ?SND_GetSlavePercent@@YAMPEBUSndAlias@@@Z(alias);
  return result;
}

/*
==============
SND_PrintEqParams
==============
*/

void SND_PrintEqParams(void)
{
  ?SND_PrintEqParams@@YAXXZ();
}

/*
==============
CG_SND_Update
==============
*/

void __fastcall CG_SND_Update(const LocalClientNum_t localClientNum)
{
  ?CG_SND_Update@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
SND_IsRestricted
==============
*/

bool __fastcall SND_IsRestricted(unsigned int entchannel)
{
  return ?SND_IsRestricted@@YA_NI@Z(entchannel);
}

/*
==============
SND_InitGlobalContexts
==============
*/

void SND_InitGlobalContexts(void)
{
  ?SND_InitGlobalContexts@@YAXXZ();
}

/*
==============
SND_ApplySpeakerParams
==============
*/

void __fastcall SND_ApplySpeakerParams(const int index, const int frametime, const float voiceVolume)
{
  ?SND_ApplySpeakerParams@@YAXHHM@Z(index, frametime, voiceVolume);
}

/*
==============
SND_StopVoice
==============
*/

void __fastcall SND_StopVoice(int index)
{
  ?SND_StopVoice@@YAXH@Z(index);
}

/*
==============
SND_SetListener
==============
*/

void __fastcall SND_SetListener(LocalClientNum_t localClientNum, int playerStateClientNum, const vec3_t *origin, const tmat33_t<vec3_t> *axis, const vec3_t *velocity)
{
  ?SND_SetListener@@YAXW4LocalClientNum_t@@HAEBTvec3_t@@AEBT?$tmat33_t@Tvec3_t@@@@1@Z(localClientNum, playerStateClientNum, origin, axis, velocity);
}

/*
==============
SND_GetListenerOrigin
==============
*/

void __fastcall SND_GetListenerOrigin(const LocalClientNum_t clientNum, vec3_t *outOrigin)
{
  ?SND_GetListenerOrigin@@YAXW4LocalClientNum_t@@AEATvec3_t@@@Z(clientNum, outOrigin);
}

/*
==============
SND_RecalcPropagation_f
==============
*/

void __fastcall SND_RecalcPropagation_f()
{
  ?SND_RecalcPropagation_f@@YAXXZ();
}

/*
==============
SND_SetEqQ
==============
*/

void __fastcall SND_SetEqQ(int entchannel, int eqIndex, int band, float q)
{
  ?SND_SetEqQ@@YAXHHHM@Z(entchannel, eqIndex, band, q);
}

/*
==============
SND_PlayContextSoundAsync
==============
*/

void __fastcall SND_PlayContextSoundAsync(const SndAliasList *aliasList, const int surfaceType, const int contextIndex, const int contextIndex2, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org)
{
  ?SND_PlayContextSoundAsync@@YAXPEBUSndAliasList@@HHHW4LocalClientNum_t@@HMMAEBTvec3_t@@@Z(aliasList, surfaceType, contextIndex, contextIndex2, localClientNum, entnum, volumeScale, pitch, org);
}

/*
==============
SND_StopAmbientAlias
==============
*/

void __fastcall SND_StopAmbientAlias(const char *aliasName, int fadeTime)
{
  ?SND_StopAmbientAlias@@YAXPEBDH@Z(aliasName, fadeTime);
}

/*
==============
SND_FindAssetsForVoice
==============
*/

bool __fastcall SND_FindAssetsForVoice(SndStartAliasInfo *info)
{
  return ?SND_FindAssetsForVoice@@YA_NPEAUSndStartAliasInfo@@@Z(info);
}

/*
==============
SND_OcclusionWorker
==============
*/

void __fastcall SND_OcclusionWorker(const void *const cmdInfo)
{
  ?SND_OcclusionWorker@@YAXQEBX@Z(cmdInfo);
}

/*
==============
SND_RemoveVoice
==============
*/

void __fastcall SND_RemoveVoice(unsigned int entchannel)
{
  ?SND_RemoveVoice@@YAXI@Z(entchannel);
}

/*
==============
SND_PlaySoundAliasFromParams
==============
*/

unsigned int __fastcall SND_PlaySoundAliasFromParams(const SndPlayParams *inParams, bool deferred)
{
  return ?SND_PlaySoundAliasFromParams@@YAIAEBUSndPlayParams@@_N@Z(inParams, deferred);
}

/*
==============
SND_GetSoundFileLengthMS
==============
*/

int __fastcall SND_GetSoundFileLengthMS(const SndAssetBankEntry *entry)
{
  return ?SND_GetSoundFileLengthMS@@YAHPEBUSndAssetBankEntry@@@Z(entry);
}

/*
==============
SND_GetMasterPercent
==============
*/

double __fastcall SND_GetMasterPercent(const SndVoice *voice)
{
  double result; 

  *(float *)&result = ?SND_GetMasterPercent@@YAMPEBUSndVoice@@@Z(voice);
  return result;
}

/*
==============
SND_ResetVoice
==============
*/

void __fastcall SND_ResetVoice(int index)
{
  ?SND_ResetVoice@@YAXH@Z(index);
}

/*
==============
SND_SetEq
==============
*/

void __fastcall SND_SetEq(const char *channelName, int eqIndex, int band, SND_EQTYPE type, float gain, float freq, float q)
{
  ?SND_SetEq@@YAXPEBDHHW4SND_EQTYPE@@MMM@Z(channelName, eqIndex, band, type, gain, freq, q);
}

/*
==============
SND_ChangeSoundAliasValuesOnPlayingChannels
==============
*/

void __fastcall SND_ChangeSoundAliasValuesOnPlayingChannels(const SndAlias *alias, const unsigned int oldEntChannel)
{
  ?SND_ChangeSoundAliasValuesOnPlayingChannels@@YAXPEBUSndAlias@@I@Z(alias, oldEntChannel);
}

/*
==============
SND_GetSubtitleForPlaybackId
==============
*/

const char *__fastcall SND_GetSubtitleForPlaybackId(unsigned int id)
{
  return ?SND_GetSubtitleForPlaybackId@@YAPEBDI@Z(id);
}

/*
==============
SND_FullOcclusionEnabledForChannel
==============
*/

bool __fastcall SND_FullOcclusionEnabledForChannel(int entChannelIdx)
{
  return ?SND_FullOcclusionEnabledForChannel@@YA_NH@Z(entChannelIdx);
}

/*
==============
SND_UpdateVehicle
==============
*/

void __fastcall SND_UpdateVehicle(const SndAliasList *aliasList, LocalClientNum_t localClientNum, int entNum, vec3_t *origin, float throttle, float brake)
{
  ?SND_UpdateVehicle@@YAXPEBUSndAliasList@@W4LocalClientNum_t@@HTvec3_t@@MM@Z(aliasList, localClientNum, entNum, origin, throttle, brake);
}

/*
==============
SND_UnpauseVoice
==============
*/

void __fastcall SND_UnpauseVoice(int index)
{
  ?SND_UnpauseVoice@@YAXH@Z(index);
}

/*
==============
SND_IsAliasSpatial
==============
*/

bool __fastcall SND_IsAliasSpatial(const SndAlias *alias)
{
  return ?SND_IsAliasSpatial@@YA_NPEBUSndAlias@@@Z(alias);
}

/*
==============
SND_ResetEntState
==============
*/

void SND_ResetEntState(void)
{
  ?SND_ResetEntState@@YAXXZ();
}

/*
==============
SNDL_Shutdown
==============
*/

void SNDL_Shutdown(void)
{
  ?SNDL_Shutdown@@YAXXZ();
}

/*
==============
SND_ErrorIfSoundGlobalsTrashed
==============
*/

void SND_ErrorIfSoundGlobalsTrashed(void)
{
  ?SND_ErrorIfSoundGlobalsTrashed@@YAXXZ();
}

/*
==============
SND_GetVoiceIndexForId
==============
*/

int __fastcall SND_GetVoiceIndexForId(unsigned int id)
{
  return ?SND_GetVoiceIndexForId@@YAHI@Z(id);
}

/*
==============
SND_ShouldInit
==============
*/

bool __fastcall SND_ShouldInit()
{
  return ?SND_ShouldInit@@YA_NXZ();
}

/*
==============
SND_AnyActiveListeners
==============
*/

bool __fastcall SND_AnyActiveListeners()
{
  return ?SND_AnyActiveListeners@@YA_NXZ();
}

/*
==============
SND_GetVolModDefaultValue
==============
*/

double __fastcall SND_GetVolModDefaultValue(unsigned int volmodIndex)
{
  double result; 

  *(float *)&result = ?SND_GetVolModDefaultValue@@YAMI@Z(volmodIndex);
  return result;
}

/*
==============
SND_ResetPauseDefaults
==============
*/

void SND_ResetPauseDefaults(void)
{
  ?SND_ResetPauseDefaults@@YAXXZ();
}

/*
==============
SND_StopSoundChannelOnEnt
==============
*/

void __fastcall SND_StopSoundChannelOnEnt(unsigned __int64 sndEnt, unsigned int channelNum)
{
  ?SND_StopSoundChannelOnEnt@@YAX_KI@Z(sndEnt, channelNum);
}

/*
==============
SND_EntChannelHasCenterSpeakerPanning
==============
*/

bool __fastcall SND_EntChannelHasCenterSpeakerPanning(unsigned int entchannel)
{
  return ?SND_EntChannelHasCenterSpeakerPanning@@YA_NI@Z(entchannel);
}

/*
==============
SND_EntChannelHas71SpeakerPanning
==============
*/

bool __fastcall SND_EntChannelHas71SpeakerPanning(unsigned int entchannel)
{
  return ?SND_EntChannelHas71SpeakerPanning@@YA_NI@Z(entchannel);
}

/*
==============
SND_IsScriptNotifySoundPlaying
==============
*/

bool __fastcall SND_IsScriptNotifySoundPlaying(int entNum, unsigned __int16 index)
{
  return ?SND_IsScriptNotifySoundPlaying@@YA_NHG@Z(entNum, index);
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/

int __fastcall SND_PlayVirtualLoopSound(const char *aliasName, const unsigned __int64 sndEnt, const vec3_t *org, float volume, float pitch)
{
  return ?SND_PlayVirtualLoopSound@@YAHPEBD_KAEBTvec3_t@@MM@Z(aliasName, sndEnt, org, volume, pitch);
}

/*
==============
SND_EntChannelFarReverbBehavior
==============
*/

SndFarReverbBehavior __fastcall SND_EntChannelFarReverbBehavior(unsigned int entchannel)
{
  return ?SND_EntChannelFarReverbBehavior@@YA?AW4SndFarReverbBehavior@@I@Z(entchannel);
}

/*
==============
SND_GetWetLevel
==============
*/

double __fastcall SND_GetWetLevel(const SndAlias *pAlias, ReverbDescriptor index)
{
  double result; 

  *(float *)&result = ?SND_GetWetLevel@@YAMPEBUSndAlias@@W4ReverbDescriptor@@@Z(pAlias, index);
  return result;
}

/*
==============
SND_GetFractionStartMsec
==============
*/

int __fastcall SND_GetFractionStartMsec(const SndStartAliasInfo *startAliasInfo)
{
  return ?SND_GetFractionStartMsec@@YAHPEBUSndStartAliasInfo@@@Z(startAliasInfo);
}

/*
==============
SND_PlaySurfaceSound
==============
*/

unsigned int __fastcall SND_PlaySurfaceSound(const char *aliasName, const int surfaceType, const unsigned __int64 sndEnt, float volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  return ?SND_PlaySurfaceSound@@YAIPEBDH_KMMHAEBTvec3_t@@@Z(aliasName, surfaceType, sndEnt, volumeScale, pitch, fadeTime, org);
}

/*
==============
SND_GetVoiceFractionPlayed
==============
*/

double __fastcall SND_GetVoiceFractionPlayed(int index, bool wrap)
{
  double result; 

  *(float *)&result = ?SND_GetVoiceFractionPlayed@@YAMH_N@Z(index, wrap);
  return result;
}

/*
==============
SND_CalcAttenuation
==============
*/

double __fastcall SND_CalcAttenuation(const float baseVolume, const float volumeScale, const SndAlias *p_alias, const unsigned __int64 sndEnt, const snd_alias_system_t system)
{
  double result; 

  *(float *)&result = ?SND_CalcAttenuation@@YAMMMPEBUSndAlias@@_KW4snd_alias_system_t@@@Z(baseVolume, volumeScale, p_alias, sndEnt, system);
  return result;
}

/*
==============
SND_SetAmbientEvents
==============
*/

void __fastcall SND_SetAmbientEvents(const LocalClientNum_t localClientNum, const SoundTable *soundTable, const AmbientDef *ambientDef, float strength)
{
  ?SND_SetAmbientEvents@@YAXW4LocalClientNum_t@@PEBUSoundTable@@PEBUAmbientDef@@M@Z(localClientNum, soundTable, ambientDef, strength);
}

/*
==============
SND_IsChannelQuadAmbientChannel
==============
*/

bool __fastcall SND_IsChannelQuadAmbientChannel(unsigned int entChannel)
{
  return ?SND_IsChannelQuadAmbientChannel@@YA_NI@Z(entChannel);
}

/*
==============
SND_FadeLocalSoundAliasById
==============
*/

bool __fastcall SND_FadeLocalSoundAliasById(LocalClientNum_t localClientNum, unsigned int id, float fadeValue, int msec, snd_alias_system_t system)
{
  return ?SND_FadeLocalSoundAliasById@@YA_NW4LocalClientNum_t@@IMHW4snd_alias_system_t@@@Z(localClientNum, id, fadeValue, msec, system);
}

/*
==============
SND_ScaleVolumeOnEnt
==============
*/

void __fastcall SND_ScaleVolumeOnEnt(unsigned __int64 sndEnt, float volume, int msec)
{
  ?SND_ScaleVolumeOnEnt@@YAX_KMH@Z(sndEnt, volume, msec);
}

/*
==============
SND_ApplyEq
==============
*/

void __fastcall SND_ApplyEq(int voiceIndex, int entchannel, int frametime, float lpfCutoff, float hpfCutoff, float occlusionAmount)
{
  ?SND_ApplyEq@@YAXHHHMMM@Z(voiceIndex, entchannel, frametime, lpfCutoff, hpfCutoff, occlusionAmount);
}

/*
==============
SND_InitVirtualLoopingSounds
==============
*/

void SND_InitVirtualLoopingSounds(void)
{
  ?SND_InitVirtualLoopingSounds@@YAXXZ();
}

/*
==============
CG_SND_BankDetailStream_SetScriptedSoundbanks
==============
*/

void __fastcall CG_SND_BankDetailStream_SetScriptedSoundbanks(const unsigned __int64 scriptedSoundbanksStateBitfield)
{
  ?CG_SND_BankDetailStream_SetScriptedSoundbanks@@YAX_K@Z(scriptedSoundbanksStateBitfield);
}

/*
==============
SND_SetEqLerp
==============
*/

void __fastcall SND_SetEqLerp(float lerp)
{
  ?SND_SetEqLerp@@YAXM@Z(lerp);
}

/*
==============
SND_StopSoundAliasAndSecondariesByAliasId
==============
*/

bool __fastcall SND_StopSoundAliasAndSecondariesByAliasId(unsigned int aliasId, LocalClientNum_t localClientNum, int entnum)
{
  return ?SND_StopSoundAliasAndSecondariesByAliasId@@YA_NIW4LocalClientNum_t@@H@Z(aliasId, localClientNum, entnum);
}

/*
==============
SND_GetVolModIndexFromName
==============
*/

unsigned int __fastcall SND_GetVolModIndexFromName(const char *name)
{
  return ?SND_GetVolModIndexFromName@@YAIPEBD@Z(name);
}

/*
==============
SND_DisableFullOcclusionForEntChannel
==============
*/

void __fastcall SND_DisableFullOcclusionForEntChannel(int entChannelIdx)
{
  ?SND_DisableFullOcclusionForEntChannel@@YAXH@Z(entChannelIdx);
}

/*
==============
SND_SetMainReverbBlended
==============
*/

void __fastcall SND_SetMainReverbBlended(const ReverbDef *fromDef, const ReverbDef *toDef, float lerp)
{
  ?SND_SetMainReverbBlended@@YAXPEBUReverbDef@@0M@Z(fromDef, toDef, lerp);
}

/*
==============
SND_DeactivateEqForChannel
==============
*/

void __fastcall SND_DeactivateEqForChannel(int entchannel, int eqIndex, int band)
{
  ?SND_DeactivateEqForChannel@@YAXHHH@Z(entchannel, eqIndex, band);
}

/*
==============
SND_AnyEqEnabled
==============
*/

bool __fastcall SND_AnyEqEnabled(int entchannel)
{
  return ?SND_AnyEqEnabled@@YA_NH@Z(entchannel);
}

/*
==============
SND_PlaySurfaceSoundAsync
==============
*/

void __fastcall SND_PlaySurfaceSoundAsync(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, float volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  ?SND_PlaySurfaceSoundAsync@@YAXPEBUSndAliasList@@H_KMMHAEBTvec3_t@@@Z(aliasList, surfaceType, sndEnt, volumeScale, pitch, fadeTime, org);
}

/*
==============
SND_SetOcclusionFilterSingleIndex
==============
*/

void __fastcall SND_SetOcclusionFilterSingleIndex(int entchannel, int eqIndex, OccludeDef *occludeDef)
{
  ?SND_SetOcclusionFilterSingleIndex@@YAXHHPEAUOccludeDef@@@Z(entchannel, eqIndex, occludeDef);
}

/*
==============
SND_PlayContextSound
==============
*/

unsigned int __fastcall SND_PlayContextSound(const SndAliasList *aliasList, const int surfaceType, const int contextIndex, const int contextIndex2, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org)
{
  return ?SND_PlayContextSound@@YAIPEBUSndAliasList@@HHHW4LocalClientNum_t@@HMMAEBTvec3_t@@@Z(aliasList, surfaceType, contextIndex, contextIndex2, localClientNum, entnum, volumeScale, pitch, org);
}

/*
==============
CG_GeneratePredictedEntSndEntHandle
==============
*/

unsigned __int64 __fastcall CG_GeneratePredictedEntSndEntHandle(const LocalClientNum_t localClientNum, const int predictedEntIdx)
{
  return ?CG_GeneratePredictedEntSndEntHandle@@YA_KW4LocalClientNum_t@@H@Z(localClientNum, predictedEntIdx);
}

/*
==============
SND_SetTimeScaleLerp
==============
*/

void __fastcall SND_SetTimeScaleLerp(const int entchannel, const float lerp)
{
  ?SND_SetTimeScaleLerp@@YAXHM@Z(entchannel, lerp);
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  return ?SND_PlayScaledSoundAlias@@YAIPEBUSndAliasList@@W4LocalClientNum_t@@HMMAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasList, localClientNum, entnum, volumeScale, pitch, org, timeshift, system);
}

/*
==============
SND_HasFreeVoice
==============
*/

bool __fastcall SND_HasFreeVoice(unsigned int entchannel)
{
  return ?SND_HasFreeVoice@@YA_NI@Z(entchannel);
}

/*
==============
SND_SetMusicState
==============
*/

void __fastcall SND_SetMusicState(unsigned int stateId)
{
  ?SND_SetMusicState@@YAXI@Z(stateId);
}

/*
==============
SND_DebugAliasPrint
==============
*/

void __fastcall SND_DebugAliasPrint(bool condition, const SndAlias *alias, const char *msg)
{
  ?SND_DebugAliasPrint@@YAX_NPEBUSndAlias@@PEBD@Z(condition, alias, msg);
}

/*
==============
SND_SetEntContext
==============
*/

void __fastcall SND_SetEntContext(unsigned __int64 handle, unsigned int type, unsigned int value, float fadeTime)
{
  ?SND_SetEntContext@@YAX_KIIM@Z(handle, type, value, fadeTime);
}

/*
==============
SND_StartAliasOnVoiceIndex
==============
*/

unsigned int __fastcall SND_StartAliasOnVoiceIndex(SndStartAliasInfo *startAliasInfo, int index)
{
  return ?SND_StartAliasOnVoiceIndex@@YAIPEAUSndStartAliasInfo@@H@Z(startAliasInfo, index);
}

/*
==============
SND_GetDefaultHash
==============
*/

unsigned int __fastcall SND_GetDefaultHash()
{
  return ?SND_GetDefaultHash@@YAIXZ();
}

/*
==============
SND_DumpTimeScale_f
==============
*/

void __fastcall SND_DumpTimeScale_f()
{
  ?SND_DumpTimeScale_f@@YAXXZ();
}

/*
==============
SND_DeInitMemory
==============
*/

void SND_DeInitMemory(void)
{
  ?SND_DeInitMemory@@YAXXZ();
}

/*
==============
SND_FindFreeVoice
==============
*/

int __fastcall SND_FindFreeVoice(const SndStartAliasInfo *startAliasInfo, int entchannel, int startVoiceIndex, int voiceCount, SndAliasGroupTracking *inOutTracking)
{
  return ?SND_FindFreeVoice@@YAHPEBUSndStartAliasInfo@@HHHAEAUSndAliasGroupTracking@@@Z(startAliasInfo, entchannel, startVoiceIndex, voiceCount, inOutTracking);
}

/*
==============
SND_BankDetailStream_Debug
==============
*/

void __fastcall SND_BankDetailStream_Debug(LocalClientNum_t localClientNum)
{
  ?SND_BankDetailStream_Debug@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
SND_GetPlaybackChannels
==============
*/

unsigned int __fastcall SND_GetPlaybackChannels()
{
  return ?SND_GetPlaybackChannels@@YAIXZ();
}

/*
==============
SND_SetLevelFadeIn
==============
*/

void __fastcall SND_SetLevelFadeIn(float volume, int fadetime)
{
  ?SND_SetLevelFadeIn@@YAXMH@Z(volume, fadetime);
}

/*
==============
SND_StopSoundAliasById
==============
*/

bool __fastcall SND_StopSoundAliasById(unsigned int id)
{
  return ?SND_StopSoundAliasById@@YA_NI@Z(id);
}

/*
==============
SND_Restore
==============
*/

void __fastcall SND_Restore(MemoryFile *memFile)
{
  ?SND_Restore@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_IsListenerActive
==============
*/

bool __fastcall SND_IsListenerActive(const LocalClientNum_t localClientNum)
{
  return ?SND_IsListenerActive@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
SND_SaveEq
==============
*/

void __fastcall SND_SaveEq(MemoryFile *memFile)
{
  ?SND_SaveEq@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_InitParameter
==============
*/

void __fastcall SND_InitParameter(snd_param_info_t *paramInfo, float initValue)
{
  ?SND_InitParameter@@YAXPEAUsnd_param_info_t@@M@Z(paramInfo, initValue);
}

/*
==============
SND_IsVoiceFree
==============
*/

bool __fastcall SND_IsVoiceFree(int index)
{
  return ?SND_IsVoiceFree@@YA_NH@Z(index);
}

/*
==============
SND_GetAliasOffset
==============
*/

int __fastcall SND_GetAliasOffset(const SndAlias *alias)
{
  return ?SND_GetAliasOffset@@YAHPEBUSndAlias@@@Z(alias);
}

/*
==============
SND_DeactivateChannelVolumes
==============
*/

void __fastcall SND_DeactivateChannelVolumes(int priority, int fademsec)
{
  ?SND_DeactivateChannelVolumes@@YAXHH@Z(priority, fademsec);
}

/*
==============
SND_StopMusicState
==============
*/

void __fastcall SND_StopMusicState(const char *stateName)
{
  ?SND_StopMusicState@@YAXPEBD@Z(stateName);
}

/*
==============
SND_PlaySoundAlias
==============
*/

unsigned int __fastcall SND_PlaySoundAlias(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  return ?SND_PlaySoundAlias@@YAIPEBUSndAliasList@@W4LocalClientNum_t@@HAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasList, localClientNum, entNum, org, timeshift, system);
}

/*
==============
CG_GenerateScriptableSndEntHandle
==============
*/

unsigned __int64 __fastcall CG_GenerateScriptableSndEntHandle(const LocalClientNum_t localClientNum, const unsigned __int64 scriptableIndex)
{
  return ?CG_GenerateScriptableSndEntHandle@@YA_KW4LocalClientNum_t@@_K@Z(localClientNum, scriptableIndex);
}

/*
==============
SND_GetFarDryLevel
==============
*/

double __fastcall SND_GetFarDryLevel(const SndVoice *voice)
{
  double result; 

  *(float *)&result = ?SND_GetFarDryLevel@@YAMPEBUSndVoice@@@Z(voice);
  return result;
}

/*
==============
SND_GetEntChannelSendFlag
==============
*/

SndSendType __fastcall SND_GetEntChannelSendFlag(unsigned int entchannel)
{
  return ?SND_GetEntChannelSendFlag@@YA?AW4SndSendType@@I@Z(entchannel);
}

/*
==============
SND_AddWhizbyToBulletEvent
==============
*/

void __fastcall SND_AddWhizbyToBulletEvent(const int bulletEventId, const LocalClientNum_t localClientNum, const WeaponSFXPackage *sfxPackage, const vec3_t *inSndCenterPt, const vec3_t *inBulletDir, float radius, float shooterDist)
{
  ?SND_AddWhizbyToBulletEvent@@YAXHW4LocalClientNum_t@@PEBUWeaponSFXPackage@@AEBTvec3_t@@2MM@Z(bulletEventId, localClientNum, sfxPackage, inSndCenterPt, inBulletDir, radius, shooterDist);
}

/*
==============
SND_DriverPreUpdate
==============
*/

void __fastcall SND_DriverPreUpdate(int frametime)
{
  ?SND_DriverPreUpdate@@YAXH@Z(frametime);
}

/*
==============
SND_ReleasePhysicsQueryBlock
==============
*/

void SND_ReleasePhysicsQueryBlock(void)
{
  ?SND_ReleasePhysicsQueryBlock@@YAXXZ();
}

/*
==============
SND_AcquirePlaybackId
==============
*/

unsigned int __fastcall SND_AcquirePlaybackId(int index, int totalMsec)
{
  return ?SND_AcquirePlaybackId@@YAIHH@Z(index, totalMsec);
}

/*
==============
SND_SetFullResourcesMode
==============
*/

void SND_SetFullResourcesMode(void)
{
  ?SND_SetFullResourcesMode@@YAXXZ();
}

/*
==============
SND_InitDriver
==============
*/

bool __fastcall SND_InitDriver()
{
  return ?SND_InitDriver@@YA_NXZ();
}

/*
==============
SND_GetEntChannelSpeedOfSoundMultiplier
==============
*/

double __fastcall SND_GetEntChannelSpeedOfSoundMultiplier(unsigned int entchannel)
{
  double result; 

  *(float *)&result = ?SND_GetEntChannelSpeedOfSoundMultiplier@@YAMI@Z(entchannel);
  return result;
}

/*
==============
SND_PickSoundAliasFromList
==============
*/

void __fastcall SND_PickSoundAliasFromList(const SndAliasList *aliasList, const SndPlayParams *inParams, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp)
{
  ?SND_PickSoundAliasFromList@@YAXPEBUSndAliasList@@AEBUSndPlayParams@@PEAPEBUSndAlias@@2PEAM@Z(aliasList, inParams, outAliasA, outAliasB, outLerp);
}

/*
==============
SND_AnyEqEnabledOnVoice
==============
*/

bool __fastcall SND_AnyEqEnabledOnVoice(int voiceIndex)
{
  return ?SND_AnyEqEnabledOnVoice@@YA_NH@Z(voiceIndex);
}

/*
==============
SND_FindEntState
==============
*/

SndEntState *__fastcall SND_FindEntState(unsigned __int64 handle, bool createNew)
{
  return ?SND_FindEntState@@YAPEAUSndEntState@@_K_N@Z(handle, createNew);
}

/*
==============
SND_ShutdownDriver
==============
*/

void SND_ShutdownDriver(void)
{
  ?SND_ShutdownDriver@@YAXXZ();
}

/*
==============
SND_PlayLocalSoundAliasAsync
==============
*/

void __fastcall SND_PlayLocalSoundAliasAsync(LocalClientNum_t localClientNum, const char *aliasname, snd_alias_system_t system)
{
  ?SND_PlayLocalSoundAliasAsync@@YAXW4LocalClientNum_t@@PEBDW4snd_alias_system_t@@@Z(localClientNum, aliasname, system);
}

/*
==============
SND_PlayLocalSoundAlias
==============
*/

unsigned int __fastcall SND_PlayLocalSoundAlias(LocalClientNum_t localClientNum, const SndAliasList *aliasList, snd_alias_system_t system)
{
  return ?SND_PlayLocalSoundAlias@@YAIW4LocalClientNum_t@@PEBUSndAliasList@@W4snd_alias_system_t@@@Z(localClientNum, aliasList, system);
}

/*
==============
SND_EnablePASpeaker
==============
*/

void __fastcall SND_EnablePASpeaker(unsigned int nameHash, bool enable)
{
  ?SND_EnablePASpeaker@@YAXI_N@Z(nameHash, enable);
}

/*
==============
SND_GetVolModByIndex
==============
*/

const snd_volmod_info_t *__fastcall SND_GetVolModByIndex(unsigned int volmodIndex)
{
  return ?SND_GetVolModByIndex@@YAPEBUsnd_volmod_info_t@@I@Z(volmodIndex);
}

/*
==============
SND_GetAliasWithOffset
==============
*/

SndAlias *__fastcall SND_GetAliasWithOffset(const char *name, int offset)
{
  return ?SND_GetAliasWithOffset@@YAPEAUSndAlias@@PEBDH@Z(name, offset);
}

/*
==============
SND_PerformOcclusionTrace
==============
*/

double __fastcall SND_PerformOcclusionTrace(const vec3_t *listener, const vec3_t *emitter, const LocalClientNum_t localClientNum, const unsigned __int64 sndEnt, unsigned int id)
{
  double result; 

  *(float *)&result = ?SND_PerformOcclusionTrace@@YAMAEBTvec3_t@@0W4LocalClientNum_t@@_KI@Z(listener, emitter, localClientNum, sndEnt, id);
  return result;
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/

int __fastcall SND_PlayVirtualLoopSound(const SndAliasList *aliasList, const unsigned __int64 sndEnt, const vec3_t *org, const float volume, const float pitch)
{
  return ?SND_PlayVirtualLoopSound@@YAHPEBUSndAliasList@@_KAEBTvec3_t@@MM@Z(aliasList, sndEnt, org, volume, pitch);
}

/*
==============
SND_PlaySoundAliasCore
==============
*/

unsigned int __fastcall SND_PlaySoundAliasCore(const SndAlias *alias, float contextLerp, const SndPlayParams *inParams, SndAliasGroupTracking *inOutTracking)
{
  return ?SND_PlaySoundAliasCore@@YAIPEBUSndAlias@@MAEBUSndPlayParams@@AEAUSndAliasGroupTracking@@@Z(alias, contextLerp, inParams, inOutTracking);
}

/*
==============
EntityDebugDrawOffset::GetOffset
==============
*/

int __fastcall EntityDebugDrawOffset::GetOffset(EntityDebugDrawOffset *this, unsigned __int64 entIndex)
{
  return ?GetOffset@EntityDebugDrawOffset@@QEBAH_K@Z(this, entIndex);
}

/*
==============
SND_UpdateParameter
==============
*/

void __fastcall SND_UpdateParameter(snd_param_info_t *paramInfo, int dt_msec, bool nonLinear)
{
  ?SND_UpdateParameter@@YAXPEAUsnd_param_info_t@@H_N@Z(paramInfo, dt_msec, nonLinear);
}

/*
==============
SND_UnpauseVoiceThatWasStartedPaused
==============
*/

void __fastcall SND_UnpauseVoiceThatWasStartedPaused(int index)
{
  ?SND_UnpauseVoiceThatWasStartedPaused@@YAXH@Z(index);
}

/*
==============
SND_PlayAmbientAlias
==============
*/

void __fastcall SND_PlayAmbientAlias(LocalClientNum_t localClientNum, const char *aliasName, float volumeScale, int fadeTime, bool isExclusive, snd_alias_system_t system)
{
  ?SND_PlayAmbientAlias@@YAXW4LocalClientNum_t@@PEBDMH_NW4snd_alias_system_t@@@Z(localClientNum, aliasName, volumeScale, fadeTime, isExclusive, system);
}

/*
==============
SND_StopVoiceById
==============
*/

void __fastcall SND_StopVoiceById(unsigned int id)
{
  ?SND_StopVoiceById@@YAXI@Z(id);
}

/*
==============
SND_Init
==============
*/

void SND_Init(void)
{
  ?SND_Init@@YAXXZ();
}

/*
==============
SND_DevUpdateReverbParams
==============
*/

void __fastcall SND_DevUpdateReverbParams(const unsigned int id)
{
  ?SND_DevUpdateReverbParams@@YAXI@Z(id);
}

/*
==============
SND_PlayBlendedSoundAliasAsync
==============
*/

void __fastcall SND_PlayBlendedSoundAliasAsync(const SndAliasList *aliasList0, const SndAliasList *aliasList1, const float lerp, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  ?SND_PlayBlendedSoundAliasAsync@@YAXPEBUSndAliasList@@0MW4LocalClientNum_t@@HMMAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasList0, aliasList1, lerp, localClientNum, entnum, volumeScale, pitch, org, timeshift, system);
}

/*
==============
SND_SetReverbParams
==============
*/

void __fastcall SND_SetReverbParams(const unsigned int id, ReverbDescriptor index, bool fadeOut)
{
  ?SND_SetReverbParams@@YAXIW4ReverbDescriptor@@_N@Z(id, index, fadeOut);
}

/*
==============
SND_AddSoundDoneNotify
==============
*/

void __fastcall SND_AddSoundDoneNotify(unsigned int playbackId, int entNum, unsigned __int16 soundString)
{
  ?SND_AddSoundDoneNotify@@YAXIHG@Z(playbackId, entNum, soundString);
}

/*
==============
SND_ClearAllOcclusionSettings
==============
*/

void SND_ClearAllOcclusionSettings(void)
{
  ?SND_ClearAllOcclusionSettings@@YAXXZ();
}

/*
==============
SND_AddVoice
==============
*/

void __fastcall SND_AddVoice(unsigned int entchannel)
{
  ?SND_AddVoice@@YAXI@Z(entchannel);
}

/*
==============
SND_GetEntChannelSubmixBus
==============
*/

SndBus __fastcall SND_GetEntChannelSubmixBus(unsigned int entchannel)
{
  return ?SND_GetEntChannelSubmixBus@@YA?AW4SndBus@@I@Z(entchannel);
}

/*
==============
SND_DoTracesWithDebug
==============
*/

void __fastcall SND_DoTracesWithDebug(SndVoice *voice)
{
  ?SND_DoTracesWithDebug@@YAXPEAUSndVoice@@@Z(voice);
}

/*
==============
SND_IsVoice3D
==============
*/

bool __fastcall SND_IsVoice3D(unsigned int voiceIndex)
{
  return ?SND_IsVoice3D@@YA_NI@Z(voiceIndex);
}

/*
==============
SND_StopVoiceWithoutLock
==============
*/

void __fastcall SND_StopVoiceWithoutLock(int index)
{
  ?SND_StopVoiceWithoutLock@@YAXH@Z(index);
}

/*
==============
Com_GetSpeakerLevels
==============
*/

const float *__fastcall Com_GetSpeakerLevels(const SpeakerMap *speakerMap, int sourceChannelCount, int *outSpeakermapChannelCount)
{
  return ?Com_GetSpeakerLevels@@YAPEBMPEBUSpeakerMap@@HAEAH@Z(speakerMap, sourceChannelCount, outSpeakermapChannelCount);
}

/*
==============
SND_GetEntChannelFromName
==============
*/

unsigned int __fastcall SND_GetEntChannelFromName(const char *channelName)
{
  return ?SND_GetEntChannelFromName@@YAIPEBD@Z(channelName);
}

/*
==============
SND_GetStreamIoActive
==============
*/

int __fastcall SND_GetStreamIoActive()
{
  return ?SND_GetStreamIoActive@@YA?CJXZ();
}

/*
==============
SND_GetCurrentReverb
==============
*/

unsigned int __fastcall SND_GetCurrentReverb()
{
  return ?SND_GetCurrentReverb@@YAIXZ();
}

/*
==============
SND_IsEntChannelPASpeaker
==============
*/

bool __fastcall SND_IsEntChannelPASpeaker(unsigned int entchannel)
{
  return ?SND_IsEntChannelPASpeaker@@YA_NI@Z(entchannel);
}

/*
==============
SND_GetVolume
==============
*/

double __fastcall SND_GetVolume()
{
  double result; 

  *(float *)&result = ?SND_GetVolume@@YAMXZ();
  return result;
}

/*
==============
SND_PickSoundAliasFromList
==============
*/

void __fastcall SND_PickSoundAliasFromList(const SndAliasList *aliasList, const SndPlayParams *inParams, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp, const unsigned int specType1, const unsigned int specValue1, const unsigned int specType2, const unsigned int specValue2)
{
  ?SND_PickSoundAliasFromList@@YAXPEBUSndAliasList@@AEBUSndPlayParams@@PEAPEBUSndAlias@@2PEAMIIII@Z(aliasList, inParams, outAliasA, outAliasB, outLerp, specType1, specValue1, specType2, specValue2);
}

/*
==============
SND_DistSqToNearestListener
==============
*/

double __fastcall SND_DistSqToNearestListener(const vec3_t *origin)
{
  double result; 

  *(float *)&result = ?SND_DistSqToNearestListener@@YAMAEBTvec3_t@@@Z(origin);
  return result;
}

/*
==============
SND_DeactivateEq
==============
*/

void __fastcall SND_DeactivateEq(const char *channelName, int eqIndex, int band)
{
  ?SND_DeactivateEq@@YAXPEBDHH@Z(channelName, eqIndex, band);
}

/*
==============
SND_DisableOcclusion
==============
*/

void __fastcall SND_DisableOcclusion(int entchannel, int eqIndex)
{
  ?SND_DisableOcclusion@@YAXHH@Z(entchannel, eqIndex);
}

/*
==============
SND_SetPlaybackIdNotPlayed
==============
*/

unsigned int __fastcall SND_SetPlaybackIdNotPlayed(int index)
{
  return ?SND_SetPlaybackIdNotPlayed@@YAIH@Z(index);
}

/*
==============
SND_CalcAndAlignDesiredSampleIndex
==============
*/

int __fastcall SND_CalcAndAlignDesiredSampleIndex(const int startMsec, const int sampleCount, const int sampleRate)
{
  return ?SND_CalcAndAlignDesiredSampleIndex@@YAHHHH@Z(startMsec, sampleCount, sampleRate);
}

/*
==============
SND_StopMusicState
==============
*/

void __fastcall SND_StopMusicState(const unsigned int *stateIdArray, unsigned int arrayCount)
{
  ?SND_StopMusicState@@YAXPEBII@Z(stateIdArray, arrayCount);
}

/*
==============
SND_RestoreVoiceIndex
==============
*/

int __fastcall SND_RestoreVoiceIndex(MemoryFile *memFile)
{
  return ?SND_RestoreVoiceIndex@@YAHPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_SetContext
==============
*/

void __fastcall SND_SetContext(unsigned int type, unsigned int value, float fadeTime)
{
  ?SND_SetContext@@YAXIIM@Z(type, value, fadeTime);
}

/*
==============
SND_GetEntChannelName
==============
*/

const char *__fastcall SND_GetEntChannelName(unsigned int entchannel)
{
  return ?SND_GetEntChannelName@@YAPEBDI@Z(entchannel);
}

/*
==============
SND_AttenuateHPF
==============
*/

double __fastcall SND_AttenuateHPF(float currentValue, float attenuation)
{
  double result; 

  *(float *)&result = ?SND_AttenuateHPF@@YAMMM@Z(currentValue, attenuation);
  return result;
}

/*
==============
SND_FinalizeAliasGroupTracking
==============
*/

void __fastcall SND_FinalizeAliasGroupTracking(SndAliasGroupTracking *inOutTracking)
{
  ?SND_FinalizeAliasGroupTracking@@YAXAEAUSndAliasGroupTracking@@@Z(inOutTracking);
}

/*
==============
SND_SetChannelVolumes
==============
*/

void __fastcall SND_SetChannelVolumes(int priority, const float *channelvolume, int fademsec)
{
  ?SND_SetChannelVolumes@@YAXHQEBMH@Z(priority, channelvolume, fademsec);
}

/*
==============
SND_VoiceSetStopSync
==============
*/

void __fastcall SND_VoiceSetStopSync(SndVoice *voice, bool stopSync, int delayBeats, int fadeBeats)
{
  ?SND_VoiceSetStopSync@@YAXPEAUSndVoice@@_NHH@Z(voice, stopSync, delayBeats, fadeBeats);
}

/*
==============
SND_VoiceUpdateWorker
==============
*/

void __fastcall SND_VoiceUpdateWorker(const void *const cmdInfo)
{
  ?SND_VoiceUpdateWorker@@YAXQEBX@Z(cmdInfo);
}

/*
==============
CG_GenerateClothSndEntHandle
==============
*/

unsigned __int64 __fastcall CG_GenerateClothSndEntHandle(const LocalClientNum_t localClientNum, const int clothSoundIndex)
{
  return ?CG_GenerateClothSndEntHandle@@YA_KW4LocalClientNum_t@@H@Z(localClientNum, clothSoundIndex);
}

/*
==============
SND_SetEqFreq
==============
*/

void __fastcall SND_SetEqFreq(int entchannel, int eqIndex, int band, float freq)
{
  ?SND_SetEqFreq@@YAXHHHM@Z(entchannel, eqIndex, band, freq);
}

/*
==============
SND_SetEqEntChannel
==============
*/

void __fastcall SND_SetEqEntChannel(int entChannel, int eqIndex, int band, SND_EQTYPE type, float gain, float freq, float q)
{
  ?SND_SetEqEntChannel@@YAXHHHW4SND_EQTYPE@@MMM@Z(entChannel, eqIndex, band, type, gain, freq, q);
}

/*
==============
SND_GetSndCurveValue
==============
*/

double __fastcall SND_GetSndCurveValue(const int knotCount, const vec2_t *knots, const float fraction)
{
  double result; 

  *(float *)&result = ?SND_GetSndCurveValue@@YAMHPEBTvec2_t@@M@Z(knotCount, knots, fraction);
  return result;
}

/*
==============
SND_IsPausable
==============
*/

bool __fastcall SND_IsPausable(unsigned int entchannel)
{
  return ?SND_IsPausable@@YA_NI@Z(entchannel);
}

/*
==============
SND_GetMasterPriorityID
==============
*/

unsigned __int8 __fastcall SND_GetMasterPriorityID(const SndVoice *voice)
{
  return ?SND_GetMasterPriorityID@@YAEPEBUSndVoice@@@Z(voice);
}

/*
==============
SND_IsEntChannelPlayerDialogue
==============
*/

bool __fastcall SND_IsEntChannelPlayerDialogue(unsigned int entchannel)
{
  return ?SND_IsEntChannelPlayerDialogue@@YA_NI@Z(entchannel);
}

/*
==============
SND_SetMainReverb
==============
*/

void __fastcall SND_SetMainReverb(const ReverbDef *reverbDef)
{
  ?SND_SetMainReverb@@YAXPEBUReverbDef@@@Z(reverbDef);
}

/*
==============
SND_SyncAmbientTracks
==============
*/

int __fastcall SND_SyncAmbientTracks(int index)
{
  return ?SND_SyncAmbientTracks@@YAHH@Z(index);
}

/*
==============
FindDominantContextType
==============
*/

bool __fastcall FindDominantContextType(const unsigned int contextType, const ZoneDef *zoneA, const ZoneDef *zoneB, const float zoneLerp, const SndEntState *entState, unsigned int *outContextValueA, unsigned int *outContextValueB, float *outLerp)
{
  return ?FindDominantContextType@@YA_NIPEBUZoneDef@@0MPEBUSndEntState@@PEAI2PEAM@Z(contextType, zoneA, zoneB, zoneLerp, entState, outContextValueA, outContextValueB, outLerp);
}

/*
==============
SND_GetSoundOverlay
==============
*/

int __fastcall SND_GetSoundOverlay(snd_overlay_info_t *info, int maxcount, int *cpu)
{
  return ?SND_GetSoundOverlay@@YAHQEAUsnd_overlay_info_t@@HPEAH@Z(info, maxcount, cpu);
}

/*
==============
SND_SetWorldPosition
==============
*/

bool __fastcall SND_SetWorldPosition(unsigned int id, const vec3_t *origin)
{
  return ?SND_SetWorldPosition@@YA_NIAEBTvec3_t@@@Z(id, origin);
}

/*
==============
SND_GetAliasEntChannelId
==============
*/

unsigned int __fastcall SND_GetAliasEntChannelId(const SndAlias *alias)
{
  return ?SND_GetAliasEntChannelId@@YAIPEBUSndAlias@@@Z(alias);
}

/*
==============
SND_PlaySoundAlias
==============
*/

unsigned int __fastcall SND_PlaySoundAlias(const char *aliasName, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  return ?SND_PlaySoundAlias@@YAIPEBDW4LocalClientNum_t@@HAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasName, localClientNum, entNum, org, timeshift, system);
}

/*
==============
SND_IsEntChannel3D
==============
*/

bool __fastcall SND_IsEntChannel3D(unsigned int entchannel)
{
  return ?SND_IsEntChannel3D@@YA_NI@Z(entchannel);
}

/*
==============
SND_SetEqGain
==============
*/

void __fastcall SND_SetEqGain(int entchannel, int eqIndex, int band, float gain)
{
  ?SND_SetEqGain@@YAXHHHM@Z(entchannel, eqIndex, band, gain);
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const SndAliasList *aliasList, const unsigned __int64 sndEnt, const float volumeScale, const float pitch, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  return ?SND_PlayScaledSoundAlias@@YAIPEBUSndAliasList@@_KMMAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasList, sndEnt, volumeScale, pitch, org, timeshift, system);
}

/*
==============
SND_FrameUpdateVirtualLoopSounds
==============
*/

void SND_FrameUpdateVirtualLoopSounds(void)
{
  ?SND_FrameUpdateVirtualLoopSounds@@YAXXZ();
}

/*
==============
SND_FadeAllSounds
==============
*/

void __fastcall SND_FadeAllSounds(float volume, int fadetime)
{
  ?SND_FadeAllSounds@@YAXMH@Z(volume, fadetime);
}

/*
==============
SND_RecalcChaninfoPriority
==============
*/

void __fastcall SND_RecalcChaninfoPriority(int index)
{
  ?SND_RecalcChaninfoPriority@@YAXH@Z(index);
}

/*
==============
SND_PlayExplosionSoundAsync
==============
*/

void __fastcall SND_PlayExplosionSoundAsync(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, const vec3_t *org, const unsigned int reflectionClass)
{
  ?SND_PlayExplosionSoundAsync@@YAXPEBUSndAliasList@@H_KAEBTvec3_t@@I@Z(aliasList, surfaceType, sndEnt, org, reflectionClass);
}

/*
==============
SND_PlayLocalSoundAliasAsync
==============
*/

void __fastcall SND_PlayLocalSoundAliasAsync(LocalClientNum_t localClientNum, const SndAliasList *aliasList, snd_alias_system_t system)
{
  ?SND_PlayLocalSoundAliasAsync@@YAXW4LocalClientNum_t@@PEBUSndAliasList@@W4snd_alias_system_t@@@Z(localClientNum, aliasList, system);
}

/*
==============
SND_SetChannelVolume
==============
*/

void __fastcall SND_SetChannelVolume(unsigned int channel, float channelvolume, int fademsec)
{
  ?SND_SetChannelVolume@@YAXIMH@Z(channel, channelvolume, fademsec);
}

/*
==============
SND_GetHDMIChannelCount
==============
*/

unsigned int __fastcall SND_GetHDMIChannelCount()
{
  return ?SND_GetHDMIChannelCount@@YAIXZ();
}

/*
==============
SND_PlayBlendedSoundAlias
==============
*/

unsigned int __fastcall SND_PlayBlendedSoundAlias(const SndAliasList *aliasList0, const SndAliasList *aliasList1, const float lerp, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  return ?SND_PlayBlendedSoundAlias@@YAIPEBUSndAliasList@@0MW4LocalClientNum_t@@HMMAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasList0, aliasList1, lerp, localClientNum, entnum, volumeScale, pitch, org, timeshift, system);
}

/*
==============
SND_GetSoundEqOverlay
==============
*/

int __fastcall SND_GetSoundEqOverlay(snd_eqoverlay_info_t *info, unsigned int maxcount)
{
  return ?SND_GetSoundEqOverlay@@YAHQEAUsnd_eqoverlay_info_t@@I@Z(info, maxcount);
}

/*
==============
CG_GenerateSndEntHandle
==============
*/

unsigned __int64 __fastcall CG_GenerateSndEntHandle(const LocalClientNum_t localClientNum, const int entIndex)
{
  return ?CG_GenerateSndEntHandle@@YA_KW4LocalClientNum_t@@H@Z(localClientNum, entIndex);
}

/*
==============
SND_StopAmbient
==============
*/

void __fastcall SND_StopAmbient(int fadetime)
{
  ?SND_StopAmbient@@YAXH@Z(fadetime);
}

/*
==============
SND_PlayScaledSoundAliasAsync
==============
*/

void __fastcall SND_PlayScaledSoundAliasAsync(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  ?SND_PlayScaledSoundAliasAsync@@YAXPEBUSndAliasList@@W4LocalClientNum_t@@HMMAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasList, localClientNum, entnum, volumeScale, pitch, org, timeshift, system);
}

/*
==============
SND_SetVoiceStartInfo
==============
*/

void __fastcall SND_SetVoiceStartInfo(int index, const SndStartAliasInfo *startInfo)
{
  ?SND_SetVoiceStartInfo@@YAXHPEBUSndStartAliasInfo@@@Z(index, startInfo);
}

/*
==============
SND_DisconnectListener
==============
*/

void __fastcall SND_DisconnectListener(LocalClientNum_t localClientNum)
{
  ?SND_DisconnectListener@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
SND_GetFarWetLevel
==============
*/

double __fastcall SND_GetFarWetLevel(const SndVoice *voice)
{
  double result; 

  *(float *)&result = ?SND_GetFarWetLevel@@YAMPEBUSndVoice@@@Z(voice);
  return result;
}

/*
==============
SND_GetCurrentGlobalContext
==============
*/

bool __fastcall SND_GetCurrentGlobalContext(unsigned int type, unsigned int *outValueA, unsigned int *outValueB, float *outLerp)
{
  return ?SND_GetCurrentGlobalContext@@YA_NIPEAI0PEAM@Z(type, outValueA, outValueB, outLerp);
}

/*
==============
SND_StartBulletEvent
==============
*/

void __fastcall SND_StartBulletEvent(int id)
{
  ?SND_StartBulletEvent@@YAXH@Z(id);
}

/*
==============
SND_GetNewBulletEvent
==============
*/

int __fastcall SND_GetNewBulletEvent()
{
  return ?SND_GetNewBulletEvent@@YAHXZ();
}

/*
==============
SND_PlayWeaponSound
==============
*/

void __fastcall SND_PlayWeaponSound(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, const Weapon *weapon, const bool isAlternate, const bool isPlayer, const int autoSimId, const __int64 autoSimTimeStamp, const float autoSimDistSq, const SndWeapShotCountId shotCount, const bool isProne, const bool isDualWield, const PlayerHandIndex hand, const bool isHyperBurstSound)
{
  ?SND_PlayWeaponSound@@YAXPEBUSndAliasList@@W4LocalClientNum_t@@HAEBTvec3_t@@AEBUWeapon@@_N4H_JMW4SndWeapShotCountId@@44W4PlayerHandIndex@@4@Z(aliasList, localClientNum, entNum, org, weapon, isAlternate, isPlayer, autoSimId, autoSimTimeStamp, autoSimDistSq, shotCount, isProne, isDualWield, hand, isHyperBurstSound);
}

/*
==============
CG_GeneratePhysicsSndEntHandle
==============
*/

unsigned __int64 __fastcall CG_GeneratePhysicsSndEntHandle(const LocalClientNum_t localClientNum, const unsigned __int8 worldId, const bool isRagdoll, const unsigned int bodyId)
{
  return ?CG_GeneratePhysicsSndEntHandle@@YA_KW4LocalClientNum_t@@E_NI@Z(localClientNum, worldId, isRagdoll, bodyId);
}

/*
==============
SND_SetWorldPosition
==============
*/

bool __fastcall SND_SetWorldPosition(unsigned int id, const vec3_t *origin, unsigned __int64 sndEnt)
{
  return ?SND_SetWorldPosition@@YA_NIAEBTvec3_t@@_K@Z(id, origin, sndEnt);
}

/*
==============
SND_StopSounds
==============
*/

void __fastcall SND_StopSounds(snd_stopsounds_arg_t which)
{
  ?SND_StopSounds@@YAXW4snd_stopsounds_arg_t@@@Z(which);
}

/*
==============
SND_AttenuateLPF
==============
*/

double __fastcall SND_AttenuateLPF(float currentValue, float attenuation)
{
  double result; 

  *(float *)&result = ?SND_AttenuateLPF@@YAMMM@Z(currentValue, attenuation);
  return result;
}

/*
==============
SND_RestoreEntityParamInfo
==============
*/

void __fastcall SND_RestoreEntityParamInfo(MemoryFile *memFile)
{
  ?SND_RestoreEntityParamInfo@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_StopSoundAliasOnEnt
==============
*/

void __fastcall SND_StopSoundAliasOnEnt(unsigned __int64 sndEnt, const char *aliasName)
{
  ?SND_StopSoundAliasOnEnt@@YAX_KPEBD@Z(sndEnt, aliasName);
}

/*
==============
SND_UpdateVirtualLoopSound
==============
*/

bool __fastcall SND_UpdateVirtualLoopSound(int handle, const vec3_t *org, float volume, float pitch)
{
  return ?SND_UpdateVirtualLoopSound@@YA_NHAEBTvec3_t@@MM@Z(handle, org, volume, pitch);
}

/*
==============
SND_Update
==============
*/

void SND_Update(void)
{
  ?SND_Update@@YAXXZ();
}

/*
==============
SND_SetUIPause
==============
*/

void __fastcall SND_SetUIPause(bool paused)
{
  ?SND_SetUIPause@@YAX_N@Z(paused);
}

/*
==============
SND_PlayLocalSoundAlias
==============
*/

unsigned int __fastcall SND_PlayLocalSoundAlias(LocalClientNum_t localClientNum, const char *aliasname, snd_alias_system_t system)
{
  return ?SND_PlayLocalSoundAlias@@YAIW4LocalClientNum_t@@PEBDW4snd_alias_system_t@@@Z(localClientNum, aliasname, system);
}

/*
==============
Com_GetSoundAliasSeed
==============
*/

int __fastcall Com_GetSoundAliasSeed()
{
  return ?Com_GetSoundAliasSeed@@YAHXZ();
}

/*
==============
CG_GenerateParticleSndEntHandle
==============
*/

unsigned __int64 __fastcall CG_GenerateParticleSndEntHandle(const LocalClientNum_t localClientNum, const int particleSoundIndex)
{
  return ?CG_GenerateParticleSndEntHandle@@YA_KW4LocalClientNum_t@@H@Z(localClientNum, particleSoundIndex);
}

/*
==============
EntityDebugDrawOffset::SetOffset
==============
*/

void __fastcall EntityDebugDrawOffset::SetOffset(EntityDebugDrawOffset *this, unsigned __int64 entIndex, int offset)
{
  ?SetOffset@EntityDebugDrawOffset@@QEAAX_KH@Z(this, entIndex, offset);
}

/*
==============
SND_SaveEntityParamInfo
==============
*/

void __fastcall SND_SaveEntityParamInfo(MemoryFile *memFile)
{
  ?SND_SaveEntityParamInfo@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_StopVirtualLoopSound
==============
*/

void __fastcall SND_StopVirtualLoopSound(int handle)
{
  ?SND_StopVirtualLoopSound@@YAXH@Z(handle);
}

/*
==============
SND_IsPlaybackIdPlaying
==============
*/

bool __fastcall SND_IsPlaybackIdPlaying(unsigned int id)
{
  return ?SND_IsPlaybackIdPlaying@@YA_NI@Z(id);
}

/*
==============
SND_GetMasterPriorityVal
==============
*/

double __fastcall SND_GetMasterPriorityVal(SndVoice *voice)
{
  double result; 

  *(float *)&result = ?SND_GetMasterPriorityVal@@YAMPEAUSndVoice@@@Z(voice);
  return result;
}

/*
==============
SND_GetListener
==============
*/

void __fastcall SND_GetListener(const LocalClientNum_t localClientNum, snd_listener *outListener)
{
  ?SND_GetListener@@YAXW4LocalClientNum_t@@AEAUsnd_listener@@@Z(localClientNum, outListener);
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/

int __fastcall SND_PlayVirtualLoopSound(const char *aliasName, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, float volume, float pitch)
{
  return ?SND_PlayVirtualLoopSound@@YAHPEBDW4LocalClientNum_t@@HAEBTvec3_t@@MM@Z(aliasName, localClientNum, entNum, org, volume, pitch);
}

/*
==============
SND_AddPlayFXSoundAlias
==============
*/

void __fastcall SND_AddPlayFXSoundAlias(unsigned int aliasId, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *origin)
{
  ?SND_AddPlayFXSoundAlias@@YAXIW4LocalClientNum_t@@HAEBTvec3_t@@@Z(aliasId, localClientNum, entNum, origin);
}

/*
==============
SND_GetPriority
==============
*/

int __fastcall SND_GetPriority(unsigned int entchannel)
{
  return ?SND_GetPriority@@YAHI@Z(entchannel);
}

/*
==============
SND_RemoveClipMap
==============
*/

void __fastcall SND_RemoveClipMap(clipMap_t *__formal)
{
  ?SND_RemoveClipMap@@YAXPEAUclipMap_t@@@Z(__formal);
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/

int __fastcall SND_PlayVirtualLoopSound(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, float volume, float pitch)
{
  return ?SND_PlayVirtualLoopSound@@YAHPEBUSndAliasList@@W4LocalClientNum_t@@HAEBTvec3_t@@MM@Z(aliasList, localClientNum, entNum, org, volume, pitch);
}

/*
==============
SND_DeactivateAllFilters
==============
*/

void SND_DeactivateAllFilters(void)
{
  ?SND_DeactivateAllFilters@@YAXXZ();
}

/*
==============
SND_PlayVirtualLoopSoundFollowEntity
==============
*/

int __fastcall SND_PlayVirtualLoopSoundFollowEntity(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, float volume, float pitch)
{
  return ?SND_PlayVirtualLoopSoundFollowEntity@@YAHPEBUSndAliasList@@W4LocalClientNum_t@@HAEBTvec3_t@@MM@Z(aliasList, localClientNum, entNum, org, volume, pitch);
}

/*
==============
SND_InitMemory
==============
*/

void SND_InitMemory(void)
{
  ?SND_InitMemory@@YAXXZ();
}

/*
==============
SND_EndFrame
==============
*/

void SND_EndFrame(void)
{
  ?SND_EndFrame@@YAXXZ();
}

/*
==============
SND_ClearMainReverb
==============
*/

void __fastcall SND_ClearMainReverb(const float fadetime)
{
  ?SND_ClearMainReverb@@YAXM@Z(fadetime);
}

/*
==============
SND_CalcVoicePitch
==============
*/

double __fastcall SND_CalcVoicePitch(const int frametime, SndVoice *voice)
{
  double result; 

  *(float *)&result = ?SND_CalcVoicePitch@@YAMHPEAUSndVoice@@@Z(frametime, voice);
  return result;
}

/*
==============
SND_InitFXSounds
==============
*/

void SND_InitFXSounds(void)
{
  ?SND_InitFXSounds@@YAXXZ();
}

/*
==============
SND_GetNearestListenerOrigin
==============
*/

void __fastcall SND_GetNearestListenerOrigin(const vec3_t *origin, vec3_t *outListenerOrigin)
{
  ?SND_GetNearestListenerOrigin@@YAXAEBTvec3_t@@AEAT1@@Z(origin, outListenerOrigin);
}

/*
==============
SND_ClearReverbs
==============
*/

void SND_ClearReverbs(void)
{
  ?SND_ClearReverbs@@YAXXZ();
}

/*
==============
SND_SaveVoiceIndex
==============
*/

void __fastcall SND_SaveVoiceIndex(MemoryFile *memFile, const SndVoice *voice)
{
  ?SND_SaveVoiceIndex@@YAXPEAUMemoryFile@@PEBUSndVoice@@@Z(memFile, voice);
}

/*
==============
SND_Get3DDistanceAttenuation
==============
*/

double __fastcall SND_Get3DDistanceAttenuation(const vec3_t *soundOrigin, const SndCurve *curve, float distMin, float distMax, float distanceScale)
{
  double result; 

  *(float *)&result = ?SND_Get3DDistanceAttenuation@@YAMAEBTvec3_t@@PEBUSndCurve@@MMM@Z(soundOrigin, curve, distMin, distMax, distanceScale);
  return result;
}

/*
==============
SND_GetEqTypeFromName
==============
*/

SND_EQTYPE __fastcall SND_GetEqTypeFromName(const char *eqTypeName)
{
  return ?SND_GetEqTypeFromName@@YA?AW4SND_EQTYPE@@PEBD@Z(eqTypeName);
}

/*
==============
SND_ResetCanDoPhysicsQuery
==============
*/

void SND_ResetCanDoPhysicsQuery(void)
{
  ?SND_ResetCanDoPhysicsQuery@@YAXXZ();
}

/*
==============
SND_Reset
==============
*/

void __fastcall SND_Reset(bool restart)
{
  ?SND_Reset@@YAX_N@Z(restart);
}

/*
==============
SND_SetTimeLerp
==============
*/

void __fastcall SND_SetTimeLerp(TimeLerp *lerp, float time)
{
  ?SND_SetTimeLerp@@YAXPEAUTimeLerp@@M@Z(lerp, time);
}

/*
==============
SND_SetConstrainedMode
==============
*/

void SND_SetConstrainedMode(void)
{
  ?SND_SetConstrainedMode@@YAXXZ();
}

/*
==============
SND_UpdateVehicle
==============
*/

void __fastcall SND_UpdateVehicle(const SndAliasList *aliasList, LocalClientNum_t localClientNum, int entNum, vec3_t *origin, float throttle, float brake, float rpm, float velocity, int gear, float distanceScale)
{
  ?SND_UpdateVehicle@@YAXPEBUSndAliasList@@W4LocalClientNum_t@@HTvec3_t@@MMMMHM@Z(aliasList, localClientNum, entNum, origin, throttle, brake, rpm, velocity, gear, distanceScale);
}

/*
==============
SND_SoloChannel_f
==============
*/

void __fastcall SND_SoloChannel_f()
{
  ?SND_SoloChannel_f@@YAXXZ();
}

/*
==============
SND_GetPerkIndexFromName
==============
*/

unsigned int __fastcall SND_GetPerkIndexFromName(const char *name)
{
  return ?SND_GetPerkIndexFromName@@YAIPEBD@Z(name);
}

/*
==============
SND_DisableEq
==============
*/

void __fastcall SND_DisableEq(int entchannel, int eqIndex, int band)
{
  ?SND_DisableEq@@YAXHHH@Z(entchannel, eqIndex, band);
}

/*
==============
SND_GetEntChannelCount
==============
*/

unsigned int __fastcall SND_GetEntChannelCount()
{
  return ?SND_GetEntChannelCount@@YAIXZ();
}

/*
==============
Com_SetSoundAliasSeed
==============
*/

void __fastcall Com_SetSoundAliasSeed(int seed)
{
  ?Com_SetSoundAliasSeed@@YAXH@Z(seed);
}

/*
==============
SND_ClearDrawOnlyChannel_f
==============
*/

void __fastcall SND_ClearDrawOnlyChannel_f()
{
  ?SND_ClearDrawOnlyChannel_f@@YAXXZ();
}

/*
==============
SND_SetMusicState
==============
*/

void __fastcall SND_SetMusicState(unsigned int stateId, const unsigned int *assetIdPlaylist, unsigned int assetIdCount)
{
  ?SND_SetMusicState@@YAXIPEBII@Z(stateId, assetIdPlaylist, assetIdCount);
}

/*
==============
SND_GetControllerIndex
==============
*/

int __fastcall SND_GetControllerIndex(const LocalClientNum_t localClientNum)
{
  return ?SND_GetControllerIndex@@YAHW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
SND_SetEqType
==============
*/

void __fastcall SND_SetEqType(int entchannel, int eqIndex, int band, SND_EQTYPE type)
{
  ?SND_SetEqType@@YAXHHHW4SND_EQTYPE@@@Z(entchannel, eqIndex, band, type);
}

/*
==============
SND_GetTimescaleLerp
==============
*/

double __fastcall SND_GetTimescaleLerp(const unsigned int entchannel)
{
  double result; 

  *(float *)&result = ?SND_GetTimescaleLerp@@YAMI@Z(entchannel);
  return result;
}

/*
==============
SND_EntityFindContextValue
==============
*/

bool __fastcall SND_EntityFindContextValue(const SndEntState *entState, unsigned int contextType, unsigned int *outValueA, unsigned int *outValueB, float *outLerp)
{
  return ?SND_EntityFindContextValue@@YA_NPEBUSndEntState@@IPEAI1PEAM@Z(entState, contextType, outValueA, outValueB, outLerp);
}

/*
==============
SND_Save
==============
*/

void __fastcall SND_Save(MemoryFile *memFile)
{
  ?SND_Save@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_SetVolModValue
==============
*/

void __fastcall SND_SetVolModValue(unsigned int volmodindex, float value, int msec)
{
  ?SND_SetVolModValue@@YAXIMH@Z(volmodindex, value, msec);
}

/*
==============
SND_IsVoicePlaying
==============
*/

bool __fastcall SND_IsVoicePlaying(unsigned int id)
{
  return ?SND_IsVoicePlaying@@YA_NI@Z(id);
}

/*
==============
SND_RestoreEq
==============
*/

void __fastcall SND_RestoreEq(MemoryFile *memFile)
{
  ?SND_RestoreEq@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_StopMusicState
==============
*/

void __fastcall SND_StopMusicState(unsigned int stateId)
{
  ?SND_StopMusicState@@YAXI@Z(stateId);
}

/*
==============
SND_GetPlaybackVoice
==============
*/

SndVoice *__fastcall SND_GetPlaybackVoice(unsigned int id)
{
  return ?SND_GetPlaybackVoice@@YAPEAUSndVoice@@I@Z(id);
}

/*
==============
SND_DrawOcclusionDebug
==============
*/

void __fastcall SND_DrawOcclusionDebug(LocalClientNum_t localClientNum)
{
  ?SND_DrawOcclusionDebug@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
SND_UpdateLoopingSounds
==============
*/

void __fastcall SND_UpdateLoopingSounds(bool deferred)
{
  ?SND_UpdateLoopingSounds@@YAX_N@Z(deferred);
}

/*
==============
SND_GetPerkByIndex
==============
*/

const snd_perk_info_t *__fastcall SND_GetPerkByIndex(unsigned int perkIndex)
{
  return ?SND_GetPerkByIndex@@YAPEBUsnd_perk_info_t@@I@Z(perkIndex);
}

/*
==============
Com_GetSoundFileName
==============
*/

void __fastcall Com_GetSoundFileName(const SndAlias *alias, char *filename, unsigned __int64 filenameSize)
{
  ?Com_GetSoundFileName@@YAXPEBUSndAlias@@PEAD_K@Z(alias, filename, filenameSize);
}

/*
==============
SND_StopSoundsOnEnt
==============
*/

void __fastcall SND_StopSoundsOnEnt(unsigned __int64 sndEnt)
{
  ?SND_StopSoundsOnEnt@@YAX_K@Z(sndEnt);
}

/*
==============
CG_SND_PlayFXSounds
==============
*/

void CG_SND_PlayFXSounds(void)
{
  ?CG_SND_PlayFXSounds@@YAXXZ();
}

/*
==============
SND_GetSPDIFChannelCount
==============
*/

unsigned int __fastcall SND_GetSPDIFChannelCount()
{
  return ?SND_GetSPDIFChannelCount@@YAIXZ();
}

/*
==============
SND_SaveTransientBanks
==============
*/

void __fastcall SND_SaveTransientBanks(MemoryFile *memFile)
{
  ?SND_SaveTransientBanks@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_SetMusicState
==============
*/

void __fastcall SND_SetMusicState(const char *stateName)
{
  ?SND_SetMusicState@@YAXPEBD@Z(stateName);
}

/*
==============
SND_CanDoPhysicsQuery
==============
*/

bool __fastcall SND_CanDoPhysicsQuery()
{
  return ?SND_CanDoPhysicsQuery@@YA_NXZ();
}

/*
==============
SND_PickSoundAliasFromList
==============
*/

void __fastcall SND_PickSoundAliasFromList(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entityNum, const vec3_t *inOrigin, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp)
{
  ?SND_PickSoundAliasFromList@@YAXPEBUSndAliasList@@W4LocalClientNum_t@@HAEBTvec3_t@@PEAPEBUSndAlias@@3PEAM@Z(aliasList, localClientNum, entityNum, inOrigin, outAliasA, outAliasB, outLerp);
}

/*
==============
SND_PlayAmbientAliasBlended
==============
*/

void __fastcall SND_PlayAmbientAliasBlended(LocalClientNum_t localClientNum, const char *aliasNameFrom, const char *aliasNameTo, float lerp, bool isExclusive, snd_alias_system_t system)
{
  ?SND_PlayAmbientAliasBlended@@YAXW4LocalClientNum_t@@PEBD1M_NW4snd_alias_system_t@@@Z(localClientNum, aliasNameFrom, aliasNameTo, lerp, isExclusive, system);
}

/*
==============
SND_UpdateAndStartVoice
==============
*/

void __fastcall SND_UpdateAndStartVoice(int voiceIndex, int frametime)
{
  ?SND_UpdateAndStartVoice@@YAXHH@Z(voiceIndex, frametime);
}

/*
==============
SND_SV_SetEntityHasParams
==============
*/

void __fastcall SND_SV_SetEntityHasParams(int entNum)
{
  ?SND_SV_SetEntityHasParams@@YAXH@Z(entNum);
}

/*
==============
SND_PauseVoice
==============
*/

void __fastcall SND_PauseVoice(int index)
{
  ?SND_PauseVoice@@YAXH@Z(index);
}

/*
==============
SND_GetPerkName
==============
*/

const char *__fastcall SND_GetPerkName(unsigned int perkIndex)
{
  return ?SND_GetPerkName@@YAPEBDI@Z(perkIndex);
}

/*
==============
SND_FreeEntityParamInfo
==============
*/

void __fastcall SND_FreeEntityParamInfo(int entIndex)
{
  ?SND_FreeEntityParamInfo@@YAXH@Z(entIndex);
}

/*
==============
SND_GetPerkVolume
==============
*/

double __fastcall SND_GetPerkVolume(unsigned int perkIndex)
{
  double result; 

  *(float *)&result = ?SND_GetPerkVolume@@YAMI@Z(perkIndex);
  return result;
}

/*
==============
SND_PlaySurfaceSoundAsync
==============
*/

void __fastcall SND_PlaySurfaceSoundAsync(const char *aliasName, const int surfaceType, const unsigned __int64 sndEnt, float volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  ?SND_PlaySurfaceSoundAsync@@YAXPEBDH_KMMHAEBTvec3_t@@@Z(aliasName, surfaceType, sndEnt, volumeScale, pitch, fadeTime, org);
}

/*
==============
SND_SV_CheckAndClearEntityHasParams
==============
*/

bool __fastcall SND_SV_CheckAndClearEntityHasParams(int entNum)
{
  return ?SND_SV_CheckAndClearEntityHasParams@@YA_NH@Z(entNum);
}

/*
==============
SND_SoftReset
==============
*/

void SND_SoftReset(void)
{
  ?SND_SoftReset@@YAXXZ();
}

/*
==============
SND_ScaleVoicePitchById
==============
*/

bool __fastcall SND_ScaleVoicePitchById(unsigned int id, float pitch, int msec)
{
  return ?SND_ScaleVoicePitchById@@YA_NIMH@Z(id, pitch, msec);
}

/*
==============
SND_EntChannelHasOcclusion
==============
*/

bool __fastcall SND_EntChannelHasOcclusion(unsigned int entchannel)
{
  return ?SND_EntChannelHasOcclusion@@YA_NI@Z(entchannel);
}

/*
==============
SND_InitFullOcclusionFlags
==============
*/

void SND_InitFullOcclusionFlags(void)
{
  ?SND_InitFullOcclusionFlags@@YAXXZ();
}

/*
==============
SND_AddPhysicsQueryBlock
==============
*/

void SND_AddPhysicsQueryBlock(void)
{
  ?SND_AddPhysicsQueryBlock@@YAXXZ();
}

/*
==============
SND_PlayExplosionSound
==============
*/

unsigned int __fastcall SND_PlayExplosionSound(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, const vec3_t *org, const unsigned int reflectionClass)
{
  return ?SND_PlayExplosionSound@@YAIPEBUSndAliasList@@H_KAEBTvec3_t@@I@Z(aliasList, surfaceType, sndEnt, org, reflectionClass);
}

/*
==============
SND_PlaySurfaceSound
==============
*/

unsigned int __fastcall SND_PlaySurfaceSound(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, float volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  return ?SND_PlaySurfaceSound@@YAIPEBUSndAliasList@@H_KMMHAEBTvec3_t@@@Z(aliasList, surfaceType, sndEnt, volumeScale, pitch, fadeTime, org);
}

/*
==============
SND_GetVolModCount
==============
*/

unsigned int __fastcall SND_GetVolModCount()
{
  return ?SND_GetVolModCount@@YAIXZ();
}

/*
==============
SND_DrawOnlyChannel_f
==============
*/

void __fastcall SND_DrawOnlyChannel_f()
{
  ?SND_DrawOnlyChannel_f@@YAXXZ();
}

/*
==============
CG_SND_EntStateFrame
==============
*/

void CG_SND_EntStateFrame(void)
{
  ?CG_SND_EntStateFrame@@YAXXZ();
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const char *aliasName, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  return ?SND_PlayScaledSoundAlias@@YAIPEBDW4LocalClientNum_t@@HMMAEBTvec3_t@@HW4snd_alias_system_t@@@Z(aliasName, localClientNum, entnum, volumeScale, pitch, org, timeshift, system);
}

/*
==============
SND_MyChanges
==============
*/

void SND_MyChanges(void)
{
  ?SND_MyChanges@@YAXXZ();
}

/*
==============
SND_ScaleVoiceVolumeById
==============
*/

bool __fastcall SND_ScaleVoiceVolumeById(unsigned int id, float volume, int msec)
{
  return ?SND_ScaleVoiceVolumeById@@YA_NIMH@Z(id, volume, msec);
}

/*
==============
SND_RestoreTransientBanks
==============
*/

void __fastcall SND_RestoreTransientBanks(MemoryFile *memFile)
{
  ?SND_RestoreTransientBanks@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
SND_GetBinkVolume
==============
*/

double __fastcall SND_GetBinkVolume()
{
  double result; 

  *(float *)&result = ?SND_GetBinkVolume@@YAMXZ();
  return result;
}

/*
==============
SND_DeactivateAllEq
==============
*/

void __fastcall SND_DeactivateAllEq(int eqIndex)
{
  ?SND_DeactivateAllEq@@YAXH@Z(eqIndex);
}

/*
==============
SND_CreateAutoSimId
==============
*/

int __fastcall SND_CreateAutoSimId(int index, int instanceId)
{
  return ?SND_CreateAutoSimId@@YAHHH@Z(index, instanceId);
}

/*
==============
SND_StopAutoSim
==============
*/

void __fastcall SND_StopAutoSim(int autoSimId)
{
  ?SND_StopAutoSim@@YAXH@Z(autoSimId);
}

/*
==============
SND_ErrorCleanup
==============
*/

void SND_ErrorCleanup(void)
{
  ?SND_ErrorCleanup@@YAXXZ();
}

/*
==============
SND_DriverPostUpdate
==============
*/

void __fastcall SND_DriverPostUpdate(int frametime)
{
  ?SND_DriverPostUpdate@@YAXH@Z(frametime);
}

/*
==============
SND_ExistsPendingRestore
==============
*/

bool __fastcall SND_ExistsPendingRestore()
{
  return ?SND_ExistsPendingRestore@@YA_NXZ();
}

/*
==============
SND_ChangeSoundAliasListValue
==============
*/

void __fastcall SND_ChangeSoundAliasListValue(const SndAliasList *aliasList, const char *columnName, const char *value)
{
  ?SND_ChangeSoundAliasListValue@@YAXPEBUSndAliasList@@PEBD1@Z(aliasList, columnName, value);
}

/*
==============
SND_SetIgnorePauseFlag
==============
*/

void __fastcall SND_SetIgnorePauseFlag(bool ignorePause)
{
  ?SND_SetIgnorePauseFlag@@YAX_N@Z(ignorePause);
}

/*
==============
SND_SetEntContext
==============
*/

void __fastcall SND_SetEntContext(unsigned __int64 handle, const char *type, const char *value, float fadeTime)
{
  ?SND_SetEntContext@@YAX_KPEBD1M@Z(handle, type, value, fadeTime);
}

/*
==============
SND_SetEqParams
==============
*/

void __fastcall SND_SetEqParams(int entchannel, int eqIndex, int band, SND_EQTYPE type, float gain, float freq, float q)
{
  ?SND_SetEqParams@@YAXHHHW4SND_EQTYPE@@MMM@Z(entchannel, eqIndex, band, type, gain, freq, q);
}

/*
==============
SND_AddImpactToBulletEvent
==============
*/

void __fastcall SND_AddImpactToBulletEvent(const int bulletEventId, const LocalClientNum_t localClientNum, const WeaponSFXPackage *sfxPackage, const vec3_t *inShooterPos, const vec3_t *inImpactPos, int impactEnt, const SndAliasList *impactSound, int surfaceType, const int hitImpactDelayOverride, SndHitmarkerType hitmarkerType)
{
  ?SND_AddImpactToBulletEvent@@YAXHW4LocalClientNum_t@@PEBUWeaponSFXPackage@@AEBTvec3_t@@2HPEBUSndAliasList@@HHW4SndHitmarkerType@@@Z(bulletEventId, localClientNum, sfxPackage, inShooterPos, inImpactPos, impactEnt, impactSound, surfaceType, hitImpactDelayOverride, hitmarkerType);
}

/*
==============
SND_GetDistanceCurveFraction
==============
*/

double __fastcall SND_GetDistanceCurveFraction(float radius, float mindist, float maxdist)
{
  double result; 

  *(float *)&result = ?SND_GetDistanceCurveFraction@@YAMMMM@Z(radius, mindist, maxdist);
  return result;
}

/*
==============
SND_SetEntContext
==============
*/

void __fastcall SND_SetEntContext(unsigned __int64 handle, const char *type, const char *value, double fadeTime)
{
  unsigned int v9; 
  unsigned int v10; 
  unsigned int v11; 
  unsigned int v12; 
  unsigned int v13; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  if ( *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1044i64) == 1164548266 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd_public.cpp", 361, ASSERT_TYPE_ASSERT, "(!SND_IsUpdate())", (const char *)&queryFormat, "!SND_IsUpdate()") )
    __debugbreak();
  if ( g_snd.driverInitialized )
  {
    v9 = SND_HashName(type);
    if ( SND_FindContextIndex(v9) >= 0 )
    {
      if ( !SND_HashName(value) || (v10 = SND_HashName(value), v11 = SND_HashName(type), SND_IsValidContext(v11, v10)) )
      {
        v12 = SND_HashName(value);
        v13 = SND_HashName(type);
        __asm { vmovaps xmm3, xmm6; fadeTime }
        SND_SetEntContext(handle, v13, v12, *(float *)&_XMM3);
      }
      else
      {
        Com_PrintError(9, "SOUND: Unknown sound context value %s for type %s\n", value, type);
      }
    }
    else
    {
      Com_PrintError(9, "SOUND: Unknown sound context %s\n", type);
    }
  }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
CG_GenerateClothSndEntHandle
==============
*/
unsigned __int64 CG_GenerateClothSndEntHandle(const LocalClientNum_t localClientNum, const int clothSoundIndex)
{
  unsigned __int64 v4; 
  __int64 v5; 
  cg_t *LocalClientGlobals; 
  __int64 v7; 

  if ( (unsigned int)clothSoundIndex > 0x3FF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5055, ASSERT_TYPE_ASSERT, "(clothSoundIndex >= 0 && clothSoundIndex < ( 1024 ))", (const char *)&queryFormat, "clothSoundIndex >= 0 && clothSoundIndex < SND_MAX_CLOTH_LOOP_SOUNDS") )
    __debugbreak();
  v4 = clothSoundIndex + 4387;
  if ( v4 >= 0x400000000i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5058, ASSERT_TYPE_ASSERT, "(entId < (1ULL << (33ULL + 1)))", (const char *)&queryFormat, "entId < (1ULL << (SNDENT_ENTNUM_BITS + 1))") )
    __debugbreak();
  v5 = v4 & 0x1FFFFFFFFi64;
  if ( v4 != (v4 & 0x1FFFFFFFFi64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 433, ASSERT_TYPE_ASSERT, "(entIndex == ( ( ( ( handle )&( ( ( 1ULL << ( 33ULL ) ) - 1ULL ) << ( 0ULL ) ) ) >> ( 0ULL ) ) ))", (const char *)&queryFormat, "entIndex == SNDENT_GET_ENTNUM( handle )") )
    __debugbreak();
  if ( !CL_IsLocalClientConnectionActiveForGameServer(localClientNum) )
    return v5 | ((unsigned __int64)(localClientNum & 3) << 33);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v7 = 0x1000000000i64;
  if ( LocalClientGlobals->inKillCam == 1 )
    v7 = 0x1800000000i64;
  return v5 | ((unsigned __int64)(localClientNum & 3) << 33) | v7;
}

/*
==============
CG_GenerateParticleSndEntHandle
==============
*/
unsigned __int64 CG_GenerateParticleSndEntHandle(const LocalClientNum_t localClientNum, const int particleSoundIndex)
{
  unsigned __int64 v4; 
  __int64 v5; 
  cg_t *LocalClientGlobals; 
  __int64 v7; 

  if ( (unsigned int)particleSoundIndex > 0x1F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5027, ASSERT_TYPE_ASSERT, "(particleSoundIndex >= 0 && particleSoundIndex < ( 32 ))", (const char *)&queryFormat, "particleSoundIndex >= 0 && particleSoundIndex < SND_MAX_PARTICLE_LOOP_SOUNDS") )
    __debugbreak();
  v4 = particleSoundIndex + 4355;
  if ( v4 >= 0x400000000i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5030, ASSERT_TYPE_ASSERT, "(entId < ( 1ULL << (33ULL+1) ))", (const char *)&queryFormat, "entId < ( 1ULL << (SNDENT_ENTNUM_BITS+1) )") )
    __debugbreak();
  v5 = v4 & 0x1FFFFFFFFi64;
  if ( v4 != (v4 & 0x1FFFFFFFFi64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 433, ASSERT_TYPE_ASSERT, "(entIndex == ( ( ( ( handle )&( ( ( 1ULL << ( 33ULL ) ) - 1ULL ) << ( 0ULL ) ) ) >> ( 0ULL ) ) ))", (const char *)&queryFormat, "entIndex == SNDENT_GET_ENTNUM( handle )") )
    __debugbreak();
  if ( !CL_IsLocalClientConnectionActiveForGameServer(localClientNum) )
    return v5 | ((unsigned __int64)(localClientNum & 3) << 33);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v7 = 0x1000000000i64;
  if ( LocalClientGlobals->inKillCam == 1 )
    v7 = 0x1800000000i64;
  return v5 | ((unsigned __int64)(localClientNum & 3) << 33) | v7;
}

/*
==============
CG_GeneratePhysicsSndEntHandle
==============
*/
unsigned __int64 CG_GeneratePhysicsSndEntHandle(const LocalClientNum_t localClientNum, const unsigned __int8 worldId, const bool isRagdoll, const unsigned int bodyId)
{
  __int64 v4; 
  unsigned int v8; 
  unsigned __int64 v9; 
  cg_t *LocalClientGlobals; 
  __int64 v11; 
  unsigned __int64 data[3]; 

  v4 = bodyId;
  if ( worldId >= 0x80u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5111, ASSERT_TYPE_ASSERT, "(worldId < 0x80)", (const char *)&queryFormat, "worldId < 0x80") )
    __debugbreak();
  v8 = worldId;
  if ( isRagdoll )
    v8 = worldId | 0x80;
  data[0] = v4 | ((unsigned __int64)v8 << 32);
  v9 = ((unsigned __int64)(localClientNum & 3) << 33) | (SND_Hash(data, 8u) + 505571i64);
  if ( !CL_IsLocalClientConnectionActiveForGameServer(localClientNum) )
    return v9;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v11 = 0x1000000000i64;
  if ( LocalClientGlobals->inKillCam == 1 )
    v11 = 0x1800000000i64;
  return v9 | v11;
}

/*
==============
CG_GeneratePredictedEntSndEntHandle
==============
*/
unsigned __int64 CG_GeneratePredictedEntSndEntHandle(const LocalClientNum_t localClientNum, const int predictedEntIdx)
{
  unsigned __int64 v4; 
  __int64 v5; 
  cg_t *LocalClientGlobals; 
  __int64 v7; 
  int v10; 

  if ( (unsigned int)predictedEntIdx >= 0x20 )
  {
    v10 = 32;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5083, ASSERT_TYPE_ASSERT, "(unsigned)( predictedEntIdx ) < (unsigned)( ( 32 ) )", "predictedEntIdx doesn't index MAX_PREDICTED_ENTS\n\t%i not in [0, %i)", predictedEntIdx, v10) )
      __debugbreak();
  }
  v4 = predictedEntIdx + 5411;
  if ( v4 >= 0x400000000i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5086, ASSERT_TYPE_ASSERT, "(entId < ( 1ULL << (33ULL+1) ))", (const char *)&queryFormat, "entId < ( 1ULL << (SNDENT_ENTNUM_BITS+1) )") )
    __debugbreak();
  v5 = v4 & 0x1FFFFFFFFi64;
  if ( v4 != (v4 & 0x1FFFFFFFFi64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 433, ASSERT_TYPE_ASSERT, "(entIndex == ( ( ( ( handle )&( ( ( 1ULL << ( 33ULL ) ) - 1ULL ) << ( 0ULL ) ) ) >> ( 0ULL ) ) ))", (const char *)&queryFormat, "entIndex == SNDENT_GET_ENTNUM( handle )") )
    __debugbreak();
  if ( !CL_IsLocalClientConnectionActiveForGameServer(localClientNum) )
    return v5 | ((unsigned __int64)(localClientNum & 3) << 33);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v7 = 0x1000000000i64;
  if ( LocalClientGlobals->inKillCam == 1 )
    v7 = 0x1800000000i64;
  return v5 | ((unsigned __int64)(localClientNum & 3) << 33) | v7;
}

/*
==============
CG_GenerateScriptableSndEntHandle
==============
*/
unsigned __int64 CG_GenerateScriptableSndEntHandle(const LocalClientNum_t localClientNum, const unsigned __int64 scriptableIndex)
{
  unsigned __int64 v4; 
  __int64 v5; 
  cg_t *LocalClientGlobals; 
  __int64 v7; 
  int v9; 
  int v10; 

  if ( (unsigned int)scriptableIndex >= 0x7A120 )
  {
    v10 = 500000;
    v9 = scriptableIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5147, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( SCRIPTABLE_MAX_INSTANCE_COUNT )", "scriptableIndex doesn't index SCRIPTABLE_MAX_INSTANCE_COUNT\n\t%i not in [0, %i)", v9, v10) )
      __debugbreak();
  }
  v4 = scriptableIndex + 5571;
  if ( v4 >= 0x400000000i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5150, ASSERT_TYPE_ASSERT, "(entId < ( 1ULL << ( 33ULL + 1 ) ))", (const char *)&queryFormat, "entId < ( 1ULL << ( SNDENT_ENTNUM_BITS + 1 ) )") )
    __debugbreak();
  v5 = v4 & 0x1FFFFFFFFi64;
  if ( v4 != (v4 & 0x1FFFFFFFFi64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 433, ASSERT_TYPE_ASSERT, "(entIndex == ( ( ( ( handle )&( ( ( 1ULL << ( 33ULL ) ) - 1ULL ) << ( 0ULL ) ) ) >> ( 0ULL ) ) ))", (const char *)&queryFormat, "entIndex == SNDENT_GET_ENTNUM( handle )") )
    __debugbreak();
  if ( !CL_IsLocalClientConnectionActiveForGameServer(localClientNum) )
    return v5 | ((unsigned __int64)(localClientNum & 3) << 33);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v7 = 0x1000000000i64;
  if ( LocalClientGlobals->inKillCam == 1 )
    v7 = 0x1800000000i64;
  return v5 | ((unsigned __int64)(localClientNum & 3) << 33) | v7;
}

/*
==============
CG_GenerateSndEntHandle
==============
*/
__int64 CG_GenerateSndEntHandle(const LocalClientNum_t localClientNum, const int entIndex)
{
  __int64 v4; 
  unsigned __int64 v5; 
  int inKillCam; 
  centity_t *Entity; 
  __int64 v8; 
  __int64 result; 
  __int64 v10; 

  v4 = entIndex & 0x1FFFFFFFFi64;
  if ( entIndex != v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 433, ASSERT_TYPE_ASSERT, "(entIndex == ( ( ( ( handle )&( ( ( 1ULL << ( 33ULL ) ) - 1ULL ) << ( 0ULL ) ) ) >> ( 0ULL ) ) ))", (const char *)&queryFormat, "entIndex == SNDENT_GET_ENTNUM( handle )") )
    __debugbreak();
  v5 = v4 | ((unsigned __int64)(localClientNum & 3) << 33);
  if ( !CL_IsLocalClientConnectionActiveForGameServer(localClientNum) )
    return v4 | ((unsigned __int64)(localClientNum & 3) << 33);
  inKillCam = CG_GetLocalClientGlobals(localClientNum)->inKillCam;
  if ( entIndex >= 2048 )
  {
$LN13_143:
    v8 = 0x1000000000i64;
    if ( inKillCam )
      v8 = 0x1800000000i64;
    return v5 | v8;
  }
  else
  {
    Entity = CG_GetEntity(localClientNum, entIndex);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4986, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
      __debugbreak();
    switch ( Entity->nextState.eType )
    {
      case ET_FIRST:
      case ET_PLAYER:
      case ET_PLAYER_CORPSE:
      case ET_ITEM:
      case ET_MISSILE:
      case ET_INVISIBLE:
      case ET_SCRIPTMOVER:
      case ET_SOUND:
      case ET_TURRET:
      case ET_HELICOPTER:
      case ET_PLANE:
      case ET_VEHICLE:
      case ET_AGENT:
      case ET_ACTOR:
      case ET_PHYSICS_CHILD:
        goto $LN13_143;
      default:
        v10 = 0i64;
        if ( Entity->nextState.eType >= ET_EVENTS )
          v10 = 0x1000000000i64;
        result = v5 | -(__int64)(inKillCam != 0) & 0x800000000i64 | v10;
        break;
    }
  }
  return result;
}

/*
==============
CG_SND_BankDetailStream_GetBankForWeapon
==============
*/
const SndBankTransient *CG_SND_BankDetailStream_GetBankForWeapon(const Weapon *weapon, bool isPlayer)
{
  const SndBankTransient *result; 

  if ( weapon->weaponIdx >= 0x226u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8651, ASSERT_TYPE_ASSERT, "(unsigned)( weapon.weaponIdx ) < (unsigned)( 550 )", "weapon.weaponIdx doesn't index MAX_WEAPONS\n\t%i not in [0, %i)", weapon->weaponIdx, 550) )
    __debugbreak();
  result = (const SndBankTransient *)BG_GetSfxPackage(weapon, 0);
  if ( result )
  {
    if ( isPlayer )
      return *(const SndBankTransient **)&result->bank.aliasCount;
    else
      return (const SndBankTransient *)result->bank.soundLanguage;
  }
  return result;
}

/*
==============
CG_SND_BankDetailStream_PrioritizeThirdPersonWeapons
==============
*/
void CG_SND_BankDetailStream_PrioritizeThirdPersonWeapons(const BgWeaponMap *const weaponMap, const centity_t *const cent, int playerStateClientNum, const vec3_t *origin)
{
  entityState_t *p_nextState; 
  entityType_s eType; 
  int v11; 
  char v24; 
  char v25; 
  const Weapon *Weapon; 
  const SndBankTransient *BankForWeapon; 
  const SndBankTransient *v28; 
  int v33; 
  unsigned int v34; 
  int v35; 
  const Weapon *v36; 
  const SndBankTransient *v37; 
  vec3_t outOrigin; 
  __int64 v44; 

  v44 = -2i64;
  __asm { vmovaps [rsp+98h+var_48], xmm6 }
  _RBP = origin;
  if ( (cent->flags & 1) != 0 )
  {
    p_nextState = &cent->nextState;
    if ( cent == (const centity_t *const)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1921, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    eType = p_nextState->eType;
    if ( ((eType - 1) & 0xFFED) == 0 && eType != ET_ITEM || cent->nextState.eType == ET_TURRET )
    {
      v11 = 1;
      if ( !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cent->nextState.lerp.eFlags, ACTIVE, 0xCu) && p_nextState->number != playerStateClientNum )
      {
        CG_GetPoseOrigin(&cent->pose, &outOrigin);
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0]
          vsubss  xmm3, xmm0, dword ptr [rsp+98h+outOrigin]
          vmovss  xmm1, dword ptr [rbp+4]
          vsubss  xmm2, xmm1, dword ptr [rsp+98h+outOrigin+4]
          vmovss  xmm0, dword ptr [rbp+8]
          vsubss  xmm4, xmm0, dword ptr [rsp+98h+outOrigin+8]
          vmulss  xmm2, xmm2, xmm2
          vmulss  xmm1, xmm3, xmm3
          vaddss  xmm3, xmm2, xmm1
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm2, xmm3, xmm0
          vsqrtss xmm6, xmm2, xmm2
          vcomiss xmm6, cs:__real@469c4000
        }
        if ( v24 | v25 )
        {
          if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 438, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
            __debugbreak();
          if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 439, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
            __debugbreak();
          Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, p_nextState->weaponHandle);
          if ( Weapon->weaponIdx )
          {
            BankForWeapon = CG_SND_BankDetailStream_GetBankForWeapon(Weapon, 0);
            v28 = BankForWeapon;
            if ( BankForWeapon )
            {
              __asm
              {
                vmulss  xmm1, xmm6, cs:__real@3ba3d70a
                vmovss  xmm0, cs:__real@42c80000
                vsubss  xmm1, xmm0, xmm1
                vcvttss2si ecx, xmm1
              }
              v33 = 1;
              if ( _ECX > 1 )
                v33 = _ECX;
              if ( SND_BankDetailStreaming_BankIsActive(BankForWeapon) )
                v33 += 10;
              SND_BankDetailStreaming_AddBankRequest(v28, SND_BANK_STREAM_CATEGORY_WEAPONS, v33);
            }
          }
          if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_bg_enable_stowed_weapons, "bg_enable_stowed_weapons") && ((cent->nextState.eType - 1) & 0xFFEF) == 0 )
          {
            if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 522, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
              __debugbreak();
            if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 523, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
              __debugbreak();
            v34 = (unsigned __int16)p_nextState->eType;
            if ( (unsigned __int16)v34 > 0x11u || (v35 = 131111, !_bittest(&v35, v34)) )
            {
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 524, ASSERT_TYPE_ASSERT, "(es->eType == ET_GENERAL || es->eType == ET_PLAYER || es->eType == ET_PLAYER_CORPSE || es->eType == ET_AGENT || es->eType == ET_INVISIBLE)", (const char *)&queryFormat, "es->eType == ET_GENERAL || es->eType == ET_PLAYER || es->eType == ET_PLAYER_CORPSE || es->eType == ET_AGENT || es->eType == ET_INVISIBLE") )
                __debugbreak();
            }
            v36 = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, p_nextState->staticState.player.stowedWeaponHandle);
            if ( v36->weaponIdx )
            {
              v37 = CG_SND_BankDetailStream_GetBankForWeapon(v36, 0);
              if ( v37 )
              {
                __asm
                {
                  vmulss  xmm1, xmm6, cs:__real@3b9374bc
                  vmovss  xmm0, cs:__real@42b40000
                  vsubss  xmm1, xmm0, xmm1
                  vcvttss2si edx, xmm1
                }
                if ( _EDX > 1 )
                  v11 = _EDX;
                SND_BankDetailStreaming_AddBankRequest(v37, SND_BANK_STREAM_CATEGORY_WEAPONS, v11);
              }
            }
          }
        }
        memset(&outOrigin, 0, sizeof(outOrigin));
      }
    }
  }
  __asm { vmovaps xmm6, [rsp+98h+var_48] }
}

/*
==============
CG_SND_BankDetailStream_SetScriptedSoundbanks
==============
*/
void CG_SND_BankDetailStream_SetScriptedSoundbanks(const unsigned __int64 scriptedSoundbanksStateBitfield)
{
  unsigned __int64 v1; 
  int v3; 
  int SoundBankCount; 
  char v5; 
  unsigned int SoundBankName; 

  v1 = g_sb.scriptedSoundbanksStateBitfield;
  if ( scriptedSoundbanksStateBitfield != g_sb.scriptedSoundbanksStateBitfield )
  {
    g_sb.scriptedSoundbanksStateBitfield = scriptedSoundbanksStateBitfield;
    v3 = 0;
    SoundBankCount = BG_SoundBankList_GetSoundBankCount();
    if ( SoundBankCount > 0 )
    {
      do
      {
        v5 = (scriptedSoundbanksStateBitfield >> v3) & 1;
        if ( ((v1 >> v3) & 1) != v5 )
        {
          SoundBankName = BG_SoundBankList_GetSoundBankName(v3);
          if ( SoundBankName )
          {
            if ( v5 )
              SND_BankDetailStreaming_AddScriptBankRequest(SoundBankName, 100);
            else
              SND_BankDetailStreaming_RemoveScriptBankRequest(SoundBankName);
          }
          else
          {
            Com_PrintError(9, "Could not find sound bank for soundbanklist index %d.\n", (unsigned int)v3);
          }
        }
        ++v3;
      }
      while ( v3 < SoundBankCount );
    }
  }
}

/*
==============
CG_SND_DetailStreamingPrioritizeForLocalClient
==============
*/
void CG_SND_DetailStreamingPrioritizeForLocalClient(LocalClientNum_t localClientNum, int playerStateClientNum, const vec3_t *origin, const tmat33_t<vec3_t> *axis, const vec3_t *velocity, const playerState_s *ps)
{
  __int64 v7; 
  __int64 v9; 
  CgWeaponMap *v10; 
  __int64 v11; 
  int i; 
  CgEntitySystem *v13; 
  int v14; 
  CgEntitySystem **v15; 
  bool v16; 
  CgEntitySystem *v17; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned __int16 weaponIdx; 
  WeaponSFXPackage *SfxPackage; 
  const SndBankTransient *detailSoundBankPlayer; 
  const dvar_t *v22; 
  const Weapon *v23; 
  BgWeaponHandle *weaponsEquipped; 
  int j; 
  const Weapon *Weapon; 
  const Weapon *v27; 
  unsigned __int16 v28; 
  WeaponSFXPackage *v29; 
  const SndBankTransient *v30; 
  int *p_priority; 
  int v32; 
  bool v33; 
  __int64 v34; 
  CgEntitySystem *v35; 
  const VehicleDef *ClientDef; 
  const SndBankTransient *detailSoundBankNPC; 
  const VehicleDef *v38; 
  const SndBankTransient *v39; 
  unsigned int PlayerSoundBankTriggerIndex; 
  const SndBankTransient *v41; 
  __int64 v42; 
  __int64 v43; 
  __int64 v44; 
  CgEntitySystem **v45; 

  v7 = localClientNum;
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "CG_SND_DetailStreamingPrioritizeForLocalClient");
  v9 = v7;
  v44 = v7;
  if ( !CgWeaponMap::ms_instance[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v10 = CgWeaponMap::ms_instance[v9];
  v11 = 0i64;
  for ( i = 0; ; ++i )
  {
    if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
      __debugbreak();
    if ( i >= (int)ComCharacterLimits::ms_gameData.m_characterCount )
      break;
    if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
    {
      LODWORD(v43) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", v43) )
        __debugbreak();
    }
    if ( (unsigned int)v7 >= CgEntitySystem::ms_allocatedCount )
    {
      LODWORD(v43) = CgEntitySystem::ms_allocatedCount;
      LODWORD(v42) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    if ( !CgEntitySystem::ms_entitySystemArray[v9] )
    {
      LODWORD(v43) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", v43) )
        __debugbreak();
    }
    v13 = CgEntitySystem::ms_entitySystemArray[v9];
    if ( (unsigned int)i >= 0x800 )
    {
      LODWORD(v43) = 2048;
      LODWORD(v42) = i;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    CG_SND_BankDetailStream_PrioritizeThirdPersonWeapons(v10, &v13->m_entities[i], playerStateClientNum, origin);
    v9 = v7;
  }
  v14 = 0;
  v15 = &CgEntitySystem::ms_entitySystemArray[v9];
  v16 = Com_GameMode_SupportsFeature(WEAPON_READY);
  v45 = v15;
  do
  {
    if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
    {
      LODWORD(v43) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", v43) )
        __debugbreak();
    }
    if ( (unsigned int)v7 >= CgEntitySystem::ms_allocatedCount )
    {
      LODWORD(v43) = CgEntitySystem::ms_allocatedCount;
      LODWORD(v42) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    if ( !*v15 )
    {
      LODWORD(v43) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", v43) )
        __debugbreak();
    }
    v17 = *v15;
    if ( (unsigned int)v14 >= 0x800 )
    {
      LODWORD(v43) = 2048;
      LODWORD(v42) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    if ( (v17->m_entities[v11].flags & 1) != 0 && (v16 && v17->m_entities[v11].nextState.eType == ET_ACTOR || v17->m_entities[v11].nextState.eType == ET_TURRET && *((char *)&v17->m_entities[v11].nextState.lerp.u.infoVolumeGrapple + 20) < 0) )
      CG_SND_BankDetailStream_PrioritizeThirdPersonWeapons(v10, &v17->m_entities[v11], playerStateClientNum, origin);
    v15 = v45;
    ++v14;
    ++v11;
  }
  while ( v14 < 2048 );
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v10, ps);
  weaponIdx = CurrentWeaponForPlayer->weaponIdx;
  if ( CurrentWeaponForPlayer->weaponIdx )
  {
    if ( weaponIdx >= 0x226u )
    {
      LODWORD(v43) = 550;
      LODWORD(v42) = weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8651, ASSERT_TYPE_ASSERT, "(unsigned)( weapon.weaponIdx ) < (unsigned)( 550 )", "weapon.weaponIdx doesn't index MAX_WEAPONS\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    SfxPackage = BG_GetSfxPackage(CurrentWeaponForPlayer, 0);
    if ( SfxPackage )
    {
      detailSoundBankPlayer = SfxPackage->detailSoundBankPlayer;
      if ( detailSoundBankPlayer )
        SND_BankDetailStreaming_AddBankRequest(detailSoundBankPlayer, SND_BANK_STREAM_CATEGORY_WEAPONS, 200);
    }
  }
  v22 = DVARBOOL_bg_enable_stowed_weapons;
  if ( !DVARBOOL_bg_enable_stowed_weapons && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_enable_stowed_weapons") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v22);
  if ( v22->current.enabled )
  {
    if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 899, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 900, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v23 = BG_GetCurrentWeaponForPlayer(v10, ps);
    weaponsEquipped = ps->weaponsEquipped;
    for ( j = 0; j < 15; ++j )
    {
      if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (unsigned int)j >= 0xF )
      {
        LODWORD(v43) = 15;
        LODWORD(v42) = j;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v42, v43) )
          __debugbreak();
      }
      Weapon = BgWeaponMap::GetWeapon(v10, (BgWeaponHandle)weaponsEquipped->m_mapEntryId);
      v27 = Weapon;
      v28 = Weapon->weaponIdx;
      if ( Weapon->weaponIdx && memcmp_0(Weapon, v23, 0x3Cui64) )
      {
        if ( v28 >= 0x226u )
        {
          LODWORD(v43) = 550;
          LODWORD(v42) = v28;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8651, ASSERT_TYPE_ASSERT, "(unsigned)( weapon.weaponIdx ) < (unsigned)( 550 )", "weapon.weaponIdx doesn't index MAX_WEAPONS\n\t%i not in [0, %i)", v42, v43) )
            __debugbreak();
        }
        v29 = BG_GetSfxPackage(v27, 0);
        if ( v29 )
        {
          v30 = v29->detailSoundBankPlayer;
          if ( v30 )
            SND_BankDetailStreaming_AddBankRequest(v30, SND_BANK_STREAM_CATEGORY_WEAPONS, 190);
        }
      }
      ++weaponsEquipped;
    }
    LODWORD(v7) = localClientNum;
  }
  if ( !(_BYTE)CgVehicleSystem::ms_allocatedType )
  {
    LODWORD(v43) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 406, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the vehicle system for localClientNum %d but the vehicle system type is not known\n", "ms_allocatedType != GameModeType::NONE", v43) )
      __debugbreak();
  }
  if ( (unsigned int)v7 >= CgVehicleSystem::ms_allocatedCount )
  {
    LODWORD(v43) = CgVehicleSystem::ms_allocatedCount;
    LODWORD(v42) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 407, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v42, v43) )
      __debugbreak();
  }
  if ( !CgVehicleSystem::ms_vehicleSystemArray[v44] )
  {
    LODWORD(v43) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 408, ASSERT_TYPE_ASSERT, "(ms_vehicleSystemArray[localClientNum])", "%s\n\tTrying to access unallocated vehicle system for localClientNum %d\n", "ms_vehicleSystemArray[localClientNum]", v43) )
      __debugbreak();
  }
  p_priority = &CgVehicleSystem::ms_vehicleSystemArray[v44]->m_vehicleClients[0].audioState.priority;
  v32 = 0;
  v33 = 1;
  do
  {
    if ( !v33 )
    {
      LODWORD(v43) = 128;
      LODWORD(v42) = v32;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 502, ASSERT_TYPE_ASSERT, "(unsigned)( vehIndex ) < (unsigned)( (1 << 7) )", "vehIndex doesn't index MAX_VEHICLES\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    if ( p_priority == (int *)580 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8828, ASSERT_TYPE_ASSERT, "(vc)", (const char *)&queryFormat, "vc") )
      __debugbreak();
    v34 = *(p_priority - 125);
    if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
    {
      LODWORD(v43) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", v43) )
        __debugbreak();
    }
    if ( (unsigned int)v7 >= CgEntitySystem::ms_allocatedCount )
    {
      LODWORD(v43) = CgEntitySystem::ms_allocatedCount;
      LODWORD(v42) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    if ( !*v45 )
    {
      LODWORD(v43) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", v43) )
        __debugbreak();
    }
    v35 = *v45;
    if ( (unsigned int)v34 >= 0x800 )
    {
      LODWORD(v43) = 2048;
      LODWORD(v42) = v34;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v42, v43) )
        __debugbreak();
    }
    if ( CG_Vehicle_IsVehicleEntity(&v35->m_entities[v34]) )
    {
      ClientDef = CgVehicleSystem::GetClientDef((const VehicleClient *)(p_priority - 145));
      if ( !ClientDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8666, ASSERT_TYPE_ASSERT, "(vehDef)", (const char *)&queryFormat, "vehDef") )
        __debugbreak();
      detailSoundBankNPC = ClientDef->detailSoundBankNPC;
      if ( detailSoundBankNPC && *p_priority > 0 )
        SND_BankDetailStreaming_AddBankRequest(detailSoundBankNPC, SND_BANK_STREAM_CATEGORY_VEHICLES, *p_priority);
      if ( *p_priority == 128 )
      {
        v38 = CgVehicleSystem::GetClientDef((const VehicleClient *)(p_priority - 145));
        if ( !v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8666, ASSERT_TYPE_ASSERT, "(vehDef)", (const char *)&queryFormat, "vehDef") )
          __debugbreak();
        v39 = v38->detailSoundBankPlayer;
        if ( v39 && *p_priority > 0 )
          SND_BankDetailStreaming_AddBankRequest(v39, SND_BANK_STREAM_CATEGORY_VEHICLES, *p_priority);
      }
    }
    ++v32;
    p_priority += 147;
    v33 = (unsigned int)v32 < 0x80;
  }
  while ( v32 < 128 );
  if ( !(_DWORD)v7 )
  {
    PlayerSoundBankTriggerIndex = CG_GetPlayerSoundBankTriggerIndex(LOCAL_CLIENT_0);
    if ( PlayerSoundBankTriggerIndex != 0x4000 )
    {
      v41 = cm.mapEnts->clientTrigger.detailSoundBank[PlayerSoundBankTriggerIndex];
      if ( v41 )
        SND_BankDetailStreaming_AddBankRequest(v41, SND_BANK_STREAM_CATEGORY_TRIGGERS, 100);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_SND_EntStateFrame
==============
*/
void CG_SND_EntStateFrame(void)
{
  int v0; 
  unsigned int v1; 
  unsigned __int64 *p_sndEnt; 
  unsigned __int64 v3; 
  SndEntState *EntState; 
  unsigned int v5; 
  unsigned int *p_hasPosition; 
  vec3_t origin_out; 
  __int64 v8; 
  tmat33_t<vec3_t> axis_out; 

  v8 = -2i64;
  v0 = Sys_Microseconds();
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "SND_EntStateFrame");
  v1 = 0;
  p_sndEnt = &g_snd.voices[0].sndEnt;
  do
  {
    if ( sdGlob.voiceAlloc[v1] )
    {
      v3 = *p_sndEnt & 0x1FFFFFFFFi64;
      if ( v3 - 5411 <= 0x1F || v3 - 2049 <= 0x8FF || v3 <= 0x7FD || v3 - 5571 <= 0x7A120 )
      {
        if ( *((_DWORD *)p_sndEnt + 43) )
        {
          EntState = SND_FindEntState(*p_sndEnt, 0);
          if ( EntState )
          {
            if ( EntState->lastUsed != g_snd.frame )
            {
              CG_SND_GetSoundEntityOrientation(*p_sndEnt, &origin_out, &axis_out);
              SND_SetEntState(*p_sndEnt, &origin_out, &axis_out);
              memset(&origin_out, 0, sizeof(origin_out));
            }
          }
        }
      }
    }
    ++v1;
    p_sndEnt += 246;
  }
  while ( v1 < 0x63 );
  v5 = 0;
  p_hasPosition = &g_snd.entState[1].hasPosition;
  do
  {
    if ( g_snd.frame - *(p_hasPosition - 33) > 5 )
      *(p_hasPosition - 32) = 0;
    if ( g_snd.frame - *(p_hasPosition - 1) > 5 )
      *p_hasPosition = 0;
    if ( g_snd.frame - p_hasPosition[31] > 5 )
      p_hasPosition[32] = 0;
    if ( g_snd.frame - p_hasPosition[63] > 5 )
      p_hasPosition[64] = 0;
    if ( g_snd.frame - p_hasPosition[95] > 5 )
      p_hasPosition[96] = 0;
    if ( g_snd.frame - p_hasPosition[127] > 5 )
      p_hasPosition[128] = 0;
    if ( g_snd.frame - p_hasPosition[159] > 5 )
      p_hasPosition[160] = 0;
    if ( g_snd.frame - p_hasPosition[191] > 5 )
      p_hasPosition[192] = 0;
    if ( g_snd.frame - p_hasPosition[223] > 5 )
      p_hasPosition[224] = 0;
    if ( g_snd.frame - p_hasPosition[255] > 5 )
      p_hasPosition[256] = 0;
    if ( g_snd.frame - p_hasPosition[287] > 5 )
      p_hasPosition[288] = 0;
    if ( g_snd.frame - p_hasPosition[319] > 5 )
      p_hasPosition[320] = 0;
    if ( g_snd.frame - p_hasPosition[351] > 5 )
      p_hasPosition[352] = 0;
    if ( g_snd.frame - p_hasPosition[383] > 5 )
      p_hasPosition[384] = 0;
    if ( g_snd.frame - p_hasPosition[415] > 5 )
      p_hasPosition[416] = 0;
    if ( g_snd.frame - p_hasPosition[447] > 5 )
      p_hasPosition[448] = 0;
    if ( g_snd.frame - p_hasPosition[479] > 5 )
      p_hasPosition[480] = 0;
    if ( g_snd.frame - p_hasPosition[511] > 5 )
      p_hasPosition[512] = 0;
    if ( g_snd.frame - p_hasPosition[543] > 5 )
      p_hasPosition[544] = 0;
    if ( g_snd.frame - p_hasPosition[575] > 5 )
      p_hasPosition[576] = 0;
    if ( g_snd.frame - p_hasPosition[607] > 5 )
      p_hasPosition[608] = 0;
    if ( g_snd.frame - p_hasPosition[639] > 5 )
      p_hasPosition[640] = 0;
    if ( g_snd.frame - p_hasPosition[671] > 5 )
      p_hasPosition[672] = 0;
    if ( g_snd.frame - p_hasPosition[703] > 5 )
      p_hasPosition[704] = 0;
    if ( g_snd.frame - p_hasPosition[735] > 5 )
      p_hasPosition[736] = 0;
    if ( g_snd.frame - p_hasPosition[767] > 5 )
      p_hasPosition[768] = 0;
    if ( g_snd.frame - p_hasPosition[799] > 5 )
      p_hasPosition[800] = 0;
    if ( g_snd.frame - p_hasPosition[831] > 5 )
      p_hasPosition[832] = 0;
    if ( g_snd.frame - p_hasPosition[863] > 5 )
      p_hasPosition[864] = 0;
    if ( g_snd.frame - p_hasPosition[895] > 5 )
      p_hasPosition[896] = 0;
    if ( g_snd.frame - p_hasPosition[927] > 5 )
      p_hasPosition[928] = 0;
    if ( g_snd.frame - p_hasPosition[959] > 5 )
      p_hasPosition[960] = 0;
    v5 += 32;
    p_hasPosition += 1024;
  }
  while ( v5 < 0x80 );
  g_snd.entStateUsec = Sys_Microseconds() - v0;
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_SND_GetSoundEntityOrientation
==============
*/
void CG_SND_GetSoundEntityOrientation(const unsigned __int64 sndEnt, vec3_t *origin_out, tmat33_t<vec3_t> *axis_out)
{
  unsigned __int64 v6; 
  cg_t **v7; 
  connstate_t *p_connectionState; 
  int v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  if ( (sndEnt & 0x800000000i64) != 0 )
  {
    v6 = (sndEnt >> 33) & 3;
    if ( CL_IsLocalClientConnectionActiveForGameServer((const LocalClientNum_t)((sndEnt >> 33) & 3)) )
    {
LABEL_26:
      v9 = truncate_cast<int,unsigned __int64>(sndEnt & 0x1FFFFFFFFi64);
      GetSoundEntityOrientation((LocalClientNum_t)v6, v9, origin_out, axis_out);
      return;
    }
  }
  else
  {
    LODWORD(v6) = 0;
    if ( SLODWORD(cl_maxLocalClients) > 0 )
    {
      v7 = cg_t::ms_cgArray;
      p_connectionState = &clientUIActives[0].connectionState;
      do
      {
        if ( (unsigned int)v6 >= 2 )
        {
          LODWORD(v12) = 2;
          LODWORD(v10) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 182, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v10, v12) )
            __debugbreak();
          LODWORD(v13) = 2;
          LODWORD(v11) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 165, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v11, v13) )
            __debugbreak();
        }
        if ( !*((_BYTE *)p_connectionState + 28) )
        {
          if ( (unsigned int)v6 >= 2 )
          {
            LODWORD(v12) = 2;
            LODWORD(v10) = v6;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v10, v12) )
              __debugbreak();
          }
          if ( *p_connectionState == CA_ACTIVE )
          {
            if ( (unsigned int)v6 >= cg_t::ms_allocatedCount )
            {
              LODWORD(v12) = cg_t::ms_allocatedCount;
              LODWORD(v10) = v6;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1166, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( cg_t::ms_allocatedCount )", "localClientNum doesn't index cg_t::ms_allocatedCount\n\t%i not in [0, %i)", v10, v12) )
                __debugbreak();
            }
            if ( !*v7 )
            {
              LODWORD(v12) = v6;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", v12) )
                __debugbreak();
            }
            if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
            {
              LODWORD(v12) = v6;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", v12) )
                __debugbreak();
            }
            if ( !(*v7)->inKillCam )
              goto LABEL_26;
          }
        }
        LODWORD(v6) = v6 + 1;
        p_connectionState += 110;
        ++v7;
      }
      while ( (int)v6 < SLODWORD(cl_maxLocalClients) );
    }
  }
  *(_QWORD *)origin_out->v = 0i64;
  origin_out->v[2] = 0.0;
  AxisClear(axis_out);
}

/*
==============
CG_SND_PlayFXSounds
==============
*/
void CG_SND_PlayFXSounds(void)
{
  __int64 v0; 
  __int64 v1; 
  __int64 v2; 
  AsyncPlaySound *v3; 
  const SndAliasList *AliasFromId; 
  __int64 system; 

  v0 = (unsigned int)s_FXPlaySoundCount;
  v1 = ((_BYTE)s_FXPlaySoundHead - (_BYTE)s_FXPlaySoundCount) & 0x1F;
  if ( !SND_AnyActiveListeners() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4953, ASSERT_TYPE_ASSERT, "(SND_AnyActiveListeners())", (const char *)&queryFormat, "SND_AnyActiveListeners()") )
    __debugbreak();
  if ( (unsigned int)v0 >= 0x20 )
  {
    LODWORD(system) = v0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4954, ASSERT_TYPE_ASSERT, "(unsigned)( soundCount ) < (unsigned)( ( sizeof( *array_counter( s_FXPlaySounds ) ) + 0 ) )", "soundCount doesn't index ARRAY_COUNT( s_FXPlaySounds )\n\t%i not in [0, %i)", system, 32) )
      __debugbreak();
  }
  if ( (int)v0 > 0 )
  {
    v2 = v0;
    do
    {
      v3 = &s_FXPlaySounds[v1];
      AliasFromId = SND_FindAliasFromId(v3->aliasId);
      SND_PlaySoundAlias(AliasFromId, (const LocalClientNum_t)v3->localClientNum, v3->entNum, &v3->origin, 0, SASYS_CGAME);
      v1 = ((_BYTE)v1 + 1) & 0x1F;
      --v2;
    }
    while ( v2 );
  }
  if ( ((unsigned __int8)&s_FXPlaySoundCount & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 79, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_FXPlaySoundCount) )
    __debugbreak();
  _InterlockedExchangeAdd(&s_FXPlaySoundCount, -(int)v0);
}

/*
==============
CG_SND_Update
==============
*/
void CG_SND_Update(const LocalClientNum_t localClientNum)
{
  int frametime; 
  float v5; 
  LocalClientNum_t v6; 
  _BYTE *frontEndSceneState; 
  unsigned int refdefViewOrg_aab; 
  bool *voiceAlloc; 
  int v16; 
  int v17; 
  int v18; 
  bool *v19; 
  unsigned __int64 *p_sndEnt; 
  __int64 v21; 
  int v22; 
  const dvar_t *v23; 
  const dvar_t *v24; 
  int v25; 
  const SndAlias **p_alias; 
  int SoundFileLengthMS; 
  int i; 
  volatile int v29; 
  __int64 v30; 
  __int64 v31; 
  LocalClientNum_t v32; 
  connstate_t *p_connectionState; 
  int v35; 
  int v36; 
  unsigned __int64 SndEntHandle; 
  __int64 v39; 
  const AmbientElement *RandomElement; 
  int ControllerFromClient; 
  __int64 v42; 
  __int64 v43; 
  __int64 v44; 
  const SndAliasList *AliasFromId; 
  const dvar_t *v46; 
  const dvar_t *v47; 
  int integer; 
  const SndAliasList *v49; 
  int v50; 
  SndBankInfo *v51; 
  const SndBank *bank; 
  playerState_s *ps; 
  playerState_s *psa; 
  playerState_s *psb; 
  __int64 v58; 
  __int64 v59; 
  __int64 v60; 
  int data; 
  int gameFrameDelta; 
  float volume; 
  int v64; 
  vec3_t origin; 
  connstate_t *v66; 
  __int64 v67; 
  unsigned __int64 v68; 
  __int64 v69; 
  cg_t *p_z; 
  vec3_t velocity; 
  snd_listener outListener; 
  char v73; 
  void *retaddr; 

  _RAX = &retaddr;
  v69 = -2i64;
  __asm { vmovaps xmmword ptr [rax-38h], xmm6 }
  frametime = 0;
  gameFrameDelta = 0;
  if ( SND_Active() )
  {
    v5 = cl_maxLocalClients;
    if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 352, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, cl_maxLocalClients) )
        __debugbreak();
      v5 = cl_maxLocalClients;
    }
    if ( v5 == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 336, ASSERT_TYPE_ASSERT, "(cl_maxLocalClients)", "%s\n\tMust be called after client allocation", "cl_maxLocalClients") )
      __debugbreak();
    if ( cls.m_localClientsActive.activeCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 353, ASSERT_TYPE_ASSERT, "(GetGameLocalClientActiveCount() > 0)", "%s\n\tClient active data has not been setup", "GetGameLocalClientActiveCount() > 0") )
      __debugbreak();
    if ( cls.m_localClientsActive.firstActiveIndex == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 354, ASSERT_TYPE_ASSERT, "(m_localClientsActive.firstActiveIndex != LOCAL_CLIENT_INVALID)", "%s\n\tClient active data has not been setup", "m_localClientsActive.firstActiveIndex != LOCAL_CLIENT_INVALID") )
      __debugbreak();
    if ( localClientNum == cls.m_localClientsActive.firstActiveIndex )
    {
      v68 = Sys_Microseconds();
      Sys_ProfBeginNamedEvent(0xFFD8BFD8, "CG_SND_Update");
      Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
      cls.inUpdateSound = 1;
      SND_BankDetailStreaming_Reset();
      v6 = LOCAL_CLIENT_0;
      if ( SLODWORD(cl_maxLocalClients) > 0 )
      {
        frontEndSceneState = clientUIActives[0].frontEndSceneState;
        __asm { vxorps  xmm6, xmm6, xmm6 }
        do
        {
          if ( (unsigned int)v6 >= LOCAL_CLIENT_COUNT )
          {
            LODWORD(v58) = 2;
            LODWORD(ps) = v6;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 182, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", ps, v58) )
              __debugbreak();
            LODWORD(v59) = 2;
            LODWORD(psa) = v6;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 165, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", psa, v59) )
              __debugbreak();
          }
          if ( !*frontEndSceneState && CL_GetLocalClientAnyConnectionState(v6) == CA_ACTIVE )
          {
            _RDI = CG_GetLocalClientGlobals(v6);
            if ( CG_View_IsKillCamEntityView(v6) )
            {
              __asm
              {
                vmovss  dword ptr [rbp+60h+velocity], xmm6
                vmovss  dword ptr [rbp+60h+velocity+4], xmm6
                vmovss  dword ptr [rbp+60h+velocity+8], xmm6
              }
            }
            else
            {
              if ( _RDI->predictedPlayerState.vehicleState.entity == 2047 )
              {
                __asm
                {
                  vmovss  xmm0, dword ptr [rdi+44h]
                  vmovss  dword ptr [rbp+60h+velocity], xmm0
                  vmovss  xmm1, dword ptr [rdi+48h]
                  vmovss  xmm0, dword ptr [rdi+4Ch]
                }
              }
              else
              {
                __asm
                {
                  vmovss  xmm0, dword ptr [rdi+14Ch]
                  vmovss  dword ptr [rbp+60h+velocity], xmm0
                  vmovss  xmm1, dword ptr [rdi+150h]
                  vmovss  xmm0, dword ptr [rdi+154h]
                }
              }
              __asm
              {
                vmovss  dword ptr [rbp+60h+velocity+8], xmm0
                vmovss  dword ptr [rbp+60h+velocity+4], xmm1
              }
            }
            if ( _RDI == (cg_t *)-26928i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\renderer\\tr_types.h", 1316, ASSERT_TYPE_ASSERT, "(refdefView)", (const char *)&queryFormat, "refdefView") )
              __debugbreak();
            refdefViewOrg_aab = _RDI->refdef.view.refdefViewOrg_aab;
            if ( _RDI == (cg_t *)-26936i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\renderer\\tr_types.h", 1284, ASSERT_TYPE_ASSERT, "(viewOrg)", (const char *)&queryFormat, "viewOrg") )
              __debugbreak();
            LODWORD(origin.v[0]) = LODWORD(_RDI->refdef.view.org.org.v[0]) ^ ((refdefViewOrg_aab ^ ((_DWORD)_RDI + 26936)) * ((refdefViewOrg_aab ^ ((_DWORD)_RDI + 26936)) + 2));
            LODWORD(origin.v[1]) = LODWORD(_RDI->refdef.view.org.org.v[1]) ^ ((refdefViewOrg_aab ^ ((_DWORD)_RDI + 26940)) * ((refdefViewOrg_aab ^ ((_DWORD)_RDI + 26940)) + 2));
            p_z = (cg_t *)&_RDI->refdef.view.org.org.z;
            LODWORD(v67) = refdefViewOrg_aab ^ ((_DWORD)_RDI + 26944);
            LODWORD(origin.v[2]) = (v67 * (v67 + 2)) ^ LODWORD(_RDI->refdef.view.org.org.v[2]);
            SND_SetListener(v6, _RDI->predictedPlayerState.clientNum, &origin, &_RDI->refdef.view.axis, &velocity);
            if ( v6 )
            {
              frametime = gameFrameDelta;
            }
            else
            {
              frametime = _RDI->frametime;
              gameFrameDelta = frametime;
            }
            CG_SND_DetailStreamingPrioritizeForLocalClient(v6, _RDI->predictedPlayerState.clientNum, &origin, &_RDI->refdef.view.axis, &velocity, &_RDI->predictedPlayerState);
            memset(&origin, 0, sizeof(origin));
          }
          ++v6;
          frontEndSceneState += 440;
        }
        while ( v6 < SLODWORD(cl_maxLocalClients) );
      }
      voiceAlloc = sdGlob.voiceAlloc;
      if ( !clientUIActives[0].frontEndSceneState[0] && CL_GetLocalClientAnyConnectionState(LOCAL_CLIENT_0) == CA_ACTIVE )
      {
        Sys_ProfBeginNamedEvent(0xFFD8BFD8, "wait_workers");
        Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
        Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
        Sys_ProfEndNamedEvent();
        CG_SND_UpdateReverbs(frametime);
        CG_SND_UpdateDoppler(frametime);
        CG_SND_EntStateFrame();
        SND_UpdateEntVolumes(frametime);
        v16 = 0;
        v17 = 0x7FFFFFFF;
        v18 = 0x7FFFFFFF;
        v19 = sdGlob.voiceAlloc;
        p_sndEnt = &g_snd.voices[0].sndEnt;
        do
        {
          if ( (unsigned int)v16 > 0x62 )
          {
            LODWORD(ps) = v16;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", ps) )
              __debugbreak();
          }
          if ( *v19 )
          {
            v21 = (unsigned __int8)(*(int *)(p_sndEnt[12] + 112) >> 10);
            if ( SND_IsEntChannel3D(v21) && g_snd.entChanOcclusionParams[v21][0].enabled )
            {
              if ( LOBYTE(g_snd.entChanFullOcclusionDisabled[18 * v21 - 4599]) )
              {
                if ( (*p_sndEnt & 0x1FFFFFFFFi64) != 2048 && (*p_sndEnt & 0x1000000000i64) != 0 && !SND_IsEntChannelPASpeaker(v21) )
                {
                  v22 = *((_DWORD *)p_sndEnt + 42);
                  if ( v22 <= g_snd.time && v22 < v18 )
                  {
                    v18 = *((_DWORD *)p_sndEnt + 42);
                    v17 = v16;
                  }
                }
              }
            }
          }
          ++v16;
          ++v19;
          p_sndEnt += 246;
        }
        while ( v16 < 99 );
        voiceAlloc = sdGlob.voiceAlloc;
        if ( v17 != 0x7FFFFFFF )
          SND_DoTracesWithDebug(&g_snd.voices[v17]);
        SND_BankDetailStreaming_Update();
      }
      v23 = DCONST_DVARINT_snd_draw3D;
      if ( !DCONST_DVARINT_snd_draw3D && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_draw3D") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v23);
      if ( v23->current.integer )
      {
        v24 = DCONST_DVARINT_snd_draw3D;
        if ( !DCONST_DVARINT_snd_draw3D && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_draw3D") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v24);
        DebugDrawWorldSounds(v24->current.integer);
      }
      v25 = 0;
      p_alias = &g_snd.voices[0].alias;
      do
      {
        if ( (unsigned int)v25 > 0x62 )
        {
          LODWORD(ps) = v25;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", ps) )
            __debugbreak();
        }
        if ( *voiceAlloc && *((_BYTE *)p_alias - 75) && (*p_alias)->subtitle )
        {
          SoundFileLengthMS = SND_GetSoundFileLengthMS((const SndAssetBankEntry *)p_alias[1]);
          for ( i = 0; i < 2; ++i )
          {
            if ( CL_IsLocalClientActive((LocalClientNum_t)i) )
              CG_Utils_SubtitlePrint((const LocalClientNum_t)i, SoundFileLengthMS, *p_alias);
          }
          *((_BYTE *)p_alias - 75) = 0;
        }
        ++v25;
        ++voiceAlloc;
        p_alias += 246;
      }
      while ( v25 < 99 );
      v29 = s_notifiesCount;
      v30 = ((_BYTE)s_notifiesHead - (_BYTE)s_notifiesCount) & 0x1F;
      if ( s_notifiesCount > 0 )
      {
        v31 = (unsigned int)s_notifiesCount;
        do
        {
          CG_Utils_ScriptNotifySoundDone(s_notifies[v30].entnum, s_notifies[v30].soundString);
          v30 = ((_BYTE)v30 + 1) & 0x1F;
          --v31;
        }
        while ( v31 );
      }
      if ( ((unsigned __int8)&s_notifiesCount & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 79, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_notifiesCount) )
        __debugbreak();
      _InterlockedExchangeAdd(&s_notifiesCount, -v29);
      v32 = LOCAL_CLIENT_0;
      if ( SLODWORD(cl_maxLocalClients) > 0 )
      {
        _R14 = &g_ambGlob[0].playTimeFound;
        p_connectionState = &clientUIActives[0].connectionState;
        v66 = &clientUIActives[0].connectionState;
        do
        {
          if ( (unsigned int)v32 >= LOCAL_CLIENT_COUNT )
          {
            LODWORD(v58) = 2;
            LODWORD(ps) = v32;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 182, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", ps, v58) )
              __debugbreak();
            LODWORD(v60) = 2;
            LODWORD(psb) = v32;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 165, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", psb, v60) )
              __debugbreak();
          }
          if ( !*((_BYTE *)p_connectionState + 28) )
          {
            if ( (unsigned int)v32 >= LOCAL_CLIENT_COUNT )
            {
              LODWORD(v58) = 2;
              LODWORD(ps) = v32;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", ps, v58) )
                __debugbreak();
            }
            if ( *p_connectionState == CA_ACTIVE )
            {
              v35 = Sys_Milliseconds() - g_snd.time;
              if ( !*_R14 )
              {
                SND_GetLengthMS(*((_DWORD *)_R14 - 3), &g_ambGlob[v32].playTime);
                v36 = *((_DWORD *)_R14 - 2);
                if ( v36 )
                {
                  *_R14 = 1;
                  if ( *(_QWORD *)(_R14 + 4) )
                    *((_DWORD *)_R14 - 1) += v36;
                }
              }
              if ( *((_DWORD *)_R14 - 2) > g_snd.time )
              {
                __asm
                {
                  vmovss  xmm0, dword ptr [r14+1Ch]
                  vmovss  [rsp+160h+volume], xmm0
                }
                SndEntHandle = CG_GenerateSndEntHandle(v32, v32 + 4353);
                SND_SetEntityParamInfoData(SndEntHandle, NULL, &volume, 1000);
              }
              if ( g_snd.paused )
              {
                *((_DWORD *)_R14 - 1) += v35;
              }
              else
              {
                v39 = *(_QWORD *)(_R14 + 12);
                if ( v39 )
                {
                  if ( *(_QWORD *)(_R14 + 20) )
                  {
                    if ( g_snd.time > *((_DWORD *)_R14 - 1) )
                    {
                      if ( *(_WORD *)(v39 + 14) )
                      {
                        RandomElement = SND_AmbientEventGetRandomElement(v32);
                        if ( RandomElement )
                          SND_PlayAmbientElement(v32, RandomElement);
                      }
                    }
                  }
                }
              }
              if ( v32 == LOCAL_CLIENT_0 )
              {
                ControllerFromClient = CL_Mgr_GetControllerFromClient(LOCAL_CLIENT_0);
                v64 = ControllerFromClient;
                v42 = (unsigned int)s_FXPlaySoundCount;
                v43 = ((_BYTE)s_FXPlaySoundHead - (_BYTE)s_FXPlaySoundCount) & 0x1F;
                if ( !SND_AnyActiveListeners() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4953, ASSERT_TYPE_ASSERT, "(SND_AnyActiveListeners())", (const char *)&queryFormat, "SND_AnyActiveListeners()") )
                  __debugbreak();
                if ( (unsigned int)v42 >= 0x20 )
                {
                  LODWORD(v58) = 32;
                  LODWORD(ps) = v42;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4954, ASSERT_TYPE_ASSERT, "(unsigned)( soundCount ) < (unsigned)( ( sizeof( *array_counter( s_FXPlaySounds ) ) + 0 ) )", "soundCount doesn't index ARRAY_COUNT( s_FXPlaySounds )\n\t%i not in [0, %i)", ps, v58) )
                    __debugbreak();
                }
                if ( (int)v42 > 0 )
                {
                  v44 = v42;
                  do
                  {
                    AliasFromId = SND_FindAliasFromId(s_FXPlaySounds[v43].aliasId);
                    SND_PlaySoundAlias(AliasFromId, (const LocalClientNum_t)s_FXPlaySounds[v43].localClientNum, s_FXPlaySounds[v43].entNum, &s_FXPlaySounds[v43].origin, 0, SASYS_CGAME);
                    v43 = ((_BYTE)v43 + 1) & 0x1F;
                    --v44;
                  }
                  while ( v44 );
                  ControllerFromClient = v64;
                  p_connectionState = v66;
                }
                if ( ((unsigned __int8)&s_FXPlaySoundCount & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 79, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_FXPlaySoundCount) )
                  __debugbreak();
                _InterlockedExchangeAdd(&s_FXPlaySoundCount, -(int)v42);
                SND_UpdateDelayedWeaponSoundQueue(gameFrameDelta, ControllerFromClient);
                CG_SND_WeapReflectUpdate();
              }
            }
          }
          ++v32;
          p_connectionState += 110;
          v66 = p_connectionState;
          _R14 += 48;
        }
        while ( v32 < SLODWORD(cl_maxLocalClients) );
      }
      v46 = DCONST_DVARINT_snd_debugStressTest;
      if ( !DCONST_DVARINT_snd_debugStressTest && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debugStressTest") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v46);
      if ( v46->current.integer )
      {
        v47 = DCONST_DVARINT_snd_debugStressTest;
        if ( !DCONST_DVARINT_snd_debugStressTest && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debugStressTest") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v47);
        integer = v47->current.integer;
        if ( integer > 0 )
        {
          SND_GetListener(LOCAL_CLIENT_0, &outListener);
          if ( outListener.active )
          {
            for ( dword_155DF6A80 += Sys_Milliseconds() - g_snd.time; dword_155DF6A80 > integer; dword_155DF6A80 -= integer )
            {
              v49 = NULL;
              Sys_EnterCriticalSection(CRITSECT_SOUND_BANK);
              v50 = 1000;
              while ( 1 )
              {
                --v50;
                v51 = g_sb.bankStack[rand() % 800];
                if ( v51->bank )
                {
                  if ( v51->bankActive && v51->bank->aliasCount )
                    break;
                }
                if ( v50 <= 0 )
                  goto LABEL_148;
              }
              bank = v51->bank;
              v49 = &bank->alias[rand() % bank->aliasCount];
LABEL_148:
              Sys_LeaveCriticalSection(CRITSECT_SOUND_BANK);
              if ( v49 )
                SND_PlaySoundAlias(v49, LOCAL_CLIENT_0, 2047, &outListener.orient.origin, 0, SASYS_CGAME);
            }
          }
        }
      }
      g_snd.numFullOcclusionCache = 0;
      CG_ClearAudioZoneCache();
      cls.inUpdateSound = 0;
      Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
      if ( !Sys_ExistsWorkerCmdsOfType(WRKCMD_SOUND_DOOR_PROPAGATION) )
        Sys_AddWorkerCmd(WRKCMD_SOUND_DOOR_PROPAGATION, &data);
      Sys_AddWorkerCmd(WRKCMD_SOUND_DEFERRED_PLAYBACK, (char *)&data + 1);
      if ( SND_Active() && Com_DevhostSystemActive(3) )
        SND_PossiblyUpdate(15);
      g_snd.cgFrameUsec = Sys_Microseconds() - v68;
      Sys_ProfEndNamedEvent();
    }
  }
  _R11 = &v73;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
CG_SND_UpdateDoppler
==============
*/
void CG_SND_UpdateDoppler(int frameDelta)
{
  int v15; 
  bool *voiceAlloc; 
  int v19; 
  __int64 v65; 
  vec3_t outOrigin; 
  int v67; 
  __int64 v68; 
  snd_listener outListener; 
  char v70; 
  void *retaddr; 

  if ( frameDelta > 0 )
  {
    _RAX = &retaddr;
    v68 = -2i64;
    __asm
    {
      vmovaps xmmword ptr [rax-18h], xmm6
      vmovaps xmmword ptr [rax-28h], xmm7
      vmovaps xmmword ptr [rax-38h], xmm8
      vmovaps xmmword ptr [rax-48h], xmm9
      vmovaps xmmword ptr [rax-58h], xmm10
      vmovaps xmmword ptr [rax-68h], xmm11
      vmovaps xmmword ptr [rax-78h], xmm12
      vmovaps xmmword ptr [rax-88h], xmm13
      vmovaps xmmword ptr [rax-98h], xmm14
    }
    if ( SND_AnyActiveListeners() )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, edi
        vmulss  xmm13, xmm0, cs:__real@3a83126f
        vmovss  [rsp+178h+var_138], xmm13
      }
      if ( (v67 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7042, ASSERT_TYPE_ASSERT, "(!IS_NAN(frameTimeInSeconds))", (const char *)&queryFormat, "!IS_NAN(frameTimeInSeconds)") )
        __debugbreak();
      v15 = 0;
      voiceAlloc = sdGlob.voiceAlloc;
      _RDI = &g_snd.voices[0].dopplerPreset.minPitch;
      __asm { vmovss  xmm14, cs:__real@3f800000 }
      do
      {
        if ( (unsigned int)v15 > 0x62 )
        {
          LODWORD(v65) = v15;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v65) )
            __debugbreak();
        }
        if ( *voiceAlloc && SND_IsEntChannel3D((unsigned __int8)(*(int *)(*(_QWORD *)(_RDI - 435) + 112i64) >> 10)) )
        {
          SndVoice_GetOrigin((const SndVoice *)(_RDI - 463), &outOrigin);
          SND_GetListenerNearestToOrigin(&outOrigin, &outListener);
          if ( _RDI == (float *)76 )
          {
            MEMORY[0xFFFFFFFFFFFFFA08] = 1065353216;
          }
          else
          {
            v19 = *((_DWORD *)_RDI - 366);
            if ( v19 )
            {
              *(_RDI - 401) = 1.0;
              *((_DWORD *)_RDI - 366) = v19 - 1;
            }
            else
            {
              __asm
              {
                vmulss  xmm11, xmm13, dword ptr [rdi-8]
                vmovss  xmm12, dword ptr [rdi+8]
                vmovss  xmm2, dword ptr [rsp+178h+outOrigin]
                vsubss  xmm3, xmm2, dword ptr [rdi-650h]
                vmovss  xmm1, dword ptr [rsp+178h+outOrigin+4]
                vsubss  xmm4, xmm1, dword ptr [rdi-64Ch]
                vmovss  xmm0, dword ptr [rsp+178h+outOrigin+8]
                vsubss  xmm5, xmm0, dword ptr [rdi-648h]
                vsubss  xmm8, xmm2, dword ptr [rsp+178h+outListener.orient.origin]
                vsubss  xmm9, xmm1, dword ptr [rsp+178h+outListener.orient.origin+4]
                vsubss  xmm10, xmm0, dword ptr [rsp+178h+outListener.orient.origin+8]
                vmovss  xmm0, dword ptr [rsp+178h+outListener.velocityVect]
                vsubss  xmm6, xmm0, xmm3
                vmovss  xmm3, dword ptr [rsp+178h+outListener.velocityVect+4]
                vsubss  xmm4, xmm3, xmm4
                vmovss  xmm0, dword ptr [rsp+178h+outListener.velocityVect+8]
                vsubss  xmm5, xmm0, xmm5
                vsubss  xmm7, xmm11, xmm14
                vmulss  xmm3, xmm6, xmm8
                vmulss  xmm0, xmm4, xmm9
                vaddss  xmm4, xmm3, xmm0
                vmulss  xmm3, xmm5, xmm10
                vaddss  xmm4, xmm4, xmm3
                vminss  xmm0, xmm4, xmm7
                vsubss  xmm5, xmm11, xmm0
                vdivss  xmm0, xmm11, xmm5; val
                vmovss  xmm2, dword ptr [rdi+4]; max
                vmovss  xmm1, dword ptr [rdi]; min
              }
              I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
              __asm
              {
                vmulss  xmm1, xmm12, dword ptr [rdi-644h]
                vaddss  xmm2, xmm1, xmm0
                vaddss  xmm0, xmm12, xmm14
                vdivss  xmm2, xmm2, xmm0
                vmovss  dword ptr [rdi-644h], xmm2
              }
            }
            __asm
            {
              vmovss  xmm0, dword ptr [rsp+178h+outOrigin]
              vmovss  dword ptr [rdi-650h], xmm0
              vmovss  xmm1, dword ptr [rsp+178h+outOrigin+4]
              vmovss  dword ptr [rdi-64Ch], xmm1
              vmovss  xmm0, dword ptr [rsp+178h+outOrigin+8]
              vmovss  dword ptr [rdi-648h], xmm0
            }
          }
        }
        ++v15;
        ++voiceAlloc;
        _RDI += 492;
      }
      while ( v15 < 99 );
      memset(&outOrigin, 0, sizeof(outOrigin));
    }
    _R11 = &v70;
    __asm
    {
      vmovaps xmm6, xmmword ptr [r11-10h]
      vmovaps xmm7, xmmword ptr [r11-20h]
      vmovaps xmm8, xmmword ptr [r11-30h]
      vmovaps xmm9, xmmword ptr [r11-40h]
      vmovaps xmm10, xmmword ptr [r11-50h]
      vmovaps xmm11, xmmword ptr [r11-60h]
      vmovaps xmm12, xmmword ptr [r11-70h]
      vmovaps xmm13, xmmword ptr [r11-80h]
      vmovaps xmm14, xmmword ptr [r11-90h]
    }
  }
}

/*
==============
CG_SND_UpdateReverbs
==============
*/
void CG_SND_UpdateReverbs(int frametime)
{
  bool v16; 
  __int64 v17; 
  bool *voiceAlloc; 
  unsigned int v19; 
  unsigned int *p_propagationTriggerIndex; 
  unsigned int i; 
  int v22; 
  __int64 v23; 
  bool v24; 
  unsigned int roomTypeId; 
  unsigned int v26; 
  int v27; 
  int v28; 
  __int64 v29; 
  int v30; 
  unsigned int v31; 
  unsigned int v32; 
  unsigned int v33; 
  __int64 v34; 
  __int64 v35; 
  _BOOL8 v36; 
  __int64 v37; 
  __int64 v38; 
  const dvar_t *v72; 
  int v79; 
  unsigned int PlayerAudioTriggerIndex; 
  unsigned int PlayerAudioBlendTriggerIndex; 
  unsigned int v82; 
  unsigned int v83; 
  unsigned int v84; 
  float *v85; 
  unsigned int v101; 
  unsigned int *reverbTrigger; 
  float (*reverbPan)[64]; 
  unsigned int v105; 
  __int64 v119; 
  float *v120; 
  __int64 v121; 
  float spreadMinDist; 
  float spreadMinDista; 
  float v128; 
  float v129; 
  float v130; 
  float v131; 
  float v132; 
  float v133; 
  unsigned int outTrigger1[2]; 
  ReverbDef *outReverbDef; 
  ReverbDef *v136; 
  ReverbDef *v137; 
  vec3_t delta; 
  vec3_t inOutPoint; 
  vec3_t outCenter; 
  vec3_t v141; 
  SndPropagationWorkerCmd cmd; 
  snd_listener outListener; 
  unsigned int triggerList[100]; 
  char v148; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-78h], xmm10
  }
  if ( g_snd.doPropagationRecalc )
  {
    SND_RecalcPropagation();
    g_snd.doPropagationRecalc = 0;
  }
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, ebx
    vmulss  xmm1, xmm0, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS; snd_local_t g_snd
    vaddss  xmm0, xmm1, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current; val
    vxorps  xmm1, xmm1, xmm1; min
    vmovaps xmm2, xmm6; max
    vxorps  xmm10, xmm10, xmm10
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm0; snd_local_t g_snd }
  SND_GetListener(LOCAL_CLIENT_0, &outListener);
  if ( !outListener.active && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 13414, ASSERT_TYPE_ASSERT, "(listener.active)", (const char *)&queryFormat, "listener.active") )
    __debugbreak();
  __asm
  {
    vmovss  dword ptr [rbp+270h+outCenter], xmm10
    vmovss  dword ptr [rbp+270h+outCenter+4], xmm10
    vmovss  dword ptr [rbp+270h+outCenter+8], xmm10
    vmovss  dword ptr [rbp+270h+var_2D0], xmm10
    vmovss  dword ptr [rbp+270h+var_2D0+4], xmm10
    vmovss  dword ptr [rbp+270h+var_2D0+8], xmm10
  }
  v16 = 0;
  v137 = (ReverbDef *)Sys_Microseconds();
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "SND_FarReverbs");
  v17 = 0i64;
  voiceAlloc = sdGlob.voiceAlloc;
  v19 = 0;
  p_propagationTriggerIndex = &g_snd.voices[0].propagationTriggerIndex;
  for ( i = 0; i < 0x63; ++i )
  {
    if ( *voiceAlloc && *p_propagationTriggerIndex != 1024 && SND_EntChannelFarReverbBehavior((unsigned __int8)(*(int *)(*((_QWORD *)p_propagationTriggerIndex - 13) + 112i64) >> 10)) )
    {
      v22 = 0;
      if ( v19 )
      {
        while ( triggerList[v22] != *p_propagationTriggerIndex )
        {
          if ( ++v22 >= v19 )
            goto LABEL_13;
        }
      }
      else
      {
LABEL_13:
        v23 = v19++;
        triggerList[v23] = *p_propagationTriggerIndex;
      }
    }
    ++voiceAlloc;
    p_propagationTriggerIndex += 492;
  }
  v24 = 0;
  if ( v19 )
  {
    outReverbDef = NULL;
    v136 = NULL;
    CG_GetNearestTwoPropagationTriggers(outListener.localClientNum, &outListener.orient.origin, triggerList, v19, outTrigger1, &outTrigger1[1]);
    roomTypeId = 0;
    v26 = 0;
    CG_GetReverbDefForTrigger(outListener.localClientNum, outTrigger1[0], &outListener.orient.origin, (const ReverbDef **)&outReverbDef);
    v27 = -1;
    if ( outReverbDef )
      roomTypeId = outReverbDef->roomTypeId;
    if ( g_snd.farReverbIds[0] == roomTypeId )
    {
      v28 = 0;
    }
    else
    {
      v28 = -1;
      if ( g_snd.farReverbIds[1] == roomTypeId )
        v28 = 1;
    }
    if ( v19 <= 1 )
    {
      if ( v28 == -1 )
      {
        v36 = g_snd.farReverbTimestamp[0] >= g_snd.farReverbTimestamp[1];
        v37 = (unsigned int)(g_snd.farReverbTimestamp[0] >= g_snd.farReverbTimestamp[1]) + 2;
        g_snd.farReverbIds[v36] = roomTypeId;
        g_snd.reverbTrigger[v37] = outTrigger1[0];
        SND_SetReverbParams(roomTypeId, (ReverbDescriptor)v37, 1);
        g_snd.farReverbTimestamp[v36] = g_snd.time;
      }
      else
      {
        v38 = 3i64;
        g_snd.farReverbIds[v28] = roomTypeId;
        if ( !v28 )
          v38 = 2i64;
        g_snd.reverbTrigger[v38] = outTrigger1[0];
      }
      goto LABEL_52;
    }
    CG_GetReverbDefForTrigger(outListener.localClientNum, outTrigger1[1], &outListener.orient.origin, (const ReverbDef **)&v136);
    if ( v136 )
      v26 = v136->roomTypeId;
    if ( g_snd.farReverbIds[0] == v26 )
    {
      v27 = 0;
    }
    else if ( g_snd.farReverbIds[1] == v26 )
    {
      v27 = 1;
    }
    if ( v27 == v28 )
      v27 = v28 == 0;
    if ( v28 == -1 )
    {
      if ( v27 == -1 )
      {
        g_snd.reverbTrigger[2] = outTrigger1[0];
        g_snd.reverbTrigger[3] = outTrigger1[1];
        g_snd.farReverbIds[0] = roomTypeId;
        g_snd.farReverbIds[1] = v26;
        SND_SetReverbParams(roomTypeId, RVB_FAR_A, 1);
        SND_SetReverbParams(v26, RVB_FAR_B, 1);
        g_snd.farReverbTimestamp[0] = g_snd.time;
        g_snd.farReverbTimestamp[1] = g_snd.time;
        goto LABEL_52;
      }
      v29 = 0i64;
      if ( v27 != 1 )
        v29 = 1i64;
      v30 = (v27 != 1) + 2;
      v31 = outTrigger1[0];
      g_snd.farReverbIds[v29] = roomTypeId;
      g_snd.reverbTrigger[v30] = v31;
      v32 = roomTypeId;
    }
    else
    {
      if ( v27 != -1 )
      {
        v34 = (unsigned int)(v28 != 0) + 2;
        if ( g_snd.farReverbIds[v28] != roomTypeId )
        {
          SND_SetReverbParams(roomTypeId, (ReverbDescriptor)v34, 1);
          g_snd.farReverbIds[v28] = roomTypeId;
        }
        g_snd.reverbTrigger[v34] = outTrigger1[0];
        v35 = (unsigned int)(v27 != 0) + 2;
        if ( g_snd.farReverbIds[v27] != v26 )
        {
          SND_SetReverbParams(v26, (ReverbDescriptor)v35, 1);
          g_snd.farReverbIds[v27] = v26;
        }
        g_snd.reverbTrigger[v35] = outTrigger1[1];
        goto LABEL_52;
      }
      v29 = 0i64;
      if ( v28 != 1 )
        v29 = 1i64;
      v30 = (v28 != 1) + 2;
      v33 = outTrigger1[1];
      g_snd.farReverbIds[v29] = v26;
      g_snd.reverbTrigger[v30] = v33;
      v32 = v26;
    }
    SND_SetReverbParams(v32, (ReverbDescriptor)v30, 1);
    g_snd.farReverbTimestamp[v29] = g_snd.time;
LABEL_52:
    __asm
    {
      vmovaps xmmword ptr [rsp+370h+var_48+8], xmm7
      vmovaps [rsp+370h+var_58+8], xmm8
      vmovaps [rsp+370h+var_68+8], xmm9
    }
    if ( g_snd.reverbTrigger[2] == 1024 || !CG_GetTriggerCenter(outListener.localClientNum, g_snd.reverbTrigger[2], &outCenter) )
    {
      v24 = 0;
      memset_0(sdGlob.reverbPan[2], 0, sizeof(sdGlob.reverbPan[2]));
      __asm
      {
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+200h, xmm6; SDLocal sdGlob
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+244h, xmm6; SDLocal sdGlob
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+290h, xmm6; SDLocal sdGlob
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+2D4h, xmm6; SDLocal sdGlob
        vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+18h, xmm10; snd_local_t g_snd
        vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+1Ch, xmm10; snd_local_t g_snd
        vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+20h, xmm10; snd_local_t g_snd
      }
    }
    else
    {
      if ( g_snd.reverbTriggerOutputNumberA == g_snd.reverbTrigger[2] )
      {
        __asm
        {
          vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPortalPropagationOutputA; snd_local_t g_snd
          vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPortalPropagationOutputA+4; snd_local_t g_snd
          vmovss  xmm2, dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPortalPropagationOutputA+8; snd_local_t g_snd
          vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+18h, xmm0; snd_local_t g_snd
          vsubss  xmm0, xmm0, dword ptr [rbp+270h+outListener.orient.origin]
          vmovss  dword ptr [rsp+370h+delta], xmm0
          vsubss  xmm0, xmm2, dword ptr [rbp+270h+outListener.orient.origin+8]
          vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+1Ch, xmm1; snd_local_t g_snd
          vsubss  xmm1, xmm1, dword ptr [rbp+270h+outListener.orient.origin+4]
          vmovss  dword ptr [rsp+370h+delta+8], xmm0
          vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+20h, xmm2; snd_local_t g_snd
          vmovss  dword ptr [rsp+370h+delta+4], xmm1
        }
        memset_0(sdGlob.reverbPan[2], 0, sizeof(sdGlob.reverbPan[2]));
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMaxAngle;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMaxAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMaxAngle") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm9, dword ptr [rbx+28h] }
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMax;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMax") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm8, dword ptr [rbx+28h] }
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMax;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMax") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm7, dword ptr [rbx+28h] }
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMin;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMin") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+28h]
          vmovss  [rsp+370h+var_328], xmm9
          vmovss  [rsp+370h+var_330], xmm8
          vmovss  [rsp+370h+var_338], xmm7
          vmovss  [rsp+370h+spreadMinDist], xmm0
          vmovaps xmm3, xmm10; dist
        }
        SND_Spatialize51(sdGlob.reverbPan[2], &delta, &outListener, *(const float *)&_XMM3, 2, 0, spreadMinDist, v128, v130, v132);
      }
      v24 = 1;
    }
    if ( g_snd.reverbTrigger[3] == 1024 || !CG_GetTriggerCenter(outListener.localClientNum, g_snd.reverbTrigger[3], &v141) )
    {
      v16 = 0;
      memset_0(sdGlob.reverbPan[3], 0, sizeof(sdGlob.reverbPan[3]));
      __asm
      {
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+300h, xmm6; SDLocal sdGlob
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+344h, xmm6; SDLocal sdGlob
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+390h, xmm6; SDLocal sdGlob
        vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+3D4h, xmm6; SDLocal sdGlob
        vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+24h, xmm10; snd_local_t g_snd
        vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+28h, xmm10; snd_local_t g_snd
        vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+2Ch, xmm10; snd_local_t g_snd
      }
    }
    else
    {
      if ( g_snd.reverbTriggerOutputNumberB == g_snd.reverbTrigger[3] )
      {
        __asm
        {
          vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPortalPropagationOutputB; snd_local_t g_snd
          vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPortalPropagationOutputB+4; snd_local_t g_snd
          vmovss  xmm2, dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPortalPropagationOutputB+8; snd_local_t g_snd
          vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+24h, xmm0; snd_local_t g_snd
          vsubss  xmm0, xmm0, dword ptr [rbp+270h+outListener.orient.origin]
          vmovss  dword ptr [rsp+370h+delta], xmm0
          vsubss  xmm0, xmm2, dword ptr [rbp+270h+outListener.orient.origin+8]
          vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+28h, xmm1; snd_local_t g_snd
          vsubss  xmm1, xmm1, dword ptr [rbp+270h+outListener.orient.origin+4]
          vmovss  dword ptr [rsp+370h+delta+8], xmm0
          vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+2Ch, xmm2; snd_local_t g_snd
          vmovss  dword ptr [rsp+370h+delta+4], xmm1
        }
        memset_0(sdGlob.reverbPan[3], 0, sizeof(sdGlob.reverbPan[3]));
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMaxAngle;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMaxAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMaxAngle") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm9, dword ptr [rbx+28h] }
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMax;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMax") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm8, dword ptr [rbx+28h] }
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMax;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMax") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm7, dword ptr [rbx+28h] }
        _RBX = DCONST_DVARFLT_snd_farReverbSpreadMin;
        if ( !DCONST_DVARFLT_snd_farReverbSpreadMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farReverbSpreadMin") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+28h]
          vmovss  [rsp+370h+var_328], xmm9
          vmovss  [rsp+370h+var_330], xmm8
          vmovss  [rsp+370h+var_338], xmm7
          vmovss  [rsp+370h+spreadMinDist], xmm0
          vmovaps xmm3, xmm10; dist
        }
        SND_Spatialize51(sdGlob.reverbPan[3], &delta, &outListener, *(const float *)&_XMM3, 2, 0, spreadMinDista, v129, v131, v133);
      }
      v16 = 1;
    }
    __asm
    {
      vmovaps xmm8, [rsp+370h+var_58+8]
      vmovaps xmm7, xmmword ptr [rsp+370h+var_48+8]
      vmovaps xmm9, [rsp+370h+var_68+8]
    }
  }
  if ( (v24 || v16) && !Sys_ExistsWorkerCmdsOfType(WRKCMD_SOUND_PROPAGATION) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+270h+outListener.orient.origin]
      vmovss  xmm1, dword ptr [rbp+270h+outListener.orient.origin+4]
    }
    v72 = DCONST_DVARINT_snd_debugPropagation;
    cmd.reverbTriggerInputNumberA = g_snd.reverbTrigger[2];
    cmd.runPropagationForReverbA = v24;
    cmd.runPropagationForReverbB = v16;
    cmd.reverbTriggerInputNumberB = g_snd.reverbTrigger[3];
    __asm
    {
      vmovss  dword ptr [rbp+270h+cmd.reverbListenerOrigin], xmm0
      vmovss  xmm0, dword ptr [rbp+270h+outListener.orient.origin+8]
      vmovss  dword ptr [rbp+270h+cmd.reverbListenerOrigin+8], xmm0
      vmovss  xmm0, dword ptr [rbp+270h+outCenter+4]
      vmovss  dword ptr [rbp+270h+cmd.reverbListenerOrigin+4], xmm1
      vmovss  xmm1, dword ptr [rbp+270h+outCenter]
      vmovss  dword ptr [rbp+270h+cmd.reverbTriggerPropagationInputA+4], xmm0
      vmovss  xmm0, dword ptr [rbp+270h+var_2D0]
      vmovss  dword ptr [rbp+270h+cmd.reverbTriggerPropagationInputA], xmm1
      vmovss  xmm1, dword ptr [rbp+270h+outCenter+8]
      vmovss  dword ptr [rbp+270h+cmd.reverbTriggerPropagationInputB], xmm0
      vmovss  xmm0, dword ptr [rbp+270h+var_2D0+8]
      vmovss  dword ptr [rbp+270h+cmd.reverbTriggerPropagationInputA+8], xmm1
      vmovss  xmm1, dword ptr [rbp+270h+var_2D0+4]
      vmovss  dword ptr [rbp+270h+cmd.reverbTriggerPropagationInputB+8], xmm0
      vmovss  dword ptr [rbp+270h+cmd.reverbTriggerPropagationInputB+4], xmm1
    }
    if ( !DCONST_DVARINT_snd_debugPropagation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debugPropagation") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v72);
    if ( v72->current.integer <= 0 )
      Sys_AddWorkerCmd(WRKCMD_SOUND_PROPAGATION, &cmd);
    else
      SND_UpdatePropagation(&cmd);
  }
  g_snd.updateFarReverbsUsec = Sys_Microseconds() - (_DWORD)v137;
  Sys_ProfEndNamedEvent();
  v79 = Sys_Microseconds();
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "SND_PlayerReverbs");
  PlayerAudioTriggerIndex = CG_GetPlayerAudioTriggerIndex((const LocalClientNum_t)outListener.localClientNum);
  PlayerAudioBlendTriggerIndex = CG_GetPlayerAudioBlendTriggerIndex((const LocalClientNum_t)outListener.localClientNum);
  if ( CG_GetBlendedAudioTriggers(PlayerAudioBlendTriggerIndex, outTrigger1, &outTrigger1[1]) )
  {
    PlayerAudioTriggerIndex = outTrigger1[0];
  }
  else
  {
    outTrigger1[0] = PlayerAudioTriggerIndex;
    outTrigger1[1] = PlayerAudioTriggerIndex;
  }
  if ( PlayerAudioTriggerIndex == 1024 )
  {
    memset_0(sdGlob.reverbPan, 0, 0x200ui64);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovups xmmword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition, xmm0; snd_local_t g_snd
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan, xmm6; SDLocal sdGlob
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+44h, xmm6; SDLocal sdGlob
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+90h, xmm6; SDLocal sdGlob
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+0D4h, xmm6; SDLocal sdGlob
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+100h, xmm6; SDLocal sdGlob
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+144h, xmm6; SDLocal sdGlob
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+190h, xmm6; SDLocal sdGlob
      vmovss  cs:?sdGlob@@3USDLocal@@A.reverbPan+1D4h, xmm6; SDLocal sdGlob
      vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+10h, xmm10; snd_local_t g_snd
      vmovss  dword ptr cs:?g_snd@@3Usnd_local_t@@A.reverbPosition+14h, xmm10; snd_local_t g_snd
    }
    goto LABEL_130;
  }
  v136 = NULL;
  v137 = NULL;
  v82 = 4;
  CG_GetReverbDefForTrigger(outListener.localClientNum, PlayerAudioTriggerIndex, &outListener.orient.origin, (const ReverbDef **)&v136);
  if ( v136 )
    v83 = v136->roomTypeId;
  else
    v83 = 0;
  if ( sdGlob.currentReverbId[0] == v83 )
  {
    v82 = 0;
  }
  else
  {
    if ( sdGlob.currentReverbId[1] != v83 )
      goto LABEL_111;
    v82 = 1;
  }
  v84 = outTrigger1[0];
  g_snd.reverbTrigger[v82] = outTrigger1[0];
  v85 = sdGlob.reverbPan[(unsigned __int64)v82];
  memset_0(v85, 0, 0x100ui64);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+270h+outListener.orient.origin]
    vmovss  xmm1, dword ptr [rbp+270h+outListener.orient.origin+4]
    vmovss  dword ptr [rbp+270h+inOutPoint], xmm0
    vmovss  xmm0, dword ptr [rbp+270h+outListener.orient.origin+8]
    vmovss  dword ptr [rbp+270h+inOutPoint+8], xmm0
    vmovss  dword ptr [rbp+270h+inOutPoint+4], xmm1
  }
  _RBX = 3i64 * v82;
  if ( CG_GetWallProximityVolume(outListener.localClientNum, v84, &inOutPoint, (float *)&outReverbDef) )
  {
    CG_GetTriggerCenter(outListener.localClientNum, outTrigger1[0], &delta);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+370h+delta]
      vsubss  xmm1, xmm0, dword ptr [rbp+270h+inOutPoint]
      vmovss  xmm2, dword ptr [rsp+370h+delta+4]
      vsubss  xmm0, xmm2, dword ptr [rbp+270h+inOutPoint+4]
      vmovss  xmm3, dword ptr [rsp+370h+outReverbDef]; minVol
      vmovss  dword ptr [rsp+370h+delta], xmm1
      vmovss  xmm1, dword ptr [rsp+370h+delta+8]
      vsubss  xmm2, xmm1, dword ptr [rbp+270h+inOutPoint+8]
      vmovss  dword ptr [rsp+370h+delta+8], xmm2
      vmovss  dword ptr [rsp+370h+delta+4], xmm0
    }
    SND_SpatializeReverb(v85, &delta, &outListener, *(const float *)&_XMM3);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+370h+delta]
      vmovss  xmm1, dword ptr [rsp+370h+delta+4]
    }
    _R13 = 0x140000000ui64;
    __asm
    {
      vmovss  dword ptr rva ?g_snd@@3Usnd_local_t@@A.reverbPosition[r13+rbx*4], xmm0; snd_local_t g_snd
      vmovss  xmm0, dword ptr [rsp+370h+delta+8]
      vmovss  dword ptr (rva ?g_snd@@3Usnd_local_t@@A.reverbPosition+8)[r13+rbx*4], xmm0; snd_local_t g_snd
      vmovss  dword ptr (rva ?g_snd@@3Usnd_local_t@@A.reverbPosition+4)[r13+rbx*4], xmm1; snd_local_t g_snd
    }
  }
  else
  {
    *v85 = 1.0;
    *(_QWORD *)g_snd.reverbPosition[v82].v = 0i64;
    g_snd.reverbTrigger[3 * v82 - 10] = 0;
    v85[17] = 1.0;
    v85[36] = 1.0;
    v85[53] = 1.0;
  }
LABEL_111:
  if ( outTrigger1[0] == outTrigger1[1] )
  {
    v119 = 0i64;
    if ( !v82 )
      v119 = 1i64;
    v120 = sdGlob.reverbPan[v119];
    memset_0(sdGlob.reverbPan[v119], 0, sizeof(sdGlob.reverbPan[v119]));
    *v120 = 1.0;
    v121 = 0i64;
    v120[17] = 1.0;
    v120[36] = 1.0;
    v120[53] = 1.0;
    if ( !v82 )
      v121 = 1i64;
    *(_QWORD *)g_snd.reverbPosition[v121].v = 0i64;
    g_snd.reverbTrigger[3 * v121 - 10] = 0;
    if ( !v82 )
      v17 = 1i64;
    g_snd.reverbTrigger[v17] = 1024;
  }
  else
  {
    CG_GetReverbDefForTrigger(outListener.localClientNum, outTrigger1[1], &outListener.orient.origin, (const ReverbDef **)&v137);
    if ( v137 )
      v101 = v137->roomTypeId;
    else
      v101 = 0;
    if ( sdGlob.currentReverbId[0] == v101 )
    {
      reverbTrigger = g_snd.reverbTrigger;
      reverbPan = sdGlob.reverbPan;
      _R14 = g_snd.reverbPosition;
    }
    else
    {
      if ( sdGlob.currentReverbId[1] != v101 )
        goto LABEL_130;
      reverbTrigger = &g_snd.reverbTrigger[1];
      reverbPan = (float (*)[64])sdGlob.reverbPan[1];
      _R14 = &g_snd.reverbPosition[1];
    }
    v105 = outTrigger1[1];
    *reverbTrigger = outTrigger1[1];
    memset_0(reverbPan, 0, sizeof(float[64]));
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+270h+outListener.orient.origin]
      vmovss  xmm1, dword ptr [rbp+270h+outListener.orient.origin+4]
      vmovss  dword ptr [rbp+270h+inOutPoint], xmm0
      vmovss  xmm0, dword ptr [rbp+270h+outListener.orient.origin+8]
      vmovss  dword ptr [rbp+270h+inOutPoint+8], xmm0
      vmovss  dword ptr [rbp+270h+inOutPoint+4], xmm1
    }
    if ( CG_GetWallProximityVolume(outListener.localClientNum, v105, &inOutPoint, (float *)&outReverbDef) )
    {
      CG_GetTriggerCenter(outListener.localClientNum, outTrigger1[1], &delta);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+370h+delta]
        vsubss  xmm1, xmm0, dword ptr [rbp+270h+inOutPoint]
        vmovss  xmm2, dword ptr [rsp+370h+delta+4]
        vsubss  xmm0, xmm2, dword ptr [rbp+270h+inOutPoint+4]
        vmovss  xmm3, dword ptr [rsp+370h+outReverbDef]; minVol
        vmovss  dword ptr [rsp+370h+delta], xmm1
        vmovss  xmm1, dword ptr [rsp+370h+delta+8]
        vsubss  xmm2, xmm1, dword ptr [rbp+270h+inOutPoint+8]
        vmovss  dword ptr [rsp+370h+delta+8], xmm2
        vmovss  dword ptr [rsp+370h+delta+4], xmm0
      }
      SND_SpatializeReverb((float *)reverbPan, &delta, &outListener, *(const float *)&_XMM3);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+370h+delta]
        vmovss  xmm1, dword ptr [rsp+370h+delta+4]
        vmovss  dword ptr [r14], xmm0
        vmovss  xmm0, dword ptr [rsp+370h+delta+8]
        vmovss  dword ptr [r14+8], xmm0
        vmovss  dword ptr [r14+4], xmm1
      }
    }
    else
    {
      *(_DWORD *)reverbPan = 1065353216;
      (*reverbPan)[17] = 1.0;
      (*reverbPan)[36] = 1.0;
      (*reverbPan)[53] = 1.0;
      *(_QWORD *)_R14->v = 0i64;
      _R14->v[2] = 0.0;
    }
  }
LABEL_130:
  g_snd.updatePlayerReverbUsec = Sys_Microseconds() - v79;
  Sys_ProfEndNamedEvent();
  _R11 = &v148;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
CheckIfClosestID
==============
*/
void CheckIfClosestID(int idx, const vec3_t *org, const orientation_t *listener, int *closestId, float *closestIdDotProd)
{
  bool v12; 
  bool v13; 
  __int128 v42; 
  char v45; 

  _RBX = closestIdDotProd;
  __asm
  {
    vmovaps [rsp+78h+var_28], xmm6
    vmovaps [rsp+78h+var_38], xmm7
  }
  _R14 = org;
  __asm { vmovaps [rsp+78h+var_48], xmm8 }
  if ( !closestId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8067, ASSERT_TYPE_ASSERT, "(closestId)", (const char *)&queryFormat, "closestId", v42) )
    __debugbreak();
  v12 = closestIdDotProd == NULL;
  if ( !closestIdDotProd )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8068, ASSERT_TYPE_ASSERT, "(closestIdDotProd)", (const char *)&queryFormat, "closestIdDotProd");
    v12 = !v13;
    if ( v13 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vsubss  xmm8, xmm0, dword ptr [rbp+0]
    vmovss  xmm1, dword ptr [r14+4]
    vsubss  xmm6, xmm1, dword ptr [rbp+4]
    vmovss  xmm0, dword ptr [r14+8]
    vsubss  xmm7, xmm0, dword ptr [rbp+8]
    vmulss  xmm0, xmm7, xmm7
    vmulss  xmm2, xmm6, xmm6
    vmulss  xmm1, xmm8, xmm8
    vaddss  xmm3, xmm2, xmm1
    vmovss  xmm1, cs:__real@3f800000
    vaddss  xmm2, xmm3, xmm0
    vsqrtss xmm4, xmm2, xmm2
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm1, xmm0
    vdivss  xmm5, xmm1, xmm0
    vmulss  xmm0, xmm6, xmm5
    vmulss  xmm3, xmm0, dword ptr [rbp+10h]
    vmulss  xmm1, xmm8, xmm5
    vmulss  xmm2, xmm1, dword ptr [rbp+0Ch]
    vmulss  xmm0, xmm7, xmm5
    vmulss  xmm1, xmm0, dword ptr [rbp+14h]
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm2, xmm4, xmm1
    vcomiss xmm2, dword ptr [rbx]
  }
  if ( !v12 )
  {
    *closestId = idx;
    __asm { vmovss  dword ptr [rbx], xmm2 }
  }
  __asm { vmovaps xmm6, [rsp+78h+var_28] }
  _R11 = &v45;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm7, [rsp+78h+var_38]
  }
}

/*
==============
Com_GetSoundAliasSeed
==============
*/
__int64 Com_GetSoundAliasSeed()
{
  return (unsigned int)randSeed;
}

/*
==============
Com_GetSoundFileName
==============
*/
void Com_GetSoundFileName(const SndAlias *alias, char *filename, unsigned __int64 filenameSize)
{
  const char *assetFileName; 

  assetFileName = "null";
  if ( alias->assetFileName )
    assetFileName = alias->assetFileName;
  Core_strcpy(filename, filenameSize, assetFileName);
}

/*
==============
Com_GetSpeakerLevels
==============
*/
float *Com_GetSpeakerLevels(const SpeakerMap *speakerMap, int sourceChannelCount, int *outSpeakermapChannelCount)
{
  if ( g_snd.playback_channels < 16 )
  {
    if ( g_snd.playback_channels < 8 )
    {
      if ( g_snd.playback_channels == 6 )
      {
        *outSpeakermapChannelCount = 6;
        if ( sourceChannelCount == 2 )
          return speakerMap->stereoTo51;
        if ( sourceChannelCount == 1 )
          return speakerMap->monoTo51;
      }
      else if ( g_snd.playback_channels == 2 )
      {
        *outSpeakermapChannelCount = 2;
        if ( sourceChannelCount == 2 )
          return speakerMap->stereoToStereo;
        if ( sourceChannelCount == 1 )
          return speakerMap->monoToStereo;
      }
    }
    else
    {
      *outSpeakermapChannelCount = 8;
      if ( sourceChannelCount == 2 )
        return speakerMap->stereoTo71;
      if ( sourceChannelCount == 1 )
        return speakerMap->monoTo71;
    }
  }
  else
  {
    *outSpeakermapChannelCount = 16;
    if ( sourceChannelCount == 2 )
      return speakerMap->stereoTo7144;
    if ( sourceChannelCount == 1 )
      return speakerMap->monoTo7144;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14967, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid audio channel count") )
    __debugbreak();
  *outSpeakermapChannelCount = 0;
  return 0i64;
}

/*
==============
Com_SetSoundAliasSeed
==============
*/
void Com_SetSoundAliasSeed(int seed)
{
  randSeed = seed;
}

/*
==============
DebugDrawWorldSound3D
==============
*/
void DebugDrawWorldSound3D(int idx, int debugDrawStyle, EntityDebugDrawOffset *drawOffset, int *closestId, float *closestIdDotProd)
{
  __int64 v12; 
  SndVoice *v13; 
  char v23; 
  unsigned __int64 v26; 
  __int64 v27; 
  __int64 numEntIndices; 
  int v29; 
  __int64 i; 
  unsigned __int64 v36; 
  float dista; 
  vec3_t to; 
  vec3_t outListenerSpaceVoicePosition; 
  tmat33_t<vec3_t> outVoiceOrientation; 
  snd_listener outListener; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-58h], xmm7 }
  v12 = idx;
  __asm { vmovaps xmmword ptr [r11-68h], xmm8 }
  if ( (unsigned int)idx > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8281, ASSERT_TYPE_ASSERT, "( ( ( idx >= 0 ) && ( idx < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) ) )", "( idx ) = %i", idx) )
    __debugbreak();
  v13 = &g_snd.voices[v12];
  if ( !v13->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8284, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
    __debugbreak();
  __asm { vmovaps [rsp+178h+var_48], xmm6 }
  SND_CalcVoice3DInfo(&g_snd.voices[v12], &outListener, &outListenerSpaceVoicePosition, &outVoiceOrientation);
  GetSecureSndVec3(&v13->org.origin, &to, s_soundvoiceorg_aab_X, s_soundvoiceorg_aab_Y, s_soundvoiceorg_aab_Z);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+178h+outListenerSpaceVoicePosition]
    vmovss  xmm1, dword ptr [rsp+178h+outListenerSpaceVoicePosition+4]
    vmulss  xmm2, xmm1, xmm1
    vmulss  xmm3, xmm0, xmm0
    vmovss  xmm0, dword ptr [rsp+178h+outListenerSpaceVoicePosition+8]
    vmulss  xmm1, xmm0, xmm0
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm2, xmm4, xmm1
    vsqrtss xmm8, xmm2, xmm2
    vcomiss xmm8, cs:__real@41200000
  }
  if ( v23 )
    __asm { vmovss  xmm6, cs:__real@3f400000 }
  else
    __asm { vmulss  xmm6, xmm8, cs:__real@3cd70a3d }
  v26 = v13->sndEnt & 0x1FFFFFFFFi64;
  v27 = 0i64;
  if ( v26 - 5411 <= 0x1F || v26 - 2049 <= 0x8FF || v26 <= 0x7FD || v26 - 5571 <= 0x7A120 )
    v27 = v13->sndEnt & 0x1FFFFFFFFi64;
  if ( debugDrawStyle != 3 )
    CheckIfClosestID(v12, &to, &outListener.orient, closestId, closestIdDotProd);
  numEntIndices = drawOffset->numEntIndices;
  v29 = 0;
  __asm { vmovss  xmm7, dword ptr [rsp+178h+to+8] }
  if ( numEntIndices > 0 )
  {
    for ( i = 0i64; i < numEntIndices; ++i )
    {
      if ( drawOffset->entIndices[i] == v27 )
        break;
      ++v29;
    }
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, r14d
    vaddss  xmm1, xmm7, xmm0
    vmovss  [rsp+178h+dist], xmm8
    vmovss  dword ptr [rsp+178h+to+8], xmm1
  }
  DebugDrawWorldSoundText(debugDrawStyle, v12, v27, &to, &outVoiceOrientation, dista);
  __asm { vmovaps xmm8, [rsp+178h+var_68] }
  v36 = v13->sndEnt & 0x1FFFFFFFFi64;
  if ( v36 - 5411 <= 0x1F || v36 - 2049 <= 0x8FF || v36 <= 0x7FD || v36 - 5571 <= 0x7A120 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+178h+to+8]
      vsubss  xmm1, xmm0, xmm6
      vsubss  xmm2, xmm1, xmm7
      vcvttss2si r8d, xmm2; offset
    }
    EntityDebugDrawOffset::SetOffset(drawOffset, v27, _ER8);
  }
  __asm
  {
    vmovaps xmm6, [rsp+178h+var_48]
    vmovaps xmm7, [rsp+178h+var_58]
  }
}

/*
==============
DebugDrawWorldSoundPASpeaker
==============
*/
void DebugDrawWorldSoundPASpeaker(int idx, int debugDrawStyle, EntityDebugDrawOffset *drawOffset, int *closestId, float *closestIdDotProd)
{
  __int64 v14; 
  __int64 v15; 
  char *v16; 
  __int64 v17; 
  unsigned __int64 v18; 
  bool v19; 
  unsigned int v24; 
  __int64 i; 
  signed int audioPASpeakerCount; 
  unsigned int v28; 
  unsigned int AliasEntChannelId; 
  unsigned int v30; 
  unsigned int entChannelHash; 
  AudioPASpeaker *audioPASpeakers; 
  vec3_t *v33; 
  char v46; 
  unsigned __int64 v52; 
  int Offset; 
  int v55; 
  int v60; 
  MapEnts *mapEnts; 
  signed int v62; 
  int numEntIndices; 
  int v64; 
  int v65; 
  __int64 v66; 
  __int64 dist; 
  float dista; 
  __int64 v77; 
  snd_listener outListener; 
  char v81[256]; 
  vec3_t origin[64]; 
  char v86; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
  }
  v14 = idx;
  if ( (unsigned int)idx > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8202, ASSERT_TYPE_ASSERT, "( ( ( idx >= 0 ) && ( idx < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) ) )", "( idx ) = %i", idx) )
    __debugbreak();
  v15 = v14;
  if ( !g_snd.voices[v14].alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8205, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
    __debugbreak();
  memset_0(v81, 0, sizeof(v81));
  memset_0(v81, 0, sizeof(v81));
  memset_0(origin, 0, sizeof(origin));
  v16 = v81;
  v17 = 4i64;
  do
  {
    v16 += 64;
    --v17;
  }
  while ( v17 );
  v18 = g_snd.voices[v15].sndEnt & 0x1FFFFFFFFi64;
  v19 = v18 - 5411 > 0x1F && v18 - 2049 > 0x8FF && v18 > 0x7FD && v18 - 5571 > 0x7A120;
  __asm
  {
    vmovss  xmm12, cs:__real@41200000
    vmovss  xmm9, cs:__real@3d4ccccd
    vmovss  xmm10, cs:__real@3ae56042
    vmovss  xmm11, cs:__real@41700000
    vmovaps [rsp+598h+var_48], xmm6
    vmovaps [rsp+598h+var_58], xmm7
  }
  if ( v19 )
    v18 = 0i64;
  __asm { vmovaps [rsp+598h+var_68], xmm8 }
  v24 = 0;
  _R14 = &origin[0].v[2];
  for ( i = 0i64; ; i += 4i64 )
  {
    if ( cm.mapEnts )
    {
      if ( cm.mapEnts->audioPASpeakerCount >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 532, ASSERT_TYPE_ASSERT, "(cm.mapEnts->audioPASpeakerCount < 64)", (const char *)&queryFormat, "cm.mapEnts->audioPASpeakerCount < AUDIO_PA_SPEAKERS_MAXSIZE") )
        __debugbreak();
      audioPASpeakerCount = cm.mapEnts->audioPASpeakerCount;
    }
    else
    {
      audioPASpeakerCount = 0;
    }
    if ( (int)v24 >= audioPASpeakerCount )
      break;
    if ( v24 >= 0x40 )
    {
      LODWORD(v77) = 64;
      LODWORD(dist) = v24;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 14, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", dist, v77) )
        __debugbreak();
    }
    v28 = g_snd.paSpeakerDisabledArray[(__int64)(int)v24 >> 5];
    if ( !_bittest((const int *)&v28, v24 & 0x1F) )
    {
      AliasEntChannelId = SND_GetAliasEntChannelId(g_snd.voices[v15].alias);
      if ( cm.mapEnts )
      {
        v30 = cm.mapEnts->audioPASpeakerCount;
        if ( v30 > v24 )
        {
          entChannelHash = cm.mapEnts->audioPASpeakers[v24].entChannelHash;
          if ( entChannelHash && entChannelHash != AliasEntChannelId )
            goto LABEL_64;
          if ( v30 > v24 )
          {
            audioPASpeakers = cm.mapEnts->audioPASpeakers;
            *(_R14 - 2) = audioPASpeakers[v24].origin.v[0];
            *(_R14 - 1) = audioPASpeakers[v24].origin.v[1];
            *_R14 = audioPASpeakers[v24].origin.v[2];
          }
        }
      }
      v33 = &origin[v24];
      SND_GetListenerNearestToOrigin(v33, &outListener);
      __asm
      {
        vmovss  xmm0, dword ptr [r14-8]
        vmovss  xmm1, dword ptr [r14-4]
        vsubss  xmm2, xmm1, dword ptr [rsp+598h+outListener.orient.origin+4]
        vsubss  xmm4, xmm0, dword ptr [rsp+598h+outListener.orient.origin]
        vmovss  xmm6, dword ptr [r14]
        vsubss  xmm3, xmm6, dword ptr [rsp+598h+outListener.orient.origin+8]
        vmulss  xmm1, xmm2, xmm2
        vmulss  xmm0, xmm4, xmm4
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm3, xmm3
        vaddss  xmm2, xmm2, xmm1
        vsqrtss xmm7, xmm2, xmm2
        vcomiss xmm7, xmm12
      }
      if ( v46 )
        __asm { vmovaps xmm8, xmm9 }
      else
        __asm { vmulss  xmm8, xmm7, xmm10 }
      if ( debugDrawStyle != 3 )
      {
        CheckIfClosestID(v14, v33, &outListener.orient, closestId, closestIdDotProd);
        __asm { vmovss  xmm6, dword ptr [r14] }
      }
      EntityDebugDrawOffset::GetOffset(drawOffset, v18);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vaddss  xmm1, xmm0, xmm6
        vmovss  [rsp+598h+dist], xmm7
        vmovss  dword ptr [r14], xmm1
      }
      DebugDrawWorldSoundText(debugDrawStyle, v14, v18, v33, NULL, dista);
      v52 = g_snd.voices[v15].sndEnt & 0x1FFFFFFFFi64;
      if ( (v52 <= 0x7FD || v52 - 2049 <= 0x7AEE2) && (v52 < 0x1101 || v52 >= 0x1103 && v52 >= 0x1123 && v52 >= 0x1523) && (v52 < 0x1543 || v52 >= 0x15C3) )
      {
        Offset = EntityDebugDrawOffset::GetOffset(drawOffset, v18);
        __asm { vmovss  xmm0, dword ptr [r14] }
        v55 = Offset;
        __asm
        {
          vmulss  xmm1, xmm8, xmm11
          vsubss  xmm1, xmm0, xmm1
          vsubss  xmm2, xmm1, xmm6
          vcvttss2si eax, xmm2
        }
        v60 = _EAX + v55;
        mapEnts = cm.mapEnts;
        if ( cm.mapEnts )
        {
          if ( cm.mapEnts->audioPASpeakerCount >= 0x40 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 532, ASSERT_TYPE_ASSERT, "(cm.mapEnts->audioPASpeakerCount < 64)", (const char *)&queryFormat, "cm.mapEnts->audioPASpeakerCount < AUDIO_PA_SPEAKERS_MAXSIZE") )
              __debugbreak();
            mapEnts = cm.mapEnts;
          }
          v62 = mapEnts->audioPASpeakerCount;
        }
        else
        {
          v62 = 0;
        }
        numEntIndices = drawOffset->numEntIndices;
        v64 = v60 / v62;
        v65 = 0;
        v66 = 0i64;
        if ( numEntIndices <= 0 )
        {
LABEL_60:
          if ( (unsigned int)numEntIndices >= 0x63 )
          {
            LODWORD(v77) = 99;
            LODWORD(dist) = drawOffset->numEntIndices;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 300, ASSERT_TYPE_ASSERT, "(unsigned)( numEntIndices ) < (unsigned)( ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) )", "numEntIndices doesn't index SND_MAX_VOICES\n\t%i not in [0, %i)", dist, v77) )
              __debugbreak();
          }
          drawOffset->entIndices[drawOffset->numEntIndices] = v18;
          drawOffset->offsets[drawOffset->numEntIndices++] = v64;
        }
        else
        {
          while ( drawOffset->entIndices[v66] != v18 )
          {
            ++v65;
            ++v66;
            if ( v65 >= numEntIndices )
              goto LABEL_60;
          }
          drawOffset->offsets[v66] = v64;
        }
      }
    }
LABEL_64:
    ++v24;
    _R14 += 3;
  }
  __asm
  {
    vmovaps xmm8, [rsp+598h+var_68]
    vmovaps xmm7, [rsp+598h+var_58]
    vmovaps xmm6, [rsp+598h+var_48]
  }
  _R11 = &v86;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
}

/*
==============
DebugDrawWorldSoundText
==============
*/
void DebugDrawWorldSoundText(int debugDrawStyle, int idx, unsigned __int64 entIndex, vec3_t *org, const tmat33_t<vec3_t> *entityOrientation, float dist)
{
  __int64 v13; 
  unsigned __int64 v17; 
  bool v18; 
  vec4_t *v19; 
  const vec4_t *v21; 
  int v23; 
  int v24; 
  const SndAlias *alias; 
  const char *v28; 
  unsigned __int64 v29; 
  const char *EntChannelName; 
  const char *v35; 
  __int64 v39; 
  char *v40; 
  unsigned __int64 v41; 
  const char *assetFileName; 
  const SndAlias *v43; 
  unsigned __int64 v45; 
  const char *v48; 
  __int64 v50; 
  const char *v61; 
  const char *v69; 
  char v71; 
  const char *v78; 
  float fmt; 
  float v91; 
  vec3_t vRotation; 
  vec3_t out; 
  vec3_t vIn; 
  char dest[256]; 
  char v98; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _RBX = org;
  __asm { vmovss  xmm9, [rsp+208h+dist] }
  v13 = idx;
  *(_QWORD *)vRotation.v = entIndex;
  if ( (unsigned int)idx > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8089, ASSERT_TYPE_ASSERT, "( ( ( idx >= 0 ) && ( idx < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) ) )", "( idx ) = %i", idx) )
    __debugbreak();
  _RSI = v13;
  _RDI = &g_snd;
  if ( !g_snd.voices[v13].alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8092, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
    __debugbreak();
  v17 = g_snd.voices[_RSI].sndEnt & 0x1FFFFFFFFi64;
  v18 = v17 - 5411 > 0x1F && v17 - 2049 > 0x8FF && v17 > 0x7FD && v17 - 5571 > 0x7A120;
  v19 = &colorGreen;
  if ( !v18 )
    v19 = &colorLtCyan;
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm8, dword ptr [rsi+rdi+0CAE4h]
  }
  v21 = v19;
  __asm
  {
    vcomiss xmm9, cs:__real@41200000
    vmulss  xmm2, xmm9, cs:__real@3ae56042; scale
  }
  v23 = debugDrawStyle - 1;
  if ( v23 )
  {
    v24 = v23 - 1;
    if ( v24 )
    {
      if ( v24 == 1 )
      {
        __asm { vmovaps [rsp+208h+var_48], xmm6 }
        _RBP = &g_snd;
        alias = g_snd.voices[_RSI].alias;
        __asm
        {
          vmulss  xmm6, xmm2, cs:__real@3f59999a
          vmovaps [rsp+208h+var_58], xmm7
        }
        v28 = j_va("Alias: %s", alias->aliasName);
        v29 = g_snd.voices[_RSI].sndEnt & 0x1FFFFFFFFi64;
        if ( v29 - 2046 <= 2 || v29 >= 0x7B6E4 || v29 - 4353 <= 0x421 || v29 - 5443 <= 0x7F )
        {
          __asm { vmovss  dword ptr [rsp+208h+fmt], xmm6 }
          CL_AddDebugStarWithText(_RBX, v21, &colorWhiteFaded, v28, fmt, 0, 1, 0);
        }
        else
        {
          __asm { vmovaps xmm2, xmm6; scale }
          CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, v28, 0, 1);
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+8]
          vmulss  xmm7, xmm6, cs:__real@41400000
          vsubss  xmm1, xmm0, xmm7
          vmovss  dword ptr [rbx+8], xmm1
        }
        EntChannelName = SND_GetEntChannelName(g_snd.chaninfoEntchannel[v13]);
        v35 = j_va("Mix Channel: %s", EntChannelName);
        __asm { vmovaps xmm2, xmm6; scale }
        CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, v35, 0, 1);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+8]
          vsubss  xmm1, xmm0, xmm7
          vmovss  dword ptr [rbx+8], xmm1
        }
        strcpy(dest, "File: ");
        v39 = -1i64;
        do
          ++v39;
        while ( dest[v39] );
        v40 = &dest[v39];
        v41 = 256 - v39;
        assetFileName = "null";
        v43 = g_snd.voices[_RSI].alias;
        if ( v43->assetFileName )
          assetFileName = v43->assetFileName;
        Core_strcpy(v40, v41, assetFileName);
        __asm { vmovaps xmm2, xmm6; scale }
        CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, dest, 0, 1);
        v45 = g_snd.voices[_RSI].sndEnt & 0x1FFFFFFFFi64;
        if ( v45 - 5411 <= 0x1F || v45 - 2049 <= 0x8FF || v45 <= 0x7FD || v45 - 5571 <= 0x7A120 )
        {
          __asm { vmovss  xmm0, dword ptr [rbx+8] }
          v50 = *(_QWORD *)vRotation.v;
          __asm
          {
            vsubss  xmm1, xmm0, xmm7
            vmovss  dword ptr [rbx+8], xmm1
          }
          v48 = j_va("Owner: entity #%zu", v50);
        }
        else
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+8]
            vsubss  xmm1, xmm0, xmm7
            vmovss  dword ptr [rbx+8], xmm1
          }
          v48 = j_va("Owner: World");
        }
        __asm { vmovaps xmm2, xmm6; scale }
        CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, v48, 0, 1);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+8]
          vsubss  xmm1, xmm0, xmm7
          vmovss  dword ptr [rbx+8], xmm1
        }
        _RAX = g_snd.voices[_RSI].alias;
        __asm
        {
          vcvtss2sd xmm1, xmm9, xmm9
          vmovq   rdx, xmm1
          vmovss  xmm2, dword ptr [rax+68h]
          vcvtss2sd xmm2, xmm2, xmm2
          vmovq   r8, xmm2
        }
        v61 = j_va("Distance: %.0f / %.0f", _RDX, _R8);
        __asm { vmovaps xmm2, xmm6; scale }
        CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, v61, 0, 1);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+8]
          vsubss  xmm1, xmm0, xmm7
          vmovss  dword ptr [rbx+8], xmm1
        }
        *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(v13, 0);
        __asm
        {
          vmovss  xmm9, cs:__real@42c80000
          vmulss  xmm0, xmm0, xmm9
          vcvtss2sd xmm1, xmm0, xmm0
          vmovq   rdx, xmm1
        }
        v69 = j_va("Played: %.1f%%", _RDX);
        __asm { vmovaps xmm2, xmm6; scale }
        CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, v69, 0, 1);
        __asm { vcomiss xmm8, dword ptr [rsi+rbp+0CAE4h] }
        if ( v71 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+8]
            vsubss  xmm1, xmm0, xmm7
            vmovss  dword ptr [rbx+8], xmm1
            vmovss  xmm2, dword ptr [rsi+rbp+0CAE4h]
            vmulss  xmm0, xmm2, xmm9
            vcvtss2sd xmm1, xmm0, xmm0
            vmovq   rdx, xmm1
          }
          v78 = j_va("OCCLUDED: %.2f%%", _RDX);
          __asm { vmovaps xmm2, xmm6; scale }
          CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, v78, 0, 1);
        }
        __asm
        {
          vmovaps xmm6, [rsp+208h+var_48]
          vmovaps xmm7, [rsp+208h+var_58]
        }
      }
      goto LABEL_37;
    }
    CL_AddDebugString(_RBX, &colorWhiteFaded, *(float *)&_XMM2, g_snd.voices[_RSI].alias->aliasName, 0, 1);
  }
  CL_AddDebugStar(_RBX, v21, 0, 1, 0);
  if ( g_snd.voices[_RSI].alias )
  {
    _RDI = &g_snd.voices[_RSI].occlusionShape;
    if ( (snd_local_t *)((char *)&g_snd + _RSI * 1968) != (snd_local_t *)-53624i64 && g_snd.voices[_RSI].occlusionShape.id != g_snd.defaultHash )
    {
      if ( !entityOrientation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8123, ASSERT_TYPE_ASSERT, "(entityOrientation)", (const char *)&queryFormat, "entityOrientation") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+5Ch]
        vmovss  xmm1, dword ptr [rdi+60h]
        vmovss  dword ptr [rsp+208h+vRotation+8], xmm0
        vmovss  xmm0, cs:__real@3f800000
        vunpcklps xmm0, xmm0, xmm8
        vmovss  [rsp+208h+var_1C0], xmm8
      }
      vIn.v[2] = v91;
      __asm
      {
        vmovsd  qword ptr [rsp+208h+vIn], xmm0
        vmovss  dword ptr [rsp+208h+vRotation+4], xmm1
        vmovss  dword ptr [rsp+208h+vRotation], xmm8
      }
      VectorRotateAngles(&vIn, &vRotation, &out);
      AxisTransformVec3(entityOrientation, &out, &out);
      DrawArrow(_RBX, &out);
    }
  }
LABEL_37:
  _R11 = &v98;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
DebugDrawWorldSounds
==============
*/
void DebugDrawWorldSounds(int debugDrawStyle)
{
  int v5; 
  bool *voiceAlloc; 
  const SndAlias **p_alias; 
  unsigned int v8; 
  char v10; 
  float fmt; 
  float fmta; 
  __int64 depthTest; 
  int closestId; 
  float closestIdDotProd[3]; 
  EntityDebugDrawOffset drawOffset; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  memset_0(&drawOffset, 0, 0x4A4ui64);
  drawOffset.numEntIndices = 0;
  if ( !g_snd.driverInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8324, ASSERT_TYPE_ASSERT, "(g_snd.driverInitialized)", (const char *)&queryFormat, "g_snd.driverInitialized") )
    __debugbreak();
  __asm { vmovss  xmm0, cs:__real@c0000000 }
  v5 = 0;
  closestId = -1;
  __asm { vmovss  [rsp+548h+closestIdDotProd], xmm0 }
  voiceAlloc = sdGlob.voiceAlloc;
  p_alias = &g_snd.voices[0].alias;
  do
  {
    if ( (unsigned int)v5 > 0x62 )
    {
      LODWORD(depthTest) = v5;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", depthTest) )
        __debugbreak();
    }
    if ( *voiceAlloc )
    {
      if ( !*p_alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8334, ASSERT_TYPE_ASSERT, "(g_snd.voices[voiceIdx].alias)", (const char *)&queryFormat, "g_snd.voices[voiceIdx].alias") )
        __debugbreak();
      v8 = (unsigned __int8)((*p_alias)->flags >> 10);
      if ( SND_IsEntChannel3D(v8) && (snd_drawOnlyChannel == -1 || snd_drawOnlyChannel == v8) )
      {
        if ( SND_IsEntChannelPASpeaker((unsigned __int8)((*p_alias)->flags >> 10)) )
          DebugDrawWorldSoundPASpeaker(v5, debugDrawStyle, &drawOffset, &closestId, closestIdDotProd);
        else
          DebugDrawWorldSound3D(v5, debugDrawStyle, &drawOffset, &closestId, closestIdDotProd);
      }
    }
    ++v5;
    ++voiceAlloc;
    p_alias += 246;
  }
  while ( v5 < 99 );
  if ( closestId != -1 )
  {
    __asm
    {
      vmovss  xmm0, [rsp+548h+closestIdDotProd]
      vcomiss xmm0, cs:__real@3f6e147b
    }
  }
  __asm { vmovss  xmm6, cs:__real@3d4ccccd }
  if ( g_snd.reverbTriggerOutputNumberA != 1024 )
  {
    *(double *)&_XMM0 = SND_DistSqToNearestListener(&g_snd.reverbPosition[2]);
    __asm { vcomiss xmm0, cs:__real@41200000 }
    if ( v10 )
      __asm { vmovaps xmm1, xmm6 }
    else
      __asm { vmulss  xmm1, xmm0, cs:__real@3ae56042 }
    __asm { vmovss  dword ptr [rsp+548h+fmt], xmm1 }
    CL_AddDebugStarWithText(&g_snd.reverbPosition[2], &colorYellow, &colorWhiteFaded, "Far Reverb A", fmt, 0, 1, 0);
  }
  if ( g_snd.reverbTriggerOutputNumberB != 1024 )
  {
    *(double *)&_XMM0 = SND_DistSqToNearestListener(&g_snd.reverbPosition[3]);
    __asm { vcomiss xmm0, cs:__real@41200000 }
    if ( !v10 )
      __asm { vmulss  xmm6, xmm0, cs:__real@3ae56042 }
    __asm { vmovss  dword ptr [rsp+548h+fmt], xmm6 }
    CL_AddDebugStarWithText(&g_snd.reverbPosition[3], &colorYellow, &colorWhiteFaded, "Far Reverb B", fmta, 0, 1, 0);
  }
  __asm { vmovaps xmm6, [rsp+548h+var_38] }
}

/*
==============
FindDominantContextType
==============
*/

bool __fastcall FindDominantContextType(const unsigned int contextType, const ZoneDef *zoneA, const ZoneDef *zoneB, double zoneLerp, const SndEntState *entState, unsigned int *outContextValueA, unsigned int *outContextValueB, float *outLerp)
{
  unsigned int v18; 
  const SndEntState *v19; 
  bool v21; 
  unsigned int v23; 
  bool result; 
  __int64 v27; 
  unsigned int v36; 
  unsigned int contextValue1; 
  unsigned int contextValue2; 
  unsigned int contextValue3; 

  __asm
  {
    vmovaps [rsp+68h+var_28], xmm6
    vmovaps [rsp+68h+var_38], xmm7
    vmovaps [rsp+68h+var_48], xmm8
    vmovss  xmm6, cs:__real@3f800000
    vxorps  xmm8, xmm8, xmm8
    vmovaps xmm7, xmm3
  }
  if ( entState )
  {
    v18 = 0;
    v19 = entState;
    while ( v19->contextTypes[0] != contextType )
    {
      ++v18;
      v19 = (const SndEntState *)((char *)v19 + 4);
      if ( v18 >= 3 )
        goto LABEL_5;
    }
    v27 = (int)v18;
    __asm { vmovaps xmm0, xmm6 }
    if ( entState->contextFadeLength[v18] > 0 )
    {
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm1, xmm1, eax
        vcvtsi2ss xmm0, xmm0, ecx
        vdivss  xmm0, xmm1, xmm0; val
        vmovaps xmm1, xmm8; min
        vmovaps xmm2, xmm6; max
      }
      I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vsubss  xmm0, xmm6, xmm0 }
    }
    v36 = entState->contextValuesTo[v27];
    if ( v36 )
    {
      *outContextValueA = entState->contextValuesFrom[v27];
      *outContextValueB = v36;
      _RAX = outLerp;
      __asm { vmovss  dword ptr [rax], xmm0 }
      result = 1;
      goto LABEL_55;
    }
    __asm { vucomiss xmm0, xmm6 }
  }
LABEL_5:
  LODWORD(_RAX) = SND_FindContextIndex(contextType);
  v21 = (_DWORD)_RAX == 0;
  if ( (int)_RAX < 0 )
    goto LABEL_14;
  _RAX = (int)_RAX;
  _R8 = &g_snd;
  v23 = g_snd.globalContextsTo[(int)_RAX];
  v21 = v23 == 0;
  if ( !v23 )
  {
    __asm { vucomiss xmm6, dword ptr [r8+rax*8+145284h] }
LABEL_14:
    __asm { vucomiss xmm7, xmm8 }
    if ( v21 )
    {
      if ( zoneA )
      {
        if ( zoneA->contextType1 == contextType )
        {
          contextValue1 = zoneA->contextValue1;
LABEL_24:
          *outContextValueA = contextValue1;
          *outContextValueB = contextValue1;
          *outLerp = 0.0;
          result = 1;
          goto LABEL_55;
        }
        if ( zoneA->contextType2 == contextType )
        {
          contextValue1 = zoneA->contextValue2;
          goto LABEL_24;
        }
        if ( zoneA->contextType3 == contextType )
        {
          contextValue1 = zoneA->contextValue3;
          goto LABEL_24;
        }
        if ( zoneA->contextType4 == contextType )
        {
          contextValue1 = zoneA->contextValue4;
          goto LABEL_24;
        }
      }
    }
    else
    {
      __asm { vucomiss xmm7, xmm6 }
      if ( v21 )
      {
        if ( zoneB )
        {
          if ( zoneB->contextType1 == contextType )
          {
            contextValue1 = zoneB->contextValue1;
            goto LABEL_24;
          }
          if ( zoneB->contextType2 == contextType )
          {
            contextValue1 = zoneB->contextValue2;
            goto LABEL_24;
          }
          if ( zoneB->contextType3 == contextType )
          {
            contextValue1 = zoneB->contextValue3;
            goto LABEL_24;
          }
          if ( zoneB->contextType4 == contextType )
          {
            contextValue1 = zoneB->contextValue4;
            goto LABEL_24;
          }
        }
      }
      else if ( zoneA )
      {
        if ( zoneA->contextType1 == contextType )
        {
          contextValue2 = zoneA->contextValue1;
        }
        else if ( zoneA->contextType2 == contextType )
        {
          contextValue2 = zoneA->contextValue2;
        }
        else if ( zoneA->contextType3 == contextType )
        {
          contextValue2 = zoneA->contextValue3;
        }
        else
        {
          if ( zoneA->contextType4 != contextType )
            goto LABEL_54;
          contextValue2 = zoneA->contextValue4;
        }
        if ( zoneB )
        {
          if ( zoneB->contextType1 == contextType )
          {
            contextValue3 = zoneB->contextValue1;
          }
          else if ( zoneB->contextType2 == contextType )
          {
            contextValue3 = zoneB->contextValue2;
          }
          else if ( zoneB->contextType3 == contextType )
          {
            contextValue3 = zoneB->contextValue3;
          }
          else
          {
            if ( zoneB->contextType4 != contextType )
              goto LABEL_54;
            contextValue3 = zoneB->contextValue4;
          }
          *outContextValueA = contextValue2;
          *outContextValueB = contextValue3;
          _RAX = outLerp;
          __asm { vmovss  dword ptr [rax], xmm7 }
          result = 1;
          goto LABEL_55;
        }
      }
    }
LABEL_54:
    *outContextValueA = 0;
    *outContextValueB = 0;
    *outLerp = 0.0;
    result = 0;
    goto LABEL_55;
  }
  __asm { vmovss  xmm0, dword ptr [r8+rax*8+145284h] }
  *outContextValueA = g_snd.globalContextsFrom[(int)_RAX];
  *outContextValueB = v23;
  _RAX = outLerp;
  __asm { vmovss  dword ptr [rax], xmm0 }
  result = 1;
LABEL_55:
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_28]
    vmovaps xmm7, [rsp+68h+var_38]
    vmovaps xmm8, [rsp+68h+var_48]
  }
  return result;
}

/*
==============
FindDominantContextTypeNoBlend
==============
*/
__int64 FindDominantContextTypeNoBlend(const unsigned int contextType, const ZoneDef *zone, const SndEntState *entState)
{
  unsigned int v9; 
  const SndEntState *v10; 
  int ContextIndex; 
  __int64 result; 
  __int64 v16; 

  __asm
  {
    vmovaps [rsp+38h+var_18], xmm6
    vmovss  xmm6, cs:__real@3f800000
  }
  if ( entState )
  {
    v9 = 0;
    v10 = entState;
    while ( v10->contextTypes[0] != contextType )
    {
      ++v9;
      v10 = (const SndEntState *)((char *)v10 + 4);
      if ( v9 >= 3 )
        goto LABEL_5;
    }
    v16 = (int)v9;
    __asm { vmovaps xmm0, xmm6 }
    if ( entState->contextFadeLength[v9] > 0 )
    {
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm1, xmm1, eax
        vcvtsi2ss xmm0, xmm0, ecx
        vdivss  xmm0, xmm1, xmm0; val
        vxorps  xmm1, xmm1, xmm1; min
        vmovaps xmm2, xmm6; max
      }
      I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vsubss  xmm0, xmm6, xmm0 }
    }
    result = entState->contextValuesTo[v16];
    if ( (_DWORD)result )
    {
      __asm { vcomiss xmm0, cs:__real@3f000000 }
      goto LABEL_24;
    }
    __asm { vucomiss xmm0, xmm6 }
  }
LABEL_5:
  ContextIndex = SND_FindContextIndex(contextType);
  if ( ContextIndex < 0 )
    goto LABEL_14;
  _RCX = ContextIndex;
  _RDX = &g_snd;
  result = g_snd.globalContextsTo[ContextIndex];
  if ( !(_DWORD)result )
  {
    __asm { vucomiss xmm6, dword ptr [rdx+rcx*8+145284h] }
LABEL_14:
    if ( zone )
    {
      if ( zone->contextType1 == contextType )
      {
        result = zone->contextValue1;
        goto LABEL_24;
      }
      if ( zone->contextType2 == contextType )
      {
        result = zone->contextValue2;
        goto LABEL_24;
      }
      if ( zone->contextType3 == contextType )
      {
        result = zone->contextValue3;
        goto LABEL_24;
      }
      if ( zone->contextType4 == contextType )
      {
        result = zone->contextValue4;
        goto LABEL_24;
      }
    }
    result = 0i64;
    goto LABEL_24;
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+rcx*8+145284h]
    vcomiss xmm0, cs:__real@3f000000
  }
LABEL_24:
  __asm { vmovaps xmm6, [rsp+38h+var_18] }
  return result;
}

/*
==============
EntityDebugDrawOffset::GetOffset
==============
*/
__int64 EntityDebugDrawOffset::GetOffset(EntityDebugDrawOffset *this, unsigned __int64 entIndex)
{
  __int64 numEntIndices; 
  int v3; 
  __int64 v4; 

  numEntIndices = this->numEntIndices;
  v3 = 0;
  if ( numEntIndices <= 0 )
    return 0i64;
  v4 = 0i64;
  while ( this->entIndices[v4] != entIndex )
  {
    ++v3;
    if ( ++v4 >= numEntIndices )
      return 0i64;
  }
  return (unsigned int)this->offsets[v3];
}

/*
==============
GetSoundEntityOrientation
==============
*/
void GetSoundEntityOrientation(LocalClientNum_t localClientNum, int entIndex, vec3_t *origin_out, tmat33_t<vec3_t> *axis_out)
{
  __int64 v4; 
  int v8; 
  int v9; 
  int v10; 
  int v11; 
  const cpose_t *PoseExtended; 
  CgPredictedEntitySystem *System; 
  __int64 v14; 
  __int64 v15; 

  v4 = localClientNum;
  if ( entIndex < 2049 )
    goto LABEL_7;
  if ( entIndex < 3329 )
  {
    v8 = 1;
    goto LABEL_12;
  }
  if ( entIndex >= 4353 )
  {
LABEL_7:
    if ( (unsigned int)(entIndex - 5411) > 0x1F )
    {
      v8 = 0;
      if ( entIndex >= 5571 && entIndex < 505571 )
        v8 = 4;
    }
    else
    {
      v8 = 3;
    }
  }
  else
  {
    v8 = 2;
  }
LABEL_12:
  v9 = v8 - 1;
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      v11 = v10 - 1;
      if ( v11 )
      {
        if ( v11 == 1 )
        {
          ScriptableCl_GetInstanceOrientation(localClientNum, entIndex - 5571, origin_out, axis_out);
        }
        else
        {
          PoseExtended = CG_GetPoseExtended(localClientNum, entIndex, 0);
          CG_GetPoseOrigin(PoseExtended, origin_out);
          AnglesToAxis(&PoseExtended->angles, axis_out);
        }
      }
      else
      {
        System = CgPredictedEntitySystem::GetSystem(localClientNum);
        CgPredictedEntitySystem::CopyEntityOrientation(System, entIndex - 5411, origin_out, axis_out);
      }
    }
    else
    {
      CL_CopySoundInfoOrientation(entIndex - 3329, origin_out, axis_out);
    }
  }
  else
  {
    if ( !(_BYTE)CgClientSideEffectsSystem::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_client_side_effects.h", 310, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the client-side effects system for localClientNum %d but the client-side effects system type is not known\n", "ms_allocatedType != GameModeType::NONE", localClientNum) )
      __debugbreak();
    if ( (unsigned int)v4 >= CgClientSideEffectsSystem::ms_allocatedCount )
    {
      LODWORD(v15) = CgClientSideEffectsSystem::ms_allocatedCount;
      LODWORD(v14) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_client_side_effects.h", 311, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v14, v15) )
        __debugbreak();
    }
    if ( !CgClientSideEffectsSystem::ms_cseSystemArray[v4] )
    {
      LODWORD(v15) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_client_side_effects.h", 312, ASSERT_TYPE_ASSERT, "(ms_cseSystemArray[localClientNum])", "%s\n\tTrying to access unallocated client-side effects system for localClientNum %d\n", "ms_cseSystemArray[localClientNum]", v15) )
        __debugbreak();
    }
    CgClientSideEffectsSystem::CopySoundEntityOrientation(CgClientSideEffectsSystem::ms_cseSystemArray[v4], entIndex - 2049, origin_out, axis_out);
  }
}

/*
==============
GetSoundEntityType
==============
*/
EnumSndType GetSoundEntityType(const LocalClientNum_t localClientNum, const int entIndex)
{
  EnumSndType result; 

  if ( entIndex < 2049 )
    goto LABEL_7;
  if ( entIndex < 3329 )
    return 1;
  if ( entIndex < 4353 )
    return 2;
LABEL_7:
  if ( (unsigned int)(entIndex - 5411) <= 0x1F )
    return 3;
  result = EST_DEFAULT_ENT;
  if ( (unsigned int)(entIndex - 5571) <= 0x7A11F )
    return 4;
  return result;
}

/*
==============
InRange
==============
*/
char InRange(const SndAlias *alias, const vec3_t *org)
{
  char v22; 
  bool v26; 
  const dvar_t *v27; 
  const char *v39; 
  unsigned int v43; 
  int v51; 
  __int64 v52; 
  bool IsFullyAudioOccluded; 
  char *fmt; 
  __int64 v59; 
  snd_listener outListener; 
  _QWORD v61[3]; 

  _RDI = alias;
  _RBP = org;
  if ( !SND_IsEntChannel3D((unsigned __int8)(alias->flags >> 10)) || SND_IsEntChannelPASpeaker((unsigned __int8)(_RDI->flags >> 10)) || _RDI->assetId == g_snd.cinematicAssetId )
    return 1;
  __asm
  {
    vmovaps [rsp+128h+var_28], xmm6
    vmovaps [rsp+128h+var_38], xmm7
    vmovss  xmm7, dword ptr [rdi+68h]
    vmovaps [rsp+128h+var_48], xmm8
    vmovss  xmm8, dword ptr [rdi+64h]
  }
  SND_GetListenerNearestToOrigin(_RBP, &outListener);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+128h+outListener.orient.origin]
    vsubss  xmm3, xmm0, dword ptr [rbp+0]
    vmovss  xmm1, dword ptr [rsp+128h+outListener.orient.origin+4]
    vsubss  xmm2, xmm1, dword ptr [rbp+4]
    vmovss  xmm0, dword ptr [rsp+128h+outListener.orient.origin+8]
    vsubss  xmm4, xmm0, dword ptr [rbp+8]
    vmulss  xmm2, xmm2, xmm2
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm3, xmm2, xmm1
    vmovss  xmm1, [rsp+128h+outListener.velocity]
    vxorps  xmm2, xmm2, xmm2
    vcomiss xmm1, xmm2
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm6, xmm3, xmm0
  }
  if ( v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4001, ASSERT_TYPE_ASSERT, "(listener.velocity >= 0.0f)", (const char *)&queryFormat, "listener.velocity >= 0.0f") )
    __debugbreak();
  if ( (_RDI->flags & 0x70) != 0 )
  {
    __asm
    {
      vmulss  xmm0, xmm8, xmm8
      vcomiss xmm6, xmm0
    }
  }
  __asm
  {
    vmulss  xmm0, xmm7, xmm7
    vcomiss xmm6, xmm0
  }
  if ( (_RDI->flags & 0x70) != 0 )
  {
    v26 = 0;
  }
  else
  {
    __asm
    {
      vmovss  xmm0, [rsp+128h+outListener.velocity]
      vcomiss xmm0, dword ptr [rdi+6Ch]
    }
    v26 = 1;
  }
  v27 = DCONST_DVARSTR_snd_debugAlias;
  if ( !DCONST_DVARSTR_snd_debugAlias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debugAlias") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v27);
  if ( *(_BYTE *)v27->current.integer64 )
  {
    __asm
    {
      vmovss  xmm4, dword ptr [rdi+6Ch]
      vmovss  xmm5, [rsp+128h+outListener.velocity]
      vsqrtss xmm0, xmm6, xmm6
      vcvtss2sd xmm4, xmm4, xmm4
      vcvtss2sd xmm1, xmm0, xmm0
      vcvtss2sd xmm3, xmm7, xmm7
      vcvtss2sd xmm2, xmm8, xmm8
      vcvtss2sd xmm5, xmm5, xmm5
      vmovsd  [rsp+128h+var_100], xmm4
      vmovq   rdx, xmm1
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+128h+fmt], xmm5
    }
    v39 = j_va("Not playing, sound has 0 volume.  dist = %.2f, min = %.2f, max = %.2f.  velocity = %.2f, min = %.2f", _RDX, _R8, _R9, fmt, v59);
    SND_DebugAliasPrint(!v26, _RDI, v39);
  }
  __asm
  {
    vmovaps xmm8, [rsp+128h+var_48]
    vmovaps xmm7, [rsp+128h+var_38]
    vmovaps xmm6, [rsp+128h+var_28]
  }
  if ( v26 )
  {
    v43 = g_snd.entChanFullOcclusionDisabled[(unsigned __int64)(unsigned __int8)(_RDI->flags >> 10) >> 5];
    if ( !_bittest((const int *)&v43, (_RDI->flags >> 10) & 0x1F) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+128h+outListener.orient.origin]
        vmovss  xmm1, dword ptr [rsp+128h+outListener.orient.origin+4]
      }
      _RSI = g_snd.fullOcclusionCache;
      __asm
      {
        vmovss  dword ptr [rsp+128h+var_68], xmm0
        vmovss  xmm0, dword ptr [rsp+128h+outListener.orient.origin+8]
        vmovss  dword ptr [rsp+128h+var_68+4], xmm1
        vmovss  xmm1, dword ptr [rbp+0]
        vmovss  dword ptr [rsp+128h+var_68+8], xmm0
        vmovss  xmm0, dword ptr [rbp+4]
        vmovss  dword ptr [rsp+128h+var_68+0Ch], xmm1
        vmovss  xmm1, dword ptr [rbp+8]
      }
      v51 = 0;
      __asm
      {
        vmovss  dword ptr [rsp+128h+var_68+10h], xmm0
        vmovss  dword ptr [rsp+128h+var_68+14h], xmm1
      }
      if ( g_snd.numFullOcclusionCache <= 0 )
      {
LABEL_24:
        IsFullyAudioOccluded = CG_IsFullyAudioOccluded((const LocalClientNum_t)outListener.localClientNum, &outListener.orient.origin, _RBP, _RDI);
        if ( (unsigned __int64)g_snd.numFullOcclusionCache < 0x20 )
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rsp+128h+var_68]
            vmovsd  xmm1, qword ptr [rsp+128h+var_68+10h]
          }
          _RCX = g_snd.numFullOcclusionCache++;
          __asm
          {
            vmovups xmmword ptr [rcx+rsi], xmm0
            vmovsd  qword ptr [rcx+rsi+10h], xmm1
          }
          g_snd.fullOcclusionCache[_RCX].occluded = IsFullyAudioOccluded;
        }
      }
      else
      {
        while ( 1 )
        {
          v52 = v51;
          if ( *(_QWORD *)g_snd.fullOcclusionCache[v52].key.listener.v == v61[0] && *(_OWORD *)&g_snd.fullOcclusionCache[v52].key.listener.z == *(_OWORD *)&v61[1] )
            break;
          if ( ++v51 >= g_snd.numFullOcclusionCache )
            goto LABEL_24;
        }
        IsFullyAudioOccluded = g_snd.fullOcclusionCache[v51].occluded;
      }
      v26 = !IsFullyAudioOccluded;
      if ( *Dvar_GetString_Internal_DebugName(DCONST_DVARSTR_snd_debugAlias, "snd_debugAlias") )
        SND_DebugAliasPrint(IsFullyAudioOccluded, _RDI, "Not playing, sound was blocked by full occluder");
    }
  }
  return v26;
}

/*
==============
SNDL_Shutdown
==============
*/
void SNDL_Shutdown(void)
{
  Voice_Shutdown();
  SND_StopSounds(SND_STOP_ALL);
  SND_StopSounds(SND_STOP_ALL);
  SD_Shutdown();
  g_snd.driverInitialized = 0;
  Cmd_RemoveCommand("snd_playLocal");
  Cmd_RemoveCommand("snd_setEq");
  Cmd_RemoveCommand("snd_setEqFreq");
  Cmd_RemoveCommand("snd_setEqGain");
  Cmd_RemoveCommand("snd_setEqQ");
  Cmd_RemoveCommand("snd_setEqType");
  Cmd_RemoveCommand("snd_deactivateEq");
  Cmd_RemoveCommand("snd_setAliasValue");
}

/*
==============
SND_AbsoluteToFractionalPosition
==============
*/
float SND_AbsoluteToFractionalPosition(unsigned __int64 absPosition, bool wrap, int totalSamples)
{
  if ( totalSamples <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1278, ASSERT_TYPE_ASSERT, "( ( totalSamples > 0 ) )", "( totalSamples ) = %i", totalSamples) )
    __debugbreak();
  if ( !wrap )
    truncate_cast<int,unsigned __int64>(absPosition);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, ebx
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, edx
    vdivss  xmm0, xmm1, xmm0
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_AcquirePlaybackId
==============
*/
unsigned int SND_AcquirePlaybackId(int index, int totalMsec)
{
  __int64 v2; 
  SndVoice *v3; 
  unsigned int playbackIdCounter; 
  unsigned int result; 

  v2 = index;
  if ( (unsigned int)index > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3068, ASSERT_TYPE_ASSERT, "(index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "index >= 0 && index < SND_MAX_VOICES") )
    __debugbreak();
  v3 = &g_snd.voices[v2];
  if ( v3->soundFileInfo.loadingState == SFLS_UNLOADED && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3072, ASSERT_TYPE_ASSERT, "(voice->soundFileInfo.loadingState != SFLS_UNLOADED)", (const char *)&queryFormat, "voice->soundFileInfo.loadingState != SFLS_UNLOADED") )
    __debugbreak();
  if ( !v3->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3073, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
    __debugbreak();
  playbackIdCounter = g_snd.playbackIdCounter;
  if ( g_snd.playbackIdCounter > 0x7FFFFFFF )
    playbackIdCounter = 1;
  g_snd.playbackIdCounter = playbackIdCounter;
  result = playbackIdCounter;
  if ( (v3->alias->flags & 1) != 0 )
  {
    result = playbackIdCounter | 0x80000000;
    g_snd.playbackIdCounter = playbackIdCounter + 1;
    v3->playbackId = playbackIdCounter | 0x80000000;
  }
  else
  {
    g_snd.playbackIdCounter = playbackIdCounter + 1;
    v3->playbackId = playbackIdCounter;
  }
  return result;
}

/*
==============
SND_AddImpactToBulletEvent
==============
*/
void SND_AddImpactToBulletEvent(const int bulletEventId, const LocalClientNum_t localClientNum, const WeaponSFXPackage *sfxPackage, const vec3_t *inShooterPos, const vec3_t *inImpactPos, int impactEnt, const SndAliasList *impactSound, int surfaceType, const int hitImpactDelayOverride, SndHitmarkerType hitmarkerType)
{
  __int64 v12; 

  if ( bulletEventId >= 0 && (unsigned int)bulletEventId < 0x40 )
  {
    v12 = (__int64)bulletEventId << 7;
    SND_GetWhizby(sfxPackage);
    _RSI = inImpactPos;
    __asm
    {
      vmovss  xmm0, dword ptr [rsi]
      vsubss  xmm3, xmm0, dword ptr [rdi]
      vmovss  xmm1, dword ptr [rsi+4]
      vsubss  xmm2, xmm1, dword ptr [rdi+4]
      vmovss  xmm0, dword ptr [rsi+8]
      vsubss  xmm4, xmm0, dword ptr [rdi+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm3, xmm2, xmm1
      vaddss  xmm2, xmm3, xmm0
      vsqrtss xmm5, xmm2, xmm2
    }
    if ( hitImpactDelayOverride < 0 )
    {
      __asm
      {
        vmovss  xmm0, cs:__real@447a0000
        vdivss  xmm1, xmm0, dword ptr [rdx+80h]
        vmulss  xmm2, xmm1, xmm5
        vcvttss2si eax, xmm2
      }
      *(int *)((char *)&g_snd.delayedBulletEvents[0].impactDelay + v12) = _EAX;
    }
    else
    {
      *(int *)((char *)&g_snd.delayedBulletEvents[0].impactDelay + v12) = hitImpactDelayOverride;
      if ( surfaceType != 29 )
        *(&g_snd.delayedBulletEvents[0].playHitMarkerSoundDuringImpact + v12) = 1;
      *(SndHitmarkerType *)((char *)&g_snd.delayedBulletEvents[0].hitmarkerType + v12) = hitmarkerType;
    }
    *(int *)((char *)&g_snd.delayedBulletEvents[0].impactSurfType + v12) = surfaceType;
    *(unsigned int *)((char *)&g_snd.delayedBulletEvents[0].explosionReflectionType + v12) = sfxPackage->projExplosionReflClass;
    *(unsigned __int64 *)((char *)&g_snd.delayedBulletEvents[0].impactSndEnt + v12) = CG_GenerateSndEntHandle(localClientNum, impactEnt);
    *(vec3_t *)((char *)&g_snd.delayedBulletEvents[0].impactPos + v12) = *inImpactPos;
    *(const SndAliasList **)((char *)&g_snd.delayedBulletEvents[0].impactAlias + v12) = impactSound;
  }
}

/*
==============
SND_AddPhysicsQueryBlock
==============
*/
void SND_AddPhysicsQueryBlock(void)
{
  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_WEAPON_REFLECT);
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16489, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( s_soundPhysicsQueryBlock < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16490, ASSERT_TYPE_ASSERT, "(s_soundPhysicsQueryBlock >= 0)", (const char *)&queryFormat, "s_soundPhysicsQueryBlock >= 0") )
    __debugbreak();
  ++s_soundPhysicsQueryBlock;
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
}

/*
==============
SND_AddPlayFXSoundAlias
==============
*/
void SND_AddPlayFXSoundAlias(unsigned int aliasId, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *origin)
{
  __int64 v7; 
  int v8; 
  __int64 v9; 

  if ( s_FXPlaySoundCount < 32 )
  {
    do
    {
      v7 = s_FXPlaySoundHead;
      v8 = ((_BYTE)s_FXPlaySoundHead + 1) & 0x1F;
      if ( ((unsigned __int64)&s_FXPlaySoundHead & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_FXPlaySoundHead) )
        __debugbreak();
    }
    while ( (_DWORD)v7 != _InterlockedCompareExchange(&s_FXPlaySoundHead, v8, v7) );
    v9 = v7;
    s_FXPlaySounds[v9].aliasId = aliasId;
    s_FXPlaySounds[v9].localClientNum = localClientNum;
    s_FXPlaySounds[v9].entNum = entNum;
    s_FXPlaySounds[v9].origin.v[0] = origin->v[0];
    s_FXPlaySounds[v9].origin.v[1] = origin->v[1];
    s_FXPlaySounds[v9].origin.v[2] = origin->v[2];
    if ( ((unsigned __int8)&s_FXPlaySoundCount & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_FXPlaySoundCount) )
      __debugbreak();
    _InterlockedIncrement(&s_FXPlaySoundCount);
  }
  else
  {
    Com_PrintError(20, "ERROR: too many FX sounds %d\n", 32i64);
  }
}

/*
==============
SND_AddSoundDoneNotify
==============
*/
void SND_AddSoundDoneNotify(unsigned int playbackId, int entNum, unsigned __int16 soundString)
{
  unsigned __int64 v3; 
  unsigned int *p_playbackId; 
  int v6; 
  SndVoice *v7; 
  const char *v8; 

  v3 = entNum;
  if ( !playbackId || (playbackId & 0x80000000) != 0 )
    goto LABEL_6;
  p_playbackId = &g_snd.voices[0].playbackId;
  v6 = 0;
  while ( *p_playbackId != playbackId )
  {
    ++v6;
    p_playbackId += 492;
    if ( (__int64)p_playbackId >= (__int64)&g_snd.chaninfoUnweightedPriority[7] )
      goto LABEL_6;
  }
  v7 = &g_snd.voices[v6];
  if ( !v7 )
    goto LABEL_6;
  v7->soundDoneSoundString = 0;
  if ( !v7->alias )
  {
    Com_PrintError(9, "Primary alias was stopped during the playsound call.  Was it played on a restricted channel?\n");
LABEL_6:
    SND_QueueSoundDoneNotify(v3, soundString);
    return;
  }
  v8 = j_va("adding sound done notify %d %d\n", (unsigned int)entNum, soundString);
  SND_DebugAliasPrint(1, v7->alias, v8);
  if ( !soundString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3216, ASSERT_TYPE_ASSERT, "(soundString != 0)", (const char *)&queryFormat, "soundString != 0") )
    __debugbreak();
  v7->soundDoneSoundString = soundString;
}

/*
==============
SND_AddVoice
==============
*/
void SND_AddVoice(unsigned int entchannel)
{
  __int64 v1; 
  snd_entchannel_info_t *v2; 
  int *v3; 
  __int64 v4; 
  int maxVoices; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2041, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2042, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v4) )
      __debugbreak();
  }
  v2 = &g_snd.globals->entchannelInfo[v1];
  v3 = &g_snd.entchanvoicecount[v1];
  if ( *v3 >= v2->maxVoices )
  {
    maxVoices = v2->maxVoices;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2043, ASSERT_TYPE_ASSERT, "(g_snd.entchanvoicecount[entchannel] < g_snd.globals->entchannelInfo[entchannel].maxVoices)", "%s\n\tNot enough voices: entchannel = %s, maxvoices = %i", "g_snd.entchanvoicecount[entchannel] < g_snd.globals->entchannelInfo[entchannel].maxVoices", v2->name, maxVoices) )
      __debugbreak();
  }
  ++*v3;
}

/*
==============
SND_AddWhizbyToBulletEvent
==============
*/
void SND_AddWhizbyToBulletEvent(const int bulletEventId, const LocalClientNum_t localClientNum, const WeaponSFXPackage *sfxPackage, const vec3_t *inSndCenterPt, const vec3_t *inBulletDir, float radius, float shooterDist)
{
  unsigned __int64 SndEntHandle; 
  const SndAliasList *whizbyInAlias; 
  float v18; 
  float v19; 
  float v20; 
  SndWhizbyData outWhizbyData; 

  if ( bulletEventId >= 0 && (unsigned int)bulletEventId < 0x40 )
  {
    __asm
    {
      vmovss  xmm0, [rsp+0A8h+radius]
      vmovss  xmm1, cs:__real@ff7fffff
    }
    _RBX = (__int64)bulletEventId << 7;
    __asm
    {
      vmovss  [rsp+0A8h+var_70], xmm0
      vmovss  xmm0, [rsp+0A8h+shooterDist]
      vmovss  [rsp+0A8h+var_78], xmm1
      vmovss  [rsp+0A8h+var_88], xmm0
    }
    if ( SND_GetWhizbyData(localClientNum, sfxPackage, inSndCenterPt, inBulletDir, v18, 0, v19, v20, &outWhizbyData) )
    {
      SndEntHandle = CG_GenerateSndEntHandle(localClientNum, 2046);
      __asm
      {
        vmovss  xmm2, dword ptr [rsp+0A8h+var_58.whizbySndInPos]
        vmovss  xmm1, dword ptr [rsp+0A8h+var_58.whizbySndInPos+4]
        vmovss  xmm0, dword ptr [rsp+0A8h+var_58.whizbySndInPos+8]
      }
      _RCX = &g_snd;
      *(unsigned __int64 *)((char *)&g_snd.delayedBulletEvents[0].whizbySndEnt + _RBX) = SndEntHandle;
      whizbyInAlias = outWhizbyData.whizbyInAlias;
      __asm
      {
        vmovss  dword ptr [rbx+rcx+14C2DCh], xmm2
        vmovss  dword ptr [rbx+rcx+14C2E0h], xmm1
        vmovss  dword ptr [rbx+rcx+14C2E4h], xmm0
        vmovss  dword ptr [rbx+rcx+14C2E8h], xmm2
        vmovss  dword ptr [rbx+rcx+14C2ECh], xmm1
        vmovss  dword ptr [rbx+rcx+14C2F0h], xmm0
      }
      *(_QWORD *)&g_snd.delayedBulletEvents[0].state[_RBX + 8] = whizbyInAlias;
      *(const SndAliasList **)((char *)&g_snd.delayedBulletEvents[0].whizbyOutAlias + _RBX) = outWhizbyData.whizbyOutAlias;
      *(const SndAliasList **)((char *)&g_snd.delayedBulletEvents[0].whizbyCrackAlias + _RBX) = outWhizbyData.whizbyCrackAlias;
      *(int *)((char *)&g_snd.delayedBulletEvents[0].whizbyDelay + _RBX) = outWhizbyData.whizbyDelayMs;
    }
  }
}

/*
==============
SND_AmbientEventGetRandomElement
==============
*/

AmbientElement *__fastcall SND_AmbientEventGetRandomElement(const LocalClientNum_t localClientNum, double _XMM1_8)
{
  signed int v3; 
  int v6; 
  __int64 v7; 
  const AmbientDef *ambientDef; 
  const SoundTable *soundTable; 
  unsigned int numEvents; 
  __int64 p_weight; 
  unsigned int v12; 
  __int64 v13; 
  __int64 v17; 
  __int64 v18; 
  bool v20; 
  AmbientEvent *ambientEvents; 
  int ambientEventIndex; 
  __int64 v23; 
  AmbientElement *result; 
  int ambientElementIndex; 
  unsigned int ambientElementsCount; 

  v3 = 0;
  __asm
  {
    vmovaps [rsp+68h+var_28], xmm6
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm1, xmm1, xmm1
  }
  v6 = 0;
  v7 = localClientNum;
  ambientDef = g_ambGlob[localClientNum].ambientDef;
  soundTable = g_ambGlob[localClientNum].soundTable;
  numEvents = ambientDef->numEvents;
  if ( numEvents >= 4 )
  {
    p_weight = (__int64)&soundTable->ambientEvents[ambientDef->ambientEventIndex + 1].weight;
    v12 = ((numEvents - 4) >> 2) + 1;
    v13 = v12;
    v6 = 4 * v12;
    do
    {
      __asm
      {
        vaddss  xmm0, xmm1, dword ptr [rcx-0Ch]
        vaddss  xmm1, xmm0, dword ptr [rcx]
        vaddss  xmm2, xmm1, dword ptr [rcx+0Ch]
        vaddss  xmm1, xmm2, dword ptr [rcx+18h]
      }
      p_weight += 48i64;
      --v13;
    }
    while ( v13 );
  }
  if ( v6 < (int)numEvents )
  {
    v17 = (__int64)&soundTable->ambientEvents[v6 + g_ambGlob[v7].ambientDef->ambientEventIndex].weight;
    v18 = numEvents - v6;
    do
    {
      __asm { vaddss  xmm1, xmm1, dword ptr [rdx]; max }
      v17 += 12i64;
      --v18;
    }
    while ( v18 );
  }
  __asm { vmovaps xmm0, xmm6; min }
  *(double *)&_XMM0 = I_flrand(*(float *)&_XMM0, *(float *)&_XMM1);
  v20 = 0;
  if ( numEvents )
  {
    ambientEvents = soundTable->ambientEvents;
    ambientEventIndex = g_ambGlob[v7].ambientDef->ambientEventIndex;
    while ( 1 )
    {
      v23 = ambientEventIndex + v3;
      __asm
      {
        vaddss  xmm6, xmm6, dword ptr [rsi+rdi*4+8]
        vcomiss xmm0, xmm6
      }
      if ( v20 )
        break;
      v20 = ++v3 < numEvents;
      if ( v3 >= (int)numEvents )
        goto LABEL_11;
    }
    if ( ambientEvents[ambientEventIndex + v3].ambientElementIndex >= soundTable->ambientElementsCount )
    {
      ambientElementsCount = soundTable->ambientElementsCount;
      ambientElementIndex = ambientEvents[ambientEventIndex + v3].ambientElementIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7278, ASSERT_TYPE_ASSERT, "(unsigned)( event->ambientElementIndex ) < (unsigned)( soundTable->ambientElementsCount )", "event->ambientElementIndex doesn't index soundTable->ambientElementsCount\n\t%i not in [0, %i)", ambientElementIndex, ambientElementsCount) )
        __debugbreak();
    }
    result = &soundTable->ambientElements[ambientEvents[v23].ambientElementIndex];
  }
  else
  {
LABEL_11:
    result = NULL;
  }
  __asm { vmovaps xmm6, [rsp+68h+var_28] }
  return result;
}

/*
==============
SND_AnyActiveListeners
==============
*/
__int64 SND_AnyActiveListeners()
{
  unsigned __int8 v0; 
  unsigned __int64 v1; 
  bool *p_active; 

  v0 = 0;
  v1 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  p_active = &g_snd.listeners[0].active;
  while ( !*p_active )
  {
    p_active += 128;
    if ( (__int64)p_active >= (__int64)&g_snd.entchanvoicecount[26] )
      goto LABEL_11;
  }
  v0 = 1;
LABEL_11:
  if ( v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
  return v0;
}

/*
==============
SND_AnyEqEnabled
==============
*/
char SND_AnyEqEnabled(int entchannel)
{
  __int64 v1; 
  bool *p_enabled; 
  __int64 v3; 
  bool *v4; 

  v1 = 0i64;
  p_enabled = &sdGlob.eqParams[0][0][entchannel].enabled;
  while ( 2 )
  {
    v3 = 0i64;
    v4 = p_enabled;
    do
    {
      if ( *v4 )
        return 1;
      ++v3;
      v4 += 5120;
    }
    while ( v3 < 2 );
    ++v1;
    p_enabled += 10240;
    if ( v1 < 2 )
      continue;
    break;
  }
  return 0;
}

/*
==============
SND_AnyEqEnabledOnVoice
==============
*/
char SND_AnyEqEnabledOnVoice(int voiceIndex)
{
  __int64 v1; 
  __int64 v2; 
  unsigned int *v3; 
  __int64 v4; 
  unsigned int *v5; 

  v1 = voiceIndex;
  if ( (unsigned int)voiceIndex > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", voiceIndex) )
    __debugbreak();
  if ( sdGlob.voiceAlloc[v1] )
  {
    v2 = 0i64;
    v3 = &sdGlob.currentReverbId[65 * v1 - 6388];
    while ( 2 )
    {
      v4 = 0i64;
      v5 = v3;
      do
      {
        if ( *(_BYTE *)v5 )
          return 1;
        ++v4;
        v5 += 5;
      }
      while ( v4 < 2 );
      ++v2;
      v3 += 10;
      if ( v2 < 2 )
        continue;
      break;
    }
  }
  return 0;
}

/*
==============
SND_ApplyEq
==============
*/

void __fastcall SND_ApplyEq(int voiceIndex, int entchannel, int frametime, double lpfCutoff, float hpfCutoff)
{
  __int64 v12; 
  __int64 v13; 
  char v17; 
  __int64 v23; 
  bool *p_enabled; 
  __int64 v26; 
  bool *v27; 
  char v28; 
  __int64 v30; 
  int v32; 
  bool v34; 
  int v36; 
  bool v37; 
  unsigned int v57; 
  const dvar_t *v59; 
  __int64 v72; 
  __int64 v73; 
  __m256i v75; 
  unsigned int v77; 
  char v78; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  v12 = voiceIndex;
  v13 = entchannel;
  __asm { vmovaps xmm10, xmm3 }
  if ( (unsigned int)voiceIndex >= 0x63 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12578, ASSERT_TYPE_ASSERT, "(unsigned)( voiceIndex ) < (unsigned)( ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) )", "voiceIndex doesn't index SND_MAX_VOICES\n\t%i not in [0, %i)", voiceIndex, 99) )
    __debugbreak();
  if ( (unsigned int)v13 >= 0x100 )
  {
    LODWORD(v73) = 256;
    LODWORD(v72) = v13;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12579, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v72, v73) )
      __debugbreak();
  }
  _RBX = DCONST_DVARFLT_snd_lpf_override;
  if ( !DCONST_DVARFLT_snd_lpf_override && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_lpf_override") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm9, cs:__real@bf800000
    vucomiss xmm9, dword ptr [rbx+28h]
  }
  if ( !v17 )
  {
    _RBX = DCONST_DVARFLT_snd_lpf_override;
    if ( !DCONST_DVARFLT_snd_lpf_override && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_lpf_override") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm10, dword ptr [rbx+28h] }
  }
  _RBX = DCONST_DVARFLT_snd_hpf_override;
  if ( !DCONST_DVARFLT_snd_hpf_override && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_hpf_override") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vucomiss xmm9, dword ptr [rbx+28h] }
  if ( v17 )
  {
    __asm { vmovss  xmm11, [rsp+148h+hpfCutoff] }
  }
  else
  {
    _RBX = DCONST_DVARFLT_snd_hpf_override;
    if ( !DCONST_DVARFLT_snd_hpf_override && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_hpf_override") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm11, dword ptr [rbx+28h] }
  }
  v23 = 0i64;
  _R14 = 0x140000000ui64;
  p_enabled = &sdGlob.eqParams[0][0][v13].enabled;
  while ( 2 )
  {
    v26 = 0i64;
    v27 = p_enabled;
    do
    {
      if ( *v27 )
      {
        v28 = 1;
        goto LABEL_31;
      }
      ++v26;
      v27 += 5120;
    }
    while ( v26 < 2 );
    ++v23;
    p_enabled += 10240;
    if ( v23 < 2 )
      continue;
    break;
  }
  v28 = 0;
LABEL_31:
  if ( (unsigned int)v13 >= 0x100 )
  {
    LODWORD(v73) = 256;
    LODWORD(v72) = v13;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12596, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v72, v73) )
      __debugbreak();
  }
  _RCX = &v75.m256i_i64[1];
  v30 = 2i64;
  _RDX = (char *)&sdGlob + 20 * v13;
  do
  {
    v32 = *((_DWORD *)_RDX + 4);
    __asm
    {
      vmovups xmm0, xmmword ptr [rdx]
      vmovups xmmword ptr [rcx-24h], xmm0
    }
    *((_DWORD *)_RCX - 5) = v32;
    v34 = (_BYTE)v32 && v28;
    __asm { vmovups xmm0, xmmword ptr [rdx+1400h] }
    *((_BYTE *)_RCX - 20) = v34;
    v36 = *((_DWORD *)_RDX + 1284);
    __asm { vmovups xmmword ptr [rcx-10h], xmm0 }
    *(_DWORD *)_RCX = v36;
    v37 = (_BYTE)v36 && v28;
    *(_BYTE *)_RCX = v37;
    _RDX += 10240;
    _RCX += 5;
    --v30;
  }
  while ( v30 );
  __asm { vmovss  xmm0, cs:?sdGlob@@3USDLocal@@A.eqLerp; SDLocal sdGlob }
  _RBX = 1968 * v12;
  __asm
  {
    vmovss  dword ptr [rsp+148h+var_108], xmm0
    vmovss  xmm7, dword ptr [rbx+r14+15C6C3C4h]
    vmovss  xmm6, dword ptr [rbx+r14+15C6C3F4h]
  }
  *(double *)&_XMM0 = SND_SubmixGetLpFilterValue(*(_DWORD *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v12 - 48680] + 84i64));
  __asm
  {
    vmovss  xmm8, cs:__real@46bb8000
    vmulss  xmm2, xmm0, xmm6
    vmovss  xmm6, dword ptr [rbx+r14+15C6C400h]
    vmulss  xmm1, xmm2, xmm2
    vmulss  xmm3, xmm1, xmm2
    vmulss  xmm0, xmm7, xmm7
    vmulss  xmm1, xmm0, xmm7
    vmulss  xmm2, xmm1, xmm8
    vmulss  xmm4, xmm3, xmm8
    vminss  xmm7, xmm4, xmm2
  }
  *(double *)&_XMM0 = SND_SubmixGetHpFilterValue(*(_DWORD *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v12 - 48680] + 84i64));
  __asm
  {
    vucomiss xmm10, xmm9
    vmulss  xmm1, xmm0, xmm6
    vmulss  xmm2, xmm1, xmm8
    vmaxss  xmm3, xmm2, xmm11
  }
  if ( !v17 )
    __asm { vminss  xmm7, xmm7, xmm10 }
  __asm
  {
    vmovups ymm0, [rsp+148h+var_108]
    vmovups ymm1, ymmword ptr [rsp+60h]
  }
  v57 = v77;
  _RBX = 260 * v12;
  v59 = DCONST_DVARBOOL_snd_useSinglepoleFilter;
  sdGlob.voiceParams[_RBX / 0x104].useBiQuad = 1;
  __asm
  {
    vmovups ymmword ptr [rbx+r14+15C4CEACh], ymm0
    vmovups xmm0, [rsp+148h+var_C8]
    vmovups ymmword ptr [rbx+r14+15C4CECCh], ymm1
    vmovups xmmword ptr [rbx+r14+15C4CEECh], xmm0
  }
  sdGlob.currentReverbId[_RBX / 4 - 6373] = v57;
  __asm
  {
    vcmpless xmm0, xmm8, xmm7
    vblendvps xmm1, xmm7, xmm9, xmm0
    vcmpless xmm0, xmm3, cs:__real@41200000
    vmovss  dword ptr [rbx+r14+15C4CF00h], xmm1
    vblendvps xmm1, xmm3, xmm9, xmm0
    vmovss  dword ptr [rbx+r14+15C4CF04h], xmm1
  }
  if ( !v59 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_useSinglepoleFilter") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v59);
  if ( v59->current.enabled )
    sdGlob.voiceParams[_RBX / 0x104].useBiQuad = 0;
  _R11 = &v78;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
SND_ApplyFocusCone
==============
*/

float __fastcall SND_ApplyFocusCone(double focusAmount, const FocusCone *focusCone, const vec3_t *listenerForward, const vec3_t *targetPos)
{
  bool v20; 
  bool v21; 
  char v52; 
  char v53; 
  char v87; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  _RSI = targetPos;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
  }
  _RBX = focusCone;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
    vmovaps xmmword ptr [rax-78h], xmm12
    vmovaps [rsp+0D8h+var_88], xmm13
    vxorps  xmm11, xmm11, xmm11
    vcomiss xmm0, xmm11
    vmovaps [rsp+0D8h+var_98], xmm14
    vmovaps [rsp+0D8h+var_A8], xmm15
    vmovaps xmm7, xmm0
    vcomiss xmm0, xmm6
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12478, ASSERT_TYPE_ASSERT, "(focusAmount >= 0.0f && focusAmount <= 1.0f)", (const char *)&queryFormat, "focusAmount >= 0.0f && focusAmount <= 1.0f") )
    __debugbreak();
  v20 = _RBX == NULL;
  if ( !_RBX )
  {
    v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12479, ASSERT_TYPE_ASSERT, "(focusCone)", (const char *)&queryFormat, "focusCone");
    v20 = !v21;
    if ( v21 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm3, dword ptr [rsi]
    vmovss  xmm12, dword ptr [rbx+4Ch]
    vmovss  xmm4, dword ptr [rsi+4]
    vmovss  xmm5, dword ptr [rsi+8]
    vmovss  xmm9, dword ptr [rbx+44h]
    vmovss  xmm10, dword ptr [rbx+54h]
    vaddss  xmm0, xmm9, xmm6
    vmaxss  xmm13, xmm0, dword ptr [rbx+48h]
    vmulss  xmm0, xmm3, xmm3
    vaddss  xmm1, xmm12, xmm6
    vmaxss  xmm15, xmm1, dword ptr [rbx+50h]
    vmulss  xmm1, xmm4, xmm4
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm5, xmm5
    vaddss  xmm2, xmm2, xmm1
    vsqrtss xmm14, xmm2, xmm2
    vcomiss xmm14, xmm12
    vcmpless xmm0, xmm14, cs:__real@80000000
    vblendvps xmm0, xmm14, xmm6, xmm0
    vdivss  xmm1, xmm6, xmm0
    vmulss  xmm2, xmm3, xmm1
    vmulss  xmm3, xmm5, xmm1
    vmulss  xmm0, xmm4, xmm1
    vmovaps xmm8, xmm6
  }
  if ( !v20 )
  {
    __asm
    {
      vmulss  xmm1, xmm0, dword ptr [rdi+4]
      vmulss  xmm0, xmm2, dword ptr [rdi]
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, dword ptr [rdi+8]
      vaddss  xmm0, xmm2, xmm1; val
      vmovss  xmm1, cs:__real@bf800000; min
      vmovaps xmm2, xmm6; max
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@42652ee0
      vcomiss xmm1, xmm13
    }
    if ( v52 | v53 )
    {
      __asm { vcomiss xmm1, xmm9 }
      if ( !(v52 | v53) )
      {
        __asm
        {
          vsubss  xmm0, xmm13, xmm9
          vsubss  xmm2, xmm1, xmm9
          vdivss  xmm3, xmm2, xmm0
          vmulss  xmm4, xmm3, xmm10
          vsubss  xmm0, xmm6, xmm3
          vaddss  xmm8, xmm4, xmm0
        }
      }
    }
    else
    {
      __asm { vmovaps xmm8, xmm10 }
    }
    __asm
    {
      vsubss  xmm2, xmm14, xmm12
      vsubss  xmm0, xmm15, xmm12
      vdivss  xmm0, xmm2, xmm0; val
      vmovaps xmm2, xmm6; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmulss  xmm1, xmm0, xmm8
      vsubss  xmm0, xmm6, xmm0
      vaddss  xmm8, xmm1, xmm0
    }
  }
  __asm { vmovaps xmm14, [rsp+0D8h+var_98] }
  _R11 = &v87;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm15, [rsp+0D8h+var_A8]
    vmulss  xmm1, xmm8, xmm7
    vmovaps xmm8, xmmword ptr [r11-30h]
    vsubss  xmm0, xmm6, xmm7
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vaddss  xmm0, xmm1, xmm0
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_ApplyOcclusionShape
==============
*/
void SND_ApplyOcclusionShape(SndVoice *voice, const OcclusionShape *occShape, const snd_listener *listener, const vec3_t *entityPos, const tmat33_t<vec3_t> *entityOrientation, float *outVolumeAtten, float *outLPFAtten)
{
  char v59; 
  char v60; 
  vec3_t out; 
  vec3_t vRotation; 
  vec3_t vIn; 
  char v92; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
    vmovaps xmmword ptr [rax-78h], xmm12
    vmovaps xmmword ptr [rax-88h], xmm13
    vmovaps [rsp+108h+var_98], xmm14
    vmovaps [rsp+108h+var_A8], xmm15
    vmovss  xmm2, dword ptr cs:__xmm@80000000800000008000000080000000
    vmovss  xmm0, dword ptr [rdx+48h]
    vmovss  xmm12, cs:__real@3f800000
    vmovss  xmm1, dword ptr [r9+8]
    vmovss  xmm11, dword ptr [rdx+44h]
    vmovss  xmm14, dword ptr [rdx+4Ch]
    vmovss  xmm10, dword ptr [rdx+50h]
    vmovss  xmm15, dword ptr [rdx+54h]
    vmovss  xmm13, dword ptr [rdx+58h]
  }
  _RDI = outVolumeAtten;
  _RSI = outLPFAtten;
  __asm
  {
    vmovss  [rsp+108h+var_E8], xmm0
    vmovss  xmm0, dword ptr [r9]
    vxorps  xmm7, xmm0, xmm2
    vmovss  xmm0, dword ptr [r9+4]
    vxorps  xmm6, xmm0, xmm2
    vxorps  xmm5, xmm1, xmm2
    vmulss  xmm0, xmm7, xmm7
    vmulss  xmm2, xmm6, xmm6
    vaddss  xmm3, xmm2, xmm0
    vmulss  xmm1, xmm5, xmm5
    vaddss  xmm2, xmm3, xmm1
    vsqrtss xmm4, xmm2, xmm2
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm12, xmm0
    vdivss  xmm1, xmm12, xmm0
    vmovss  xmm0, dword ptr [rdx+5Ch]
    vmovss  dword ptr [rsp+108h+vRotation+8], xmm0
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+108h+out+8], xmm0
    vmovss  dword ptr [rsp+108h+vRotation], xmm0
    vmulss  xmm7, xmm7, xmm1
    vmulss  xmm6, xmm6, xmm1
    vmulss  xmm8, xmm5, xmm1
    vmovss  xmm1, dword ptr [rdx+60h]
    vunpcklps xmm0, xmm12, xmm0
  }
  vIn.v[2] = out.v[2];
  __asm
  {
    vmovsd  qword ptr [rsp+108h+vIn], xmm0
    vmovss  dword ptr [rsp+108h+vRotation+4], xmm1
    vmovaps xmm9, xmm12
  }
  VectorRotateAngles(&vIn, &vRotation, &out);
  AxisTransformVec3(entityOrientation, &out, &out);
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rsp+108h+out+4]
    vmulss  xmm1, xmm7, dword ptr [rsp+108h+out]
    vmovss  xmm6, cs:__real@bf800000
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm8, dword ptr [rsp+108h+out+8]
    vaddss  xmm0, xmm2, xmm1; val
    vmovaps xmm2, xmm12; max
    vmovaps xmm1, xmm6; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm4, xmm0, cs:__real@42652ee0
    vmovss  xmm0, [rsp+108h+var_E8]
    vcomiss xmm4, xmm0
  }
  if ( v59 | v60 )
  {
    __asm { vcomiss xmm4, xmm11 }
    if ( !(v59 | v60) )
    {
      __asm
      {
        vsubss  xmm0, xmm0, xmm11
        vsubss  xmm1, xmm4, xmm11
        vdivss  xmm2, xmm1, xmm0
        vmulss  xmm3, xmm2, xmm14
        vsubss  xmm0, xmm12, xmm2
        vaddss  xmm9, xmm3, xmm0
      }
    }
  }
  else
  {
    __asm { vmovaps xmm9, xmm14 }
  }
  __asm
  {
    vcomiss xmm4, xmm15
    vmovss  dword ptr [rdi], xmm9
  }
  if ( v59 | v60 )
  {
    __asm { vcomiss xmm4, xmm10 }
    if ( v59 | v60 )
    {
      __asm { vmovss  dword ptr [rsi], xmm6 }
    }
    else
    {
      __asm
      {
        vsubss  xmm1, xmm4, xmm10
        vsubss  xmm0, xmm15, xmm10
        vdivss  xmm2, xmm1, xmm0
        vsubss  xmm0, xmm12, xmm2
        vmulss  xmm1, xmm0, cs:__real@46bb8000
        vmulss  xmm3, xmm2, xmm13
        vaddss  xmm2, xmm3, xmm1
        vmovss  dword ptr [rsi], xmm2
      }
    }
  }
  else
  {
    __asm { vmovss  dword ptr [rsi], xmm13 }
  }
  _R11 = &v92;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, [rsp+108h+var_98]
    vmovaps xmm15, [rsp+108h+var_A8]
  }
}

/*
==============
SND_ApplyPanningMatrix
==============
*/

void __fastcall SND_ApplyPanningMatrix(const int index, const float *p_matrix, double dryLevel, double wetLevel, const LocalClientNum_t localClientNum)
{
  const dvar_t *v11; 
  __int64 v12; 
  SndVoice *v14; 
  int integer; 
  bool v18; 
  int PlayerAudioPropagationTriggerIndex; 
  int v20; 
  int v21; 
  const dvar_t *v22; 
  __int64 v29; 
  unsigned int propagationTriggerIndex; 
  int v32; 
  unsigned int v36; 
  bool v39; 
  __int64 v57; 
  const SndAlias *alias; 
  const SndAlias *v66; 
  double v77; 
  char v83; 
  LocalClientNum_t localClientNuma; 

  v11 = DCONST_DVARINT_snd_solo_propagation;
  v12 = index;
  _R12 = p_matrix;
  __asm
  {
    vmovaps [rsp+0B8h+var_48], xmm7
    vmovaps [rsp+0B8h+var_68], xmm9
    vmovaps [rsp+0B8h+var_78], xmm10
  }
  v14 = &g_snd.voices[index];
  __asm
  {
    vmovaps xmm9, xmm3
    vmovaps xmm10, xmm2
  }
  if ( !DCONST_DVARINT_snd_solo_propagation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_solo_propagation") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  integer = v11->current.integer;
  if ( localClientNum == LOCAL_CLIENT_INVALID )
  {
    v18 = 0;
    PlayerAudioPropagationTriggerIndex = 0x4000;
  }
  else
  {
    v18 = CG_AreAudioZonesOverriden(localClientNum);
    PlayerAudioPropagationTriggerIndex = CG_GetPlayerAudioPropagationTriggerIndex(localClientNum);
  }
  v20 = SND_LookupZoneIndex(v14->propagationTriggerIndex);
  v21 = SND_LookupZoneIndex(PlayerAudioPropagationTriggerIndex);
  v22 = DCONST_DVARBOOL_snd_enable_capture_mode;
  localClientNuma = v21;
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v22);
  _EBX = 0;
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( v22->current.enabled )
  {
    _EAX = SND_IsChannelMissionVOChannel((unsigned __int8)(v14->alias->flags >> 10));
    __asm
    {
      vmovd   xmm0, eax
      vmovd   xmm1, ebx
      vpcmpeqd xmm2, xmm0, xmm1
      vblendvps xmm9, xmm7, xmm9, xmm2
    }
  }
  v29 = v12;
  _RSI = &sdGlob;
  *(_QWORD *)sdGlob.voiceParams[v29].panLevels = 0i64;
  *(_QWORD *)&sdGlob.voiceParams[v29].panLevels[2] = 0i64;
  *(_QWORD *)&sdGlob.voiceParams[v29].panLevels[4] = 0i64;
  if ( !v18 )
  {
    propagationTriggerIndex = v14->propagationTriggerIndex;
    if ( propagationTriggerIndex != 1024 )
    {
      if ( propagationTriggerIndex == g_snd.reverbTrigger[2] && g_snd.reverbTriggerOutputNumberA != 1024 )
      {
        v32 = 2;
LABEL_20:
        __asm
        {
          vmovaps [rsp+0B8h+var_58], xmm8
          vmovss  xmm8, cs:__real@3f800000
        }
        if ( !integer )
        {
          *(double *)&_XMM0 = SND_GetDryLevel(v14, 1);
          _RAX = 260 * v12;
          __asm
          {
            vmulss  xmm1, xmm0, xmm10
            vmovss  dword ptr [rax+rsi+5090h], xmm1
          }
        }
        if ( v20 == localClientNuma )
        {
          LOBYTE(_EBX) = g_snd.activeMainReverb != RVB_MAIN_A;
          v36 = _EBX + 2;
          if ( g_snd.activeMainReverb )
            __asm { vsubss  xmm8, xmm8, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current; snd_local_t g_snd }
          else
            __asm { vmovss  xmm8, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current; snd_local_t g_snd }
          *(double *)&_XMM0 = SND_GetWetLevel(v14->alias, g_snd.activeMainReverb);
          _RCX = v36 + 65 * v12;
          __asm { vmulss  xmm1, xmm0, xmm9 }
          v39 = !v14->occlusionMatchesListener;
          __asm { vmovss  dword ptr [rsi+rcx*4+5090h], xmm1 }
        }
        else
        {
          v39 = 0;
        }
        _RBX = 260 * v12;
        __asm { vmovaps [rsp+0B8h+var_38], xmm6 }
        sdGlob.voiceParams[v12].onePolePreReverb = v39;
        if ( SND_EntChannelFarReverbBehavior((unsigned __int8)(v14->alias->flags >> 10)) == SND_FAR_REVERB_FULL && integer != 2 )
        {
          *(double *)&_XMM0 = SND_GetDryLevel(v14, 1);
          _RSI = DCONST_DVARFLT_snd_farDryAttenuation;
          __asm { vmovaps xmm6, xmm0 }
          if ( !DCONST_DVARFLT_snd_farDryAttenuation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farDryAttenuation") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(_RSI);
          __asm
          {
            vmovss  xmm0, dword ptr [rsi+28h]
            vmulss  xmm1, xmm0, cs:__real@3d4ccccd; Y
            vmovss  xmm0, cs:__real@41200000; X
          }
          *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
          __asm
          {
            vcmpltss xmm1, xmm0, cs:__real@37803e84
            vblendvps xmm0, xmm0, xmm7, xmm1
            vmulss  xmm1, xmm0, xmm6
          }
          _RAX = 260 * v12;
          __asm
          {
            vmulss  xmm0, xmm8, xmm10
            vmulss  xmm2, xmm1, xmm0
          }
          _RSI = &sdGlob;
          __asm { vmovss  dword ptr [rax+rsi+5094h], xmm2 }
        }
        if ( integer != 3 )
        {
          if ( SND_GetEntChannelSendFlag((unsigned __int8)(v14->alias->flags >> 10)) != SENDTYPE_NONE )
          {
            if ( v14->reverbDef )
            {
              __asm
              {
                vmovss  xmm0, dword ptr [rcx+4Ch]
                vmulss  xmm6, xmm0, dword ptr [rax+0ACh]
                vcomiss xmm6, xmm7
                vcomiss xmm6, cs:__real@43800000
                vcvtss2sd xmm0, xmm6, xmm6
                vmovsd  [rsp+0B8h+var_90], xmm0
              }
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12126, ASSERT_TYPE_ASSERT, "( ( wetLevel >= 0 && wetLevel <= 256 ) )", "( wetLevel ) = %g", v77) )
                __debugbreak();
              __asm { vmovaps xmm7, xmm6 }
            }
            else
            {
              *(double *)&_XMM0 = SND_GetWetLevel(v14->alias, g_snd.activeMainReverb);
              __asm { vmovaps xmm7, xmm0 }
            }
          }
          v57 = 20i64;
          if ( v32 == 2 )
            v57 = 16i64;
          __asm { vmulss  xmm1, xmm8, xmm9 }
          _RCX = 260 * v12 + v57;
          __asm
          {
            vmulss  xmm0, xmm1, xmm7
            vmovss  dword ptr [rcx+rsi+5090h], xmm0
          }
        }
        __asm
        {
          vmovaps xmm8, [rsp+0B8h+var_58]
          vmovaps xmm6, [rsp+0B8h+var_38]
        }
        goto LABEL_49;
      }
      if ( propagationTriggerIndex == g_snd.reverbTrigger[3] && g_snd.reverbTriggerOutputNumberB != 1024 )
      {
        v32 = 3;
        goto LABEL_20;
      }
    }
  }
  if ( !integer )
  {
    _RBX = 260 * v12;
    *(double *)&_XMM0 = SND_GetDryLevel(v14, 0);
    alias = v14->alias;
    __asm
    {
      vmulss  xmm1, xmm0, xmm10
      vmovss  dword ptr [rbx+rsi+5090h], xmm1
    }
    *(double *)&_XMM0 = SND_GetWetLevel(alias, RVB_MAIN_A);
    v66 = v14->alias;
    __asm
    {
      vmulss  xmm1, xmm0, xmm9
      vmovss  dword ptr [rbx+rsi+5098h], xmm1
    }
    *(double *)&_XMM0 = SND_GetWetLevel(v66, RVB_MAIN_B);
    __asm
    {
      vmulss  xmm1, xmm0, xmm9
      vmovss  dword ptr [rbx+rsi+509Ch], xmm1
    }
  }
  _RBX = 260 * v12;
  sdGlob.voiceParams[v12].onePolePreReverb = 0;
LABEL_49:
  __asm
  {
    vmovups ymm0, ymmword ptr [r12]
    vmovaps xmm7, [rsp+0B8h+var_48]
  }
  _R11 = &v83;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovups ymmword ptr [rbx+rsi+5010h], ymm0
    vmovups ymm1, ymmword ptr [r12+20h]
    vmovups ymmword ptr [rbx+rsi+5030h], ymm1
    vmovups ymm0, ymmword ptr [r12+40h]
    vmovups ymmword ptr [rbx+rsi+5050h], ymm0
    vmovups ymm1, ymmword ptr [r12+60h]
    vmovups ymmword ptr [rbx+rsi+5070h], ymm1
  }
}

/*
==============
SND_ApplySpeakerParams
==============
*/

void __fastcall SND_ApplySpeakerParams(const int index, const int frametime, double voiceVolume)
{
  const dvar_t *v15; 
  const SpeakerMap *p_speakerMap; 
  unsigned int v21; 
  const dvar_t *v23; 
  const dvar_t *v25; 
  unsigned int v26; 
  const SndAlias *alias; 
  unsigned int AliasEntChannelId; 
  MapEnts *mapEnts; 
  unsigned int v35; 
  __int64 v36; 
  int audioPASpeakerCount; 
  volatile int v39; 
  unsigned int v40; 
  unsigned int entChannelHash; 
  char v62; 
  unsigned int v64; 
  unsigned int defaultHash; 
  bool v88; 
  int v96; 
  float *v97; 
  unsigned int v115; 
  char v125; 
  const FocusCone *focusCone; 
  bool v128; 
  bool v137; 
  float fmt; 
  float fmta; 
  float fmtb; 
  SpeakerMap *speakerMap; 
  float speakerMapa; 
  float speakerMapb; 
  float speakerMapc; 
  float *outLPFAtten; 
  float outVolumeAtten; 
  float v160; 
  float v161; 
  int entchannel; 
  int voiceIndex; 
  vec3_t delta; 
  vec3_t origin; 
  snd_listener outListener; 
  tmat33_t<vec3_t> outVoiceOrientation; 
  __int128 v168[8]; 
  float outputs[4]; 
  char v177; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm14
  }
  v15 = DCONST_DVARFLT_snd_dry_scale;
  __asm { vmovaps xmm6, xmm2 }
  _RBX = &g_snd.voices[index];
  voiceIndex = index;
  p_speakerMap = &_RBX->speakerMap;
  v21 = (unsigned __int8)(_RBX->alias->flags >> 10);
  entchannel = v21;
  if ( !DCONST_DVARFLT_snd_dry_scale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_dry_scale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  __asm { vmulss  xmm14, xmm6, dword ptr [rsi+28h] }
  v23 = DCONST_DVARFLT_snd_wet_scale;
  __asm { vmovss  [rsp+300h+outVolumeAtten], xmm14 }
  if ( !DCONST_DVARFLT_snd_wet_scale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_wet_scale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v23);
  __asm { vmulss  xmm12, xmm6, dword ptr [rsi+28h] }
  v25 = DCONST_DVARBOOL_snd_enable_capture_mode;
  __asm { vmovss  [rsp+300h+var_2B8], xmm12 }
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v25);
  if ( v25->current.enabled && SND_IsChannelMissionVOChannel((unsigned __int8)(_RBX->alias->flags >> 10)) )
  {
    v26 = SND_HashName(S_VO_CENTER_ONLY_MAP);
    p_speakerMap = SND_GetSpeakerMapById(v26);
  }
  alias = _RBX->alias;
  __asm
  {
    vmovaps xmmword ptr [rsp+300h+var_48+8], xmm7
    vmovaps [rsp+300h+var_58+8], xmm8
    vmovaps [rsp+300h+var_68+8], xmm9
  }
  LODWORD(alias) = (unsigned __int8)(alias->flags >> 10);
  __asm
  {
    vmovaps [rsp+300h+var_78+8], xmm10
    vmovaps [rsp+300h+var_88+8], xmm11
  }
  if ( SND_IsEntChannelPASpeaker((unsigned int)alias) )
  {
    __asm
    {
      vmovss  xmm10, cs:__real@3f800000
      vmovaps xmmword ptr [rsp+300h+var_A8+8], xmm13
      vmovaps xmmword ptr [rsp+300h+var_C8+8], xmm15
      vmovss  xmm15, cs:__real@7f7fffff
    }
    memset_0(v168, 0, sizeof(v168));
    AliasEntChannelId = SND_GetAliasEntChannelId(_RBX->alias);
    mapEnts = cm.mapEnts;
    __asm
    {
      vmovss  xmm11, dword ptr [rsp+300h+origin+8]
      vmovss  xmm12, dword ptr [rsp+300h+origin+4]
      vmovss  xmm13, dword ptr [rsp+300h+origin]
    }
    v35 = AliasEntChannelId;
    outListener.localClientNum = LOCAL_CLIENT_INVALID;
    v36 = 0i64;
    __asm { vxorps  xmm14, xmm14, xmm14 }
    while ( 1 )
    {
      if ( mapEnts )
      {
        if ( mapEnts->audioPASpeakerCount >= 0x40 )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 532, ASSERT_TYPE_ASSERT, "(cm.mapEnts->audioPASpeakerCount < 64)", (const char *)&queryFormat, "cm.mapEnts->audioPASpeakerCount < AUDIO_PA_SPEAKERS_MAXSIZE") )
            __debugbreak();
          mapEnts = cm.mapEnts;
        }
        audioPASpeakerCount = mapEnts->audioPASpeakerCount;
      }
      else
      {
        audioPASpeakerCount = 0;
      }
      if ( (int)v36 >= audioPASpeakerCount )
      {
        __asm
        {
          vmovaps xmm2, xmm10; distFrac
          vmovaps xmm1, xmm15; dist
        }
        *(double *)&_XMM0 = SND_GetVolumeFalloffGain(_RBX, *(const float *)&_XMM1, *(const float *)&_XMM2, &_RBX->vfCurve);
        defaultHash = g_snd.defaultHash;
        __asm
        {
          vmovss  xmm6, cs:__real@bf800000
          vmovaps xmm15, xmmword ptr [rsp+300h+var_C8+8]
          vmovaps xmm13, xmmword ptr [rsp+300h+var_A8+8]
          vmovaps xmm9, xmm0
        }
        if ( _RBX->lpfCurve.id == g_snd.defaultHash )
        {
          __asm { vmovaps xmm8, xmm6 }
        }
        else
        {
          __asm { vmovaps xmm2, xmm10; fraction }
          *(double *)&_XMM0 = SND_GetSndCurveValue(_RBX->lpfCurve.numPoints, _RBX->lpfCurve.points, *(const float *)&_XMM2);
          defaultHash = g_snd.defaultHash;
          __asm { vmovaps xmm8, xmm0 }
        }
        if ( _RBX->hpfCurve.id == defaultHash )
        {
          __asm { vmovaps xmm7, xmm6 }
        }
        else
        {
          __asm { vmovaps xmm2, xmm10; fraction }
          *(double *)&_XMM0 = SND_GetSndCurveValue(_RBX->hpfCurve.numPoints, _RBX->hpfCurve.points, *(const float *)&_XMM2);
          defaultHash = g_snd.defaultHash;
          __asm { vmovaps xmm7, xmm0 }
        }
        v88 = _RBX->rvbCurve.id == defaultHash;
        if ( _RBX->rvbCurve.id != defaultHash )
        {
          __asm { vmovaps xmm2, xmm10; fraction }
          *(double *)&_XMM0 = SND_GetSndCurveValue(_RBX->rvbCurve.numPoints, _RBX->rvbCurve.points, *(const float *)&_XMM2);
          __asm { vmovaps xmm9, xmm0 }
        }
        __asm
        {
          vucomiss xmm8, xmm6
          vmovss  xmm1, dword ptr [rbx+100h]
        }
        if ( v88 )
        {
          __asm { vmovaps xmm8, xmm1 }
        }
        else
        {
          __asm { vucomiss xmm1, xmm6 }
          if ( !v88 )
            __asm { vminss  xmm8, xmm1, xmm8 }
        }
        __asm
        {
          vucomiss xmm7, xmm6
          vmovss  xmm0, dword ptr [rbx+104h]
        }
        if ( v88 )
        {
          __asm { vmovaps xmm7, xmm0 }
        }
        else
        {
          __asm { vucomiss xmm0, xmm6 }
          if ( !v88 )
            __asm { vminss  xmm7, xmm0, xmm7 }
        }
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovss  dword ptr [rsp+300h+speakerMap], xmm0
          vmovaps xmm3, xmm8; lpfCutoff
          vmovss  dword ptr [rsp+300h+fmt], xmm7
        }
        SND_ApplyEq(voiceIndex, entchannel, frametime, *(float *)&_XMM3, fmt, speakerMapa);
        __asm
        {
          vmulss  xmm3, xmm9, [rsp+300h+var_2B8]
          vmovss  xmm2, [rsp+300h+outVolumeAtten]
        }
        v96 = voiceIndex;
        v97 = (float *)v168;
        goto LABEL_93;
      }
      if ( (unsigned int)v36 >= 0x40 )
      {
        LODWORD(outLPFAtten) = 64;
        LODWORD(speakerMap) = v36;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 14, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", speakerMap, outLPFAtten) )
          __debugbreak();
        mapEnts = cm.mapEnts;
      }
      v39 = g_snd.voiceBusyUpdating[((__int64)(int)v36 >> 5) - 2];
      if ( !_bittest((const int *)&v39, v36 & 0x1F) )
      {
        if ( mapEnts )
        {
          v40 = mapEnts->audioPASpeakerCount;
          if ( v40 > (unsigned int)v36 )
          {
            entChannelHash = mapEnts->audioPASpeakers[v36].entChannelHash;
            if ( entChannelHash && entChannelHash != v35 )
              goto LABEL_39;
            if ( v40 > (unsigned int)v36 )
            {
              _RAX = mapEnts->audioPASpeakers;
              _RCX = 5 * v36;
              __asm
              {
                vmovss  xmm13, dword ptr [rax+rcx*4]
                vmovss  xmm12, dword ptr [rax+rcx*4+4]
                vmovss  xmm11, dword ptr [rax+rcx*4+8]
                vmovss  dword ptr [rsp+300h+origin], xmm13
                vmovss  dword ptr [rsp+300h+origin+4], xmm12
                vmovss  dword ptr [rsp+300h+origin+8], xmm11
              }
            }
          }
        }
        SND_GetListenerNearestToOrigin(&origin, &outListener);
        __asm
        {
          vsubss  xmm0, xmm12, dword ptr [rbp+200h+outListener.orient.origin+4]
          vsubss  xmm2, xmm13, dword ptr [rbp+200h+outListener.orient.origin]
          vsubss  xmm3, xmm11, dword ptr [rbp+200h+outListener.orient.origin+8]
        }
        _RAX = _RBX->alias;
        __asm
        {
          vmovss  dword ptr [rsp+300h+delta+4], xmm0
          vmulss  xmm1, xmm0, xmm0
          vmulss  xmm0, xmm2, xmm2
          vmovss  dword ptr [rsp+300h+delta], xmm2
          vaddss  xmm2, xmm1, xmm0
          vmulss  xmm1, xmm3, xmm3
          vaddss  xmm2, xmm2, xmm1
          vsqrtss xmm8, xmm2, xmm2
          vmovss  dword ptr [rsp+300h+delta+8], xmm3
          vmovss  xmm1, dword ptr [rax+64h]; mindist
          vmovss  xmm2, dword ptr [rax+68h]; maxdist
          vmovaps xmm0, xmm8; radius
        }
        _RBX->priorityAttenuation = 0.0;
        *(double *)&_XMM0 = SND_GetDistanceCurveFraction(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovaps xmm2, xmm0; distFrac
          vmovaps xmm1, xmm8; dist
          vmovaps xmm9, xmm0
        }
        *(double *)&_XMM0 = SND_GetVolumeFalloffGain(_RBX, *(const float *)&_XMM1, *(const float *)&_XMM2, &_RBX->vfCurve);
        __asm
        {
          vcomiss xmm0, xmm14
          vmovaps xmm7, xmm0
          vshufps xmm7, xmm7, xmm7, 0
          vmovaps xmm6, xmm0
        }
        if ( !(v62 | v88) )
        {
          __asm { vmovaps xmm1, xmm8; dist }
          SND_Get3DSpeakerVolumes(outputs, *(const float *)&_XMM1, &delta, &outListener, _RBX, p_speakerMap);
          v64 = 0;
          _RAX = 0i64;
          do
          {
            __asm
            {
              vmovups xmm0, [rbp+rax*4+200h+var_1D0]
              vmulps  xmm1, xmm7, xmmword ptr [rbp+rax*4+200h+outputs]
              vmaxps  xmm1, xmm0, xmm1
              vmovups [rbp+rax*4+200h+var_1D0], xmm1
              vmovups xmm0, [rbp+rax*4+200h+var_1C0]
              vmulps  xmm1, xmm7, [rbp+rax*4+200h+var_140]
              vmaxps  xmm1, xmm0, xmm1
              vmovups [rbp+rax*4+200h+var_1C0], xmm1
              vmovups xmm0, [rbp+rax*4+200h+var_1B0]
              vmulps  xmm1, xmm7, [rbp+rax*4+200h+var_130]
              vmaxps  xmm1, xmm0, xmm1
              vmovups [rbp+rax*4+200h+var_1B0], xmm1
              vmovups xmm0, [rbp+rax*4+200h+var_1A0]
              vmulps  xmm1, xmm7, [rbp+rax*4+200h+var_120]
              vmaxps  xmm1, xmm0, xmm1
            }
            v64 += 16;
            __asm { vmovups [rbp+rax*4+200h+var_1A0], xmm1 }
            _RAX += 16i64;
          }
          while ( v64 < 0x20 );
          __asm
          {
            vminss  xmm10, xmm9, xmm10
            vminss  xmm15, xmm8, xmm15
          }
        }
        mapEnts = cm.mapEnts;
      }
LABEL_39:
      v36 = (unsigned int)(v36 + 1);
    }
  }
  if ( SND_IsEntChannel3D(v21) )
  {
    SND_CalcVoice3DInfo(_RBX, &outListener, &delta, &outVoiceOrientation);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+300h+delta+4]
      vmovss  xmm1, dword ptr [rsp+300h+delta]
    }
    _RAX = _RBX->alias;
    __asm
    {
      vmulss  xmm3, xmm0, xmm0
      vmovss  xmm0, dword ptr [rsp+300h+delta+8]
      vmulss  xmm2, xmm1, xmm1
      vmulss  xmm1, xmm0, xmm0
      vaddss  xmm4, xmm3, xmm2
      vaddss  xmm2, xmm4, xmm1
      vmovss  xmm1, dword ptr [rax+64h]; mindist
      vsqrtss xmm3, xmm2, xmm2
      vmulss  xmm10, xmm3, dword ptr [rbx+88h]
      vmovss  xmm2, dword ptr [rax+68h]; maxdist
      vmovaps xmm0, xmm10; radius
    }
    *(double *)&_XMM0 = SND_GetDistanceCurveFraction(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovaps xmm2, xmm0; distFrac
      vmovaps xmm1, xmm10; dist
      vmovaps xmm8, xmm0
    }
    *(double *)&_XMM0 = SND_GetVolumeFalloffGain(_RBX, *(const float *)&_XMM1, *(const float *)&_XMM2, &_RBX->vfCurve);
    __asm { vmovss  dword ptr [rbx+30h], xmm0 }
    v115 = g_snd.defaultHash;
    __asm { vmovaps xmm9, xmm0 }
    if ( _RBX->rvbCurve.id == g_snd.defaultHash )
    {
      __asm { vmovaps xmm11, xmm0 }
    }
    else
    {
      __asm { vmovaps xmm2, xmm8; fraction }
      *(double *)&_XMM0 = SND_GetSndCurveValue(_RBX->rvbCurve.numPoints, _RBX->rvbCurve.points, *(const float *)&_XMM2);
      v115 = g_snd.defaultHash;
      __asm { vmovaps xmm11, xmm0 }
    }
    __asm { vmovss  xmm7, cs:__real@bf800000 }
    if ( _RBX->lpfCurve.id == v115 )
    {
      __asm { vmovaps xmm6, xmm7 }
    }
    else
    {
      __asm { vmovaps xmm2, xmm8; fraction }
      *(double *)&_XMM0 = SND_GetSndCurveValue(_RBX->lpfCurve.numPoints, _RBX->lpfCurve.points, *(const float *)&_XMM2);
      v115 = g_snd.defaultHash;
      __asm { vmovaps xmm6, xmm0 }
    }
    if ( _RBX->hpfCurve.id == v115 )
    {
      __asm { vmovaps xmm8, xmm7 }
    }
    else
    {
      __asm { vmovaps xmm2, xmm8; fraction }
      *(double *)&_XMM0 = SND_GetSndCurveValue(_RBX->hpfCurve.numPoints, _RBX->hpfCurve.points, *(const float *)&_XMM2);
      __asm { vmovaps xmm8, xmm0 }
    }
    __asm { vmovaps xmm1, xmm10; dist }
    SND_Get3DSpeakerVolumes(outputs, *(const float *)&_XMM1, &delta, &outListener, _RBX, p_speakerMap);
    if ( _RBX->occlusionShape.id != g_snd.defaultHash )
    {
      SND_ApplyOcclusionShape(_RBX, &_RBX->occlusionShape, &outListener, &delta, &outVoiceOrientation, &outVolumeAtten, &v160);
      __asm
      {
        vucomiss xmm6, xmm7
        vmulss  xmm14, xmm14, [rsp+300h+outVolumeAtten]
      }
      if ( v125 )
      {
        __asm { vmovss  xmm6, [rsp+300h+var_2BC] }
      }
      else
      {
        __asm
        {
          vmovss  xmm0, [rsp+300h+var_2BC]
          vucomiss xmm0, xmm7
        }
        if ( !v125 )
          __asm { vminss  xmm6, xmm0, xmm6 }
      }
    }
    focusCone = _RBX->params.focusCone;
    v128 = focusCone == NULL;
    if ( focusCone )
    {
      __asm { vmovss  xmm0, dword ptr [rbx+1F8h]; focusAmount }
      SND_ApplyFocusCone(*(double *)&_XMM0, focusCone, outListener.orient.axis.m, &delta);
      __asm { vmulss  xmm14, xmm14, xmm0 }
    }
    __asm
    {
      vucomiss xmm6, xmm7
      vmovss  xmm0, dword ptr [rbx+100h]
    }
    if ( v128 )
    {
      __asm { vmovaps xmm6, xmm0 }
    }
    else
    {
      __asm { vucomiss xmm0, xmm7 }
      if ( !v128 )
        __asm { vminss  xmm6, xmm0, xmm6 }
    }
    __asm
    {
      vucomiss xmm8, xmm7
      vmovss  xmm0, dword ptr [rbx+104h]
    }
    if ( v128 )
    {
      __asm { vmovaps xmm8, xmm0 }
    }
    else
    {
      __asm { vucomiss xmm0, xmm7 }
      if ( !v128 )
        __asm { vminss  xmm8, xmm0, xmm8 }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+0B4h]
      vmovss  dword ptr [rsp+300h+speakerMap], xmm0
      vmovaps xmm3, xmm6; lpfCutoff
      vmovss  dword ptr [rsp+300h+fmt], xmm8
    }
    SND_ApplyEq(index, v21, frametime, *(float *)&_XMM3, fmta, speakerMapb);
    __asm
    {
      vmulss  xmm3, xmm11, xmm12
      vmulss  xmm2, xmm9, xmm14
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm7, cs:__real@bf800000
      vmovaps xmm6, xmm7
    }
    memset_0(outputs, 0, 0x80ui64);
    SND_UpdateSpeakerMap(_RBX, p_speakerMap, outputs);
    v137 = &_RBX->occlusionShape == NULL;
    if ( _RBX == (SndVoice *)-1864i64 || (v137 = _RBX->occlusionShape.id == g_snd.defaultHash) )
    {
      outListener.localClientNum = LOCAL_CLIENT_INVALID;
    }
    else
    {
      SND_CalcVoice3DInfo(_RBX, &outListener, &delta, &outVoiceOrientation);
      SND_ApplyOcclusionShape(_RBX, &_RBX->occlusionShape, &outListener, &delta, &outVoiceOrientation, &outVolumeAtten, &v161);
      __asm
      {
        vmulss  xmm14, xmm14, [rsp+300h+outVolumeAtten]
        vmovss  xmm6, [rsp+300h+var_2B8]
      }
    }
    __asm
    {
      vucomiss xmm6, xmm7
      vmovss  xmm0, dword ptr [rbx+100h]
    }
    if ( v137 )
    {
      __asm { vmovaps xmm6, xmm0 }
    }
    else
    {
      __asm { vucomiss xmm0, xmm7 }
      if ( !v137 )
        __asm { vminss  xmm6, xmm0, xmm6 }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+0B4h]
      vmovss  xmm1, dword ptr [rbx+104h]
      vmovss  dword ptr [rsp+300h+speakerMap], xmm0
      vmovaps xmm3, xmm6; lpfCutoff
      vmovss  dword ptr [rsp+300h+fmt], xmm1
    }
    SND_ApplyEq(index, v21, frametime, *(float *)&_XMM3, fmtb, speakerMapc);
    __asm
    {
      vmovaps xmm3, xmm12; wetLevel
      vmovaps xmm2, xmm14; dryLevel
    }
  }
  v96 = index;
  v97 = outputs;
LABEL_93:
  SND_ApplyPanningMatrix(v96, v97, *(double *)&_XMM2, *(double *)&_XMM3, (const LocalClientNum_t)outListener.localClientNum);
  __asm
  {
    vmovaps xmm11, [rsp+300h+var_88+8]
    vmovaps xmm10, [rsp+300h+var_78+8]
    vmovaps xmm9, [rsp+300h+var_68+8]
    vmovaps xmm8, [rsp+300h+var_58+8]
    vmovaps xmm7, xmmword ptr [rsp+300h+var_48+8]
  }
  _R11 = &v177;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
}

/*
==============
SND_ApplyVolumeCoefficientAdjustments
==============
*/

void __fastcall SND_ApplyVolumeCoefficientAdjustments(float *speakerlevel, double lfePercentage, double centerPercentage, double omniPercentage, bool panThroughCenter)
{
  __m256i *v25; 
  int v26; 
  __int64 v28; 
  bool v30; 
  char v31; 
  __int64 i; 
  __int64 *v47; 
  unsigned __int64 v48; 
  __int64 v64; 
  int v65; 
  __int64 *v69; 
  __int64 v70; 
  __int64 v84; 
  __int64 v85; 
  unsigned __int64 v86; 
  __int64 *v93; 
  unsigned __int64 v94; 
  __int64 v117; 
  double v118; 
  bool v119; 
  int v120; 
  __m256i v121; 
  int v123; 
  int v124; 
  int v125; 
  __m256i v126; 
  int v128; 
  int v129; 
  char v131; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovdqu ymm0, cs:__ymm@0000000900000008000000070000000600000005000000040000000100000000
  }
  _RBX = speakerlevel;
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vmovaps xmm12, xmm1
    vmovdqu xmm1, cs:__xmm@0000000d0000000c0000000b0000000a
    vmovdqu [rsp+168h+var_D0], xmm1
    vmovdqu xmm1, cs:__xmm@0000000c0000000b0000000a00000009
    vmovdqu [rsp+168h+var_F0], ymm0
    vmovdqu ymm0, cs:__ymm@0000000800000007000000060000000500000004000000020000000100000000
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm12, xmm7
    vmovdqu [rsp+168h+var_110], xmm1
    vmovaps xmm11, xmm3
    vmovaps xmm9, xmm2
  }
  v119 = panThroughCenter;
  v128 = 14;
  v129 = 15;
  __asm { vmovdqu [rsp+168h+var_130], ymm0 }
  v123 = 13;
  v124 = 14;
  v125 = 15;
  __asm { vcomiss xmm12, xmm8 }
  if ( (unsigned __int64)&v117 != _security_cookie )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm12, xmm12
      vmovsd  [rsp+168h+var_140], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12208, ASSERT_TYPE_ASSERT, "( ( lfePercentage >= 0.0f && lfePercentage <= 1.0f ) )", "( lfePercentage ) = %g", v118) )
      __debugbreak();
  }
  if ( !panThroughCenter )
  {
    __asm
    {
      vcomiss xmm9, xmm7
      vcomiss xmm9, xmm8
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vucomiss xmm0, xmm7
  }
  if ( panThroughCenter )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+168h+var_140], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12210, ASSERT_TYPE_ASSERT, "( ( speakerlevel[SD_MIX_CHANNEL_LFE] == 0.0f ) )", "( speakerlevel[SD_MIX_CHANNEL_LFE] ) = %g", v118) )
      __debugbreak();
  }
  if ( !panThroughCenter )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+8]
      vucomiss xmm0, xmm7
    }
  }
  v25 = &v121;
  if ( !panThroughCenter )
    v25 = &v126;
  if ( g_snd.playback_channels <= 2 )
    v26 = 2;
  else
    v26 = g_snd.playback_channels - !panThroughCenter - 1;
  v120 = v26;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( g_snd.playback_channels <= 2 )
  {
    __asm { vcomiss xmm11, xmm7 }
    if ( g_snd.playback_channels > 2u )
    {
      v64 = 0i64;
      v65 = 0;
      __asm { vsubss  xmm3, xmm8, xmm11 }
      if ( v26 > 0 && (unsigned int)v26 >= 8 )
      {
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vxorps  xmm2, xmm2, xmm2
        }
        v69 = &v25->m256i_i64[1];
        v70 = 0i64;
        do
        {
          _RAX = *((int *)v69 - 2);
          v65 += 8;
          v70 += 8i64;
          v69 += 4;
          __asm { vmovss  xmm0, dword ptr [rbx+rax*4] }
          _RAX = *((int *)v69 - 6);
          __asm
          {
            vinsertps xmm0, xmm0, dword ptr [rbx+rcx*4], 10h
            vinsertps xmm0, xmm0, dword ptr [rbx+rdx*4], 20h ; ' '
            vinsertps xmm0, xmm0, dword ptr [rbx+r8*4], 30h ; '0'
            vaddps  xmm1, xmm1, xmm0
            vmovss  xmm0, dword ptr [rbx+rax*4]
            vinsertps xmm0, xmm0, dword ptr [rbx+rcx*4], 10h
            vinsertps xmm0, xmm0, dword ptr [rbx+rdx*4], 20h ; ' '
            vinsertps xmm0, xmm0, dword ptr [rbx+r8*4], 30h ; '0'
            vaddps  xmm2, xmm2, xmm0
          }
        }
        while ( v70 < (int)(v26 - (v26 & 0x80000007)) );
        __asm
        {
          vaddps  xmm1, xmm2, xmm1
          vmovhlps xmm0, xmm1, xmm1
          vaddps  xmm6, xmm0, xmm1
          vshufps xmm0, xmm6, xmm6, 0F5h ; ''
          vaddss  xmm6, xmm6, xmm0
        }
      }
      v84 = v65;
      if ( v65 < (__int64)v26 )
      {
        if ( v26 - (__int64)v65 >= 4 )
        {
          v85 = (__int64)&v25[v65 / 8u].m256i_i64[1];
          v86 = ((unsigned __int64)(v26 - (__int64)v65 - 4) >> 2) + 1;
          v84 = v65 + 4 * v86;
          do
          {
            v85 += 16i64;
            __asm
            {
              vaddss  xmm0, xmm6, dword ptr [rbx+rax*4]
              vaddss  xmm1, xmm0, dword ptr [rbx+rax*4]
              vaddss  xmm2, xmm1, dword ptr [rbx+rax*4]
              vaddss  xmm6, xmm2, dword ptr [rbx+rax*4]
            }
            --v86;
          }
          while ( v86 );
        }
        while ( v84 < v26 )
        {
          ++v84;
          __asm { vaddss  xmm6, xmm6, dword ptr [rbx+rax*4] }
        }
      }
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, r13d
        vdivss  xmm1, xmm11, xmm0
        vmulss  xmm2, xmm6, xmm1
      }
      if ( v26 >= 4i64 )
      {
        v93 = &v25->m256i_i64[1];
        v94 = ((unsigned __int64)(v26 - 4i64) >> 2) + 1;
        v64 = 4 * v94;
        do
        {
          _RAX = *((int *)v93 - 2);
          v93 += 2;
          __asm
          {
            vmulss  xmm0, xmm3, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm2
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          _RAX = *((int *)v93 - 5);
          __asm
          {
            vmulss  xmm0, xmm3, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm2
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          _RAX = *((int *)v93 - 4);
          __asm
          {
            vmulss  xmm0, xmm3, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm2
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          _RAX = *((int *)v93 - 3);
          __asm
          {
            vmulss  xmm0, xmm3, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm2
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          --v94;
        }
        while ( v94 );
      }
      while ( v64 < v26 )
      {
        _RAX = v25->m256i_i32[v64++];
        __asm
        {
          vmulss  xmm0, xmm3, dword ptr [rbx+rax*4]
          vaddss  xmm1, xmm0, xmm2
          vmovss  dword ptr [rbx+rax*4], xmm1
        }
      }
    }
  }
  else
  {
    v28 = 0i64;
    __asm
    {
      vmovaps [rsp+168h+var_88], xmm10
      vsubss  xmm10, xmm8, xmm9
    }
    v30 = v26 == 0;
    if ( v26 > 0 )
    {
      v31 = v119;
      for ( i = 0i64; i < v26; ++i )
      {
        _R15 = v25->m256i_i32[i];
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+0Ch]
          vmaxss  xmm1, xmm0, dword ptr [rbx+r15*4]
          vmovss  dword ptr [rbx+0Ch], xmm1
        }
        if ( !v31 )
        {
          __asm
          {
            vmulss  xmm0, xmm9, dword ptr [rbx+r15*4]
            vaddss  xmm1, xmm0, dword ptr [rbx+8]
            vcomiss xmm1, xmm7
            vmovss  dword ptr [rbx+8], xmm1
            vcomiss xmm1, xmm8
            vmulss  xmm0, xmm10, dword ptr [rbx+r15*4]
            vcomiss xmm0, xmm7
            vmovss  dword ptr [rbx+r15*4], xmm0
            vcomiss xmm0, xmm8
          }
          v31 = v119;
        }
        __asm { vaddss  xmm6, xmm6, dword ptr [rbx+r15*4] }
      }
      v30 = 1;
      v28 = 0i64;
    }
    __asm
    {
      vcomiss xmm11, xmm7
      vmulss  xmm0, xmm12, [rsp+168h+lfeScale]
      vmulss  xmm1, xmm0, dword ptr [rbx+0Ch]
      vmovaps xmm10, [rsp+168h+var_88]
      vmovss  dword ptr [rbx+0Ch], xmm1
    }
    if ( !v30 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, r13d
        vdivss  xmm1, xmm11, xmm0
        vmulss  xmm3, xmm6, xmm1
        vsubss  xmm2, xmm8, xmm11
      }
      if ( v26 >= 4i64 )
      {
        v47 = &v25->m256i_i64[1];
        v48 = ((unsigned __int64)(v26 - 4i64) >> 2) + 1;
        v28 = 4 * v48;
        do
        {
          _RAX = *((int *)v47 - 2);
          v47 += 2;
          __asm
          {
            vmulss  xmm0, xmm2, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm3
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          _RAX = *((int *)v47 - 5);
          __asm
          {
            vmulss  xmm0, xmm2, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm3
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          _RAX = *((int *)v47 - 4);
          __asm
          {
            vmulss  xmm0, xmm2, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm3
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          _RAX = *((int *)v47 - 3);
          __asm
          {
            vmulss  xmm0, xmm2, dword ptr [rbx+rax*4]
            vaddss  xmm1, xmm0, xmm3
            vmovss  dword ptr [rbx+rax*4], xmm1
          }
          --v48;
        }
        while ( v48 );
      }
      while ( v28 < v26 )
      {
        _RAX = v25->m256i_i32[v28++];
        __asm
        {
          vmulss  xmm0, xmm2, dword ptr [rbx+rax*4]
          vaddss  xmm1, xmm0, xmm3
          vmovss  dword ptr [rbx+rax*4], xmm1
        }
      }
    }
  }
  _R11 = &v131;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-20h]
    vmovaps xmm7, xmmword ptr [r11-30h]
    vmovaps xmm8, xmmword ptr [r11-40h]
    vmovaps xmm9, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-70h]
    vmovaps xmm12, xmmword ptr [r11-80h]
  }
}

/*
==============
SND_AttenuateHPF
==============
*/

float __fastcall SND_AttenuateHPF(double currentValue, double attenuation)
{
  char v2; 

  __asm
  {
    vmovss  xmm2, cs:__real@bf800000
    vucomiss xmm0, xmm2
  }
  if ( v2 )
  {
    __asm { vmovaps xmm0, xmm1 }
  }
  else
  {
    __asm { vucomiss xmm1, xmm2 }
    if ( !v2 )
      __asm { vminss  xmm0, xmm0, xmm1 }
  }
  return *(float *)&currentValue;
}

/*
==============
SND_AttenuateLPF
==============
*/

float __fastcall SND_AttenuateLPF(double currentValue, double attenuation)
{
  char v2; 

  __asm
  {
    vmovss  xmm2, cs:__real@bf800000
    vucomiss xmm0, xmm2
  }
  if ( v2 )
  {
    __asm { vmovaps xmm0, xmm1 }
  }
  else
  {
    __asm { vucomiss xmm1, xmm2 }
    if ( !v2 )
      __asm { vminss  xmm0, xmm0, xmm1 }
  }
  return *(float *)&currentValue;
}

/*
==============
SND_BankDetailStream_Debug
==============
*/
void SND_BankDetailStream_Debug(LocalClientNum_t localClientNum)
{
  unsigned __int64 v6; 
  bool active; 
  GfxFont *font; 
  const ScreenPlacement *v10; 
  const char *v13; 
  const dvar_t *v18; 
  int integer; 
  const dvar_t *v23; 
  int v24; 
  const dvar_t *v25; 
  int v26; 
  const dvar_t *v27; 
  const char **v28; 
  unsigned int v30; 
  int v31; 
  __int64 v32; 
  const char *v33; 
  __int64 v34; 
  GfxFont *smallDevFont; 
  const char *v42; 
  GfxFont *v46; 
  const char *v47; 
  __int64 v55; 
  GfxFont *v56; 
  const char *v57; 
  int v62; 
  const SndBankInfo **v63; 
  const SndBankInfo *v64; 
  const SndBank *bank; 
  int v66; 
  SndBankDetailStreamingRequest *detailStreamRequests; 
  int numDetailStreamRequests; 
  int v69; 
  __int64 v70; 
  __int64 v71; 
  SndBankDetailStreamingRequest *v72; 
  const SndBankInfo *bankInfo; 
  SndBankDetailStreamingRequest *v74; 
  GfxFont *v75; 
  const vec4_t *color; 
  const char *v77; 
  GfxFont *v82; 
  const char *v83; 
  float fmtb; 
  char *fmt; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  char *fmta; 
  float fmtf; 
  float fmtg; 
  char *s; 
  int v99; 
  const ScreenPlacement *v100; 
  __int64 v101; 
  int v102; 
  int v103; 
  __int64 v104[5]; 

  if ( localClientNum == LOCAL_CLIENT_0 )
  {
    v6 = (unsigned __int64)&g_snd.listenerFence & 3;
    do
    {
      if ( v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
    active = g_snd.listeners[0].active;
    if ( v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
    _InterlockedExchange(&g_snd.listenerFence, 0);
    if ( active )
    {
      __asm
      {
        vmovaps [rsp+108h+var_38], xmm6
        vmovaps [rsp+108h+var_48], xmm7
        vmovaps [rsp+108h+var_58], xmm8
        vmovaps [rsp+108h+var_68], xmm9
      }
      _RAX = ScrPlace_GetActivePlacement(LOCAL_CLIENT_0);
      font = cls.smallDevFont;
      v10 = _RAX;
      v100 = _RAX;
      __asm
      {
        vmovss  xmm9, dword ptr [rax+28h]
        vmovss  xmm6, dword ptr [rax+2Ch]
      }
      v13 = j_va("Sound Bank Streaming Debug");
      __asm
      {
        vmovss  xmm8, cs:__real@3f333333
        vmovaps xmm3, xmm8; xScale
        vmovaps xmm2, xmm6; y
        vmovaps xmm1, xmm9; x
        vmovss  dword ptr [rsp+108h+fmt], xmm8
      }
      CG_DrawDevString(v10, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtb, v13, &colorCyan, 5, font);
      v18 = DCONST_DVARINT_snd_transient_bank_budget_weapons;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
      }
      v104[0] = (__int64)"weapons";
      v104[1] = (__int64)"vehicles";
      v104[2] = (__int64)"scripts";
      v104[3] = (__int64)"triggers";
      v104[4] = (__int64)"resident";
      __asm { vaddss  xmm6, xmm6, xmm0 }
      if ( !DCONST_DVARINT_snd_transient_bank_budget_weapons && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_transient_bank_budget_weapons") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v18);
      integer = v18->current.integer;
      v23 = DCONST_DVARINT_snd_transient_bank_budget_vehicles;
      LODWORD(v101) = integer;
      if ( !DCONST_DVARINT_snd_transient_bank_budget_vehicles && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_transient_bank_budget_vehicles") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v23);
      v24 = v23->current.integer;
      v25 = DCONST_DVARINT_snd_transient_bank_budget_scripts;
      HIDWORD(v101) = v24;
      if ( !DCONST_DVARINT_snd_transient_bank_budget_scripts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_transient_bank_budget_scripts") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v25);
      v26 = v25->current.integer;
      v27 = DCONST_DVARINT_snd_transient_bank_budget_triggers;
      v102 = v26;
      if ( !DCONST_DVARINT_snd_transient_bank_budget_triggers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_transient_bank_budget_triggers") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v27);
      v28 = (const char **)v104;
      __asm { vmovss  xmm7, cs:__real@42c80000 }
      v30 = 0;
      v103 = v27->current.integer;
      v31 = 0;
      v32 = 0i64;
      do
      {
        v33 = *v28;
        v34 = (unsigned int)g_sb.bankStreamBytesUsed[v32];
        smallDevFont = cls.smallDevFont;
        if ( *(int *)((char *)&v101 + v32 * 4) < 0 )
        {
          v42 = j_va("category[%3d]: %25s - %10d bytes", (unsigned int)v31, v33, v34);
        }
        else
        {
          __asm
          {
            vxorps  xmm1, xmm1, xmm1
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
            vcvtsi2ss xmm1, xmm1, r9d
            vdivss  xmm1, xmm1, xmm0
            vmulss  xmm2, xmm1, xmm7
            vcvttss2si eax, xmm2
          }
          LODWORD(s) = _EAX;
          LODWORD(fmt) = *(_DWORD *)((char *)&v101 + v32 * 4);
          v42 = j_va("category[%3d]: %25s - %10d bytes / %10d bytes max (%3d%%)", (unsigned int)v31, v33, v34, fmt, s);
        }
        __asm
        {
          vmovaps xmm3, xmm8; xScale
          vmovaps xmm2, xmm6; y
          vmovaps xmm1, xmm9; x
          vmovss  dword ptr [rsp+108h+fmt], xmm8
        }
        CG_DrawDevString(v10, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtc, v42, &colorWhite, 5, smallDevFont);
        v30 += g_sb.bankStreamBytesUsed[v32];
        ++v31;
        __asm { vxorps  xmm0, xmm0, xmm0 }
        ++v28;
        ++v32;
        __asm
        {
          vcvtsi2ss xmm0, xmm0, eax
          vaddss  xmm6, xmm0, xmm6
        }
      }
      while ( v31 < 4 );
      v46 = cls.smallDevFont;
      v47 = j_va("                                           %10d total bytes", v30);
      __asm
      {
        vmovaps xmm3, xmm8; xScale
        vmovaps xmm2, xmm6; y
        vmovaps xmm1, xmm9; x
        vmovss  dword ptr [rsp+108h+fmt], xmm8
      }
      CG_DrawDevString(v10, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtd, v47, &colorWhite, 5, v46);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vaddss  xmm6, xmm6, xmm0
      }
      Sys_EnterCriticalSection(CRITSECT_SOUND_BANK);
      __asm { vmovaps xmm7, [rsp+108h+var_48] }
      v55 = 0i64;
      v99 = 0;
      v101 = 0i64;
      do
      {
        v56 = cls.smallDevFont;
        v57 = j_va("Category %s", (const char *)v104[v55]);
        __asm
        {
          vmovaps xmm3, xmm8; xScale
          vmovaps xmm2, xmm6; y
          vmovaps xmm1, xmm9; x
          vmovss  dword ptr [rsp+108h+fmt], xmm8
        }
        CG_DrawDevString(v10, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmte, v57, &colorWhite, 5, v56);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vaddss  xmm6, xmm6, xmm0
        }
        v62 = 32;
        v63 = (const SndBankInfo **)&g_sb.bankStack[32];
        do
        {
          v64 = *v63;
          if ( !*v63 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8574, ASSERT_TYPE_ASSERT, "(bankInfo)", (const char *)&queryFormat, "bankInfo") )
            __debugbreak();
          bank = v64->bank;
          if ( !v64->bank || !v64->bankActive || !bank->name )
            goto LABEL_59;
          if ( bank->streamInfo.alwaysLoaded )
          {
            if ( v55 == 4 )
              goto LABEL_55;
            goto LABEL_59;
          }
          v66 = v99;
          if ( v55 != 4 )
          {
            detailStreamRequests = g_sb.detailStreamRequests;
            if ( v99 == 2 )
              detailStreamRequests = g_sb.scriptDetailStreamRequests;
            numDetailStreamRequests = g_sb.numDetailStreamRequests;
            v69 = 0;
            v70 = 0i64;
            if ( v99 == 2 )
              numDetailStreamRequests = g_sb.numScriptDetailStreamRequests;
            v71 = numDetailStreamRequests;
            if ( numDetailStreamRequests <= 0 )
            {
LABEL_51:
              v55 = v101;
              v10 = v100;
              goto LABEL_60;
            }
            v72 = detailStreamRequests;
            while ( 1 )
            {
              bankInfo = v72->bankInfo;
              if ( bankInfo )
              {
                if ( bankInfo == v64 )
                {
                  v66 = v99;
                  v74 = &detailStreamRequests[v69];
                  if ( !v74 || v74->streamCategory != v99 )
                    goto LABEL_51;
                  v10 = v100;
LABEL_55:
                  v75 = cls.smallDevFont;
                  color = &colorWhite;
                  if ( v64->streamIsActive )
                    color = &colorGreen;
                  LODWORD(fmta) = SND_BankDetailStreaming_BankSizeBytes(v64);
                  v77 = j_va("bank[%3d] %30s - priority = %3d, bytes = %10d", (unsigned int)v62, v64->bank->name, (unsigned int)v64->streamPriority, fmta);
                  __asm
                  {
                    vmovaps xmm3, xmm8; xScale
                    vmovaps xmm2, xmm6; y
                    vmovaps xmm1, xmm9; x
                    vmovss  dword ptr [rsp+108h+fmt], xmm8
                  }
                  CG_DrawDevString(v10, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtf, v77, color, 5, v75);
                  __asm
                  {
                    vxorps  xmm0, xmm0, xmm0
                    vcvtsi2ss xmm0, xmm0, eax
                    vaddss  xmm6, xmm6, xmm0
                  }
LABEL_58:
                  v55 = v101;
LABEL_59:
                  v66 = v99;
                  break;
                }
              }
              else
              {
                Com_PrintWarning(9, "SND_BankDetailStream_Debug(): Request for %s has no associated SndBankInfo\n", v72->detailBank->bank.name);
              }
              ++v69;
              ++v70;
              ++v72;
              if ( v70 >= v71 )
              {
                v10 = v100;
                goto LABEL_58;
              }
            }
          }
LABEL_60:
          ++v62;
          ++v63;
        }
        while ( v62 < 800 );
        ++v55;
        v99 = v66 + 1;
        v101 = v55;
      }
      while ( v55 <= 4 );
      Sys_LeaveCriticalSection(CRITSECT_SOUND_BANK);
      v82 = cls.smallDevFont;
      v83 = j_va("scripted soundbanks state: %llu", g_sb.scriptedSoundbanksStateBitfield);
      __asm
      {
        vmovaps xmm3, xmm8; xScale
        vmovaps xmm2, xmm6; y
        vmovaps xmm1, xmm9; x
        vmovss  dword ptr [rsp+108h+fmt], xmm8
      }
      CG_DrawDevString(v10, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtg, v83, &colorWhite, 5, v82);
      __asm
      {
        vmovaps xmm9, [rsp+108h+var_68]
        vmovaps xmm8, [rsp+108h+var_58]
        vmovaps xmm6, [rsp+108h+var_38]
      }
    }
  }
}

/*
==============
SND_CalcAndAlignDesiredSampleIndex
==============
*/
__int64 SND_CalcAndAlignDesiredSampleIndex(const int startMsec, const int sampleCount, const int sampleRate)
{
  int v13; 
  int v14; 
  __int64 result; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, ecx
    vmulss  xmm2, xmm0, cs:__real@3a83126f
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, r8d
    vmulss  xmm2, xmm2, xmm1
    vcvttss2si ebx, xmm2
  }
  v13 = _EBX % 8;
  v14 = _EBX - _EBX % 8;
  if ( v13 > 4 )
    v14 += 8;
  if ( sampleCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 654, ASSERT_TYPE_ASSERT, "(totalSamples > 0)", (const char *)&queryFormat, "totalSamples > 0") )
    __debugbreak();
  if ( v14 >= sampleCount )
    v14 += -8 - ((v14 - sampleCount) & 0xFFFFFFF8);
  result = 0i64;
  if ( v14 >= 0 )
    return (unsigned int)v14;
  return result;
}

/*
==============
SND_CalcAttenuation
==============
*/

float __fastcall SND_CalcAttenuation(double baseVolume, double volumeScale, const SndAlias *p_alias, const unsigned __int64 sndEnt, const snd_alias_system_t system)
{
  SndVoiceParams params; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmm7, xmm1
    vmovaps xmm6, xmm0
  }
  SND_SetUpVoiceParams(&params, p_alias, sndEnt, system);
  __asm
  {
    vmulss  xmm0, xmm6, xmm7
    vmulss  xmm1, xmm0, [rsp+0C8h+params.entChannelVol]
    vmulss  xmm2, xmm1, [rsp+0C8h+params.levelFadeInVol]
    vmulss  xmm3, xmm2, [rsp+0C8h+params.volModValue]
    vmulss  xmm6, xmm3, [rsp+0C8h+params.entityVolume]
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
  {
    __asm { vmulss  xmm0, xmm6, [rsp+0C8h+params.globalVolume] }
  }
  else
  {
    __asm
    {
      vmulss  xmm1, xmm6, [rsp+0C8h+params.scriptSoundFade]
      vmulss  xmm0, xmm1, [rsp+0C8h+params.globalVolume]
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+0C8h+var_18]
    vmovaps xmm7, [rsp+0C8h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_CalcVoice3DInfo
==============
*/
void SND_CalcVoice3DInfo(SndVoice *voice, snd_listener *outListener, vec3_t *outListenerSpaceVoicePosition, tmat33_t<vec3_t> *outVoiceOrientation)
{
  SecureVec3 outVoicePosition; 
  __int64 v17; 
  tmat33_t<vec3_t> outVoiceMatrix; 

  v17 = -2i64;
  _R14 = outListenerSpaceVoicePosition;
  _RBX = outListener;
  if ( cg_maxLocalClients <= 0 )
  {
    *(_QWORD *)outListenerSpaceVoicePosition->v = 0i64;
    outListenerSpaceVoicePosition->v[2] = 0.0;
    MatrixIdentity33(outVoiceOrientation);
    __asm
    {
      vmovups ymm0, ymmword ptr cs:?orIdentity@@3Uorientation_t@@B.origin; orientation_t const orIdentity
      vmovups ymmword ptr [rbx], ymm0
      vmovups xmm1, xmmword ptr cs:?orIdentity@@3Uorientation_t@@B.axis+14h; orientation_t const orIdentity
      vmovups xmmword ptr [rbx+20h], xmm1
    }
    _RBX->localClientNum = LOCAL_CLIENT_INVALID;
    voice->reverbDef = NULL;
  }
  else
  {
    SND_UpdateVoicePosition(voice, &outVoicePosition, &outVoiceMatrix);
    SND_GetListenerNearestToOrigin((const vec3_t *)&outVoicePosition, _RBX);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+98h+outVoicePosition.___u0]
      vsubss  xmm1, xmm0, dword ptr [rbx]
      vmovss  dword ptr [r14], xmm1
      vmovss  xmm2, dword ptr [rsp+98h+outVoicePosition.___u0+4]
      vsubss  xmm0, xmm2, dword ptr [rbx+4]
      vmovss  dword ptr [r14+4], xmm0
      vmovss  xmm1, dword ptr [rsp+98h+outVoicePosition.___u0+8]
      vsubss  xmm2, xmm1, dword ptr [rbx+8]
      vmovss  dword ptr [r14+8], xmm2
    }
    AxisCopy(&outVoiceMatrix, outVoiceOrientation);
    if ( SND_EntChannelFarReverbBehavior((unsigned __int8)(voice->alias->flags >> 10)) && CG_FindAudioTriggerAtPoint(_RBX->localClientNum, (const vec3_t *)&outVoicePosition, 0x40u, &voice->propagationTriggerIndex) )
      CG_GetReverbDefForTrigger(_RBX->localClientNum, voice->propagationTriggerIndex, (const vec3_t *)&outVoicePosition, &voice->reverbDef);
    else
      voice->reverbDef = NULL;
    memset(&outVoicePosition, 0, sizeof(outVoicePosition));
  }
}

/*
==============
SND_CalcVoicePitch
==============
*/
float SND_CalcVoicePitch(const int frametime, SndVoice *voice)
{
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+84h]
    vmulss  xmm1, xmm0, dword ptr [rdx+54h]
    vmovaps [rsp+38h+var_18], xmm6
    vmulss  xmm6, xmm1, dword ptr [rdx+0F8h]
  }
  SND_UpdateParameter(&voice->pitchInfo, frametime, 0);
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rdi+58h]
    vmulss  xmm1, xmm0, dword ptr [rdi+1D0h]
    vmulss  xmm0, xmm1, dword ptr [rdi+1D8h]
    vmovaps xmm6, [rsp+38h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_CalcVoiceVolume
==============
*/
float SND_CalcVoiceVolume(const int frametime, SndVoice *voice)
{
  int flags; 
  int v26; 
  int v27; 
  const dvar_t *v31; 
  const dvar_t *v34; 
  const char **p_aliasName; 
  const dvar_t *v39; 
  const char *string; 
  const SndAlias *alias; 
  const dvar_t *v42; 
  const char *v43; 
  const char *VolModName; 
  const SndAlias *v45; 
  const dvar_t *v46; 
  const char *v47; 
  const char *v48; 
  const SndAlias *v49; 
  const dvar_t *v50; 
  const char *v51; 
  const char *v52; 
  const SndAlias *v54; 
  const dvar_t *v55; 
  const char *v56; 
  const char *EntChannelName; 
  char v70; 

  __asm
  {
    vmovss  xmm0, dword ptr [rdx+80h]
    vmulss  xmm1, xmm0, dword ptr [rdx+28h]
    vmulss  xmm2, xmm1, dword ptr [rdx+1DCh]
    vmulss  xmm3, xmm2, dword ptr [rdx+1E0h]
    vmulss  xmm0, xmm3, dword ptr [rdx+1E4h]
    vmovaps [rsp+98h+var_38], xmm6
    vmulss  xmm6, xmm0, dword ptr [rdx+1D4h]
    vmovaps [rsp+98h+var_48], xmm7
    vmovaps [rsp+98h+var_58], xmm8
  }
  _RBX = voice;
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
    __asm { vmulss  xmm6, xmm6, dword ptr [rbx+1E8h] }
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rbx+1FCh]
    vmulss  xmm6, xmm0, dword ptr [rbx+50h]
  }
  if ( frametime > 0 )
  {
    SND_UpdateParameter(&_RBX->volumeInfo, frametime, 1);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, edi
      vmulss  xmm1, xmm0, cs:__real@3a83126f; dt
    }
    SND_FaderUpdate(&_RBX->fadeInOut, *(float *)&_XMM1);
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+120h]
    vmulss  xmm0, xmm0, cs:__real@3fc90fdb; X
  }
  *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rbx+38h]
    vmulss  xmm0, xmm0, xmm1
    vmulss  xmm2, xmm0, dword ptr [rbx+138h]
    vmulss  xmm3, xmm2, dword ptr [rbx+1ECh]
    vmulss  xmm7, xmm3, dword ptr [rbx+108h]
  }
  flags = _RBX->alias->flags;
  v26 = flags & 0x300000;
  v27 = flags >> 10;
  __asm { vxorps  xmm8, xmm8, xmm8 }
  if ( v26 == 0x200000 )
  {
    _RDI = DVARFLT_profileMenuOption_licensedMusicVolume;
    if ( !DVARFLT_profileMenuOption_licensedMusicVolume && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "profileMenuOption_licensedMusicVolume") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm6, dword ptr [rdi+28h] }
    v31 = DVARFLT_profileMenuOption_musicVolume;
    if ( !DVARFLT_profileMenuOption_musicVolume && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "profileMenuOption_musicVolume") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v31);
    __asm
    {
      vmulss  xmm0, xmm6, dword ptr [rdi+28h]
      vmulss  xmm7, xmm7, xmm0
    }
  }
  else
  {
    switch ( SND_GetEntChannelSubmixBus((unsigned __int8)v27) )
    {
      case SND_BUS_SFX:
      case SND_BUS_WEAP_EXP_SCENES:
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_profileMenuOption_effectsVolume, "profileMenuOption_effectsVolume");
        __asm { vmulss  xmm7, xmm7, xmm0 }
        break;
      case SND_BUS_DIALOGUE:
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_profileMenuOption_voiceVolume, "profileMenuOption_voiceVolume");
        __asm { vmulss  xmm7, xmm7, xmm0 }
        if ( MLG_IsCoDCasterEnabled() && MLG_IsLocalPlayerMLGSpectator(LOCAL_CLIENT_0) )
          __asm { vxorps  xmm7, xmm7, xmm7 }
        break;
      case SND_BUS_REFERENCE:
        break;
      case SND_BUS_LICENCED:
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_profileMenuOption_musicVolume, "profileMenuOption_musicVolume");
        __asm { vmovaps xmm6, xmm0 }
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_profileMenuOption_licensedMusicVolume, "profileMenuOption_licensedMusicVolume");
        __asm
        {
          vmulss  xmm1, xmm6, xmm0
          vmulss  xmm7, xmm7, xmm1
        }
        break;
      case SND_BUS_MUSIC:
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_profileMenuOption_musicVolume, "profileMenuOption_musicVolume");
        __asm { vmulss  xmm7, xmm7, xmm0 }
        break;
      default:
        v34 = DVARFLT_profileMenuOption_effectsVolume;
        if ( !DVARFLT_profileMenuOption_effectsVolume && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "profileMenuOption_effectsVolume") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v34);
        __asm { vmulss  xmm7, xmm7, dword ptr [rdi+28h] }
        break;
    }
  }
  _ER13 = 0;
  if ( Dvar_GetBoolSafe("NMMPTOSMKQ") )
  {
    __asm
    {
      vmovd   xmm0, dword ptr [rbx+0BCh]
      vmovd   xmm1, r13d
      vpcmpeqd xmm2, xmm0, xmm1
      vblendvps xmm7, xmm8, xmm7, xmm2
    }
  }
  p_aliasName = &_RBX->alias->aliasName;
  if ( !p_aliasName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4127, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
    __debugbreak();
  v39 = DCONST_DVARSTR_snd_solo_alias;
  if ( !DCONST_DVARSTR_snd_solo_alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_solo_alias") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v39);
  string = v39->current.string;
  if ( string && *string && !SND_ParseSoloMuteSubstring(string, *p_aliasName) || SND_IsMuteAlias(_RBX->alias) )
    goto LABEL_63;
  alias = _RBX->alias;
  if ( !alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4183, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
    __debugbreak();
  v42 = DCONST_DVARSTR_snd_solo_volmod;
  if ( !DCONST_DVARSTR_snd_solo_volmod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_solo_volmod") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v42);
  v43 = v42->current.string;
  if ( v43 )
  {
    if ( *v43 )
    {
      VolModName = SND_GetVolModName(alias->volModIndex);
      if ( !SND_ParseSoloMuteSubstring(v43, VolModName) )
        goto LABEL_63;
    }
  }
  v45 = _RBX->alias;
  if ( !v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4199, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
    __debugbreak();
  v46 = DCONST_DVARSTR_snd_mute_volmod;
  if ( !DCONST_DVARSTR_snd_mute_volmod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_mute_volmod") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v46);
  v47 = v46->current.string;
  if ( v47 )
  {
    if ( *v47 )
    {
      v48 = SND_GetVolModName(v45->volModIndex);
      if ( SND_ParseSoloMuteSubstring(v47, v48) )
        goto LABEL_63;
    }
  }
  v49 = _RBX->alias;
  if ( !v49 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4215, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
    __debugbreak();
  v50 = DCONST_DVARSTR_snd_solo_channel;
  if ( !DCONST_DVARSTR_snd_solo_channel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_solo_channel") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v50);
  v51 = v50->current.string;
  if ( v51 && *v51 && (v52 = SND_GetEntChannelName((unsigned __int8)(v49->flags >> 10)), !SND_ParseSoloMuteSubstring(v51, v52)) )
  {
LABEL_63:
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  else
  {
    v54 = _RBX->alias;
    if ( !v54 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4231, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
      __debugbreak();
    v55 = DCONST_DVARSTR_snd_mute_channel;
    if ( !DCONST_DVARSTR_snd_mute_channel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_mute_channel") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v55);
    v56 = v55->current.string;
    if ( v56 && *v56 )
    {
      EntChannelName = SND_GetEntChannelName((unsigned __int8)(v54->flags >> 10));
      _EAX = SND_ParseSoloMuteSubstring(v56, EntChannelName);
      __asm
      {
        vmovd   xmm0, eax
        vmovd   xmm1, r13d
        vpcmpeqd xmm2, xmm0, xmm1
        vblendvps xmm0, xmm8, xmm7, xmm2
      }
    }
    else
    {
      __asm { vmovaps xmm0, xmm7 }
    }
  }
  __asm { vmovaps xmm6, [rsp+98h+var_38] }
  _R11 = &v70;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm7, [rsp+98h+var_48]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_CalculateOcclusionValues
==============
*/
void SND_CalculateOcclusionValues(const int voiceIndex, int frameTime)
{
  unsigned int v10; 
  SndFader *p_occlusionVolume; 
  SndFader *p_occlusionCutoff; 

  _R14 = &g_snd;
  _RBX = voiceIndex;
  __asm
  {
    vmovaps [rsp+88h+var_38], xmm6
    vmovaps [rsp+88h+var_48], xmm7
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmm7, xmm6
  }
  v10 = (unsigned __int8)(g_snd.voices[_RBX].alias->flags >> 10);
  if ( SND_EntChannelHasOcclusion(v10) && (g_snd.voices[_RBX].sndEnt & 0x1000000000i64) != 0 && !SND_IsEntChannelPASpeaker(v10) )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+r14+0CAE4h]
      vcomiss xmm1, cs:__real@3f400000
      vcomiss xmm1, cs:__real@3f000000
      vcomiss xmm1, cs:__real@3e800000
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm1, xmm0
    }
  }
  _RSI = DCONST_DVARFLT_snd_occfadetime;
  if ( !DCONST_DVARFLT_snd_occfadetime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occfadetime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RSI);
  __asm { vmovss  xmm1, dword ptr [rsi+28h]; time }
  p_occlusionVolume = &g_snd.voices[_RBX].occlusionVolume;
  SND_FaderSetRateTime(p_occlusionVolume, *(float *)&_XMM1);
  _RSI = DCONST_DVARFLT_snd_occfadetime;
  if ( !DCONST_DVARFLT_snd_occfadetime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occfadetime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RSI);
  __asm { vmovss  xmm1, dword ptr [rsi+28h]; time }
  p_occlusionCutoff = &g_snd.voices[_RBX].occlusionCutoff;
  SND_FaderSetRateTime(p_occlusionCutoff, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm6; g }
  SND_FaderSetGoal(p_occlusionVolume, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm7; g }
  SND_FaderSetGoal(p_occlusionCutoff, *(float *)&_XMM1);
  if ( !frameTime )
  {
    p_occlusionVolume->value = p_occlusionVolume->goal;
    p_occlusionCutoff->value = p_occlusionCutoff->goal;
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, ebp
    vmulss  xmm6, xmm0, cs:__real@3a83126f
    vmovaps xmm1, xmm6; dt
  }
  SND_FaderUpdate(p_occlusionVolume, *(float *)&_XMM1);
  __asm
  {
    vmovaps xmm1, xmm6; dt
    vmovaps xmm6, [rsp+88h+var_38]
    vmovaps xmm7, [rsp+88h+var_48]
  }
  SND_FaderUpdate(p_occlusionCutoff, *(float *)&_XMM1);
}

/*
==============
SND_CanDoPhysicsQuery
==============
*/
bool SND_CanDoPhysicsQuery()
{
  return s_soundPhysicsQueryBlock == 0;
}

/*
==============
SND_ChangeSoundAliasListValue
==============
*/
void SND_ChangeSoundAliasListValue(const SndAliasList *aliasList, const char *columnName, const char *value)
{
  int v6; 
  __int64 v7; 
  SndAlias *structure; 
  __int64 v9; 
  const char *v10; 
  int v11; 
  __int64 v12; 
  int v13; 
  int v14; 
  int v15; 
  SndAliasList *Alias; 
  unsigned int oldEntChannel; 

  if ( !aliasList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16749, ASSERT_TYPE_ASSERT, "(aliasList)", (const char *)&queryFormat, "aliasList") )
    __debugbreak();
  if ( !columnName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16750, ASSERT_TYPE_ASSERT, "(columnName)", (const char *)&queryFormat, "columnName") )
    __debugbreak();
  if ( !value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16751, ASSERT_TYPE_ASSERT, (const char *)&stru_143CE7590.m_end, (const char *)&queryFormat, &stru_143CE7590) )
    __debugbreak();
  v6 = 0;
  if ( aliasList->count > 0 )
  {
    v7 = 0i64;
    while ( 2 )
    {
      structure = &aliasList->head[v7];
      oldEntChannel = (unsigned __int8)(structure->flags >> 10);
      if ( SND_CsvSetField("devhost", 0x38u, SND_ALIAS_FIELDS, columnName, value, 0, structure, NULL) == -1 )
      {
        Com_PrintWarning(9, "SND_ChangeSoundAliasListValue: Invalid CSV column '%s'\n", columnName);
      }
      else
      {
        v9 = 0x7FFFFFFFi64;
        v10 = columnName;
        if ( !columnName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        do
        {
          v11 = (unsigned __int8)v10["SecondaryAliasName" - columnName];
          v12 = v9;
          v13 = *(unsigned __int8 *)v10++;
          --v9;
          if ( !v12 )
            break;
          if ( v11 != v13 )
          {
            v14 = v11 + 32;
            if ( (unsigned int)(v11 - 65) > 0x19 )
              v14 = v11;
            v11 = v14;
            v15 = v13 + 32;
            if ( (unsigned int)(v13 - 65) > 0x19 )
              v15 = v13;
            if ( v11 != v15 )
              goto LABEL_29;
          }
        }
        while ( v11 );
        if ( value && *value )
        {
          Alias = SND_FindAlias(value);
          if ( !Alias )
          {
            Com_PrintWarning(9, "SND_ChangeSoundAliasListValue: Invalid SecondaryAliasName '%s' (not loaded?)\n", value);
            return;
          }
          structure->secondaryAliasName = Alias->aliasName;
        }
        else
        {
          structure->secondaryAliasName = NULL;
          structure->secondaryId = 0;
        }
LABEL_29:
        SND_ChangeSoundAliasValuesOnPlayingChannels(structure, oldEntChannel);
        ++v6;
        ++v7;
        if ( v6 < aliasList->count )
          continue;
      }
      break;
    }
  }
}

/*
==============
SND_ChangeSoundAliasValuesOnPlayingChannels
==============
*/
void SND_ChangeSoundAliasValuesOnPlayingChannels(const SndAlias *alias, const unsigned int oldEntChannel)
{
  unsigned int v11; 
  bool IsEntChannel3D; 
  int v13; 
  int v17; 
  bool *v19; 
  __int64 *v20; 
  __int64 v21; 
  __int64 v22; 
  const char *aliasName; 
  __int64 v24; 
  char v25; 
  __int64 v26; 
  char v27; 
  const OcclusionShape *OcclusionShapeById; 
  unsigned int duck; 
  const SndDuck *DuckById; 
  __int64 v104; 
  bool v114; 
  const char *EntChannelName; 
  const char *v130; 
  __int64 v131; 
  unsigned int entchannel; 
  bool *voiceAlloc; 
  unsigned int *chaninfoEntchannel; 
  const SndCurve *VfCurveById; 
  void *retaddr; 
  bool v142; 
  int index; 
  int v145; 

  _RAX = &retaddr;
  _R15 = alias;
  __asm { vmovaps xmmword ptr [rax-78h], xmm8 }
  v11 = (unsigned __int8)(alias->flags >> 10);
  __asm
  {
    vmovaps [rsp+0E8h+var_88], xmm9
    vmovaps [rsp+0E8h+var_98], xmm10
  }
  entchannel = v11;
  IsEntChannel3D = SND_IsEntChannel3D(v11);
  v142 = IsEntChannel3D == SND_IsEntChannel3D(oldEntChannel);
  v13 = 0;
  v145 = 0;
  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  cls.inUpdateSound = 1;
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
  __asm
  {
    vmovss  xmm8, cs:__real@40800000
    vmovss  xmm9, cs:__real@40000000
    vmovss  xmm10, cs:__real@3a83126f
    vmovaps [rsp+0E8h+var_58], xmm6
  }
  voiceAlloc = sdGlob.voiceAlloc;
  __asm { vmovaps [rsp+0E8h+var_68], xmm7 }
  v17 = 0;
  chaninfoEntchannel = g_snd.chaninfoEntchannel;
  _RBP = &g_snd.voices[0].basevolume;
  index = 0;
  v19 = sdGlob.voiceAlloc;
  do
  {
    if ( (unsigned int)v17 > 0x62 )
    {
      LODWORD(v131) = v17;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v131) )
        __debugbreak();
      v17 = index;
    }
    if ( !*v19 )
      goto LABEL_54;
    v20 = (__int64 *)*((_QWORD *)_RBP + 9);
    if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16662, ASSERT_TYPE_ASSERT, "(playingAlias != nullptr)", (const char *)&queryFormat, "playingAlias != nullptr") )
      __debugbreak();
    v21 = *v20;
    v22 = 0x7FFFFFFFi64;
    aliasName = _R15->aliasName;
    if ( !*v20 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !aliasName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v24 = v21 - (_QWORD)aliasName;
    do
    {
      v25 = aliasName[v24];
      v26 = v22;
      v27 = *aliasName++;
      --v22;
      if ( !v26 )
        break;
      if ( v25 != v27 )
        goto LABEL_53;
    }
    while ( v25 );
    if ( *((_DWORD *)v20 + 18) != _R15->sequence )
    {
LABEL_53:
      v17 = index;
      v11 = entchannel;
      v13 = v145;
LABEL_54:
      v114 = v142;
      goto LABEL_55;
    }
    __asm { vmovss  xmm6, dword ptr [r15+4Ch] }
    *(double *)&_XMM0 = I_random();
    __asm
    {
      vmovss  xmm1, dword ptr [r15+50h]
      vsubss  xmm2, xmm1, xmm6
      vmulss  xmm0, xmm0, xmm2
      vaddss  xmm0, xmm0, xmm6; val
      vmovaps xmm2, xmm8; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovss  xmm6, dword ptr [r15+58h]
      vmovaps xmm7, xmm0
    }
    *(double *)&_XMM0 = I_random();
    __asm
    {
      vmovss  xmm1, dword ptr [r15+5Ch]
      vsubss  xmm2, xmm1, xmm6
      vmulss  xmm3, xmm0, xmm2
      vaddss  xmm0, xmm3, xmm6; val
      vmovaps xmm2, xmm9; max
      vmovaps xmm1, xmm10; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm6, xmm0 }
    VfCurveById = SND_GetVfCurveById(_R15->volumeFalloffCurve);
    _R14 = SND_GetLpfCurveById(_R15->lpfCurve);
    _R13 = SND_GetHpfCurveById(_R15->hpfCurve);
    _R12 = SND_GetRvbCurveById(_R15->reverbSendCurve);
    _RBX = SND_GetSpeakerMapById(_R15->speakerMap);
    _RDI = SND_GetDopplerPresetById(_R15->dopplerPreset);
    OcclusionShapeById = SND_GetOcclusionShapeById(_R15->occlusionShape);
    __asm
    {
      vmovss  dword ptr [rbp+0], xmm7
      vmovss  dword ptr [rbp+2Ch], xmm6
    }
    duck = _R15->duck;
    _RSI = OcclusionShapeById;
    if ( duck )
      DuckById = SND_GetDuckById(duck);
    else
      DuckById = NULL;
    *((_QWORD *)_RBP + 33) = DuckById;
    if ( !VfCurveById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16690, ASSERT_TYPE_ASSERT, "(vfCurve)", (const char *)&queryFormat, "vfCurve") )
      __debugbreak();
    if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16691, ASSERT_TYPE_ASSERT, "(lpfCurve)", (const char *)&queryFormat, "lpfCurve") )
      __debugbreak();
    if ( !_R13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16692, ASSERT_TYPE_ASSERT, "(hpfCurve)", (const char *)&queryFormat, "hpfCurve") )
      __debugbreak();
    if ( !_R12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16693, ASSERT_TYPE_ASSERT, "(rvbCurve)", (const char *)&queryFormat, "rvbCurve") )
      __debugbreak();
    if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16694, ASSERT_TYPE_ASSERT, "(speakerMap)", (const char *)&queryFormat, "speakerMap") )
      __debugbreak();
    if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16695, ASSERT_TYPE_ASSERT, "(dopplerPreset)", (const char *)&queryFormat, "dopplerPreset") )
      __debugbreak();
    if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16696, ASSERT_TYPE_ASSERT, "(occlusionShape)", (const char *)&queryFormat, "occlusionShape") )
      __debugbreak();
    _RAX = VfCurveById;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rbp+1E4h], xmm0
      vmovups xmm1, xmmword ptr [rax+10h]
      vmovups xmmword ptr [rbp+1F4h], xmm1
      vmovups xmm0, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rbp+204h], xmm0
      vmovups xmm1, xmmword ptr [rax+30h]
      vmovups xmmword ptr [rbp+214h], xmm1
      vmovups xmm0, xmmword ptr [rax+40h]
      vmovups xmmword ptr [rbp+224h], xmm0
      vmovups xmm1, xmmword ptr [rax+50h]
      vmovups xmmword ptr [rbp+234h], xmm1
      vmovups xmm0, xmmword ptr [rax+60h]
      vmovups xmmword ptr [rbp+244h], xmm0
      vmovups xmm1, xmmword ptr [rax+70h]
      vmovups xmmword ptr [rbp+254h], xmm1
      vmovups xmm0, xmmword ptr [rax+80h]
      vmovups xmmword ptr [rbp+264h], xmm0
      vmovups xmm1, xmmword ptr [rax+90h]
      vmovups xmmword ptr [rbp+274h], xmm1
      vmovups xmm0, xmmword ptr [rax+0A0h]
      vmovups xmmword ptr [rbp+284h], xmm0
      vmovups xmm1, xmmword ptr [rax+0B0h]
      vmovups xmmword ptr [rbp+294h], xmm1
    }
    *(vec2_t *)(_RBP + 169) = VfCurveById->points[15];
    __asm
    {
      vmovups xmm0, xmmword ptr [r14]
      vmovups xmmword ptr [rbp+2ACh], xmm0
      vmovups xmm1, xmmword ptr [r14+10h]
      vmovups xmmword ptr [rbp+2BCh], xmm1
      vmovups xmm0, xmmword ptr [r14+20h]
      vmovups xmmword ptr [rbp+2CCh], xmm0
      vmovups xmm1, xmmword ptr [r14+30h]
      vmovups xmmword ptr [rbp+2DCh], xmm1
      vmovups xmm0, xmmword ptr [r14+40h]
      vmovups xmmword ptr [rbp+2ECh], xmm0
      vmovups xmm1, xmmword ptr [r14+50h]
      vmovups xmmword ptr [rbp+2FCh], xmm1
      vmovups xmm0, xmmword ptr [r14+60h]
      vmovups xmmword ptr [rbp+30Ch], xmm0
      vmovups xmm1, xmmword ptr [r14+70h]
      vmovups xmmword ptr [rbp+31Ch], xmm1
    }
    _R14 = &_R14->points[7];
    __asm
    {
      vmovups xmm0, xmmword ptr [r14]
      vmovups xmmword ptr [rbp+32Ch], xmm0
      vmovups xmm1, xmmword ptr [r14+10h]
      vmovups xmmword ptr [rbp+33Ch], xmm1
      vmovups xmm0, xmmword ptr [r14+20h]
      vmovups xmmword ptr [rbp+34Ch], xmm0
      vmovups xmm1, xmmword ptr [r14+30h]
      vmovups xmmword ptr [rbp+35Ch], xmm1
    }
    *(vec2_t *)(_RBP + 219) = _R14[8];
    __asm
    {
      vmovups xmm0, xmmword ptr [r13+0]
      vmovups xmmword ptr [rbp+374h], xmm0
      vmovups xmm1, xmmword ptr [r13+10h]
      vmovups xmmword ptr [rbp+384h], xmm1
      vmovups xmm0, xmmword ptr [r13+20h]
      vmovups xmmword ptr [rbp+394h], xmm0
      vmovups xmm1, xmmword ptr [r13+30h]
      vmovups xmmword ptr [rbp+3A4h], xmm1
      vmovups xmm0, xmmword ptr [r13+40h]
      vmovups xmmword ptr [rbp+3B4h], xmm0
      vmovups xmm1, xmmword ptr [r13+50h]
      vmovups xmmword ptr [rbp+3C4h], xmm1
      vmovups xmm0, xmmword ptr [r13+60h]
      vmovups xmmword ptr [rbp+3D4h], xmm0
      vmovups xmm1, xmmword ptr [r13+70h]
      vmovups xmmword ptr [rbp+3E4h], xmm1
      vmovups xmm0, xmmword ptr [r13+80h]
      vmovups xmmword ptr [rbp+3F4h], xmm0
      vmovups xmm1, xmmword ptr [r13+90h]
      vmovups xmmword ptr [rbp+404h], xmm1
      vmovups xmm0, xmmword ptr [r13+0A0h]
      vmovups xmmword ptr [rbp+414h], xmm0
      vmovups xmm1, xmmword ptr [r13+0B0h]
      vmovups xmmword ptr [rbp+424h], xmm1
    }
    *(vec2_t *)(_RBP + 269) = _R13->points[15];
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovups xmmword ptr [rbp+43Ch], xmm0
      vmovups xmm1, xmmword ptr [r12+10h]
      vmovups xmmword ptr [rbp+44Ch], xmm1
      vmovups xmm0, xmmword ptr [r12+20h]
      vmovups xmmword ptr [rbp+45Ch], xmm0
      vmovups xmm1, xmmword ptr [r12+30h]
      vmovups xmmword ptr [rbp+46Ch], xmm1
      vmovups xmm0, xmmword ptr [r12+40h]
      vmovups xmmword ptr [rbp+47Ch], xmm0
      vmovups xmm1, xmmword ptr [r12+50h]
      vmovups xmmword ptr [rbp+48Ch], xmm1
      vmovups xmm0, xmmword ptr [r12+60h]
      vmovups xmmword ptr [rbp+49Ch], xmm0
      vmovups xmm1, xmmword ptr [r12+70h]
      vmovups xmmword ptr [rbp+4ACh], xmm1
      vmovups xmm0, xmmword ptr [r12+80h]
      vmovups xmmword ptr [rbp+4BCh], xmm0
      vmovups xmm1, xmmword ptr [r12+90h]
      vmovups xmmword ptr [rbp+4CCh], xmm1
      vmovups xmm0, xmmword ptr [r12+0A0h]
      vmovups xmmword ptr [rbp+4DCh], xmm0
      vmovups xmm1, xmmword ptr [r12+0B0h]
      vmovups xmmword ptr [rbp+4ECh], xmm1
    }
    _RCX = _RBP + 321;
    *(vec2_t *)(_RBP + 319) = _R12->points[15];
    v104 = 3i64;
    do
    {
      _RCX += 32;
      __asm { vmovups xmm0, xmmword ptr [rbx] }
      _RBX = (const SpeakerMap *)((char *)_RBX + 128);
      __asm
      {
        vmovups xmmword ptr [rcx-80h], xmm0
        vmovups xmm1, xmmword ptr [rbx-70h]
        vmovups xmmword ptr [rcx-70h], xmm1
        vmovups xmm0, xmmword ptr [rbx-60h]
        vmovups xmmword ptr [rcx-60h], xmm0
        vmovups xmm1, xmmword ptr [rbx-50h]
        vmovups xmmword ptr [rcx-50h], xmm1
        vmovups xmm0, xmmword ptr [rbx-40h]
        vmovups xmmword ptr [rcx-40h], xmm0
        vmovups xmm1, xmmword ptr [rbx-30h]
        vmovups xmmword ptr [rcx-30h], xmm1
        vmovups xmm0, xmmword ptr [rbx-20h]
        vmovups xmmword ptr [rcx-20h], xmm0
        vmovups xmm1, xmmword ptr [rbx-10h]
        vmovups xmmword ptr [rcx-10h], xmm1
      }
      --v104;
    }
    while ( v104 );
    __asm { vmovups xmm0, xmmword ptr [rbx] }
    v114 = v142;
    __asm
    {
      vmovups xmmword ptr [rcx], xmm0
      vmovups xmm1, xmmword ptr [rbx+10h]
      vmovups xmmword ptr [rcx+10h], xmm1
      vmovups xmm0, xmmword ptr [rbx+20h]
      vmovups xmmword ptr [rcx+20h], xmm0
      vmovups xmm1, xmmword ptr [rbx+30h]
      vmovups xmmword ptr [rcx+30h], xmm1
    }
    _RCX[16] = *(float *)&_RBX->id;
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi]
      vmovups ymmword ptr [rbp+6C8h], ymm0
      vmovups ymm1, ymmword ptr [rdi+20h]
      vmovups ymmword ptr [rbp+6E8h], ymm1
      vmovups xmm0, xmmword ptr [rdi+40h]
      vmovups xmmword ptr [rbp+708h], xmm0
      vmovsd  xmm1, qword ptr [rdi+50h]
    }
    v11 = entchannel;
    __asm
    {
      vmovsd  qword ptr [rbp+718h], xmm1
      vmovups ymm0, ymmword ptr [rsi]
      vmovups ymmword ptr [rbp+720h], ymm0
      vmovups ymm1, ymmword ptr [rsi+20h]
      vmovups ymmword ptr [rbp+740h], ymm1
      vmovups ymm0, ymmword ptr [rsi+40h]
      vmovups ymmword ptr [rbp+760h], ymm0
    }
    _RBP[480] = _RSI->pitchOffsetAngle;
    if ( entchannel == oldEntChannel || !v142 )
      goto LABEL_51;
    if ( SND_HasFreeVoice(entchannel) )
    {
      SND_RemoveVoice(oldEntChannel);
      SND_AddVoice(entchannel);
      *chaninfoEntchannel = entchannel;
LABEL_51:
      v17 = index;
      v19 = voiceAlloc;
      v13 = v145;
      goto LABEL_55;
    }
    SND_StopVoice(index);
    v17 = index;
    v13 = v145 + 1;
    v19 = voiceAlloc;
    ++v145;
LABEL_55:
    ++chaninfoEntchannel;
    ++v17;
    ++v19;
    index = v17;
    _RBP += 492;
    voiceAlloc = v19;
  }
  while ( v17 < 99 );
  cls.inUpdateSound = 0;
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  __asm
  {
    vmovaps xmm10, [rsp+0E8h+var_98]
    vmovaps xmm9, [rsp+0E8h+var_88]
    vmovaps xmm8, [rsp+0E8h+var_78]
    vmovaps xmm7, [rsp+0E8h+var_68]
    vmovaps xmm6, [rsp+0E8h+var_58]
  }
  if ( !v114 )
  {
    EntChannelName = SND_GetEntChannelName(v11);
    Com_PrintWarning(9, "SndAlias %s cannot LiveUpdate EntChannel 2D/3D dimension %s\n", _R15->aliasName, EntChannelName);
  }
  if ( v13 > 0 )
  {
    v130 = SND_GetEntChannelName(v11);
    Com_PrintWarning(9, "SndAlias %s stopped %i voices for changed EntChannel %s\n", _R15->aliasName, (unsigned int)v13, v130);
  }
}

/*
==============
SND_ClearAllOcclusionSettings
==============
*/
void SND_ClearAllOcclusionSettings(void)
{
  __int64 i; 
  __int64 v1; 

  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7461, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  for ( i = 0i64; (unsigned int)i < g_snd.globals->entchannelCount; g_snd.entChanOcclusionParams[v1][1].attnLevel4 = 1.0 )
  {
    v1 = i;
    i = (unsigned int)(i + 1);
    g_snd.entChanOcclusionParams[v1][0].enabled = 0;
    g_snd.entChanOcclusionParams[v1][0].cutoffLevel1 = 1.0;
    g_snd.entChanOcclusionParams[v1][0].cutoffLevel2 = 1.0;
    g_snd.entChanOcclusionParams[v1][0].cutoffLevel3 = 1.0;
    g_snd.entChanOcclusionParams[v1][0].cutoffLevel4 = 1.0;
    g_snd.entChanOcclusionParams[v1][0].attnLevel1 = 1.0;
    g_snd.entChanOcclusionParams[v1][0].attnLevel2 = 1.0;
    g_snd.entChanOcclusionParams[v1][0].attnLevel3 = 1.0;
    g_snd.entChanOcclusionParams[v1][0].attnLevel4 = 1.0;
    g_snd.entChanOcclusionParams[v1][1].enabled = 0;
    g_snd.entChanOcclusionParams[v1][1].cutoffLevel1 = 1.0;
    g_snd.entChanOcclusionParams[v1][1].cutoffLevel2 = 1.0;
    g_snd.entChanOcclusionParams[v1][1].cutoffLevel3 = 1.0;
    g_snd.entChanOcclusionParams[v1][1].cutoffLevel4 = 1.0;
    g_snd.entChanOcclusionParams[v1][1].attnLevel1 = 1.0;
    g_snd.entChanOcclusionParams[v1][1].attnLevel2 = 1.0;
    g_snd.entChanOcclusionParams[v1][1].attnLevel3 = 1.0;
  }
}

/*
==============
SND_ClearDrawOnlyChannel_f
==============
*/
void SND_ClearDrawOnlyChannel_f(void)
{
  if ( Cmd_Argc() == 1 )
    snd_drawOnlyChannel = -1;
  else
    Com_Printf(9, "USAGE: snd_clearDrawOnlyChannel\n");
}

/*
==============
SND_ClearMainReverb
==============
*/

void __fastcall SND_ClearMainReverb(double fadetime, __int64 a2, __int64 a3, double _XMM3_8)
{
  unsigned int defaultHash; 
  BOOL v10; 
  __int64 v11; 

  defaultHash = g_snd.defaultHash;
  _ESI = 0;
  __asm
  {
    vmovaps [rsp+38h+var_18], xmm6
    vmovaps xmm6, xmm0
  }
  _EBP = 1;
  if ( sdGlob.currentReverbId[0] == g_snd.defaultHash )
  {
    v10 = 0;
  }
  else if ( sdGlob.currentReverbId[1] == g_snd.defaultHash )
  {
    v10 = 1;
  }
  else
  {
    v10 = g_snd.activeMainReverb != RVB_MAIN_B;
    SND_SetReverbParams(g_snd.defaultHash, (ReverbDescriptor)v10, 0);
  }
  g_snd.activeMainReverb = v10;
  g_snd.reverbSetting[v10].presetId = defaultHash;
  g_snd.reverbSetting[g_snd.activeMainReverb].drylevel = 1.0;
  v11 = 0i64;
  g_snd.reverbSetting[g_snd.activeMainReverb].wetlevel = 0.0;
  _ECX = g_snd.activeMainReverb;
  if ( g_snd.activeMainReverb != RVB_MAIN_B )
    v11 = 1i64;
  if ( !g_snd.reverbSetting[v11].presetId )
  {
    __asm
    {
      vmovss  xmm2, cs:__real@3f800000
      vmovd   xmm0, ecx
      vxorps  xmm4, xmm4, xmm4
      vmovd   xmm1, ebp
      vpcmpeqd xmm3, xmm0, xmm1
      vblendvps xmm0, xmm4, xmm2, xmm3
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm4; snd_local_t g_snd
    }
LABEL_14:
    __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm0; snd_local_t g_snd }
    goto LABEL_15;
  }
  __asm
  {
    vxorps  xmm3, xmm3, xmm3
    vucomiss xmm6, xmm3
  }
  if ( g_snd.activeMainReverb == RVB_MAIN_B )
  {
    __asm { vmovd   xmm1, esi }
    _EAX = g_snd.activeMainReverb == RVB_MAIN_B;
    __asm
    {
      vmovd   xmm0, eax
      vpcmpeqd xmm2, xmm0, xmm1
      vmovss  xmm1, cs:__real@3f800000
      vblendvps xmm0, xmm1, xmm3, xmm2
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm3; snd_local_t g_snd
    }
    goto LABEL_14;
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vdivss  xmm1, xmm0, xmm6
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm1; snd_local_t g_snd
    vmovss  xmm0, cs:__real@ba83126f
    vdivss  xmm1, xmm0, xmm6
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm1; snd_local_t g_snd
  }
LABEL_15:
  __asm { vmovaps xmm6, [rsp+38h+var_18] }
}

/*
==============
SND_ClearReverbs
==============
*/
void SND_ClearReverbs(void)
{
  unsigned int v0; 
  unsigned int *currentReverbId; 
  int v2; 
  unsigned int defaultHash; 
  unsigned int v5; 
  const SndSendEffectParams *Radverb; 
  SndReverbSetting *v50; 
  unsigned int v51; 
  unsigned int v52; 
  unsigned int *v53; 
  unsigned int *v54; 
  __int64 v55; 
  __int64 v56; 
  snd_rv_params params; 
  snd_quad_five_tap_delay_params v58; 

  v0 = 0;
  currentReverbId = sdGlob.currentReverbId;
  v2 = 0;
  _R15 = sdGlob.currentReverbParams;
  do
  {
    defaultHash = g_snd.defaultHash;
    v5 = 0;
    if ( (unsigned int)v2 >= 4 )
    {
      LODWORD(v56) = 4;
      LODWORD(v55) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1676, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( RVB_MAX_NUM )", "index doesn't index RVB_MAX_NUM\n\t%i not in [0, %i)", v55, v56) )
        __debugbreak();
    }
    SND_RvParamsDefault(&params);
    SND_DelayParamsDefault(&v58);
    _RCX = SND_GetRadverb(defaultHash);
    if ( _RCX || (Radverb = SND_GetRadverb(g_snd.defaultHash), defaultHash = g_snd.defaultHash, (_RCX = Radverb) != NULL) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+48h]
        vmovss  [rsp+130h+params.earlyTime], xmm0
        vmovss  xmm1, dword ptr [rcx+4Ch]
        vmovss  [rsp+130h+params.lateTime], xmm1
        vmovss  xmm0, dword ptr [rcx+50h]
        vmovss  [rsp+130h+params.earlyGain], xmm0
        vmovss  xmm1, dword ptr [rcx+54h]
        vmovss  [rsp+130h+params.lateGain], xmm1
        vmovss  xmm0, dword ptr [rcx+5Ch]
        vmovss  [rsp+130h+params.returnGain], xmm0
        vmovss  xmm1, dword ptr [rcx+60h]
        vmovss  [rsp+130h+params.earlyLpf], xmm1
        vmovss  xmm0, dword ptr [rcx+64h]
        vmovss  [rsp+130h+params.lateLpf], xmm0
        vmovss  xmm1, dword ptr [rcx+68h]
        vmovss  [rsp+130h+params.inputLpf], xmm1
        vmovss  xmm0, dword ptr [rcx+6Ch]
        vmovss  [rsp+130h+params.dampLpf], xmm0
        vmovss  xmm1, dword ptr [rcx+74h]
        vmovss  [rsp+130h+params.dryGain], xmm1
        vmovss  xmm0, dword ptr [rcx+78h]
        vmovss  [rsp+130h+params.earlySize], xmm0
        vmovss  xmm1, dword ptr [rcx+7Ch]
        vmovss  [rbp+30h+params.lateSize], xmm1
        vmovss  xmm0, dword ptr [rcx+80h]
        vmovss  [rbp+30h+params.diffusion], xmm0
        vmovss  xmm1, dword ptr [rcx+84h]
        vmovss  [rbp+30h+params.rearLevel], xmm1
      }
      params.fade = 0;
      params.fadeTimeStamp = g_snd.time;
      v58.params[0].enabled = _RCX->delay1enabled;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+8Ch]
        vmovss  [rbp+30h+var_A0.params.delayTimeMS], xmm0
        vmovss  xmm1, dword ptr [rcx+90h]
        vmovss  [rbp+30h+var_A0.params.level], xmm1
        vmovss  xmm0, dword ptr [rcx+94h]
        vmovss  [rbp+30h+var_A0.params.lpfCutoff], xmm0
        vmovss  xmm1, dword ptr [rcx+98h]
        vmovss  [rbp+30h+var_A0.params.hpfCutoff], xmm1
      }
      v58.params[1].enabled = _RCX->delay2enabled;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+0A0h]
        vmovss  [rbp+30h+var_A0.params.delayTimeMS+14h], xmm0
        vmovss  xmm1, dword ptr [rcx+0A4h]
        vmovss  [rbp+30h+var_A0.params.level+14h], xmm1
        vmovss  xmm0, dword ptr [rcx+0A8h]
        vmovss  [rbp+30h+var_A0.params.lpfCutoff+14h], xmm0
        vmovss  xmm1, dword ptr [rcx+0ACh]
        vmovss  [rbp+30h+var_A0.params.hpfCutoff+14h], xmm1
      }
      v58.params[2].enabled = _RCX->delay3enabled;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+0B4h]
        vmovss  [rbp+30h+var_A0.params.delayTimeMS+28h], xmm0
        vmovss  xmm1, dword ptr [rcx+0B8h]
        vmovss  [rbp+30h+var_A0.params.level+28h], xmm1
        vmovss  xmm0, dword ptr [rcx+0BCh]
        vmovss  [rbp+30h+var_A0.params.lpfCutoff+28h], xmm0
        vmovss  xmm1, dword ptr [rcx+0C0h]
        vmovss  [rbp+30h+var_A0.params.hpfCutoff+28h], xmm1
      }
      v58.params[3].enabled = _RCX->delay4enabled;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+0C8h]
        vmovss  [rbp+30h+var_A0.params.delayTimeMS+3Ch], xmm0
        vmovss  xmm1, dword ptr [rcx+0CCh]
        vmovss  [rbp+30h+var_A0.params.level+3Ch], xmm1
        vmovss  xmm0, dword ptr [rcx+0D0h]
        vmovss  [rbp+30h+var_A0.params.lpfCutoff+3Ch], xmm0
        vmovss  xmm1, dword ptr [rcx+0D4h]
        vmovss  [rbp+30h+var_A0.params.hpfCutoff+3Ch], xmm1
      }
      v58.params[4].enabled = _RCX->delay5enabled;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+0DCh]
        vmovss  [rbp+30h+var_A0.params.delayTimeMS+50h], xmm0
        vmovss  xmm1, dword ptr [rcx+0E0h]
        vmovss  [rbp+30h+var_A0.params.level+50h], xmm1
        vmovss  xmm0, dword ptr [rcx+0E4h]
        vmovss  [rbp+30h+var_A0.params.lpfCutoff+50h], xmm0
        vmovss  xmm1, dword ptr [rcx+0E8h]
        vmovss  [rbp+30h+var_A0.params.hpfCutoff+50h], xmm1
      }
      v5 = defaultHash;
    }
    _RAX = &params;
    ++v2;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [r15], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovups ymmword ptr [r15+20h], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [r15+40h], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups ymmword ptr [r15+60h], ymm0
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovups ymmword ptr [r15+80h], ymm0
      vmovups xmm0, xmmword ptr [rax+0A0h]
    }
    *(float *)&_RAX = v58.params[4].hpfCutoff;
    __asm { vmovups xmmword ptr [r15+0A0h], xmm0 }
    LODWORD(_R15->delayParams.params[4].hpfCutoff) = (_DWORD)_RAX;
    ++_R15;
    *currentReverbId++ = v5;
  }
  while ( v2 < 4 );
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm0; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm0; snd_local_t g_snd
  }
  g_snd.activeMainReverb = RVB_MAIN_A;
  v50 = &g_snd.reverbSetting[1];
  v51 = 0;
  do
  {
    v51 += 2;
    v50[-1].presetId = 0;
    v50->presetId = 0;
    v50 += 2;
  }
  while ( v51 < 2 );
  v52 = 0;
  v53 = &g_snd.farReverbIds[1];
  do
  {
    v52 += 2;
    *(_QWORD *)(v53 - 1) = 0i64;
    v53 += 2;
  }
  while ( v52 < 2 );
  v54 = &g_snd.reverbTrigger[1];
  do
  {
    v0 += 4;
    *(v54 - 1) = 1024;
    *v54 = 1024;
    v54[1] = 1024;
    v54[2] = 1024;
    v54 += 4;
  }
  while ( v0 < 4 );
}

/*
==============
SND_ClearSoloChannel_f
==============
*/

void __fastcall SND_ClearSoloChannel_f(__int64 a1, __int64 a2, double _XMM2_8)
{
  unsigned int v4; 

  if ( Cmd_Argc() == 1 )
  {
    v4 = 0;
    __asm
    {
      vmovaps [rsp+48h+var_18], xmm6
      vmovss  xmm6, cs:__real@3f800000
    }
    while ( g_snd.globals && v4 < g_snd.globals->entchannelCount )
    {
      if ( CL_GetLocalClientActiveCount() <= 1 )
      {
        if ( (!g_snd.globals || v4 >= g_snd.globals->entchannelCount) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6771, ASSERT_TYPE_ASSERT, "(channel >= 0 && channel < SND_GetEntChannelCount())", (const char *)&queryFormat, "channel >= 0 && channel < SND_GetEntChannelCount()") )
          __debugbreak();
        __asm
        {
          vmovaps xmm3, xmm6; max
          vxorps  xmm2, xmm2, xmm2; min
          vmovaps xmm1, xmm6; value
        }
        SND_SetParamValue(&g_snd.levelFadeInChannelVols.channelvol[v4], *(float *)&_XMM1, *(float *)&_XMM2_8, *(float *)&_XMM3, 0);
      }
      ++v4;
    }
    __asm { vmovaps xmm6, [rsp+48h+var_18] }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_clearSoloChannel\n");
  }
}

/*
==============
SND_ContinueLoopingSound
==============
*/
bool SND_ContinueLoopingSound(const SndAlias *alias, const SndPlayParams *inParams, int *outVoice)
{
  int v10; 
  bool *voiceAlloc; 
  sd_voice **voices; 
  const SndAlias *v15; 
  const char *v16; 
  sd_voice *v17; 
  bool result; 
  SndEntState *EntState; 
  const tmat33_t<vec3_t> *v24; 
  __int64 v53; 
  int v54; 
  int v55; 
  int v56; 
  int v57; 
  int v58; 
  int v59; 
  vec3_t outOrigin; 
  __int64 v61; 
  tmat33_t<vec3_t> out; 
  char v63; 
  void *retaddr; 

  _RAX = &retaddr;
  v61 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
  }
  _RBP = inParams;
  v10 = 0;
  _RDI = 0i64;
  voiceAlloc = sdGlob.voiceAlloc;
  voices = g_sd.voices;
  _R13 = &g_snd;
  while ( 1 )
  {
    if ( g_snd.voices[_RDI].sndEnt != _RBP->sndEnt )
      goto LABEL_20;
    if ( (unsigned int)v10 > 0x62 )
    {
      LODWORD(v53) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v53) )
        __debugbreak();
    }
    if ( !*voiceAlloc )
      goto LABEL_20;
    if ( !g_snd.voices[_RDI].alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3875, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
      __debugbreak();
    v15 = g_snd.voices[_RDI].alias;
    if ( (v15->flags & 1) == 0 || v15->aliasName != alias->aliasName || v15->contextType != alias->contextType || v15->contextValue != alias->contextValue )
      goto LABEL_20;
    if ( v15->surfaceFlags == alias->surfaceFlags )
      break;
    __asm { vxorps  xmm1, xmm1, xmm1; g }
    SND_FaderSetGoal(&g_snd.voices[_RDI].fadeInOut, *(float *)&_XMM1);
    v16 = j_va("Fading out looping voice %i due to surface change", (unsigned int)v10);
    SND_DebugAliasPrint(1, g_snd.voices[_RDI].alias, v16);
LABEL_20:
    ++v10;
    ++voiceAlloc;
    ++_RDI;
    ++voices;
    if ( v10 >= 99 )
    {
      result = 0;
      goto LABEL_22;
    }
  }
  v17 = *voices;
  if ( *voices && (v17->state != SD_VOICE_ACTIVE || v17->isSync && v17->syncState != SD_VOICE_SYNC_ACTIVE) )
    goto LABEL_20;
  g_snd.voices[_RDI].volumeScale = _RBP->volumeScale;
  g_snd.voices[_RDI].pitchScale = _RBP->pitch;
  g_snd.voices[_RDI].distanceScale = _RBP->distanceScale;
  __asm { vmovss  xmm1, cs:__real@3f800000; g }
  SND_FaderSetGoal(&g_snd.voices[_RDI].fadeInOut, *(float *)&_XMM1);
  g_snd.voices[_RDI].looptime = g_snd.looptime;
  EntState = SND_FindEntState(g_snd.voices[_RDI].sndEnt, 0);
  v24 = (const tmat33_t<vec3_t> *)EntState;
  if ( EntState && EntState->hasPosition )
  {
    SndEntState_GetOrigin(EntState, &outOrigin);
    AxisCopy(v24 + 2, &out);
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+28h]
      vmovss  [rsp+0C8h+var_98], xmm0
    }
    if ( (v54 & 0x7F800000) == 2139095040 )
      goto LABEL_39;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+2Ch]
      vmovss  [rsp+0C8h+var_98], xmm0
    }
    if ( (v55 & 0x7F800000) == 2139095040 )
      goto LABEL_39;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+30h]
      vmovss  [rsp+0C8h+var_98], xmm0
    }
    if ( (v56 & 0x7F800000) == 2139095040 )
    {
LABEL_39:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3922, ASSERT_TYPE_SANITY, "( !IS_NAN( ( inParams.org )[0] ) && !IS_NAN( ( inParams.org )[1] ) && !IS_NAN( ( inParams.org )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( inParams.org )[0] ) && !IS_NAN( ( inParams.org )[1] ) && !IS_NAN( ( inParams.org )[2] )") )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+28h]
      vsubss  xmm7, xmm0, dword ptr [rsp+0C8h+outOrigin]
      vmovss  xmm1, dword ptr [rbp+2Ch]
      vsubss  xmm5, xmm1, dword ptr [rsp+0C8h+outOrigin+4]
      vmovss  xmm0, dword ptr [rbp+30h]
      vsubss  xmm6, xmm0, dword ptr [rsp+0C8h+outOrigin+8]
      vmulss  xmm2, xmm5, dword ptr [rsp+0C8h+out+4]
      vmulss  xmm1, xmm7, dword ptr [rsp+0C8h+out]
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm2, xmm6, dword ptr [rsp+0C8h+out+8]
      vaddss  xmm1, xmm3, xmm2
      vmovss  dword ptr [rdi+r13+0CAC8h], xmm1
      vmulss  xmm3, xmm5, dword ptr [rsp+0C8h+out+10h]
      vmulss  xmm2, xmm7, dword ptr [rsp+0C8h+out+0Ch]
      vaddss  xmm4, xmm3, xmm2
      vmulss  xmm1, xmm6, dword ptr [rsp+0C8h+out+14h]
      vaddss  xmm2, xmm4, xmm1
      vmovss  dword ptr [rdi+r13+0CACCh], xmm2
      vmulss  xmm3, xmm5, dword ptr [rsp+0C8h+out+1Ch]
      vmulss  xmm2, xmm7, dword ptr [rsp+0C8h+out+18h]
      vaddss  xmm4, xmm3, xmm2
      vmulss  xmm1, xmm6, dword ptr [rsp+0C8h+out+20h]
      vaddss  xmm2, xmm4, xmm1
      vmovss  dword ptr [rdi+r13+0CAD0h], xmm2
      vmovss  xmm0, dword ptr [rdi+r13+0CAC8h]
      vmovss  [rsp+0C8h+var_98], xmm0
    }
    if ( (v57 & 0x7F800000) == 2139095040 )
      goto LABEL_40;
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+r13+0CACCh]
      vmovss  [rsp+0C8h+var_98], xmm0
    }
    if ( (v58 & 0x7F800000) == 2139095040 )
      goto LABEL_40;
    __asm { vmovss  [rsp+0C8h+var_98], xmm2 }
    if ( (v59 & 0x7F800000) == 2139095040 )
    {
LABEL_40:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3927, ASSERT_TYPE_SANITY, "( !IS_NAN( ( voice->offset )[0] ) && !IS_NAN( ( voice->offset )[1] ) && !IS_NAN( ( voice->offset )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( voice->offset )[0] ) && !IS_NAN( ( voice->offset )[1] ) && !IS_NAN( ( voice->offset )[2] )") )
        __debugbreak();
    }
  }
  else
  {
    g_snd.voices[_RDI].offset.v[0] = _RBP->org.v[0];
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+2Ch]
      vmovss  dword ptr [rdi+r13+0CACCh], xmm0
      vmovss  xmm1, dword ptr [rbp+30h]
      vmovss  dword ptr [rdi+r13+0CAD0h], xmm1
    }
  }
  *outVoice = v10;
  result = 1;
  memset(&outOrigin, 0, sizeof(outOrigin));
LABEL_22:
  _R11 = &v63;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
SND_CreateAutoSimId
==============
*/
__int64 SND_CreateAutoSimId(int index, int instanceId)
{
  __int64 v2; 
  __int64 v4; 
  __int64 result; 
  int v7; 

  v2 = index;
  if ( (unsigned int)index >= 0x40 )
  {
    v7 = 64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15243, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( sizeof( *array_counter( g_sd.autoSims ) ) + 0 ) )", "index doesn't index ARRAY_COUNT( g_sd.autoSims )\n\t%i not in [0, %i)", index, v7) )
      __debugbreak();
  }
  v4 = v2;
  g_sd.autoSims[v4].startTime = g_sd.autoSimClock;
  g_sd.autoSims[v4].instanceId = instanceId;
  result = (instanceId << 16) | (unsigned int)(unsigned __int16)v2;
  g_sd.autoSims[v4].currentShotCount = SND_WEAP_SHOT_UNCOUNTED;
  return result;
}

/*
==============
SND_DeInitMemory
==============
*/

void SND_DeInitMemory(void)
{
  SD_AllocDeInit();
}

/*
==============
SND_DeactivateAllEq
==============
*/
void SND_DeactivateAllEq(int eqIndex)
{
  int v2; 
  bool *p_enabled; 
  int v4; 
  bool *v5; 
  __int64 v6; 
  __int64 v7; 

  v2 = 0;
  p_enabled = &sdGlob.eqParams[eqIndex][0][0].enabled;
  do
  {
    v4 = 0;
    v5 = p_enabled;
    do
    {
      if ( (unsigned int)v2 >= 0x100 )
      {
        LODWORD(v7) = 256;
        LODWORD(v6) = v2;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 926, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      if ( (unsigned int)v4 >= 2 )
      {
        LODWORD(v7) = 2;
        LODWORD(v6) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 927, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      if ( (unsigned int)eqIndex >= 2 )
      {
        LODWORD(v7) = 2;
        LODWORD(v6) = eqIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 928, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      *v5 = 0;
      ++v4;
      v5 += 5120;
    }
    while ( v4 < 2 );
    ++v2;
    p_enabled += 20;
  }
  while ( v2 < 256 );
}

/*
==============
SND_DeactivateAllFilters
==============
*/
void SND_DeactivateAllFilters(void)
{
  int v0; 
  bool *p_enabled; 
  int v2; 
  bool *v3; 
  int i; 
  __int64 v5; 
  __int64 v6; 

  v0 = 0;
  p_enabled = &sdGlob.eqParams[0][0][0].enabled;
  do
  {
    v2 = 0;
    v3 = p_enabled;
    do
    {
      for ( i = 0; i < 2; ++i )
      {
        if ( (unsigned int)v0 >= 0x100 )
        {
          LODWORD(v6) = 256;
          LODWORD(v5) = v0;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 926, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v5, v6) )
            __debugbreak();
        }
        if ( (unsigned int)i >= 2 )
        {
          LODWORD(v6) = 2;
          LODWORD(v5) = i;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 927, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v5, v6) )
            __debugbreak();
        }
        if ( (unsigned int)v2 >= 2 )
        {
          LODWORD(v6) = 2;
          LODWORD(v5) = v2;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 928, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v5, v6) )
            __debugbreak();
        }
        *v3 = 0;
        v3 += 5120;
      }
      ++v2;
    }
    while ( v2 < 2 );
    ++v0;
    p_enabled += 20;
  }
  while ( v0 < 256 );
}

/*
==============
SND_DeactivateChannelVolumes
==============
*/

void __fastcall SND_DeactivateChannelVolumes(int priority, int fademsec, double _XMM2_8)
{
  __int64 v7; 
  int currentChannelPriority; 
  __int64 v10; 
  bool *p_active; 
  unsigned int v13; 
  __int64 v14; 
  __int64 v25; 
  __int64 v26; 

  v7 = priority;
  if ( g_snd.driverInitialized && CL_GetLocalClientActiveCount() <= 1 )
  {
    if ( (unsigned int)(v7 - 1) > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6827, ASSERT_TYPE_ASSERT, "( ( priority > SND_CHANNELVOLPRIO_NONE && priority < SND_CHANNELVOLPRIO_COUNT ) )", "( priority ) = %i", v7) )
      __debugbreak();
    if ( fademsec < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6828, ASSERT_TYPE_ASSERT, "(fademsec >= 0)", (const char *)&queryFormat, "fademsec >= 0") )
      __debugbreak();
    _RSI = &g_snd.channelPriorityVolGroups[v7];
    _RSI->active = 0;
    if ( (_DWORD)v7 == g_snd.currentChannelPriority )
    {
      currentChannelPriority = v7 - 1;
      __asm { vmovaps [rsp+98h+var_58], xmm8 }
      v10 = currentChannelPriority;
      if ( currentChannelPriority >= 0 )
      {
        p_active = &g_snd.channelPriorityVolGroups[currentChannelPriority].active;
        do
        {
          if ( *p_active )
            break;
          --currentChannelPriority;
          p_active -= 6148;
          --v10;
        }
        while ( v10 >= 0 );
      }
      if ( currentChannelPriority < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6841, ASSERT_TYPE_ASSERT, "(i >= SND_CHANNELVOLPRIO_NONE)", (const char *)&queryFormat, "i >= SND_CHANNELVOLPRIO_NONE") )
        __debugbreak();
      __asm
      {
        vmovss  xmm8, cs:__real@3f800000
        vmovaps [rsp+98h+var_38], xmm6
      }
      v13 = 0;
      g_snd.currentChannelPriority = currentChannelPriority;
      v14 = currentChannelPriority;
      __asm { vmovaps [rsp+98h+var_48], xmm7 }
      while ( g_snd.globals && v13 < g_snd.globals->entchannelCount )
      {
        if ( (unsigned int)currentChannelPriority >= 4 )
        {
          LODWORD(v26) = 4;
          LODWORD(v25) = currentChannelPriority;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 612, ASSERT_TYPE_ASSERT, "(unsigned)( g_snd.currentChannelPriority ) < (unsigned)( ( sizeof( *array_counter( g_snd.channelPriorityVolGroups ) ) + 0 ) )", "g_snd.currentChannelPriority doesn't index ARRAY_COUNT( g_snd.channelPriorityVolGroups )\n\t%i not in [0, %i)", v25, v26) )
            __debugbreak();
          currentChannelPriority = g_snd.currentChannelPriority;
        }
        _RAX = 3 * v14;
        __asm { vmovss  xmm6, dword ptr [rsi+rax*8] }
        _RCX = &g_snd.channelPriorityVolGroups[currentChannelPriority];
        __asm { vmovss  xmm7, dword ptr [rcx+rax*8] }
        _RBX = &_RCX->channelvol[v14];
        if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
          __debugbreak();
        __asm
        {
          vmovaps xmm3, xmm8; max
          vxorps  xmm2, xmm2, xmm2; min
          vmovaps xmm1, xmm7; value
        }
        *(_QWORD *)&_RBX->goalrate = 1065353216i64;
        __asm
        {
          vmovss  dword ptr [rbx], xmm6
          vmovss  dword ptr [rbx+4], xmm6
        }
        _RBX->goalgain = 0.0;
        SND_SetParamValue(_RBX, *(float *)&_XMM1, *(float *)&_XMM2_8, *(float *)&_XMM3, fademsec);
        currentChannelPriority = g_snd.currentChannelPriority;
        ++v13;
      }
      __asm
      {
        vmovaps xmm7, [rsp+98h+var_48]
        vmovaps xmm6, [rsp+98h+var_38]
        vmovaps xmm8, [rsp+98h+var_58]
      }
    }
  }
}

/*
==============
SND_DeactivateEq
==============
*/
void SND_DeactivateEq(const char *channelName, int eqIndex, int band)
{
  int EntChannelFromName; 

  EntChannelFromName = SND_GetEntChannelFromName(channelName);
  if ( EntChannelFromName == -1 )
    Com_PrintError(9, "Unknown channel name (%s), please check channel definitions file\n", channelName);
  else
    SND_DeactivateEqForChannel(EntChannelFromName, eqIndex, band);
}

/*
==============
SND_DeactivateEqForChannel
==============
*/
void SND_DeactivateEqForChannel(int entchannel, int eqIndex, int band)
{
  int v7; 

  if ( (unsigned int)entchannel >= 0x100 )
  {
    v7 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7577, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v7) )
      __debugbreak();
  }
  SND_DisableEq(entchannel, eqIndex, band);
}

/*
==============
SND_DeactivateEq_f
==============
*/
void SND_DeactivateEq_f()
{
  int v0; 
  unsigned int v1; 
  int v2; 
  int v3; 
  const char *v4; 
  unsigned int v5; 
  int v6; 
  int EntChannelFromName; 
  unsigned int v8; 
  int i; 
  int j; 
  int k; 
  __int64 v12; 
  __int64 v13; 

  v0 = Cmd_Argc();
  if ( (unsigned int)(v0 - 2) > 2 )
  {
    Com_Printf(9, "USAGE: snd_deactivateEq <int eqIndex> [(optional) const char *channelName] [(optional) int band]\n");
    return;
  }
  v1 = Cmd_ArgInt(1);
  if ( v1 > 1 )
  {
    Com_Printf(9, "invalid 'eqIndex' %i, must be >= 0 and < %i\n", v1, 2i64);
    return;
  }
  v2 = v0 - 2;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 != 1 )
        return;
      v4 = Cmd_Argv(2);
      v5 = Cmd_ArgInt(3);
      v6 = v5;
      if ( v5 > 1 )
      {
        Com_Printf(9, "invalid 'band' %i, must be >= 0 and < %i\n", v5, 2i64);
        return;
      }
      EntChannelFromName = SND_GetEntChannelFromName(v4);
      if ( EntChannelFromName != -1 )
      {
        SND_DeactivateEqForChannel(EntChannelFromName, v1, v6);
        return;
      }
LABEL_12:
      Com_PrintError(9, "Unknown channel name (%s), please check channel definitions file\n", v4);
      return;
    }
    v4 = Cmd_Argv(2);
    v8 = SND_GetEntChannelFromName(v4);
    if ( v8 == -1 )
      goto LABEL_12;
    for ( i = 0; i < 2; ++i )
    {
      if ( v8 >= 0x100 )
      {
        LODWORD(v13) = 256;
        LODWORD(v12) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7577, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
      }
      SND_DisableEq(v8, v1, i);
    }
  }
  else
  {
    for ( j = 0; j < 256; ++j )
    {
      for ( k = 0; k < 2; ++k )
        SND_DisableEq(j, v1, k);
    }
  }
}

/*
==============
SND_DebugAddOcclusionLine
==============
*/
void SND_DebugAddOcclusionLine(const vec3_t *start, const vec3_t *end, bool occluded, unsigned int id, float fraction)
{
  const dvar_t *v5; 
  ntl::internal::list_node_base *mp_next; 
  unsigned __int64 v11; 
  const dvar_t *v12; 
  int v22; 
  __m256i v42; 
  __m256i v43; 

  v5 = DCONST_DVARINT_snd_occlusionDebug;
  _RBP = start;
  _RDI = end;
  if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.integer )
  {
    mp_next = s_occlusionLines.m_listHead.m_sentinel.mp_next;
    v11 = 0i64;
    if ( (ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine> > *)s_occlusionLines.m_listHead.m_sentinel.mp_next == &s_occlusionLines.m_listHead )
      goto LABEL_8;
    do
    {
      mp_next = mp_next->mp_next;
      ++v11;
    }
    while ( mp_next != (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead );
    if ( v11 < 0x252 )
    {
LABEL_8:
      if ( s_occlusionDebugDrawLines )
      {
        v12 = DCONST_DVARINT_snd_occlusionDebug;
        if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v12);
        if ( v12->current.integer == 1 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbp+0]
            vmovss  xmm1, dword ptr [rbp+4]
            vmovss  dword ptr [rsp+0B8h+var_78], xmm0
            vmovss  xmm0, dword ptr [rbp+8]
            vmovss  dword ptr [rsp+0B8h+var_78+4], xmm1
            vmovss  xmm1, dword ptr [rdi]
            vmovss  dword ptr [rsp+0B8h+var_78+8], xmm0
            vmovss  xmm0, dword ptr [rdi+4]
            vmovss  dword ptr [rsp+0B8h+var_78+0Ch], xmm1
            vmovss  xmm1, dword ptr [rdi+8]
            vmovss  dword ptr [rsp+0B8h+var_78+10h], xmm0
            vmovss  dword ptr [rsp+0B8h+var_78+14h], xmm1
          }
          v42.m256i_i8[24] = occluded;
          *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_snd_occlusionDebugTime, "snd_occlusionDebugTime");
          __asm
          {
            vmulss  xmm1, xmm0, cs:__real@c47a0000
            vmovss  xmm0, dword ptr [rdi]
            vmovss  xmm5, [rsp+0B8h+fraction]
          }
          v22 = 0;
          __asm
          {
            vcvttss2si eax, xmm1
            vsubss  xmm1, xmm0, dword ptr [rbp+0]
            vmovss  xmm0, dword ptr [rdi+4]
            vsubss  xmm2, xmm0, dword ptr [rbp+4]
            vmovss  xmm0, dword ptr [rdi+8]
            vmulss  xmm1, xmm1, xmm5
            vaddss  xmm4, xmm1, dword ptr [rbp+0]
            vmulss  xmm1, xmm2, xmm5
            vaddss  xmm3, xmm1, dword ptr [rbp+4]
            vsubss  xmm1, xmm0, dword ptr [rbp+8]
          }
          v43.m256i_i32[0] = id;
          __asm
          {
            vmulss  xmm2, xmm1, xmm5
            vmovss  dword ptr [rsp+0B8h+var_58+14h], xmm3
            vaddss  xmm3, xmm2, dword ptr [rbp+8]
            vxorps  xmm0, xmm0, xmm0
            vmovss  dword ptr [rsp+0B8h+var_58+18h], xmm3
            vmovss  dword ptr [rsp+0B8h+var_58+10h], xmm4
            vmovss  dword ptr [rsp+0B8h+var_58+1Ch], xmm0
          }
          v42.m256i_i32[7] = g_snd.time - _EAX;
          _RBP = &g_snd;
          for ( _RDI = 0i64; SND_IsVoiceFree(v22) || g_snd.voices[_RDI].playbackId != id; ++_RDI )
          {
            if ( ++v22 >= 99 )
              return;
          }
          v43.m256i_i64[1] = (__int64)g_snd.voices[_RDI].alias;
          __asm
          {
            vmovss  xmm0, dword ptr [rdi+rbp+0CAE4h]
            vmovss  dword ptr [rsp+0B8h+var_58+1Ch], xmm0
          }
          if ( !v43.m256i_i64[1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11590, ASSERT_TYPE_ASSERT, "(line.alias != 0)", (const char *)&queryFormat, "line.alias != NULL") )
            __debugbreak();
          if ( !s_occlusionLines.m_freelist.m_head.mp_next )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
              __debugbreak();
            if ( !s_occlusionLines.m_freelist.m_head.mp_next && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
              __debugbreak();
          }
          if ( (ntl::internal::pool_allocator_freelist<80> *)s_occlusionLines.m_freelist.m_head.mp_next == &s_occlusionLines.m_freelist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 298, ASSERT_TYPE_ASSERT, "( !empty() )", "Pool out of elements to allocate (Elem size=%zu, Num elems=%zu)", 0x50ui64, 0x252ui64) )
            __debugbreak();
          _R8 = (ntl::internal::list_node<OcclusionLine> *)s_occlusionLines.m_freelist.m_head.mp_next;
          __asm
          {
            vmovups ymm0, [rsp+0B8h+var_78]
            vmovups ymm1, [rsp+0B8h+var_58]
          }
          s_occlusionLines.m_freelist.m_head.mp_next = s_occlusionLines.m_freelist.m_head.mp_next->mp_next;
          __asm
          {
            vmovups ymmword ptr [r8+10h], ymm0
            vmovups ymmword ptr [r8+30h], ymm1
          }
          _R8->mp_prev = NULL;
          _R8->mp_next = NULL;
          ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine>>::insert_before(&s_occlusionLines.m_listHead, (ntl::internal::list_node<OcclusionLine> *)s_occlusionLines.m_listHead.m_sentinel.mp_next, _R8);
        }
      }
    }
  }
}

/*
==============
SND_DebugAliasPrint
==============
*/
void SND_DebugAliasPrint(bool condition, const SndAlias *alias, const char *msg)
{
  const dvar_t *v4; 
  const char *aliasName; 
  const dvar_t *v7; 
  char *typeName; 
  char *valueName; 

  if ( condition )
  {
    v4 = DCONST_DVARSTR_snd_debugAlias;
    aliasName = alias->aliasName;
    if ( !DCONST_DVARSTR_snd_debugAlias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debugAlias") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v4);
    if ( !I_stricmp(v4->current.string, aliasName) )
      goto LABEL_10;
    v7 = DCONST_DVARSTR_snd_debugAlias;
    if ( !DCONST_DVARSTR_snd_debugAlias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debugAlias") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    if ( !I_stricmp(v7->current.string, "all") )
    {
LABEL_10:
      typeName = (char *)&queryFormat.fmt + 3;
      valueName = (char *)&queryFormat.fmt + 3;
      SND_GetContextNames(alias, (const char **)&typeName, (const char **)&valueName);
      Com_DPrintf(9, "^5SND_DEBUG_ALIAS (%s) context (%s-%s): %s\n", alias->aliasName, typeName, valueName, msg);
    }
  }
}

/*
==============
SND_DevUpdateReverbParams
==============
*/
void SND_DevUpdateReverbParams(const unsigned int id)
{
  SND_SetReverbParams(id, g_snd.activeMainReverb, 0);
}

/*
==============
SND_DisableEq
==============
*/
void SND_DisableEq(int entchannel, int eqIndex, int band)
{
  __int64 v3; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v8; 
  int v9; 

  v3 = entchannel;
  v4 = band;
  v5 = eqIndex;
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v9 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 926, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v9) )
      __debugbreak();
  }
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v6) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 927, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v6, v8) )
      __debugbreak();
  }
  if ( (unsigned int)v5 >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v6) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 928, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v6, v8) )
      __debugbreak();
  }
  sdGlob.eqParams[0][v4 + 2 * v5][v3].enabled = 0;
}

/*
==============
SND_DisableFullOcclusionForEntChannel
==============
*/
void SND_DisableFullOcclusionForEntChannel(int entChannelIdx)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 
  __int64 v5; 

  v1 = entChannelIdx;
  if ( (unsigned int)entChannelIdx >= 0x100 )
  {
    v4 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7453, ASSERT_TYPE_ASSERT, "(unsigned)( entChannelIdx ) < (unsigned)( 256 )", "entChannelIdx doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entChannelIdx, v4) )
      __debugbreak();
    LODWORD(v5) = 256;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 22, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v3, v5) )
      __debugbreak();
  }
  g_snd.entChanFullOcclusionDisabled[v1 >> 5] |= 1 << (v1 & 0x1F);
}

/*
==============
SND_DisableOcclusion
==============
*/
void SND_DisableOcclusion(int entchannel, int eqIndex)
{
  __int64 v2; 
  __int64 v3; 
  unsigned __int64 v4; 
  __int64 v5; 
  __int64 v7; 
  int v8; 

  v2 = entchannel;
  v3 = eqIndex;
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v8 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7498, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( ( sizeof( *array_counter( g_snd.entChanOcclusionParams ) ) + 0 ) )", "entchannel doesn't index ARRAY_COUNT( g_snd.entChanOcclusionParams )\n\t%i not in [0, %i)", entchannel, v8) )
      __debugbreak();
  }
  if ( (unsigned int)v3 >= 2 )
  {
    LODWORD(v7) = 2;
    LODWORD(v5) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7499, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( ( sizeof( *array_counter( g_snd.entChanOcclusionParams[0] ) ) + 0 ) )", "eqIndex doesn't index ARRAY_COUNT( g_snd.entChanOcclusionParams[0] )\n\t%i not in [0, %i)", v5, v7) )
      __debugbreak();
  }
  v4 = 9 * (v3 + 2 * v2);
  g_snd.entChanOcclusionParams[0][v4 / 9].enabled = 0;
  g_snd.entChanFullOcclusionDisabled[v4 - 4607] = 1065353216;
  g_snd.entChanFullOcclusionDisabled[v4 - 4606] = 1065353216;
  g_snd.entChanFullOcclusionDisabled[v4 - 4605] = 1065353216;
  g_snd.entChanFullOcclusionDisabled[v4 - 4604] = 1065353216;
  g_snd.entChanFullOcclusionDisabled[v4 - 4603] = 1065353216;
  g_snd.entChanFullOcclusionDisabled[v4 - 4602] = 1065353216;
  g_snd.entChanFullOcclusionDisabled[v4 - 4601] = 1065353216;
  g_snd.entChanFullOcclusionDisabled[v4 - 4600] = 1065353216;
}

/*
==============
SND_DisconnectListener
==============
*/
void SND_DisconnectListener(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  unsigned __int64 v2; 
  __int64 v3; 
  bool active; 
  int v6; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v6 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2974, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v6) )
      __debugbreak();
  }
  v2 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  v3 = v1 << 7;
  active = g_snd.listeners[v1].active;
  if ( (_DWORD)v1 )
    active = active && !g_snd.listeners[0].active;
  if ( active && ((_DWORD)v1 == 1 || !g_snd.listeners[1].active) )
  {
    if ( v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
    _InterlockedExchange(&g_snd.listenerFence, 0);
    Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
    SND_Stop3DSounds();
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    do
    {
      if ( v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  }
  memset_0((char *)g_snd.listeners + v3, 0, 0x80ui64);
  MatrixIdentity33((tmat33_t<vec3_t> *)((char *)&g_snd.listeners[0].orient.axis + v3));
  OrientationInvert((const orientation_t *)((char *)&g_snd.listeners[0].orient + v3), (orientation_t *)((char *)&g_snd.listeners[0].inverse + v3));
  if ( v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
}

/*
==============
SND_DistSqToNearestListener
==============
*/
float SND_DistSqToNearestListener(const vec3_t *origin)
{
  unsigned __int64 v3; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovss  xmm6, cs:__real@7f7fffff
  }
  v3 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  if ( g_snd.listeners[0].active )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin; snd_local_t g_snd
      vsubss  xmm3, xmm0, dword ptr [rdi]
      vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+4; snd_local_t g_snd
      vsubss  xmm2, xmm1, dword ptr [rdi+4]
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+8; snd_local_t g_snd
      vsubss  xmm4, xmm0, dword ptr [rdi+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm3, xmm2, xmm1
      vaddss  xmm2, xmm3, xmm0
      vminss  xmm6, xmm2, xmm6
    }
  }
  if ( g_snd.listeners[1].active )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+74h; snd_local_t g_snd
      vsubss  xmm3, xmm0, dword ptr [rdi]
      vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+78h; snd_local_t g_snd
      vsubss  xmm2, xmm1, dword ptr [rdi+4]
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+7Ch; snd_local_t g_snd
      vsubss  xmm4, xmm0, dword ptr [rdi+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm3, xmm2, xmm1
      vaddss  xmm2, xmm3, xmm0
      vminss  xmm6, xmm2, xmm6
    }
  }
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
  __asm
  {
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+48h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_DoTracesWithDebug
==============
*/
void SND_DoTracesWithDebug(SndVoice *voice)
{
  bool v6; 
  const dvar_t *v7; 
  const dvar_t *v8; 
  unsigned int playbackId; 
  const dvar_t *v11; 
  SecureVec3 outVoicePosition; 
  __int64 v15; 
  snd_listener outListener; 
  tmat33_t<vec3_t> outVoiceMatrix; 
  char v18; 
  void *retaddr; 

  _RAX = &retaddr;
  v15 = -2i64;
  __asm { vmovaps xmmword ptr [rax-38h], xmm6 }
  _RBX = voice;
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12001, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  __asm { vxorps  xmm6, xmm6, xmm6 }
  v6 = 1;
  SND_UpdateVoicePosition(_RBX, &outVoicePosition, &outVoiceMatrix);
  SND_GetListenerNearestToOrigin((const vec3_t *)&outVoicePosition, &outListener);
  if ( outListener.active && !CG_IsPlayerAndPointInSameInteriorZone((const LocalClientNum_t)outListener.localClientNum, (const vec3_t *)&outVoicePosition) )
  {
    v7 = DCONST_DVARINT_snd_occlusionDebug;
    if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    if ( v7->current.integer )
      s_occlusionDebugDrawLines = SND_ShouldDrawOcclusionForAlias(&outListener, _RBX->alias, (const vec3_t *)&outVoicePosition);
    *(double *)&_XMM0 = SND_PerformOcclusionTrace(&outListener.orient.origin, (const vec3_t *)&outVoicePosition, (const LocalClientNum_t)outListener.localClientNum, _RBX->sndEnt, _RBX->playbackId);
    __asm { vmovaps xmm6, xmm0 }
    v6 = CG_OcclusionSettingsMatch((const LocalClientNum_t)outListener.localClientNum, (const vec3_t *)&outVoicePosition);
    v8 = DCONST_DVARINT_snd_occlusionDebug;
    if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    if ( v8->current.integer )
    {
      playbackId = _RBX->playbackId;
      for ( _RDI = s_occlusionLines.m_listHead.m_sentinel.mp_next; _RDI != (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead; _RDI = _RDI->mp_next )
      {
        if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 97, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
          __debugbreak();
        if ( LODWORD(_RDI[3].mp_prev) == playbackId )
          __asm { vmovss  dword ptr [rdi+4Ch], xmm6 }
      }
    }
  }
  _RBX->occlusionMatchesListener = v6;
  v11 = DCONST_DVARINT_snd_occlusionDelay;
  if ( !DCONST_DVARINT_snd_occlusionDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDelay") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  _RBX->nextOcclusionTime = g_snd.time + v11->current.integer;
  __asm { vmovss  dword ptr [rbx+0B4h], xmm6 }
  memset(&outVoicePosition, 0, sizeof(outVoicePosition));
  _R11 = &v18;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
SND_DrawOcclusionDebug
==============
*/
void SND_DrawOcclusionDebug(LocalClientNum_t localClientNum)
{
  const dvar_t *v7; 
  int integer; 
  int v11; 
  const ScreenPlacement *v12; 
  const char *s; 
  const vec3_t *v23; 
  const vec3_t *v24; 
  ntl::internal::list_node<OcclusionLine> *v25; 
  __int64 v26; 
  unsigned int mp_prev; 
  int VoiceIndexForId; 
  const SndAlias *mp_next; 
  char v34; 
  __int64 v38; 
  __int64 v39; 
  bool v40; 
  GfxFont *smallDevFont; 
  const vec4_t *color; 
  const char *v48; 
  bool v54; 
  float fmt; 
  float fmta; 
  GfxFont *font; 
  const ScreenPlacement *ActivePlacement; 
  __int128 v64; 
  char v66; 
  char v67; 
  char v69; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-38h], xmm6
    vmovaps xmmword ptr [r11-58h], xmm8
    vmovaps xmmword ptr [r11-68h], xmm9
  }
  v7 = DCONST_DVARINT_snd_occlusionDebug;
  if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
    __debugbreak();
  __asm { vmovaps [rsp+0A38h+var_48], xmm7 }
  Dvar_CheckFrontendServerThread(v7);
  integer = v7->current.integer;
  __asm { vmovss  xmm7, cs:__real@3f0ccccd }
  v11 = 0;
  ActivePlacement = ScrPlace_GetActivePlacement(localClientNum);
  v12 = ActivePlacement;
  __asm
  {
    vmovss  xmm8, dword ptr [rax+28h]
    vmovss  xmm6, dword ptr [rax+2Ch]
    vmovaps xmm2, xmm6; y
    vmovaps xmm1, xmm8; x
    vmovaps xmm3, xmm7; xScale
  }
  if ( integer == 2 )
  {
    s = "Occlusion Debug: (frozen)";
    font = cls.smallDevFont;
  }
  else
  {
    font = cls.smallDevFont;
    s = "Occlusion Debug:";
  }
  __asm { vmovss  dword ptr [rsp+0A38h+fmt], xmm7 }
  CG_DrawDevString(ActivePlacement, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmt, s, &colorMagenta, 5, font);
  _RBX = s_occlusionLines.m_listHead.m_sentinel.mp_next;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vaddss  xmm9, xmm0, xmm6
  }
  if ( (ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine> > *)s_occlusionLines.m_listHead.m_sentinel.mp_next != &s_occlusionLines.m_listHead )
  {
    do
    {
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 97, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      v23 = (const vec3_t *)((char *)&_RBX[1].mp_next + 4);
      v24 = (const vec3_t *)&_RBX[1];
      if ( LOBYTE(_RBX[2].mp_next) )
      {
        CL_AddDebugLine(v24, v23, &colorRed, 1, 1, 0);
        CL_AddDebugStar((const vec3_t *)&_RBX[4], &colorYellow, 0, 1, 0);
      }
      else
      {
        CL_AddDebugLine(v24, v23, &colorGreen, 1, 1, 0);
      }
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 109, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      _RBX = _RBX->mp_next;
    }
    while ( _RBX != (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead );
    _RBX = s_occlusionLines.m_listHead.m_sentinel.mp_next;
    v12 = ActivePlacement;
  }
  if ( integer != 2 )
  {
    if ( _RBX == (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead )
      goto LABEL_50;
    do
    {
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 97, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      if ( SHIDWORD(_RBX[2].mp_next) >= g_snd.time )
      {
        _RBX = _RBX->mp_next;
      }
      else
      {
        v25 = (ntl::internal::list_node<OcclusionLine> *)_RBX;
        if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 439, ASSERT_TYPE_ASSERT, "( pos.mp_node )", (const char *)&queryFormat, "pos.mp_node") )
          __debugbreak();
        _RBX = _RBX->mp_next;
        ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine>>::remove(&s_occlusionLines.m_listHead, v25);
        v25->mp_prev = (ntl::internal::list_node_base *)s_occlusionLines.m_freelist.m_head.mp_next;
        s_occlusionLines.m_freelist.m_head.mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)v25;
      }
    }
    while ( _RBX != (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead );
    _RBX = s_occlusionLines.m_listHead.m_sentinel.mp_next;
  }
  if ( _RBX != (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead )
  {
    v26 = 0i64;
    _RBP = &v66;
    _R13 = &g_snd;
    do
    {
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 97, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      mp_prev = (unsigned int)_RBX[3].mp_prev;
      LODWORD(v64) = mp_prev;
      VoiceIndexForId = SND_GetVoiceIndexForId(mp_prev);
      if ( VoiceIndexForId == -1 )
      {
        __asm { vmovss  xmm0, dword ptr [rbx+4Ch] }
        mp_next = (const SndAlias *)_RBX[3].mp_next;
      }
      else
      {
        _RAX = VoiceIndexForId;
        __asm { vmovss  xmm0, dword ptr [rax+r13+0CAE4h] }
        mp_next = g_snd.voices[_RAX].alias;
      }
      v34 = 0;
      *((_QWORD *)&v64 + 1) = mp_next;
      __asm
      {
        vmovups xmm2, [rsp+0A38h+var_9E0]
        vmovss  dword ptr [rsp+0A38h+var_9D0], xmm0
        vmovsd  xmm1, [rsp+0A38h+var_9D0]
      }
      if ( v26 <= 0 )
        goto LABEL_46;
      _RAX = &v66;
      v38 = v26;
      do
      {
        if ( *(_DWORD *)_RAX == mp_prev )
        {
          __asm
          {
            vmovups xmmword ptr [rax], xmm2
            vmovsd  qword ptr [rax+10h], xmm1
          }
          v34 = 1;
        }
        _RAX += 24;
        --v38;
      }
      while ( v38 );
      if ( !v34 )
      {
LABEL_46:
        if ( (unsigned int)v11 < 0x63 )
        {
          __asm { vmovups xmmword ptr [rbp+0], xmm2 }
          ++v11;
          ++v26;
          __asm { vmovsd  qword ptr [rbp+10h], xmm1 }
          _RBP += 24;
        }
      }
      _RBX = _RBX->mp_next;
    }
    while ( _RBX != (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead );
    v12 = ActivePlacement;
  }
LABEL_50:
  v39 = v11;
  v40 = v11 == 0;
  if ( v11 > 0 )
  {
    _RSI = &v67;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    do
    {
      __asm { vmovss  xmm0, dword ptr [rsi+8] }
      smallDevFont = cls.smallDevFont;
      color = &colorRed;
      __asm
      {
        vcomiss xmm0, xmm6
        vcvtss2sd xmm2, xmm0, xmm0
      }
      if ( v40 )
        color = &colorGreen;
      __asm { vmovq   r8, xmm2 }
      v48 = j_va("%s : %f", **(_QWORD **)_RSI, _R8);
      __asm
      {
        vmovaps xmm3, xmm7; xScale
        vmovaps xmm2, xmm9; y
        vmovaps xmm1, xmm8; x
        vmovss  dword ptr [rsp+0A38h+fmt], xmm7
      }
      CG_DrawDevString(v12, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmta, v48, color, 5, smallDevFont);
      _RSI += 24;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vaddss  xmm9, xmm9, xmm0
      }
      v54 = v39-- == 0;
      v40 = v54 || v39 == 0;
    }
    while ( v39 );
  }
  __asm { vmovaps xmm7, [rsp+0A38h+var_48] }
  _R11 = &v69;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
SND_DrawOnlyChannel_f
==============
*/
void SND_DrawOnlyChannel_f(void)
{
  const char *v0; 

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1);
    snd_drawOnlyChannel = SND_GetEntChannelFromName(v0);
  }
  else
  {
    Com_Printf(9, "USAGE: snd_drawOnlyChannel <string channelName>\n");
  }
}

/*
==============
SND_DriverPostUpdate
==============
*/

void __fastcall SND_DriverPostUpdate(int frametime)
{
  SD_PostUpdate(frametime);
}

/*
==============
SND_DriverPreUpdate
==============
*/

void __fastcall SND_DriverPreUpdate(int frametime)
{
  SD_PreUpdate(frametime);
}

/*
==============
SND_DumpGlobals_f
==============
*/
void SND_DumpGlobals_f()
{
  int v0; 
  char v1; 
  unsigned int v3; 
  unsigned int v4; 
  unsigned int v5; 
  const char *name; 
  unsigned int v7; 
  unsigned int v8; 
  __int64 v9; 
  unsigned int v10; 
  const char *v11; 
  int v12; 
  signed int v19; 
  signed int i; 
  signed int j; 
  __int64 v22; 
  signed int v23; 
  __int64 v24; 
  signed int k; 
  __int64 v26; 
  __int64 v27; 

  v0 = Cmd_Argc();
  v1 = 0;
  _RBX = g_snd.globals;
  if ( v0 > 1 )
    v1 = 1;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2771, ASSERT_TYPE_ASSERT, "(g)", (const char *)&queryFormat, "g") )
    __debugbreak();
  v3 = 132 * _RBX->whizbyCount;
  v4 = 572 * _RBX->masterCount;
  v5 = 124 * _RBX->entchannelCount;
  name = _RBX->name;
  v7 = 16 * _RBX->contextValueCount;
  v8 = 24 * _RBX->contextCount;
  v9 = -1i64;
  v10 = 72 * _RBX->volmodinfoCount;
  do
    ++v9;
  while ( name[v9] );
  v11 = "<null>";
  v12 = v4 + v7 + v8 + v5 + v10 + v9;
  if ( name )
    v11 = _RBX->name;
  Com_Printf(9, "g_snd.globals.name   \"%s\"  size %d\n", v11, v12 + v3 + 129);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx+8]
    vcvtss2sd xmm2, xmm2, xmm2
    vmovq   r8, xmm2
  }
  Com_Printf(9, "globalVolumeModifier:    %.3f\n", *(double *)&_XMM2);
  __asm
  {
    vmovss  xmm2, dword ptr [rbx+0Ch]
    vcvtss2sd xmm2, xmm2, xmm2
    vmovq   r8, xmm2
  }
  Com_Printf(9, "binkVolumeModifier:      %.3f\n", *(double *)&_XMM2);
  Com_Printf(9, "volmodinfoCount:         %d  (%6d)\n", _RBX->volmodinfoCount, v10);
  Com_Printf(9, "entchannelCount:         %d  (%6d)\n", _RBX->entchannelCount, v5);
  Com_Printf(9, "contextCount:            %d  (%6d)\n", _RBX->contextCount, v8);
  Com_Printf(9, "contextValueCount:       %d  (%6d)\n", _RBX->contextValueCount, v7);
  Com_Printf(9, "masterCount:             %d  (%6d)\n", _RBX->masterCount, v4);
  Com_Printf(9, "whizbyCount:             %d  (%6d)\n", _RBX->whizbyCount, v3);
  if ( v1 )
  {
    v19 = 0;
    for ( i = 0; i < (signed int)_RBX->volmodinfoCount; ++i )
    {
      if ( !&_RBX->volmodinfo[i] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2800, ASSERT_TYPE_ASSERT, "(g->volmodinfo[i].name)", (const char *)&queryFormat, "g->volmodinfo[i].name") )
        __debugbreak();
      Com_Printf(9, "volmod[%3d]: \"%s\"\n", (unsigned int)i, _RBX->volmodinfo[i].name);
    }
    for ( j = 0; j < (signed int)_RBX->entchannelCount; ++j )
    {
      v22 = j;
      if ( !&_RBX->entchannelInfo[v22] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2806, ASSERT_TYPE_ASSERT, "(g->entchannelInfo[i].name)", (const char *)&queryFormat, "g->entchannelInfo[i].name") )
        __debugbreak();
      Com_Printf(9, "entchannel[%3d]: \"%s\"\n", (unsigned int)j, _RBX->entchannelInfo[v22].name);
    }
    v23 = 0;
    if ( (int)_RBX->contextCount > 0 )
    {
      v24 = 0i64;
      do
      {
        if ( !_RBX->contexts[v24].type && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2812, ASSERT_TYPE_ASSERT, "(g->contexts[i].type)", (const char *)&queryFormat, "g->contexts[i].type") )
          __debugbreak();
        Com_Printf(9, "context[%3d]: \"%s\"\n", (unsigned int)v23++, _RBX->contexts[v24++].type);
      }
      while ( v23 < (signed int)_RBX->contextCount );
    }
    for ( k = 0; k < (signed int)_RBX->masterCount; ++k )
    {
      v26 = k;
      if ( !&_RBX->masters[v26] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2818, ASSERT_TYPE_ASSERT, "(g->masters[i].name)", (const char *)&queryFormat, "g->masters[i].name") )
        __debugbreak();
      Com_Printf(9, "master[%3d]: \"%s\"\n", (unsigned int)k, _RBX->masters[v26].name);
    }
    if ( (int)_RBX->whizbyCount > 0 )
    {
      do
      {
        v27 = v19;
        if ( !&_RBX->whizbys[v27] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2824, ASSERT_TYPE_ASSERT, "(g->whizbys[i].name)", (const char *)&queryFormat, "g->whizbys[i].name") )
          __debugbreak();
        Com_Printf(9, "context[%3d]: \"%s\"\n", (unsigned int)v19++, _RBX->whizbys[v27].name);
      }
      while ( v19 < (signed int)_RBX->whizbyCount );
    }
  }
}

/*
==============
SND_DumpTimeScale_f
==============
*/
void SND_DumpTimeScale_f(void)
{
  _RBX = 0i64;
  _RDI = g_snd.entchanOverrides.timescaleLerp;
  while ( g_snd.globals && (unsigned int)_RBX < g_snd.globals->entchannelCount )
  {
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+rbx*4]
      vcvtss2sd xmm3, xmm3, xmm3
      vmovq   r9, xmm3
    }
    Com_Printf(9, "%32s %0.2f\n", g_snd.globals->entchannelInfo[(unsigned int)_RBX].name, *(double *)&_XMM3);
    _RBX = (unsigned int)(_RBX + 1);
  }
}

/*
==============
SND_EnablePASpeaker
==============
*/
void SND_EnablePASpeaker(unsigned int nameHash, bool enable)
{
  __int64 i; 
  __int64 v5; 
  __int64 v6; 

  if ( cm.mapEnts )
  {
    for ( i = 0i64; (unsigned int)i < cm.mapEnts->audioPASpeakerCount; i = (unsigned int)(i + 1) )
    {
      if ( cm.mapEnts->audioPASpeakers[i].nameHash == nameHash )
      {
        if ( enable )
        {
          if ( (unsigned int)i >= 0x40 )
          {
            LODWORD(v6) = 64;
            LODWORD(v5) = i;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 30, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v5, v6) )
              __debugbreak();
          }
          g_snd.paSpeakerDisabledArray[(__int64)(int)i >> 5] &= ~(1 << (i & 0x1F));
        }
        else
        {
          if ( (unsigned int)i >= 0x40 )
          {
            LODWORD(v6) = 64;
            LODWORD(v5) = i;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 22, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v5, v6) )
              __debugbreak();
          }
          g_snd.paSpeakerDisabledArray[(__int64)(int)i >> 5] |= 1 << (i & 0x1F);
        }
      }
    }
  }
}

/*
==============
SND_EndFrame
==============
*/
void SND_EndFrame(void)
{
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "SND_EndFrame");
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
  Sys_ProfEndNamedEvent();
}

/*
==============
SND_EntChannelFarReverbBehavior
==============
*/
__int64 SND_EntChannelFarReverbBehavior(unsigned int entchannel)
{
  __int64 v1; 
  char ActiveGameMode; 
  __int64 v4; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2230, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2231, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v4) )
      __debugbreak();
  }
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  switch ( ActiveGameMode )
  {
    case 0:
      return 0i64;
    case 1:
      return (unsigned int)g_snd.globals->entchannelInfo[v1].spFarReverbBehavior;
    case 2:
      return (unsigned int)g_snd.globals->entchannelInfo[v1].mpFarReverbBehavior;
  }
  if ( ActiveGameMode != 3 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2256, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "SND_EntChannelFarReverbBehavior() retrieved unknown game mode.") )
      __debugbreak();
    return 0i64;
  }
  return (unsigned int)g_snd.globals->entchannelInfo[v1].cpFarReverbBehavior;
}

/*
==============
SND_EntChannelHas71SpeakerPanning
==============
*/
bool SND_EntChannelHas71SpeakerPanning(unsigned int entchannel)
{
  __int64 v1; 
  const dvar_t *v2; 
  __int64 v4; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2209, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2210, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v4) )
      __debugbreak();
  }
  v2 = DCONST_DVARBOOL_snd_enable_capture_mode;
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
    return SND_IsChannelMissionVOChannel(v1);
  else
    return g_snd.globals->entchannelInfo[v1].has71Pan;
}

/*
==============
SND_EntChannelHasCenterSpeakerPanning
==============
*/
bool SND_EntChannelHasCenterSpeakerPanning(unsigned int entchannel)
{
  __int64 v1; 
  const dvar_t *v2; 
  __int64 v4; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2188, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2189, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v4) )
      __debugbreak();
  }
  v2 = DCONST_DVARBOOL_snd_enable_capture_mode;
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
    return SND_IsChannelMissionVOChannel(v1);
  else
    return g_snd.globals->entchannelInfo[v1].centerSpeakerPan;
}

/*
==============
SND_EntChannelHasOcclusion
==============
*/
bool SND_EntChannelHasOcclusion(unsigned int entchannel)
{
  __int64 v1; 
  int v4; 

  v1 = entchannel;
  if ( entchannel >= 0x100 )
  {
    v4 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2091, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( ( sizeof( *array_counter( g_snd.entChanOcclusionParams ) ) + 0 ) )", "entchannel doesn't index ARRAY_COUNT( g_snd.entChanOcclusionParams )\n\t%i not in [0, %i)", entchannel, v4) )
      __debugbreak();
  }
  return SND_IsEntChannel3D(v1) && g_snd.entChanOcclusionParams[v1][0].enabled && g_snd.entChanOcclusionParams[v1][1].enabled;
}

/*
==============
SND_EntityFindContextValue
==============
*/
bool SND_EntityFindContextValue(const SndEntState *entState, unsigned int contextType, unsigned int *outValueA, unsigned int *outValueB, float *outLerp)
{
  unsigned int v10; 
  const SndEntState *v11; 
  bool result; 
  __int64 v15; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  if ( !entState )
    goto LABEL_5;
  v10 = 0;
  v11 = entState;
  while ( v11->contextTypes[0] != contextType )
  {
    ++v10;
    v11 = (const SndEntState *)((char *)v11 + 4);
    if ( v10 >= 3 )
      goto LABEL_5;
  }
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  v15 = (int)v10;
  __asm { vmovaps xmm0, xmm6 }
  if ( entState->contextFadeLength[v10] > 0 )
  {
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm1, xmm1, eax
      vcvtsi2ss xmm0, xmm0, ecx
      vdivss  xmm0, xmm1, xmm0; val
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm2, xmm6; max
    }
    I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vsubss  xmm0, xmm6, xmm0 }
  }
  if ( entState->contextValuesTo[v15] )
    goto LABEL_12;
  __asm { vucomiss xmm0, xmm6 }
  if ( !entState->contextValuesTo[v15] )
    goto LABEL_5;
  if ( entState->contextValuesFrom[v15] )
  {
LABEL_12:
    *outValueA = entState->contextValuesFrom[v15];
    *outValueB = entState->contextValuesTo[v15];
    _RAX = outLerp;
    __asm { vmovss  dword ptr [rax], xmm0 }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  __asm { vmovaps xmm6, [rsp+38h+var_18] }
  return result;
}

/*
==============
SND_EqTypeFromString
==============
*/
__int64 SND_EqTypeFromString(const char *typeString)
{
  const char *v2; 
  __int64 v3; 
  unsigned int v4; 
  __int64 v5; 
  __int64 v6; 
  const char *v7; 
  int v8; 
  __int64 v9; 
  int v10; 
  int v11; 
  int v12; 
  const char *i; 

  if ( !typeString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2404, ASSERT_TYPE_ASSERT, "(typeString)", (const char *)&queryFormat, "typeString") )
    __debugbreak();
  v2 = snd_eqTypeStrings[0];
  v3 = 0i64;
  v4 = 0;
  if ( snd_eqTypeStrings[0] )
  {
    v5 = 0i64;
    do
    {
      v6 = 0x7FFFFFFFi64;
      if ( !typeString && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v7 = (const char *)(typeString - v2);
      while ( 1 )
      {
        v8 = (unsigned __int8)v2[(_QWORD)v7];
        v9 = v6;
        v10 = *(unsigned __int8 *)v2++;
        --v6;
        if ( !v9 )
          return v4;
        if ( v8 != v10 )
        {
          v11 = v8 + 32;
          if ( (unsigned int)(v8 - 65) > 0x19 )
            v11 = v8;
          v8 = v11;
          v12 = v10 + 32;
          if ( (unsigned int)(v10 - 65) > 0x19 )
            v12 = v10;
          if ( v8 != v12 )
            break;
        }
        if ( !v8 )
          return v4;
      }
      v2 = snd_eqTypeStrings[++v5];
      ++v4;
    }
    while ( v2 );
  }
  Com_Printf(9, "invalid eq type string '%s', it must be one of the following strings:\n", typeString);
  for ( i = snd_eqTypeStrings[0]; i; i = snd_eqTypeStrings[++v3] )
  {
    if ( *i )
      Com_Printf(9, "  %s\n", i);
  }
  return 5i64;
}

/*
==============
SND_ErrorCleanup
==============
*/
void SND_ErrorCleanup(void)
{
  SndBankInfo **v0; 
  const SndBank *bank; 
  __int64 i; 
  SndVirtualLoop *virtualLoops; 
  int v4; 
  bool *voiceAlloc; 
  const SndAlias **p_alias; 
  int j; 
  int k; 
  int m; 
  int n; 
  __int64 v11; 

  g_snd.hasPendingRestore = 0;
  while ( Sys_InCriticalSection(CRITSECT_SOUND_UPDATE) )
  {
    cls.inUpdateSound = 0;
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  }
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_PROPAGATION);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_WEAPON_REFLECT);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DOOR_PROPAGATION);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  v0 = &g_sb.bankStack[32];
  do
  {
    bank = (*v0)->bank;
    if ( bank && !bank->streamInfo.alwaysLoaded )
      SND_StopBankSoundsWithBankInfo(*v0);
    ++v0;
  }
  while ( (__int64)v0 < (__int64)&g_sb.loadGate );
  if ( g_snd.driverInitialized )
  {
    for ( i = 0i64; Sys_InCriticalSection(CRITSECT_SOUND_UPDATE); i = (unsigned int)(i + 1) )
      Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
    if ( (int)i > 0 )
    {
      do
      {
        Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
        --i;
      }
      while ( i );
    }
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    Sys_ProfBeginNamedEvent(0xFFD8BFD8, "wait_workers");
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
    Sys_ProfEndNamedEvent();
    virtualLoops = g_snd.virtualLoops;
    g_snd.nextVirtualLoopHandle = 0;
    do
    {
      virtualLoops->handle = -1;
      ++virtualLoops;
    }
    while ( (__int64)virtualLoops < (__int64)&g_snd.nextVirtualLoopHandle );
    SND_DeferredPlaybackInit();
    v4 = 0;
    voiceAlloc = sdGlob.voiceAlloc;
    p_alias = &g_snd.voices[0].alias;
    do
    {
      if ( (unsigned int)v4 > 0x62 )
      {
        LODWORD(v11) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v11) )
          __debugbreak();
      }
      if ( *voiceAlloc )
      {
        SND_DebugAliasPrint(*p_alias != NULL, *p_alias, "Stop voice requested by SND_StopSounds()");
        SND_StopVoice(v4);
      }
      ++v4;
      ++voiceAlloc;
      p_alias += 246;
    }
    while ( v4 < 99 );
    SND_ClearReverbs();
    for ( j = 1; j < 4; ++j )
      SND_DeactivateChannelVolumes(j, 0);
    for ( k = 0; k < 256; ++k )
    {
      for ( m = 0; m < 2; ++m )
      {
        for ( n = 0; n < 2; ++n )
          SND_DisableEq(k, m, n);
      }
    }
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  }
  SNDL_ResetMusicState(g_snd.musicCurrentState);
  SD_Sync();
}

/*
==============
SND_ErrorIfSoundGlobalsTrashed
==============
*/
void SND_ErrorIfSoundGlobalsTrashed(void)
{
  if ( g_snd.driverInitialized && g_snd.magic != 591763574 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 9645, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "The sound globals have been overwritten") )
    __debugbreak();
}

/*
==============
SND_ExistsPendingRestore
==============
*/
_BOOL8 SND_ExistsPendingRestore()
{
  return g_snd.hasPendingRestore;
}

/*
==============
SND_FadeAllSounds
==============
*/

void __fastcall SND_FadeAllSounds(double volume, int fadetime, double _XMM2_8)
{
  char v11; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
    vmovaps xmm6, xmm0
  }
  if ( fadetime < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6740, ASSERT_TYPE_ASSERT, "(fadetime >= 0)", (const char *)&queryFormat, "fadetime >= 0") )
    __debugbreak();
  __asm
  {
    vmovss  xmm3, cs:__real@3f800000; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  SND_SetParamValue(&g_snd.mastervol, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fadetime);
  __asm { vucomiss xmm6, xmm7 }
  if ( v11 )
    g_snd.stopSoundsAfterMasterFade = 1;
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
  }
}

/*
==============
SND_FadeLocalSoundAliasById
==============
*/

char __fastcall SND_FadeLocalSoundAliasById(LocalClientNum_t localClientNum, unsigned int id, double fadeValue, int msec)
{
  if ( !id )
    return 0;
  _RAX = 0i64;
  _RCX = &g_snd;
  while ( g_snd.voices[_RAX].playbackId != id )
  {
    if ( ++_RAX >= 99 )
      return 0;
  }
  __asm
  {
    vsubss  xmm1, xmm2, dword ptr [rax+rcx+0CA68h]
    vmovss  dword ptr [rax+rcx+0CA6Ch], xmm2
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, r9d
    vdivss  xmm2, xmm1, xmm0
    vmovss  dword ptr [rax+rcx+0CA70h], xmm2
  }
  return 1;
}

/*
==============
SND_FinalizeAliasGroupTracking
==============
*/
void SND_FinalizeAliasGroupTracking(SndAliasGroupTracking *inOutTracking)
{
  int v2; 
  int *voiceIndices; 
  unsigned int *voicePlaybackIds; 
  __int64 v5; 
  SndVoice *v6; 
  unsigned int v7; 
  const dvar_t *v8; 
  unsigned int v9; 
  const char **p_aliasName; 
  const char *v17; 
  int v18; 
  int *v19; 
  __int64 v20; 
  __int64 v21; 
  const dvar_t *v22; 
  __int64 v23; 
  __int64 v24; 
  vec3_t outOrigin; 
  __int64 v26; 
  int v27[40]; 
  int v28; 
  LocalClientNum_t localClientNum; 
  unsigned __int64 sndEnt; 
  int data[4]; 
  int v38[4]; 
  snd_listener outListener; 

  v26 = -2i64;
  if ( !Sys_InCriticalSection(CRITSECT_SOUND_UPDATE) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4299, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_SOUND_UPDATE ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_SOUND_UPDATE )") )
    __debugbreak();
  if ( inOutTracking->numVoices > 0 )
  {
    v28 = 0;
    sndEnt = 0i64;
    v2 = 0;
    voiceIndices = inOutTracking->voiceIndices;
    voicePlaybackIds = inOutTracking->voicePlaybackIds;
    do
    {
      v5 = *voiceIndices;
      v6 = &g_snd.voices[v5];
      if ( (unsigned int)v5 > 0x62 )
      {
        LODWORD(v23) = *voiceIndices;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v23) )
          __debugbreak();
      }
      if ( sdGlob.voiceAlloc[v5] && v6->playbackId == *voicePlaybackIds )
      {
        SD_SetSecondaryGroupInfo(v5, inOutTracking->numVoices);
        if ( !g_snd.paused || !SND_IsPausable((unsigned __int8)(v6->alias->flags >> 10)) )
          v6->paused = 0;
        v7 = (unsigned __int8)(v6->alias->flags >> 10);
        if ( !SND_EntChannelHasOcclusion(v7) || (v6->sndEnt & 0x1FFFFFFFFi64) == 2048 || (v6->sndEnt & 0x1000000000i64) == 0 || SND_IsEntChannelPASpeaker(v7) )
          goto LABEL_51;
        v8 = DCONST_DVARINT_snd_occlusionDebug;
        if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v8);
        if ( v8->current.integer )
        {
LABEL_51:
          if ( !v6->paused )
          {
            data[0] = v6->playbackId;
            data[1] = v5;
            data[2] = 0;
            if ( !Sys_TryAddWorkerCmd(WRKCMD_SOUND_VOICE_UPDATE, data) )
              SND_UpdateAndStartVoice(v5, 0);
          }
        }
        else
        {
          v9 = v28;
          if ( !v28 )
          {
            SndVoice_GetOrigin(v6, &outOrigin);
            SND_GetListenerNearestToOrigin(&outOrigin, &outListener);
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+100h+outListener.orient.origin]
              vmovss  [rbp+100h+var_FC], xmm0
              vmovss  xmm1, dword ptr [rbp+100h+outListener.orient.origin+4]
              vmovss  [rbp+100h+var_F8], xmm1
              vmovss  xmm0, dword ptr [rbp+100h+outListener.orient.origin+8]
              vmovss  [rbp+100h+var_F4], xmm0
              vmovss  xmm1, dword ptr [rsp+200h+outOrigin]
              vmovss  [rbp+100h+var_F0], xmm1
              vmovss  xmm0, dword ptr [rsp+200h+outOrigin+4]
              vmovss  [rbp+100h+var_EC], xmm0
              vmovss  xmm1, dword ptr [rsp+200h+outOrigin+8]
              vmovss  [rbp+100h+var_E8], xmm1
            }
            localClientNum = outListener.localClientNum;
            sndEnt = v6->sndEnt;
            memset(&outOrigin, 0, sizeof(outOrigin));
            v9 = v28;
          }
          v6->occlusionWaitId = v6->playbackId;
          if ( v9 >= 0x14 )
          {
            LODWORD(v24) = 20;
            LODWORD(v23) = v9;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4352, ASSERT_TYPE_ASSERT, "(unsigned)( cmd.numSecondaries ) < (unsigned)( ( sizeof( *array_counter( cmd.voiceIndex ) ) + 0 ) )", "cmd.numSecondaries doesn't index ARRAY_COUNT( cmd.voiceIndex )\n\t%i not in [0, %i)", v23, v24) )
              __debugbreak();
            v9 = v28;
          }
          v27[v9 + 20] = v5;
          v27[v28++] = v6->occlusionWaitId;
        }
      }
      else
      {
        p_aliasName = &v6->alias->aliasName;
        if ( p_aliasName )
          v17 = *p_aliasName;
        else
          v17 = "<free>";
        Com_PrintError(9, "Secondary group containing sound alias: %s has voice limiting issues.\n", v17);
        *voiceIndices = *(&inOutTracking->secondaryGroupId + inOutTracking->numVoices--);
        --v2;
        --voicePlaybackIds;
        --voiceIndices;
      }
      ++v2;
      ++voicePlaybackIds;
      ++voiceIndices;
    }
    while ( v2 < inOutTracking->numVoices );
    if ( v28 > 0 && !Sys_TryAddWorkerCmd(WRKCMD_SOUND_OCCLUSION, v27) )
    {
      v18 = 0;
      if ( inOutTracking->numVoices > 0 )
      {
        v19 = inOutTracking->voiceIndices;
        do
        {
          v20 = *v19;
          v21 = 492 * v20;
          g_snd.chaninfoUnweightedPriority[v21 - 48612] = 0.0;
          g_snd.chaninfoUnweightedPriority[v21 - 48663] = 0.0;
          v22 = DCONST_DVARINT_snd_occlusionDelay;
          if ( !DCONST_DVARINT_snd_occlusionDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDelay") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v22);
          LODWORD(g_snd.chaninfoUnweightedPriority[v21 - 48662]) = v22->current.integer + g_snd.time;
          if ( !LOBYTE(g_snd.chaninfoUnweightedPriority[v21 - 48664]) )
          {
            v38[0] = LODWORD(g_snd.chaninfoUnweightedPriority[v21 - 48701]);
            v38[1] = v20;
            v38[2] = 0;
            if ( !Sys_TryAddWorkerCmd(WRKCMD_SOUND_VOICE_UPDATE, v38) )
              SND_UpdateAndStartVoice(v20, 0);
          }
          ++v18;
          ++v19;
        }
        while ( v18 < inOutTracking->numVoices );
      }
    }
  }
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
}

/*
==============
SND_FindAssetsForVoice
==============
*/
bool SND_FindAssetsForVoice(SndStartAliasInfo *info)
{
  bool Streamed; 
  const SndAlias *alias; 
  int flags; 
  unsigned int assetId; 
  bool result; 

  Streamed = 0;
  alias = info->alias;
  flags = info->alias->flags;
  info->isCinematic = 0;
  info->arcadeAssetIndex = -1;
  assetId = alias->assetId;
  if ( assetId == g_snd.cinematicAssetId )
  {
    info->isCinematic = 1;
    info->assetEntry = &g_snd.cinematicAssetEntry;
    result = 1;
    info->assetExists = 1;
    return result;
  }
  if ( assetId == g_snd.arcadeAssetId )
  {
    info->arcadeAssetIndex = (info->sndEnt >> 33) & 3;
    info->assetEntry = &g_snd.arcadeAssetEntry;
LABEL_5:
    info->assetExists = 1;
    return 1;
  }
  if ( (flags & 0x380) == 512 )
  {
    if ( SND_AssetBankFindLoaded(assetId, &info->assetEntry, &info->loadedData, &info->loadedSize) && SND_AssetBankFindStreamed(info->alias->assetId, &info->assetEntry, (FileStreamFileID *)info->streamFid) )
      goto LABEL_5;
    info->assetExists = 0;
    return 0;
  }
  else if ( (flags & 0x380) == 128 || (alias->flags & 0x380u) <= 0x100 )
  {
    result = SND_AssetBankFindLoaded(assetId, &info->assetEntry, &info->loadedData, &info->loadedSize);
    info->assetExists = result;
  }
  else
  {
    if ( (flags & 0x380) == 384 )
      Streamed = SND_AssetBankFindStreamed(assetId, &info->assetEntry, (FileStreamFileID *)info->streamFid);
    info->assetExists = Streamed;
    return Streamed;
  }
  return result;
}

/*
==============
SND_FindEntState
==============
*/
SndEntState *SND_FindEntState(unsigned __int64 handle, bool createNew)
{
  unsigned __int64 v2; 
  signed int v5; 
  SndEntState *entState; 
  unsigned int v7; 
  int v8; 
  char v9; 
  __int64 v10; 
  SndEntState *v11; 
  SndEntState *result; 

  v2 = handle & 0x1FFFFFFFFi64;
  if ( (handle & 0x1FFFFFFFFi64) - 5411 <= 0x1F || v2 - 2049 <= 0x8FF || v2 <= 0x7FD || v2 - 5571 <= 0x7A120 )
  {
    v5 = 0;
    entState = g_snd.entState;
    v7 = 0;
    v8 = -1;
    do
    {
      if ( handle == entState->handle )
        return entState;
      v9 = 0;
      v10 = 0i64;
      while ( !entState->contextTypes[v10] )
      {
        if ( ++v10 >= 3 )
          goto LABEL_12;
      }
      v9 = 1;
LABEL_12:
      if ( (signed int)(g_snd.frame - entState->lastUsed) > v5 && !v9 )
      {
        v8 = v7;
        v5 = g_snd.frame - entState->lastUsed;
      }
      ++v7;
      ++entState;
    }
    while ( v7 < 0x80 );
    if ( createNew && v8 != -1 )
    {
      v11 = &g_snd.entState[(__int64)v8];
      memset_0(v11, 0, sizeof(SndEntState));
      result = v11;
      v11->handle = handle;
      return result;
    }
  }
  return 0i64;
}

/*
==============
SND_FindFreeVoice
==============
*/
__int64 SND_FindFreeVoice(const SndStartAliasInfo *startAliasInfo, int entchannel, int startVoiceIndex, int voiceCount, SndAliasGroupTracking *inOutTracking)
{
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  const char *EntChannelName; 
  const char *v15; 
  const SndAlias *alias; 
  bool HasFreeVoice; 
  int ReplaceableVoiceWithEntChannel; 
  __int64 v19; 
  __int64 v20; 
  unsigned int v21; 
  int autoSimId; 
  unsigned int Priority; 
  unsigned __int64 v24; 
  const char *v25; 
  unsigned int v26; 
  const char *v27; 
  unsigned int v28; 
  const char *aliasName; 
  unsigned int v30; 
  const char *v31; 
  const dvar_t *v32; 
  char v33; 
  int v34; 
  const char *v35; 
  unsigned int v38; 
  __int64 result; 
  int v43; 
  const char *v44; 
  unsigned int v48; 
  double limitBehavior; 
  double limitBehaviora; 
  __int64 v55; 
  double v56; 
  __int64 v57; 
  double v58; 
  vec3_t outOrigin; 
  char v60; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  v10 = voiceCount;
  v11 = startVoiceIndex;
  v12 = entchannel;
  EntChannelName = SND_GetEntChannelName(entchannel);
  v15 = j_va("Max voices reached for entchannel %s", EntChannelName);
  alias = startAliasInfo->alias;
  HasFreeVoice = SND_HasFreeVoice(v12);
  SND_DebugAliasPrint(!HasFreeVoice, alias, v15);
  Profile_Begin(475);
  if ( !SND_HasFreeVoice(v12) )
  {
    ReplaceableVoiceWithEntChannel = SND_FindReplaceableVoiceWithEntChannel(startAliasInfo, v12, v11, v10, g_snd.globals->entchannelInfo[v12].limitBehavior);
    v19 = ReplaceableVoiceWithEntChannel;
    if ( ReplaceableVoiceWithEntChannel != -1 )
    {
      if ( (unsigned int)ReplaceableVoiceWithEntChannel > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", ReplaceableVoiceWithEntChannel) )
        __debugbreak();
      if ( !sdGlob.voiceAlloc[v19] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3718, ASSERT_TYPE_ASSERT, "((i == -1) || !SND_IsVoiceFree( i ))", (const char *)&queryFormat, "(i == SND_NOT_REPLACEABLE) || !SND_IsVoiceFree( i )") )
        __debugbreak();
    }
    goto LABEL_17;
  }
  if ( (int)v10 <= 0 )
  {
LABEL_16:
    LODWORD(v19) = SND_FindReplaceableVoice(startAliasInfo, v12, v11, v10);
LABEL_17:
    Profile_EndInternal(NULL);
    if ( (_DWORD)v19 != -1 )
    {
      if ( (unsigned int)v19 > 0x62 )
      {
        LODWORD(v55) = v19;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v55) )
          __debugbreak();
      }
      if ( sdGlob.voiceAlloc[(int)v19] )
      {
        autoSimId = startAliasInfo->autoSimId;
        if ( autoSimId != -1 && autoSimId == LODWORD(g_snd.chaninfoUnweightedPriority[492 * (int)v19 - 48650]) )
          g_sd.voices[(int)v19]->autoSimStopTimeStamp = startAliasInfo->autoSimTimeStamp;
        Priority = SND_GetPriority(g_snd.chaninfoEntchannel[(int)v19]);
        v24 = 1968i64 * (int)v19;
        v25 = **(const char ***)&g_snd.chaninfoUnweightedPriority[v24 / 4 - 48680];
        v26 = SND_GetPriority(v12);
        v27 = j_va("(prio %i) => Replacing '%s' (prio: %i)", v26, v25, Priority);
        SND_DebugAliasPrint(1, startAliasInfo->alias, v27);
        v28 = SND_GetPriority(v12);
        aliasName = startAliasInfo->alias->aliasName;
        v30 = SND_GetPriority(g_snd.chaninfoEntchannel[(int)v19]);
        v31 = j_va("(prio %i ) => Replaced by '%s' (prio: %i)", v30, aliasName, v28);
        SND_DebugAliasPrint(1, *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[v24 / 4 - 48680], v31);
        v32 = DCONST_DVARBOOL_snd_debugReplace;
        if ( !DCONST_DVARBOOL_snd_debugReplace && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debugReplace") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v32);
        if ( v32->current.enabled )
        {
          if ( (*(_BYTE *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[v24 / 4 - 48680] + 112i64) & 1) != 0 )
            goto LABEL_31;
          *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(v19, 0);
          __asm { vcomiss xmm0, cs:__real@3f800000 }
          if ( !v33 )
          {
LABEL_31:
            if ( (unsigned int)(v19 - 80) <= 0xD )
            {
              *(double *)&_XMM0 = SND_DistSqToNearestListener(&startAliasInfo->org);
              __asm { vmovaps xmm6, xmm0 }
              SndVoice_GetOrigin(&g_snd.voices[v24 / 0x7B0], &outOrigin);
              __asm
              {
                vsqrtss xmm0, xmm6, xmm6
                vcvtss2sd xmm8, xmm0, xmm0
              }
              v43 = SND_GetPriority(v12);
              v44 = startAliasInfo->alias->aliasName;
              *(double *)&_XMM0 = SND_DistSqToNearestListener(&outOrigin);
              __asm { vcvtss2sd xmm7, xmm0, xmm0 }
              *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(v19, 0);
              __asm
              {
                vmulss  xmm1, xmm0, cs:__real@42c80000
                vcvtss2sd xmm6, xmm1, xmm1
              }
              v48 = SND_GetPriority(g_snd.chaninfoEntchannel[(int)v19]);
              __asm
              {
                vmovsd  [rsp+0C8h+var_88], xmm8
                vmovsd  [rsp+0C8h+var_A0], xmm7
                vmovsd  qword ptr [rsp+0C8h+limitBehavior], xmm6
              }
              Com_DPrintf(9, "Stopping stream sound channel that's playing '%s' (prio: %i, %.0f%% played, dist: %f) so we can play '%s' (prio: %i, dist: %f) instead\n", **(const char ***)&g_snd.chaninfoUnweightedPriority[v24 / 4 - 48680], v48, limitBehaviora, v56, v44, v43, v58);
              memset(&outOrigin, 0, sizeof(outOrigin));
            }
            else
            {
              v34 = SND_GetPriority(v12);
              v35 = startAliasInfo->alias->aliasName;
              *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(v19, 0);
              __asm
              {
                vmulss  xmm1, xmm0, cs:__real@42c80000
                vcvtss2sd xmm6, xmm1, xmm1
              }
              v38 = SND_GetPriority(g_snd.chaninfoEntchannel[(int)v19]);
              LODWORD(v57) = v34;
              __asm { vmovsd  qword ptr [rsp+0C8h+limitBehavior], xmm6 }
              Com_Printf(14, "Stopping sound channel that's playing '%s' (prio: %i, %.0f%% played) so we can play '%s' (prio: %i) instead\n", **(const char ***)&g_snd.chaninfoUnweightedPriority[v24 / 4 - 48680], v38, limitBehavior, v35, v57);
            }
          }
        }
      }
      SND_StopVoiceAndClearTracking(v19, inOutTracking);
    }
    SND_DebugAliasPrint((int)v19 < 0, startAliasInfo->alias, "No free channels");
    result = (unsigned int)v19;
    goto LABEL_37;
  }
  v20 = 0i64;
  v21 = v11;
  while ( 1 )
  {
    if ( v21 > 0x62 )
    {
      LODWORD(v55) = v21;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v55) )
        __debugbreak();
    }
    if ( !sdGlob.voiceAlloc[v11 + v20] )
      break;
    ++v21;
    if ( ++v20 >= v10 )
      goto LABEL_16;
  }
  Profile_EndInternal(NULL);
  result = v21;
LABEL_37:
  _R11 = &v60;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return result;
}

/*
==============
SND_FindReplaceableVoice
==============
*/
__int64 SND_FindReplaceableVoice(const SndStartAliasInfo *startAliasInfo, unsigned int entchannel, int first, int count)
{
  __int64 v11; 
  bool v12; 
  bool v13; 
  bool v18; 
  const dvar_t *v20; 
  bool enabled; 
  __int64 result; 
  unsigned int v26; 
  int v27; 
  const char *subtitle; 
  float *v29; 
  float *v30; 
  __int64 v31; 
  char v33; 
  const dvar_t *v34; 
  bool v35; 
  __int64 v42; 
  double v43; 
  double v44; 

  __asm
  {
    vmovaps [rsp+0A8h+var_38], xmm6
    vmovaps [rsp+0A8h+var_58], xmm8
    vmovaps [rsp+0A8h+var_68], xmm9
  }
  _RSI = startAliasInfo;
  v11 = first;
  if ( !startAliasInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3622, ASSERT_TYPE_ASSERT, "(startAliasInfo)", (const char *)&queryFormat, "startAliasInfo") )
    __debugbreak();
  if ( (unsigned int)v11 > 0x62 )
  {
    LODWORD(v42) = v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3623, ASSERT_TYPE_ASSERT, "( ( first >= 0 && first < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( first ) = %i", v42) )
      __debugbreak();
  }
  if ( count < 0 || count > 99 - (int)v11 )
  {
    LODWORD(v42) = count;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3624, ASSERT_TYPE_ASSERT, "( ( count >= 0 && count <= ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) - first ) )", "( count ) = %i", v42) )
      __debugbreak();
  }
  if ( entchannel >= g_snd.globals->entchannelCount )
  {
    LODWORD(v42) = entchannel;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3625, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v42) )
      __debugbreak();
  }
  v12 = _RSI->alias == NULL;
  if ( !_RSI->alias )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3626, ASSERT_TYPE_ASSERT, "(startAliasInfo->alias)", (const char *)&queryFormat, "startAliasInfo->alias");
    v12 = !v13;
    if ( v13 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+28h]
    vmovss  xmm9, cs:__real@3f800000
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
    vcomiss xmm0, xmm9
  }
  if ( !v12 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0A8h+var_80], xmm0
    }
    v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3627, ASSERT_TYPE_ASSERT, "( ( startAliasInfo->priorityVolume >= 0.0f && startAliasInfo->priorityVolume <= 1.0f ) )", "( startAliasInfo->priorityVolume ) = %g", v43);
    v12 = !v18;
    if ( v18 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+2Ch]
    vcomiss xmm0, xmm6
    vcomiss xmm0, xmm9
  }
  if ( !v12 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0A8h+var_80], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3628, ASSERT_TYPE_ASSERT, "( ( startAliasInfo->priorityAttenuation >= 0.0f && startAliasInfo->priorityAttenuation <= 1.0f ) )", "( startAliasInfo->priorityAttenuation ) = %g", v44) )
      __debugbreak();
  }
  v20 = DCONST_DVARBOOL_snd_useHardOuterEntchannelPriorities;
  if ( !DCONST_DVARBOOL_snd_useHardOuterEntchannelPriorities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_useHardOuterEntchannelPriorities") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v20);
  enabled = v20->current.enabled;
  SND_GetPriority(entchannel);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, eax
  }
  if ( !enabled )
  {
    __asm
    {
      vmulss  xmm0, xmm6, dword ptr [rsi+28h]
      vmulss  xmm6, xmm0, dword ptr [rsi+2Ch]
    }
  }
  __asm
  {
    vmovss  xmm8, cs:__real@38d1b717
    vcomiss xmm6, xmm8
  }
  if ( !enabled )
  {
    result = 0xFFFFFFFFi64;
    goto LABEL_54;
  }
  v26 = -1;
  v27 = v11 + count;
  __asm { vmovaps [rsp+0A8h+var_48], xmm7 }
  subtitle = _RSI->alias->subtitle;
  if ( (int)v11 >= (int)v11 + count )
  {
LABEL_52:
    result = v26;
    goto LABEL_53;
  }
  v29 = &g_snd.chaninfoUnweightedPriority[492 * v11 - 48680];
  v30 = &g_snd.chaninfoUnweightedPriority[v11];
  while ( 1 )
  {
    v31 = *(_QWORD *)v29;
    __asm { vmovaps xmm7, xmm6 }
    if ( !*(_QWORD *)v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3649, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
      __debugbreak();
    if ( !*((_DWORD *)v29 - 28) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3650, ASSERT_TYPE_ASSERT, "(voice->soundFileInfo.loadingState != SFLS_UNLOADED)", (const char *)&queryFormat, "voice->soundFileInfo.loadingState != SFLS_UNLOADED") )
      __debugbreak();
    if ( !SND_IsEntChannelPASpeaker((unsigned __int8)(*(int *)(*(_QWORD *)v29 + 112i64) >> 10)) && *(_DWORD *)(*(_QWORD *)v29 + 40i64) != g_snd.cinematicAssetId )
    {
      if ( *((_DWORD *)v29 - 28) == 2 && (*(_BYTE *)(v31 + 112) & 1) == 0 )
      {
        *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(v11, 0);
        __asm { vcomiss xmm0, xmm9 }
        if ( !v33 )
          goto LABEL_55;
      }
      if ( subtitle || !*(_QWORD *)(v31 + 8) )
        break;
    }
LABEL_51:
    LODWORD(v11) = v11 + 1;
    v29 += 492;
    ++v30;
    if ( (int)v11 >= v27 )
      goto LABEL_52;
  }
  v34 = DCONST_DVARBOOL_snd_useHardOuterEntchannelPriorities;
  if ( !DCONST_DVARBOOL_snd_useHardOuterEntchannelPriorities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_useHardOuterEntchannelPriorities") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v34);
  v35 = v34->current.enabled;
  SND_GetPriority(*((_DWORD *)v30 + 99));
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
  }
  if ( v35 )
  {
    __asm
    {
      vcomiss xmm0, xmm8
      vcomiss xmm7, xmm0
    }
    v26 = v11;
    __asm { vminss  xmm6, xmm0, xmm6 }
    goto LABEL_51;
  }
  __asm
  {
    vmulss  xmm0, xmm0, dword ptr [rbp+0]
    vcomiss xmm0, xmm8
  }
LABEL_55:
  result = (unsigned int)v11;
LABEL_53:
  __asm { vmovaps xmm7, [rsp+0A8h+var_48] }
LABEL_54:
  __asm
  {
    vmovaps xmm6, [rsp+0A8h+var_38]
    vmovaps xmm8, [rsp+0A8h+var_58]
    vmovaps xmm9, [rsp+0A8h+var_68]
  }
  return result;
}

/*
==============
SND_FinishPlayingWeaponSound
==============
*/
void SND_FinishPlayingWeaponSound(const SndPlayParams *inParams, bool isPlayer, const WeaponSFXPackage *sfxPackage, bool playAtmo, bool isDualWield, PlayerHandIndex hand)
{
  const SndAliasList *WeapFireAtmoSound; 
  const vec3_t *p_org; 
  SndWeapShotCountId autoSimShotCount; 
  unsigned __int64 sndEnt; 
  int autoSimId; 
  __int64 autoSimTimeStamp; 
  SndPlayParams inParamsa; 

  _RBX = inParams;
  if ( SND_PlaySoundAliasFromParams(inParams, 0) )
  {
    if ( playAtmo )
    {
      WeapFireAtmoSound = SND_GetWeapFireAtmoSound(sfxPackage, isPlayer, isDualWield, hand);
      if ( WeapFireAtmoSound )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx]
          vmovups ymm1, ymmword ptr [rbx+20h]
          vmovups ymmword ptr [rsp+0E8h+inParams.aliasList], ymm0
          vmovups ymm0, ymmword ptr [rbx+40h]
          vmovups ymmword ptr [rsp+0E8h+inParams.sndEnt], ymm1
          vmovups ymm1, ymmword ptr [rbx+60h]
        }
        inParamsa.aliasList = WeapFireAtmoSound;
        inParamsa.aliasId = 0;
        __asm
        {
          vmovups ymmword ptr [rsp+0E8h+inParams.system], ymm0
          vmovups ymmword ptr [rsp+0E8h+inParams.startOffsetFraction], ymm1
        }
        SND_PlaySoundAliasFromParams(&inParamsa, 0);
      }
    }
    p_org = &_RBX->org;
    autoSimShotCount = _RBX->autoSimShotCount;
    sndEnt = _RBX->sndEnt;
    autoSimTimeStamp = _RBX->autoSimTimeStamp;
    autoSimId = _RBX->autoSimId;
    if ( isPlayer )
      SND_WeapReflectPlayPlayerSound(sndEnt, p_org, sfxPackage, autoSimShotCount, autoSimId, autoSimTimeStamp);
    else
      SND_WeapReflectPlayNPCSound(sndEnt, p_org, sfxPackage, autoSimShotCount, autoSimId, autoSimTimeStamp);
  }
}

/*
==============
SND_FrameUpdateVirtualLoopSounds
==============
*/

void __fastcall SND_FrameUpdateVirtualLoopSounds(__int64 a1, double _XMM1_8)
{
  __int64 v6; 
  bool v7; 
  const SndAliasList *v8; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  SndPlayParams inParams; 
  tmat33_t<vec3_t> axis_out; 

  __asm { vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000 }
  inParams.playbackType = SPT_BLEND;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovups xmmword ptr [rbp+57h+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+57h+inParams.lpfCutoff], xmm0
    vmovss  [rbp+57h+inParams.hpfCutoff], xmm0
    vmovss  dword ptr [rbp+57h+inParams.org], xmm1
    vmovss  dword ptr [rbp+57h+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+57h+inParams.org+8], xmm1
    vmovss  [rbp+57h+inParams.startOffsetFraction], xmm1
  }
  inParams.aliasList = NULL;
  _RBX = &g_snd.virtualLoops[0].org.v[2];
  inParams.aliasId = 0;
  v6 = 198i64;
  inParams.sndEnt = 0i64;
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  do
  {
    if ( *((_DWORD *)_RBX - 8) != -1 )
    {
      v7 = *((_BYTE *)_RBX + 12) == 0;
      v8 = (const SndAliasList *)*((_QWORD *)_RBX - 3);
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+4]
        vmovss  xmm1, dword ptr [rbx+8]
      }
      v11 = *((_QWORD *)_RBX - 2);
      __asm
      {
        vmovss  [rbp+57h+inParams.volumeScale], xmm0
        vmovss  [rbp+57h+inParams.pitch], xmm1
      }
      inParams.aliasList = v8;
      inParams.sndEnt = v11;
      if ( !v7 )
      {
        v12 = v11 & 0x1FFFFFFFFi64;
        if ( (v11 & 0x1FFFFFFFFi64) - 5411 <= 0x1F || v12 - 2049 <= 0x8FF || v12 <= 0x7FD || v12 - 5571 <= 0x7A120 )
          CG_SND_GetSoundEntityOrientation(v11, (vec3_t *)(_RBX - 2), &axis_out);
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx-8]
        vmovss  xmm1, dword ptr [rbx-4]
        vmovss  dword ptr [rbp+57h+inParams.org], xmm0
        vmovss  xmm0, dword ptr [rbx]
        vmovss  dword ptr [rbp+57h+inParams.org+8], xmm0
        vmovss  dword ptr [rbp+57h+inParams.org+4], xmm1
      }
      *((_DWORD *)_RBX - 7) = SND_PlaySoundAliasFromParams(&inParams, 0);
    }
    _RBX += 12;
    --v6;
  }
  while ( v6 );
}

/*
==============
SND_FreeEntityParamInfo
==============
*/
void SND_FreeEntityParamInfo(int entIndex)
{
  unsigned __int64 v2; 
  unsigned __int16 EntParamIdx; 
  int v4; 
  int v5; 
  __int64 v7; 
  __int64 v9; 
  __int64 v10; 
  int v11; 
  unsigned int v12; 
  int v13; 

  if ( g_snd.driverInitialized )
  {
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    Sys_ProfBeginNamedEvent(0xFFD8BFD8, "wait_workers");
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
    Sys_ProfEndNamedEvent();
    v2 = (unsigned __int64)&g_sndEntityParamFence & 3;
    do
    {
      if ( v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&g_sndEntityParamFence) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(&g_sndEntityParamFence, 1, 0) == 1 );
    if ( (unsigned int)entIndex >= 0x7B6E3 )
    {
      v11 = 505571;
      LODWORD(v9) = entIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1856, ASSERT_TYPE_ASSERT, "(unsigned)( entIndex ) < (unsigned)( ( ( ( 2048 ) ) + ( 1 ) + ( 1024 ) + ( 128 ) + ( 128 ) + 1024 + ( 2 ) + ( 32 ) + ( 1024 ) + ( 32 ) + ( 128 ) + ( 500000 ) ) )", "entIndex doesn't index MAX_SOUND_ENTITIES\n\t%i not in [0, %i)", v9, v11) )
        __debugbreak();
    }
    EntParamIdx = SND_GetEntParamIdx(entIndex);
    if ( EntParamIdx != 0xFFFF )
    {
      if ( EntParamIdx >= 0x40u )
      {
        LODWORD(v10) = 64;
        LODWORD(v9) = EntParamIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1862, ASSERT_TYPE_ASSERT, "(unsigned)( paramInfoIndex ) < (unsigned)( 64 )", "paramInfoIndex doesn't index SND_MAX_PARAM_INFO\n\t%i not in [0, %i)", v9, v10) )
          __debugbreak();
      }
      if ( g_sndEntityParamInfo[EntParamIdx].entIndex != entIndex )
      {
        v13 = entIndex;
        v12 = g_sndEntityParamInfo[EntParamIdx].entIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1866, ASSERT_TYPE_ASSERT, "( info->entIndex ) == ( static_cast<uint>( entIndex ) )", "%s == %s\n\t%i, %i", "info->entIndex", "static_cast<uint>( entIndex )", v12, v13) )
          __debugbreak();
      }
      v4 = 0;
      while ( 1 )
      {
        v5 = (v4 + entIndex % 64 % 64) % 64;
        if ( g_sndEntityParamIndex[v5].entNum == entIndex )
          break;
        if ( ++v4 >= 64 )
          goto LABEL_22;
      }
      g_sndEntityParamIndex[v5] = (EntParamIdxHashBucket)0x7FFFFFF;
LABEL_22:
      if ( EntParamIdx >= 0x40u )
      {
        LODWORD(v10) = 64;
        LODWORD(v9) = EntParamIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1797, ASSERT_TYPE_ASSERT, "(unsigned)( paramInfoIndex ) < (unsigned)( 64 )", "paramInfoIndex doesn't index SND_MAX_PARAM_INFO\n\t%i not in [0, %i)", v9, v10) )
          __debugbreak();
      }
      __asm { vmovss  xmm1, cs:__real@3f800000; initValue }
      v7 = EntParamIdx;
      SND_InitParameter(&g_sndEntityParamInfo[v7].pitch, *(float *)&_XMM1);
      __asm { vmovss  xmm1, cs:__real@3f800000; initValue }
      SND_InitParameter(&g_sndEntityParamInfo[v7].volume, *(float *)&_XMM1);
      g_sndEntityParamInfo[v7].entIndex = 0x7FFFFFFF;
    }
    if ( v2 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&g_sndEntityParamFence) )
        __debugbreak();
    }
    _InterlockedExchange(&g_sndEntityParamFence, 0);
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  }
}

/*
==============
SND_FullOcclusionEnabledForChannel
==============
*/
bool SND_FullOcclusionEnabledForChannel(int entChannelIdx)
{
  __int64 v1; 
  unsigned int v2; 
  __int64 v5; 
  int v6; 
  __int64 v7; 

  v1 = entChannelIdx;
  if ( (unsigned int)entChannelIdx >= 0x100 )
  {
    v6 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7445, ASSERT_TYPE_ASSERT, "(unsigned)( entChannelIdx ) < (unsigned)( 256 )", "entChannelIdx doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entChannelIdx, v6) )
      __debugbreak();
    LODWORD(v7) = 256;
    LODWORD(v5) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 14, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v5, v7) )
      __debugbreak();
  }
  v2 = g_snd.entChanFullOcclusionDisabled[v1 >> 5];
  return !_bittest((const int *)&v2, v1 & 0x1F);
}

/*
==============
SND_Get3DDistanceAttenuation
==============
*/

double __fastcall SND_Get3DDistanceAttenuation(const vec3_t *soundOrigin, const SndCurve *curve, double distMin, double distMax, float distanceScale)
{
  bool v16; 
  bool v17; 
  unsigned __int64 v20; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps [rsp+0C8h+var_88], xmm11
    vmovaps [rsp+0C8h+var_98], xmm12
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmm9, xmm3
    vmovaps xmm8, xmm2
  }
  v16 = curve == NULL;
  if ( !curve )
  {
    v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3597, ASSERT_TYPE_ASSERT, "(curve)", (const char *)&queryFormat, "curve");
    v16 = !v17;
    if ( v17 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm8, xmm6
    vcomiss xmm9, xmm6
    vcomiss xmm9, xmm8
  }
  if ( v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3600, ASSERT_TYPE_ASSERT, "(distMax > distMin)", (const char *)&queryFormat, "distMax > distMin") )
    __debugbreak();
  __asm { vmovss  xmm10, cs:__real@7f7fffff }
  v20 = (unsigned __int64)&g_snd.listenerFence & 3;
  __asm
  {
    vxorps  xmm11, xmm11, xmm11
    vxorps  xmm12, xmm12, xmm12
  }
  do
  {
    if ( v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  __asm { vmovaps [rsp+0C8h+var_48], xmm7 }
  if ( g_snd.listeners[0].active )
  {
    __asm
    {
      vmovss  xmm5, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+4; snd_local_t g_snd
      vsubss  xmm0, xmm5, dword ptr [rdi+4]
      vmovss  xmm4, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin; snd_local_t g_snd
      vsubss  xmm2, xmm4, dword ptr [rdi]
      vmovss  xmm7, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+8; snd_local_t g_snd
      vsubss  xmm3, xmm7, dword ptr [rdi+8]
      vmulss  xmm1, xmm0, xmm0
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm0, xmm2, xmm1
      vcomiss xmm0, xmm10
    }
  }
  if ( g_snd.listeners[1].active )
  {
    __asm
    {
      vmovss  xmm5, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+78h; snd_local_t g_snd
      vsubss  xmm0, xmm5, dword ptr [rdi+4]
      vmovss  xmm4, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+74h; snd_local_t g_snd
      vsubss  xmm2, xmm4, dword ptr [rdi]
      vmovss  xmm7, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+7Ch; snd_local_t g_snd
      vsubss  xmm3, xmm7, dword ptr [rdi+8]
      vmulss  xmm1, xmm0, xmm0
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vcomiss xmm2, xmm10
    }
  }
  __asm
  {
    vmovaps xmm10, [rsp+0C8h+var_78]
    vmovaps xmm7, [rsp+0C8h+var_48]
  }
  if ( v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
  __asm
  {
    vsubss  xmm0, xmm11, dword ptr [rdi+4]
    vsubss  xmm4, xmm6, dword ptr [rdi]
    vsubss  xmm5, xmm12, dword ptr [rdi+8]
    vmulss  xmm3, xmm0, xmm0
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm4, xmm3, xmm0
    vmulss  xmm3, xmm5, xmm5
    vaddss  xmm4, xmm4, xmm3
    vsqrtss xmm0, xmm4, xmm4
    vmulss  xmm0, xmm0, [rsp+0C8h+distanceScale]; radius
    vmovaps xmm2, xmm9; maxdist
    vmovaps xmm1, xmm8; mindist
  }
  *(double *)&_XMM0 = SND_GetDistanceCurveFraction(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm2, xmm0; fraction
    vmovaps xmm6, [rsp+0C8h+var_38]
    vmovaps xmm8, [rsp+0C8h+var_58]
    vmovaps xmm9, [rsp+0C8h+var_68]
    vmovaps xmm11, [rsp+0C8h+var_88]
    vmovaps xmm12, [rsp+0C8h+var_98]
  }
  return SND_GetSndCurveValue(curve->numPoints, curve->points, *(const float *)&_XMM2);
}

/*
==============
SND_Get3DSpeakerVolumes
==============
*/

void __fastcall SND_Get3DSpeakerVolumes(float *outputs, double dist, const vec3_t *delta, const snd_listener *listener, const SndVoice *voice, const SpeakerMap *speakerMap)
{
  const dvar_t *v7; 
  char v8; 
  const SndAlias **p_alias; 
  bool IsChannelMissionVOChannel; 
  bool v14; 
  __int64 v28; 
  float *v32; 
  __int64 v37; 
  unsigned __int64 v52; 
  __int64 v73; 
  __int64 v74; 
  unsigned __int64 v81; 
  __int64 v87; 
  float fmt; 
  float fmta; 
  float volumes; 
  float v94; 
  float v95; 
  float v96; 

  __asm { vmovaps [rsp+1A0h+var_40], xmm6 }
  v7 = DCONST_DVARBOOL_snd_enable_capture_mode;
  v8 = 0;
  _RBX = outputs;
  __asm { vmovaps xmm6, xmm1 }
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  p_alias = &voice->alias;
  if ( v7->current.enabled && (IsChannelMissionVOChannel = SND_IsChannelMissionVOChannel((unsigned __int8)((*p_alias)->flags >> 10)), v14 = 0, IsChannelMissionVOChannel) )
  {
    v8 = 1;
  }
  else
  {
    v14 = speakerMap->id < g_snd.defaultHash;
    if ( speakerMap->id == g_snd.defaultHash )
      goto LABEL_41;
    _RAX = *p_alias;
    __asm { vcomiss xmm6, dword ptr [rax+0BCh] }
    if ( speakerMap->id >= g_snd.defaultHash )
    {
LABEL_41:
      memset_0(_RBX, 0, 0x80ui64);
      __asm { vmovss  dword ptr [rsp+1A0h+fmt], xmm6 }
      SND_SpatializeVoice(voice, _RBX, delta, listener, fmta);
      goto LABEL_42;
    }
  }
  _RAX = *p_alias;
  __asm
  {
    vmovss  xmm0, dword ptr [rax+0BCh]
    vcomiss xmm0, dword ptr [rax+0B8h]
  }
  if ( v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12752, ASSERT_TYPE_ASSERT, "(voice->alias->smartPanDistance2d <= voice->alias->smartPanDistance3d)", (const char *)&queryFormat, "voice->alias->smartPanDistance2d <= voice->alias->smartPanDistance3d") )
    __debugbreak();
  memset_0(_RBX, 0, 0x80ui64);
  memset_0(&volumes, 0, 0x80ui64);
  SND_UpdateSpeakerMap(voice, speakerMap, &volumes);
  if ( v8 )
  {
    _RAX = *p_alias;
    __asm
    {
      vmovss  xmm2, dword ptr [rax+0C0h]
      vmovaps xmm1, xmm2
      vshufps xmm1, xmm1, xmm1, 0
    }
    if ( _RBX > &v94 || (v73 = 0i64, _RBX + 31 < &volumes) )
    {
      v74 = 2i64;
      _RAX = _RBX + 8;
      do
      {
        __asm
        {
          vmulps  xmm0, xmm1, xmmword ptr [rcx+rax-20h]
          vmovups xmmword ptr [rax-20h], xmm0
          vmulps  xmm0, xmm1, xmmword ptr [rdx+rax-20h]
          vmovups xmmword ptr [rax-10h], xmm0
          vmulps  xmm0, xmm1, xmmword ptr [rcx+rax]
          vmovups xmmword ptr [rax], xmm0
          vmulps  xmm0, xmm1, xmmword ptr [rdx+rax]
          vmovups xmmword ptr [rax+10h], xmm0
        }
        _RAX += 16;
        --v74;
      }
      while ( v74 );
      v73 = 32i64;
    }
    if ( (unsigned __int64)v73 < 0x20 )
    {
      if ( 32 - v73 >= 4 )
      {
        _RAX = (__int64)&_RBX[v73 + 2];
        v81 = ((unsigned __int64)(28 - v73) >> 2) + 1;
        v73 += 4 * v81;
        do
        {
          __asm
          {
            vmulss  xmm0, xmm2, dword ptr [r9+rax-8]
            vmulss  xmm1, xmm2, dword ptr [r10+rax-8]
            vmovss  dword ptr [rax-8], xmm0
            vmulss  xmm0, xmm2, dword ptr [rax+r9]
            vmovss  dword ptr [rax-4], xmm1
            vmulss  xmm1, xmm2, dword ptr [r10+rax]
            vmovss  dword ptr [rax], xmm0
            vmovss  dword ptr [rax+4], xmm1
          }
          _RAX += 16i64;
          --v81;
        }
        while ( v81 );
      }
      if ( v73 < 32 )
      {
        _RAX = &_RBX[v73];
        v87 = 32 - v73;
        do
        {
          __asm
          {
            vmulss  xmm0, xmm2, dword ptr [rax+rcx]
            vmovss  dword ptr [rax], xmm0
          }
          ++_RAX;
          --v87;
        }
        while ( v87 );
      }
    }
  }
  else
  {
    _RAX = *p_alias;
    __asm { vcomiss xmm6, dword ptr [rax+0B8h] }
    memset_0(&v95, 0, 0x80ui64);
    __asm { vmovss  dword ptr [rsp+1A0h+fmt], xmm6 }
    SND_SpatializeVoice(voice, &v95, delta, listener, fmt);
    _RAX = *p_alias;
    __asm
    {
      vmovss  xmm1, dword ptr [rax+0B8h]
      vmovss  xmm0, dword ptr [rax+0BCh]
      vsubss  xmm2, xmm6, xmm1
      vmovss  xmm6, cs:__real@3f800000
      vsubss  xmm1, xmm0, xmm1
      vdivss  xmm0, xmm2, xmm1; val
      vmovaps xmm2, xmm6; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    v28 = 0i64;
    __asm
    {
      vsubss  xmm1, xmm6, xmm0
      vmovaps xmm2, xmm0
      vmulss  xmm4, xmm1, dword ptr [rax+0C0h]
    }
    v32 = _RBX + 31;
    __asm
    {
      vmovaps xmm5, xmm4
      vshufps xmm5, xmm5, xmm5, 0
      vmovaps xmm3, xmm0
      vshufps xmm2, xmm2, xmm2, 0
    }
    if ( (_RBX > &v96 || v32 < &v95) && (_RBX > &v94 || v32 < &volumes) )
    {
      v37 = 2i64;
      _RAX = _RBX + 8;
      do
      {
        __asm
        {
          vmulps  xmm0, xmm5, xmmword ptr [rcx+rax-20h]
          vmulps  xmm1, xmm2, xmmword ptr [rdx+rax-20h]
        }
        _RAX += 16;
        __asm
        {
          vaddps  xmm1, xmm1, xmm0
          vmulps  xmm0, xmm5, xmmword ptr [r10+rax-60h]
          vmovups xmmword ptr [rax-60h], xmm1
          vmulps  xmm1, xmm2, xmmword ptr [r11+rax-60h]
          vaddps  xmm1, xmm1, xmm0
          vmulps  xmm0, xmm5, xmmword ptr [rcx+rax-40h]
          vmovups xmmword ptr [rax-50h], xmm1
          vmulps  xmm1, xmm2, xmmword ptr [rdx+rax-40h]
          vaddps  xmm1, xmm1, xmm0
          vmulps  xmm0, xmm5, xmmword ptr [r10+rax-40h]
          vmovups xmmword ptr [rax-40h], xmm1
          vmulps  xmm1, xmm2, xmmword ptr [r11+rax-40h]
          vaddps  xmm1, xmm1, xmm0
          vmovups xmmword ptr [rax-30h], xmm1
        }
        --v37;
      }
      while ( v37 );
      v28 = 32i64;
    }
    if ( (unsigned __int64)v28 < 0x20 )
    {
      if ( 32 - v28 >= 4 )
      {
        _RAX = (__int64)&_RBX[v28 + 2];
        v52 = ((unsigned __int64)(28 - v28) >> 2) + 1;
        v28 += 4 * v52;
        do
        {
          __asm
          {
            vmulss  xmm1, xmm3, dword ptr [r9+rax-8]
            vmulss  xmm0, xmm4, dword ptr [r8+rax-8]
            vmulss  xmm2, xmm3, dword ptr [r11+rax-8]
          }
          _RAX += 16i64;
          __asm
          {
            vaddss  xmm1, xmm1, xmm0
            vmulss  xmm0, xmm4, dword ptr [r10+rax-18h]
            vmovss  dword ptr [rax-18h], xmm1
            vaddss  xmm1, xmm2, xmm0
            vmulss  xmm2, xmm3, dword ptr [rax+r9-10h]
            vmulss  xmm0, xmm4, dword ptr [rax+r8-10h]
            vmovss  dword ptr [rax-14h], xmm1
            vaddss  xmm1, xmm2, xmm0
            vmulss  xmm2, xmm3, dword ptr [r11+rax-10h]
            vmulss  xmm0, xmm4, dword ptr [r10+rax-10h]
            vmovss  dword ptr [rax-10h], xmm1
            vaddss  xmm1, xmm2, xmm0
            vmovss  dword ptr [rax-0Ch], xmm1
          }
          --v52;
        }
        while ( v52 );
      }
      if ( v28 < 32 )
      {
        _RAX = 4 * v28;
        do
        {
          __asm
          {
            vmulss  xmm1, xmm4, [rsp+rax+1A0h+volumes]
            vmulss  xmm0, xmm3, [rbp+rax+0A0h+var_D0]
            vaddss  xmm1, xmm1, xmm0
            vmovss  dword ptr [rax+rbx], xmm1
          }
          _RAX += 4i64;
        }
        while ( _RAX < 128 );
      }
    }
  }
LABEL_42:
  __asm { vmovaps xmm6, [rsp+1A0h+var_40] }
}

/*
==============
SND_GetAliasEntChannelId
==============
*/
__int64 SND_GetAliasEntChannelId(const SndAlias *alias)
{
  __int64 v2; 
  __int64 v4; 

  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2162, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  v2 = (unsigned __int8)(alias->flags >> 10);
  if ( (unsigned int)v2 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2166, ASSERT_TYPE_ASSERT, "( ( entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v4) )
      __debugbreak();
  }
  return g_snd.globals->entchannelInfo[v2].id;
}

/*
==============
SND_GetAliasOffset
==============
*/
__int64 SND_GetAliasOffset(const SndAlias *alias)
{
  SndAliasList *v2; 
  int count; 
  __int64 result; 
  const SndAlias *head; 

  if ( !alias->aliasName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14979, ASSERT_TYPE_ASSERT, "(alias->aliasName)", (const char *)&queryFormat, "alias->aliasName") )
    __debugbreak();
  v2 = SND_FindAlias(alias->aliasName);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14982, ASSERT_TYPE_ASSERT, "(aliasList)", (const char *)&queryFormat, "aliasList") )
    __debugbreak();
  count = v2->count;
  result = 0i64;
  head = v2->head;
  if ( count <= 0 )
    return 0i64;
  while ( head != alias )
  {
    ++head;
    result = (unsigned int)(result + 1);
    if ( (int)result >= count )
      return 0i64;
  }
  return result;
}

/*
==============
SND_GetAliasWithOffset
==============
*/
SndAlias *SND_GetAliasWithOffset(const char *name, int offset)
{
  SndAliasList *Alias; 
  SndAlias *head; 
  int v6; 
  int count; 
  SndAlias *result; 
  bool v9; 
  char *fmt; 

  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15000, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  Alias = SND_FindAlias(name);
  if ( !Alias )
  {
LABEL_11:
    LODWORD(fmt) = offset;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444ED5C0, 149i64, name, fmt);
    return 0i64;
  }
  head = Alias->head;
  v6 = 0;
  count = Alias->count;
  result = head;
  v9 = count == 0;
  if ( count <= 0 )
  {
LABEL_9:
    if ( !v9 )
      return head;
    goto LABEL_11;
  }
  while ( v6 != offset )
  {
    ++result;
    if ( ++v6 >= count )
    {
      v9 = count == 0;
      goto LABEL_9;
    }
  }
  return result;
}

/*
==============
SND_GetAmbientTrack
==============
*/
__int64 SND_GetAmbientTrack(int number)
{
  int v4; 

  if ( (unsigned int)number >= 2 )
  {
    v4 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6249, ASSERT_TYPE_ASSERT, "(unsigned)( number ) < (unsigned)( 2 )", "number doesn't index SND_NUM_AMBIENT_TRACKS\n\t%i not in [0, %i)", number, v4) )
      __debugbreak();
  }
  return number != 0 ? 2 : 0;
}

/*
==============
SND_GetBinkVolume
==============
*/

float __fastcall SND_GetBinkVolume(double _XMM0_8)
{
  bool v1; 
  bool v2; 

  v1 = g_snd.globals == NULL;
  if ( !g_snd.globals )
  {
    v2 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11522, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals");
    v1 = !v2;
    if ( v2 )
      __debugbreak();
  }
  _RAX = g_snd.globals;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm0, dword ptr [rax+8]
  }
  if ( v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11523, ASSERT_TYPE_ASSERT, "(g_snd.globals->globalVolumeModifier != 0.f)", (const char *)&queryFormat, "g_snd.globals->globalVolumeModifier != 0.f") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.volume; snd_local_t g_snd
    vdivss  xmm0, xmm0, dword ptr [rax+8]
    vmulss  xmm0, xmm0, dword ptr [rax+0Ch]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetControllerIndex
==============
*/
__int64 SND_GetControllerIndex(const LocalClientNum_t localClientNum)
{
  unsigned int controllerIndex; 
  unsigned __int64 v3; 
  LocalClientNum_t *p_localClientNum; 
  unsigned int v5; 
  int v8; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v8 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16313, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v8) )
      __debugbreak();
  }
  controllerIndex = -1;
  v3 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  p_localClientNum = &g_snd.listeners[0].localClientNum;
  v5 = 0;
  while ( !*((_BYTE *)p_localClientNum + 4) || *p_localClientNum != localClientNum )
  {
    ++v5;
    p_localClientNum += 32;
    if ( v5 >= 2 )
      goto LABEL_15;
  }
  controllerIndex = g_snd.listeners[(__int64)(int)v5].controllerIndex;
LABEL_15:
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
  return controllerIndex;
}

/*
==============
SND_GetCurrentGlobalContext
==============
*/
char SND_GetCurrentGlobalContext(unsigned int type, unsigned int *outValueA, unsigned int *outValueB, float *outLerp)
{
  int ContextIndex; 

  ContextIndex = SND_FindContextIndex(type);
  if ( ContextIndex < 0 )
    return 0;
  _RCX = ContextIndex;
  _RDX = &g_snd;
  if ( !g_snd.globalContextsTo[ContextIndex] )
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vucomiss xmm0, dword ptr [rdx+rcx*8+145284h]
    }
    if ( !g_snd.globalContextsTo[ContextIndex] || !g_snd.globalContextsFrom[ContextIndex] )
      return 0;
  }
  *outValueA = g_snd.globalContextsFrom[ContextIndex];
  *outValueB = g_snd.globalContextsTo[ContextIndex];
  *outLerp = g_snd.globalContextLerp[ContextIndex].current;
  return 1;
}

/*
==============
SND_GetCurrentPriorityChannelGroup
==============
*/
snd_channelvolgroup *SND_GetCurrentPriorityChannelGroup()
{
  int currentChannelPriority; 
  int v2; 
  int v3; 

  currentChannelPriority = g_snd.currentChannelPriority;
  if ( g_snd.currentChannelPriority >= 4u )
  {
    v3 = 4;
    v2 = g_snd.currentChannelPriority;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 612, ASSERT_TYPE_ASSERT, "(unsigned)( g_snd.currentChannelPriority ) < (unsigned)( ( sizeof( *array_counter( g_snd.channelPriorityVolGroups ) ) + 0 ) )", "g_snd.currentChannelPriority doesn't index ARRAY_COUNT( g_snd.channelPriorityVolGroups )\n\t%i not in [0, %i)", v2, v3) )
      __debugbreak();
    currentChannelPriority = g_snd.currentChannelPriority;
  }
  return &g_snd.channelPriorityVolGroups[currentChannelPriority];
}

/*
==============
SND_GetCurrentReverb
==============
*/
__int64 SND_GetCurrentReverb()
{
  unsigned int presetId; 
  __int64 result; 

  presetId = g_snd.reverbSetting[g_snd.activeMainReverb].presetId;
  result = g_snd.defaultHash;
  if ( presetId )
    return presetId;
  return result;
}

/*
==============
SND_GetDefaultHash
==============
*/
__int64 SND_GetDefaultHash()
{
  return g_snd.defaultHash;
}

/*
==============
SND_GetDistanceCurveFraction
==============
*/

float __fastcall SND_GetDistanceCurveFraction(double radius, double mindist, double maxdist)
{
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps [rsp+68h+var_38], xmm8
    vsubss  xmm8, xmm0, xmm1
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm8, xmm0
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm1
    vcomiss xmm2, xmm1
    vmovss  xmm1, cs:__real@3f800000
    vsubss  xmm0, xmm7, xmm6
    vdivss  xmm2, xmm8, xmm0
    vcmpless xmm0, xmm1, xmm2
    vblendvps xmm0, xmm2, xmm1, xmm0
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm8, [rsp+68h+var_38]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetDryLevel
==============
*/
float SND_GetDryLevel(const SndVoice *voice, bool useReverbDryLevel)
{
  const SndAlias *alias; 

  alias = voice->alias;
  if ( !alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12042, ASSERT_TYPE_ASSERT, "(pAlias)", (const char *)&queryFormat, "pAlias") )
    __debugbreak();
  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( SND_GetEntChannelSendFlag((unsigned __int8)(alias->flags >> 10)) == SENDTYPE_NONE )
    goto LABEL_14;
  if ( !useReverbDryLevel || (_RCX = voice->reverbDef) == NULL )
  {
    _EAX = g_snd.reverbSetting[1].presetId;
    __asm { vmovss  xmm6, cs:__real@3f800000 }
    if ( g_snd.reverbSetting[0].presetId )
    {
      __asm { vmovss  xmm5, cs:?g_snd@@3Usnd_local_t@@A.reverbSetting.drylevel; snd_local_t g_snd }
    }
    else
    {
      if ( !g_snd.reverbSetting[1].presetId )
        goto LABEL_14;
      __asm { vmovaps xmm5, xmm6 }
    }
    __asm { vmovd   xmm0, eax }
    _ECX = 0;
    __asm
    {
      vmovd   xmm1, ecx
      vpcmpeqd xmm2, xmm0, xmm1
      vmovss  xmm1, cs:?g_snd@@3Usnd_local_t@@A.reverbSetting.drylevel+0Ch; snd_local_t g_snd
      vsubss  xmm0, xmm6, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current; snd_local_t g_snd
      vblendvps xmm4, xmm1, xmm6, xmm2
      vmulss  xmm1, xmm0, xmm5
      vmulss  xmm0, xmm4, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current; snd_local_t g_snd
      vaddss  xmm5, xmm1, xmm0
    }
    _EAX = alias->flags & 8;
    __asm
    {
      vmovd   xmm0, eax
      vmovd   xmm1, ecx
      vpcmpeqd xmm2, xmm0, xmm1
      vblendvps xmm0, xmm6, xmm5, xmm2
    }
    goto LABEL_15;
  }
  if ( (voice->alias->flags & 8) != 0 )
  {
LABEL_14:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
    goto LABEL_15;
  }
  __asm { vmovss  xmm0, dword ptr [rcx+48h] }
LABEL_15:
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetEntChannelCount
==============
*/
const SndGlobals *SND_GetEntChannelCount()
{
  const SndGlobals *result; 

  result = g_snd.globals;
  if ( g_snd.globals )
    return (const SndGlobals *)g_snd.globals->entchannelCount;
  return result;
}

/*
==============
SND_GetEntChannelFromName
==============
*/
__int64 SND_GetEntChannelFromName(const char *channelName)
{
  const char *v1; 
  const SndGlobals *globals; 
  unsigned int v3; 
  char v4; 
  int v5; 
  char v6; 
  unsigned int entchannelCount; 
  unsigned int *i; 

  v1 = channelName;
  if ( !channelName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2381, ASSERT_TYPE_ASSERT, "(channelName)", (const char *)&queryFormat, "channelName") )
    __debugbreak();
  globals = g_snd.globals;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2382, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  v3 = 0;
  if ( v1 && (v4 = *v1) != 0 )
  {
    v5 = 5381;
    do
    {
      ++v1;
      v6 = v4 | 0x20;
      if ( (unsigned int)(v4 - 65) >= 0x1A )
        v6 = v4;
      v5 = 65599 * v5 + v6;
      v4 = *v1;
    }
    while ( *v1 );
    if ( !v5 )
      v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  entchannelCount = globals->entchannelCount;
  if ( !entchannelCount )
    return 0xFFFFFFFFi64;
  for ( i = &globals->entchannelInfo->id; v5 != *i; i += 31 )
  {
    if ( ++v3 >= entchannelCount )
      return 0xFFFFFFFFi64;
  }
  return v3;
}

/*
==============
SND_GetEntChannelName
==============
*/
snd_entchannel_info_t *SND_GetEntChannelName(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2371, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2372, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  return &g_snd.globals->entchannelInfo[v1];
}

/*
==============
SND_GetEntChannelSendFlag
==============
*/
__int64 SND_GetEntChannelSendFlag(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2144, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2145, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  return (unsigned int)g_snd.globals->entchannelInfo[v1].sendType;
}

/*
==============
SND_GetEntChannelSpeedOfSoundMultiplier
==============
*/
float SND_GetEntChannelSpeedOfSoundMultiplier(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v6; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2153, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v6) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2154, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v6) )
      __debugbreak();
  }
  _RDX = 124 * v1;
  _RCX = g_snd.globals->entchannelInfo;
  __asm { vmovss  xmm0, dword ptr [rdx+rcx+78h] }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetEntChannelSubmixBus
==============
*/
__int64 SND_GetEntChannelSubmixBus(unsigned int entchannel)
{
  __int64 v1; 
  __int64 result; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2115, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2116, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  switch ( g_snd.globals->entchannelInfo[v1].busId )
  {
    case 1:
      result = 9i64;
      break;
    case 2:
      result = 10i64;
      break;
    case 3:
      result = 11i64;
      break;
    case 4:
      result = 12i64;
      break;
    case 5:
      result = 13i64;
      break;
    default:
      result = 8i64;
      break;
  }
  return result;
}

/*
==============
SND_GetEntParamIdx
==============
*/
__int64 SND_GetEntParamIdx(int entNum)
{
  int v1; 
  int v2; 

  v1 = 0;
  while ( 1 )
  {
    v2 = (v1 + entNum % 64 % 64) % 64;
    if ( g_sndEntityParamIndex[v2].entNum == entNum )
      break;
    if ( ++v1 >= 64 )
      return 0xFFFFi64;
  }
  return g_sndEntityParamIndex[v2].paramIndex;
}

/*
==============
SND_GetEntityParamInfo
==============
*/
EntityParamInfo *SND_GetEntityParamInfo(unsigned __int64 sndEnt)
{
  unsigned __int64 v2; 
  int v3; 
  __int64 EntParamIdx; 
  EntityParamInfo *v5; 
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 
  volatile int v10; 
  __int64 v11; 
  int v12; 

  if ( ((unsigned __int8)&g_sndEntityParamFence & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 141, ASSERT_TYPE_ASSERT, "( ( IsAligned( addr, sizeof( volatile_int32 ) ) ) )", "( addr ) = %p", (const void *)&g_sndEntityParamFence) )
    __debugbreak();
  if ( g_sndEntityParamFence != 1 )
  {
    if ( ((unsigned __int64)&g_sndEntityParamFence & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 141, ASSERT_TYPE_ASSERT, "( ( IsAligned( addr, sizeof( volatile_int32 ) ) ) )", "( addr ) = %p", (const void *)&g_sndEntityParamFence) )
      __debugbreak();
    v12 = 1;
    v10 = g_sndEntityParamFence;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1881, ASSERT_TYPE_ASSERT, "( Sys_InterlockedLoad( &g_sndEntityParamFence ) ) == ( 1 )", "%s == %s\n\t%i, %i", "Sys_InterlockedLoad( &g_sndEntityParamFence )", "1", v10, v12) )
      __debugbreak();
  }
  v2 = sndEnt & 0x1FFFFFFFFi64;
  if ( v2 - 5411 > 0x1F && v2 - 2049 > 0x8FF && v2 > 0x7FD && v2 - 5571 > 0x7A120 )
    return 0i64;
  v3 = truncate_cast<unsigned int,unsigned __int64>(v2);
  EntParamIdx = (unsigned __int16)SND_GetEntParamIdx(v3);
  if ( (_DWORD)EntParamIdx == 0xFFFF )
    return 0i64;
  if ( (unsigned int)EntParamIdx >= 0x40 )
  {
    LODWORD(v8) = 64;
    LODWORD(v7) = EntParamIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1897, ASSERT_TYPE_ASSERT, "(unsigned)( paramInfoIndex ) < (unsigned)( 64 )", "paramInfoIndex doesn't index SND_MAX_PARAM_INFO\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  v5 = &g_sndEntityParamInfo[EntParamIdx];
  if ( v5->entIndex != v3 )
  {
    LODWORD(v11) = v3;
    LODWORD(v9) = v5->entIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1900, ASSERT_TYPE_ASSERT, "( info->entIndex ) == ( entIndex )", "%s == %s\n\t%i, %i", "info->entIndex", "entIndex", v9, v11) )
      __debugbreak();
  }
  return v5;
}

/*
==============
SND_GetEqTypeFromName
==============
*/
__int64 SND_GetEqTypeFromName(const char *eqTypeName)
{
  const char **v2; 
  unsigned int v3; 
  const char *v4; 
  __int64 v5; 
  const char *v6; 
  signed __int64 v7; 
  int v8; 
  __int64 v9; 
  int v10; 
  int v11; 
  int v12; 

  v2 = snd_eqTypeStrings;
  v3 = 0;
  do
  {
    v4 = *v2;
    v5 = 0x7FFFFFFFi64;
    v6 = eqTypeName;
    if ( !*v2 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !eqTypeName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v7 = v4 - eqTypeName;
    while ( 1 )
    {
      v8 = (unsigned __int8)v6[v7];
      v9 = v5;
      v10 = *(unsigned __int8 *)v6++;
      --v5;
      if ( !v9 )
        return v3;
      if ( v8 != v10 )
      {
        v11 = v8 + 32;
        if ( (unsigned int)(v8 - 65) > 0x19 )
          v11 = v8;
        v8 = v11;
        v12 = v10 + 32;
        if ( (unsigned int)(v10 - 65) > 0x19 )
          v12 = v10;
        if ( v8 != v12 )
          break;
      }
      if ( !v8 )
        return v3;
    }
    ++v3;
    ++v2;
  }
  while ( (__int64)v2 < (__int64)&snd_eqTypeStrings[5] );
  return 5i64;
}

/*
==============
SND_GetFarDryLevel
==============
*/
float SND_GetFarDryLevel(const SndVoice *voice)
{
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  *(double *)&_XMM0 = SND_GetDryLevel(voice, 1);
  _RBX = DCONST_DVARFLT_snd_farDryAttenuation;
  __asm { vmovaps xmm6, xmm0 }
  if ( !DCONST_DVARFLT_snd_farDryAttenuation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_farDryAttenuation") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmulss  xmm1, xmm0, cs:__real@3d4ccccd; Y
    vmovss  xmm0, cs:__real@41200000; X
  }
  *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
  __asm
  {
    vcmpltss xmm2, xmm0, cs:__real@37803e84
    vxorps  xmm1, xmm1, xmm1
    vblendvps xmm0, xmm0, xmm1, xmm2
    vmulss  xmm0, xmm0, xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetFarWetLevel
==============
*/

double __fastcall SND_GetFarWetLevel(const SndVoice *voice, double _XMM1_8)
{
  double v13; 

  if ( SND_GetEntChannelSendFlag((unsigned __int8)(voice->alias->flags >> 10)) == SENDTYPE_NONE )
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  else if ( voice->reverbDef )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+4Ch]
      vmovaps [rsp+48h+var_18], xmm6
      vxorps  xmm1, xmm1, xmm1
      vmulss  xmm6, xmm0, dword ptr [rax+0ACh]
      vcomiss xmm6, xmm1
      vcomiss xmm6, cs:__real@43800000
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+48h+var_20], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12126, ASSERT_TYPE_ASSERT, "( ( wetLevel >= 0 && wetLevel <= 256 ) )", "( wetLevel ) = %g", v13) )
      __debugbreak();
    __asm
    {
      vmovaps xmm0, xmm6
      vmovaps xmm6, [rsp+48h+var_18]
    }
  }
  else
  {
    *(double *)&_XMM0 = SND_GetWetLevel(voice->alias, g_snd.activeMainReverb);
  }
  return *(double *)&_XMM0;
}

/*
==============
SND_GetFractionStartMsec
==============
*/

unsigned int __fastcall SND_GetFractionStartMsec(const SndStartAliasInfo *startAliasInfo, __int64 a2, double _XMM2_8)
{
  char v7; 
  unsigned int result; 

  _RBX = startAliasInfo;
  SND_GetSoundFileLengthMS(startAliasInfo->assetEntry);
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+40h]
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm1, xmm0
  }
  if ( v7 )
  {
    result = _RBX->timeshift;
    if ( !result )
    {
      if ( (_RBX->alias->flags & 2) != 0 )
      {
        *(double *)&_XMM0 = I_random();
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vcvtsi2ss xmm1, xmm1, edi
          vmulss  xmm0, xmm0, xmm1
          vaddss  xmm3, xmm0, cs:__real@3f000000
          vxorps  xmm2, xmm2, xmm2
          vmovss  xmm1, xmm2, xmm3
          vxorps  xmm0, xmm0, xmm0
          vroundss xmm4, xmm0, xmm1, 1
          vcvttss2si eax, xmm4
        }
        return _EAX & 0xFFFFFF00;
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm1, xmm0, xmm1
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm3, 1
      vcvttss2si eax, xmm1
    }
  }
  return result;
}

/*
==============
SND_GetHDMIChannelCount
==============
*/
__int64 SND_GetHDMIChannelCount()
{
  return (unsigned int)g_snd.playback_channels;
}

/*
==============
SND_GetLengthMS
==============
*/
char SND_GetLengthMS(unsigned int playbackId, int *msec)
{
  int v4; 
  unsigned int *p_playbackId; 

  if ( !msec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3226, ASSERT_TYPE_ASSERT, "(msec)", (const char *)&queryFormat, "msec") )
    __debugbreak();
  v4 = 0;
  *msec = 0;
  if ( playbackId && (playbackId & 0x80000000) == 0 )
  {
    p_playbackId = &g_snd.voices[1].playbackId;
    while ( *(p_playbackId - 492) != playbackId )
    {
      if ( *p_playbackId == playbackId )
      {
        ++v4;
        break;
      }
      if ( p_playbackId[492] == playbackId )
      {
        v4 += 2;
        break;
      }
      p_playbackId += 1476;
      v4 += 3;
      if ( (__int64)p_playbackId >= (__int64)&g_snd.volmods[50].goalvalue )
        break;
    }
    if ( v4 == 99 )
      return 0;
    *msec = SND_GetSoundFileLengthMS(*(const SndAssetBankEntry **)&g_snd.chaninfoUnweightedPriority[492 * v4 - 48678]);
  }
  return 1;
}

/*
==============
SND_GetListener
==============
*/
void SND_GetListener(const LocalClientNum_t localClientNum, snd_listener *outListener)
{
  __int64 v2; 
  unsigned __int64 v4; 

  v2 = localClientNum;
  _RSI = outListener;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2872, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  v4 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  _RAX = &g_snd.listeners[v2];
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsi], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsi+20h], ymm1
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups ymmword ptr [rsi+40h], ymm0
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovups ymmword ptr [rsi+60h], ymm1
  }
  if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
}

/*
==============
SND_GetListenerNearestToOrigin
==============
*/
void SND_GetListenerNearestToOrigin(const vec3_t *origin, snd_listener *outListener)
{
  unsigned __int64 v4; 
  __int64 v18; 

  __asm
  {
    vmovaps [rsp+78h+var_38], xmm6
    vmovss  xmm6, cs:__real@7f7fffff
  }
  v4 = (unsigned __int64)&g_snd.listenerFence & 3;
  _RSI = outListener;
  do
  {
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  if ( g_snd.listeners[0].active )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin; snd_local_t g_snd
      vsubss  xmm3, xmm0, dword ptr [rbp+0]
      vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+4; snd_local_t g_snd
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+8; snd_local_t g_snd
      vsubss  xmm2, xmm1, dword ptr [rbp+4]
      vsubss  xmm4, xmm0, dword ptr [rbp+8]
      vmulss  xmm0, xmm4, xmm4
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm1
      vaddss  xmm5, xmm3, xmm0
      vcmpltss xmm0, xmm5, xmm6
      vblendvps xmm6, xmm6, xmm5, xmm0
    }
  }
  v18 = 0i64;
  if ( g_snd.listeners[1].active )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+74h; snd_local_t g_snd
      vsubss  xmm3, xmm0, dword ptr [rbp+0]
      vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+78h; snd_local_t g_snd
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+7Ch; snd_local_t g_snd
      vsubss  xmm2, xmm1, dword ptr [rbp+4]
      vsubss  xmm4, xmm0, dword ptr [rbp+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm3, xmm2, xmm1
      vaddss  xmm5, xmm3, xmm0
      vcomiss xmm6, xmm5
    }
    if ( g_snd.listeners[1].active )
      v18 = 1i64;
  }
  _RAX = &g_snd.listeners[v18];
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsi], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsi+20h], ymm1
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups ymmword ptr [rsi+40h], ymm0
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovups ymmword ptr [rsi+60h], ymm1
  }
  if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
  __asm { vmovaps xmm6, [rsp+78h+var_38] }
}

/*
==============
SND_GetListenerOrigin
==============
*/
void SND_GetListenerOrigin(const LocalClientNum_t clientNum, vec3_t *outOrigin)
{
  __int64 v2; 
  unsigned __int64 v3; 
  snd_listener *v5; 

  v2 = clientNum;
  v3 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  v5 = &g_snd.listeners[v2];
  outOrigin->v[0] = v5->orient.origin.v[0];
  outOrigin->v[1] = v5->orient.origin.v[1];
  outOrigin->v[2] = v5->orient.origin.v[2];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
}

/*
==============
SND_GetMasterPercent
==============
*/
float SND_GetMasterPercent(const SndVoice *voice)
{
  if ( !voice && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15940, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
    __debugbreak();
  if ( !voice->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15941, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
    __debugbreak();
  _RAX = voice->alias;
  __asm { vmovss  xmm0, dword ptr [rax+0D4h] }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetMasterPriorityID
==============
*/
__int64 SND_GetMasterPriorityID(const SndVoice *voice)
{
  if ( voice )
    return voice->alias->masterPriority;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15933, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
    __debugbreak();
  return *(unsigned __int8 *)(MEMORY[0x70] + 209i64);
}

/*
==============
SND_GetMasterPriorityVal
==============
*/
float SND_GetMasterPriorityVal(SndVoice *voice)
{
  char v4; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( !voice && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15971, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
    __debugbreak();
  if ( !voice->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15972, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
    __debugbreak();
  SND_GetMasterPriorityID(voice);
  *(float *)&_XMM0 = SND_CalcVoiceVolume(0, voice);
  __asm { vmulss  xmm6, xmm0, dword ptr [rbx+174h] }
  _RCX = voice->alias;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  xmm1, dword ptr [rcx+0DCh]
    vcomiss xmm6, xmm1
  }
  if ( v4 )
  {
    __asm { vcomiss xmm1, xmm0 }
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15983, ASSERT_TYPE_ASSERT, "(voice->alias->masterThreshold >= 0.0f)", (const char *)&queryFormat, "voice->alias->masterThreshold >= 0.0f") )
      __debugbreak();
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vdivss  xmm1, xmm6, dword ptr [rax+0DCh]
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm0, xmm1, xmm0
    }
  }
  else
  {
    __asm { vcvtsi2ss xmm0, xmm0, eax }
  }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetNearestListenerOrigin
==============
*/
void SND_GetNearestListenerOrigin(const vec3_t *origin, vec3_t *outListenerOrigin)
{
  unsigned __int64 v4; 

  __asm
  {
    vmovaps [rsp+68h+var_38], xmm6
    vmovss  xmm6, cs:__real@7f7fffff
  }
  *(_QWORD *)outListenerOrigin->v = 0i64;
  outListenerOrigin->v[2] = 0.0;
  v4 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  if ( g_snd.listeners[0].active )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+4; snd_local_t g_snd
      vsubss  xmm2, xmm0, dword ptr [rbp+4]
      vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin+8; snd_local_t g_snd
      vmovss  xmm5, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.origin; snd_local_t g_snd
      vsubss  xmm3, xmm5, dword ptr [rbp+0]
      vsubss  xmm4, xmm1, dword ptr [rbp+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm0, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm0
      vmulss  xmm1, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm1
      vcomiss xmm2, xmm6
    }
  }
  if ( g_snd.listeners[1].active )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+78h; snd_local_t g_snd
      vsubss  xmm2, xmm0, dword ptr [rbp+4]
      vmovss  xmm1, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+7Ch; snd_local_t g_snd
      vmovss  xmm5, dword ptr cs:?g_snd@@3Usnd_local_t@@A.listeners.orient.axis+74h; snd_local_t g_snd
      vsubss  xmm3, xmm5, dword ptr [rbp+0]
      vsubss  xmm4, xmm1, dword ptr [rbp+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm0, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm0
      vmulss  xmm1, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm1
      vcomiss xmm2, xmm6
    }
  }
  if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
  __asm { vmovaps xmm6, [rsp+68h+var_38] }
}

/*
==============
SND_GetNewBulletEvent
==============
*/
__int64 SND_GetNewBulletEvent()
{
  SndBulletEvent *delayedBulletEvents; 
  unsigned int v1; 

  delayedBulletEvents = g_snd.delayedBulletEvents;
  v1 = 0;
  while ( *(_DWORD *)delayedBulletEvents->state )
  {
    ++v1;
    ++delayedBulletEvents;
    if ( v1 >= 0x40 )
      return 0xFFFFFFFFi64;
  }
  delayedBulletEvents->impactAlias = NULL;
  delayedBulletEvents->whizbyCrackAlias = NULL;
  delayedBulletEvents->whizbyInAlias = NULL;
  delayedBulletEvents->whizbyOutAlias = NULL;
  *(_QWORD *)&delayedBulletEvents->whizbyInPlayId = 0i64;
  delayedBulletEvents->impactSurfType = -1;
  *(_QWORD *)&delayedBulletEvents->explosionReflectionType = 0i64;
  delayedBulletEvents->whizbyDelay = 0;
  delayedBulletEvents->playHitMarkerSoundDuringImpact = 0;
  delayedBulletEvents->hitmarkerType = SND_HITMARKER_TYPE_STANDARD;
  return v1;
}

/*
==============
SND_GetNewEntityParamInfo
==============
*/
EntityParamInfo *SND_GetNewEntityParamInfo(unsigned __int64 sndEnt)
{
  unsigned __int64 v2; 
  signed int v3; 
  int EntParamIdx; 
  int v5; 
  EntityParamInfo *v6; 
  unsigned int v7; 
  unsigned __int16 v9; 
  EntParamIdxHashBucket *v10; 
  unsigned __int16 entNum; 
  __int64 v12; 
  volatile int v13; 
  __int64 v14; 
  int v15; 

  if ( ((unsigned __int8)&g_sndEntityParamFence & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 141, ASSERT_TYPE_ASSERT, "( ( IsAligned( addr, sizeof( volatile_int32 ) ) ) )", "( addr ) = %p", (const void *)&g_sndEntityParamFence) )
    __debugbreak();
  if ( g_sndEntityParamFence != 1 )
  {
    if ( ((unsigned __int64)&g_sndEntityParamFence & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 141, ASSERT_TYPE_ASSERT, "( ( IsAligned( addr, sizeof( volatile_int32 ) ) ) )", "( addr ) = %p", (const void *)&g_sndEntityParamFence) )
      __debugbreak();
    v15 = 1;
    v13 = g_sndEntityParamFence;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1910, ASSERT_TYPE_ASSERT, "( Sys_InterlockedLoad( &g_sndEntityParamFence ) ) == ( 1 )", "%s == %s\n\t%i, %i", "Sys_InterlockedLoad( &g_sndEntityParamFence )", "1", v13, v15) )
      __debugbreak();
  }
  v2 = sndEnt & 0x1FFFFFFFFi64;
  if ( v2 - 2046 <= 2 || v2 >= 0x7B6E4 || v2 - 4353 <= 0x421 || v2 - 5443 <= 0x7F )
    return 0i64;
  v3 = truncate_cast<unsigned int,unsigned __int64>(v2);
  EntParamIdx = (unsigned __int16)SND_GetEntParamIdx(v3);
  if ( EntParamIdx != 0xFFFF )
  {
    LODWORD(v14) = 0xFFFF;
    LODWORD(v12) = EntParamIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1924, ASSERT_TYPE_ASSERT, "( paramInfoIndex ) == ( 0xffff )", "%s == %s\n\t%i, %i", "paramInfoIndex", "SND_INVALID_PARAM_INDEX", v12, v14) )
      __debugbreak();
  }
  v5 = 0;
  v6 = g_sndEntityParamInfo;
  v7 = 0;
  while ( v6->entIndex != 0x7FFFFFFF )
  {
    ++v7;
    ++v6;
    if ( v7 >= 0x40 )
    {
      Com_PrintError(9, "Ran of sound entity params for ScaleVolume/Pitch.  Max %zu.\n", 0x40ui64);
      return 0i64;
    }
  }
  v9 = truncate_cast<unsigned short,unsigned int>(v7);
  while ( 1 )
  {
    v10 = &g_sndEntityParamIndex[(v5 + v3 % 64 % 64) % 64];
    entNum = v10->entNum;
    if ( entNum == 2047 || entNum == v3 )
      break;
    if ( ++v5 >= 64 )
    {
      Com_PrintError(9, "Too many simultaneous persistent sound params used!\n", 2047i64);
      return SND_InitEntityParamInfoEntry(v7, v3);
    }
  }
  v10->entNum = truncate_cast<unsigned short,int>(v3);
  v10->paramIndex = v9;
  return SND_InitEntityParamInfoEntry(v7, v3);
}

/*
==============
SND_GetPerkByIndex
==============
*/
snd_perk_info_t *SND_GetPerkByIndex(unsigned int perkIndex)
{
  const SndGlobals *globals; 
  __int64 v2; 

  globals = g_snd.globals;
  v2 = perkIndex;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2330, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  if ( (unsigned int)v2 >= globals->perkinfoCount )
    return 0i64;
  else
    return &globals->perkinfo[v2];
}

/*
==============
SND_GetPerkIndexFromName
==============
*/
__int64 SND_GetPerkIndexFromName(const char *name)
{
  const char *v1; 
  const SndGlobals *globals; 
  unsigned int v3; 
  char v4; 
  int v5; 
  char v6; 
  unsigned int perkinfoCount; 
  unsigned int *i; 

  v1 = name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2352, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  globals = g_snd.globals;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2353, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  v3 = 0;
  if ( v1 && (v4 = *v1) != 0 )
  {
    v5 = 5381;
    do
    {
      ++v1;
      v6 = v4 | 0x20;
      if ( (unsigned int)(v4 - 65) >= 0x1A )
        v6 = v4;
      v5 = 65599 * v5 + v6;
      v4 = *v1;
    }
    while ( *v1 );
    if ( !v5 )
      v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  perkinfoCount = globals->perkinfoCount;
  if ( !perkinfoCount )
    return 0xFFFFFFFFi64;
  for ( i = &globals->perkinfo->id; v5 != *i; i += 18 )
  {
    if ( ++v3 >= perkinfoCount )
      return 0xFFFFFFFFi64;
  }
  return v3;
}

/*
==============
SND_GetPerkName
==============
*/
snd_perk_info_t *SND_GetPerkName(unsigned int perkIndex)
{
  __int64 v1; 
  __int64 v3; 
  unsigned int perkinfoCount; 

  v1 = perkIndex;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2322, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->perkinfoCount )
  {
    perkinfoCount = g_snd.globals->perkinfoCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2323, ASSERT_TYPE_ASSERT, "(unsigned)( perkIndex ) < (unsigned)( g_snd.globals->perkinfoCount )", "perkIndex doesn't index g_snd.globals->perkinfoCount\n\t%i not in [0, %i)", v3, perkinfoCount) )
      __debugbreak();
  }
  return &g_snd.globals->perkinfo[v1];
}

/*
==============
SND_GetPerkVolume
==============
*/
float SND_GetPerkVolume(unsigned int perkIndex)
{
  __int64 v1; 
  __int64 v6; 
  unsigned int perkinfoCount; 

  v1 = perkIndex;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2342, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->perkinfoCount )
  {
    perkinfoCount = g_snd.globals->perkinfoCount;
    LODWORD(v6) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2343, ASSERT_TYPE_ASSERT, "(unsigned)( perkIndex ) < (unsigned)( g_snd.globals->perkinfoCount )", "perkIndex doesn't index g_snd.globals->perkinfoCount\n\t%i not in [0, %i)", v6, perkinfoCount) )
      __debugbreak();
  }
  _RDX = 9 * v1;
  _RCX = g_snd.globals->perkinfo;
  __asm { vmovss  xmm0, dword ptr [rcx+rdx*8+44h] }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetPlaybackChannels
==============
*/
__int64 SND_GetPlaybackChannels()
{
  return (unsigned int)g_snd.playback_channels;
}

/*
==============
SND_GetPlaybackVoice
==============
*/
SndVoice *SND_GetPlaybackVoice(unsigned int id)
{
  bool *voiceAlloc; 
  int v3; 
  unsigned int *i; 
  __int64 v6; 

  voiceAlloc = sdGlob.voiceAlloc;
  v3 = 0;
  for ( i = &g_snd.voices[0].playbackId; ; i += 492 )
  {
    if ( (unsigned int)v3 > 0x62 )
    {
      LODWORD(v6) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v6) )
        __debugbreak();
    }
    if ( *voiceAlloc && *i == id )
      break;
    ++v3;
    ++voiceAlloc;
    if ( v3 >= 99 )
      return 0i64;
  }
  return &g_snd.voices[v3];
}

/*
==============
SND_GetPriority
==============
*/
__int64 SND_GetPriority(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2061, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2062, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  return (unsigned int)g_snd.globals->entchannelInfo[v1].priority;
}

/*
==============
SND_GetRandomAliasPitch
==============
*/
double SND_GetRandomAliasPitch(const SndAlias *alias)
{
  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  _RBX = alias;
  __asm { vmovss  xmm6, dword ptr [rcx+58h] }
  *(double *)&_XMM0 = I_random();
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+5Ch]
    vsubss  xmm2, xmm1, xmm6
    vmovss  xmm1, cs:__real@3a83126f; min
    vmulss  xmm0, xmm0, xmm2
    vmovss  xmm2, cs:__real@40000000; max
    vaddss  xmm0, xmm0, xmm6; val
    vmovaps xmm6, [rsp+38h+var_18]
  }
  return I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
}

/*
==============
SND_GetRandomAliasVolume
==============
*/
double SND_GetRandomAliasVolume(const SndAlias *alias)
{
  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  _RBX = alias;
  __asm { vmovss  xmm6, dword ptr [rcx+4Ch] }
  *(double *)&_XMM0 = I_random();
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+50h]
    vsubss  xmm2, xmm1, xmm6
    vmulss  xmm0, xmm0, xmm2
    vmovss  xmm2, cs:__real@40800000; max
    vaddss  xmm0, xmm0, xmm6; val
    vxorps  xmm1, xmm1, xmm1; min
    vmovaps xmm6, [rsp+38h+var_18]
  }
  return I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
}

/*
==============
SND_GetSPDIFChannelCount
==============
*/
__int64 SND_GetSPDIFChannelCount()
{
  return (unsigned int)g_snd.playback_channels;
}

/*
==============
SND_GetSlavePercent
==============
*/
float SND_GetSlavePercent(const SndAlias *alias)
{
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vsubss  xmm1, xmm0, cs:?g_snd@@3Usnd_local_t@@A.masterPercentage; snd_local_t g_snd
    vmulss  xmm0, xmm1, dword ptr [rcx+0D8h]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetSndCurveValue
==============
*/

float __fastcall SND_GetSndCurveValue(const int knotCount, const vec2_t *knots, double fraction)
{
  bool v8; 
  bool v9; 
  bool v10; 
  bool v11; 
  bool v14; 
  int v17; 
  bool v18; 
  bool v19; 
  __int64 v36; 
  double v37; 
  double v38; 
  double v39; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  _RBX = knots;
  __asm { vmovaps [rsp+58h+var_28], xmm8 }
  _RDI = knotCount;
  __asm { vmovaps xmm6, xmm2 }
  if ( !knots && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15026, ASSERT_TYPE_ASSERT, "(knots)", (const char *)&queryFormat, "knots") )
    __debugbreak();
  v8 = (unsigned int)_RDI < 2;
  v9 = (_DWORD)_RDI == 2;
  v10 = (unsigned int)_RDI <= 2;
  if ( (int)_RDI < 2 )
  {
    LODWORD(v36) = _RDI;
    v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15027, ASSERT_TYPE_ASSERT, "( ( knotCount >= 2 ) )", "( knotCount ) = %i", v36);
    v8 = 0;
    v9 = !v11;
    v10 = !v11;
    if ( v11 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm6, xmm8
  }
  if ( v8 )
    goto LABEL_30;
  __asm { vcomiss xmm6, cs:__real@3f800000 }
  if ( !v10 )
  {
LABEL_30:
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+58h+var_30], xmm0
    }
    v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15028, ASSERT_TYPE_ASSERT, "( ( fraction >= 0.0f && fraction <= 1.0f ) )", "( fraction ) = %g", v37);
    v9 = !v14;
    if ( v14 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+rdi*8-8]
    vucomiss xmm0, cs:__real@3f800000
  }
  if ( !v9 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+58h+var_30], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15029, ASSERT_TYPE_ASSERT, "( ( knots[knotCount - 1][0] == 1.0f ) )", "( knots[knotCount - 1][0] ) = %g", v38) )
      __debugbreak();
  }
  v17 = 1;
  v18 = _RDI == 0;
  v19 = (unsigned __int64)_RDI <= 1;
  if ( _RDI <= 1 )
  {
LABEL_18:
    __asm { vmovss  xmm0, cs:__real@bf800000 }
  }
  else
  {
    _RAX = 1i64;
    while ( 1 )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rbx+rax*8]
        vcomiss xmm6, xmm1
      }
      if ( v19 )
        break;
      ++v17;
      v18 = ++_RAX < (unsigned __int64)_RDI;
      v19 = _RAX <= (unsigned __int64)_RDI;
      if ( _RAX >= _RDI )
        goto LABEL_18;
    }
    _RDI = v17;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+rdi*8-8]
      vsubss  xmm2, xmm1, xmm0
      vcomiss xmm2, cs:__real@37803e84
    }
    if ( v19 )
    {
      __asm { vmovaps xmm6, xmm8 }
    }
    else
    {
      __asm
      {
        vsubss  xmm0, xmm6, xmm0
        vdivss  xmm6, xmm0, xmm2
        vcomiss xmm6, xmm8
      }
      if ( v18 )
        goto LABEL_23;
      __asm { vcomiss xmm6, cs:__real@3f800000 }
      if ( !v19 )
      {
LABEL_23:
        __asm
        {
          vcvtss2sd xmm0, xmm6, xmm6
          vmovsd  [rsp+58h+var_30], xmm0
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15038, ASSERT_TYPE_ASSERT, "( ( adjustedFrac >= 0.0f && adjustedFrac <= 1.0f ) )", "( adjustedFrac ) = %g", v39) )
          __debugbreak();
      }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+rdi*8+4]
      vsubss  xmm1, xmm0, dword ptr [rbx+rdi*8-4]
      vmulss  xmm2, xmm1, xmm6
      vaddss  xmm0, xmm2, dword ptr [rbx+rdi*8-4]
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm8, [rsp+58h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetSoundEqOverlay
==============
*/
const SndGlobals *SND_GetSoundEqOverlay(snd_eqoverlay_info_t *info, unsigned int maxcount)
{
  const SndGlobals *result; 
  __int64 entchannelCount; 
  SDLocal *v5; 
  __int64 v6; 
  SndEqParams **v8; 
  SDLocal *v9; 
  __int64 v10; 
  SndEqParams *v11; 

  result = g_snd.globals;
  _RBX = info;
  if ( g_snd.globals )
  {
    entchannelCount = g_snd.globals->entchannelCount;
    if ( (unsigned int)entchannelCount > maxcount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1000, ASSERT_TYPE_ASSERT, "(entChannelCount <= maxcount)", (const char *)&queryFormat, "entChannelCount <= maxcount") )
      __debugbreak();
    if ( (_DWORD)entchannelCount )
    {
      v5 = &sdGlob;
      v6 = entchannelCount;
      do
      {
        __asm
        {
          vmovss  xmm0, cs:?sdGlob@@3USDLocal@@A.eqLerp; SDLocal sdGlob
          vmovss  dword ptr [rbx+20h], xmm0
        }
        v8 = (SndEqParams **)_RBX;
        v9 = v5;
        v10 = 2i64;
        do
        {
          *v8 = (SndEqParams *)v9;
          v11 = v9->eqParams[0][1];
          v9 = (SDLocal *)((char *)v9 + 10240);
          v8[1] = v11;
          v8 += 2;
          --v10;
        }
        while ( v10 );
        v5 = (SDLocal *)((char *)v5 + 20);
        ++_RBX;
        --v6;
      }
      while ( v6 );
    }
    return (const SndGlobals *)(unsigned int)entchannelCount;
  }
  return result;
}

/*
==============
SND_GetSoundFileLengthMS
==============
*/
int SND_GetSoundFileLengthMS(const SndAssetBankEntry *entry)
{
  __int64 v2; 

  if ( !entry && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1770, ASSERT_TYPE_ASSERT, "(entry)", (const char *)&queryFormat, "entry") )
    __debugbreak();
  LODWORD(v2) = SND_AssetBankGetFrameRate(entry);
  if ( (_DWORD)v2 )
    return 1000 * (unsigned __int64)entry->frameCount / (unsigned int)v2;
  return v2;
}

/*
==============
SND_GetSoundOverlay
==============
*/
int SND_GetSoundOverlay(snd_overlay_info_t *info, int maxcount, int *cpu)
{
  if ( !info && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11497, ASSERT_TYPE_ASSERT, "(info)", (const char *)&queryFormat, "info") )
    __debugbreak();
  if ( maxcount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11498, ASSERT_TYPE_ASSERT, "(maxcount > 0)", (const char *)&queryFormat, "maxcount > 0") )
    __debugbreak();
  if ( !cpu && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11499, ASSERT_TYPE_ASSERT, "(cpu)", (const char *)&queryFormat, "cpu") )
    __debugbreak();
  if ( !g_snd.driverInitialized )
    return 0;
  *cpu = g_snd.clientFrameUsec;
  return SND_GetSoundOverlay_Internal(info, 0, maxcount);
}

/*
==============
SND_GetSoundOverlay
==============
*/
int SND_GetSoundOverlay(snd_overlay_type_t type, snd_overlay_info_t *info, int maxcount, int *cpu)
{
  int v8; 
  int result; 
  int v10; 
  int v11; 
  snd_overlay_info_t *v12; 

  if ( !info && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11463, ASSERT_TYPE_ASSERT, "(info)", (const char *)&queryFormat, "info") )
    __debugbreak();
  if ( maxcount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11464, ASSERT_TYPE_ASSERT, "(maxcount > 0)", (const char *)&queryFormat, "maxcount > 0") )
    __debugbreak();
  if ( !cpu && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11465, ASSERT_TYPE_ASSERT, "(cpu)", (const char *)&queryFormat, "cpu") )
    __debugbreak();
  if ( !g_snd.driverInitialized )
    return 0;
  *cpu = g_snd.clientFrameUsec;
  switch ( type )
  {
    case SND_OVERLAY_3D:
    case SND_OVERLAY_3D_VOLS:
      v10 = 48;
      v11 = 32;
      v12 = info;
      if ( maxcount < 48 )
        v10 = maxcount;
      goto LABEL_23;
    case SND_OVERLAY_STREAM:
    case SND_OVERLAY_STREAM_VOLS:
      v10 = 14;
      v11 = 80;
      v12 = info;
      if ( maxcount < 14 )
        v10 = maxcount;
      goto LABEL_23;
    case SND_OVERLAY_2D:
    case SND_OVERLAY_2D_VOLS:
      v8 = 32;
      if ( maxcount < 32 )
        v8 = maxcount;
      return SND_GetSoundOverlay_Internal(info, 0, v8);
    case SND_OVERLAY_VEHICLE:
    case SND_OVERLAY_VEHICLE_VOLS:
      v10 = 5;
      v11 = 94;
      v12 = info;
      if ( maxcount < 5 )
        v10 = maxcount;
LABEL_23:
      result = SND_GetSoundOverlay_Internal(v12, v11, v10);
      break;
    default:
      return 0;
  }
  return result;
}

/*
==============
SND_GetSoundOverlay_Internal
==============
*/
__int64 SND_GetSoundOverlay_Internal(snd_overlay_info_t *info, int startIndex, int maxcount)
{
  __int64 v12; 
  snd_overlay_info_t *v13; 
  __int64 v14; 
  bool *v16; 
  unsigned int v17; 
  unsigned int *v22; 
  unsigned int *v23; 
  const char *v26; 
  char *pszSampleName; 
  const char *EntChannelName; 
  const SpeakerMap *SpeakerMapById; 
  const dvar_t *v30; 
  char v31; 
  bool v32; 
  bool IsChannelMissionVOChannel; 
  unsigned int v34; 
  int v41; 
  __int64 v42; 
  unsigned int *v43; 
  __int64 v44; 
  unsigned int *v45; 
  int v48; 
  unsigned int AliasEntChannelId; 
  MapEnts *mapEnts; 
  unsigned int v52; 
  __int64 v53; 
  int audioPASpeakerCount; 
  volatile int v56; 
  unsigned int v57; 
  unsigned int entChannelHash; 
  const char *VolModName; 
  __int64 result; 
  __int64 v96; 
  __int64 v97; 
  unsigned int *v99; 
  __int64 v100; 
  unsigned int v102; 
  unsigned int v103; 
  unsigned int *v104; 
  unsigned __int8 v105; 
  bool *v106; 
  unsigned int *p_contextValue; 
  vec3_t origin; 
  vec3_t to; 

  v12 = startIndex;
  v13 = info;
  v103 = maxcount;
  if ( startIndex + maxcount > 99 )
  {
    maxcount = 99 - startIndex;
    v103 = 99 - startIndex;
  }
  v14 = maxcount;
  v100 = maxcount;
  if ( maxcount <= 0 )
    return (unsigned int)maxcount;
  _RDI = &v13->contextValue;
  v16 = &sdGlob.voiceAlloc[startIndex];
  __asm
  {
    vmovaps [rsp+188h+var_48], xmm6
    vmovaps [rsp+188h+var_58], xmm7
    vmovaps [rsp+188h+var_68], xmm8
  }
  v17 = startIndex;
  __asm
  {
    vmovaps [rsp+188h+var_78], xmm9
    vmovaps [rsp+188h+var_88], xmm10
    vmovaps [rsp+188h+var_98], xmm11
    vmovss  xmm11, cs:__real@7f7fffff
    vmovaps [rsp+188h+var_A8], xmm12
    vmovss  xmm12, cs:__real@37803e84
    vmovaps [rsp+188h+var_B8], xmm13
    vmovaps [rsp+188h+var_C8], xmm14
    vmovss  xmm13, cs:__real@41a00000
    vmovss  xmm14, cs:__real@41400000
  }
  v22 = &sdGlob.currentReverbId[65 * startIndex - 6433];
  v102 = v12;
  v23 = &g_snd.chaninfoEntchannel[v12];
  v106 = &sdGlob.voiceAlloc[v12];
  _R14 = &g_snd.chaninfoUnweightedPriority[492 * v12 - 48560];
  p_contextValue = &v13->contextValue;
  v104 = &sdGlob.currentReverbId[65 * v12 - 6433];
  v99 = v23;
  __asm { vxorps  xmm10, xmm10, xmm10 }
  do
  {
    if ( v17 > 0x62 )
    {
      LODWORD(v96) = v17;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v96) )
        __debugbreak();
      v23 = v99;
      v14 = v100;
      v22 = v104;
    }
    if ( *v16 && *((_DWORD *)_R14 - 148) == 2 || *((_DWORD *)_R14 - 148) == 1 )
    {
      if ( *((int *)_R14 - 146) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11262, ASSERT_TYPE_ASSERT, "((voice->soundFileInfo.baserate > 0))", (const char *)&queryFormat, "(voice->soundFileInfo.baserate > 0)") )
        __debugbreak();
      if ( !*((_QWORD *)_R14 - 60) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11264, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
        __debugbreak();
      v26 = "null";
      if ( *(_QWORD *)(*((_QWORD *)_R14 - 60) + 24i64) )
        v26 = *(const char **)(*((_QWORD *)_R14 - 60) + 24i64);
      v105 = v17 - v12;
      pszSampleName = v13[(int)(v17 - v12)].pszSampleName;
      Core_strcpy(pszSampleName, 0x80ui64, v26);
      Com_sprintf(pszSampleName + 128, 0x80ui64, (const char *)&queryFormat, **((_QWORD **)_R14 - 60));
      EntChannelName = SND_GetEntChannelName(*v99);
      Com_sprintf(pszSampleName + 256, 0x40ui64, (const char *)&queryFormat, EntChannelName);
      SpeakerMapById = (const SpeakerMap *)(_R14 + 183);
      *(_RDI - 7) = *v104;
      *(_RDI - 1) = *(_DWORD *)(*((_QWORD *)_R14 - 60) + 44i64);
      *_RDI = *(_DWORD *)(*((_QWORD *)_R14 - 60) + 48i64);
      _RDI[1] = *(_DWORD *)(*((_QWORD *)_R14 - 60) + 52i64);
      _RDI[2] = *(_DWORD *)(*((_QWORD *)_R14 - 60) + 56i64);
      *((_QWORD *)_RDI + 2) = *(_QWORD *)(*((_QWORD *)_R14 - 60) + 64i64);
      v30 = DCONST_DVARBOOL_snd_enable_capture_mode;
      if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v30);
      v31 = 0;
      v32 = !v30->current.enabled;
      if ( v30->current.enabled )
      {
        IsChannelMissionVOChannel = SND_IsChannelMissionVOChannel((unsigned __int8)(*(int *)(*((_QWORD *)_R14 - 60) + 112i64) >> 10));
        v31 = 0;
        v32 = !IsChannelMissionVOChannel;
        if ( IsChannelMissionVOChannel )
        {
          v34 = SND_HashName(S_VO_CENTER_ONLY_MAP);
          SpeakerMapById = SND_GetSpeakerMapById(v34);
        }
      }
      __asm
      {
        vmovss  xmm0, dword ptr [r14-228h]
        vmulss  xmm1, xmm0, dword ptr [r14-1D0h]
        vmovss  dword ptr [rdi-28h], xmm1
        vmovss  xmm2, dword ptr [r14-224h]
        vmovss  dword ptr [rdi-24h], xmm2
        vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.volume; snd_local_t g_snd
        vcomiss xmm0, xmm10
      }
      if ( !(v31 | v32) )
      {
        __asm
        {
          vdivss  xmm0, xmm2, xmm0
          vmovss  dword ptr [rdi-24h], xmm0
        }
      }
      if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
      {
        __asm
        {
          vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.value; snd_local_t g_snd
          vmulss  xmm1, xmm0, dword ptr [rdi-24h]
          vmovss  dword ptr [rdi-24h], xmm1
        }
      }
      __asm { vmovaps xmm9, xmm10 }
      if ( v17 > 0x62 )
      {
        LODWORD(v96) = v17;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v96) )
          __debugbreak();
      }
      if ( *v16 )
      {
        v42 = 0i64;
        v43 = v104 + 45;
        while ( 2 )
        {
          v44 = 0i64;
          v45 = v43;
          do
          {
            if ( *(_BYTE *)v45 )
            {
              v41 = 1;
              goto LABEL_43;
            }
            ++v44;
            v45 += 5;
          }
          while ( v44 < 2 );
          ++v42;
          v43 += 10;
          if ( v42 < 2 )
            continue;
          break;
        }
        v41 = 0;
      }
      else
      {
        v41 = 0;
      }
LABEL_43:
      *(_RDI - 6) = v41;
      if ( SND_IsEntChannel3D((unsigned __int8)(*(int *)(*((_QWORD *)_R14 - 60) + 112i64) >> 10)) )
      {
        GetSecureSndVec3((const vec3_t *)(_R14 - 113), &to, s_soundvoiceorg_aab_X, s_soundvoiceorg_aab_Y, s_soundvoiceorg_aab_Z);
        *(double *)&_XMM0 = SND_DistSqToNearestListener(&to);
        __asm
        {
          vsqrtss xmm9, xmm0, xmm0
          vcvttss2si eax, xmm9
        }
        *(_RDI - 8) = _EAX;
        *(_RDI - 5) = *((_DWORD *)_R14 - 103);
        *(_RDI - 4) = *((_DWORD *)_R14 - 83);
        if ( _R14 != (float *)-1184i64 )
          Com_sprintf(pszSampleName + 704, 0x40ui64, (const char *)&queryFormat);
      }
      else
      {
        *(_RDI - 8) = -1;
        *(_QWORD *)(_RDI - 5) = 0i64;
      }
      if ( SND_IsEntChannelPASpeaker((unsigned __int8)(*(int *)(*((_QWORD *)_R14 - 60) + 112i64) >> 10)) )
      {
        __asm { vmovaps xmm8, xmm10 }
        Com_sprintf(pszSampleName + 320, 0x40ui64, (const char *)&queryFormat, _R14 - 17);
        Com_sprintf(pszSampleName + 384, 0x40ui64, (const char *)&queryFormat, _R14 + 33);
        Com_sprintf(pszSampleName + 448, 0x40ui64, (const char *)&queryFormat, _R14 + 83);
        Com_sprintf(pszSampleName + 512, 0x40ui64, (const char *)&queryFormat, _R14 + 133);
        Com_sprintf(pszSampleName + 576, 0x40ui64, (const char *)&queryFormat, SpeakerMapById);
        *(_QWORD *)(_RDI - 5) = 0i64;
        _RCX = (const SndAlias *)*((_QWORD *)_R14 - 60);
        if ( SpeakerMapById->id == g_snd.defaultHash )
          goto LABEL_48;
        __asm { vcomiss xmm10, dword ptr [rcx+0B8h] }
        v48 = 2;
        if ( SpeakerMapById->id >= g_snd.defaultHash )
LABEL_48:
          v48 = 1;
        __asm { vmovaps xmm7, xmm11 }
        AliasEntChannelId = SND_GetAliasEntChannelId(_RCX);
        mapEnts = cm.mapEnts;
        v52 = AliasEntChannelId;
        v53 = 0i64;
        while ( 2 )
        {
          if ( mapEnts )
          {
            if ( mapEnts->audioPASpeakerCount >= 0x40 )
            {
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 532, ASSERT_TYPE_ASSERT, "(cm.mapEnts->audioPASpeakerCount < 64)", (const char *)&queryFormat, "cm.mapEnts->audioPASpeakerCount < AUDIO_PA_SPEAKERS_MAXSIZE") )
                __debugbreak();
              mapEnts = cm.mapEnts;
            }
            audioPASpeakerCount = mapEnts->audioPASpeakerCount;
          }
          else
          {
            audioPASpeakerCount = 0;
          }
          if ( (int)v53 >= audioPASpeakerCount )
          {
            _RDI = p_contextValue;
            v17 = v102;
            v16 = v106;
            __asm
            {
              vmulss  xmm0, xmm8, dword ptr [rdi-24h]
              vcvttss2si eax, xmm7
              vmovss  dword ptr [rdi-24h], xmm0
            }
            *(p_contextValue - 8) = _EAX;
            goto LABEL_80;
          }
          if ( (unsigned int)v53 >= 0x40 )
          {
            LODWORD(v97) = 64;
            LODWORD(v96) = v53;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 14, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v96, v97) )
              __debugbreak();
            mapEnts = cm.mapEnts;
          }
          v56 = g_snd.voiceBusyUpdating[((__int64)(int)v53 >> 5) - 2];
          if ( !_bittest((const int *)&v56, v53 & 0x1F) )
          {
            if ( mapEnts && (v57 = mapEnts->audioPASpeakerCount, v57 > (unsigned int)v53) )
            {
              entChannelHash = mapEnts->audioPASpeakers[v53].entChannelHash;
              if ( !entChannelHash || entChannelHash == v52 )
              {
                if ( v57 > (unsigned int)v53 )
                {
                  _RAX = mapEnts->audioPASpeakers;
                  _RCX = 5 * v53;
                  __asm
                  {
                    vmovss  xmm0, dword ptr [rax+rcx*4]
                    vmovss  xmm1, dword ptr [rax+rcx*4+4]
                    vmovss  dword ptr [rsp+188h+origin], xmm0
                    vmovss  xmm0, dword ptr [rax+rcx*4+8]
                    vmovss  dword ptr [rsp+188h+origin+8], xmm0
                    vmovss  dword ptr [rsp+188h+origin+4], xmm1
                  }
                }
                goto LABEL_71;
              }
            }
            else
            {
LABEL_71:
              *(double *)&_XMM0 = SND_DistSqToNearestListener(&origin);
              _RAX = *((_QWORD *)_R14 - 60);
              __asm
              {
                vsqrtss xmm6, xmm0, xmm0
                vmovaps xmm0, xmm9; radius
                vmovss  xmm2, dword ptr [rax+68h]; maxdist
                vmovss  xmm1, dword ptr [rax+64h]; mindist
              }
              *(double *)&_XMM0 = SND_GetDistanceCurveFraction(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
              __asm { vmovaps xmm2, xmm0; fraction }
              *(double *)&_XMM0 = SND_GetSndCurveValue(*(_DWORD *)_R14, (const vec2_t *)(_R14 + 1), *(const float *)&_XMM2);
              mapEnts = cm.mapEnts;
              __asm
              {
                vmaxss  xmm8, xmm0, xmm8
                vminss  xmm7, xmm6, xmm7
              }
            }
          }
          v53 = (unsigned int)(v53 + 1);
          continue;
        }
      }
      if ( SND_IsEntChannel3D((unsigned __int8)(*(int *)(*((_QWORD *)_R14 - 60) + 112i64) >> 10)) )
      {
        _RAX = *((_QWORD *)_R14 - 60);
        __asm
        {
          vmovaps xmm0, xmm9; radius
          vmovss  xmm2, dword ptr [rax+68h]; maxdist
          vmovss  xmm1, dword ptr [rax+64h]; mindist
        }
        *(double *)&_XMM0 = SND_GetDistanceCurveFraction(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vmovaps xmm2, xmm0; fraction }
        *(double *)&_XMM0 = SND_GetSndCurveValue(*(_DWORD *)_R14, (const vec2_t *)(_R14 + 1), *(const float *)&_XMM2);
        __asm
        {
          vmulss  xmm1, xmm0, dword ptr [rdi-24h]
          vmovss  dword ptr [rdi-24h], xmm1
        }
        Com_sprintf(pszSampleName + 320, 0x40ui64, (const char *)&queryFormat, _R14 - 17);
        Com_sprintf(pszSampleName + 384, 0x40ui64, (const char *)&queryFormat, _R14 + 33);
        Com_sprintf(pszSampleName + 448, 0x40ui64, (const char *)&queryFormat, _R14 + 83);
        Com_sprintf(pszSampleName + 512, 0x40ui64, (const char *)&queryFormat, _R14 + 133);
        Com_sprintf(pszSampleName + 576, 0x40ui64, (const char *)&queryFormat, SpeakerMapById);
        if ( SpeakerMapById->id == g_snd.defaultHash )
          goto LABEL_78;
        _RAX = *((_QWORD *)_R14 - 60);
        __asm { vcomiss xmm10, dword ptr [rax+0B8h] }
        if ( SpeakerMapById->id >= g_snd.defaultHash )
LABEL_78:
          v48 = 1;
        else
          v48 = 2;
      }
      else
      {
        *(_RDI - 8) = -1;
        *((_BYTE *)_RDI - 488) = 0;
        *((_BYTE *)_RDI - 424) = 0;
        *((_BYTE *)_RDI - 360) = 0;
        *((_BYTE *)_RDI - 296) = 0;
        *((_BYTE *)_RDI - 104) = 0;
        Com_sprintf(pszSampleName + 576, 0x40ui64, (const char *)&queryFormat, SpeakerMapById);
        v48 = 0;
      }
LABEL_80:
      VolModName = SND_GetVolModName(*(_DWORD *)(*((_QWORD *)_R14 - 60) + 84i64));
      Com_sprintf(pszSampleName + 640, 0x40ui64, (const char *)&queryFormat, VolModName);
      __asm
      {
        vmovss  xmm0, dword ptr [rdi-28h]
        vmaxss  xmm0, xmm0, xmm12; X
      }
      *(_RDI - 2) = LODWORD(g_snd.volmods[*(int *)(*((_QWORD *)_R14 - 60) + 84i64)].value);
      *(_RDI - 3) = v48 | (16 * v105) | (*(int *)(*((_QWORD *)_R14 - 60) + 112i64) >> 5) & 0x1C;
      *(float *)&_XMM0 = log10f_0(*(float *)&_XMM0);
      __asm
      {
        vmovss  xmm2, dword ptr [rdi-24h]
        vmulss  xmm1, xmm0, xmm13
        vmaxss  xmm0, xmm2, xmm12; X
        vmovss  dword ptr [rdi-28h], xmm1
      }
      *(float *)&_XMM0 = log10f_0(*(float *)&_XMM0);
      __asm
      {
        vmulss  xmm1, xmm0, xmm13
        vmovss  xmm0, dword ptr [rdi-1Ch]; X
        vmovss  dword ptr [rdi-24h], xmm1
      }
      *(float *)&_XMM0 = log2f(*(float *)&_XMM0);
      v22 = v104;
      __asm
      {
        vmulss  xmm1, xmm0, xmm14
        vmovss  dword ptr [rdi-1Ch], xmm1
      }
      switch ( *(v104 - 2) )
      {
        case 9u:
          _RDI[3] = 1;
          break;
        case 0xAu:
          _RDI[3] = 2;
          break;
        case 0xBu:
          _RDI[3] = 3;
          break;
        case 0xCu:
          _RDI[3] = 4;
          break;
        case 0xDu:
          _RDI[3] = 5;
          break;
        default:
          _RDI[3] = 0;
          break;
      }
      v13 = info;
      LODWORD(v12) = startIndex;
      v23 = v99;
      v14 = v100;
    }
    else
    {
      *((_BYTE *)_RDI - 808) = 0;
    }
    ++v17;
    ++v23;
    v102 = v17;
    v22 += 65;
    v99 = v23;
    ++v16;
    v104 = v22;
    _RDI += 208;
    v106 = v16;
    _R14 += 492;
    p_contextValue = _RDI;
    v100 = --v14;
  }
  while ( v14 );
  result = v103;
  __asm
  {
    vmovaps xmm14, [rsp+188h+var_C8]
    vmovaps xmm13, [rsp+188h+var_B8]
    vmovaps xmm12, [rsp+188h+var_A8]
    vmovaps xmm11, [rsp+188h+var_98]
    vmovaps xmm10, [rsp+188h+var_88]
    vmovaps xmm9, [rsp+188h+var_78]
    vmovaps xmm8, [rsp+188h+var_68]
    vmovaps xmm7, [rsp+188h+var_58]
    vmovaps xmm6, [rsp+188h+var_48]
  }
  return result;
}

/*
==============
SND_GetStreamIoActive
==============
*/
__int64 SND_GetStreamIoActive()
{
  return (unsigned int)g_sd_stream_globals.streamIoActive;
}

/*
==============
SND_GetSubtitleForPlaybackId
==============
*/
const char *SND_GetSubtitleForPlaybackId(unsigned int id)
{
  int v1; 
  unsigned int *p_playbackId; 

  if ( !id )
    return 0i64;
  v1 = 0;
  p_playbackId = &g_snd.voices[0].playbackId;
  while ( *p_playbackId != id )
  {
    ++v1;
    p_playbackId += 492;
    if ( (__int64)p_playbackId >= (__int64)&g_snd.chaninfoUnweightedPriority[7] )
      return 0i64;
  }
  return *(const char **)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v1 - 48680] + 8i64);
}

/*
==============
SND_GetTimescaleLerp
==============
*/
float SND_GetTimescaleLerp(const unsigned int entchannel)
{
  __int64 v5; 

  _RBX = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2266, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)_RBX >= g_snd.globals->entchannelCount )
  {
    LODWORD(v5) = _RBX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2267, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v5) )
      __debugbreak();
  }
  _RCX = g_snd.entchanOverrides.timescaleLerp;
  __asm { vmovss  xmm0, dword ptr [rcx+rbx*4] }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetVoiceFractionPlayed
==============
*/
double SND_GetVoiceFractionPlayed(int index, bool wrap)
{
  __int64 v3; 
  int v5; 

  v3 = index;
  if ( index < 80 )
  {
    if ( index <= -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1314, ASSERT_TYPE_ASSERT, "( ( (index >= 0 && index < 0 + 32) || (index >= (0 + 32) && index < (0 + 32) + 48) ) )", "( index ) = %i", index) )
      __debugbreak();
    _RCX = v3;
    goto LABEL_13;
  }
  if ( index >= 94 )
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
    return *(double *)&_XMM0;
  }
  v5 = SND_SyncAmbientTracks_Internal(index, 0, 1);
  if ( v5 == (_DWORD)v3 )
    v5 = SND_SyncAmbientTracks_Internal(v3, 2, 3);
  _R9 = &g_snd;
  _RCX = v5;
  if ( g_snd.voices[_RCX].soundFileInfo.loadingState != SFLS_LOADING )
  {
LABEL_13:
    *(float *)&_XMM0 = SND_AbsoluteToFractionalPosition(g_snd.voices[_RCX].framesPlayed, wrap, g_snd.voices[_RCX].assetEntry->frameCount);
    return *(double *)&_XMM0;
  }
  __asm { vmovss  xmm0, dword ptr [rcx+r9+0CAF8h] }
  return *(double *)&_XMM0;
}

/*
==============
SND_GetVoiceIndexForId
==============
*/
__int64 SND_GetVoiceIndexForId(unsigned int id)
{
  unsigned int v1; 
  bool *voiceAlloc; 
  unsigned int *i; 

  if ( !id )
    return 0xFFFFFFFFi64;
  v1 = 0;
  voiceAlloc = sdGlob.voiceAlloc;
  for ( i = &g_snd.voices[0].playbackId; !*voiceAlloc || *i != id; i += 492 )
  {
    ++v1;
    ++voiceAlloc;
    if ( v1 >= 0x63 )
      return 0xFFFFFFFFi64;
  }
  return v1;
}

/*
==============
SND_GetVolModByIndex
==============
*/
snd_volmod_info_t *SND_GetVolModByIndex(unsigned int volmodIndex)
{
  const SndGlobals *globals; 
  __int64 v2; 

  globals = g_snd.globals;
  v2 = volmodIndex;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2282, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  if ( (unsigned int)v2 >= globals->volmodinfoCount )
    return 0i64;
  else
    return &globals->volmodinfo[v2];
}

/*
==============
SND_GetVolModCount
==============
*/
__int64 SND_GetVolModCount()
{
  const SndGlobals *globals; 

  globals = g_snd.globals;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4831, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  return globals->volmodinfoCount;
}

/*
==============
SND_GetVolModDefaultValue
==============
*/
float SND_GetVolModDefaultValue(unsigned int volmodIndex)
{
  __int64 v1; 
  __int64 v6; 
  unsigned int volmodinfoCount; 

  v1 = volmodIndex;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2295, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->volmodinfoCount )
  {
    volmodinfoCount = g_snd.globals->volmodinfoCount;
    LODWORD(v6) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2296, ASSERT_TYPE_ASSERT, "(unsigned)( volmodIndex ) < (unsigned)( g_snd.globals->volmodinfoCount )", "volmodIndex doesn't index g_snd.globals->volmodinfoCount\n\t%i not in [0, %i)", v6, volmodinfoCount) )
      __debugbreak();
  }
  _RDX = 9 * v1;
  _RCX = g_snd.globals->volmodinfo;
  __asm { vmovss  xmm0, dword ptr [rcx+rdx*8+44h] }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetVolModIndexFromName
==============
*/
__int64 SND_GetVolModIndexFromName(const char *name)
{
  const char *v1; 
  const SndGlobals *globals; 
  unsigned int v3; 
  char v4; 
  int v5; 
  char v6; 
  unsigned int volmodinfoCount; 
  unsigned int *i; 

  v1 = name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2305, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
    __debugbreak();
  globals = g_snd.globals;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2306, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  v3 = 0;
  if ( v1 && (v4 = *v1) != 0 )
  {
    v5 = 5381;
    do
    {
      ++v1;
      v6 = v4 | 0x20;
      if ( (unsigned int)(v4 - 65) >= 0x1A )
        v6 = v4;
      v5 = 65599 * v5 + v6;
      v4 = *v1;
    }
    while ( *v1 );
    if ( !v5 )
      v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  volmodinfoCount = globals->volmodinfoCount;
  if ( !volmodinfoCount )
    return 0xFFFFFFFFi64;
  for ( i = &globals->volmodinfo->id; v5 != *i; i += 18 )
  {
    if ( ++v3 >= volmodinfoCount )
      return 0xFFFFFFFFi64;
  }
  return v3;
}

/*
==============
SND_GetVolModName
==============
*/
snd_volmod_info_t *SND_GetVolModName(unsigned int volmodIndex)
{
  __int64 v1; 
  __int64 v3; 
  unsigned int volmodinfoCount; 

  v1 = volmodIndex;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2274, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->volmodinfoCount )
  {
    volmodinfoCount = g_snd.globals->volmodinfoCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2275, ASSERT_TYPE_ASSERT, "(unsigned)( volmodIndex ) < (unsigned)( g_snd.globals->volmodinfoCount )", "volmodIndex doesn't index g_snd.globals->volmodinfoCount\n\t%i not in [0, %i)", v3, volmodinfoCount) )
      __debugbreak();
  }
  return &g_snd.globals->volmodinfo[v1];
}

/*
==============
SND_GetVolume
==============
*/
float SND_GetVolume()
{
  __asm { vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.volume; snd_local_t g_snd }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetVolumeFalloffGain
==============
*/

float __fastcall SND_GetVolumeFalloffGain(const SndVoice *voice, double dist, const float distFrac, const SndCurve *vfCurve)
{
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
    vmovaps xmm7, xmm1
  }
  *(double *)&_XMM0 = SND_GetSndCurveValue(vfCurve->numPoints, vfCurve->points, distFrac);
  _RAX = voice->alias;
  __asm { vmovaps xmm6, xmm0 }
  if ( ((_RAX->flags >> 4) & 7) != 0 )
  {
    __asm
    {
      vmovss  xmm2, dword ptr [rax+60h]
      vcomiss xmm7, xmm2
    }
  }
  __asm
  {
    vmovaps xmm7, [rsp+58h+var_28]
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetWeapFireAtmoSound
==============
*/
SndAliasList *SND_GetWeapFireAtmoSound(const WeaponSFXPackage *sfxPackage, bool isPlayerView, bool isDualWield, PlayerHandIndex hand)
{
  WeaponSFXPackageSounds *sounds; 
  const char *v9; 
  __int64 v10; 
  const char *v11; 
  SndAliasList *result; 
  const dvar_t *v13; 

  if ( !sfxPackage )
    return 0i64;
  sounds = sfxPackage->sounds;
  v9 = (const char *)*((_QWORD *)&sounds->fireSoundAtmosphere.name + isPlayerView);
  if ( isPlayerView && isDualWield )
  {
    v10 = 144i64;
    if ( hand != WEAPON_HAND_LEFT )
      v10 = 152i64;
    v11 = *(const char **)((char *)&sounds->name + v10);
    if ( v11 )
      v9 = v11;
  }
  if ( !v9 )
    return 0i64;
  result = SND_TryFindAlias(v9);
  if ( !result )
  {
    v13 = DCONST_DVARBOOL_snd_bankDetailStreamingFallback;
    if ( !DCONST_DVARBOOL_snd_bankDetailStreamingFallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_bankDetailStreamingFallback") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    if ( v13->current.enabled )
    {
      if ( sfxPackage->transientFallbackPackage == sfxPackage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5232, ASSERT_TYPE_ASSERT, "(sfxPackage->transientFallbackPackage != sfxPackage)", (const char *)&queryFormat, "sfxPackage->transientFallbackPackage != sfxPackage") )
        __debugbreak();
      return (SndAliasList *)SND_GetWeapFireAtmoSound(sfxPackage->transientFallbackPackage, isPlayerView, isDualWield, hand);
    }
    else
    {
      SND_Missing(v9);
      return 0i64;
    }
  }
  return result;
}

/*
==============
SND_GetWetLevel
==============
*/

float __fastcall SND_GetWetLevel(const SndAlias *pAlias, ReverbDescriptor index, double _XMM2_8, double _XMM3_8)
{
  __int64 v6; 
  double v20; 

  v6 = index;
  if ( !pAlias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12081, ASSERT_TYPE_ASSERT, "(pAlias)", (const char *)&queryFormat, "pAlias") )
    __debugbreak();
  if ( (unsigned int)v6 > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12082, ASSERT_TYPE_ASSERT, "(index == RVB_MAIN_A || index == RVB_MAIN_B)", (const char *)&queryFormat, "index == RVB_MAIN_A || index == RVB_MAIN_B") )
    __debugbreak();
  if ( SND_GetEntChannelSendFlag((unsigned __int8)(pAlias->flags >> 10)) != SENDTYPE_NONE && (g_snd.reverbSetting[0].presetId || g_snd.reverbSetting[1].presetId) )
  {
    _RCX = 3 * v6;
    __asm { vmovaps [rsp+48h+var_18], xmm6 }
    _RAX = &g_snd;
    __asm { vxorps  xmm3, xmm3, xmm3 }
    if ( g_snd.reverbSetting[v6].presetId )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rax+rcx*4+7874h]
        vmulss  xmm2, xmm0, dword ptr [rdi+0A8h]
      }
    }
    else
    {
      __asm { vxorps  xmm2, xmm2, xmm2 }
    }
    if ( (_DWORD)v6 == 1 )
    {
      __asm { vmulss  xmm6, xmm2, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current; snd_local_t g_snd }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vsubss  xmm1, xmm0, cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current; snd_local_t g_snd
        vmulss  xmm6, xmm2, xmm1
      }
    }
    __asm { vcomiss xmm6, xmm3 }
    if ( !(_DWORD)v6 )
      goto LABEL_18;
    __asm { vcomiss xmm6, cs:__real@43800000 }
    if ( (unsigned int)v6 > 1 )
    {
LABEL_18:
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vmovsd  [rsp+48h+var_20], xmm0
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12106, ASSERT_TYPE_ASSERT, "( ( wetLevel >= 0 && wetLevel <= 256 ) )", "( wetLevel ) = %g", v20) )
        __debugbreak();
    }
    __asm
    {
      vmovaps xmm0, xmm6
      vmovaps xmm6, [rsp+48h+var_18]
    }
  }
  else
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_GetWhizbyData
==============
*/
bool SND_GetWhizbyData(const LocalClientNum_t localClientNum, const WeaponSFXPackage *sfxPackage, const vec3_t *inSndCenterPt, const vec3_t *inBulletDir, const float shooterDist, const bool isBallistic, const float ballisticTimeSecToTarget, float radius, SndWhizbyData *outWhizbyData)
{
  bool result; 
  char v31; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm12
  }
  *(_OWORD *)outWhizbyData->whizbySndInPos.v = 0ui64;
  *(_QWORD *)&outWhizbyData->whizbySndOutPos.y = 0i64;
  outWhizbyData->whizbyInAlias = NULL;
  outWhizbyData->whizbyOutAlias = NULL;
  outWhizbyData->whizbyCrackAlias = NULL;
  *(_QWORD *)&outWhizbyData->whizbyDelayMs = 0i64;
  if ( SND_GetWhizby(sfxPackage) )
  {
    __asm
    {
      vmovss  xmm8, [rsp+168h+shooterDist]
      vcomiss xmm8, dword ptr [rax+68h]
      vmovss  xmm0, [rsp+168h+radius]
      vmaxss  xmm7, xmm0, cs:__real@3f800000
      vmovss  xmm0, dword ptr [rax+44h]
      vcomiss xmm7, xmm0
      vxorps  xmm6, xmm6, xmm6
      vcomiss xmm7, dword ptr [rax+48h]
      vcomiss xmm7, dword ptr [rax+4Ch]
    }
  }
  else if ( sfxPackage )
  {
    Com_Printf(9, "Couldn't find sound whizby type for WeaponSFXPackage: %s\n", sfxPackage->name);
  }
  result = 0;
  _R11 = &v31;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
  return result;
}

/*
==============
SND_HasFreeVoice
==============
*/
bool SND_HasFreeVoice(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2031, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2032, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  if ( g_snd.globals->entchannelInfo[v1].maxVoices <= 0 )
  {
    LODWORD(v3) = g_snd.globals->entchannelInfo[v1].maxVoices;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2033, ASSERT_TYPE_ASSERT, "( ( g_snd.globals->entchannelInfo[entchannel].maxVoices > 0 ) )", "( g_snd.globals->entchannelInfo[entchannel].maxVoices ) = %i", v3) )
      __debugbreak();
  }
  return g_snd.entchanvoicecount[v1] < g_snd.globals->entchannelInfo[v1].maxVoices;
}

/*
==============
SND_Init
==============
*/
void SND_Init()
{
  int v2; 
  unsigned int v3; 
  const char *v4; 
  char v5; 
  char v6; 
  const char *v7; 
  char v8; 
  unsigned int v9; 
  char v10; 
  const char *v11; 
  char v12; 
  unsigned int v13; 
  char v14; 
  const char *v15; 
  char v16; 
  unsigned int v17; 
  char v18; 
  const char *v19; 
  char v20; 
  unsigned int v21; 
  char v22; 
  const char *v23; 
  char v24; 
  unsigned int v25; 
  char v26; 
  unsigned int v27; 
  char v28; 
  const char *v29; 
  char v30; 
  snd_listener *listeners; 
  __int64 v33; 
  unsigned int v34; 
  float *p_wetlevel; 
  unsigned int v36; 
  const SndGlobals *globals; 
  snd_volmod_info_t *volmodinfo; 
  unsigned int v40; 
  __int64 v41; 
  __int64 v42; 
  unsigned int v43; 
  __int64 v44; 
  char *v45; 
  int v46; 
  const dvar_t *v47; 
  unsigned int v51; 
  __int64 v52; 
  float *timescaleLerp; 
  __int64 v54; 
  const SndGlobals *v55; 
  unsigned int v56; 
  unsigned int v57; 
  int *p_playTime; 
  SndVirtualLoop *virtualLoops; 
  float *p_freq; 
  __int64 v61; 
  __int64 v62; 
  float *p_hpfCutoff; 
  SndDspSourceParams *p_dspParams; 
  __int64 v65; 
  const char *v66; 
  char v67; 
  char v68; 
  unsigned int volmodinfoCount; 
  unsigned int *p_id; 
  __int64 v73; 
  __int64 v74; 

  v2 = 5381;
  __asm { vmovaps [rsp+88h+var_38], xmm6 }
  v3 = 5381;
  __asm { vmovaps [rsp+88h+var_48], xmm7 }
  g_snd.magic = 591763574;
  v4 = "default";
  v5 = 100;
  do
  {
    ++v4;
    v6 = v5 | 0x20;
    if ( (unsigned int)(v5 - 65) >= 0x1A )
      v6 = v5;
    v3 = 65599 * v3 + v6;
    v5 = *v4;
  }
  while ( *v4 );
  v7 = "log_slow";
  v8 = 108;
  if ( !v3 )
    v3 = 1;
  g_snd.defaultHash = v3;
  v9 = 5381;
  do
  {
    ++v7;
    v10 = v8 | 0x20;
    if ( (unsigned int)(v8 - 65) >= 0x1A )
      v10 = v8;
    v9 = 65599 * v9 + v10;
    v8 = *v7;
  }
  while ( *v7 );
  v11 = "log_fast";
  v12 = 108;
  if ( !v9 )
    v9 = 1;
  g_snd.logSlowHash = v9;
  v13 = 5381;
  do
  {
    ++v11;
    v14 = v12 | 0x20;
    if ( (unsigned int)(v12 - 65) >= 0x1A )
      v14 = v12;
    v13 = 65599 * v13 + v14;
    v12 = *v11;
  }
  while ( *v11 );
  v15 = "flat_ended";
  v16 = 102;
  if ( !v13 )
    v13 = 1;
  g_snd.logFastHash = v13;
  v17 = 5381;
  do
  {
    ++v15;
    v18 = v16 | 0x20;
    if ( (unsigned int)(v16 - 65) >= 0x1A )
      v18 = v16;
    v17 = 65599 * v17 + v18;
    v16 = *v15;
  }
  while ( *v15 );
  v19 = "flat_middle";
  v20 = 102;
  if ( !v17 )
    v17 = 1;
  g_snd.flatEndedHash = v17;
  v21 = 5381;
  do
  {
    ++v19;
    v22 = v20 | 0x20;
    if ( (unsigned int)(v20 - 65) >= 0x1A )
      v22 = v20;
    v21 = 65599 * v21 + v22;
    v20 = *v19;
  }
  while ( *v19 );
  v23 = "cinematic";
  v24 = 99;
  if ( !v21 )
    v21 = 1;
  g_snd.flatMiddleHash = v21;
  v25 = 5381;
  do
  {
    ++v23;
    v26 = v24 | 0x20;
    if ( (unsigned int)(v24 - 65) >= 0x1A )
      v26 = v24;
    v25 = 65599 * v25 + v26;
    v24 = *v23;
  }
  while ( *v23 );
  v27 = 5381;
  v28 = 97;
  if ( !v25 )
    v25 = 1;
  g_snd.cinematicAssetId = v25;
  v29 = "arcade";
  do
  {
    ++v29;
    v30 = v28 | 0x20;
    if ( (unsigned int)(v28 - 65) >= 0x1A )
      v30 = v28;
    v27 = 65599 * v27 + v30;
    v28 = *v29;
  }
  while ( *v29 );
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( !v27 )
    v27 = 1;
  *(_QWORD *)&g_snd.cinematicAssetEntry.seekTableSize = 0x7FFFFFFF00000000i64;
  *(unsigned __int64 *)((char *)&g_snd.cinematicAssetEntry.offset + 4) = 0xBB8000000000i64;
  *(_QWORD *)&g_snd.cinematicAssetEntry.channelCount = 2i64;
  *(_QWORD *)&g_snd.arcadeAssetEntry.seekTableSize = 0x7FFFFFFF00000000i64;
  *(unsigned __int64 *)((char *)&g_snd.arcadeAssetEntry.offset + 4) = 0xBB8000000000i64;
  __asm
  {
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.masterPercentage, xmm6; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.masterPriorityVal, xmm6; snd_local_t g_snd
  }
  g_snd.arcadeAssetId = v27;
  *(_QWORD *)&g_snd.cinematicAssetEntry.id = 0i64;
  *(_QWORD *)&g_snd.cinematicAssetEntry.hybridPcmSize = 0i64;
  *(_DWORD *)&g_snd.cinematicAssetEntry.EnvelopeLoudness1 = 0;
  *(_QWORD *)&g_snd.arcadeAssetEntry.id = 0i64;
  *(_QWORD *)&g_snd.arcadeAssetEntry.hybridPcmSize = 0i64;
  *(_DWORD *)&g_snd.arcadeAssetEntry.EnvelopeLoudness1 = 0;
  *(_QWORD *)&g_snd.arcadeAssetEntry.channelCount = 1i64;
  g_snd.masterPriorityID = 0;
  Com_Printf(9, "\n------- sound system initialization -------\n");
  *(_WORD *)&g_snd.muted = 0;
  SND_RegisterDvars();
  listeners = g_snd.listeners;
  v33 = 2i64;
  do
  {
    memset_0(listeners, 0, sizeof(snd_listener));
    MatrixIdentity33(&listeners->orient.axis);
    OrientationInvert(&listeners->orient, &listeners->inverse);
    ++listeners;
    --v33;
  }
  while ( v33 );
  v34 = 0;
  p_wetlevel = &g_snd.reverbSetting[0].wetlevel;
  v36 = 0;
  do
  {
    v36 += 2;
    *(_QWORD *)(p_wetlevel - 1) = 0i64;
    *(p_wetlevel - 2) = 0.0;
    *((_QWORD *)p_wetlevel + 1) = 0i64;
    p_wetlevel[1] = 0.0;
    p_wetlevel += 6;
  }
  while ( v36 < 2 );
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.value, xmm7; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalvalue, xmm7; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalrate, xmm7; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm6; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm6; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalfraction, xmm6; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalgain, xmm6; snd_local_t g_snd
  }
  g_snd.activeMainReverb = RVB_MAIN_A;
  SND_InitEntityParamInfo();
  globals = g_snd.globals;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 9469, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  if ( !globals->volmodinfo )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 9470, ASSERT_TYPE_ASSERT, "(g_snd.globals->volmodinfo)", (const char *)&queryFormat, "g_snd.globals->volmodinfo") )
      __debugbreak();
    globals = g_snd.globals;
  }
  if ( !globals->volmodinfoCount )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 9471, ASSERT_TYPE_ASSERT, "(g_snd.globals->volmodinfoCount > 0)", (const char *)&queryFormat, "g_snd.globals->volmodinfoCount > 0") )
      __debugbreak();
    globals = g_snd.globals;
  }
  volmodinfo = globals->volmodinfo;
  v40 = 0;
  if ( globals->volmodinfoCount )
  {
    do
    {
      v41 = v40++;
      v42 = v41;
      g_snd.volmods[v42].value = volmodinfo[v41].value;
      g_snd.volmods[v42].goalvalue = volmodinfo[v41].value;
      g_snd.volmods[v42].goalrate = 0.0;
      globals = g_snd.globals;
    }
    while ( v40 < g_snd.globals->volmodinfoCount );
  }
  g_snd.playbackIdCounter = 1;
  v43 = 0;
  g_snd.stopSoundsAfterMasterFade = 0;
  __asm
  {
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mastervol.value, xmm7; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mastervol.goalvalue, xmm7; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mastervol.goalrate, xmm7; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mastervol.goalfraction, xmm6; snd_local_t g_snd
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mastervol.goalgain, xmm6; snd_local_t g_snd
  }
  g_snd.currentChannelPriority = 0;
  while ( globals && v43 < globals->entchannelCount )
  {
    v44 = v43;
    if ( (snd_local_t *)((char *)&g_snd + v44 * 24) == (snd_local_t *)-80i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
      __debugbreak();
    g_snd.levelFadeInChannelVols.channelvol[v44].value = 1.0;
    g_snd.levelFadeInChannelVols.channelvol[v44].goalvalue = 1.0;
    *(_QWORD *)&g_snd.levelFadeInChannelVols.channelvol[v44].goalrate = 1065353216i64;
    g_snd.levelFadeInChannelVols.channelvol[v44].goalgain = 0.0;
    v45 = (char *)&g_snd.channelPriorityVolGroups[g_snd.currentChannelPriority] + v44 * 24;
    if ( !v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
      __debugbreak();
    *(_DWORD *)v45 = 1065353216;
    ++v43;
    *((_DWORD *)v45 + 1) = 1065353216;
    *((_QWORD *)v45 + 1) = 1065353216i64;
    *((_DWORD *)v45 + 4) = 0;
    globals = g_snd.globals;
  }
  g_snd.levelFadeInChannelVols.active = 1;
  g_snd.channelPriorityVolGroups[g_snd.currentChannelPriority].active = 1;
  v46 = Sys_Milliseconds();
  v47 = DVARBOOL_snd_volume_mute;
  g_snd.time = v46;
  g_snd.looptime = v46;
  if ( !DVARBOOL_snd_volume_mute && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_volume_mute") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v47);
  if ( v47->current.enabled )
  {
    __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.volume, xmm6; snd_local_t g_snd }
  }
  else
  {
    _RDI = DVARFLT_profileMenuOption_volume;
    if ( !DVARFLT_profileMenuOption_volume && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "profileMenuOption_volume") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm0, xmm0, dword ptr [rax+8]
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.volume, xmm0; snd_local_t g_snd
    }
  }
  g_snd.listenerFence = 0;
  v51 = 0;
  g_sndEntityParamFence = 0;
  do
  {
    v52 = (int)v51++;
    g_snd.voiceBusyUpdating[v52] = 0;
  }
  while ( v51 < 0x63 );
  timescaleLerp = g_snd.entchanOverrides.timescaleLerp;
  v54 = 16i64;
  do
  {
    *(_QWORD *)timescaleLerp = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp + 1) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp + 2) = 0x3F8000003F800000i64;
    timescaleLerp += 16;
    *((_QWORD *)timescaleLerp - 5) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 4) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 3) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 2) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 1) = 0x3F8000003F800000i64;
    --v54;
  }
  while ( v54 );
  v55 = g_snd.globals;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6064, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    v55 = g_snd.globals;
  }
  *(_QWORD *)g_snd.entchanOverrides.isPausable = -1i64;
  v56 = 0;
  *(_QWORD *)&g_snd.entchanOverrides.isPausable[2] = -1i64;
  *(_QWORD *)&g_snd.entchanOverrides.isPausable[4] = -1i64;
  for ( *(_QWORD *)&g_snd.entchanOverrides.isPausable[6] = -1i64; v56 < v55->entchannelCount; ++v56 )
  {
    if ( !v55->entchannelInfo[v56].isPausable )
    {
      if ( v56 >= 0x100 )
      {
        LODWORD(v74) = 256;
        LODWORD(v73) = v56;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 30, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v73, v74) )
          __debugbreak();
      }
      g_snd.entchanOverrides.isPausable[(__int64)(int)v56 >> 5] &= ~(1 << (v56 & 0x1F));
      v55 = g_snd.globals;
    }
  }
  Cmd_AddCommandInternal("snd_playLocal", SND_PlayLocal_f, &SND_PlayLocal_f_VAR);
  Cmd_AddCommandInternal("snd_setEq", SND_SetEq_f, &SND_SetEq_f_VAR);
  Cmd_AddCommandInternal("snd_setEqFreq", SND_SetEqFreq_f, &SND_SetEqFreq_f_VAR);
  Cmd_AddCommandInternal("snd_setEqGain", SND_SetEqGain_f, &SND_SetEqGain_f_VAR);
  Cmd_AddCommandInternal("snd_setEqQ", SND_SetEqQ_f, &SND_SetEqQ_f_VAR);
  Cmd_AddCommandInternal("snd_setEqType", SND_SetEqType_f, &SND_SetEqType_f_VAR);
  Cmd_AddCommandInternal("snd_deactivateEq", SND_DeactivateEq_f, &SND_DeactivateEq_f_VAR);
  snd_drawOnlyChannel = -1;
  Cmd_AddCommandInternal("snd_soloChannel", SND_SoloChannel_f, &SND_SoloChannel_f_VAR);
  Cmd_AddCommandInternal("snd_clearSoloChannel", SND_ClearSoloChannel_f, &SND_ClearSoloChannel_f_VAR);
  Cmd_AddCommandInternal("snd_drawOnlyChannel", SND_DrawOnlyChannel_f, &SND_DrawOnlyChannel_f_VAR);
  Cmd_AddCommandInternal("snd_clearDrawOnlyChannel", SND_ClearDrawOnlyChannel_f, &SND_ClearDrawOnlyChannel_f_VAR);
  Cmd_AddCommandInternal("snd_dumpTimeScaleSettings", SND_DumpTimeScale_f, &SND_DumpTimeScale_f_VAR);
  Cmd_AddCommandInternal("snd_dumpGlobals", SND_DumpGlobals_f, &SND_DumpGlobals_f_VAR);
  Cmd_AddCommandInternal("snd_RecalcPropagation", SND_RecalcPropagation_f, &SND_RecalcPropagation_f_VAR);
  g_snd.doPropagationRecalc = 0;
  Cmd_AddCommandInternal("snd_setAliasValue", SND_SetAliasValue_f, &SND_SetAliasValue_f_VAR);
  g_snd.ambient_track = 0;
  SND_InitDolbyPanners();
  v57 = 0;
  p_playTime = &g_ambGlob[0].playTime;
  do
  {
    v57 += 2;
    *(_QWORD *)(p_playTime - 1) = 0i64;
    p_playTime[1] = 0;
    *((_BYTE *)p_playTime + 8) = 0;
    *(_QWORD *)(p_playTime + 3) = 0i64;
    *(_QWORD *)(p_playTime + 7) = 0i64;
    *(_QWORD *)(p_playTime + 5) = 0i64;
    p_playTime[9] = 0;
    *(_QWORD *)(p_playTime + 11) = 0i64;
    p_playTime[13] = 0;
    *((_BYTE *)p_playTime + 56) = 0;
    *(_QWORD *)(p_playTime + 15) = 0i64;
    *(_QWORD *)(p_playTime + 19) = 0i64;
    *(_QWORD *)(p_playTime + 17) = 0i64;
    p_playTime[21] = 0;
    p_playTime += 24;
  }
  while ( v57 < 2 );
  g_snd.nextVirtualLoopHandle = 0;
  virtualLoops = g_snd.virtualLoops;
  do
  {
    virtualLoops->handle = -1;
    ++virtualLoops;
  }
  while ( (__int64)virtualLoops < (__int64)&g_snd.nextVirtualLoopHandle );
  SND_InitWeaponRelection();
  SND_InitGlobalContexts();
  SND_DspInit();
  s_FXPlaySoundCount = 0;
  s_FXPlaySoundHead = 0;
  g_snd.numFullOcclusionCache = 0;
  SND_ClearAllOcclusionSettings();
  *(_QWORD *)g_snd.entChanFullOcclusionDisabled = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[2] = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[4] = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[6] = 0i64;
  CG_ClearAudioZoneCache();
  SND_SubmixInit();
  SND_BankDetailStreaming_Init();
  if ( !g_snd.driverInitialized )
  {
    SND_ClearReverbs();
    g_snd.playback_channels = 16;
    SD_Init();
    p_freq = &sdGlob.eqParams[0][0][0].freq;
    g_snd.playback_rate = 0x7FFFFFFF;
    __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.timescale, xmm7; snd_local_t g_snd }
    do
    {
      v61 = 2i64;
      do
      {
        v62 = 256i64;
        do
        {
          *((_BYTE *)p_freq + 8) = 0;
          *p_freq = 24000.0;
          *(p_freq - 1) = 1.0;
          p_freq[1] = 1.0;
          *(p_freq - 2) = 0.0;
          p_freq += 5;
          --v62;
        }
        while ( v62 );
        --v61;
      }
      while ( v61 );
    }
    while ( (__int64)p_freq < (__int64)&sdGlob.voiceParams[0].sendType );
    p_hpfCutoff = &sdGlob.voiceParams[0].dspParams.hpfCutoff;
    p_dspParams = &sdGlob.voiceParams[0].dspParams;
    v65 = 99i64;
    do
    {
      SND_InitEQBankParams(&p_dspParams->eqBankParams);
      p_dspParams = (SndDspSourceParams *)((char *)p_dspParams + 260);
      *(p_hpfCutoff - 1) = -1.0;
      *p_hpfCutoff = -1.0;
      p_hpfCutoff += 65;
      --v65;
    }
    while ( v65 );
    SND_DevhostInit();
    if ( g_snd.globals )
      SND_ParseInit(g_snd.globals);
    g_snd.driverInitialized = 1;
  }
  SND_LoadSoundsWait(1);
  v66 = "voiceover_plr";
  g_snd.playerVoiceVolmodIndex = -1;
  v67 = 118;
  do
  {
    ++v66;
    v68 = v67 | 0x20;
    if ( (unsigned int)(v67 - 65) >= 0x1A )
      v68 = v67;
    v2 = 65599 * v2 + v68;
    v67 = *v66;
  }
  while ( *v66 );
  if ( !v2 )
    v2 = 1;
  volmodinfoCount = g_snd.globals->volmodinfoCount;
  if ( !volmodinfoCount )
    goto LABEL_123;
  p_id = &g_snd.globals->volmodinfo->id;
  while ( *p_id != v2 )
  {
    ++v34;
    p_id += 18;
    if ( v34 >= volmodinfoCount )
      goto LABEL_123;
  }
  g_snd.playerVoiceVolmodIndex = v34;
  if ( v34 == -1 )
LABEL_123:
    Com_PrintError(9, "Did not find the 'voiceover_plr' volmod for muting player dialogue\n");
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_38]
    vmovaps xmm7, [rsp+88h+var_48]
  }
  Com_Printf(9, "------- sound system successfully initialized -------\n");
}

/*
==============
SND_InitAliasGroupTracking
==============
*/
void SND_InitAliasGroupTracking(SndAliasGroupTracking *inOutTracking)
{
  unsigned int secondaryGroupCounter; 

  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  *(_QWORD *)&inOutTracking->numVoices = 0i64;
  secondaryGroupCounter = g_snd.secondaryGroupCounter;
  do
    ++secondaryGroupCounter;
  while ( !secondaryGroupCounter );
  g_snd.secondaryGroupCounter = secondaryGroupCounter;
  inOutTracking->secondaryGroupId = secondaryGroupCounter;
  inOutTracking->hasSetPlayerBreathDialogueAlias = 0;
}

/*
==============
SND_InitDriver
==============
*/
char SND_InitDriver()
{
  float *p_freq; 
  __int64 v2; 
  __int64 v3; 
  float *p_hpfCutoff; 
  SndDspSourceParams *p_dspParams; 
  __int64 v6; 

  if ( !g_snd.driverInitialized )
  {
    SND_ClearReverbs();
    g_snd.playback_channels = 16;
    SD_Init();
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.timescale, xmm0; snd_local_t g_snd
    }
    g_snd.playback_rate = 0x7FFFFFFF;
    p_freq = &sdGlob.eqParams[0][0][0].freq;
    do
    {
      v2 = 2i64;
      do
      {
        v3 = 256i64;
        do
        {
          *((_BYTE *)p_freq + 8) = 0;
          *p_freq = 24000.0;
          *(p_freq - 1) = 1.0;
          p_freq[1] = 1.0;
          *(p_freq - 2) = 0.0;
          p_freq += 5;
          --v3;
        }
        while ( v3 );
        --v2;
      }
      while ( v2 );
    }
    while ( (__int64)p_freq < (__int64)&sdGlob.voiceParams[0].sendType );
    p_hpfCutoff = &sdGlob.voiceParams[0].dspParams.hpfCutoff;
    p_dspParams = &sdGlob.voiceParams[0].dspParams;
    v6 = 99i64;
    do
    {
      SND_InitEQBankParams(&p_dspParams->eqBankParams);
      p_dspParams = (SndDspSourceParams *)((char *)p_dspParams + 260);
      *(p_hpfCutoff - 1) = -1.0;
      *p_hpfCutoff = -1.0;
      p_hpfCutoff += 65;
      --v6;
    }
    while ( v6 );
    SND_DevhostInit();
    if ( g_snd.globals )
      SND_ParseInit(g_snd.globals);
    g_snd.driverInitialized = 1;
  }
  return 1;
}

/*
==============
SND_InitEntityParamInfo
==============
*/
__int64 SND_InitEntityParamInfo()
{
  float *p_goalrate; 
  int v1; 
  bool v2; 
  unsigned int v3; 
  EntParamIdxHashBucket *v4; 
  __int64 v5; 
  __int64 result; 
  unsigned __int16 *v7; 
  __int64 v8; 
  __int64 v9; 

  p_goalrate = &g_sndEntityParamInfo[0].pitch.goalrate;
  v1 = 0;
  v2 = 1;
  do
  {
    if ( !v2 )
    {
      LODWORD(v9) = 64;
      LODWORD(v8) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1797, ASSERT_TYPE_ASSERT, "(unsigned)( paramInfoIndex ) < (unsigned)( 64 )", "paramInfoIndex doesn't index SND_MAX_PARAM_INFO\n\t%i not in [0, %i)", v8, v9) )
        __debugbreak();
    }
    if ( p_goalrate == (float *)8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
      __debugbreak();
    *(p_goalrate - 2) = 1.0;
    *(p_goalrate - 1) = 1.0;
    *(_QWORD *)p_goalrate = 1065353216i64;
    p_goalrate[2] = 0.0;
    if ( p_goalrate == (float *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
      __debugbreak();
    p_goalrate[5] = 1.0;
    ++v1;
    *((_QWORD *)p_goalrate + 3) = 1065353216i64;
    p_goalrate[8] = 0.0;
    p_goalrate[4] = 1.0;
    *(p_goalrate - 3) = NAN;
    p_goalrate += 13;
    v2 = (unsigned int)v1 < 0x40;
  }
  while ( v1 < 64 );
  v3 = 0;
  v4 = &g_sndEntityParamIndex[1];
  do
  {
    v3 += 64;
    v4[-1] = (EntParamIdxHashBucket)0x7FFFFFF;
    *v4 = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[1] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[2] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[3] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[4] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[5] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[6] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[7] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[8] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[9] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[10] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[11] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[12] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[13] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[14] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[15] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[16] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[17] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[18] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[19] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[20] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[21] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[22] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[23] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[24] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[25] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[26] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[27] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[28] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[29] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[30] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[31] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[32] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[33] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[34] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[35] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[36] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[37] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[38] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[39] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[40] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[41] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[42] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[43] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[44] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[45] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[46] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[47] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[48] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[49] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[50] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[51] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[52] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[53] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[54] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[55] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[56] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[57] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[58] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[59] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[60] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[61] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4[62] = (EntParamIdxHashBucket)0x7FFFFFF;
    v4 += 64;
  }
  while ( v3 < 0x40 );
  v5 = 64i64;
  result = 2047i64;
  v7 = g_sndSVEntityParamSet;
  while ( v5 )
  {
    *v7++ = 2047;
    --v5;
  }
  return result;
}

/*
==============
SND_InitEntityParamInfoEntry
==============
*/
EntityParamInfo *SND_InitEntityParamInfoEntry(unsigned int paramInfoIndex, unsigned int entIndex)
{
  __int64 v2; 
  EntityParamInfo *v5; 
  EntityParamInfo *result; 
  __int64 v8; 
  int v10; 

  v2 = paramInfoIndex;
  if ( paramInfoIndex >= 0x40 )
  {
    v10 = 64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1797, ASSERT_TYPE_ASSERT, "(unsigned)( paramInfoIndex ) < (unsigned)( 64 )", "paramInfoIndex doesn't index SND_MAX_PARAM_INFO\n\t%i not in [0, %i)", paramInfoIndex, v10) )
      __debugbreak();
  }
  if ( entIndex >= 0x7B6E3 && entIndex != 0x7FFFFFFF )
  {
    LODWORD(v8) = entIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1798, ASSERT_TYPE_ASSERT, "( ( entIndex < ( ( ( 2048 ) ) + ( 1 ) + ( 1024 ) + ( 128 ) + ( 128 ) + 1024 + ( 2 ) + ( 32 ) + ( 1024 ) + ( 32 ) + ( 128 ) + ( 500000 ) ) || entIndex == 2147483647 ) )", "( entIndex ) = %i", v8) )
      __debugbreak();
  }
  __asm { vmovss  xmm1, cs:__real@3f800000; initValue }
  v5 = &g_sndEntityParamInfo[v2];
  SND_InitParameter(&v5->pitch, *(float *)&_XMM1);
  __asm { vmovss  xmm1, cs:__real@3f800000; initValue }
  SND_InitParameter(&v5->volume, *(float *)&_XMM1);
  result = v5;
  v5->entIndex = entIndex;
  return result;
}

/*
==============
SND_InitFXSounds
==============
*/
void SND_InitFXSounds(void)
{
  s_FXPlaySoundCount = 0;
  s_FXPlaySoundHead = 0;
}

/*
==============
SND_InitFullOcclusionFlags
==============
*/
void SND_InitFullOcclusionFlags(void)
{
  *(_QWORD *)g_snd.entChanFullOcclusionDisabled = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[2] = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[4] = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[6] = 0i64;
}

/*
==============
SND_InitGlobalContexts
==============
*/
void SND_InitGlobalContexts(void)
{
  unsigned int *v0; 
  float *p_rateMS; 
  unsigned int v2; 
  const char *v3; 
  int v4; 
  char v5; 
  char v6; 
  const char *v7; 
  char v8; 
  char v9; 
  int ContextIndex; 

  v0 = &g_snd.globalContextsTo[1];
  p_rateMS = &g_snd.globalContextLerp[2].rateMS;
  do
  {
    *(v0 - 65) = 0;
    *(v0 - 1) = 0;
    *(_QWORD *)(p_rateMS - 5) = 0i64;
    *(v0 - 64) = 0;
    *v0 = 0;
    *(_QWORD *)(p_rateMS - 3) = 0i64;
    *(v0 - 63) = 0;
    v0[1] = 0;
    *(_QWORD *)(p_rateMS - 1) = 0i64;
    *(v0 - 62) = 0;
    v0[2] = 0;
    *(_QWORD *)(p_rateMS + 1) = 0i64;
    *(v0 - 61) = 0;
    v0[3] = 0;
    *(_QWORD *)(p_rateMS + 3) = 0i64;
    *(v0 - 60) = 0;
    v0[4] = 0;
    *(_QWORD *)(p_rateMS + 5) = 0i64;
    *(v0 - 59) = 0;
    v0[5] = 0;
    *(_QWORD *)(p_rateMS + 7) = 0i64;
    *(v0 - 58) = 0;
    v0[6] = 0;
    *(_QWORD *)(p_rateMS + 9) = 0i64;
    *(v0 - 57) = 0;
    v0[7] = 0;
    *(_QWORD *)(p_rateMS + 11) = 0i64;
    *(v0 - 56) = 0;
    v0[8] = 0;
    *(_QWORD *)(p_rateMS + 13) = 0i64;
    *(v0 - 55) = 0;
    v0[9] = 0;
    *(_QWORD *)(p_rateMS + 15) = 0i64;
    *(v0 - 54) = 0;
    v0[10] = 0;
    *(_QWORD *)(p_rateMS + 17) = 0i64;
    *(v0 - 53) = 0;
    v0[11] = 0;
    *(_QWORD *)(p_rateMS + 19) = 0i64;
    *(v0 - 52) = 0;
    v0[12] = 0;
    *(_QWORD *)(p_rateMS + 21) = 0i64;
    *(v0 - 51) = 0;
    v0[13] = 0;
    *(_QWORD *)(p_rateMS + 23) = 0i64;
    *(v0 - 50) = 0;
    v0[14] = 0;
    *(_QWORD *)(p_rateMS + 25) = 0i64;
    *(v0 - 49) = 0;
    v0[15] = 0;
    *(_QWORD *)(p_rateMS + 27) = 0i64;
    *(v0 - 48) = 0;
    v0[16] = 0;
    *(_QWORD *)(p_rateMS + 29) = 0i64;
    *(v0 - 47) = 0;
    v0[17] = 0;
    *(_QWORD *)(p_rateMS + 31) = 0i64;
    *(v0 - 46) = 0;
    v0[18] = 0;
    *(_QWORD *)(p_rateMS + 33) = 0i64;
    *(v0 - 45) = 0;
    v0[19] = 0;
    *(_QWORD *)(p_rateMS + 35) = 0i64;
    *(v0 - 44) = 0;
    v0[20] = 0;
    *(_QWORD *)(p_rateMS + 37) = 0i64;
    *(v0 - 43) = 0;
    v0[21] = 0;
    *(_QWORD *)(p_rateMS + 39) = 0i64;
    *(v0 - 42) = 0;
    v0[22] = 0;
    *(_QWORD *)(p_rateMS + 41) = 0i64;
    *(v0 - 41) = 0;
    v0[23] = 0;
    *(_QWORD *)(p_rateMS + 43) = 0i64;
    *(v0 - 40) = 0;
    v0[24] = 0;
    *(_QWORD *)(p_rateMS + 45) = 0i64;
    *(v0 - 39) = 0;
    v0[25] = 0;
    *(_QWORD *)(p_rateMS + 47) = 0i64;
    *(v0 - 38) = 0;
    v0[26] = 0;
    v0 += 32;
    *(_QWORD *)(p_rateMS + 49) = 0i64;
    *(v0 - 69) = 0;
    *(v0 - 5) = 0;
    *(_QWORD *)(p_rateMS + 51) = 0i64;
    *(v0 - 68) = 0;
    *(v0 - 4) = 0;
    *(_QWORD *)(p_rateMS + 53) = 0i64;
    *(v0 - 67) = 0;
    *(v0 - 3) = 0;
    *(_QWORD *)(p_rateMS + 55) = 0i64;
    *(v0 - 66) = 0;
    *(v0 - 2) = 0;
    *(_QWORD *)(p_rateMS + 57) = 0i64;
    p_rateMS += 64;
  }
  while ( (__int64)p_rateMS < (__int64)&g_snd.entState[0].contextValuesFrom[1] );
  v2 = 5381;
  v3 = "explicit";
  v4 = 5381;
  v5 = 101;
  do
  {
    ++v3;
    v6 = v5 | 0x20;
    if ( (unsigned int)(v5 - 65) >= 0x1A )
      v6 = v5;
    v4 = 65599 * v4 + v6;
    v5 = *v3;
  }
  while ( *v3 );
  v7 = "mature";
  v8 = 109;
  if ( !v4 )
    v4 = 1;
  do
  {
    ++v7;
    v9 = v8 | 0x20;
    if ( (unsigned int)(v8 - 65) >= 0x1A )
      v9 = v8;
    v2 = 65599 * v2 + v9;
    v8 = *v7;
  }
  while ( *v7 );
  if ( !v2 )
    v2 = 1;
  ContextIndex = SND_FindContextIndex(v2);
  if ( ContextIndex >= 0 )
  {
    g_snd.globalContextsFrom[ContextIndex] = g_snd.globalContextsTo[ContextIndex];
    g_snd.globalContextsTo[ContextIndex] = v4;
    g_snd.globalContextLerp[ContextIndex] = (TimeLerp)1065353216i64;
  }
}

/*
==============
SND_InitMemory
==============
*/
void SND_InitMemory(void)
{
  SD_AllocInit();
  SND_BankInit();
}

/*
==============
SND_InitParameter
==============
*/

void __fastcall SND_InitParameter(snd_param_info_t *paramInfo, double initValue)
{
  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  _RBX = paramInfo;
  __asm { vmovaps xmm6, xmm1 }
  if ( !paramInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
    __debugbreak();
  *(_QWORD *)&_RBX->goalrate = 1065353216i64;
  __asm
  {
    vmovss  dword ptr [rbx], xmm6
    vmovss  dword ptr [rbx+4], xmm6
    vmovaps xmm6, [rsp+48h+var_18]
  }
  _RBX->goalgain = 0.0;
}

/*
==============
SND_InitVirtualLoopingSounds
==============
*/
void SND_InitVirtualLoopingSounds(void)
{
  SndVirtualLoop *virtualLoops; 

  g_snd.nextVirtualLoopHandle = 0;
  virtualLoops = g_snd.virtualLoops;
  do
  {
    virtualLoops->handle = -1;
    ++virtualLoops;
  }
  while ( (__int64)virtualLoops < (__int64)&g_snd.nextVirtualLoopHandle );
}

/*
==============
SND_IsAliasPlayingOnTrack
==============
*/
_BOOL8 SND_IsAliasPlayingOnTrack(const char *aliasName, int track)
{
  __int64 v2; 
  __int64 v5; 

  v2 = track;
  if ( !aliasName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6313, ASSERT_TYPE_ASSERT, "(aliasName != 0)", (const char *)&queryFormat, "aliasName != NULL") )
    __debugbreak();
  if ( (v2 & 0xFFFFFFFD) != 0 )
  {
    LODWORD(v5) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6314, ASSERT_TYPE_ASSERT, "( ( track == SND_TRACK_AMBIENT_PRIMARY_0 || track == SND_TRACK_AMBIENT_PRIMARY_1 ) )", "( track ) = %i", v5) )
      __debugbreak();
  }
  if ( (unsigned int)(v2 + 80) > 0x62 )
  {
    LODWORD(v5) = v2 + 80;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v5) )
      __debugbreak();
  }
  return sdGlob.voiceAlloc[v2 + 80] && I_strcmp(**(const char ***)&g_snd.chaninfoUnweightedPriority[492 * v2 - 9320], aliasName) == 0;
}

/*
==============
SND_IsAliasSpatial
==============
*/
bool SND_IsAliasSpatial(const SndAlias *alias)
{
  return SND_IsEntChannel3D((unsigned __int8)(alias->flags >> 10));
}

/*
==============
SND_IsChannelMissionVOChannel
==============
*/
char SND_IsChannelMissionVOChannel(unsigned int entChannel)
{
  __int64 v1; 
  snd_entchannel_info_t *v2; 
  char v3; 
  int v4; 
  char v5; 
  int v6; 
  int v7; 
  const char **i; 
  const char *v9; 
  char v10; 
  int v11; 
  char v12; 
  __int64 v14; 

  v1 = entChannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16413, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v14) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16414, ASSERT_TYPE_ASSERT, "( ( entChannel >= 0 && entChannel < g_snd.globals->entchannelCount ) )", "( entChannel ) = %i", v14) )
      __debugbreak();
  }
  v2 = &g_snd.globals->entchannelInfo[v1];
  if ( v2 && (v3 = v2->name[0]) != 0 )
  {
    v4 = 5381;
    do
    {
      v2 = (snd_entchannel_info_t *)((char *)v2 + 1);
      v5 = v3 | 0x20;
      if ( (unsigned int)(v3 - 65) >= 0x1A )
        v5 = v3;
      v6 = 65599 * v4 + v5;
      v3 = v2->name[0];
      v4 = v6;
    }
    while ( v2->name[0] );
    if ( !v6 )
      v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  v7 = 0;
  for ( i = s_missionVOChannelNames; ; ++i )
  {
    v9 = *i;
    if ( *i && (v10 = *v9) != 0 )
    {
      v11 = 5381;
      do
      {
        ++v9;
        v12 = v10 | 0x20;
        if ( (unsigned int)(v10 - 65) >= 0x1A )
          v12 = v10;
        v11 = 65599 * v11 + v12;
        v10 = *v9;
      }
      while ( *v9 );
      if ( !v11 )
        v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    if ( v4 == v11 )
      break;
    if ( (unsigned int)++v7 >= 7 )
      return 0;
  }
  return 1;
}

/*
==============
SND_IsChannelQuadAmbientChannel
==============
*/
bool SND_IsChannelQuadAmbientChannel(unsigned int entChannel)
{
  __int64 v1; 
  int v2; 
  snd_entchannel_info_t *v3; 
  char v4; 
  int v5; 
  char v6; 
  const char *v7; 
  char v8; 
  char v9; 
  __int64 v11; 

  v1 = entChannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16435, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v11) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16436, ASSERT_TYPE_ASSERT, "( ( entChannel >= 0 && entChannel < g_snd.globals->entchannelCount ) )", "( entChannel ) = %i", v11) )
      __debugbreak();
  }
  v2 = 5381;
  v3 = &g_snd.globals->entchannelInfo[v1];
  if ( v3 && (v4 = v3->name[0]) != 0 )
  {
    v5 = 5381;
    do
    {
      v3 = (snd_entchannel_info_t *)((char *)v3 + 1);
      v6 = v4 | 0x20;
      if ( (unsigned int)(v4 - 65) >= 0x1A )
        v6 = v4;
      v5 = 65599 * v5 + v6;
      v4 = v3->name[0];
    }
    while ( v3->name[0] );
    if ( !v5 )
      v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  v7 = S_QUAD_AMBIENCE_CHANNEL;
  if ( !S_QUAD_AMBIENCE_CHANNEL )
    return v5 == 0;
  v8 = *S_QUAD_AMBIENCE_CHANNEL;
  if ( !*S_QUAD_AMBIENCE_CHANNEL )
    return v5 == 0;
  do
  {
    ++v7;
    v9 = v8 | 0x20;
    if ( (unsigned int)(v8 - 65) >= 0x1A )
      v9 = v8;
    v2 = 65599 * v2 + v9;
    v8 = *v7;
  }
  while ( *v7 );
  if ( !v2 )
    v2 = 1;
  return v5 == v2;
}

/*
==============
SND_IsEntChannel3D
==============
*/
bool SND_IsEntChannel3D(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2083, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2084, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  return g_snd.globals->entchannelInfo[v1].spatialType != SND_ENTCHAN_TYPE_2D;
}

/*
==============
SND_IsEntChannelPASpeaker
==============
*/
bool SND_IsEntChannelPASpeaker(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2099, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2100, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  return g_snd.globals->entchannelInfo[v1].spatialType == SND_ENTCHAN_TYPE_PA_SPEAKER;
}

/*
==============
SND_IsEntChannelPlayerDialogue
==============
*/
_BOOL8 SND_IsEntChannelPlayerDialogue(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2107, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2108, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  return g_snd.globals->entchannelInfo[v1].isPlayerDialogue;
}

/*
==============
SND_IsListenerActive
==============
*/
_BOOL8 SND_IsListenerActive(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  unsigned __int64 v2; 
  bool active; 
  int v6; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v6 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2833, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v6) )
      __debugbreak();
  }
  v2 = (unsigned __int64)&g_snd.listenerFence & 3;
  do
  {
    if ( v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
  active = g_snd.listeners[v1].active;
  if ( v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
    __debugbreak();
  _InterlockedExchange(&g_snd.listenerFence, 0);
  return active;
}

/*
==============
SND_IsMuteAlias
==============
*/
bool SND_IsMuteAlias(const SndAlias *alias)
{
  const dvar_t *v2; 
  const char *string; 
  const dvar_t *v4; 
  const char *v5; 

  if ( !alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4143, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
    __debugbreak();
  v2 = DCONST_DVARSTR_snd_mute_alias;
  if ( !DCONST_DVARSTR_snd_mute_alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_mute_alias") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  string = v2->current.string;
  if ( string && *string && SND_ParseSoloMuteSubstring(string, alias->aliasName) )
    return 1;
  if ( (alias->flags & 0x380u) <= 0x100 )
  {
    if ( SND_IsEntChannel3D((unsigned __int8)(alias->flags >> 10)) )
    {
      v4 = DCONST_DVARBOOL_snd_mute_3D;
      if ( DCONST_DVARBOOL_snd_mute_3D )
        goto LABEL_20;
      v5 = "snd_mute_3D";
    }
    else
    {
      v4 = DCONST_DVARBOOL_snd_mute_2D;
      if ( DCONST_DVARBOOL_snd_mute_2D )
        goto LABEL_20;
      v5 = "snd_mute_2D";
    }
  }
  else
  {
    v4 = DCONST_DVARBOOL_snd_mute_stream;
    if ( DCONST_DVARBOOL_snd_mute_stream )
      goto LABEL_20;
    v5 = "snd_mute_stream";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v5) )
    __debugbreak();
LABEL_20:
  Dvar_CheckFrontendServerThread(v4);
  return v4->current.enabled;
}

/*
==============
SND_IsPausable
==============
*/
unsigned __int8 SND_IsPausable(unsigned int entchannel)
{
  __int64 v1; 
  unsigned int v2; 
  __int64 v4; 
  int v5; 

  v1 = (int)entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2180, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2181, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v4) )
      __debugbreak();
  }
  if ( (unsigned int)v1 >= 0x100 )
  {
    v5 = 256;
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 14, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v4, v5) )
      __debugbreak();
  }
  v2 = g_snd.entchanOverrides.isPausable[v1 >> 5];
  return _bittest((const int *)&v2, v1 & 0x1F);
}

/*
==============
SND_IsPlaybackIdPlaying
==============
*/
char SND_IsPlaybackIdPlaying(unsigned int id)
{
  unsigned int *p_playbackId; 

  if ( !id )
    return 0;
  p_playbackId = &g_snd.voices[0].playbackId;
  while ( *p_playbackId != id )
  {
    p_playbackId += 492;
    if ( (__int64)p_playbackId >= (__int64)&g_snd.chaninfoUnweightedPriority[7] )
      return 0;
  }
  return 1;
}

/*
==============
SND_IsRestricted
==============
*/
_BOOL8 SND_IsRestricted(unsigned int entchannel)
{
  __int64 v1; 
  __int64 v3; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2069, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2070, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v3) )
      __debugbreak();
  }
  return g_snd.globals->entchannelInfo[v1].isRestricted;
}

/*
==============
SND_IsScriptNotifySoundPlaying
==============
*/
char SND_IsScriptNotifySoundPlaying(int entNum, unsigned __int16 index)
{
  __int64 v3; 
  int v4; 
  bool *voiceAlloc; 
  unsigned __int16 *i; 
  __int64 v8; 

  v3 = entNum;
  v4 = 0;
  voiceAlloc = sdGlob.voiceAlloc;
  for ( i = &g_snd.voices[0].soundDoneSoundString; ; i += 984 )
  {
    if ( (*(_QWORD *)(i - 11) & 0x1FFFFFFFFi64) == v3 && index == *i )
    {
      if ( (unsigned int)v4 > 0x62 )
      {
        LODWORD(v8) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v8) )
          __debugbreak();
      }
      if ( *voiceAlloc )
        break;
    }
    ++v4;
    ++voiceAlloc;
    if ( v4 >= 99 )
      return 0;
  }
  return 1;
}

/*
==============
SND_IsVoice3D
==============
*/
bool SND_IsVoice3D(unsigned int voiceIndex)
{
  return SND_IsEntChannel3D((unsigned __int8)(*(int *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * voiceIndex - 48680] + 112i64) >> 10));
}

/*
==============
SND_IsVoiceFree
==============
*/
bool SND_IsVoiceFree(int index)
{
  __int64 v1; 

  v1 = index;
  if ( (unsigned int)index > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", index) )
    __debugbreak();
  return !sdGlob.voiceAlloc[v1];
}

/*
==============
SND_IsVoicePlaying
==============
*/
bool SND_IsVoicePlaying(unsigned int id)
{
  return SND_GetPlaybackVoice(id) != NULL;
}

/*
==============
SND_MyChanges
==============
*/
void SND_MyChanges(void)
{
  ;
}

/*
==============
SND_OccTraceSide
==============
*/
float SND_OccTraceSide(LocalClientNum_t localClientNum, const vec3_t *listener, const vec3_t *emitter, const vec3_t *direction, float spacing, int numTraces, unsigned int id)
{
  __int32 v16; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  __int64 v18; 
  int v31; 
  HavokPhysics_CollisionQueryResult *AnyResult; 
  bool HasHit; 
  float fmt; 
  Physics_RaycastExtendedData extendedData; 
  vec3_t start; 
  vec3_t end; 

  *(_QWORD *)start.v = direction;
  __asm { vxorps  xmm0, xmm0, xmm0 }
  if ( Physics_AreClientWorldsCreated() )
  {
    v16 = 3 * localClientNum + 2;
    __asm
    {
      vmovaps [rsp+108h+var_48], xmm6
      vmovaps [rsp+108h+var_58], xmm7
      vmovaps [rsp+108h+var_68], xmm8
      vmovaps [rsp+108h+var_78], xmm9
      vmovss  [rsp+108h+extendedData.collisionBuffer], xmm0
    }
    extendedData.ignoreBodies = NULL;
    extendedData.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
    extendedData.phaseSelection = All;
    extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
    *(_WORD *)&extendedData.collectInsideHits = 256;
    extendedData.contents = 2097169;
    ClosestResult = PhysicsQuery_GetClosestResult((Physics_WorldId)v16);
    if ( !ClosestResult && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11779, ASSERT_TYPE_ASSERT, "(closestResult)", (const char *)&queryFormat, "closestResult") )
      __debugbreak();
    HavokPhysics_CollisionQueryResult::Reset(ClosestResult, 1);
    v18 = (unsigned int)numTraces;
    __asm
    {
      vmovss  xmm7, [rsp+108h+spacing]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, esi
      vmulss  xmm2, xmm0, xmm7
      vmulss  xmm0, xmm2, dword ptr [rdi]
      vaddss  xmm1, xmm0, dword ptr [r13+0]
      vmulss  xmm0, xmm2, dword ptr [rdi+4]
      vmovss  dword ptr [rsp+108h+end], xmm1
      vaddss  xmm1, xmm0, dword ptr [r13+4]
      vmulss  xmm0, xmm2, dword ptr [rdi+8]
      vmovss  dword ptr [rsp+108h+end+4], xmm1
      vaddss  xmm1, xmm0, dword ptr [r13+8]
      vmovss  dword ptr [rsp+108h+end+8], xmm1
    }
    Physics_Raycast((Physics_WorldId)v16, listener, &end, &extendedData, ClosestResult);
    __asm { vmovss  xmm9, cs:__real@3f800000 }
    if ( HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
    {
      *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(ClosestResult, 0);
      __asm { vmovaps xmm6, xmm0 }
    }
    else
    {
      __asm { vmovaps xmm6, xmm9 }
    }
    v31 = 1;
    AnyResult = PhysicsQuery_GetAnyResult((Physics_WorldId)v16);
    if ( !AnyResult && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11805, ASSERT_TYPE_ASSERT, "(anyResult)", (const char *)&queryFormat, "anyResult") )
      __debugbreak();
    __asm
    {
      vmulss  xmm8, xmm6, xmm7
      vmovaps xmm7, xmm8
    }
    if ( numTraces > 0 )
    {
      do
      {
        __asm
        {
          vmulss  xmm0, xmm7, dword ptr [rbp+0]
          vaddss  xmm1, xmm0, dword ptr [r13+0]
          vmulss  xmm0, xmm7, dword ptr [rbp+4]
          vmovss  dword ptr [rsp+108h+start], xmm1
          vaddss  xmm1, xmm0, dword ptr [r13+4]
          vmulss  xmm0, xmm7, dword ptr [rbp+8]
          vmovss  dword ptr [rsp+108h+start+4], xmm1
          vaddss  xmm1, xmm0, dword ptr [r13+8]
          vmovss  dword ptr [rsp+108h+start+8], xmm1
        }
        HavokPhysics_CollisionQueryResult::Reset(AnyResult, 1);
        Physics_Raycast((Physics_WorldId)v16, &start, emitter, &extendedData, AnyResult);
        if ( HavokPhysics_CollisionQueryResult::HasHit(AnyResult) )
          ++v31;
        __asm { vaddss  xmm7, xmm7, xmm8 }
        if ( HavokPhysics_CollisionQueryResult::HasHit(AnyResult) )
        {
          *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(AnyResult, 0);
          __asm { vmovaps xmm6, xmm0 }
        }
        else
        {
          __asm { vmovaps xmm6, xmm9 }
        }
        HasHit = HavokPhysics_CollisionQueryResult::HasHit(AnyResult);
        __asm { vmovss  dword ptr [rsp+108h+fmt], xmm6 }
        SND_DebugAddOcclusionLine(&start, emitter, HasHit, id, fmt);
        --v18;
      }
      while ( v18 );
      if ( numTraces + 1 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11835, ASSERT_TYPE_ASSERT, "(totalCount > 0)", (const char *)&queryFormat, "totalCount > 0") )
        __debugbreak();
    }
    __asm
    {
      vmovaps xmm9, [rsp+108h+var_78]
      vmovaps xmm8, [rsp+108h+var_68]
      vmovaps xmm7, [rsp+108h+var_58]
      vmovaps xmm6, [rsp+108h+var_48]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, ebp
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, edi
      vdivss  xmm0, xmm1, xmm0
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_OcclusionWorker
==============
*/
void SND_OcclusionWorker(const void *const cmdInfo)
{
  char *v3; 
  int v5; 
  _DWORD *i; 
  __int64 v7; 
  volatile int *v9; 
  const dvar_t *v11; 
  bool v14; 

  v3 = (char *)cmdInfo;
  __asm { vmovaps [rsp+78h+var_38], xmm6 }
  v14 = 1;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( !CG_IsPlayerAndPointInSameInteriorZone(*((const LocalClientNum_t *)cmdInfo + 47), (const vec3_t *)((char *)cmdInfo + 176)) )
  {
    *(double *)&_XMM0 = SND_PerformOcclusionTrace((const vec3_t *)(v3 + 164), (const vec3_t *)(v3 + 176), (const LocalClientNum_t)*((_DWORD *)v3 + 47), *((_QWORD *)v3 + 24), 0);
    __asm { vmovaps xmm6, xmm0 }
    v14 = CG_OcclusionSettingsMatch(*((const LocalClientNum_t *)v3 + 47), (const vec3_t *)(v3 + 176));
  }
  v5 = 0;
  for ( i = v3 + 160; v5 < *i; v3 += 4 )
  {
    v7 = *((int *)v3 + 20);
    _RBP = v7;
    v9 = &g_snd.voiceBusyUpdating[v7];
    do
    {
      if ( ((unsigned __int8)v9 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)v9) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(v9, 1, 0) == 1 );
    _RDX = &g_snd;
    if ( *(_DWORD *)v3 == g_snd.voices[_RBP].occlusionWaitId && *(_DWORD *)v3 )
    {
      g_snd.voices[_RBP].occlusionMatchesListener = v14;
      v11 = DCONST_DVARINT_snd_occlusionDelay;
      __asm { vmovss  dword ptr [rdx+rbp+0CAE4h], xmm6 }
      if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDelay") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      g_snd.voices[_RBP].nextOcclusionTime = v11->current.integer + g_snd.time;
      g_snd.voices[_RBP].occlusionWaitId = 0;
      if ( !g_snd.voices[_RBP].paused )
        SND_UpdateAndStartVoice(v7, 0);
    }
    if ( ((unsigned __int8)v9 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)v9) )
      __debugbreak();
    _InterlockedCompareExchange(v9, 0, 1);
    ++v5;
  }
  __asm { vmovaps xmm6, [rsp+78h+var_38] }
}

/*
==============
SND_ParseSoloMuteSubstring
==============
*/
char SND_ParseSoloMuteSubstring(const char *soloMuteNames, const char *name)
{
  char *v4; 
  char dest[128]; 

  memset_0(dest, 0, sizeof(dest));
  if ( !soloMuteNames )
    return 0;
  if ( !name )
    return 0;
  Core_strcpy(dest, 0x80ui64, soloMuteNames);
  v4 = strtok(dest, "%");
  if ( !v4 )
    return 0;
  while ( !*v4 || !strstr_0(name, v4) )
  {
    v4 = strtok(NULL, "%");
    if ( !v4 )
      return 0;
  }
  return 1;
}

/*
==============
SND_PauseSounds
==============
*/
void SND_PauseSounds()
{
  int v0; 
  bool *voiceAlloc; 
  bool *p_ignorePause; 
  __int64 v3; 

  if ( !g_snd.paused )
  {
    if ( g_snd.driverInitialized )
    {
      v0 = 0;
      voiceAlloc = sdGlob.voiceAlloc;
      p_ignorePause = &g_snd.voices[0].ignorePause;
      do
      {
        if ( (unsigned int)v0 > 0x62 )
        {
          LODWORD(v3) = v0;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v3) )
            __debugbreak();
        }
        if ( *voiceAlloc && SND_IsPausable((unsigned __int8)(*(int *)(*((_QWORD *)p_ignorePause - 51) + 112i64) >> 10)) && (g_snd.uiPaused || !*p_ignorePause) )
        {
          if ( !Sys_IsMainThread() && !Sys_IsRenderThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1129, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsRenderThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsRenderThread()") )
            __debugbreak();
          if ( (unsigned int)v0 > 0x62 )
          {
            LODWORD(v3) = v0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1130, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v3) )
              __debugbreak();
          }
          *(p_ignorePause - 344) = 1;
          SD_UpdateVoice(v0, 0);
        }
        ++v0;
        ++voiceAlloc;
        p_ignorePause += 1968;
      }
      while ( v0 < 99 );
    }
    g_snd.pausetime = g_snd.time;
    g_snd.paused = 1;
  }
}

/*
==============
SND_PauseVoice
==============
*/
void SND_PauseVoice(int index)
{
  __int64 v1; 
  __int64 v2; 

  v1 = index;
  if ( !Sys_IsMainThread() && !Sys_IsRenderThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1129, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsRenderThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsRenderThread()") )
    __debugbreak();
  if ( (unsigned int)v1 > 0x62 )
  {
    LODWORD(v2) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1130, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v2) )
      __debugbreak();
  }
  LOBYTE(g_snd.chaninfoUnweightedPriority[492 * v1 - 48664]) = 1;
  SD_UpdateVoice(v1, 0);
}

/*
==============
SND_PerformOcclusionTrace
==============
*/
float SND_PerformOcclusionTrace(const vec3_t *listener, const vec3_t *emitter, const LocalClientNum_t localClientNum, const unsigned __int64 sndEnt, unsigned int id)
{
  unsigned __int64 v17; 
  LocalClientNum_t v18; 
  const dvar_t *v25; 
  unsigned __int64 v27; 
  const dvar_t *v46; 
  bool v47; 
  ntl::internal::list_node_base *mp_next; 
  ntl::internal::list_node<OcclusionLine> *v49; 
  unsigned __int64 v64; 
  unsigned int v66; 
  int v67; 
  unsigned int v68; 
  const ScriptableDef *def; 
  HavokPhysics_CollisionQueryResult *AnyResult; 
  bool HasHit; 
  float fmt; 
  float fmta; 
  float fmtb; 
  __int64 numTraces; 
  __int64 v143; 
  Physics_RaycastExtendedData extendedData; 
  __int64 v151; 
  vec3_t outPos; 
  vec3_t end; 
  vec3_t direction; 
  tmat33_t<vec3_t> outAxis; 
  char v156; 
  void *retaddr; 

  _RAX = &retaddr;
  v151 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  v17 = sndEnt;
  *(_QWORD *)direction.v = sndEnt;
  v18 = localClientNum;
  _RDI = emitter;
  _RSI = listener;
  if ( CL_IsLocalClientConnectionActiveForGameServer(localClientNum) )
  {
    __asm
    {
      vmovss  xmm8, dword ptr [rdi]
      vmovss  [rsp+1C0h+var_17C], xmm8
      vmovss  xmm9, dword ptr [rdi+4]
      vmovss  [rsp+1C0h+var_178], xmm9
      vmovss  xmm6, dword ptr [rdi+8]
    }
    v25 = DCONST_DVARFLT_snd_occlusionZOffset;
    if ( !DCONST_DVARFLT_snd_occlusionZOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionZOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v25);
    __asm
    {
      vaddss  xmm7, xmm6, dword ptr [rdi+28h]
      vmovss  [rsp+1C0h+var_174], xmm7
    }
    if ( (unsigned int)v18 >= LOCAL_CLIENT_COUNT )
    {
      LODWORD(v143) = 2;
      LODWORD(numTraces) = v18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11850, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", numTraces, v143) )
        __debugbreak();
    }
    v27 = Sys_Microseconds();
    *(_QWORD *)outPos.v = v27;
    Sys_ProfBeginNamedEvent(0xFFD8BFD8, "Occlusion Raycast");
    __asm
    {
      vmovss  xmm0, dword ptr [rsi]
      vsubss  xmm10, xmm0, xmm8
      vmovss  [rsp+1C0h+var_170], xmm10
      vmovss  xmm1, dword ptr [rsi+4]
      vsubss  xmm14, xmm1, xmm9
      vmovss  [rsp+1C0h+var_16C], xmm14
      vmovss  xmm0, dword ptr [rsi+8]
      vsubss  xmm6, xmm0, xmm7
    }
    _RDI = DCONST_DVARFLT_snd_occDepth;
    if ( !DCONST_DVARFLT_snd_occDepth && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occDepth") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm15, dword ptr [rdi+28h]
      vsubss  xmm2, xmm8, dword ptr [rsi]
      vsubss  xmm0, xmm9, dword ptr [rsi+4]
      vsubss  xmm3, xmm7, dword ptr [rsi+8]
      vmulss  xmm1, xmm0, xmm0
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vsqrtss xmm7, xmm2, xmm2
      vxorps  xmm9, xmm9, xmm9
    }
    v46 = DCONST_DVARINT_snd_occlusionDebug;
    if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v46);
    v47 = 0;
    if ( v46->current.integer )
    {
      mp_next = s_occlusionLines.m_listHead.m_sentinel.mp_next;
      v47 = s_occlusionLines.m_listHead.m_sentinel.mp_next < &s_occlusionLines.m_listHead.m_sentinel;
      if ( (ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine> > *)s_occlusionLines.m_listHead.m_sentinel.mp_next != &s_occlusionLines.m_listHead )
      {
        do
        {
          if ( !mp_next && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 97, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
            __debugbreak();
          if ( LODWORD(mp_next[3].mp_prev) == id )
          {
            v49 = (ntl::internal::list_node<OcclusionLine> *)mp_next;
            if ( !mp_next && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 439, ASSERT_TYPE_ASSERT, "( pos.mp_node )", (const char *)&queryFormat, "pos.mp_node") )
              __debugbreak();
            mp_next = mp_next->mp_next;
            ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine>>::remove(&s_occlusionLines.m_listHead, v49);
            v49->mp_prev = (ntl::internal::list_node_base *)s_occlusionLines.m_freelist.m_head.mp_next;
            s_occlusionLines.m_freelist.m_head.mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)v49;
          }
          else
          {
            if ( !mp_next && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\list\\list.h", 109, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
              __debugbreak();
            mp_next = mp_next->mp_next;
          }
          v47 = mp_next < &s_occlusionLines.m_listHead.m_sentinel;
        }
        while ( mp_next != (ntl::internal::list_node_base *)&s_occlusionLines.m_listHead );
        v18 = localClientNum;
        v17 = *(_QWORD *)direction.v;
        *(float *)&v27 = outPos.v[0];
      }
    }
    __asm { vcomiss xmm7, xmm15 }
    if ( !v47 )
    {
      __asm
      {
        vmulss  xmm12, xmm14, xmm14
        vmulss  xmm0, xmm10, xmm10
        vaddss  xmm2, xmm0, xmm12
        vmulss  xmm1, xmm6, xmm6
        vaddss  xmm2, xmm2, xmm1
        vsqrtss xmm3, xmm2, xmm2
        vmovss  xmm11, cs:__real@80000000
        vcmpless xmm0, xmm3, xmm11
        vmovss  xmm7, cs:__real@3f800000
        vblendvps xmm1, xmm3, xmm7, xmm0
        vdivss  xmm0, xmm7, xmm1
        vmulss  xmm13, xmm10, xmm0
        vmulss  xmm14, xmm14, xmm0
        vmulss  xmm8, xmm6, xmm0
      }
      v64 = v17 & 0x1FFFFFFFFi64;
      __asm { vmovss  xmm10, dword ptr cs:__xmm@80000000800000008000000080000000 }
      if ( ((v17 & 0x1FFFFFFFFi64) - 5411 <= 0x1F || v64 - 2049 <= 0x8FF || v64 <= 0x7FD || v64 - 5571 <= 0x7A120) && (v17 & 0x1000000000i64) != 0 )
      {
        v66 = truncate_cast<int,unsigned __int64>(v64);
        v67 = v66;
        if ( v66 >= 0x7B6E3 )
        {
          LODWORD(v143) = 505571;
          LODWORD(numTraces) = v66;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11880, ASSERT_TYPE_ASSERT, "(unsigned)( sndEntIndex ) < (unsigned)( ( ( ( 2048 ) ) + ( 1 ) + ( 1024 ) + ( 128 ) + ( 128 ) + 1024 + ( 2 ) + ( 32 ) + ( 1024 ) + ( 32 ) + ( 128 ) + ( 500000 ) ) )", "sndEntIndex doesn't index MAX_SOUND_ENTITIES\n\t%i not in [0, %i)", numTraces, v143) )
            __debugbreak();
        }
        if ( GetSoundEntityType(v18, v67) == EST_SCRIPTABLE )
        {
          v68 = v67 - 5571;
          ScriptableCommon_AssertCountsInitialized();
          if ( v68 >= g_scriptableWorldCounts.totalInstanceCount )
          {
            ScriptableCommon_AssertCountsInitialized();
            LODWORD(v143) = g_scriptableWorldCounts.totalInstanceCount;
            LODWORD(numTraces) = v68;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_client_utility.h", 113, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableId ) < (unsigned)( ScriptableCommon_GetTotalInstanceCount() )", "scriptableId doesn't index ScriptableCommon_GetTotalInstanceCount()\n\t%i not in [0, %i)", numTraces, v143) )
              __debugbreak();
          }
          if ( (unsigned int)v18 >= LOCAL_CLIENT_COUNT )
          {
            LODWORD(v143) = 2;
            LODWORD(numTraces) = v18;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_client_utility.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( g_scriptableCl_instanceContexts ) ) + 0 ) )", "localClientNum doesn't index g_scriptableCl_instanceContexts\n\t%i not in [0, %i)", numTraces, v143) )
              __debugbreak();
          }
          if ( !g_scriptableCl_instanceContexts[v18] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_client_utility.h", 115, ASSERT_TYPE_ASSERT, "(g_scriptableCl_instanceContexts[localClientNum])", (const char *)&queryFormat, "g_scriptableCl_instanceContexts[localClientNum]") )
            __debugbreak();
          def = g_scriptableCl_instanceContexts[v18][v68].commonContext.def;
          if ( def && (def->flags & 0x180000) != 0 )
          {
            ScriptableCl_GetInstanceOrientation(v18, v68, &outPos, &outAxis);
            __asm
            {
              vmovss  xmm0, [rsp+1C0h+var_17C]
              vsubss  xmm6, xmm0, dword ptr [rbp+0C0h+outPos]
              vmovss  xmm0, [rsp+1C0h+var_178]
              vsubss  xmm5, xmm0, dword ptr [rbp+0C0h+outPos+4]
              vmovss  xmm0, [rsp+1C0h+var_174]
              vsubss  xmm3, xmm0, dword ptr [rbp+0C0h+outPos+8]
              vmulss  xmm1, xmm5, xmm5
              vmulss  xmm0, xmm6, xmm6
              vaddss  xmm2, xmm1, xmm0
              vmulss  xmm1, xmm3, xmm3
              vaddss  xmm2, xmm2, xmm1
              vsqrtss xmm4, xmm2, xmm2
              vcmpless xmm0, xmm4, xmm11
              vblendvps xmm1, xmm4, xmm7, xmm0
              vdivss  xmm0, xmm7, xmm1
              vmulss  xmm4, xmm5, xmm0
              vmulss  xmm0, xmm6, xmm0
              vxorps  xmm5, xmm0, xmm10
              vmulss  xmm2, xmm5, xmm5
              vmulss  xmm1, xmm4, xmm4
              vaddss  xmm0, xmm2, xmm1
              vsqrtss xmm3, xmm0, xmm0
              vcmpless xmm0, xmm3, xmm11
              vblendvps xmm1, xmm3, xmm7, xmm0
              vdivss  xmm0, xmm7, xmm1
              vmulss  xmm6, xmm0, xmm4
              vmulss  xmm2, xmm0, xmm5
              vmulss  xmm1, xmm2, xmm14
              vmulss  xmm0, xmm13, xmm6
              vaddss  xmm4, xmm1, xmm0
            }
            memset(&outPos, 0, sizeof(outPos));
            __asm
            {
              vmovaps xmm8, xmm9
              vxorps  xmm1, xmm2, xmm10
              vcmpless xmm0, xmm9, xmm4
              vblendvps xmm14, xmm1, xmm2, xmm0
              vxorps  xmm2, xmm6, xmm10
              vcmpless xmm0, xmm9, xmm4
              vblendvps xmm13, xmm2, xmm6, xmm0
            }
          }
        }
      }
      __asm
      {
        vmulss  xmm0, xmm13, xmm15
        vaddss  xmm1, xmm0, [rsp+1C0h+var_17C]
        vmovss  dword ptr [rbp+0C0h+end], xmm1
        vmulss  xmm2, xmm14, xmm15
        vaddss  xmm0, xmm2, [rsp+1C0h+var_178]
        vmovss  dword ptr [rbp+0C0h+end+4], xmm0
        vmulss  xmm1, xmm8, xmm15
        vaddss  xmm2, xmm1, [rsp+1C0h+var_174]
        vmovss  dword ptr [rbp+0C0h+end+8], xmm2
      }
      extendedData.ignoreBodies = NULL;
      extendedData.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
      __asm { vmovss  [rsp+1C0h+extendedData.collisionBuffer], xmm9 }
      extendedData.phaseSelection = All;
      extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
      *(_WORD *)&extendedData.collectInsideHits = 256;
      extendedData.contents = 2097169;
      AnyResult = PhysicsQuery_GetAnyResult(PHYSICS_WORLD_ID_CLIENT_FIRST);
      if ( !AnyResult && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11926, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
        __debugbreak();
      HavokPhysics_CollisionQueryResult::Reset(AnyResult, 1);
      Physics_Raycast(PHYSICS_WORLD_ID_CLIENT_FIRST, _RSI, &end, &extendedData, AnyResult);
      HasHit = HavokPhysics_CollisionQueryResult::HasHit(AnyResult);
      if ( HavokPhysics_CollisionQueryResult::HasHit(AnyResult) )
      {
        *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(AnyResult, 0);
        __asm { vmovaps xmm8, xmm0 }
      }
      else
      {
        __asm { vmovaps xmm8, xmm7 }
      }
      if ( HavokPhysics_CollisionQueryResult::HasHit(AnyResult) )
      {
        __asm
        {
          vmovss  xmm0, [rsp+1C0h+var_170]
          vxorps  xmm3, xmm0, xmm10
          vmulss  xmm0, xmm3, xmm3
          vaddss  xmm1, xmm0, xmm12
          vsqrtss xmm2, xmm1, xmm1
          vcmpless xmm0, xmm2, xmm11
          vblendvps xmm0, xmm2, xmm7, xmm0
          vdivss  xmm1, xmm7, xmm0
          vmulss  xmm2, xmm1, [rsp+1C0h+var_16C]
          vmovss  dword ptr [rbp+0C0h+outPos], xmm2
          vmulss  xmm3, xmm1, xmm3
          vmovss  dword ptr [rbp+0C0h+outPos+4], xmm3
          vmovss  dword ptr [rbp+0C0h+outPos+8], xmm9
          vxorps  xmm0, xmm2, xmm10
          vmovss  dword ptr [rbp+0C0h+direction], xmm0
          vxorps  xmm1, xmm3, xmm10
          vmovss  dword ptr [rbp+0C0h+direction+4], xmm1
          vmovss  dword ptr [rbp+0C0h+direction+8], xmm9
          vmovss  xmm7, cs:__real@42c80000
          vmovss  dword ptr [rsp+1C0h+fmt], xmm7
        }
        *(float *)&_XMM0 = SND_OccTraceSide(v18, _RSI, &end, &outPos, fmt, 3, id);
        __asm
        {
          vmovaps xmm6, xmm0
          vmovss  dword ptr [rsp+1C0h+fmt], xmm7
        }
        *(float *)&_XMM0 = SND_OccTraceSide(v18, _RSI, &end, &direction, fmta, 3, id);
        __asm { vminss  xmm9, xmm0, xmm6 }
      }
      __asm { vmovss  dword ptr [rsp+1C0h+fmt], xmm8 }
      SND_DebugAddOcclusionLine(_RSI, &end, HasHit, id, fmtb);
      g_snd.occlusionRaycastUsec = Sys_Microseconds() - v27;
      Sys_ProfEndNamedEvent();
    }
    __asm { vmovaps xmm0, xmm9 }
  }
  else
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  _R11 = &v156;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
  return *(float *)&_XMM0;
}

/*
==============
SND_PickBlendedContextSoundAlias
==============
*/
void SND_PickBlendedContextSoundAlias(const SndAlias **aliases, const int numAliases, const SndEntState *entState, const vec3_t *inOrigin, const ZoneDef *zoneA, const ZoneDef *zoneB, const float zoneLerpVal, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp)
{
  const SndAlias **v17; 
  int v19; 
  int v20; 
  int v21; 
  __int64 v22; 
  float v24; 
  char v25; 
  __int64 v26; 
  unsigned int v27; 
  unsigned int v28; 
  char v29; 
  __int64 v33; 
  const char **v35; 
  __int64 i; 
  SndAlias *v37; 
  __int64 v38; 
  const char **v40; 
  SndContext *Context; 
  unsigned int v42; 
  __int64 v45; 
  __int64 v47; 
  SndAlias *v48; 
  int v49; 
  __int64 j; 
  const char **v54; 
  bool v57; 
  const SndAlias **v58; 
  int v59; 
  const SndAlias **v60; 
  int v61; 
  int v62; 
  SndAlias *v63; 
  int v64; 
  unsigned int contextType; 
  int v66; 
  __int64 k; 
  int v68; 
  __int64 v69; 
  __int64 v70; 
  int v71; 
  SndContext *v72; 
  char v75; 
  int v76; 
  const SndAlias **v77; 
  __int64 v78; 
  unsigned int outContextValueA; 
  unsigned int outContextValueB; 
  float v81[2]; 
  SndContext *v82; 
  const SndAlias **v83; 
  const SndAlias **v84; 
  SndEntState *entStatea; 
  float *v86; 
  int v87[64]; 
  SndAlias *aliasArray[64]; 
  int v89[64]; 
  __int64 Src[128]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-78h], xmm9 }
  _R15 = outLerp;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm6
    vmovaps xmmword ptr [r11-58h], xmm7
  }
  v17 = aliases;
  v77 = aliases;
  entStatea = (SndEntState *)entState;
  v83 = outAliasA;
  v84 = outAliasB;
  v86 = outLerp;
  if ( !outAliasA )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14381, ASSERT_TYPE_ASSERT, "(outAliasA)", (const char *)&queryFormat, "outAliasA") )
      __debugbreak();
    v17 = v77;
  }
  __asm { vmovss  xmm7, cs:__real@3f800000 }
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v76 = 0;
  v22 = 64i64;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( numAliases < 64 )
    v22 = (unsigned int)numAliases;
  v24 = 0.0;
  v25 = 0;
  v81[1] = 0.0;
  v26 = 0i64;
  v75 = 0;
  v27 = 0;
  v82 = NULL;
  v28 = 0;
  outContextValueA = 0;
  v29 = 0;
  outContextValueB = 0;
  __asm
  {
    vmovss  [rsp+910h+var_8B0], xmm6
    vxorps  xmm9, xmm9, xmm9
  }
  if ( (_DWORD)v22 )
  {
    _RSI = 0i64;
    __asm
    {
      vmovaps [rsp+910h+var_68+8], xmm8
      vmovss  xmm8, [rbp+810h+zoneLerpVal]
    }
    v33 = 0i64;
    v78 = v22;
    _RBX = 0i64;
    while ( 1 )
    {
      v35 = (const char **)*v17;
      if ( (*v17)->contextType != LODWORD(v24) )
      {
        if ( !v29 )
        {
          for ( i = 0i64; i < v33; ++i )
          {
            v37 = (SndAlias *)Src[i + 64];
            if ( _RBX >= 64 )
            {
              Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", v37->aliasName, 64i64);
            }
            else
            {
              ++v20;
              aliasArray[_RBX] = v37;
              __asm { vmovss  [rbp+rbx*4+810h+var_880], xmm6 }
              ++_RBX;
            }
          }
        }
        if ( !v75 )
        {
          v38 = 0i64;
          __asm { vsubss  xmm6, xmm7, xmm6 }
          if ( v33 > 0 )
          {
            do
            {
              v40 = (const char **)Src[v38 + 64];
              if ( _RSI >= 64 )
              {
                Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", *v40, 64i64);
              }
              else
              {
                ++v21;
                Src[_RSI] = (__int64)v40;
                __asm { vmovss  [rbp+rsi*4+810h+var_580], xmm6 }
                ++_RSI;
              }
              ++v38;
            }
            while ( v38 < v33 );
          }
        }
        v75 = 0;
        v33 = 0i64;
        v81[1] = *((float *)v35 + 11);
        v76 = 0;
        v29 = 0;
        Context = SND_GetContext(LODWORD(v81[1]));
        v42 = *((_DWORD *)v35 + 11);
        v82 = Context;
        __asm { vmovaps xmm3, xmm8; zoneLerp }
        FindDominantContextType(v42, zoneA, zoneB, *(const float *)&_XMM3, entStatea, &outContextValueA, &outContextValueB, v81);
        v26 = (__int64)v82;
        v19 = 0;
        v27 = outContextValueA;
        v28 = outContextValueB;
        v17 = v77;
        v22 = v78;
        __asm { vmovss  xmm6, [rsp+910h+var_8B0] }
      }
      if ( *((_DWORD *)v35 + 11) )
        break;
      if ( _RBX >= 64 )
        goto LABEL_26;
      ++v20;
      v87[_RBX] = 0;
      aliasArray[_RBX++] = (SndAlias *)v35;
LABEL_29:
      v25 = v75;
LABEL_30:
      v19 = v76;
      ++v17;
      v26 = (__int64)v82;
      --v22;
      v27 = outContextValueA;
      v28 = outContextValueB;
      v24 = v81[1];
      v78 = v22;
      v77 = v17;
      if ( !v22 )
      {
        _R15 = v86;
        __asm { vmovaps xmm8, [rsp+910h+var_68+8] }
        goto LABEL_32;
      }
    }
    if ( !v26 )
      goto LABEL_29;
    if ( !*(_BYTE *)(v26 + 20) || *((_DWORD *)v35 + 12) )
    {
      v49 = *((_DWORD *)v35 + 12);
      if ( v49 != v27 )
        goto LABEL_92;
      __asm { vucomiss xmm6, xmm7 }
      if ( v49 == v27 )
      {
LABEL_92:
        if ( v49 == v28 )
        {
          __asm { vucomiss xmm6, xmm9 }
          if ( v49 != v28 )
          {
            if ( _RSI >= 64 )
            {
              Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", *v35, 64i64);
              v17 = v77;
              v25 = 1;
              v22 = v78;
            }
            else
            {
              v17 = v77;
              ++v21;
              v22 = v78;
              Src[_RSI] = (__int64)v35;
              v25 = 1;
              __asm
              {
                vsubss  xmm0, xmm7, xmm6
                vmovss  [rbp+rsi*4+810h+var_580], xmm0
              }
              ++_RSI;
            }
            v75 = 1;
            goto LABEL_30;
          }
        }
        goto LABEL_28;
      }
      if ( _RBX >= 64 )
      {
        Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", *v35, 64i64);
      }
      else
      {
        ++v20;
        aliasArray[_RBX] = (SndAlias *)v35;
        __asm { vmovss  [rbp+rbx*4+810h+var_880], xmm6 }
        ++_RBX;
      }
      v29 = 1;
    }
    else
    {
      if ( v33 < 64 )
      {
        Src[v33 + 64] = (__int64)v35;
        v76 = v19 + 1;
        ++v33;
        goto LABEL_29;
      }
LABEL_26:
      Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", *v35, 64i64);
    }
    v17 = v77;
LABEL_28:
    v22 = v78;
    goto LABEL_29;
  }
LABEL_32:
  v45 = v19;
  if ( !v29 && v19 > 0 )
  {
    _RBX = v20;
    v47 = 0i64;
    do
    {
      v48 = (SndAlias *)Src[v47 + 64];
      if ( _RBX >= 64 )
      {
        Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", v48->aliasName, 64i64);
      }
      else
      {
        ++v20;
        aliasArray[_RBX] = v48;
        __asm { vmovss  [rbp+rbx*4+810h+var_880], xmm6 }
        ++_RBX;
      }
      ++v47;
    }
    while ( v47 < v45 );
  }
  if ( !v25 )
  {
    __asm { vsubss  xmm6, xmm7, xmm6 }
    if ( v45 > 0 )
    {
      _RBX = v21;
      for ( j = 0i64; j < v45; ++j )
      {
        v54 = (const char **)Src[j + 64];
        if ( _RBX >= 64 )
        {
          Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", *v54, 64i64);
        }
        else
        {
          ++v21;
          Src[_RBX] = (__int64)v54;
          __asm { vmovss  [rbp+rbx*4+810h+var_580], xmm6 }
          ++_RBX;
        }
      }
    }
  }
  __asm
  {
    vmovaps xmm7, [rsp+910h+var_58+8]
    vmovaps xmm6, xmmword ptr [rsp+910h+var_48+8]
  }
  v57 = v20 <= 0;
  if ( !v20 )
  {
    if ( v21 <= 0 )
      goto LABEL_89;
    memcpy_0(aliasArray, Src, 8i64 * v21);
    memcpy_0(v87, v89, 4i64 * v21);
    v20 = v21;
    v21 = 0;
    v57 = v20 <= 0;
  }
  if ( v57 )
  {
    if ( *v83 )
    {
      if ( *v84 )
      {
        __asm { vucomiss xmm9, dword ptr [r15] }
        if ( *v84 )
        {
          v72 = SND_GetContext((*v83)->contextType);
          if ( v72 )
          {
            if ( !v72->canBlend )
            {
              __asm
              {
                vmovss  xmm0, cs:__real@3f000000
                vcomiss xmm0, dword ptr [r15]
              }
              goto LABEL_88;
            }
          }
        }
      }
    }
  }
  else
  {
    v58 = v84;
    if ( v21 > 0 && v84 && _R15 )
    {
      v59 = SND_PickRandomAliasIndex((const SndAlias **)aliasArray, v20);
      v60 = v83;
      v61 = -1;
      v62 = 0;
      v63 = aliasArray[v59];
      v64 = v87[v59];
      *v83 = v63;
      *(_DWORD *)_R15 = v64;
      contextType = v63->contextType;
      v66 = 0;
      for ( k = 0i64; k < v21; ++k )
      {
        if ( *(_DWORD *)(Src[k] + 44) == contextType )
        {
          ++v66;
          v68 = v62;
          if ( v61 != -1 )
            v68 = v61;
          v61 = v68;
        }
        ++v62;
      }
      if ( v66 <= 0 || (v69 = Src[SND_PickRandomAliasIndex((const SndAlias **)&Src[v61], v66)], *v58 = (const SndAlias *)v69, (*v60)->contextValue == *(_DWORD *)(v69 + 48)) )
      {
        *v58 = NULL;
LABEL_88:
        *_R15 = 0.0;
      }
    }
    else
    {
      v70 = SND_PickRandomAliasIndex((const SndAlias **)aliasArray, v20);
      *v83 = aliasArray[v70];
      if ( v58 && _R15 )
      {
        v71 = v87[v70];
        *v58 = NULL;
        *(_DWORD *)_R15 = v71;
      }
    }
  }
LABEL_89:
  __asm { vmovaps xmm9, [rsp+910h+var_78+8] }
}

/*
==============
SND_PickRandomAliasIndex
==============
*/

__int64 __fastcall SND_PickRandomAliasIndex(const SndAlias **aliasArray, int numAliases, __int64 a3, double _XMM3_8)
{
  int v12; 
  int v13; 
  int sequence; 
  unsigned int v18; 
  int v19; 
  int v21; 
  const SndAlias **v22; 
  __int64 v23; 
  int v26; 
  int v28; 
  int v30; 
  int v39; 
  int v40; 
  int v42; 
  int v47; 
  int v48; 
  const SndAlias **v53; 
  __int64 v54; 
  int v55; 
  int v61; 
  const SndAlias **v62; 
  const SndAlias **v83; 
  __int64 result; 

  _RAX = *aliasArray;
  v12 = 0;
  v13 = randSeed;
  __asm
  {
    vmovaps [rsp+78h+var_68], xmm10
    vmovss  xmm10, cs:__real@47000000
  }
  sequence = (*aliasArray)->sequence;
  v18 = 0;
  v19 = 1;
  __asm
  {
    vmovaps [rsp+78h+var_78], xmm11
    vmovss  xmm11, dword ptr [rax+74h]
  }
  if ( numAliases > 1 )
  {
    if ( numAliases > 4 )
    {
      v21 = numAliases - 3;
      v22 = aliasArray + 3;
      __asm
      {
        vmovaps [rsp+78h+var_28], xmm6
        vmovaps [rsp+78h+var_38], xmm7
        vmovaps [rsp+78h+var_48], xmm8
        vmovaps [rsp+78h+var_58], xmm9
      }
      do
      {
        v23 = (__int64)*(v22 - 2);
        v22 += 4;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vaddss  xmm2, xmm11, dword ptr [rcx+74h]
        }
        v26 = *(_DWORD *)(v23 + 72);
        __asm { vmulss  xmm8, xmm10, dword ptr [rcx+74h] }
        v28 = 214013 * v13 + 2531011;
        __asm { vaddss  xmm3, xmm2, dword ptr [rcx+74h] }
        v30 = (*(v22 - 5))->sequence;
        __asm { vmulss  xmm6, xmm10, dword ptr [rcx+74h] }
        if ( sequence >= v26 )
          v26 = sequence;
        __asm
        {
          vcvtsi2ss xmm0, xmm0, eax
          vmulss  xmm9, xmm0, xmm2
          vaddss  xmm2, xmm3, dword ptr [rcx+74h]
          vmulss  xmm4, xmm10, dword ptr [rcx+74h]
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmulss  xmm7, xmm0, xmm3
        }
        if ( v26 >= v30 )
          v30 = v26;
        v39 = (*(v22 - 4))->sequence;
        v40 = v19;
        __asm { vxorps  xmm0, xmm0, xmm0 }
        v42 = 214013 * (214013 * v28 + 2531011) + 2531011;
        __asm
        {
          vaddss  xmm11, xmm2, dword ptr [r8+74h]
          vcvtsi2ss xmm0, xmm0, eax
        }
        if ( v30 >= v39 )
          v39 = v30;
        __asm
        {
          vmulss  xmm5, xmm0, xmm2
          vmulss  xmm2, xmm10, dword ptr [r8+74h]
        }
        sequence = (*(v22 - 3))->sequence;
        __asm { vxorps  xmm0, xmm0, xmm0 }
        v13 = 214013 * v42 + 2531011;
        __asm
        {
          vcomiss xmm8, xmm9
          vcvtsi2ss xmm0, xmm0, eax
        }
        if ( ((v13 >> 16) & 0x7FFF) == 0 )
          v40 = v18;
        v47 = v19 + 1;
        __asm { vcomiss xmm6, xmm7 }
        v18 = v19 + 3;
        if ( (((214013 * v42 + 2531011) >> 16) & 0x7FFF) == 0 )
          v47 = v40;
        v48 = v19 + 2;
        __asm
        {
          vcomiss xmm4, xmm5
          vmulss  xmm3, xmm0, xmm11
        }
        if ( (((214013 * v42 + 2531011) >> 16) & 0x7FFF) == 0 )
          v48 = v47;
        __asm { vcomiss xmm2, xmm3 }
        if ( (((214013 * v42 + 2531011) >> 16) & 0x7FFF) == 0 )
          v18 = v48;
        if ( v39 >= sequence )
          sequence = v39;
        v19 += 4;
      }
      while ( v19 < v21 );
      __asm
      {
        vmovaps xmm9, [rsp+78h+var_58]
        vmovaps xmm8, [rsp+78h+var_48]
        vmovaps xmm7, [rsp+78h+var_38]
        vmovaps xmm6, [rsp+78h+var_28]
      }
      randSeed = 214013 * v42 + 2531011;
    }
    if ( v19 < numAliases )
    {
      v53 = &aliasArray[v19];
      do
      {
        v54 = (__int64)*v53++;
        v55 = sequence;
        __asm { vxorps  xmm0, xmm0, xmm0 }
        sequence = *(_DWORD *)(v54 + 72);
        __asm
        {
          vaddss  xmm11, xmm11, dword ptr [rcx+74h]
          vmulss  xmm1, xmm10, dword ptr [rcx+74h]
        }
        v13 = 214013 * v13 + 2531011;
        __asm
        {
          vcvtsi2ss xmm0, xmm0, eax
          vmulss  xmm2, xmm0, xmm11
          vcomiss xmm1, xmm2
        }
        if ( ((v13 >> 16) & 0x7FFF) != 0 )
          v18 = v19;
        if ( v55 >= sequence )
          sequence = v55;
        ++v19;
      }
      while ( v19 < numAliases );
      randSeed = v13;
    }
  }
  __asm { vmovaps xmm11, [rsp+78h+var_78] }
  if ( numAliases > 2 && sequence == aliasArray[v18]->sequence )
  {
    __asm { vxorps  xmm3, xmm3, xmm3 }
    if ( numAliases >= 4 )
    {
      v61 = 2;
      v62 = aliasArray + 2;
      do
      {
        _RAX = (__int64)*(v62 - 2);
        if ( sequence != *(_DWORD *)(_RAX + 72) )
        {
          __asm
          {
            vmovss  xmm1, dword ptr [rax+74h]
            vaddss  xmm3, xmm3, xmm1
            vxorps  xmm0, xmm0, xmm0
            vmulss  xmm1, xmm10, xmm1
          }
          v13 = 214013 * v13 + 2531011;
          randSeed = v13;
          __asm
          {
            vcvtsi2ss xmm0, xmm0, eax
            vmulss  xmm2, xmm0, xmm3
            vcomiss xmm1, xmm2
          }
          if ( ((v13 >> 16) & 0x7FFF) != 0 )
            v18 = v12;
        }
        _RAX = (__int64)*(v62 - 1);
        if ( sequence != *(_DWORD *)(_RAX + 72) )
        {
          __asm
          {
            vmovss  xmm1, dword ptr [rax+74h]
            vaddss  xmm3, xmm3, xmm1
            vxorps  xmm0, xmm0, xmm0
            vmulss  xmm1, xmm10, xmm1
          }
          v13 = 214013 * v13 + 2531011;
          randSeed = v13;
          __asm
          {
            vcvtsi2ss xmm0, xmm0, eax
            vmulss  xmm2, xmm0, xmm3
            vcomiss xmm2, xmm1
          }
        }
        _RAX = *v62;
        if ( sequence != (*v62)->sequence )
        {
          __asm
          {
            vmovss  xmm1, dword ptr [rax+74h]
            vaddss  xmm3, xmm3, xmm1
            vxorps  xmm0, xmm0, xmm0
            vmulss  xmm1, xmm10, xmm1
          }
          v13 = 214013 * v13 + 2531011;
          randSeed = v13;
          __asm
          {
            vcvtsi2ss xmm0, xmm0, eax
            vmulss  xmm2, xmm0, xmm3
            vcomiss xmm1, xmm2
          }
          if ( ((v13 >> 16) & 0x7FFF) != 0 )
            v18 = v61;
        }
        _RAX = v62[1];
        if ( sequence != _RAX->sequence )
        {
          __asm
          {
            vmovss  xmm1, dword ptr [rax+74h]
            vaddss  xmm3, xmm3, xmm1
            vxorps  xmm0, xmm0, xmm0
            vmulss  xmm1, xmm10, xmm1
          }
          v13 = 214013 * v13 + 2531011;
          randSeed = v13;
          __asm
          {
            vcvtsi2ss xmm0, xmm0, eax
            vmulss  xmm2, xmm0, xmm3
            vcomiss xmm2, xmm1
          }
        }
        v62 += 4;
        v12 += 4;
        v61 += 4;
      }
      while ( v12 < numAliases - 3 );
    }
    if ( v12 < numAliases )
    {
      v83 = &aliasArray[v12];
      do
      {
        _RAX = *v83;
        if ( sequence != (*v83)->sequence )
        {
          __asm
          {
            vmovss  xmm1, dword ptr [rax+74h]
            vaddss  xmm3, xmm3, xmm1
            vxorps  xmm0, xmm0, xmm0
            vmulss  xmm1, xmm10, xmm1
          }
          v13 = 214013 * v13 + 2531011;
          randSeed = v13;
          __asm
          {
            vcvtsi2ss xmm0, xmm0, eax
            vmulss  xmm2, xmm0, xmm3
            vcomiss xmm1, xmm2
          }
          if ( ((v13 >> 16) & 0x7FFF) != 0 )
            v18 = v12;
        }
        ++v83;
        ++v12;
      }
      while ( v12 < numAliases );
    }
  }
  __asm { vmovaps xmm10, [rsp+78h+var_68] }
  result = v18;
  aliasArray[v18]->sequence = sequence + 1;
  return result;
}

/*
==============
SND_PickSoundAlias
==============
*/
void SND_PickSoundAlias(const char *aliasname, const LocalClientNum_t localClientNum, const int entityNum, const vec3_t *origin, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp)
{
  SndPlayParams inParams; 

  __asm { vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000 }
  _RSI = origin;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovups xmmword ptr [rbp+3Fh+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+3Fh+inParams.lpfCutoff], xmm0
    vmovss  [rbp+3Fh+inParams.hpfCutoff], xmm0
    vmovss  dword ptr [rbp+3Fh+inParams.org], xmm1
    vmovss  dword ptr [rbp+3Fh+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+3Fh+inParams.org+8], xmm1
    vmovss  [rbp+3Fh+inParams.startOffsetFraction], xmm1
  }
  inParams.aliasId = 0;
  inParams.playbackType = SPT_BLEND;
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  inParams.aliasList = SND_FindAlias(aliasname);
  inParams.sndEnt = CG_GenerateSndEntHandle(localClientNum, entityNum);
  if ( _RSI )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsi]
      vmovss  xmm1, dword ptr [rsi+4]
      vmovss  dword ptr [rbp+3Fh+inParams.org], xmm0
      vmovss  xmm0, dword ptr [rsi+8]
      vmovss  dword ptr [rbp+3Fh+inParams.org+8], xmm0
      vmovss  dword ptr [rbp+3Fh+inParams.org+4], xmm1
    }
  }
  SND_PickSoundAliasFromList(inParams.aliasList, &inParams, outAliasA, outAliasB, outLerp, 0, 0, 0, 0);
}

/*
==============
SND_PickSoundAliasContext
==============
*/
__int64 SND_PickSoundAliasContext(const SndAlias **aliasArrayIn, const SndAlias **aliasArrayOut, const int aliasCount, const int contextIndex, const SndEntState *entState, const ZoneDef *zone, const unsigned int specType, const unsigned int specValue)
{
  int v11; 
  int v12; 
  const SndAlias **v13; 
  const SndAlias **v14; 
  int v15; 
  unsigned int contextValue1; 
  __int64 v17; 
  SndContext *v18; 
  __int64 v19; 
  __int64 v21; 
  __int64 v23; 
  unsigned int v24; 
  unsigned int v25; 
  int v26; 
  unsigned int v27; 
  __int64 v28; 
  SndContext *Context; 
  bool includeDefaultsInRandom; 
  char *v41; 
  int *v42; 
  __int64 v43; 
  __int64 v47; 
  __int64 v48; 
  unsigned int v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  int v54; 
  const SndAlias **v55; 
  unsigned int type[2]; 
  _DWORD v57[2]; 
  __int64 v58; 
  __int64 v59; 
  __int64 v60; 
  __int64 v61; 
  const SndAlias **v62; 
  char Src[512]; 
  char v64[512]; 
  char v65[512]; 

  v11 = 0;
  v12 = 0;
  v13 = aliasArrayOut;
  v62 = aliasArrayOut;
  v14 = aliasArrayIn;
  v53 = 0;
  v15 = 0;
  v50 = contextIndex;
  contextValue1 = 0;
  v17 = aliasCount;
  v18 = NULL;
  v55 = aliasArrayIn;
  v51 = 0;
  v52 = 0;
  v49 = 0;
  if ( contextIndex > 2 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14587, ASSERT_TYPE_ASSERT, "(SND_MAX_ALIAS_CONTEXTS >= contextIndex)", (const char *)&queryFormat, "SND_MAX_ALIAS_CONTEXTS >= contextIndex") )
      __debugbreak();
    v14 = v55;
    contextIndex = v50;
  }
  v61 = v17;
  if ( (int)v17 > 0 )
  {
    v19 = 0i64;
    __asm
    {
      vmovaps [rsp+700h+var_48+8], xmm6
      vmovss  xmm6, cs:__real@3f800000
    }
    v21 = contextIndex;
    __asm
    {
      vmovaps [rsp+700h+var_58+8], xmm7
      vmovss  xmm7, cs:__real@3f000000
    }
    v59 = contextIndex;
    v58 = 0i64;
    while ( 1 )
    {
      v23 = (__int64)v14[v19];
      v60 = v23;
      type[0] = *(_DWORD *)(v23 + 44);
      type[1] = *(_DWORD *)(v23 + 52);
      v57[0] = *(_DWORD *)(v23 + 48);
      v57[1] = *(_DWORD *)(v23 + 56);
      if ( (unsigned int)contextIndex >= 2 )
      {
        LODWORD(v48) = 2;
        LODWORD(v47) = contextIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14595, ASSERT_TYPE_ASSERT, "(unsigned)( contextIndex ) < (unsigned)( ( sizeof( *array_counter( contextTypes ) ) + 0 ) )", "contextIndex doesn't index ARRAY_COUNT( contextTypes )\n\t%i not in [0, %i)", v47, v48) )
          __debugbreak();
      }
      v24 = type[v21];
      v25 = v49;
      v26 = v57[v59];
      v54 = v26;
      if ( v49 != v24 )
        break;
LABEL_35:
      if ( !v24 )
      {
        v41 = v65;
        v42 = &v53;
LABEL_50:
        v43 = *v42;
        if ( (int)v43 >= 64 )
        {
          Com_PrintError(9, "Sound alias list %s has too many variants.  Must be < %u\n", *(const char **)v23, 64i64);
        }
        else
        {
          *(_QWORD *)&v41[8 * v43] = v23;
          *v42 = v43 + 1;
        }
        goto LABEL_53;
      }
      if ( v18 )
      {
        if ( v26 || !v18->allowDefaults )
        {
          if ( (v24 != specType || v26 != specValue) && (v25 != v24 || contextValue1 != v26) )
            goto LABEL_53;
          v41 = Src;
          v42 = &v51;
        }
        else
        {
          includeDefaultsInRandom = v18->includeDefaultsInRandom;
          v41 = v64;
          if ( includeDefaultsInRandom )
            v41 = Src;
          v42 = &v52;
          if ( includeDefaultsInRandom )
            v42 = &v51;
        }
        goto LABEL_50;
      }
LABEL_53:
      contextIndex = v50;
      v19 = v58 + 1;
      v21 = v50;
      v14 = v55;
      v58 = v19;
      if ( v19 >= v61 )
      {
        v11 = v51;
        v15 = v52;
        v12 = v53;
        v13 = v62;
        __asm
        {
          vmovaps xmm7, [rsp+700h+var_58+8]
          vmovaps xmm6, [rsp+700h+var_48+8]
        }
        goto LABEL_55;
      }
    }
    v49 = v24;
    if ( entState )
    {
      v27 = 0;
      v28 = 0i64;
      while ( entState->contextTypes[v28] != v24 )
      {
        ++v27;
        ++v28;
        if ( v27 >= 3 )
          goto LABEL_15;
      }
      __asm { vmovaps xmm0, xmm6 }
      if ( entState->contextFadeLength[v28] > 0 )
      {
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm1, xmm1, eax
          vcvtsi2ss xmm0, xmm0, ecx
          vdivss  xmm0, xmm1, xmm0; val
          vxorps  xmm1, xmm1, xmm1; min
          vmovaps xmm2, xmm6; max
        }
        I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vsubss  xmm0, xmm6, xmm0 }
      }
      contextValue1 = entState->contextValuesTo[v28];
      if ( contextValue1 )
      {
        __asm { vcomiss xmm0, xmm7 }
        goto LABEL_34;
      }
      __asm { vucomiss xmm0, xmm6 }
    }
LABEL_15:
    LODWORD(_RAX) = SND_FindContextIndex(v24);
    if ( (int)_RAX < 0 )
      goto LABEL_24;
    _RAX = (int)_RAX;
    _RCX = &g_snd;
    contextValue1 = g_snd.globalContextsTo[(int)_RAX];
    if ( !contextValue1 )
    {
      __asm { vucomiss xmm6, dword ptr [rcx+rax*8+145284h] }
LABEL_24:
      if ( zone )
      {
        if ( zone->contextType1 == v24 )
        {
          contextValue1 = zone->contextValue1;
          goto LABEL_34;
        }
        if ( zone->contextType2 == v24 )
        {
          contextValue1 = zone->contextValue2;
          goto LABEL_34;
        }
        if ( zone->contextType3 == v24 )
        {
          contextValue1 = zone->contextValue3;
          goto LABEL_34;
        }
        if ( zone->contextType4 == v24 )
        {
          contextValue1 = zone->contextValue4;
          goto LABEL_34;
        }
      }
      contextValue1 = 0;
      goto LABEL_34;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+rax*8+145284h]
      vcomiss xmm0, xmm7
    }
LABEL_34:
    Context = SND_GetContext(v24);
    v23 = v60;
    v18 = Context;
    v26 = v54;
    v25 = v24;
    goto LABEL_35;
  }
LABEL_55:
  if ( v11 <= 0 )
  {
    if ( v15 <= 0 )
    {
      if ( v12 <= 0 )
      {
        return 0i64;
      }
      else
      {
        memcpy_0(v13, v65, 8i64 * v12);
        return (unsigned int)v12;
      }
    }
    else
    {
      memcpy_0(v13, v64, 8i64 * v15);
      return (unsigned int)v15;
    }
  }
  else
  {
    memcpy_0(v13, Src, 8i64 * v11);
    return (unsigned int)v11;
  }
}

/*
==============
SND_PickSoundAliasFromList
==============
*/
void SND_PickSoundAliasFromList(const SndAliasList *aliasList, const SndPlayParams *inParams, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp)
{
  SND_PickSoundAliasFromList(aliasList, inParams, outAliasA, outAliasB, outLerp, 0, 0, 0, 0);
}

/*
==============
SND_PickSoundAliasFromList
==============
*/
void SND_PickSoundAliasFromList(const SndAliasList *aliasList, const SndPlayParams *inParams, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp, const unsigned int specType1, const unsigned int specValue1, const unsigned int specType2, const unsigned int specValue2)
{
  double v10; 
  SndEntState *entState; 
  int surfaceType; 
  int v15; 
  __int64 v16; 
  __int64 count; 
  char v18; 
  unsigned int v19; 
  SndAlias *head; 
  __int64 v21; 
  unsigned int *p_contextType; 
  __int64 v23; 
  __int64 v24; 
  int v25; 
  int v26; 
  SndAlias *v27; 
  __int64 v28; 
  unsigned __int64 *p_surfaceFlags; 
  unsigned __int64 v30; 
  signed int v31; 
  unsigned int v32; 
  char v33; 
  __int64 v34; 
  SndAlias *v35; 
  __int64 v37; 
  bool AudioZoneAtPoint; 
  __int64 v39; 
  ZoneDef *zoneA; 
  ZoneDef *zoneB; 
  bool v42; 
  SndAlias **v45; 
  SndAlias **p_aliasArrayOut; 
  int v47; 
  __int64 v48; 
  SndAlias **v49; 
  int v50; 
  unsigned int specType; 
  float v52; 
  int v53; 
  unsigned int specValue[2]; 
  ZoneDef *outZoneA; 
  ZoneDef *outZoneB; 
  SndAlias **v57; 
  unsigned int v58[2]; 
  SndAlias *aliases[64]; 
  SndAlias *aliasArrayOut; 

  entState = NULL;
  v57 = (SndAlias **)outAliasA;
  *(_QWORD *)specValue = inParams;
  *outAliasA = NULL;
  if ( outAliasB && outLerp )
  {
    *outAliasB = NULL;
    *outLerp = 0.0;
  }
  if ( !aliasList )
    return;
  surfaceType = inParams->surfaceType;
  v15 = 0;
  if ( (unsigned int)(surfaceType + 1) <= 1 )
    v16 = 0i64;
  else
    v16 = 1i64 << surfaceType;
  count = aliasList->count;
  v18 = 0;
  v53 = 0;
  v19 = 0;
  if ( (int)count <= 0 )
    goto LABEL_30;
  head = aliasList->head;
  v21 = 0i64;
  p_contextType = &head->contextType;
  while ( !p_contextType[2] )
  {
    if ( *p_contextType )
    {
      v19 = 1;
      v53 = 1;
    }
    if ( v18 || *(_QWORD *)(p_contextType + 5) )
      v18 = 1;
    ++v21;
    p_contextType += 58;
    if ( v21 >= count )
      goto LABEL_19;
  }
  v19 = 2;
  v53 = 2;
LABEL_19:
  if ( !v18 || !v16 || (int)count <= 0 )
    goto LABEL_30;
  v23 = 0i64;
  v24 = 0i64;
  while ( (v16 & head->surfaceFlags) == 0 )
  {
LABEL_26:
    ++v24;
    ++head;
    if ( v24 >= count )
      goto LABEL_29;
  }
  if ( v23 < 64 )
  {
    ++v15;
    aliases[v23++] = head;
    goto LABEL_26;
  }
  Com_PrintError(9, "Too many variants for aliaslist %s\n", aliasList->aliasName);
LABEL_29:
  if ( v15 )
    goto LABEL_38;
LABEL_30:
  v25 = aliasList->count;
  v26 = 0;
  if ( v25 <= 0 )
    goto LABEL_38;
  v27 = aliasList->head;
  v28 = 0i64;
  p_surfaceFlags = &v27->surfaceFlags;
  while ( 2 )
  {
    if ( *p_surfaceFlags )
    {
LABEL_35:
      ++v26;
      p_surfaceFlags += 29;
      if ( v26 >= v25 )
        goto LABEL_38;
      continue;
    }
    break;
  }
  if ( v28 < 64 )
  {
    ++v15;
    aliases[v28++] = &v27[v26];
    goto LABEL_35;
  }
  Com_PrintError(9, "Too many variants for aliaslist %s\n", aliasList->aliasName);
LABEL_38:
  v30 = *(_QWORD *)(*(_QWORD *)specValue + 32i64) & 0x1FFFFFFFFi64;
  if ( (v30 - 5411 <= 0x1F || v30 - 2049 <= 0x8FF || v30 <= 0x7FD || v30 - 5571 <= 0x7A120) && v30 - 2046 > 2 && v30 < 0x7B6E4 && v30 - 4353 > 0x421 && v30 - 5443 > 0x7F )
  {
    entState = g_snd.entState;
    v31 = 0;
    v32 = 0;
    while ( *(_QWORD *)(*(_QWORD *)specValue + 32i64) != entState->handle )
    {
      v33 = 0;
      v34 = 0i64;
      while ( !entState->contextTypes[v34] )
      {
        if ( ++v34 >= 3 )
          goto LABEL_53;
      }
      v33 = 1;
LABEL_53:
      if ( (signed int)(g_snd.frame - entState->lastUsed) > v31 && !v33 )
        v31 = g_snd.frame - entState->lastUsed;
      ++v32;
      ++entState;
      if ( v32 >= 0x80 )
      {
        entState = NULL;
        break;
      }
    }
  }
  v35 = aliasList->head;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+4D0h+var_480], xmm0
  }
  outZoneA = NULL;
  outZoneB = NULL;
  if ( SND_IsEntChannel3D((unsigned __int8)(v35->flags >> 10)) )
  {
    if ( entState )
      v37 = (entState->handle >> 33) & 3;
    else
      LODWORD(v37) = 0;
    AudioZoneAtPoint = CG_FindAudioZoneAtPoint((LocalClientNum_t)v37, (const vec3_t *)(*(_QWORD *)specValue + 40i64), (const ZoneDef **)&outZoneA, (const ZoneDef **)&outZoneB, &v52);
  }
  else
  {
    AudioZoneAtPoint = CG_GetCurrentAudioZone((const ZoneDef **)&outZoneA, (const ZoneDef **)&outZoneB, &v52);
  }
  if ( AudioZoneAtPoint )
  {
    zoneA = outZoneA;
    zoneB = outZoneB;
  }
  else
  {
    zoneA = NULL;
    zoneB = NULL;
    outZoneA = NULL;
    outZoneB = NULL;
  }
  v42 = v19 <= 1;
  if ( v19 == 1 && (v42 = v18 == 0, !v18) && (v42 = outAliasB == NULL, outAliasB) && (v42 = outLerp == NULL, outLerp) )
  {
    __asm
    {
      vmovss  xmm0, [rsp+4D0h+var_480]
      vmovss  [rsp+4D0h+specType], xmm0
    }
    SND_PickBlendedContextSoundAlias((const SndAlias **)aliases, v15, entState, (const vec3_t *)(*(_QWORD *)specValue + 40i64), zoneA, zoneB, *(const float *)&specType, (const SndAlias **)v57, outAliasB, outLerp);
  }
  else
  {
    __asm
    {
      vmovss  xmm0, [rsp+4D0h+var_480]
      vcomiss xmm0, cs:__real@3f000000
    }
    v45 = aliases;
    if ( !v42 )
      zoneA = zoneB;
    p_aliasArrayOut = &aliasArrayOut;
    v47 = 0;
    v58[0] = specType1;
    v58[1] = specType2;
    specValue[0] = specValue1;
    specValue[1] = specValue2;
    if ( v53 > 0 )
    {
      v48 = 0i64;
      do
      {
        v15 = SND_PickSoundAliasContext((const SndAlias **)v45, (const SndAlias **)p_aliasArrayOut, v15, v47, entState, zoneA, v58[v48], specValue[v48]);
        ++v48;
        v49 = p_aliasArrayOut;
        ++v47;
        p_aliasArrayOut = v45;
        v45 = v49;
      }
      while ( v47 < v53 );
    }
    if ( v15 )
    {
      v50 = SND_PickRandomAliasIndex((const SndAlias **)v45, v15, v39, v10);
      *v57 = v45[v50];
    }
    else
    {
      *v57 = NULL;
    }
  }
}

/*
==============
SND_PickSoundAliasFromList
==============
*/
void SND_PickSoundAliasFromList(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entityNum, const vec3_t *inOrigin, const SndAlias **outAliasA, const SndAlias **outAliasB, float *outLerp)
{
  unsigned __int64 SndEntHandle; 
  SndPlayParams inParams; 

  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vxorps  xmm1, xmm1, xmm1
    vmovups xmmword ptr [rbp+3Fh+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
  }
  inParams.aliasList = aliasList;
  inParams.aliasId = 0;
  __asm
  {
    vmovss  [rbp+3Fh+inParams.lpfCutoff], xmm0
    vmovss  [rbp+3Fh+inParams.hpfCutoff], xmm0
    vmovss  dword ptr [rbp+3Fh+inParams.org], xmm1
    vmovss  dword ptr [rbp+3Fh+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+3Fh+inParams.org+8], xmm1
    vmovss  [rbp+3Fh+inParams.startOffsetFraction], xmm1
  }
  _R14 = inOrigin;
  inParams.playbackType = SPT_BLEND;
  inParams.sndEnt = 0i64;
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entityNum);
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  xmm1, dword ptr [r14+4]
    vmovss  dword ptr [rbp+3Fh+inParams.org], xmm0
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  dword ptr [rbp+3Fh+inParams.org+8], xmm0
    vmovss  dword ptr [rbp+3Fh+inParams.org+4], xmm1
  }
  inParams.sndEnt = SndEntHandle;
  SND_PickSoundAliasFromList(aliasList, &inParams, outAliasA, outAliasB, outLerp, 0, 0, 0, 0);
}

/*
==============
SND_PlayAmbientAlias
==============
*/

void __fastcall SND_PlayAmbientAlias(LocalClientNum_t localClientNum, const char *aliasName, double volumeScale, int fadeTime, bool isExclusive, snd_alias_system_t system)
{
  const dvar_t *v14; 
  int v15; 
  SndAlias *v16; 
  unsigned int secondaryId; 
  const SndAliasList *AliasFromId; 
  int v20; 
  int v21; 
  int v22; 
  bool v23; 
  __int64 v24; 
  bool v25; 
  int v26; 
  int v27; 
  int v28; 
  SndAlias *v29; 
  int v30; 
  int AmbientTrack; 
  int v33; 
  int v34; 
  unsigned int secondaryGroupId; 
  __int64 v36; 
  int v37; 
  const SndAlias *v38; 
  SndAlias **outAliasB; 
  float outAliasBa; 
  float *outLerp; 
  unsigned int v45; 
  ScopedCriticalSection v46; 
  int fadetime; 
  LocalClientNum_t localClientNuma; 
  SndAlias *outAliasA[2]; 
  ScopedCriticalSection v50; 
  ScopedCriticalSection inOrigin[7]; 
  void *retaddr; 

  _RAX = &retaddr;
  outAliasA[1] = (SndAlias *)-2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  fadetime = fadeTime;
  __asm { vmovaps xmm7, xmm2 }
  localClientNuma = localClientNum;
  if ( g_snd.driverInitialized )
  {
    v14 = DCONST_DVARBOOL_snd_enable_capture_mode;
    if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    if ( !v14->current.enabled )
    {
      v15 = 0;
      SND_PickSoundAlias(aliasName, localClientNum, 2047, NULL, (const SndAlias **)outAliasA, NULL, NULL);
      v16 = outAliasA[0];
      if ( outAliasA[0] )
      {
        secondaryId = outAliasA[0]->secondaryId;
        v45 = secondaryId;
        __asm { vxorps  xmm6, xmm6, xmm6 }
        if ( secondaryId )
        {
          __asm
          {
            vmovss  dword ptr [rsp+0F8h+inOrigin], xmm6
            vmovss  dword ptr [rsp+0F8h+inOrigin+4], xmm6
            vmovss  dword ptr [rsp+0F8h+inOrigin+8], xmm6
          }
          AliasFromId = SND_FindAliasFromId(secondaryId);
          SND_PickSoundAliasFromList(AliasFromId, localClientNum, 2047, (const vec3_t *)inOrigin, (const SndAlias **)&v46._next, NULL, NULL);
        }
        else
        {
          v46._next = NULL;
        }
        *(_QWORD *)&v46._s = v16;
        if ( fadeTime < 0 )
        {
          LODWORD(outAliasB) = fadeTime;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6576, ASSERT_TYPE_ASSERT, "( ( fadeTime >= 0 ) )", "( fadeTime ) = %i", outAliasB) )
            __debugbreak();
        }
        if ( (g_snd.ambient_track & 0xFFFFFFFD) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6577, ASSERT_TYPE_ASSERT, "(g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_0 || g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_1)", (const char *)&queryFormat, "g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_0 || g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_1") )
          __debugbreak();
        ScopedCriticalSection::ScopedCriticalSection(&v50, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
        v20 = 0;
        v21 = -1;
        v22 = 0;
        v23 = 1;
        do
        {
          if ( !v23 )
          {
            LODWORD(outLerp) = 2;
            LODWORD(outAliasB) = v22;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6249, ASSERT_TYPE_ASSERT, "(unsigned)( number ) < (unsigned)( 2 )", "number doesn't index SND_NUM_AMBIENT_TRACKS\n\t%i not in [0, %i)", outAliasB, outLerp) )
              __debugbreak();
          }
          v24 = 80i64;
          if ( v22 )
            v24 = 82i64;
          v25 = sdGlob.voiceAlloc[v24];
          v26 = v20 + 1;
          if ( v25 )
            v26 = v20;
          v20 = v26;
          v27 = v22 != 0 ? 2 : 0;
          if ( v25 )
            v27 = v21;
          v21 = v27;
          v23 = (unsigned int)++v22 < 2;
        }
        while ( v22 < 2 );
        v28 = fadetime;
        v29 = outAliasA[0];
        if ( v26 != 2 )
        {
          v30 = 0;
          while ( 1 )
          {
            AmbientTrack = SND_GetAmbientTrack(v30);
            if ( SND_IsAliasPlayingOnTrack(v29->aliasName, AmbientTrack) )
              break;
            if ( ++v30 >= 2 )
              goto LABEL_31;
          }
          __asm { vmovaps xmm1, xmm7; volumeScale }
          SND_SetBackgroundTrackVolumeScale(AmbientTrack, *(float *)&_XMM1, v28);
          if ( !isExclusive )
            goto LABEL_74;
          if ( AmbientTrack )
          {
            if ( AmbientTrack != 2 )
              goto LABEL_74;
            SND_StopBackground(0, v28);
            SND_StopBackground(1, v28);
            if ( v45 )
              goto LABEL_74;
            ScopedCriticalSection::ScopedCriticalSection(&v46, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
            if ( sdGlob.voiceAlloc[83] )
            {
              SND_DebugAliasPrint(g_snd.voices[83].alias != NULL, g_snd.voices[83].alias, "Stop voice requested by SND_StopBackground()");
              SND_StopVoice(83);
            }
          }
          else
          {
            SND_StopBackground(2, v28);
            SND_StopBackground(3, v28);
            if ( v45 )
            {
LABEL_74:
              ScopedCriticalSection::~ScopedCriticalSection(&v50);
              goto LABEL_75;
            }
            ScopedCriticalSection::ScopedCriticalSection(&v46, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
            if ( sdGlob.voiceAlloc[81] )
            {
              SND_DebugAliasPrint(g_snd.voices[81].alias != NULL, g_snd.voices[81].alias, "Stop voice requested by SND_StopBackground()");
              SND_StopVoice(81);
            }
          }
          ScopedCriticalSection::~ScopedCriticalSection(&v46);
          goto LABEL_74;
        }
LABEL_31:
        if ( (v29->flags & 2) != 0 )
        {
          *(double *)&_XMM0 = I_random();
          __asm { vmovaps xmm6, xmm0 }
        }
        if ( isExclusive )
        {
          if ( !v20 )
          {
            ScopedCriticalSection::ScopedCriticalSection(inOrigin, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
            if ( v21 )
            {
              if ( sdGlob.voiceAlloc[80] )
              {
                SND_DebugAliasPrint(g_snd.voices[80].alias != NULL, g_snd.voices[80].alias, "Stop voice requested by SND_StopBackground()");
                SND_StopVoice(80);
              }
              ScopedCriticalSection::~ScopedCriticalSection(inOrigin);
              ScopedCriticalSection::ScopedCriticalSection(inOrigin, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
              if ( sdGlob.voiceAlloc[81] )
              {
                SND_DebugAliasPrint(g_snd.voices[81].alias != NULL, g_snd.voices[81].alias, "Stop voice requested by SND_StopBackground()");
                SND_StopVoice(81);
              }
              ScopedCriticalSection::~ScopedCriticalSection(inOrigin);
              SND_StopBackground(2, v28);
              SND_StopBackground(3, v28);
              v21 = 0;
            }
            else
            {
              if ( sdGlob.voiceAlloc[82] )
              {
                SND_DebugAliasPrint(g_snd.voices[82].alias != NULL, g_snd.voices[82].alias, "Stop voice requested by SND_StopBackground()");
                SND_StopVoice(82);
              }
              ScopedCriticalSection::~ScopedCriticalSection(inOrigin);
              ScopedCriticalSection::ScopedCriticalSection(inOrigin, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
              if ( sdGlob.voiceAlloc[83] )
              {
                SND_DebugAliasPrint(g_snd.voices[83].alias != NULL, g_snd.voices[83].alias, "Stop voice requested by SND_StopBackground()");
                SND_StopVoice(83);
              }
              ScopedCriticalSection::~ScopedCriticalSection(inOrigin);
              SND_StopBackground(0, v28);
              SND_StopBackground(1, v28);
              v21 = 2;
            }
            goto LABEL_67;
          }
          if ( v20 == 1 )
          {
            if ( !v21 )
            {
              SND_StopBackground(2, v28);
              SND_StopBackground(3, v28);
LABEL_67:
              secondaryGroupId = g_snd.secondaryGroupCounter;
              do
                ++secondaryGroupId;
              while ( !secondaryGroupId );
              g_snd.secondaryGroupCounter = secondaryGroupId;
              v36 = 0i64;
              v37 = v21;
              do
              {
                v38 = (const SndAlias *)*((_QWORD *)&v46._s + v36);
                if ( v38 )
                {
                  __asm
                  {
                    vmovss  dword ptr [rsp+0F8h+outAliasB], xmm6
                    vmovaps xmm3, xmm7; startVolumeScale
                  }
                  SND_StartBackground(localClientNuma, v37, v38, *(float *)&_XMM3, v28, outAliasBa, system, secondaryGroupId);
                  g_snd.ambient_track = v21;
                  ++v15;
                }
                ++v37;
                ++v36;
              }
              while ( v36 < 2 );
              SD_SetSecondaryGroupInfo(v21 + 80, v15);
              SND_UnpauseVoiceThatWasStartedPaused(v21 + 80);
              SND_UnpauseVoiceThatWasStartedPaused(v21 + 81);
              goto LABEL_74;
            }
            SND_StopBackground(0, v28);
            v33 = v28;
            v34 = 1;
            goto LABEL_63;
          }
        }
        else if ( !v20 )
        {
          v21 = g_snd.ambient_track != 0 ? 2 : 0;
          v33 = 0;
          v34 = v21;
LABEL_63:
          SND_StopBackground(v34, v33);
        }
        if ( v21 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6682, ASSERT_TYPE_ASSERT, "(freeTrack != (-1))", (const char *)&queryFormat, "freeTrack != SND_TRACK_NONE") )
          __debugbreak();
        goto LABEL_67;
      }
    }
  }
LABEL_75:
  __asm
  {
    vmovaps xmm6, [rsp+0F8h+var_48]
    vmovaps xmm7, [rsp+0F8h+var_58]
  }
}

/*
==============
SND_PlayAmbientAliasBlended
==============
*/

void __fastcall SND_PlayAmbientAliasBlended(LocalClientNum_t localClientNum, const char *aliasNameFrom, const char *aliasNameTo, double lerp, bool isExclusive, snd_alias_system_t system)
{
  SndAlias *v15; 
  __int64 v16; 
  const dvar_t *v17; 
  int v18; 
  int v21; 
  int v22; 
  int v23; 
  bool v24; 
  int v25; 
  __int64 v26; 
  unsigned int secondaryId; 
  const SndAliasList *AliasFromId; 
  LocalClientNum_t v32; 
  unsigned int v33; 
  const SndAliasList *v34; 
  unsigned int v35; 
  __int64 v37; 
  unsigned int secondaryGroupId; 
  __int64 v42; 
  unsigned int started; 
  int v50; 
  SndAlias **outAliasB; 
  float outAliasBa; 
  float outAliasBb; 
  float *outLerp; 
  SndAlias *outAliasA; 
  SndAlias *v61; 
  SndAlias *v62; 
  int v63; 
  int v65; 
  __int64 v66; 
  SndAlias *v67; 
  char v68; 
  int v70; 
  __int64 v71; 
  ScopedCriticalSection v72; 
  vec3_t inOrigin; 
  char v74; 
  void *retaddr; 

  _RAX = &retaddr;
  v71 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmm6, xmm3
  }
  v15 = NULL;
  outAliasA = NULL;
  v16 = 0i64;
  *(_QWORD *)inOrigin.v = 0i64;
  if ( g_snd.driverInitialized )
  {
    v17 = DCONST_DVARBOOL_snd_enable_capture_mode;
    if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v17);
    if ( !v17->current.enabled )
    {
      if ( aliasNameFrom )
      {
        SND_PickSoundAlias(aliasNameFrom, localClientNum, 2046, NULL, (const SndAlias **)&outAliasA, NULL, NULL);
        v15 = outAliasA;
      }
      if ( aliasNameTo )
      {
        SND_PickSoundAlias(aliasNameTo, localClientNum, 2046, NULL, (const SndAlias **)&inOrigin, NULL, NULL);
        v16 = *(_QWORD *)inOrigin.v;
      }
      ScopedCriticalSection::ScopedCriticalSection(&v72, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
      if ( (g_snd.ambient_track & 0xFFFFFFFD) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6395, ASSERT_TYPE_ASSERT, "(g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_0 || g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_1)", (const char *)&queryFormat, "g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_0 || g_snd.ambient_track == SND_TRACK_AMBIENT_PRIMARY_1") )
        __debugbreak();
      v18 = 0;
      __asm
      {
        vmovss  xmm8, cs:__real@3f800000
        vsubss  xmm7, xmm8, xmm6
      }
      LOBYTE(v63) = 0;
      v68 = 0;
      v21 = -1;
      v65 = -1;
      v70 = -1;
      v22 = -1;
      v23 = 0;
      v24 = 1;
      while ( 1 )
      {
        if ( !v24 )
        {
          LODWORD(outLerp) = 2;
          LODWORD(outAliasB) = v23;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6249, ASSERT_TYPE_ASSERT, "(unsigned)( number ) < (unsigned)( 2 )", "number doesn't index SND_NUM_AMBIENT_TRACKS\n\t%i not in [0, %i)", outAliasB, outLerp) )
            __debugbreak();
        }
        v25 = v23 != 0 ? 2 : 0;
        v26 = 80i64;
        if ( v23 )
          v26 = 82i64;
        if ( !sdGlob.voiceAlloc[v26] )
          break;
        if ( v15 && SND_IsAliasPlayingOnTrack(v15->aliasName, v25) && v21 == -1 )
        {
          v21 = v23 != 0 ? 2 : 0;
          ++v18;
          LOBYTE(v63) = 1;
LABEL_29:
          v25 = v70;
          goto LABEL_30;
        }
        if ( !v16 || !SND_IsAliasPlayingOnTrack(*(const char **)v16, v25) || v70 != -1 )
          break;
        v70 = v23 != 0 ? 2 : 0;
        ++v18;
        v68 = 1;
LABEL_30:
        v24 = (unsigned int)++v23 < 2;
        if ( v23 >= 2 )
        {
          v65 = v21;
          if ( v15 == (SndAlias *)v16 && v18 > 0 )
          {
            __asm
            {
              vmovaps xmm7, xmm8
              vmovaps xmm6, xmm8
            }
            v18 = 2;
          }
          if ( v21 != -1 )
          {
            __asm { vmovaps xmm1, xmm7; volumeScale }
            SND_SetBackgroundTrackVolumeScale(v21, *(float *)&_XMM1, 0);
          }
          if ( v25 != -1 )
          {
            __asm { vmovaps xmm1, xmm6; volumeScale }
            SND_SetBackgroundTrackVolumeScale(v25, *(float *)&_XMM1, 0);
          }
          if ( v18 < 2 )
          {
            __asm
            {
              vmovss  [rsp+130h+var_CC], xmm7
              vmovss  [rbp+47h+var_AC], xmm6
            }
            v61 = v15;
            __asm
            {
              vxorps  xmm8, xmm8, xmm8
              vmovss  dword ptr [rbp+47h+inOrigin], xmm8
              vmovss  dword ptr [rbp+47h+inOrigin+4], xmm8
              vmovss  dword ptr [rbp+47h+inOrigin+8], xmm8
            }
            if ( v15 && (secondaryId = v15->secondaryId) != 0 )
            {
              AliasFromId = SND_FindAliasFromId(secondaryId);
              v32 = localClientNum;
              SND_PickSoundAliasFromList(AliasFromId, localClientNum, 2047, &inOrigin, (const SndAlias **)&v62, NULL, NULL);
            }
            else
            {
              v62 = NULL;
              v32 = localClientNum;
            }
            v66 = v16;
            if ( v16 && (v33 = *(_DWORD *)(v16 + 36)) != 0 )
            {
              v34 = SND_FindAliasFromId(v33);
              SND_PickSoundAliasFromList(v34, v32, 2047, &inOrigin, (const SndAlias **)&v67, NULL, NULL);
            }
            else
            {
              v67 = NULL;
            }
            if ( v22 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6492, ASSERT_TYPE_ASSERT, "(trackToPlay != (-1))", (const char *)&queryFormat, "trackToPlay != SND_TRACK_NONE") )
              __debugbreak();
            v35 = 0;
            _RSI = (__int64 *)&v61;
            do
            {
              v37 = *_RSI;
              if ( *_RSI )
              {
                if ( (*(_BYTE *)(v37 + 112) & 2) != 0 )
                {
                  *(double *)&_XMM0 = I_random();
                  __asm { vmovaps xmm6, xmm0 }
                }
                else
                {
                  __asm { vmovaps xmm6, xmm8 }
                }
                if ( !*((_BYTE *)_RSI + 16) )
                {
                  secondaryGroupId = g_snd.secondaryGroupCounter;
                  do
                    ++secondaryGroupId;
                  while ( !secondaryGroupId );
                  g_snd.secondaryGroupCounter = secondaryGroupId;
                  __asm
                  {
                    vmovss  xmm7, dword ptr [rsi+14h]
                    vmovss  dword ptr [rsp+130h+outAliasB], xmm6
                    vmovaps xmm3, xmm7; startVolumeScale
                  }
                  if ( SND_StartBackground(v32, v22, (const SndAlias *)v37, *(float *)&_XMM3, 0, outAliasBa, system, secondaryGroupId) && (v42 = _RSI[1]) != 0 )
                  {
                    _ECX = 0;
                    __asm { vmovd   xmm1, ecx }
                    _EAX = *(_BYTE *)(v42 + 112) & 2;
                    __asm
                    {
                      vmovd   xmm0, eax
                      vpcmpeqd xmm2, xmm0, xmm1
                      vblendvps xmm0, xmm6, xmm8, xmm2
                      vmovss  dword ptr [rsp+130h+outAliasB], xmm0
                      vmovaps xmm3, xmm7; startVolumeScale
                    }
                    started = SND_StartBackground(v32, v22 + 1, (const SndAlias *)v42, *(float *)&_XMM3, 0, outAliasBb, system, secondaryGroupId);
                    v50 = v22 + 80;
                    if ( started )
                    {
                      SD_SetSecondaryGroupInfo(v50, 1);
                      SND_UnpauseVoiceThatWasStartedPaused(v22 + 81);
                    }
                    SND_UnpauseVoiceThatWasStartedPaused(v50);
                  }
                  else
                  {
                    SND_UnpauseVoiceThatWasStartedPaused(v22 + 80);
                    SND_StopBackground(v22 + 1, 0);
                  }
                  g_snd.ambient_track = v22;
                }
              }
              ++v35;
              _RSI += 4;
            }
            while ( v35 < 2 );
          }
          ScopedCriticalSection::~ScopedCriticalSection(&v72);
          goto LABEL_67;
        }
      }
      v22 = v23 != 0 ? 2 : 0;
      goto LABEL_29;
    }
  }
LABEL_67:
  _R11 = &v74;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
  }
}

/*
==============
SND_PlayAmbientElement
==============
*/
void SND_PlayAmbientElement(const LocalClientNum_t localClientNum, const AmbientElement *elem)
{
  __int64 v9; 
  char v14; 
  char v15; 
  const SndAliasList *Alias; 
  unsigned __int64 SndEntHandle; 
  int v26; 
  int v28; 
  int *p_playTime; 
  int v33; 
  const AmbientDef *ambientDef; 
  float volume[4]; 
  SndPlayParams inParams; 
  vec3_t angles; 
  vec3_t forward; 
  char v49; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovss  xmm1, dword ptr [rdx+1Ch]; max
    vmovss  xmm0, dword ptr [rdx+18h]; min
  }
  _RBX = elem;
  v9 = localClientNum;
  *(double *)&_XMM0 = I_flrand(*(float *)&_XMM0, *(float *)&_XMM1);
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+24h]
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm1, xmm6
    vmovaps xmm7, xmm0
  }
  if ( v14 | v15 )
  {
    __asm
    {
      vmovss  xmm1, cs:__real@43b40000; max
      vxorps  xmm0, xmm0, xmm0; min
    }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rbx+20h] }
  }
  *(double *)&_XMM0 = I_flrand(*(float *)&_XMM0, *(float *)&_XMM1);
  __asm
  {
    vmovss  dword ptr [rbp+40h+angles], xmm6
    vmovss  dword ptr [rbp+40h+angles+4], xmm0
    vmovss  dword ptr [rbp+40h+angles+8], xmm6
  }
  AngleVectors(&angles, &forward, NULL, NULL);
  __asm
  {
    vmulss  xmm8, xmm7, dword ptr [rbp+40h+forward]
    vmulss  xmm9, xmm7, dword ptr [rbp+40h+forward+4]
    vmulss  xmm7, xmm7, dword ptr [rbp+40h+forward+8]
  }
  Alias = SND_FindAlias(_RBX->aliasName);
  if ( Alias )
  {
    SndEntHandle = CG_GenerateSndEntHandle((const LocalClientNum_t)v9, (int)v9 + 4353);
    CG_GetLocalClientGlobals((const LocalClientNum_t)v9);
    __asm
    {
      vaddss  xmm3, xmm8, dword ptr [rcx+rax]
      vaddss  xmm2, xmm9, dword ptr [rcx+rax+4]
      vaddss  xmm1, xmm7, dword ptr [rcx+rax+8]
      vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    }
    v26 = 0;
    inParams.playbackType = SPT_BLEND;
    __asm
    {
      vmovups xmmword ptr [rsp+140h+inParams.volumeScale], xmm0
      vmovss  xmm0, cs:__real@bf800000
    }
    inParams.aliasId = 0;
    inParams.timeshift = 0;
    __asm
    {
      vmovss  [rbp+40h+inParams.lpfCutoff], xmm0
      vmovss  [rbp+40h+inParams.hpfCutoff], xmm0
      vmovss  [rbp+40h+inParams.startOffsetFraction], xmm6
      vmovss  dword ptr [rsp+140h+inParams.org], xmm3
      vmovss  dword ptr [rsp+140h+inParams.org+4], xmm2
      vmovss  dword ptr [rsp+140h+inParams.org+8], xmm1
    }
    inParams.adsrIndex = -1;
    inParams.fadeTime = 0;
    inParams.system = SASYS_CGAME;
    inParams.autoSimId = -1;
    inParams.autoSimTimeStamp = 0i64;
    inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
    inParams.startPaused = 0;
    inParams.additionalStartDelayUs = 0;
    *(_QWORD *)&inParams.surfaceType = -1i64;
    inParams.contextIndex2 = -1;
    inParams.reflectionClass = 0;
    *(_WORD *)&inParams.isADS = 0;
    inParams.aliasList = Alias;
    inParams.sndEnt = SndEntHandle;
    v28 = SND_PlaySoundAliasFromParams(&inParams, 0);
    _RDI = v9;
    _R15 = g_ambGlob;
    g_ambGlob[_RDI].playbackId = v28;
    if ( v28 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [r15+rdi*8+28h]
        vmovss  [rsp+140h+volume], xmm0
      }
      SND_SetEntityParamInfoData(SndEntHandle, NULL, volume, 1000);
      p_playTime = &g_ambGlob[_RDI].playTime;
      SND_GetLengthMS(g_ambGlob[_RDI].playbackId, p_playTime);
      v33 = *p_playTime;
      g_ambGlob[_RDI].playTimeFound = *p_playTime != 0;
      ambientDef = g_ambGlob[_RDI].ambientDef;
      *p_playTime = g_snd.time + v33;
      if ( ambientDef )
      {
        __asm
        {
          vmovss  xmm2, cs:__real@447a0000
          vmulss  xmm0, xmm2, dword ptr [rax+14h]
          vmulss  xmm2, xmm2, dword ptr [rax+10h]
          vcvttss2si ecx, xmm2; min
          vcvttss2si edx, xmm0; max
        }
        v26 = *p_playTime + I_irand(_ECX, _EDX);
      }
      g_ambGlob[_RDI].nextPlayTime = v26;
      g_ambGlob[_RDI].lastPlayedElem = _RBX;
    }
  }
  else
  {
    Com_PrintError(9, "Unable to find Ambient Event sound alias (%s).\n", _RBX->aliasName);
  }
  _R11 = &v49;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
  }
}

/*
==============
SND_PlayBlendedSoundAlias
==============
*/
unsigned int SND_PlayBlendedSoundAlias(const SndAliasList *aliasList0, const SndAliasList *aliasList1, const float lerp, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  float v13; 
  float v14; 

  __asm
  {
    vmovss  xmm0, [rsp+68h+pitch]
    vmovss  xmm1, [rsp+68h+volumeScale]
    vmovss  [rsp+68h+var_38], xmm0
    vmovss  [rsp+68h+var_40], xmm1
  }
  return SND_PlayBlendedSoundAlias_Internal(aliasList0, aliasList1, lerp, localClientNum, entnum, v13, v14, org, timeshift, system, 0);
}

/*
==============
SND_PlayBlendedSoundAliasAsync
==============
*/
void SND_PlayBlendedSoundAliasAsync(const SndAliasList *aliasList0, const SndAliasList *aliasList1, const float lerp, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  float v12; 
  float v13; 

  __asm
  {
    vmovss  xmm0, [rsp+68h+pitch]
    vmovss  xmm1, [rsp+68h+volumeScale]
    vmovss  [rsp+68h+var_38], xmm0
    vmovss  [rsp+68h+var_40], xmm1
  }
  SND_PlayBlendedSoundAlias_Internal(aliasList0, aliasList1, lerp, localClientNum, entnum, v12, v13, org, timeshift, system, 1);
}

/*
==============
SND_PlayBlendedSoundAlias_Internal
==============
*/
unsigned int SND_PlayBlendedSoundAlias_Internal(const SndAliasList *aliasList0, const SndAliasList *aliasList1, const float lerp, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system, bool deferred)
{
  unsigned __int64 SndEntHandle; 
  unsigned int result; 
  float v45; 
  char v46; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
  }
  if ( aliasList0 && aliasList1 )
  {
    _R8 = aliasList0->head;
    _RAX = aliasList1->head;
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vsubss  xmm3, xmm0, xmm2
      vmovss  xmm7, dword ptr [r8+4Ch]
      vmovss  xmm6, dword ptr [rax+4Ch]
      vmovss  xmm10, dword ptr [r8+58h]
      vmovss  xmm11, dword ptr [rax+58h]
      vmulss  xmm1, xmm7, xmm3
      vmulss  xmm0, xmm6, xmm2
      vaddss  xmm8, xmm1, xmm0
      vmulss  xmm1, xmm10, xmm3
      vxorps  xmm3, xmm3, xmm3
      vucomiss xmm7, xmm3
      vmulss  xmm0, xmm11, xmm2
      vaddss  xmm9, xmm1, xmm0
    }
    SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entnum);
    __asm
    {
      vdivss  xmm0, xmm9, xmm10
      vdivss  xmm3, xmm8, xmm7; volumeScale
      vmovss  [rsp+0B8h+var_98], xmm0
    }
    result = SND_PlayScaledSoundAlias_Internal(aliasList0, 0, SndEntHandle, *(const float *)&_XMM3, v45, org, timeshift, system, deferred);
  }
  else
  {
    result = 0;
  }
  _R11 = &v46;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
  return result;
}

/*
==============
SND_PlayContextBlendAliasCore
==============
*/

unsigned int __fastcall SND_PlayContextBlendAliasCore(const SndAlias *aliasA, const SndAlias *aliasB, double volumeLerp, const SndPlayParams *inPlayParams)
{
  unsigned int result; 

  __asm
  {
    vmovaps [rsp+38h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  if ( aliasA || aliasB )
  {
    result = 0;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm6, xmm0
      vmovss  xmm0, cs:__real@3f800000
      vcomiss xmm6, xmm0
      vmovaps xmm6, [rsp+38h+var_18]
    }
  }
  else
  {
    result = 0;
    __asm { vmovaps xmm6, [rsp+38h+var_18] }
  }
  return result;
}

/*
==============
SND_PlayContextSound
==============
*/
unsigned int SND_PlayContextSound(const SndAliasList *aliasList, const int surfaceType, const int contextIndex, const int contextIndex2, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org)
{
  float v12; 
  float v13; 

  __asm
  {
    vmovss  xmm0, [rsp+58h+pitch]
    vmovss  xmm1, [rsp+58h+volumeScale]
    vmovss  [rsp+58h+var_20], xmm0
    vmovss  [rsp+58h+var_28], xmm1
  }
  return SND_PlayContextSound_Internal(aliasList, surfaceType, contextIndex, contextIndex2, localClientNum, entnum, v12, v13, org, 0);
}

/*
==============
SND_PlayContextSoundAsync
==============
*/
void SND_PlayContextSoundAsync(const SndAliasList *aliasList, const int surfaceType, const int contextIndex, const int contextIndex2, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org)
{
  float v11; 
  float v12; 

  __asm
  {
    vmovss  xmm0, [rsp+58h+pitch]
    vmovss  xmm1, [rsp+58h+volumeScale]
    vmovss  [rsp+58h+var_20], xmm0
    vmovss  [rsp+58h+var_28], xmm1
  }
  SND_PlayContextSound_Internal(aliasList, surfaceType, contextIndex, contextIndex2, localClientNum, entnum, v11, v12, org, 1);
}

/*
==============
SND_PlayContextSound_Internal
==============
*/
unsigned int SND_PlayContextSound_Internal(const SndAliasList *aliasList, int surfaceType, const int contextIndex, const int contextIndex2, const LocalClientNum_t localClientNum, const int entnum, float volumeScale, float pitch, const vec3_t *org, bool deferred)
{
  SndPlayParams inParams; 

  __asm { vmovss  xmm0, cs:__real@3f800000 }
  inParams.surfaceType = surfaceType;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovss  [rbp+27h+inParams.distanceScale], xmm0
    vmovss  [rbp+27h+inParams.lfeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+27h+inParams.lpfCutoff], xmm0
    vmovss  [rbp+27h+inParams.hpfCutoff], xmm0
    vmovss  xmm0, [rbp+27h+volumeScale]
    vmovss  dword ptr [rbp+27h+inParams.org], xmm1
    vmovss  dword ptr [rbp+27h+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+27h+inParams.org+8], xmm1
    vmovss  [rbp+27h+inParams.startOffsetFraction], xmm1
    vmovss  xmm1, [rbp+27h+pitch]
  }
  inParams.aliasList = aliasList;
  __asm
  {
    vmovss  [rbp+27h+inParams.volumeScale], xmm0
    vmovss  [rbp+27h+inParams.pitch], xmm1
  }
  inParams.aliasId = 0;
  inParams.playbackType = SPT_CONTEXT;
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  inParams.sndEnt = CG_GenerateSndEntHandle(localClientNum, entnum);
  _RAX = org;
  inParams.contextIndex = contextIndex;
  inParams.contextIndex2 = contextIndex2;
  __asm
  {
    vmovss  xmm0, dword ptr [rax]
    vmovss  xmm1, dword ptr [rax+4]
    vmovss  dword ptr [rbp+27h+inParams.org], xmm0
    vmovss  xmm0, dword ptr [rax+8]
    vmovss  dword ptr [rbp+27h+inParams.org+8], xmm0
    vmovss  dword ptr [rbp+27h+inParams.org+4], xmm1
  }
  return SND_PlaySoundAliasFromParams(&inParams, deferred);
}

/*
==============
SND_PlayExplosionSound
==============
*/
unsigned int SND_PlayExplosionSound(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, const vec3_t *org, const unsigned int reflectionClass)
{
  return SND_PlayExplosionSound_Internal(aliasList, 0, surfaceType, sndEnt, org, reflectionClass, 0);
}

/*
==============
SND_PlayExplosionSoundAsync
==============
*/
void SND_PlayExplosionSoundAsync(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, const vec3_t *org, const unsigned int reflectionClass)
{
  SND_PlayExplosionSound_Internal(aliasList, 0, surfaceType, sndEnt, org, reflectionClass, 1);
}

/*
==============
SND_PlayExplosionSound_Internal
==============
*/
unsigned int SND_PlayExplosionSound_Internal(const SndAliasList *aliasList, const unsigned int aliasId, const int surfaceType, const unsigned __int64 sndEnt, const vec3_t *org, const unsigned int reflectionClass, bool deferred)
{
  int v20; 
  SndPlayParams inParams; 

  if ( (unsigned int)surfaceType >= 0x40 )
  {
    v20 = 64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5840, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( 64 )", "surfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", surfaceType, v20) )
      __debugbreak();
  }
  __asm { vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000 }
  inParams.playbackType = SPT_EXPLOSION;
  __asm
  {
    vmovups xmmword ptr [rbp+3Fh+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+3Fh+inParams.lpfCutoff], xmm0
    vmovss  [rbp+3Fh+inParams.hpfCutoff], xmm0
    vxorps  xmm0, xmm0, xmm0
  }
  inParams.timeshift = 0;
  inParams.fadeTime = 0;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  *(_WORD *)&inParams.isADS = 0;
  _RAX = org;
  __asm { vmovss  [rbp+3Fh+inParams.startOffsetFraction], xmm0 }
  inParams.adsrIndex = -1;
  inParams.system = SASYS_CGAME;
  __asm
  {
    vmovss  xmm0, dword ptr [rax]
    vmovss  xmm1, dword ptr [rax+4]
    vmovss  dword ptr [rbp+3Fh+inParams.org], xmm0
    vmovss  xmm0, dword ptr [rax+8]
    vmovss  dword ptr [rbp+3Fh+inParams.org+8], xmm0
  }
  inParams.reflectionClass = reflectionClass;
  __asm { vmovss  dword ptr [rbp+3Fh+inParams.org+4], xmm1 }
  inParams.autoSimId = -1;
  *(_QWORD *)&inParams.contextIndex = -1i64;
  inParams.aliasList = aliasList;
  inParams.aliasId = aliasId;
  inParams.sndEnt = sndEnt;
  inParams.surfaceType = surfaceType;
  return SND_PlaySoundAliasFromParams(&inParams, deferred);
}

/*
==============
SND_PlayLocalSoundAlias
==============
*/
unsigned int SND_PlayLocalSoundAlias(LocalClientNum_t localClientNum, const char *aliasname, snd_alias_system_t system)
{
  unsigned int AliasId; 

  AliasId = SND_FindAliasId(aliasname);
  return SND_PlayLocalSoundAlias_Internal(localClientNum, NULL, AliasId, system, 0);
}

/*
==============
SND_PlayLocalSoundAlias
==============
*/
unsigned int SND_PlayLocalSoundAlias(LocalClientNum_t localClientNum, const SndAliasList *aliasList, snd_alias_system_t system)
{
  return SND_PlayLocalSoundAlias_Internal(localClientNum, aliasList, 0, system, 0);
}

/*
==============
SND_PlayLocalSoundAliasAsync
==============
*/
void SND_PlayLocalSoundAliasAsync(LocalClientNum_t localClientNum, const char *aliasname, snd_alias_system_t system)
{
  unsigned int AliasId; 

  AliasId = SND_FindAliasId(aliasname);
  SND_PlayLocalSoundAlias_Internal(localClientNum, NULL, AliasId, system, 1);
}

/*
==============
SND_PlayLocalSoundAliasAsync
==============
*/
void SND_PlayLocalSoundAliasAsync(LocalClientNum_t localClientNum, const SndAliasList *aliasList, snd_alias_system_t system)
{
  SND_PlayLocalSoundAlias_Internal(localClientNum, aliasList, 0, system, 1);
}

/*
==============
SND_PlayLocalSoundAlias_Internal
==============
*/
unsigned int SND_PlayLocalSoundAlias_Internal(LocalClientNum_t localClientNum, const SndAliasList *aliasList, const unsigned int aliasId, snd_alias_system_t system, bool deferred)
{
  unsigned __int64 SndEntHandle; 
  __int64 v18; 
  __int64 v20; 
  int v21; 
  SndPlayParams inParams; 
  snd_listener outListener; 

  if ( (unsigned int)system >= SASYS_COUNT )
  {
    v21 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5878, ASSERT_TYPE_ASSERT, "(unsigned)( system ) < (unsigned)( SASYS_COUNT )", "system doesn't index SASYS_COUNT\n\t%i not in [0, %i)", system, v21) )
      __debugbreak();
  }
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    LODWORD(v20) = 2;
    LODWORD(v18) = localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5879, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v18, v20) )
      __debugbreak();
  }
  SND_GetListener(localClientNum, &outListener);
  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vxorps  xmm1, xmm1, xmm1
    vmovups xmmword ptr [rsp+170h+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
  }
  inParams.playbackType = SPT_BLEND;
  __asm
  {
    vmovss  [rbp+70h+inParams.lpfCutoff], xmm0
    vmovss  [rbp+70h+inParams.hpfCutoff], xmm0
    vmovss  dword ptr [rsp+170h+inParams.org], xmm1
    vmovss  dword ptr [rsp+170h+inParams.org+4], xmm1
    vmovss  dword ptr [rsp+170h+inParams.org+8], xmm1
    vmovss  [rbp+70h+inParams.startOffsetFraction], xmm1
  }
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  inParams.aliasList = aliasList;
  inParams.aliasId = aliasId;
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, outListener.playerStateClientNum);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+70h+outListener.orient.origin]
    vmovss  xmm1, dword ptr [rbp+70h+outListener.orient.origin+4]
    vmovss  dword ptr [rsp+170h+inParams.org], xmm0
    vmovss  xmm0, dword ptr [rbp+70h+outListener.orient.origin+8]
    vmovss  dword ptr [rsp+170h+inParams.org+8], xmm0
    vmovss  dword ptr [rsp+170h+inParams.org+4], xmm1
  }
  inParams.sndEnt = SndEntHandle;
  inParams.system = system;
  return SND_PlaySoundAliasFromParams(&inParams, deferred);
}

/*
==============
SND_PlayLocal_f
==============
*/

void __fastcall SND_PlayLocal_f(double _XMM0_8)
{
  int v10; 
  int v11; 
  int v12; 
  const char *v13; 
  const char *v24; 
  SndAliasList *Alias; 
  const char *v26; 
  SndAlias *head; 
  const char *v34; 
  const char *v41; 
  double timeshift; 
  int timeshifta; 
  double system; 
  vec3_t org; 
  vec3_t v51; 
  vec3_t forward; 
  vec3_t angles; 
  snd_listener outListener; 
  char vars0; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovss  xmm9, cs:__real@42c80000
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm7, xmm7, xmm7
    vxorps  xmm8, xmm8, xmm8
  }
  v10 = Cmd_Argc() - 2;
  if ( v10 )
  {
    v11 = v10 - 1;
    if ( v11 )
    {
      v12 = v11 - 1;
      if ( v12 )
      {
        if ( v12 != 1 )
        {
          v13 = Cmd_Argv(0);
          Com_Printf(0, "USAGE: %s <sndalias> [<dist> <yaw> <pitch>]\n", v13);
          goto LABEL_14;
        }
        _XMM0_8 = Cmd_ArgFloat(4);
        __asm { vmovaps xmm8, xmm0 }
      }
      _XMM0_8 = Cmd_ArgFloat(3);
      __asm { vmovaps xmm7, xmm0 }
    }
    _XMM0_8 = Cmd_ArgFloat(2);
    __asm { vmovaps xmm9, xmm0 }
  }
  SND_GetListener(LOCAL_CLIENT_0, &outListener);
  __asm
  {
    vxorps  xmm1, xmm7, cs:__xmm@80000000800000008000000080000000
    vxorps  xmm2, xmm8, cs:__xmm@80000000800000008000000080000000
    vmovss  dword ptr [rsp+150h+var_100+4], xmm1
    vmovss  dword ptr [rsp+150h+var_100], xmm2
    vmovss  dword ptr [rsp+150h+var_100+8], xmm6
  }
  AxisToAngles(&outListener.orient.axis, &angles);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+150h+var_100+4]
    vaddss  xmm1, xmm0, dword ptr [rsp+150h+angles+4]
    vmovss  dword ptr [rsp+150h+var_100+4], xmm1
  }
  AngleVectors(&v51, &forward, NULL, NULL);
  __asm
  {
    vmulss  xmm1, xmm9, dword ptr [rsp+150h+forward]
    vaddss  xmm2, xmm1, dword ptr [rbp+50h+outListener.orient.origin]
    vmulss  xmm1, xmm9, dword ptr [rsp+150h+forward+4]
    vmovss  dword ptr [rsp+150h+org], xmm2
    vaddss  xmm2, xmm1, dword ptr [rbp+50h+outListener.orient.origin+4]
    vmulss  xmm1, xmm9, dword ptr [rsp+150h+forward+8]
    vmovss  dword ptr [rsp+150h+org+4], xmm2
    vaddss  xmm2, xmm1, dword ptr [rbp+50h+outListener.orient.origin+8]
    vmovss  dword ptr [rsp+150h+org+8], xmm2
  }
  v24 = Cmd_Argv(1);
  Alias = SND_FindAlias(v24);
  if ( Alias )
  {
    head = Alias->head;
    if ( (head->flags & 1) != 0 )
    {
      Com_PrintError(14, "Unable to play: '%s' is a looping alias.\n", head->aliasName);
    }
    else
    {
      SND_PlaySoundAlias(Alias, LOCAL_CLIENT_0, 2047, &org, 0, SASYS_CGAME);
      __asm
      {
        vmovss  xmm6, dword ptr [rsp+150h+org+8]
        vmovss  xmm7, dword ptr [rsp+150h+org+4]
        vmovss  xmm8, dword ptr [rsp+150h+org]
        vcvtss2sd xmm6, xmm6, xmm6
        vcvtss2sd xmm7, xmm7, xmm7
        vcvtss2sd xmm8, xmm8, xmm8
      }
      v34 = Cmd_Argv(1);
      __asm
      {
        vmovaps xmm3, xmm8
        vmovq   r9, xmm3
        vmovsd  [rsp+150h+system], xmm6
        vmovsd  qword ptr [rsp+150h+timeshift], xmm7
      }
      Com_Printf(14, "Playing local sound alias \"%s\" at (%.2f, %.2f, %.2f).\n", v34, *(double *)&_XMM3, timeshift, system);
      __asm
      {
        vcmpltss xmm2, xmm9, cs:__real@43c80000
        vmovss  xmm1, cs:__real@3f000000
        vmovss  xmm0, cs:__real@3fc00000
        vblendvps xmm6, xmm0, xmm1, xmm2
      }
      v41 = Cmd_Argv(1);
      __asm { vmovss  [rsp+150h+timeshift], xmm6 }
      CL_AddDebugStarWithText(&org, &MYCOLOR, &MYCOLOR, v41, *(float *)&timeshifta, 0, 200, 0);
    }
  }
  else
  {
    v26 = Cmd_Argv(1);
    Com_PrintError(14, "Couldn't find sound alias \"%s\".\n", v26);
  }
LABEL_14:
  _R11 = &vars0;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const char *aliasName, const LocalClientNum_t localClientNum, const int entnum, double volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  unsigned __int64 SndEntHandle; 
  unsigned int AliasId; 
  unsigned int result; 
  float v17; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entnum);
  AliasId = SND_FindAliasId(aliasName);
  __asm
  {
    vmovss  xmm0, [rsp+68h+pitch]
    vmovaps xmm3, xmm6; volumeScale
    vmovss  [rsp+68h+var_48], xmm0
  }
  result = SND_PlayScaledSoundAlias_Internal(NULL, AliasId, SndEntHandle, *(const float *)&_XMM3, v17, org, timeshift, system, 0);
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
  return result;
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const char *aliasName, const unsigned __int64 sndEnt, double volumeScale, double pitch, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  unsigned int AliasId; 
  unsigned int result; 
  float v17; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps [rsp+78h+var_28], xmm7
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm3
  }
  AliasId = SND_FindAliasId(aliasName);
  __asm
  {
    vmovaps xmm3, xmm7; volumeScale
    vmovss  [rsp+78h+var_58], xmm6
  }
  result = SND_PlayScaledSoundAlias_Internal(NULL, AliasId, sndEnt, *(const float *)&_XMM3, v17, org, timeshift, system, 0);
  __asm
  {
    vmovaps xmm6, [rsp+78h+var_18]
    vmovaps xmm7, [rsp+78h+var_28]
  }
  return result;
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entnum, double volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  unsigned __int64 SndEntHandle; 
  unsigned int result; 
  float v16; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entnum);
  __asm
  {
    vmovss  xmm0, [rsp+68h+pitch]
    vmovaps xmm3, xmm6; volumeScale
    vmovss  [rsp+68h+var_48], xmm0
  }
  result = SND_PlayScaledSoundAlias_Internal(aliasList, 0, SndEntHandle, *(const float *)&_XMM3, v16, org, timeshift, system, 0);
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
  return result;
}

/*
==============
SND_PlayScaledSoundAlias
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias(const SndAliasList *aliasList, const unsigned __int64 sndEnt, double volumeScale, double pitch, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  float v9; 

  __asm
  {
    vmovss  [rsp+58h+var_38], xmm3
    vmovaps xmm3, xmm2; volumeScale
  }
  return SND_PlayScaledSoundAlias_Internal(aliasList, 0, sndEnt, *(const float *)&_XMM3, v9, org, timeshift, system, 0);
}

/*
==============
SND_PlayScaledSoundAliasAsync
==============
*/

void __fastcall SND_PlayScaledSoundAliasAsync(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entnum, double volumeScale, float pitch, const vec3_t *org, int timeshift, snd_alias_system_t system)
{
  unsigned __int64 SndEntHandle; 
  float v15; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entnum);
  __asm
  {
    vmovss  xmm0, [rsp+68h+pitch]
    vmovaps xmm3, xmm6; volumeScale
    vmovss  [rsp+68h+var_48], xmm0
  }
  SND_PlayScaledSoundAlias_Internal(aliasList, 0, SndEntHandle, *(const float *)&_XMM3, v15, org, timeshift, system, 1);
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
}

/*
==============
SND_PlayScaledSoundAlias_Internal
==============
*/

unsigned int __fastcall SND_PlayScaledSoundAlias_Internal(const SndAliasList *aliasList, const unsigned int aliasId, const unsigned __int64 sndEnt, double volumeScale, const float pitch, const vec3_t *org, const int timeshift, const snd_alias_system_t system, bool deferred)
{
  SndPlayParams inParams; 

  __asm { vmovss  xmm0, cs:__real@3f800000 }
  inParams.aliasList = aliasList;
  __asm
  {
    vmovss  [rbp+2Fh+inParams.distanceScale], xmm0
    vmovss  [rbp+2Fh+inParams.lfeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
  }
  inParams.fadeTime = 0;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  _RAX = org;
  __asm
  {
    vmovss  [rbp+2Fh+inParams.lpfCutoff], xmm0
    vmovss  [rbp+2Fh+inParams.hpfCutoff], xmm0
    vxorps  xmm0, xmm0, xmm0
    vmovss  xmm1, dword ptr [rax]
    vmovss  [rbp+2Fh+inParams.startOffsetFraction], xmm0
    vmovss  xmm0, [rbp+2Fh+pitch]
    vmovss  [rbp+2Fh+inParams.pitch], xmm0
    vmovss  xmm0, dword ptr [rax+4]
    vmovss  dword ptr [rbp+2Fh+inParams.org], xmm1
    vmovss  xmm1, dword ptr [rax+8]
  }
  inParams.timeshift = timeshift;
  inParams.aliasId = aliasId;
  inParams.system = system;
  __asm
  {
    vmovss  [rbp+2Fh+inParams.volumeScale], xmm3
    vmovss  dword ptr [rbp+2Fh+inParams.org+4], xmm0
    vmovss  dword ptr [rbp+2Fh+inParams.org+8], xmm1
  }
  inParams.playbackType = SPT_BLEND;
  inParams.adsrIndex = -1;
  inParams.autoSimId = -1;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.sndEnt = sndEnt;
  return SND_PlaySoundAliasFromParams(&inParams, deferred);
}

/*
==============
SND_PlaySecondaryAlias
==============
*/
__int64 SND_PlaySecondaryAlias(const SndAlias *alias, const SndPlayParams *inParams, SndAliasGroupTracking *inOutTracking)
{
  unsigned int secondaryId; 
  SndAliasList *AliasFromId; 
  unsigned int v10; 
  SndAlias *v11; 
  char v12; 
  SndAlias *head; 
  unsigned int contextType; 
  unsigned int contextValue; 
  __int64 v16; 
  unsigned int *p_contextValue; 
  unsigned int v18; 
  bool v20; 
  bool v21; 
  SndAlias *outAliasB; 
  float outLerp; 
  SndAlias *outAliasA; 

  secondaryId = alias->secondaryId;
  if ( !secondaryId )
    return 0i64;
  AliasFromId = SND_FindAliasFromId(secondaryId);
  if ( !AliasFromId )
    return 0i64;
  v10 = 0;
  SND_PickSoundAliasFromList(AliasFromId, inParams, (const SndAlias **)&outAliasA, (const SndAlias **)&outAliasB, &outLerp, 0, 0, 0, 0);
  v11 = outAliasA;
  v12 = alias->flags & 1;
  if ( v12 && (outAliasA->flags & 1) != 0 )
  {
    head = AliasFromId->head;
    if ( (head->flags & 1) == 0 )
    {
LABEL_17:
      Com_PrintError(9, "Error: a looping alias cannot have a looping secondary aliasName that refers to multiple aliases.\nAlias sequence: '%s'->'%s'\n", alias->aliasName, alias->secondaryAliasName);
      return 0i64;
    }
    contextType = head->contextType;
    contextValue = head->contextValue;
    if ( AliasFromId->count > 1 )
    {
      v16 = 1i64;
      p_contextValue = &head[1].contextValue;
      while ( (p_contextValue[16] & 1) != 0 )
      {
        v18 = *(p_contextValue - 1);
        if ( v18 == contextType && *p_contextValue == contextValue )
          break;
        contextValue = *p_contextValue;
        ++v16;
        p_contextValue += 58;
        contextType = v18;
        if ( v16 >= AliasFromId->count )
          goto LABEL_12;
      }
      goto LABEL_17;
    }
  }
LABEL_12:
  if ( !outAliasA )
    return 0i64;
  if ( !v12 && (outAliasA->flags & 1) != 0 )
  {
    Com_PrintError(9, "Error: a non-looping alias cannot have a looping secondary alias.\nAlias sequence: '%s'->'%s'\n", alias->aliasName, alias->secondaryAliasName);
    return 0i64;
  }
  v20 = ++inOutTracking->secondaryRecursionDepth < 0x14u;
  v21 = inOutTracking->secondaryRecursionDepth <= 0x14u;
  if ( inOutTracking->secondaryRecursionDepth > 20 )
  {
    Com_PrintError(9, "Error: exceeded max number of secondary aliases (%i).  Possible infinite loop.\nAlias sequence: '%s'->'%s'\n", 20i64, alias->aliasName, alias->secondaryAliasName);
    return 0i64;
  }
  __asm
  {
    vmovaps [rsp+98h+var_38], xmm6
    vmovss  xmm6, [rsp+98h+arg_0]
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( !v21 )
  {
    v20 = 0;
    if ( outAliasB )
    {
      __asm { vmovaps xmm1, xmm6; contextLerp }
      v10 = SND_PlaySoundAliasCore(outAliasB, *(float *)&_XMM1, inParams, inOutTracking);
    }
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vcomiss xmm6, xmm0
  }
  if ( v20 )
  {
    __asm { vsubss  xmm1, xmm0, xmm6; contextLerp }
    v10 = SND_PlaySoundAliasCore(v11, *(float *)&_XMM1, inParams, inOutTracking);
  }
  __asm { vmovaps xmm6, [rsp+98h+var_38] }
  return v10;
}

/*
==============
SND_PlaySoundAlias
==============
*/
unsigned int SND_PlaySoundAlias(const char *aliasName, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  unsigned __int64 SndEntHandle; 
  SndPlayParams inParams; 

  __asm { vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000 }
  inParams.playbackType = SPT_BLEND;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovups xmmword ptr [rbp+47h+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+47h+inParams.lpfCutoff], xmm0
    vmovss  [rbp+47h+inParams.hpfCutoff], xmm0
    vmovss  dword ptr [rbp+47h+inParams.org], xmm1
    vmovss  dword ptr [rbp+47h+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+47h+inParams.org+8], xmm1
    vmovss  [rbp+47h+inParams.startOffsetFraction], xmm1
  }
  _RSI = org;
  inParams.aliasList = NULL;
  inParams.sndEnt = 0i64;
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  inParams.aliasId = SND_FindAliasId(aliasName);
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entNum);
  __asm
  {
    vmovss  xmm0, dword ptr [rsi]
    vmovss  xmm1, dword ptr [rsi+4]
  }
  inParams.sndEnt = SndEntHandle;
  __asm
  {
    vmovss  dword ptr [rbp+47h+inParams.org], xmm0
    vmovss  xmm0, dword ptr [rsi+8]
  }
  inParams.timeshift = timeshift;
  __asm
  {
    vmovss  dword ptr [rbp+47h+inParams.org+8], xmm0
    vmovss  dword ptr [rbp+47h+inParams.org+4], xmm1
  }
  inParams.system = system;
  return SND_PlaySoundAliasFromParams(&inParams, 0);
}

/*
==============
SND_PlaySoundAlias
==============
*/
unsigned int SND_PlaySoundAlias(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, const int timeshift, const snd_alias_system_t system)
{
  unsigned __int64 SndEntHandle; 
  SndPlayParams inParams; 

  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vxorps  xmm1, xmm1, xmm1
  }
  inParams.aliasList = aliasList;
  inParams.playbackType = SPT_BLEND;
  __asm
  {
    vmovups xmmword ptr [rbp+47h+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
  }
  inParams.aliasId = 0;
  inParams.sndEnt = 0i64;
  _RBX = org;
  inParams.timeshift = 0;
  inParams.fadeTime = 0;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  __asm
  {
    vmovss  [rbp+47h+inParams.lpfCutoff], xmm0
    vmovss  [rbp+47h+inParams.hpfCutoff], xmm0
    vmovss  dword ptr [rbp+47h+inParams.org], xmm1
    vmovss  dword ptr [rbp+47h+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+47h+inParams.org+8], xmm1
    vmovss  [rbp+47h+inParams.startOffsetFraction], xmm1
  }
  inParams.adsrIndex = -1;
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entNum);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  xmm1, dword ptr [rbx+4]
  }
  inParams.sndEnt = SndEntHandle;
  __asm
  {
    vmovss  dword ptr [rbp+47h+inParams.org], xmm0
    vmovss  xmm0, dword ptr [rbx+8]
  }
  inParams.timeshift = timeshift;
  __asm
  {
    vmovss  dword ptr [rbp+47h+inParams.org+8], xmm0
    vmovss  dword ptr [rbp+47h+inParams.org+4], xmm1
  }
  inParams.system = system;
  return SND_PlaySoundAliasFromParams(&inParams, 0);
}

/*
==============
SND_PlaySoundAliasCore
==============
*/

__int64 __fastcall SND_PlaySoundAliasCore(const SndAlias *alias, double contextLerp, const SndPlayParams *inParams, SndAliasGroupTracking *inOutTracking)
{
  const SndAlias *v9; 
  __int64 v10; 
  int started; 
  __int64 result; 
  unsigned __int64 sndEnt; 
  unsigned __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  const SndAlias **p_alias; 
  sd_voice **voices; 
  unsigned int *chaninfoEntchannel; 
  SndFader *p_fadeInOut; 
  const SndAlias *v22; 
  int autoSimId; 
  int startDelayMax; 
  int startDelay; 
  __int64 v36; 
  unsigned int v37; 
  __int64 v38; 
  const char *v39; 
  __int64 v41; 
  int outVoice; 
  int v43; 
  const SndAlias *v44; 
  vec3_t origin_out; 
  __int64 v46; 
  SndStartAliasInfo info; 
  tmat33_t<vec3_t> axis_out; 

  v46 = -2i64;
  __asm { vmovaps [rsp+190h+var_50], xmm6 }
  _RSI = inParams;
  __asm { vmovaps xmm6, xmm1 }
  v9 = alias;
  v44 = alias;
  LODWORD(v10) = -1;
  outVoice = -1;
  if ( !Sys_InCriticalSection(CRITSECT_SOUND_UPDATE) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4435, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_SOUND_UPDATE ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_SOUND_UPDATE )") )
    __debugbreak();
  if ( !v9 )
    goto LABEL_11;
  if ( Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4442, ASSERT_TYPE_ASSERT, "(!Sys_IsMainThreadEntityWorker())", "%s\n\tSound playback is not supported from entity worker threads. Alias was '%s'", "!Sys_IsMainThreadEntityWorker()", v9->aliasName) )
    __debugbreak();
  started = 0;
  if ( !g_snd.driverInitialized )
    goto LABEL_11;
  if ( inOutTracking->numVoices >= 0x14u )
  {
    Com_PrintError(9, "Error: exceeded max number of secondary aliases (%lu).  Possible infinite loop.\nAlias sequence: '%s'->'%s'\n", 20i64, v9->aliasName, v9->secondaryAliasName);
LABEL_11:
    result = 0i64;
    goto LABEL_72;
  }
  _R12 = &_RSI->org;
  if ( InRange(v9, &_RSI->org) && v9->assetId )
  {
    sndEnt = _RSI->sndEnt;
    v15 = sndEnt & 0x1FFFFFFFFi64;
    if ( (sndEnt & 0x1FFFFFFFFi64) - 5411 <= 0x1F || v15 - 2049 <= 0x8FF || v15 <= 0x7FD || v15 - 5571 <= 0x7A120 )
    {
      CG_SND_GetSoundEntityOrientation(_RSI->sndEnt, &origin_out, &axis_out);
      SND_SetEntState(sndEnt, &origin_out, &axis_out);
      memset(&origin_out, 0, sizeof(origin_out));
    }
    if ( SND_ContinueLoopingSound(v9, _RSI, &outVoice) )
    {
      v16 = outVoice;
      g_snd.voices[v16].secondaryId = SND_PlaySecondaryAlias(v9, _RSI, inOutTracking);
      result = g_snd.voices[v16].playbackId;
      goto LABEL_72;
    }
    v17 = (unsigned __int8)(v9->flags >> 10);
    v43 = (unsigned __int8)(v9->flags >> 10);
    if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2069, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    if ( (unsigned int)v17 >= g_snd.globals->entchannelCount )
    {
      LODWORD(v41) = v17;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2070, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v41) )
        __debugbreak();
    }
    if ( g_snd.globals->entchannelInfo[v17].isRestricted && (!Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) || (_RSI->sndEnt & 0x1FFFFFFFFi64) != 2046) )
    {
      p_alias = &g_snd.voices[0].alias;
      voices = g_sd.voices;
      chaninfoEntchannel = g_snd.chaninfoEntchannel;
      p_fadeInOut = &g_snd.voices[0].fadeInOut;
      do
      {
        if ( *(p_alias - 12) == (const SndAlias *)_RSI->sndEnt && *chaninfoEntchannel == v43 && !SND_IsVoiceFree(started) )
        {
          v22 = *p_alias;
          if ( ((*p_alias)->flags & 1) != 0 )
          {
            __asm { vxorps  xmm1, xmm1, xmm1; g }
            SND_FaderSetGoal(p_fadeInOut, *(float *)&contextLerp);
          }
          else
          {
            autoSimId = _RSI->autoSimId;
            if ( autoSimId != -1 && autoSimId == *((_DWORD *)p_alias + 30) )
            {
              (*voices)->autoSimStopTimeStamp = _RSI->autoSimTimeStamp;
              v22 = *p_alias;
            }
            SND_DebugAliasPrint(1, v22, "stopped on entchannel");
            SND_StopVoiceAndClearTracking(started, inOutTracking);
          }
        }
        ++started;
        p_fadeInOut += 164;
        ++chaninfoEntchannel;
        ++voices;
        p_alias += 246;
      }
      while ( started < 99 );
      v9 = v44;
      _R12 = &_RSI->org;
    }
    *(double *)&_XMM0 = SND_GetRandomAliasVolume(v9);
    __asm { vmovss  [rbp+90h+info.volume], xmm0 }
    *(double *)&_XMM0 = SND_GetRandomAliasPitch(v9);
    __asm
    {
      vmovss  [rbp+90h+info.pitch], xmm0
      vmovss  xmm0, dword ptr [rsi+10h]
      vmovss  [rbp+90h+info.volumeScale], xmm0
      vmovss  xmm1, dword ptr [rsi+14h]
      vmovss  [rbp+90h+info.distanceScale], xmm1
      vmovss  [rbp+90h+info.contextLerpVolume], xmm6
      vmovss  xmm0, dword ptr [rsi+18h]
      vmovss  [rbp+90h+info.pitchScale], xmm0
    }
    info.alias = v9;
    info.sndEnt = _RSI->sndEnt;
    __asm
    {
      vmovss  xmm0, dword ptr [r12]
      vmovss  dword ptr [rbp+90h+info.org], xmm0
      vmovss  xmm1, dword ptr [r12+4]
      vmovss  dword ptr [rbp+90h+info.org+4], xmm1
      vmovss  xmm0, dword ptr [r12+8]
      vmovss  dword ptr [rbp+90h+info.org+8], xmm0
    }
    info.timeshift = _RSI->timeshift;
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+60h]
      vmovss  [rbp+90h+info.fraction], xmm0
    }
    startDelayMax = v9->startDelayMax;
    startDelay = v9->startDelay;
    if ( startDelayMax > startDelay )
      startDelay = I_irand(startDelay, startDelayMax);
    info.startDelayUs = _RSI->additionalStartDelayUs + 1000 * startDelay;
    info.system = _RSI->system;
    info.adsrIndex = _RSI->adsrIndex;
    info.fadeTime = _RSI->fadeTime;
    info.autoSimId = _RSI->autoSimId;
    info.autoSimTimeStamp = _RSI->autoSimTimeStamp;
    info.autoSimShotCount = _RSI->autoSimShotCount;
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+1Ch]
      vmovss  [rbp+90h+info.lfeScale], xmm0
      vmovss  xmm1, dword ptr [rsi+58h]
      vmovss  [rbp+90h+info.lpfCutoff], xmm1
      vmovss  xmm0, dword ptr [rsi+5Ch]
      vmovss  [rbp+90h+info.hpfCutoff], xmm0
    }
    info.secondaryGroupId = inOutTracking->secondaryGroupId;
    info.preDelayed = _RSI->preDelayed;
    if ( !SND_FindAssetsForVoice(&info) )
    {
      if ( ++snd_errorLimit < 1000 )
      {
        Com_PrintError(9, "Sound alias %s's sound data was not yet loaded when played.\n", info.alias->aliasName);
        result = 0i64;
        goto LABEL_72;
      }
      goto LABEL_11;
    }
    started = SND_StartAlias(&info, inOutTracking, &outVoice);
    if ( started )
    {
      v10 = outVoice;
      if ( outVoice == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4543, ASSERT_TYPE_ASSERT, "(voiceIndex != ( -1 ))", (const char *)&queryFormat, "voiceIndex != SND_INVALID_VOICE_INDEX") )
        __debugbreak();
      if ( !g_sd.voices[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4544, ASSERT_TYPE_ASSERT, "(g_sd.voices[voiceIndex])", (const char *)&queryFormat, "g_sd.voices[voiceIndex]") )
        __debugbreak();
      if ( inOutTracking->numVoices >= 0x14u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4545, ASSERT_TYPE_ASSERT, "(inOutTracking.numVoices < ( sizeof( *array_counter( inOutTracking.voiceIndices ) ) + 0 ))", (const char *)&queryFormat, "inOutTracking.numVoices < ARRAY_COUNT( inOutTracking.voiceIndices )") )
        __debugbreak();
      inOutTracking->voiceIndices[inOutTracking->numVoices] = v10;
      inOutTracking->voicePlaybackIds[inOutTracking->numVoices++] = started;
      v36 = (unsigned __int8)(v9->flags >> 10);
      if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2107, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
        __debugbreak();
      if ( (unsigned int)v36 >= g_snd.globals->entchannelCount )
      {
        LODWORD(v41) = v36;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2108, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v41) )
          __debugbreak();
      }
      if ( g_snd.globals->entchannelInfo[v36].isPlayerDialogue && !inOutTracking->hasSetPlayerBreathDialogueAlias )
      {
        CG_SND_PlayerBreathsSetDialogueAlias((LocalClientNum_t)((_RSI->sndEnt >> 33) & 3), started);
        inOutTracking->hasSetPlayerBreathDialogueAlias = 1;
      }
    }
    else
    {
      LODWORD(v10) = outVoice;
    }
  }
  v37 = SND_PlaySecondaryAlias(v9, _RSI, inOutTracking);
  if ( (_DWORD)v10 == -1 || (v38 = (int)v10, g_snd.voices[v38].playbackId != started) )
    started = v37;
  else
    g_snd.voices[v38].secondaryId = v37;
  v39 = j_va("Started (voice %d, time %d)", (unsigned int)v10, (unsigned int)g_snd.looptime);
  SND_DebugAliasPrint(started != 0, v9, v39);
  result = (unsigned int)started;
LABEL_72:
  __asm { vmovaps xmm6, [rsp+190h+var_50] }
  return result;
}

/*
==============
SND_PlaySoundAliasFromParams
==============
*/
__int64 SND_PlaySoundAliasFromParams(const SndPlayParams *inParams, bool deferred)
{
  const dvar_t *v9; 
  const SndAliasList *aliasList; 
  unsigned int v11; 
  SndPlaybackType playbackType; 
  __int32 v13; 
  __int32 v14; 
  int v15; 
  bool ContextFromIndex; 
  bool v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v21; 
  unsigned int secondaryGroupCounter; 
  unsigned int reflectionClass; 
  unsigned int v25; 
  unsigned int specType1; 
  unsigned int specValue1; 
  unsigned int specType2; 
  unsigned int specValue2; 
  const SndAlias *outType; 
  float outLerp[2]; 
  SndAlias *outAliasA; 
  unsigned int outValue[2]; 
  __int64 v35; 
  SndAliasGroupTracking inOutTracking; 

  v35 = -2i64;
  _RSI = inParams;
  if ( !inParams->aliasList && !inParams->aliasId )
    return 0i64;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+10h]
    vmovss  dword ptr [rsp+150h+outType], xmm0
  }
  if ( ((unsigned int)outType & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4586, ASSERT_TYPE_SANITY, "( !IS_NAN( inParams.volumeScale ) )", (const char *)&queryFormat, "!IS_NAN( inParams.volumeScale )") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+14h]
    vmovss  dword ptr [rsp+150h+outType], xmm0
  }
  if ( ((unsigned int)outType & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4587, ASSERT_TYPE_SANITY, "( !IS_NAN( inParams.distanceScale ) )", (const char *)&queryFormat, "!IS_NAN( inParams.distanceScale )") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+18h]
    vmovss  dword ptr [rsp+150h+outType], xmm0
  }
  if ( ((unsigned int)outType & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4588, ASSERT_TYPE_SANITY, "( !IS_NAN( inParams.pitch ) )", (const char *)&queryFormat, "!IS_NAN( inParams.pitch )") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+1Ch]
    vmovss  dword ptr [rsp+150h+outType], xmm0
  }
  if ( ((unsigned int)outType & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4589, ASSERT_TYPE_SANITY, "( !IS_NAN( inParams.lfeScale ) )", (const char *)&queryFormat, "!IS_NAN( inParams.lfeScale )") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFFFFF00, "SND_PlaySoundAliasFromParams");
  if ( !deferred )
    goto LABEL_23;
  v9 = DCONST_DVARBOOL_snd_deferredPlaybackEnabled;
  if ( !DCONST_DVARBOOL_snd_deferredPlaybackEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_deferredPlaybackEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( !v9->current.enabled )
  {
LABEL_23:
    aliasList = _RSI->aliasList;
    if ( !_RSI->aliasList )
    {
      aliasList = SND_FindAliasFromId(_RSI->aliasId);
      if ( !aliasList )
        goto LABEL_25;
    }
    v11 = 0;
    playbackType = _RSI->playbackType;
    if ( playbackType )
    {
      v13 = playbackType - 1;
      if ( v13 )
      {
        v14 = v13 - 1;
        if ( !v14 )
        {
          Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
          *(_QWORD *)&inOutTracking.numVoices = 0i64;
          secondaryGroupCounter = g_snd.secondaryGroupCounter;
          do
            ++secondaryGroupCounter;
          while ( !secondaryGroupCounter );
          g_snd.secondaryGroupCounter = secondaryGroupCounter;
          inOutTracking.secondaryGroupId = secondaryGroupCounter;
          inOutTracking.hasSetPlayerBreathDialogueAlias = 0;
          SND_PickSoundAliasFromList(aliasList, _RSI, (const SndAlias **)&outAliasA, NULL, NULL, 0, 0, 0, 0);
          __asm { vmovss  xmm1, cs:__real@3f800000; contextLerp }
          v11 = SND_PlaySoundAliasCore(outAliasA, *(float *)&_XMM1, _RSI, &inOutTracking);
          SND_FinalizeAliasGroupTracking(&inOutTracking);
          if ( v11 )
          {
            reflectionClass = _RSI->reflectionClass;
            if ( reflectionClass )
              SND_WeapReflectPlayExplosionSound(&_RSI->org, reflectionClass);
          }
          goto LABEL_54;
        }
        v15 = v14 - 1;
        if ( v15 )
        {
          if ( v15 != 1 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4678, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown playback type") )
              __debugbreak();
            goto LABEL_54;
          }
          LODWORD(outType) = 0;
          outValue[1] = 0;
          outValue[0] = 0;
          outLerp[0] = 0.0;
          ContextFromIndex = SND_GetContextFromIndex(_RSI->contextIndex, (unsigned int *)&outType, &outValue[1]);
          v17 = SND_GetContextFromIndex(_RSI->contextIndex2, outValue, (unsigned int *)outLerp);
          if ( !ContextFromIndex && !v17 )
            goto LABEL_54;
          Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
          *(_QWORD *)&inOutTracking.numVoices = 0i64;
          v18 = g_snd.secondaryGroupCounter;
          do
            ++v18;
          while ( !v18 );
          g_snd.secondaryGroupCounter = v18;
          inOutTracking.secondaryGroupId = v18;
          specValue2 = LODWORD(outLerp[0]);
          specType2 = outValue[0];
          specValue1 = outValue[1];
          specType1 = (unsigned int)outType;
          goto LABEL_52;
        }
        Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
        *(_QWORD *)&inOutTracking.numVoices = 0i64;
        v19 = g_snd.secondaryGroupCounter;
        do
          ++v19;
        while ( !v19 );
      }
      else
      {
        Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
        *(_QWORD *)&inOutTracking.numVoices = 0i64;
        v19 = g_snd.secondaryGroupCounter;
        do
          ++v19;
        while ( !v19 );
      }
      g_snd.secondaryGroupCounter = v19;
      inOutTracking.secondaryGroupId = v19;
      inOutTracking.hasSetPlayerBreathDialogueAlias = 0;
      SND_PickSoundAliasFromList(aliasList, _RSI, (const SndAlias **)&outAliasA, &outType, outLerp, 0, 0, 0, 0);
      __asm { vmovss  xmm2, [rsp+150h+outLerp]; volumeLerp }
      v21 = SND_PlayContextBlendAliasCore(outAliasA, outType, *(double *)&_XMM2, _RSI);
LABEL_53:
      v11 = v21;
      SND_FinalizeAliasGroupTracking(&inOutTracking);
      goto LABEL_54;
    }
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    *(_QWORD *)&inOutTracking.numVoices = 0i64;
    v25 = g_snd.secondaryGroupCounter;
    do
      ++v25;
    while ( !v25 );
    g_snd.secondaryGroupCounter = v25;
    inOutTracking.secondaryGroupId = v25;
    specValue2 = 0;
    specType2 = 0;
    specValue1 = 0;
    specType1 = 0;
LABEL_52:
    inOutTracking.hasSetPlayerBreathDialogueAlias = 0;
    SND_PickSoundAliasFromList(aliasList, _RSI, (const SndAlias **)&outAliasA, NULL, NULL, specType1, specValue1, specType2, specValue2);
    __asm { vmovss  xmm1, cs:__real@3f800000; contextLerp }
    v21 = SND_PlaySoundAliasCore(outAliasA, *(float *)&_XMM1, _RSI, &inOutTracking);
    goto LABEL_53;
  }
  if ( !SND_AddDeferredPlayback(_RSI) )
  {
    Com_PrintWarning(16, "Unable to queue deferred sound alias request. Playing synchronously.\n");
    goto LABEL_23;
  }
LABEL_25:
  v11 = 0;
LABEL_54:
  Sys_ProfEndNamedEvent();
  return v11;
}

/*
==============
SND_PlaySurfaceSound
==============
*/

unsigned int __fastcall SND_PlaySurfaceSound(const char *aliasName, const int surfaceType, const unsigned __int64 sndEnt, double volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  unsigned int AliasId; 
  unsigned int result; 
  float v15; 
  float v16; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  AliasId = SND_FindAliasId(aliasName);
  __asm
  {
    vmovss  xmm0, [rsp+68h+pitch]
    vmovss  [rsp+68h+var_40], xmm0
    vmovss  [rsp+68h+var_48], xmm6
  }
  result = SND_PlaySurfaceSound_Internal(NULL, AliasId, surfaceType, sndEnt, v15, v16, fadeTime, org, 0);
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
  return result;
}

/*
==============
SND_PlaySurfaceSound
==============
*/

unsigned int __fastcall SND_PlaySurfaceSound(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, double volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  float v9; 
  float v10; 

  __asm
  {
    vmovss  xmm0, [rsp+58h+pitch]
    vmovss  [rsp+58h+var_30], xmm0
    vmovss  [rsp+58h+var_38], xmm3
  }
  return SND_PlaySurfaceSound_Internal(aliasList, 0, surfaceType, sndEnt, v9, v10, fadeTime, org, 0);
}

/*
==============
SND_PlaySurfaceSoundAsync
==============
*/

void __fastcall SND_PlaySurfaceSoundAsync(const char *aliasName, const int surfaceType, const unsigned __int64 sndEnt, double volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  unsigned int AliasId; 
  float v14; 
  float v15; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  AliasId = SND_FindAliasId(aliasName);
  __asm
  {
    vmovss  xmm0, [rsp+68h+pitch]
    vmovss  [rsp+68h+var_40], xmm0
    vmovss  [rsp+68h+var_48], xmm6
  }
  SND_PlaySurfaceSound_Internal(NULL, AliasId, surfaceType, sndEnt, v14, v15, fadeTime, org, 1);
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
}

/*
==============
SND_PlaySurfaceSoundAsync
==============
*/

void __fastcall SND_PlaySurfaceSoundAsync(const SndAliasList *aliasList, const int surfaceType, const unsigned __int64 sndEnt, double volumeScale, float pitch, const int fadeTime, const vec3_t *org)
{
  float v8; 
  float v9; 

  __asm
  {
    vmovss  xmm0, [rsp+58h+pitch]
    vmovss  [rsp+58h+var_30], xmm0
    vmovss  [rsp+58h+var_38], xmm3
  }
  SND_PlaySurfaceSound_Internal(aliasList, 0, surfaceType, sndEnt, v8, v9, fadeTime, org, 1);
}

/*
==============
SND_PlaySurfaceSound_Internal
==============
*/
unsigned int SND_PlaySurfaceSound_Internal(const SndAliasList *aliasList, const unsigned int aliasId, const int surfaceType, const unsigned __int64 sndEnt, float volumeScale, float pitch, const int fadeTime, const vec3_t *org, bool deferred)
{
  int v24; 
  SndPlayParams inParams; 

  if ( (unsigned int)surfaceType >= 0x40 )
  {
    v24 = 64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 5710, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( 64 )", "surfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", surfaceType, v24) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  xmm1, [rbp+2Fh+pitch]
  }
  inParams.adsrIndex = -1;
  __asm
  {
    vmovss  [rbp+2Fh+inParams.distanceScale], xmm0
    vmovss  [rbp+2Fh+inParams.lfeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+2Fh+inParams.lpfCutoff], xmm0
    vmovss  [rbp+2Fh+inParams.hpfCutoff], xmm0
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rbp+2Fh+inParams.startOffsetFraction], xmm0
    vmovss  xmm0, [rbp+2Fh+volumeScale]
  }
  inParams.playbackType = SPT_GENERAL;
  inParams.timeshift = 0;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  __asm { vmovss  [rbp+2Fh+inParams.volumeScale], xmm0 }
  inParams.fadeTime = fadeTime;
  _RAX = org;
  __asm { vmovss  [rbp+2Fh+inParams.pitch], xmm1 }
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  __asm
  {
    vmovss  xmm0, dword ptr [rax]
    vmovss  xmm1, dword ptr [rax+4]
    vmovss  dword ptr [rbp+2Fh+inParams.org], xmm0
    vmovss  xmm0, dword ptr [rax+8]
    vmovss  dword ptr [rbp+2Fh+inParams.org+8], xmm0
    vmovss  dword ptr [rbp+2Fh+inParams.org+4], xmm1
  }
  *(_QWORD *)&inParams.contextIndex = -1i64;
  inParams.aliasList = aliasList;
  inParams.aliasId = aliasId;
  inParams.sndEnt = sndEnt;
  inParams.surfaceType = surfaceType;
  return SND_PlaySoundAliasFromParams(&inParams, deferred);
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/
int SND_PlayVirtualLoopSound(const char *aliasName, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, float volume, float pitch)
{
  const SndAliasList *Alias; 
  unsigned __int64 SndEntHandle; 
  float volumea; 

  Alias = SND_FindAlias(aliasName);
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entNum);
  __asm
  {
    vmovss  xmm0, [rsp+38h+pitch]
    vmovss  xmm3, [rsp+38h+volume]
    vmovss  [rsp+38h+volume], xmm0
  }
  return SND_PlayVirtualLoopSoundInternal(Alias, SndEntHandle, org, *(const float *)&_XMM3, volumea, 0);
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/

int __fastcall SND_PlayVirtualLoopSound(const char *aliasName, const unsigned __int64 sndEnt, const vec3_t *org, double volume, float pitch)
{
  const SndAliasList *Alias; 
  int result; 
  float v14; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  Alias = SND_FindAlias(aliasName);
  __asm
  {
    vmovss  xmm0, [rsp+48h+pitch]
    vmovaps xmm3, xmm6; volume
    vmovss  [rsp+48h+var_28], xmm0
  }
  result = SND_PlayVirtualLoopSoundInternal(Alias, sndEnt, org, *(const float *)&_XMM3, v14, 0);
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
  return result;
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/
int SND_PlayVirtualLoopSound(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, float volume, float pitch)
{
  unsigned __int64 SndEntHandle; 
  float volumea; 

  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entNum);
  __asm
  {
    vmovss  xmm0, [rsp+38h+pitch]
    vmovss  xmm3, [rsp+38h+volume]
    vmovss  [rsp+38h+volume], xmm0
  }
  return SND_PlayVirtualLoopSoundInternal(aliasList, SndEntHandle, org, *(const float *)&_XMM3, volumea, 0);
}

/*
==============
SND_PlayVirtualLoopSound
==============
*/
int SND_PlayVirtualLoopSound(const SndAliasList *aliasList, const unsigned __int64 sndEnt, const vec3_t *org, const float volume, const float pitch)
{
  float v7; 

  __asm
  {
    vmovss  xmm0, [rsp+38h+pitch]
    vmovss  [rsp+38h+var_18], xmm0
  }
  return SND_PlayVirtualLoopSoundInternal(aliasList, sndEnt, org, volume, v7, 0);
}

/*
==============
SND_PlayVirtualLoopSoundFollowEntity
==============
*/
int SND_PlayVirtualLoopSoundFollowEntity(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, float volume, float pitch)
{
  unsigned __int64 SndEntHandle; 
  float volumea; 

  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entNum);
  __asm
  {
    vmovss  xmm0, [rsp+38h+pitch]
    vmovss  xmm3, [rsp+38h+volume]
    vmovss  [rsp+38h+volume], xmm0
  }
  return SND_PlayVirtualLoopSoundInternal(aliasList, SndEntHandle, org, *(const float *)&_XMM3, volumea, 1);
}

/*
==============
SND_PlayVirtualLoopSoundInternal
==============
*/

__int64 __fastcall SND_PlayVirtualLoopSoundInternal(const SndAliasList *aliasList, const unsigned __int64 sndEnt, const vec3_t *org, double volume, const float pitch, const bool followEntity)
{
  __int64 result; 
  unsigned int v17; 
  int v19; 
  SndVirtualLoop *virtualLoops; 
  unsigned int v26; 
  bool v27; 
  int v28; 
  ScopedCriticalSection v33; 
  SndPlayParams inParams; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmm7, xmm3
  }
  _R14 = org;
  if ( (aliasList->head->flags & 1) != 0 )
  {
    inParams.aliasList = NULL;
    inParams.aliasId = 0;
    inParams.playbackType = SPT_BLEND;
    __asm
    {
      vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
      vmovups xmmword ptr [rsp+120h+inParams.volumeScale], xmm0
    }
    inParams.sndEnt = 0i64;
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vmovss  dword ptr [rbp+47h+inParams.org], xmm1
      vmovss  dword ptr [rbp+47h+inParams.org+4], xmm1
      vmovss  dword ptr [rbp+47h+inParams.org+8], xmm1
    }
    inParams.timeshift = 0;
    v17 = -1;
    inParams.adsrIndex = -1;
    inParams.fadeTime = 0;
    inParams.system = SASYS_CGAME;
    inParams.autoSimId = -1;
    inParams.autoSimTimeStamp = 0i64;
    inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
    inParams.startPaused = 0;
    __asm
    {
      vmovss  xmm0, cs:__real@bf800000
      vmovss  [rbp+47h+inParams.lpfCutoff], xmm0
      vmovss  [rbp+47h+inParams.hpfCutoff], xmm0
      vmovss  [rbp+47h+inParams.startOffsetFraction], xmm1
    }
    inParams.additionalStartDelayUs = 0;
    *(_QWORD *)&inParams.surfaceType = -1i64;
    inParams.contextIndex2 = -1;
    inParams.reflectionClass = 0;
    *(_WORD *)&inParams.isADS = 0;
    ScopedCriticalSection::ScopedCriticalSection(&v33, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
    v19 = 0;
    virtualLoops = g_snd.virtualLoops;
    while ( virtualLoops->handle != -1 )
    {
      ++v19;
      if ( (__int64)++virtualLoops >= (__int64)&g_snd.nextVirtualLoopHandle )
      {
        Com_PrintError(9, "SND_PlayVirtualLoopSound: Out of free virtual looping sound instances\n");
        goto LABEL_11;
      }
    }
    inParams.aliasList = aliasList;
    __asm
    {
      vmovss  [rsp+120h+inParams.volumeScale], xmm7
      vmovss  xmm6, [rbp+47h+pitch]
      vmovss  [rsp+120h+inParams.pitch], xmm6
      vmovss  xmm0, dword ptr [r14]
      vmovss  dword ptr [rbp+47h+inParams.org], xmm0
      vmovss  xmm1, dword ptr [r14+4]
      vmovss  dword ptr [rbp+47h+inParams.org+4], xmm1
      vmovss  xmm0, dword ptr [r14+8]
      vmovss  dword ptr [rbp+47h+inParams.org+8], xmm0
    }
    inParams.sndEnt = sndEnt;
    _RDI = &g_snd.virtualLoops[v19];
    v26 = SND_PlaySoundAliasFromParams(&inParams, 0);
    if ( v26 )
    {
      v27 = g_snd.nextVirtualLoopHandle + 1 < 0;
      v28 = ++g_snd.nextVirtualLoopHandle;
      v17 = 0;
      if ( !v27 )
        v17 = v28;
      _RDI->handle = v17;
      _RDI->aliasList = aliasList;
      _RDI->playbackId = v26;
      _RDI->sndEnt = sndEnt;
      __asm
      {
        vmovss  dword ptr [rdi+24h], xmm7
        vmovss  dword ptr [rdi+28h], xmm6
      }
      _RDI->followEntity = followEntity;
      _RDI->org.v[0] = _R14->v[0];
      __asm
      {
        vmovss  xmm0, dword ptr [r14+4]
        vmovss  dword ptr [rdi+1Ch], xmm0
        vmovss  xmm1, dword ptr [r14+8]
        vmovss  dword ptr [rdi+20h], xmm1
      }
    }
LABEL_11:
    ScopedCriticalSection::~ScopedCriticalSection(&v33);
    result = v17;
  }
  else
  {
    Com_PrintError(9, "SND_PlayVirtualLoopSound: Tried to play a non looping sound %s\n", aliasList->aliasName);
    result = 0xFFFFFFFFi64;
  }
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+120h+var_48+8]
    vmovaps xmm7, [rsp+120h+var_58+8]
  }
  return result;
}

/*
==============
SND_PlayWeaponSound
==============
*/
void SND_PlayWeaponSound(const SndAliasList *aliasList, const LocalClientNum_t localClientNum, const int entNum, const vec3_t *org, const Weapon *weapon, const bool isAlternate, const bool isPlayer, const int autoSimId, const __int64 autoSimTimeStamp, const float autoSimDistSq, const SndWeapShotCountId shotCount, const bool isProne, const bool isDualWield, const PlayerHandIndex hand, const bool isHyperBurstSound)
{
  bool v27; 
  bool v28; 
  bool v29; 
  SndAliasList *v32; 
  SndAliasList *v38; 
  SndAliasList *Alias; 
  int PlayerADSRSettingIndex; 
  unsigned __int64 SndEntHandle; 
  int v67; 
  unsigned int v68; 
  unsigned int id; 
  _QWORD inParams[17]; 
  char dest[128]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rsp+1C0h+inParams+18h], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vxorps  xmm8, xmm8, xmm8
  }
  inParams[1] = 0i64;
  __asm
  {
    vmovss  dword ptr [rbp+0C0h+inParams+60h], xmm0
    vmovss  dword ptr [rbp+0C0h+inParams+64h], xmm0
    vmovss  dword ptr [rbp+0C0h+inParams+68h], xmm8
  }
  _R15 = org;
  inParams[2] = 0x300000000i64;
  HIDWORD(inParams[7]) = 0;
  HIDWORD(inParams[8]) = 0;
  LODWORD(inParams[9]) = 1;
  BYTE4(inParams[11]) = 0;
  HIDWORD(inParams[13]) = 0;
  inParams[14] = -1i64;
  inParams[15] = 0xFFFFFFFFi64;
  LOBYTE(inParams[16]) = 0;
  _RDI = BG_GetSfxPackage(weapon, isAlternate);
  __asm { vmovss  xmm6, [rbp+0C0h+autoSimDistSq] }
  v27 = !isHyperBurstSound;
  if ( isPlayer )
  {
    PlayerADSRSettingIndex = CG_GetPlayerADSRSettingIndex(localClientNum, weapon);
    goto LABEL_27;
  }
  v28 = autoSimId != -1;
  v29 = autoSimId == -1;
  if ( autoSimId == -1 )
  {
    *(double *)&_XMM0 = SND_DistSqToNearestListener(_R15);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+68h]
    vcomiss xmm0, xmm8
  }
  if ( v28 || v29 )
    goto LABEL_9;
  __asm
  {
    vmulss  xmm1, xmm0, xmm0
    vcomiss xmm6, xmm1
  }
  if ( v28 )
  {
LABEL_9:
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+64h]
      vcomiss xmm0, xmm8
    }
    if ( v28 || v29 )
      goto LABEL_16;
    __asm
    {
      vmulss  xmm0, xmm0, xmm0
      vcomiss xmm6, xmm0
    }
    if ( v28 )
    {
LABEL_16:
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+60h]
        vcomiss xmm0, xmm8
      }
      if ( v28 || v29 )
        goto LABEL_24;
      __asm
      {
        vmulss  xmm0, xmm0, xmm0
        vcomiss xmm6, xmm0
      }
      if ( v28 )
        goto LABEL_24;
      Com_sprintf(dest, 0x80ui64, "%s_med", aliasList->aliasName);
      Alias = SND_FindAlias(dest);
      aliasList = Alias;
      if ( Alias )
      {
        _RAX = Alias->head;
        if ( (_RAX->flags & 0x70) != 0 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rax+64h]
            vmulss  xmm1, xmm0, xmm0
            vcomiss xmm6, xmm1
          }
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rax+68h]
          vmulss  xmm1, xmm0, xmm0
          vcomiss xmm6, xmm1
        }
        if ( (_RAX->flags & 0x70) != 0 )
          __asm { vcomiss xmm8, dword ptr [rdi+64h] }
      }
    }
    else
    {
      Com_sprintf(dest, 0x80ui64, "%s_far", aliasList->aliasName);
      v38 = SND_FindAlias(dest);
      aliasList = v38;
      if ( v38 )
      {
        _RAX = v38->head;
        if ( (_RAX->flags & 0x70) != 0 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rax+64h]
            vmulss  xmm1, xmm0, xmm0
            vcomiss xmm6, xmm1
          }
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rax+68h]
          vmulss  xmm1, xmm0, xmm0
          vcomiss xmm6, xmm1
        }
        if ( (_RAX->flags & 0x70) != 0 )
          __asm { vcomiss xmm8, dword ptr [rdi+68h] }
      }
    }
  }
  else
  {
    Com_sprintf(dest, 0x80ui64, "%s_dist", aliasList->aliasName);
    v32 = SND_FindAlias(dest);
    aliasList = v32;
    if ( v32 )
    {
      _RAX = v32->head;
      if ( (_RAX->flags & 0x70) != 0 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rax+64h]
          vmulss  xmm1, xmm0, xmm0
          vcomiss xmm6, xmm1
        }
      }
    }
  }
  v27 = 0;
LABEL_24:
  if ( !aliasList )
    goto LABEL_52;
  PlayerADSRSettingIndex = CG_GetNPCADSRSettingIndex(localClientNum, _R15, weapon);
LABEL_27:
  LODWORD(inParams[8]) = PlayerADSRSettingIndex;
  if ( !_RDI || !isPlayer || shotCount == SND_WEAP_SHOT_UNCOUNTED )
    goto LABEL_39;
  switch ( shotCount )
  {
    case SND_WEAP_SHOT_FIRST:
      __asm { vmovss  xmm0, dword ptr [rdi+50h] }
      break;
    case SND_WEAP_SHOT_SECOND:
      __asm { vmovss  xmm0, dword ptr [rdi+54h] }
      break;
    case SND_WEAP_SHOT_THIRD:
      __asm { vmovss  xmm0, dword ptr [rdi+58h] }
      break;
    default:
      goto LABEL_37;
  }
  __asm { vmovss  dword ptr [rsp+1C0h+inParams+18h], xmm0 }
LABEL_37:
  if ( isProne )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+5Ch]
      vmovss  dword ptr [rsp+1C0h+inParams+24h], xmm0
    }
  }
LABEL_39:
  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entNum);
  __asm
  {
    vmovss  xmm0, dword ptr [r15]
    vmovss  xmm1, dword ptr [r15+4]
    vmovss  dword ptr [rsp+1C0h+inParams+30h], xmm0
    vmovss  xmm0, dword ptr [r15+8]
  }
  inParams[5] = SndEntHandle;
  __asm
  {
    vmovss  dword ptr [rsp+1C0h+inParams+38h], xmm0
    vmovss  dword ptr [rsp+1C0h+inParams+34h], xmm1
  }
  HIDWORD(inParams[9]) = autoSimId;
  inParams[10] = autoSimTimeStamp;
  LODWORD(inParams[11]) = shotCount;
  BYTE1(inParams[16]) = 1;
  if ( isPlayer )
  {
    inParams[1] = aliasList;
    SND_FinishPlayingWeaponSound((const SndPlayParams *)&inParams[1], 1, _RDI, v27, isDualWield, hand);
  }
  else
  {
    __asm { vmovaps [rsp+1C0h+var_68+8], xmm7 }
    if ( autoSimId != -1 )
      goto LABEL_50;
    if ( SND_GetWhizby(_RDI) )
      __asm { vmovss  xmm7, dword ptr [rax+80h] }
    else
      __asm { vxorps  xmm7, xmm7, xmm7 }
    if ( SND_IsEntChannel3D((unsigned __int8)(aliasList->head->flags >> 10)) )
    {
      __asm
      {
        vcomiss xmm7, xmm8
        vmovss  xmm0, cs:__real@c9742400
        vdivss  xmm1, xmm0, xmm7
        vsqrtss xmm2, xmm6, xmm6
        vmulss  xmm2, xmm2, xmm1
        vcvttss2si eax, xmm2
      }
      _R8 = g_snd.delayedWeaponSounds;
      v67 = (500 - _EAX) / 1000;
      v68 = 0;
      while ( _R8->alias )
      {
        ++v68;
        ++_R8;
        if ( v68 >= 0x40 )
        {
          Com_PrintWarning(9, "Ran out of queued NPC weapon sound slots\n", _R8);
          goto LABEL_50;
        }
      }
      __asm { vmovups ymm1, ymmword ptr [rsp+1C0h+inParams+28h] }
      LODWORD(inParams[2]) = aliasList->id;
      id = aliasList->id;
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1C0h+inParams+8]
        vmovups ymmword ptr [r8+10h], ymm0
        vmovups ymm0, ymmword ptr [rbp+0C0h+inParams+48h]
        vmovups ymmword ptr [r8+30h], ymm1
        vmovups ymm1, ymmword ptr [rbp+0C0h+inParams+68h]
        vmovups ymmword ptr [r8+50h], ymm0
        vmovups ymmword ptr [r8+70h], ymm1
      }
      _R8->alias = id;
      _R8->timeStampMS = v67;
      _R8->playAtmo = v27;
      _R8->sfxPackage = _RDI;
    }
    else
    {
LABEL_50:
      inParams[1] = aliasList;
      SND_FinishPlayingWeaponSound((const SndPlayParams *)&inParams[1], 0, _RDI, v27, 0, WEAPON_HAND_DEFAULT);
    }
    __asm { vmovaps xmm7, [rsp+1C0h+var_68+8] }
  }
LABEL_52:
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+1C0h+var_58+8]
    vmovaps xmm8, [rsp+1C0h+var_78+8]
  }
}

/*
==============
SND_PrintEqParams
==============
*/
void SND_PrintEqParams(void)
{
  __int64 i; 
  int v4; 
  int j; 
  double v14; 
  double v15; 
  double v16; 
  __int128 v17; 

  __asm
  {
    vmovss  xmm2, cs:?sdGlob@@3USDLocal@@A.eqLerp; SDLocal sdGlob
    vcvtss2sd xmm2, xmm2, xmm2
    vmovq   r8, xmm2
  }
  Com_Printf(9, "Current EQ Settings\n---------------\n lerp = %.2f\n", *(double *)&_XMM2);
  for ( i = 0i64; g_snd.globals && (unsigned int)i < g_snd.globals->entchannelCount; i = (unsigned int)(i + 1) )
  {
    Com_Printf(9, "+ %s\n", g_snd.globals->entchannelInfo[(unsigned int)i].name);
    v4 = 0;
    _RBX = (char *)&sdGlob + 20 * i;
    do
    {
      for ( j = 0; j < 2; ++j )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rbx]
          vmovups [rsp+68h+var_28], xmm0
        }
        if ( (unsigned __int8)*((_DWORD *)_RBX + 4) )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rsp+68h+var_28+0Ch]
            vmovss  xmm1, dword ptr [rsp+68h+var_28+4]
            vmovss  xmm2, dword ptr [rsp+68h+var_28+8]
            vcvtss2sd xmm0, xmm0, xmm0
            vmovsd  [rsp+68h+var_30], xmm0
            vcvtss2sd xmm1, xmm1, xmm1
            vmovsd  [rsp+68h+var_38], xmm1
            vcvtss2sd xmm2, xmm2, xmm2
            vmovsd  [rsp+68h+var_40], xmm2
          }
          Com_Printf(9, "\t%i %i %s %f Hz %f dB %f q\n", (unsigned int)v4, (unsigned int)j, snd_eqTypeStrings[(int)v17], v14, v15, v16);
        }
        _RBX += 5120;
      }
      ++v4;
    }
    while ( v4 < 2 );
  }
}

/*
==============
SND_ProcessPendingRestore
==============
*/
void SND_ProcessPendingRestore()
{
  unsigned int v2; 
  double v11; 

  if ( g_snd.hasPendingRestore && Sys_IsMainThread() )
  {
    v2 = 0;
    _R14 = &g_snd.levelFadeInChannelVols;
    __asm
    {
      vmovaps [rsp+78h+var_48], xmm7
      vmovaps [rsp+78h+var_38], xmm6
    }
    g_snd.hasPendingRestore = 0;
    __asm { vxorps  xmm7, xmm7, xmm7 }
    while ( g_snd.globals && v2 < g_snd.globals->entchannelCount )
    {
      _RCX = 3i64 * v2;
      __asm
      {
        vmovss  xmm6, dword ptr [r14+rcx*8]
        vcomiss xmm6, xmm7
      }
      _RBX = &g_snd.levelFadeInChannelVols.channelvol[v2];
      if ( v2 < g_snd.globals->entchannelCount )
      {
        __asm
        {
          vcvtss2sd xmm0, xmm6, xmm6
          vmovsd  [rsp+78h+var_50], xmm0
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8428, ASSERT_TYPE_ASSERT, "( ( savedvalue >= 0.0f ) )", "( savedvalue ) = %g", v11) )
          __debugbreak();
        __asm { vcomiss xmm6, xmm7 }
      }
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4705, ASSERT_TYPE_ASSERT, "(info)", (const char *)&queryFormat, "info") )
        __debugbreak();
      __asm
      {
        vmovss  dword ptr [rbx+4], xmm6
        vmovss  dword ptr [rbx], xmm6
      }
      _RBX->goalrate = 0.0;
      ++v2;
    }
    __asm
    {
      vmovaps xmm6, [rsp+78h+var_38]
      vmovaps xmm7, [rsp+78h+var_48]
    }
  }
}

/*
==============
SND_QueueSoundDoneNotify
==============
*/
void SND_QueueSoundDoneNotify(unsigned __int64 entNum, unsigned __int16 soundString)
{
  __int64 v4; 
  int v5; 
  NotifyQueueEntry *v6; 

  if ( soundString && clientUIActives[0].connectionState >= CA_CONNECTED )
  {
    if ( s_notifiesCount < 32 )
    {
      do
      {
        v4 = s_notifiesHead;
        v5 = ((_BYTE)s_notifiesHead + 1) & 0x1F;
        if ( ((unsigned __int64)&s_notifiesHead & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&s_notifiesHead) )
          __debugbreak();
      }
      while ( (_DWORD)v4 != _InterlockedCompareExchange(&s_notifiesHead, v5, v4) );
      v6 = &s_notifies[v4];
      if ( entNum > 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned __int64>(unsigned __int64)", "unsigned", (unsigned __int16)entNum, "unsigned", entNum) )
        __debugbreak();
      v6->entnum = entNum;
      v6->soundString = soundString;
      if ( ((unsigned __int8)&s_notifiesCount & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_notifiesCount) )
        __debugbreak();
      _InterlockedIncrement(&s_notifiesCount);
    }
    else
    {
      Com_PrintError(9, "ERROR: too many sound notifies %d\n", 32i64);
    }
  }
}

/*
==============
SND_RecalcChaninfoPriority
==============
*/
void SND_RecalcChaninfoPriority(int index)
{
  char v4; 

  _RDI = index;
  _RBX = &g_snd.voices[index];
  if ( _RBX->soundFileInfo.loadingState != SFLS_LOADED )
    goto LABEL_5;
  if ( (_RBX->alias->flags & 1) != 0 )
    goto LABEL_5;
  *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(index, 0);
  __asm { vcomiss xmm0, cs:__real@3f800000 }
  if ( v4 )
  {
LABEL_5:
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+30h]
      vmulss  xmm1, xmm0, dword ptr [rbx+2Ch]
    }
    _RAX = g_snd.chaninfoUnweightedPriority;
    __asm { vmovss  dword ptr [rax+rdi*4], xmm1 }
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@00800000 }
    _RAX = g_snd.chaninfoUnweightedPriority;
    __asm { vmovss  dword ptr [rax+rdi*4], xmm0 }
  }
}

/*
==============
SND_RecalcPropagation_f
==============
*/
void SND_RecalcPropagation_f(void)
{
  g_snd.doPropagationRecalc = 1;
}

/*
==============
SND_RegisterDvars
==============
*/

void __fastcall SND_RegisterDvars(__int64 a1, __int64 a2, double _XMM2_8)
{
  const dvar_t *v48; 
  const dvar_t *v55; 
  const dvar_t *v59; 
  const dvar_t *v73; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
    vmovaps [rsp+88h+var_38], xmm8
    vmovaps [rsp+88h+var_48], xmm9
    vmovaps [rsp+88h+var_58], xmm10
  }
  Dvar_BeginPermanentRegistration();
  DCONST_DVARBOOL_snd_errorOnMissing = Dvar_RegisterBool("snd_errorOnMissing", 0, 0x40004u, "Cause an error if a sound is missing.");
  DCONST_DVARINT_snd_draw3D = Dvar_RegisterEnum("snd_draw3D", snd_draw3DNames, 0, 0x40004u, "Draw the position and info of world sounds");
  DCONST_DVARINT_snd_levelFadeTime = Dvar_RegisterInt("snd_levelFadeTime", 250, 0, 5000, 0x40004u, "The amout of time in milliseconds for all audio to fade in at the start of a level");
  DCONST_DVARINT_snd_debugStressTest = Dvar_RegisterInt("snd_debugStressTest", 0, 0, 1000, 0x40004u, "Enable random sound stress test, specifying millisecond delay between playing random sounds");
  DCONST_DVARSTR_snd_debugAlias = Dvar_RegisterString("snd_debugAlias", (const char *)&queryFormat.fmt + 3, 0x40004u, "Print out tracking information about a particular alias");
  DCONST_DVARBOOL_snd_drawWeaponRefl = Dvar_RegisterBool("snd_drawWeaponRefl", 0, 0x40004u, "Enables the weapon reflection debug overlay");
  DCONST_DVARINT_snd_debugPropagation = Dvar_RegisterInt("snd_debugPropagation", 0, 0, 2, 0x40004u, "Enables drawing the propagation objects");
  __asm
  {
    vmovss  xmm10, cs:__real@7f7fffff
    vmovss  xmm1, cs:__real@459c4000; value
  }
  DCONST_DVARBOOL_snd_debugPropagationCull = Dvar_RegisterBool("snd_debugPropagationCull", 1, 0x40004u, "Toggle 3D culling for propagation debugging");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DCONST_DVARFLT_snd_debugPropagationCullDist = Dvar_RegisterFloat("snd_debugPropagationCullDist", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Culling distance for audio propagation debug drawing");
  __asm { vmovss  xmm1, cs:__real@447a0000; value }
  DCONST_DVARINT_cg_drawDebugAudioClientTriggers = Dvar_RegisterInt("cg_drawDebugAudioClientTriggers", 0, 0, 3, 0x40004u, "Display client side trigger audio debug information");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DCONST_DVARFLT_cg_dbgClientTriggerDist = Dvar_RegisterFloat("cg_dbgClientTriggerDist", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Max distance to draw client triggers");
  DCONST_DVARBOOL_cg_dbgClientTriggerCull = Dvar_RegisterBool("cg_dbgClientTriggerCull", 0, 0x40004u, "Toggle 3D culling for client trigger debugging");
  DCONST_DVARINT_snd_occlusionDebug = Dvar_RegisterInt("snd_occlusionDebug", 0, 0, 2, 0x40004u, "Turn on occlusion debug draw. 1 is on, 2 to freeze");
  __asm
  {
    vmovss  xmm9, cs:__real@40a00000
    vmovss  xmm8, cs:__real@3f800000
  }
  DCONST_DVARSTR_snd_occlusionDebugAlias = Dvar_RegisterString("snd_occlusionDebugAlias", (const char *)&queryFormat.fmt + 3, 0x40004u, "Alias name filter to show occlusion for");
  __asm
  {
    vmovaps xmm3, xmm9; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DCONST_DVARFLT_snd_occlusionDebugTime = Dvar_RegisterFloat("snd_occlusionDebugTime", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Time to hold the occlusion debug lines for each sound");
  DCONST_DVARINT_snd_fullOcclusionDebug = Dvar_RegisterInt("snd_fullOcclusionDebug", 0, 0, 2, 0x40004u, "Turn on full occlusion debugging");
  DCONST_DVARSTR_snd_fullOcclusionDebugAlias = Dvar_RegisterString("snd_fullOcclusionDebugAlias", (const char *)&queryFormat.fmt + 3, 0x40004u, "Alias name filter to show occlusion for");
  DCONST_DVARBOOL_snd_debugReplace = Dvar_RegisterBool("snd_debugReplace", 0, 0x40004u, "Print out information about when we stop a playing sound to play another");
  DCONST_DVARBOOL_snd_bankDetailStreamingDebug = Dvar_RegisterBool("snd_bankDetailStreamingDebug", 0, 0x40004u, "Draw info about all sound banks being streamed and how they're ranked");
  DCONST_DVARBOOL_snd_bankDetailStreamingFallback = Dvar_RegisterBool("snd_bankDetailStreamingFallback", 1, 0x40004u, "Allow streaming fallback sounds to be played.");
  DCONST_DVARBOOL_snd_loadPatchBanks = Dvar_RegisterBool("snd_loadPatchBanks", 1, 0x40004u, "Should the game attempt to load patch sound banks.");
  __asm { vmovss  xmm6, cs:__real@44fa0000 }
  DCONST_DVARBOOL_snd_deferredPlaybackEnabled = Dvar_RegisterBool("snd_deferredPlaybackEnabled", 1, 0x40004u, "Should the game utilize a worker thread to play sounds.");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  DCONST_DVARFLT_snd_propagationMaxNodeRange = Dvar_RegisterFloat("snd_propagationMaxNodeRange", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Max range to look for nearest nodes.");
  __asm { vmovss  xmm1, cs:__real@3e800000; value }
  DCONST_DVARBOOL_snd_debugWeaponADSR = Dvar_RegisterBool("snd_debugWeaponADSR", 0, 0x40004u, "Turns on console printouts to find missing weapon ADSR entries");
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DCONST_DVARFLT_snd_omnidirectionalPercentage = Dvar_RegisterFloat("snd_omnidirectionalPercentage", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Percentage of sound volume that is 'directionless'");
  __asm
  {
    vmovss  xmm2, cs:__real@ff7fffff; min
    vmovss  xmm1, cs:__real@41200000; value
  }
  DCONST_DVARINT_snd_occlusionDelay = Dvar_RegisterInt("snd_occlusionDelay", 150, 0, 0x7FFFFFFF, 0x40004u, "Minimum delay in (ms) between occlusion updates");
  __asm { vmovaps xmm3, xmm10; max }
  DCONST_DVARFLT_snd_occlusionZOffset = Dvar_RegisterFloat("snd_occlusionZOffset", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Vertical offset to apply to occlusion entity positions");
  DCONST_DVARBOOL_snd_useHardOuterEntchannelPriorities = Dvar_RegisterBool("snd_useHardOuterEntchannelPriorities", 1, 0x40004u, "Chooses hard outer entchannel prioritization, false for soft (priority*volume)");
  DCONST_DVARSTR_snd_solo_alias = Dvar_RegisterString("snd_solo_alias", (const char *)&queryFormat.fmt + 3, 0x40004u, "mute alias with matching substring");
  DCONST_DVARSTR_snd_mute_alias = Dvar_RegisterString("snd_mute_alias", (const char *)&queryFormat.fmt + 3, 0x40004u, "mute alias with not matching substring");
  DCONST_DVARSTR_snd_solo_volmod = Dvar_RegisterString("snd_solo_volmod", (const char *)&queryFormat.fmt + 3, 0x40004u, "mute volmod with matching substring");
  DCONST_DVARSTR_snd_mute_volmod = Dvar_RegisterString("snd_mute_volmod", (const char *)&queryFormat.fmt + 3, 0x40004u, "mute volmod with not matching substring");
  DCONST_DVARSTR_snd_solo_channel = Dvar_RegisterString("snd_solo_channel", (const char *)&queryFormat.fmt + 3, 0x40004u, "mute channel with matching substring");
  DCONST_DVARSTR_snd_mute_channel = Dvar_RegisterString("snd_mute_channel", (const char *)&queryFormat.fmt + 3, 0x40004u, "mute channel with not matching substring");
  DCONST_DVARBOOL_snd_mute_2D = Dvar_RegisterBool("snd_mute_2D", 0, 0x40004u, "mute 2D sounds");
  DCONST_DVARBOOL_snd_mute_3D = Dvar_RegisterBool("snd_mute_3D", 0, 0x40004u, "mute 3D sounds");
  DCONST_DVARBOOL_snd_mute_stream = Dvar_RegisterBool("snd_mute_stream", 0, 0x40004u, "mute stream sounds");
  DVARSTR_snd_start_alias = Dvar_RegisterString("NLMRKKRSQQ", (const char *)&queryFormat.fmt + 3, 4u, "start sound");
  __asm
  {
    vmovss  xmm1, cs:__real@41a00000; value
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DVARSTR_snd_stop_alias = Dvar_RegisterString("NPSQPTMPNO", (const char *)&queryFormat.fmt + 3, 4u, "stop sound");
  DCONST_DVARFLT_snd_start_alias_distance = Dvar_RegisterFloat("snd_start_alias_distance", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, (const char *)&queryFormat.fmt + 3);
  DCONST_DVARSTR_snd_debug_context_type = Dvar_RegisterString("snd_debug_context_type", (const char *)&queryFormat.fmt + 3, 0x40004u, "enable debug context type");
  DCONST_DVARSTR_snd_debug_context_value = Dvar_RegisterString("snd_debug_context_value", (const char *)&queryFormat.fmt + 3, 0x40004u, "enable debug context value");
  __asm { vmovss  xmm1, cs:__real@459c4000; value }
  DCONST_DVARBOOL_snd_weapReflect_enabled = Dvar_RegisterBool("snd_weapReflect_enabled", 1, 0x40004u, "Enable/disable the audio weapon reflection feature");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovaps xmm2, xmm9; min
  }
  DCONST_DVARFLT_snd_weapReflect_maxTraceDistance = Dvar_RegisterFloat("snd_weapReflect_maxTraceDistance", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "The maximum length of the weapon reflection raycasts");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vmovaps xmm2, xmm9; min
    vmovaps xmm1, xmm6; value
  }
  DCONST_DVARFLT_snd_weapReflect_distantVoiceDistance = Dvar_RegisterFloat("snd_weapReflect_distantVoiceDistance", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "The distance from the sound source the so called distant weapon reflection sound aliases are played");
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DCONST_DVARFLT_snd_dry_scale = Dvar_RegisterFloat("snd_dry_scale", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "scalar value for dry signal path");
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm8; value
  }
  DCONST_DVARFLT_snd_wet_scale = Dvar_RegisterFloat("snd_wet_scale", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "scalar value for wet signal path");
  DCONST_DVARBOOL_snd_reverb_enable = Dvar_RegisterBool("snd_reverb_enable", 1, 0x40004u, "enable/disable reverb processing");
  DCONST_DVARBOOL_snd_delay_enable = Dvar_RegisterBool("snd_delay_enable", 1, 0x40004u, "enable/disable delay processing");
  DVARBOOL_snd_volume_mute = Dvar_RegisterBool("LMSLNRLNOT", 0, 0, "Flag to mute the game sound master volume");
  __asm { vmovss  xmm1, cs:__real@3f000000; value }
  DVARBOOL_snd_mute_player_dialogue = Dvar_RegisterBool("NMQNRSMLSL", 0, 0, "Flag to mute the player dialogue");
  __asm
  {
    vmovaps xmm3, xmm8; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v48 = Dvar_RegisterFloat("snd_controller_volume", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Controller volume");
  __asm { vmovss  xmm1, cs:__real@42c80000; value }
  DCONST_DVARFLT_snd_controller_volume = v48;
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DCONST_DVARFLT_snd_farReverbSpreadMin = Dvar_RegisterFloat("snd_farReverbSpreadMin", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Stereo Spread Min Distance for panned far reverbs");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  v55 = Dvar_RegisterFloat("snd_farReverbSpreadMax", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Stereo Spread Max Distance for panned far reverbs");
  __asm { vmovss  xmm1, cs:__real@41f00000; value }
  DCONST_DVARFLT_snd_farReverbSpreadMax = v55;
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  v59 = Dvar_RegisterFloat("snd_farReverbSpreadMaxAngle", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Stereo Spread Max Angle for panned far reverbs");
  __asm
  {
    vmovss  xmm2, cs:__real@c2c80000; min
    vmovss  xmm1, cs:__real@c1c00000; value
  }
  DCONST_DVARFLT_snd_farReverbSpreadMaxAngle = v59;
  __asm { vxorps  xmm3, xmm3, xmm3; max }
  DCONST_DVARFLT_snd_farDryAttenuation = Dvar_RegisterFloat("snd_farDryAttenuation", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "Additional attenuation applied to dry propagation sounds");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm9; value
  }
  DCONST_DVARFLT_snd_occDepth = Dvar_RegisterFloat("snd_occDepth", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "The depth a sound can penetrate a surface before being considered occluded");
  DCONST_DVARBOOL_snd_submix_dev_cutout = Dvar_RegisterBool("snd_submix_dev_cutout", 0, 0x40004u, "DEV: cutoff all submix code at runtime, use commandline at launch");
  DCONST_DVARSTR_snd_submix_debug = Dvar_RegisterString("snd_submix_debug", (const char *)&queryFormat.fmt + 3, 0x40004u, "set a debug submix by console / use \"\" to reset.");
  DCONST_DVARINT_snd_submix_debug_draw = Dvar_RegisterInt("snd_submix_debug_draw", 0, 0, 4, 0x40004u, "Turn on submix debug draw. 1: show requested+unique submixes. 2: show volmod parameters. 3: show zone settings. 4: show zone updates.");
  DCONST_DVARINT_snd_submix_debug_units = Dvar_RegisterInt("snd_submix_debug_units", 0, 0, 2, 0x40004u, "Devhost-to-monitor submix/volmod values as 0:Percent (default), 1: Linear [0,1], 2: Hz/DB etc.");
  DCONST_DVARBOOL_snd_submix_disable = Dvar_RegisterBool("snd_submix_disable", 0, 0x40004u, "ignore the submix results for mixing");
  DCONST_DVARBOOL_snd_submix_disable_att = Dvar_RegisterBool("snd_submix_disable_att", 0, 0x40004u, "disable submix attenuation effect");
  DCONST_DVARBOOL_snd_submix_disable_hpf = Dvar_RegisterBool("snd_submix_disable_hpf", 0, 0x40004u, "disable submix HPF effect");
  DCONST_DVARBOOL_snd_submix_disable_lpf = Dvar_RegisterBool("snd_submix_disable_lpf", 0, 0x40004u, "disable submix LPF effect");
  DCONST_DVARBOOL_snd_submix_disable_focuscone = Dvar_RegisterBool("snd_submix_disable_focuscone", 0, 0x40004u, "disable submix focus cone effect");
  DCONST_DVARBOOL_snd_submix_disable_alias = Dvar_RegisterBool("snd_submix_disable_alias", 0, 0x40004u, "disable submixes for ALIAS (existing requests fade)");
  DCONST_DVARBOOL_snd_submix_disable_lua = Dvar_RegisterBool("snd_submix_disable_lua", 0, 0x40004u, "disable submixes for LUA/UI script (existing request persists)");
  DCONST_DVARBOOL_snd_submix_disable_script = Dvar_RegisterBool("snd_submix_disable_script", 0, 0x40004u, "disable submixes for server GSC SCRIPT (existing request persists)");
  DCONST_DVARBOOL_snd_submix_disable_zone = Dvar_RegisterBool("snd_submix_disable_zone", 0, 0x40004u, "disable two ZONE submixes (clears existing settings to fade)");
  __asm { vmovss  xmm1, cs:__real@40000000; value }
  DCONST_DVARINT_snd_voicecount_debug_draw = Dvar_RegisterInt("snd_voicecount_debug_draw", 0, 0, 1, 0x40004u, "Turn on voicecount debug draw. 1 is on");
  __asm
  {
    vmovaps xmm3, xmm10; max
    vxorps  xmm2, xmm2, xmm2; min
  }
  DCONST_DVARFLT_snd_occfadetime = Dvar_RegisterFloat("snd_occfadetime", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "The rate in seconds the occlusion will fade for");
  DCONST_DVARBOOL_snd_dsp_meters = Dvar_RegisterBool("snd_dsp_meters", 1, 0x40004u, "enable dsp meters");
  DCONST_DVARSTR_snd_master_override = Dvar_RegisterString("snd_master_override", (const char *)&queryFormat.fmt + 3, 0x40004u, "overide current master");
  DCONST_DVARBOOL_snd_enable_capture_mode = Dvar_RegisterBool("snd_enable_capture_mode", 0, 0x40004u, "enable to alter various parts of the audio pipeline for video capture");
  DCONST_DVARBOOL_snd_voicefutz_enable = Dvar_RegisterBool("snd_voicefutz_enable", 1, 0x40004u, "enable voice chat audio processing");
  DVARINT_snd_voicefutz = Dvar_RegisterEnum("TLOLPTLNQ", snd_voiceFutzNames, 0, 0, "Voice futz effect name");
  DVARINT_snd_voiceChatDeviceType = Dvar_RegisterEnum("MSQLPLNSQN", snd_voiceChatDeviceTypeNames, 0, 0, "Voice chat device type");
  DCONST_DVARINT_snd_solo_propagation = Dvar_RegisterEnum("snd_solo_propagation", g_soloPropagationNames, 0, 0x40004u, "solo sound propagation audio");
  __asm
  {
    vmovss  xmm7, cs:__real@bf800000
    vmovss  xmm3, cs:__real@46bb8000; max
  }
  DCONST_DVARBOOL_snd_useSinglepoleFilter = Dvar_RegisterBool("snd_useSinglepoleFilter", 0, 0x40004u, "Use old singlepole filter");
  __asm
  {
    vmovaps xmm2, xmm7; min
    vmovaps xmm1, xmm7; value
  }
  v73 = Dvar_RegisterFloat("snd_lpf_override", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "LPF filter override");
  __asm { vmovss  xmm3, cs:__real@46bb8000; max }
  DCONST_DVARFLT_snd_lpf_override = v73;
  __asm
  {
    vmovaps xmm2, xmm7; min
    vmovaps xmm1, xmm7; value
  }
  DCONST_DVARFLT_snd_hpf_override = Dvar_RegisterFloat("snd_hpf_override", *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, 0x40004u, "HPF filter override");
  DVARSTR_snd_hitmarker_alias = Dvar_RegisterString("NSNPRRQTOP", "hit_marker_3d", 4u, "start sound");
  DCONST_DVARBOOL_snd_dolby_panning_disable = Dvar_RegisterBool("snd_dolby_panning_disable", 0, 0x40004u, "Disable dolby panner and use old 7.1 panner instead");
  DCONST_DVARINT_snd_transient_bank_budget_weapons = Dvar_RegisterInt("snd_transient_bank_budget_weapons", 26214400, -1, 0x40000000, 0x40004u, "Amount of transient sound bank data to load for weapons. -1 for unlimited.");
  DCONST_DVARINT_snd_transient_bank_budget_vehicles = Dvar_RegisterInt("snd_transient_bank_budget_vehicles", 15728640, -1, 0x40000000, 0x40004u, "Amount of transient sound bank data to load for vehicles. -1 for unlimited.");
  DCONST_DVARINT_snd_transient_bank_budget_scripts = Dvar_RegisterInt("snd_transient_bank_budget_scripts", -1, -1, 0x40000000, 0x40004u, "Amount of transient sound bank data to load for scripts. -1 for unlimited.");
  DCONST_DVARINT_snd_transient_bank_budget_triggers = Dvar_RegisterInt("snd_transient_bank_budget_triggers", -1, -1, 0x40000000, 0x40004u, "Amount of transient sound bank data to load for triggers. -1 for unlimited.");
  DCONST_DVARBOOL_snd_transient_bank_enabled_weapons = Dvar_RegisterBool("snd_transient_bank_enabled_weapons", 1, 0x40004u, "Enable transient sound bank data loading for weapons");
  DCONST_DVARBOOL_snd_transient_bank_enabled_vehicles = Dvar_RegisterBool("snd_transient_bank_enabled_vehicles", 1, 0x40004u, "Enable transient sound bank data loading for vehicles");
  DCONST_DVARBOOL_snd_transient_bank_enabled_scripts = Dvar_RegisterBool("snd_transient_bank_enabled_scripts", 1, 0x40004u, "Enable transient sound bank data loading for scripts");
  DCONST_DVARBOOL_snd_transient_bank_enabled_triggers = Dvar_RegisterBool("snd_transient_bank_enabled_triggers", 1, 0x40004u, "Enable transient sound bank data loading for triggers");
  DCONST_DVARBOOL_snd_notifyAllMissingEquipmentSounds = Dvar_RegisterBool("snd_notifyAllMissingEquipmentSounds", 0, 0x40004u, "We don't normally notify for all missing sounds - this dconst will do so on all of them");
  DCONST_DVARBOOL_snd_errorOnMissingEquipmentSounds = Dvar_RegisterBool("snd_errorOnMissingEquipmentSounds", 0, 0x40004u, "Print errors for missing equipment sounds");
  DVARBOOL_snd_submix_restore_workaround_enable = Dvar_RegisterBool("MKRTMTSMRP", 1, 0, "Enables crash workaround while restoring submixes.");
  DVARBOOL_snd_invalid_stream_buffer_validation_enable = Dvar_RegisterBool("NTKPQTSSLQ", 1, 0, "Enables stream buffer validation checks.");
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
    vmovaps xmm8, [rsp+88h+var_38]
    vmovaps xmm9, [rsp+88h+var_48]
    vmovaps xmm10, [rsp+88h+var_58]
  }
  Dvar_EndPermanentRegistration();
}

/*
==============
SND_ReleasePhysicsQueryBlock
==============
*/
void SND_ReleasePhysicsQueryBlock(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16499, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( --s_soundPhysicsQueryBlock < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16501, ASSERT_TYPE_ASSERT, "(s_soundPhysicsQueryBlock >= 0)", (const char *)&queryFormat, "s_soundPhysicsQueryBlock >= 0") )
    __debugbreak();
}

/*
==============
SND_RemoveClipMap
==============
*/
void SND_RemoveClipMap(clipMap_t *__formal)
{
  SndBankInfo **v1; 
  const SndBank *bank; 

  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_PROPAGATION);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_WEAPON_REFLECT);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DOOR_PROPAGATION);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
  v1 = &g_sb.bankStack[32];
  do
  {
    bank = (*v1)->bank;
    if ( bank )
    {
      if ( !bank->streamInfo.alwaysLoaded )
        SND_StopBankSoundsWithBankInfo(*v1);
    }
    ++v1;
  }
  while ( (__int64)v1 < (__int64)&g_sb.loadGate );
}

/*
==============
SND_RemoveVoice
==============
*/
void SND_RemoveVoice(unsigned int entchannel)
{
  __int64 v1; 
  int v2; 
  int *v3; 
  __int64 v4; 

  v1 = entchannel;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2051, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v1 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2052, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v4) )
      __debugbreak();
  }
  v2 = g_snd.entchanvoicecount[v1];
  v3 = &g_snd.entchanvoicecount[v1];
  if ( v2 <= 0 )
  {
    LODWORD(v4) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2053, ASSERT_TYPE_ASSERT, "( ( g_snd.entchanvoicecount[entchannel] > 0 ) )", "( g_snd.entchanvoicecount[entchannel] ) = %i", v4) )
      __debugbreak();
  }
  --*v3;
}

/*
==============
SND_Reset
==============
*/
void SND_Reset(bool restart)
{
  const dvar_t *v3; 
  unsigned int v4; 
  const SndGlobals *globals; 
  snd_param_info_t *v6; 
  SndVirtualLoop *virtualLoops; 
  unsigned int v14; 
  int *p_playTime; 
  ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *mp_next; 
  ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *v17; 
  ntl::fixed_list<OcclusionLine,594,0> *v18; 
  SndBankInfo **v20; 
  const SndBank *bank; 
  unsigned int v22; 
  __int64 v23; 

  if ( SND_Active() )
  {
    __asm { vmovaps [rsp+78h+var_38], xmm6 }
    SND_StopSounds(SND_STOP_ALL);
    v3 = DCONST_DVARINT_snd_levelFadeTime;
    g_snd.uiPaused = 0;
    g_snd.stopSoundsAfterMasterFade = 0;
    if ( !DCONST_DVARINT_snd_levelFadeTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_levelFadeTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    v4 = 0;
    while ( 1 )
    {
      globals = g_snd.globals;
      if ( !g_snd.globals || v4 >= g_snd.globals->entchannelCount )
        break;
      v6 = &g_snd.levelFadeInChannelVols.channelvol[v4];
      if ( (snd_local_t *)((char *)&g_snd + 24 * v4) == (snd_local_t *)-80i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
        __debugbreak();
      v6->value = 1.0;
      ++v4;
      v6->goalvalue = 1.0;
      *(_QWORD *)&v6->goalrate = 1065353216i64;
      v6->goalgain = 0.0;
    }
    _RDI = 0i64;
    _RBX = &g_snd.volmods[0].goalrate;
    while ( 1 )
    {
      _RAX = globals->volmodinfo;
      _RSI = _RBX - 2;
      __asm { vmovss  xmm6, dword ptr [rax+rdi+44h] }
      if ( _RBX == (float *)8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6954, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
        __debugbreak();
      __asm { vmovss  dword ptr [rbx-4], xmm6 }
      *(_QWORD *)_RBX = 1065353216i64;
      _RDI += 72i64;
      _RBX[2] = 0.0;
      _RBX += 6;
      __asm { vmovss  dword ptr [rsi], xmm6 }
      if ( (__int64)_RBX >= (__int64)&g_snd.scriptSoundFade.goalrate )
        break;
      globals = g_snd.globals;
    }
    SND_ClearReverbs();
    __asm { vmovaps xmm6, [rsp+78h+var_38] }
    virtualLoops = g_snd.virtualLoops;
    g_snd.nextVirtualLoopHandle = 0;
    do
    {
      virtualLoops->handle = -1;
      ++virtualLoops;
    }
    while ( (__int64)virtualLoops < (__int64)&g_snd.nextVirtualLoopHandle );
    Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
    Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_WEAPON_REFLECT);
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
    CG_SndAutoSimReset();
    SND_Stop3DSounds();
    v14 = 0;
    p_playTime = &g_ambGlob[0].playTime;
    do
    {
      v14 += 2;
      *(_QWORD *)(p_playTime - 1) = 0i64;
      p_playTime[1] = 0;
      *((_BYTE *)p_playTime + 8) = 0;
      *(_QWORD *)(p_playTime + 3) = 0i64;
      *(_QWORD *)(p_playTime + 7) = 0i64;
      *(_QWORD *)(p_playTime + 5) = 0i64;
      p_playTime[9] = 0;
      *(_QWORD *)(p_playTime + 11) = 0i64;
      p_playTime[13] = 0;
      *((_BYTE *)p_playTime + 56) = 0;
      *(_QWORD *)(p_playTime + 15) = 0i64;
      *(_QWORD *)(p_playTime + 19) = 0i64;
      *(_QWORD *)(p_playTime + 17) = 0i64;
      p_playTime[21] = 0;
      p_playTime += 24;
    }
    while ( v14 < 2 );
    SND_InitEntityParamInfo();
    SND_InitWeaponRelection();
    SND_InitGlobalContexts();
    memset_0(g_snd.entState, 0, sizeof(g_snd.entState));
    s_FXPlaySoundCount = 0;
    s_FXPlaySoundHead = 0;
    SND_ClearAllOcclusionSettings();
    mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)s_occlusionLines.m_listHead.m_sentinel.mp_next;
    *(_QWORD *)g_snd.entChanFullOcclusionDisabled = 0i64;
    *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[2] = 0i64;
    *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[4] = 0i64;
    *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[6] = 0i64;
    if ( (ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine> > *)s_occlusionLines.m_listHead.m_sentinel.mp_next != &s_occlusionLines.m_listHead )
    {
      v17 = s_occlusionLines.m_freelist.m_head.mp_next;
      do
      {
        v18 = (ntl::fixed_list<OcclusionLine,594,0> *)mp_next[1].mp_next;
        mp_next->mp_next = v17;
        v17 = mp_next;
        s_occlusionLines.m_freelist.m_head.mp_next = mp_next;
        mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)v18;
      }
      while ( v18 != (ntl::fixed_list<OcclusionLine,594,0> *)&s_occlusionLines.m_listHead );
    }
    __asm { vxorps  xmm0, xmm0, xmm0; fadeTimeSec }
    s_occlusionLines.m_listHead.m_sentinel.mp_prev = &s_occlusionLines.m_listHead.m_sentinel;
    s_occlusionLines.m_listHead.m_sentinel.mp_next = &s_occlusionLines.m_listHead.m_sentinel;
    SND_SubmixClearAll(*(float *)&_XMM0);
    s_notifiesCount = 0;
    *(_QWORD *)g_snd.paSpeakerDisabledArray = 0i64;
    s_notifiesHead = 0;
    memset_0(g_snd.delayedWeaponSounds, 0, sizeof(g_snd.delayedWeaponSounds));
    memset_0(g_snd.delayedBulletEvents, 0, sizeof(g_snd.delayedBulletEvents));
    SND_BankDetailStreaming_Init();
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    v20 = &g_sb.bankStack[32];
    do
    {
      bank = (*v20)->bank;
      if ( bank && !bank->streamInfo.alwaysLoaded )
        SND_StopBankSoundsWithBankInfo(*v20);
      ++v20;
    }
    while ( (__int64)v20 < (__int64)&g_sb.loadGate );
    SND_DeferredPlaybackInit();
    SND_SubmixInit();
    SND_MusicInit();
    CG_SND_InitPlayerBreathSystem();
    v22 = 0;
    g_snd.listenerFence = 0;
    g_sndEntityParamFence = 0;
    do
    {
      v23 = (int)v22++;
      g_snd.voiceBusyUpdating[v23] = 0;
    }
    while ( v22 < 0x63 );
  }
}

/*
==============
SND_ResetCanDoPhysicsQuery
==============
*/
void SND_ResetCanDoPhysicsQuery(void)
{
  s_soundPhysicsQueryBlock = 0;
}

/*
==============
SND_ResetEntState
==============
*/
void SND_ResetEntState(void)
{
  memset_0(g_snd.entState, 0, sizeof(g_snd.entState));
}

/*
==============
SND_ResetPauseDefaults
==============
*/
void SND_ResetPauseDefaults(void)
{
  const SndGlobals *globals; 
  unsigned int v1; 
  __int64 v2; 
  __int64 v3; 

  globals = g_snd.globals;
  if ( !g_snd.globals )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6064, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    globals = g_snd.globals;
  }
  v1 = 0;
  *(_QWORD *)g_snd.entchanOverrides.isPausable = -1i64;
  *(_QWORD *)&g_snd.entchanOverrides.isPausable[2] = -1i64;
  *(_QWORD *)&g_snd.entchanOverrides.isPausable[4] = -1i64;
  for ( *(_QWORD *)&g_snd.entchanOverrides.isPausable[6] = -1i64; v1 < globals->entchannelCount; ++v1 )
  {
    if ( !globals->entchannelInfo[v1].isPausable )
    {
      if ( v1 >= 0x100 )
      {
        LODWORD(v3) = 256;
        LODWORD(v2) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 30, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v2, v3) )
          __debugbreak();
      }
      g_snd.entchanOverrides.isPausable[(__int64)(int)v1 >> 5] &= ~(1 << (v1 & 0x1F));
      globals = g_snd.globals;
    }
  }
}

/*
==============
SND_ResetTimeScaleDefaults
==============
*/
void SND_ResetTimeScaleDefaults(void)
{
  float *timescaleLerp; 
  __int64 v1; 

  timescaleLerp = g_snd.entchanOverrides.timescaleLerp;
  v1 = 16i64;
  do
  {
    *(_QWORD *)timescaleLerp = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp + 1) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp + 2) = 0x3F8000003F800000i64;
    timescaleLerp += 16;
    *((_QWORD *)timescaleLerp - 5) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 4) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 3) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 2) = 0x3F8000003F800000i64;
    *((_QWORD *)timescaleLerp - 1) = 0x3F8000003F800000i64;
    --v1;
  }
  while ( v1 );
}

/*
==============
SND_ResetVoice
==============
*/
void SND_ResetVoice(int index)
{
  SndVoice *v1; 

  v1 = &g_snd.voices[index];
  if ( v1->alias )
  {
    v1->occlusionWaitId = 0;
    if ( v1->soundDoneSoundString )
    {
      if ( !v1->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3373, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
        __debugbreak();
      SND_QueueSoundDoneNotify(v1->sndEnt & 0x1FFFFFFFFi64, v1->soundDoneSoundString);
    }
    SND_SubmixStopFromVoice(v1);
    v1->paused = 0;
    v1->soundFileInfo.loadingState = SFLS_UNLOADED;
    v1->alias = NULL;
    v1->startTimeMSec = 0;
    v1->adsrIndex = -1;
    *(_QWORD *)v1->dopplerEffectLastPos.v = 0i64;
    v1->dopplerEffectLastPos.v[2] = 0.0;
    *(_QWORD *)&v1->playbackId = 0i64;
    v1->occlusionAmount = 0.0;
    v1->waitingForDoppler = 0;
    v1->ignorePause = 0;
    v1->dopplerEffectPitch = 1.0;
    v1->autoSimId = -1;
  }
}

/*
==============
SND_Restore
==============
*/
void SND_Restore(MemoryFile *memFile)
{
  int v2; 
  snd_channelvolgroup *v5; 
  __int64 v6; 
  int currentChannelPriority; 
  SDLocal *v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  unsigned int i; 
  unsigned __int8 v13; 
  int j; 
  int k; 
  int v16; 
  unsigned int v17; 
  __int64 v18; 
  unsigned __int8 p; 
  unsigned __int8 v20; 
  unsigned int v21; 

  v18 = -2i64;
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11063, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !CL_Pause_IsPendingPause() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11064, ASSERT_TYPE_ASSERT, "(CL_Pause_IsPendingPause())", (const char *)&queryFormat, "CL_Pause_IsPendingPause()") )
    __debugbreak();
  if ( g_snd.driverInitialized )
  {
    Sys_ProfBeginNamedEvent(0xFFFF0000, "SND_Restore");
    R_BeginRemoteScreenUpdate();
    v2 = Sys_Milliseconds();
    Com_Printf(16, "Begin sound sync.\n");
    SV_WaitServer();
    Com_CheckError();
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    cls.inUpdateSound = 1;
    SND_StopSounds(SND_KEEP_MUSIC_AND_AMBIENT);
    SND_PauseSounds();
    if ( !g_snd.paused && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 11090, ASSERT_TYPE_ASSERT, "(g_snd.paused)", (const char *)&queryFormat, "g_snd.paused") )
      __debugbreak();
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.value, xmm0; snd_local_t g_snd
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalvalue, xmm0; snd_local_t g_snd
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalrate, xmm0; snd_local_t g_snd
      vxorps  xmm0, xmm0, xmm0
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalfraction, xmm0; snd_local_t g_snd
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalgain, xmm0; snd_local_t g_snd
    }
    g_snd.stopSoundsAfterMasterFade = 0;
    SND_RestoreTransientBanks(memFile);
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    Sys_ProfBeginNamedEvent(0xFF8B0000, "Wait Sound Banks");
    while ( g_sd_stream_globals.streamIoActive || !SND_BankDetailStreaming_ActiveBanksLoaded() )
      Sys_Sleep(1);
    Sys_ProfEndNamedEvent();
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    v5 = &g_snd.channelPriorityVolGroups[1];
    v6 = 3i64;
    do
    {
      MemFile_ReadData(memFile, 0x1804ui64, v5++);
      --v6;
    }
    while ( v6 );
    currentChannelPriority = g_snd.currentChannelPriority;
    if ( g_snd.channelPriorityVolGroups[0].active )
      currentChannelPriority = 0;
    if ( g_snd.channelPriorityVolGroups[1].active )
      currentChannelPriority = 1;
    if ( g_snd.channelPriorityVolGroups[2].active )
      currentChannelPriority = 2;
    if ( g_snd.channelPriorityVolGroups[3].active )
      currentChannelPriority = 3;
    g_snd.currentChannelPriority = currentChannelPriority;
    MemFile_ReadData(memFile, 0x18ui64, g_snd.reverbSetting);
    MemFile_ReadData(memFile, 8ui64, &g_snd.mainReverbLerp);
    MemFile_ReadData(memFile, 4ui64, &g_snd.activeMainReverb);
    MemFile_ReadData(memFile, 8ui64, g_snd.farReverbTimestamp);
    MemFile_ReadData(memFile, 8ui64, g_snd.farReverbIds);
    MemFile_ReadData(memFile, 0x30ui64, g_snd.reverbPosition);
    MemFile_ReadData(memFile, 0x10ui64, g_snd.reverbTrigger);
    SND_SetReverbParams(g_snd.reverbSetting[0].presetId, RVB_MAIN_A, 0);
    SND_SetReverbParams(g_snd.reverbSetting[1].presetId, RVB_MAIN_B, 0);
    SND_SetReverbParams(g_snd.farReverbIds[0], RVB_FAR_A, 0);
    SND_SetReverbParams(g_snd.farReverbIds[1], RVB_FAR_B, 0);
    MemFile_ReadData(memFile, 0x420ui64, &g_snd.entchanOverrides);
    *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
    __asm { vmovss  cs:?sdGlob@@3USDLocal@@A.eqLerp, xmm0; SDLocal sdGlob }
    v8 = &sdGlob;
    v9 = 2i64;
    do
    {
      v10 = 2i64;
      do
      {
        v11 = 256i64;
        do
        {
          MemFile_ReadData(memFile, 0x14ui64, v8);
          v8 = (SDLocal *)((char *)v8 + 20);
          --v11;
        }
        while ( v11 );
        --v10;
      }
      while ( v10 );
      --v9;
    }
    while ( v9 );
    MemFile_ReadData(memFile, 0xD00ui64, g_sndEntityParamInfo);
    MemFile_ReadData(memFile, 0x100ui64, g_sndEntityParamIndex);
    MemFile_ReadData(memFile, 0x80ui64, g_sndSVEntityParamSet);
    MemFile_ReadData(memFile, 0x1804ui64, &g_snd.levelFadeInChannelVols);
    if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10219, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    for ( i = 0; i < g_snd.globals->volmodinfoCount; ++i )
      MemFile_ReadData(memFile, 0x18ui64, &g_snd.volmods[i]);
    SND_InitGlobalContexts();
    MemFile_ReadData(memFile, 1ui64, &p);
    v13 = p;
    if ( p != 0xFF )
    {
      do
      {
        MemFile_ReadData(memFile, 4ui64, &v21);
        g_snd.globalContextsTo[v13] = v21;
        MemFile_ReadData(memFile, 4ui64, &v17);
        g_snd.globalContextsFrom[v13] = v17;
        MemFile_ReadData(memFile, 8ui64, &g_snd.globalContextLerp[v13]);
        MemFile_ReadData(memFile, 1ui64, &v20);
        v13 = v20;
      }
      while ( v20 != 0xFF );
    }
    SND_RestoreEntStates(memFile);
    CG_RestoreAudioTriggerStates(memFile);
    SND_SubmixRestore(memFile);
    SND_RestoreMusicStatus(memFile);
    while ( SND_RestoreVoice(memFile) )
      ;
    while ( SND_RestoreVoice(memFile) )
      ;
    for ( j = 0; j < 4; ++j )
    {
      if ( (unsigned int)j > 3 )
        SND_RestoreStreamVoice(memFile);
    }
    while ( SND_RestoreStreamVoice(memFile) )
      ;
    while ( SND_RestoreVoice(memFile) )
      ;
    for ( k = 0; k < 99; ++k )
      SND_RestoreVoiceSync(k, memFile);
    MemFile_ReadData(memFile, 4ui64, &g_snd.playbackIdCounter);
    cls.inUpdateSound = 0;
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    v16 = Sys_Milliseconds();
    Com_Printf(16, "End sound sync (%d msec).\n", (unsigned int)(v16 - v2));
    R_EndRemoteScreenUpdate();
    g_snd.hasPendingRestore = 1;
    Sys_ProfEndNamedEvent();
  }
}

/*
==============
SND_RestoreEntStates
==============
*/
void SND_RestoreEntStates(MemoryFile *memFile)
{
  unsigned __int8 v3; 
  __int64 v5; 
  int v7; 
  __int64 v8; 
  unsigned int v9; 
  __int64 v10; 
  unsigned int v11; 
  unsigned int v12; 
  unsigned int v13; 
  int v14; 
  int v15; 
  __int64 v16[2]; 
  vec3_t from; 
  unsigned __int8 p; 
  unsigned __int8 v19; 
  unsigned __int8 v20; 

  v16[1] = -2i64;
  memset_0(g_snd.entState, 0, sizeof(g_snd.entState));
  MemFile_ReadData(memFile, 1ui64, &p);
  v3 = p;
  if ( p != 0xFF )
  {
    _R12 = &g_snd;
    do
    {
      MemFile_ReadData(memFile, 8ui64, v16);
      v5 = v3;
      _RDI = (unsigned __int64)v3 << 7;
      *(_QWORD *)((char *)&g_snd.entState[0].contextFadeLength[4] + _RDI) = v16[0];
      MemFile_ReadData(memFile, 1ui64, &p);
      v7 = p;
      *(unsigned int *)((char *)&g_snd.entState[0].hasPosition + _RDI) = p;
      if ( v7 )
      {
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rbp+from], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rbp+from+4], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rbp+from+8], xmm0 }
        if ( (snd_local_t *)((char *)&g_snd + _RDI) == (snd_local_t *)-1332360i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 895, ASSERT_TYPE_ASSERT, "(sndEntState)", (const char *)&queryFormat, "sndEntState") )
          __debugbreak();
        SetSecureSndVec3(&from, (vec3_t *)((char *)&g_snd.entState[0].origin.origin + _RDI), s_soundorg_aab_X, s_soundorg_aab_Y, s_soundorg_aab_Z);
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454D0h], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454D4h], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454D8h], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454DCh], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454E0h], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454E4h], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454E8h], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454ECh], xmm0 }
        *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
        __asm { vmovss  dword ptr [rdi+r12+1454F0h], xmm0 }
        memset(&from, 0, sizeof(from));
      }
      v8 = 3i64;
      do
      {
        MemFile_ReadData(memFile, 4ui64, &v11);
        v9 = v11;
        if ( v11 )
        {
          MemFile_ReadData(memFile, 1ui64, &v19);
          v10 = v19 + 32 * v5;
          g_snd.entState[0].contextTypes[v10] = v9;
          MemFile_ReadData(memFile, 4ui64, &v12);
          g_snd.entState[0].contextValuesFrom[v10] = v12;
          MemFile_ReadData(memFile, 4ui64, &v13);
          g_snd.entState[0].contextValuesTo[v10] = v13;
          MemFile_ReadData(memFile, 4ui64, &v14);
          g_snd.entState[0].contextFadeTime[v10] = v14;
          MemFile_ReadData(memFile, 4ui64, &v15);
          g_snd.entState[0].contextFadeLength[v10] = v15;
        }
        --v8;
      }
      while ( v8 );
      MemFile_ReadData(memFile, 1ui64, &v20);
      v3 = v20;
    }
    while ( v20 != 0xFF );
  }
}

/*
==============
SND_RestoreEntityParamInfo
==============
*/
void SND_RestoreEntityParamInfo(MemoryFile *memFile)
{
  MemFile_ReadData(memFile, 0xD00ui64, g_sndEntityParamInfo);
  MemFile_ReadData(memFile, 0x100ui64, g_sndEntityParamIndex);
  MemFile_ReadData(memFile, 0x80ui64, g_sndSVEntityParamSet);
}

/*
==============
SND_RestoreEq
==============
*/
void SND_RestoreEq(MemoryFile *memFile)
{
  SDLocal *v3; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 

  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  cs:?sdGlob@@3USDLocal@@A.eqLerp, xmm0; SDLocal sdGlob }
  v3 = &sdGlob;
  v4 = 2i64;
  do
  {
    v5 = 2i64;
    do
    {
      v6 = 256i64;
      do
      {
        MemFile_ReadData(memFile, 0x14ui64, v3);
        v3 = (SDLocal *)((char *)v3 + 20);
        --v6;
      }
      while ( v6 );
      --v5;
    }
    while ( v5 );
    --v4;
  }
  while ( v4 );
}

/*
==============
SND_RestoreMusicStatus
==============
*/
void SND_RestoreMusicStatus(MemoryFile *memFile)
{
  SndMusicAssetPlaybackState *p_playbackState; 
  __int64 v3; 
  SndMusicState *v4; 
  BOOL p; 
  int v6; 
  int v7; 

  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10160, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10161, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  MemFile_ReadData(memFile, 2ui64, &p);
  if ( (unsigned __int16)p > 0xFu )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10168, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Bad data read in SND_RestoreMusicStatus") )
      __debugbreak();
  }
  else
  {
    if ( p > 0 )
    {
      p_playbackState = &g_snd.musicPlaybacks[0].playbackState;
      v3 = p;
      do
      {
        v4 = SND_RestoreSoundMusicState(memFile);
        SndMusicAssetInstance::SetMusicState((SndMusicAssetInstance *)(p_playbackState - 5), v4);
        *(_QWORD *)(p_playbackState - 5) = SND_RestoreSoundMusicAsset(memFile, v4);
        MemFile_ReadData(memFile, 4ui64, p_playbackState - 1);
        MemFile_ReadData(memFile, 4ui64, p_playbackState);
        MemFile_ReadData(memFile, 4ui64, &p);
        *((_DWORD *)p_playbackState + 1) = p;
        MemFile_ReadData(memFile, 4ui64, &v6);
        *((_DWORD *)p_playbackState + 2) = v6;
        MemFile_ReadData(memFile, 4ui64, &v7);
        *((_DWORD *)p_playbackState + 3) = v7;
        p_playbackState += 10;
        --v3;
      }
      while ( v3 );
    }
    g_snd.musicRequestedState = SND_RestoreSoundMusicState(memFile);
    g_snd.musicCurrentState = SND_RestoreSoundMusicState(memFile);
    g_snd.musicPreviousState = SND_RestoreSoundMusicState(memFile);
    MemFile_ReadData(memFile, 1ui64, &p);
    g_snd.currentStateLooping = p;
    MemFile_ReadData(memFile, 4ui64, &g_snd.musicCurrentStateId);
    g_snd.musicCurrentPlaybackAsset = SND_RestoreSoundMusicAsset(memFile, g_snd.musicCurrentState);
  }
}

/*
==============
SND_RestoreSoundAlias
==============
*/
SndAlias *SND_RestoreSoundAlias(MemoryFile *memFile)
{
  const char *CString; 
  int v4; 
  SndAliasList *Alias; 
  SndAlias *head; 
  int v7; 
  int count; 
  SndAlias *v9; 
  bool v10; 
  unsigned __int16 p; 

  CString = MemFile_ReadCString(memFile);
  if ( !*CString )
    return 0i64;
  MemFile_ReadData(memFile, 2ui64, &p);
  v4 = p;
  Alias = SND_FindAlias(CString);
  if ( !Alias )
    goto LABEL_12;
  head = Alias->head;
  v7 = 0;
  count = Alias->count;
  v9 = head;
  v10 = count == 0;
  if ( count <= 0 )
  {
LABEL_8:
    if ( !v10 )
    {
      v9 = head;
      goto LABEL_10;
    }
LABEL_12:
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444ED5C0, 149i64, CString, v4);
    v9 = NULL;
    goto LABEL_13;
  }
  while ( v7 != v4 )
  {
    ++v9;
    if ( ++v7 >= count )
    {
      v10 = count == 0;
      goto LABEL_8;
    }
  }
LABEL_10:
  if ( !v9 )
  {
LABEL_13:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 9994, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
      __debugbreak();
  }
  return v9;
}

/*
==============
SND_RestoreSoundMusicAsset
==============
*/
SndMusicAsset *SND_RestoreSoundMusicAsset(MemoryFile *memFile, const SndMusicState *state)
{
  __int64 v4; 
  SndMusicAsset *result; 
  unsigned int loopCount; 
  int v7; 
  int p; 

  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10067, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  v4 = 0i64;
  MemFile_ReadData(memFile, 4ui64, &p);
  if ( !p || !state )
    return 0i64;
  if ( state->intro.aliasId == p )
    return &state->intro;
  loopCount = state->loopCount;
  if ( loopCount )
  {
    v7 = 0;
    while ( 1 )
    {
      result = &state->loops[v7];
      if ( result->aliasId == p )
        break;
      if ( ++v7 >= loopCount )
        return 0i64;
    }
  }
  else
  {
    if ( state->exit.aliasId == p )
      return &state->exit;
    return (SndMusicAsset *)v4;
  }
  return result;
}

/*
==============
SND_RestoreSoundMusicState
==============
*/
SndMusicState *SND_RestoreSoundMusicState(MemoryFile *memFile)
{
  SndMusicState *MusicState; 
  unsigned int p; 

  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10022, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  MemFile_ReadData(memFile, 4ui64, &p);
  if ( !p )
    return 0i64;
  MusicState = SND_GetMusicState(p);
  if ( !MusicState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10037, ASSERT_TYPE_ASSERT, "(state)", (const char *)&queryFormat, "state") )
    __debugbreak();
  MemFile_ReadData(memFile, 4ui64, &MusicState->status);
  return MusicState;
}

/*
==============
SND_RestoreStreamVoice
==============
*/
bool SND_RestoreStreamVoice(MemoryFile *memFile)
{
  SndAlias *v3; 
  const SndAlias *v4; 
  __int64 v16; 
  const char *v19; 
  unsigned __int16 soundDoneSoundString; 
  unsigned int secondaryId; 
  float rate; 
  float v31; 
  SndSubmixReq *submixRef; 
  float fraction; 
  int p; 
  int entChannel; 
  SndStartAliasInfo info; 
  SndVoice voice; 

  if ( !g_snd.paused && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10682, ASSERT_TYPE_ASSERT, "(g_snd.paused)", (const char *)&queryFormat, "g_snd.paused") )
    __debugbreak();
  v3 = SND_RestoreSoundAlias(memFile);
  v4 = v3;
  if ( v3 )
  {
    __asm { vmovaps [rsp+8B0h+var_10], xmm6 }
    MemFile_ReadData(memFile, 4ui64, &p);
    SND_RestoreVoiceInfo(&voice, memFile, &entChannel, &fraction);
    info.sndEnt = voice.sndEnt;
    info.alias = v4;
    GetSecureSndVec3(&voice.org.origin, &info.org, s_soundvoiceorg_aab_X, s_soundvoiceorg_aab_Y, s_soundvoiceorg_aab_Z);
    __asm
    {
      vmovss  xmm0, [rbp+7B0h+voice.volumeInfo.value]
      vmovss  xmm1, [rbp+7B0h+voice.priorityVolume]
      vmovss  xmm6, [rsp+8B0h+fraction]
      vmovss  [rsp+8B0h+info.volume], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.priorityAttenuation]
      vmovss  [rsp+8B0h+info.priorityVolume], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.pitchInfo.value]
    }
    info.system = SASYS_CGAME;
    __asm
    {
      vmovss  [rsp+8B0h+info.priorityAttenuation], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.lfeScale]
      vmovss  [rsp+8B0h+info.pitch], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.lpfCutoff]
      vmovss  [rbp+7B0h+info.lfeScale], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.hpfCutoff]
      vmovss  [rbp+7B0h+info.lpfCutoff], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.volumeScale]
      vmovss  [rbp+7B0h+info.hpfCutoff], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.pitchScale]
      vmovss  [rsp+8B0h+info.volumeScale], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.contextLerpVolume]
      vmovss  [rsp+8B0h+info.pitchScale], xmm0
      vmovss  [rsp+8B0h+info.contextLerpVolume], xmm1
      vmovss  [rbp+7B0h+info.fraction], xmm6
    }
    info.timeshift = 0;
    info.startDelayUs = 0;
    info.adsrIndex = voice.adsrIndex;
    info.fadeTime = 0;
    info.autoSimId = -1;
    info.autoSimTimeStamp = 0i64;
    info.secondaryGroupId = 0;
    info.preDelayed = 1;
    if ( SND_FindAssetsForVoice(&info) )
    {
      if ( (info.alias->flags & 0x380u) > 0x100 )
      {
        v16 = p;
        if ( !SND_StartAliasOnVoiceIndex(&info, p) || SND_IsVoiceFree(v16) )
        {
          SND_QueueSoundDoneNotify(g_snd.voices[v16].sndEnt & 0x1FFFFFFFFi64, g_snd.voices[v16].soundDoneSoundString);
        }
        else
        {
          __asm
          {
            vcvtss2sd xmm1, xmm6, xmm6
            vmovq   rdx, xmm1
          }
          v19 = j_va("restarted at %.3f", _RDX);
          SND_DebugAliasPrint(1, info.alias, v19);
          soundDoneSoundString = voice.soundDoneSoundString;
          _R8 = &g_snd;
          __asm
          {
            vmovss  xmm0, dword ptr [rbp+7B0h+voice.offset]
            vmovss  xmm1, dword ptr [rbp+7B0h+voice.offset+4]
          }
          _RCX = v16;
          __asm
          {
            vmovss  dword ptr [rcx+r8+0CAC8h], xmm0
            vmovss  xmm0, dword ptr [rbp+7B0h+voice.offset+8]
            vmovss  dword ptr [rcx+r8+0CAD0h], xmm0
            vmovsd  xmm0, qword ptr [rbp+7B0h+voice.submixHpf.value]
            vmovss  dword ptr [rcx+r8+0CACCh], xmm1
          }
          g_snd.voices[_RCX].soundDoneSoundString = soundDoneSoundString;
          g_snd.voices[_RCX].playbackId = voice.playbackId;
          secondaryId = voice.secondaryId;
          __asm
          {
            vmovsd  qword ptr [rcx+r8+0CB80h], xmm0
            vmovsd  xmm0, qword ptr [rbp+7B0h+voice.submixLpf.value]
          }
          g_snd.voices[_RCX].secondaryId = secondaryId;
          g_snd.voices[_RCX].submixHpf.rate = voice.submixHpf.rate;
          rate = voice.submixLpf.rate;
          __asm
          {
            vmovsd  qword ptr [rcx+r8+0CB74h], xmm0
            vmovsd  xmm0, qword ptr [rbp+7B0h+voice.submixAttenuation.value]
          }
          g_snd.voices[_RCX].submixLpf.rate = rate;
          v31 = voice.submixAttenuation.rate;
          __asm
          {
            vmovsd  qword ptr [rcx+r8+0CB68h], xmm0
            vmovss  xmm0, [rbp+7B0h+voice.basevolume]
          }
          g_snd.voices[_RCX].submixAttenuation.rate = v31;
          g_snd.voices[_RCX].submixDef = voice.submixDef;
          submixRef = voice.submixRef;
          __asm
          {
            vmovss  dword ptr [rcx+r8+0CA58h], xmm0
            vmovss  xmm0, [rbp+7B0h+voice.basepitch]
          }
          g_snd.voices[_RCX].submixRef = submixRef;
          LOBYTE(submixRef) = voice.occlusionMatchesListener;
          __asm
          {
            vmovss  dword ptr [rcx+r8+0CA84h], xmm0
            vmovss  xmm0, [rbp+7B0h+voice.occlusionAmount]
          }
          g_snd.voices[_RCX].occlusionMatchesListener = (char)submixRef;
          __asm { vmovss  dword ptr [rcx+r8+0CAE4h], xmm0 }
          g_snd.voices[_RCX].occlusionWaitId = 0;
          g_snd.voices[_RCX].wasRestored = 1;
        }
      }
      else
      {
        Com_PrintWarning(9, "Sound alias %s was restored as a stream voice but is now a loaded alias. Ignoring...\n", info.alias->aliasName);
      }
    }
    else
    {
      Com_PrintError(9, "Sound alias %s's sound data was not yet loaded when played.\n", info.alias->aliasName);
    }
    __asm { vmovaps xmm6, [rsp+8B0h+var_10] }
    LOBYTE(v3) = 1;
  }
  return (char)v3;
}

/*
==============
SND_RestoreTransientBanks
==============
*/
void SND_RestoreTransientBanks(MemoryFile *memFile)
{
  SndBankInfo **v2; 
  const SndBank *bank; 
  const char *i; 
  int v5; 
  SndBankInfo **v6; 
  SndBankInfo *v7; 
  const SndBank *v8; 
  const char *name; 
  __int64 v10; 
  signed __int64 v11; 
  char v12; 
  __int64 v13; 
  char v14; 
  const char *j; 
  char v16; 
  unsigned int v17; 
  char v18; 
  unsigned __int64 p; 

  Sys_EnterCriticalSection(CRITSECT_SOUND_BANK);
  v2 = &g_sb.bankStack[32];
  do
  {
    bank = (*v2)->bank;
    if ( bank && !bank->streamInfo.alwaysLoaded && (*v2)->bankActive && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10890, ASSERT_TYPE_ASSERT, "(bankInfo->bank->streamInfo.alwaysLoaded || !bankInfo->bankActive)", "%s\n\tTransient bank %s already active", "bankInfo->bank->streamInfo.alwaysLoaded || !bankInfo->bankActive", bank->name) )
      __debugbreak();
    ++v2;
  }
  while ( (__int64)v2 < (__int64)&g_sb.loadGate );
  SND_BankDetailStreaming_Reset();
  for ( i = MemFile_ReadCString(memFile); *i; i = MemFile_ReadCString(memFile) )
  {
    MemFile_ReadData(memFile, 4ui64, &p);
    v5 = p;
    v6 = &g_sb.bankStack[32];
    while ( 1 )
    {
      v7 = *v6;
      v8 = (*v6)->bank;
      if ( v8 )
      {
        if ( !v8->streamInfo.alwaysLoaded )
          break;
      }
LABEL_20:
      if ( (__int64)++v6 >= (__int64)&g_sb.loadGate )
      {
        Com_PrintWarning(9, "Could not restore transient sound bank %s\n", i);
        goto LABEL_22;
      }
    }
    name = v8->name;
    v10 = 0x7FFFFFFFi64;
    if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v11 = i - name;
    do
    {
      v12 = name[v11];
      v13 = v10;
      v14 = *name++;
      --v10;
      if ( !v13 )
        break;
      if ( v12 != v14 )
        goto LABEL_20;
    }
    while ( v12 );
    v7->streamIsActive = 1;
    v7->streamPriority = v5;
LABEL_22:
    ;
  }
  g_sb.numScriptDetailStreamRequests = 0;
  for ( j = MemFile_ReadCString(memFile); *j; j = MemFile_ReadCString(memFile) )
  {
    MemFile_ReadData(memFile, 4ui64, &p);
    v16 = *j;
    if ( *j )
    {
      v17 = 5381;
      do
      {
        ++j;
        v18 = v16 | 0x20;
        if ( (unsigned int)(v16 - 65) >= 0x1A )
          v18 = v16;
        v17 = 65599 * v17 + v18;
        v16 = *j;
      }
      while ( *j );
      if ( !v17 )
        v17 = 1;
    }
    else
    {
      v17 = 0;
    }
    SND_BankDetailStreaming_AddScriptBankRequest(v17, p);
  }
  MemFile_ReadData(memFile, 8ui64, &p);
  g_sb.scriptedSoundbanksStateBitfield = p;
  Sys_LeaveCriticalSection(CRITSECT_SOUND_BANK);
}

/*
==============
SND_RestoreVoice
==============
*/
bool SND_RestoreVoice(MemoryFile *memFile)
{
  SndAlias *v3; 
  const SndAlias *v4; 
  const char *v20; 
  unsigned __int16 soundDoneSoundString; 
  unsigned int secondaryId; 
  float rate; 
  float v30; 
  SndSubmixReq *submixRef; 
  float fraction; 
  int p; 
  int entChannel; 
  SndStartAliasInfo info; 
  SndVoice voice; 

  if ( !g_snd.paused && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10567, ASSERT_TYPE_ASSERT, "(g_snd.paused)", (const char *)&queryFormat, "g_snd.paused") )
    __debugbreak();
  v3 = SND_RestoreSoundAlias(memFile);
  v4 = v3;
  if ( v3 )
  {
    __asm { vmovaps [rsp+8B0h+var_10], xmm6 }
    MemFile_ReadData(memFile, 4ui64, &p);
    SND_RestoreVoiceInfo(&voice, memFile, &entChannel, &fraction);
    info.sndEnt = voice.sndEnt;
    info.alias = v4;
    GetSecureSndVec3(&voice.org.origin, &info.org, s_soundvoiceorg_aab_X, s_soundvoiceorg_aab_Y, s_soundvoiceorg_aab_Z);
    __asm
    {
      vmovss  xmm0, [rbp+7B0h+voice.volumeInfo.value]
      vmovss  xmm1, [rbp+7B0h+voice.priorityVolume]
      vmovss  xmm6, [rsp+8B0h+fraction]
      vmovss  [rsp+8B0h+info.volume], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.priorityAttenuation]
      vmovss  [rsp+8B0h+info.priorityVolume], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.pitchInfo.value]
    }
    info.system = SASYS_CGAME;
    __asm
    {
      vmovss  [rsp+8B0h+info.priorityAttenuation], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.lfeScale]
      vmovss  [rsp+8B0h+info.pitch], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.lpfCutoff]
      vmovss  [rbp+7B0h+info.lfeScale], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.hpfCutoff]
      vmovss  [rbp+7B0h+info.lpfCutoff], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.volumeScale]
      vmovss  [rbp+7B0h+info.hpfCutoff], xmm0
      vmovss  xmm0, [rbp+7B0h+voice.pitchScale]
      vmovss  [rsp+8B0h+info.volumeScale], xmm1
      vmovss  xmm1, [rbp+7B0h+voice.contextLerpVolume]
      vmovss  [rsp+8B0h+info.pitchScale], xmm0
      vmovss  [rsp+8B0h+info.contextLerpVolume], xmm1
      vmovss  [rbp+7B0h+info.fraction], xmm6
    }
    info.timeshift = 0;
    info.startDelayUs = 0;
    info.adsrIndex = voice.adsrIndex;
    info.fadeTime = 0;
    info.autoSimId = -1;
    info.autoSimTimeStamp = 0i64;
    info.secondaryGroupId = 0;
    info.preDelayed = 1;
    if ( SND_FindAssetsForVoice(&info) )
    {
      if ( (info.alias->flags & 0x380u) <= 0x100 )
      {
        _RBX = p;
        _RDI = &g_snd;
        if ( SND_StartAliasOnVoiceIndex(&info, p) )
        {
          __asm
          {
            vcvtss2sd xmm1, xmm6, xmm6
            vmovq   rdx, xmm1
          }
          v20 = j_va("restarted at %.3f", _RDX);
          SND_DebugAliasPrint(1, info.alias, v20);
          soundDoneSoundString = voice.soundDoneSoundString;
          __asm
          {
            vmovss  xmm0, dword ptr [rbp+7B0h+voice.offset]
            vmovss  xmm1, dword ptr [rbp+7B0h+voice.offset+4]
            vmovss  dword ptr [rbx+rdi+0CAC8h], xmm0
            vmovss  xmm0, dword ptr [rbp+7B0h+voice.offset+8]
            vmovss  dword ptr [rbx+rdi+0CAD0h], xmm0
            vmovsd  xmm0, qword ptr [rbp+7B0h+voice.submixHpf.value]
            vmovss  dword ptr [rbx+rdi+0CACCh], xmm1
          }
          g_snd.voices[_RBX].soundDoneSoundString = soundDoneSoundString;
          g_snd.voices[_RBX].playbackId = voice.playbackId;
          secondaryId = voice.secondaryId;
          __asm
          {
            vmovsd  qword ptr [rbx+rdi+0CB80h], xmm0
            vmovsd  xmm0, qword ptr [rbp+7B0h+voice.submixLpf.value]
          }
          g_snd.voices[_RBX].secondaryId = secondaryId;
          g_snd.voices[_RBX].submixHpf.rate = voice.submixHpf.rate;
          rate = voice.submixLpf.rate;
          __asm
          {
            vmovsd  qword ptr [rbx+rdi+0CB74h], xmm0
            vmovsd  xmm0, qword ptr [rbp+7B0h+voice.submixAttenuation.value]
          }
          g_snd.voices[_RBX].submixLpf.rate = rate;
          v30 = voice.submixAttenuation.rate;
          __asm
          {
            vmovsd  qword ptr [rbx+rdi+0CB68h], xmm0
            vmovss  xmm0, [rbp+7B0h+voice.basevolume]
          }
          g_snd.voices[_RBX].submixAttenuation.rate = v30;
          g_snd.voices[_RBX].submixDef = voice.submixDef;
          submixRef = voice.submixRef;
          __asm
          {
            vmovss  dword ptr [rbx+rdi+0CA58h], xmm0
            vmovss  xmm0, [rbp+7B0h+voice.basepitch]
          }
          g_snd.voices[_RBX].submixRef = submixRef;
          LOBYTE(submixRef) = voice.occlusionMatchesListener;
          __asm
          {
            vmovss  dword ptr [rbx+rdi+0CA84h], xmm0
            vmovss  xmm0, [rbp+7B0h+voice.occlusionAmount]
          }
          g_snd.voices[_RBX].occlusionMatchesListener = (char)submixRef;
          __asm { vmovss  dword ptr [rbx+rdi+0CAE4h], xmm0 }
          g_snd.voices[_RBX].occlusionWaitId = 0;
          g_snd.voices[_RBX].wasRestored = 1;
        }
        else
        {
          SND_QueueSoundDoneNotify(g_snd.voices[_RBX].sndEnt & 0x1FFFFFFFFi64, g_snd.voices[_RBX].soundDoneSoundString);
        }
      }
      else
      {
        Com_PrintWarning(9, "Sound alias %s was restored as a loaded voice but is now a streaming alias. Ignoring...\n", info.alias->aliasName);
      }
    }
    else
    {
      Com_PrintError(9, "Sound alias %s's sound data was not yet loaded when played.\n", info.alias->aliasName);
    }
    LOBYTE(v3) = 1;
    __asm { vmovaps xmm6, [rsp+8B0h+var_10] }
  }
  return (char)v3;
}

/*
==============
SND_RestoreVoiceIndex
==============
*/
__int64 SND_RestoreVoiceIndex(MemoryFile *memFile)
{
  unsigned int p; 

  MemFile_ReadData(memFile, 4ui64, &p);
  return p;
}

/*
==============
SND_RestoreVoiceInfo
==============
*/
void SND_RestoreVoiceInfo(SndVoice *voice, MemoryFile *memFile, int *entChannel, float *fraction)
{
  vec3_t origin; 
  unsigned __int64 p; 

  _RBP = fraction;
  _RBX = voice;
  memset_0(voice, 0, sizeof(SndVoice));
  MemFile_ReadData(memFile, 8ui64, &p);
  _RBX->sndEnt = p;
  MemFile_ReadData(memFile, 1ui64, &p);
  *entChannel = (unsigned __int8)p;
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+54h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+84h], xmm0 }
  _RBX->distanceScale = 1.0;
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+58h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+5Ch], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+60h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+2Ch], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+30h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+28h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+80h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+38h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+3Ch], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+40h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+44h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+48h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+50h], xmm0 }
  MemFile_ReadData(memFile, 1ui64, &p);
  _RBX->occlusionMatchesListener = p;
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+0B4h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+98h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+9Ch], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+0A0h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rsp+48h+origin], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rsp+48h+origin+4], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rsp+48h+origin+8], xmm0 }
  SndVoice_SetOrigin(_RBX, &origin);
  MemFile_ReadData(memFile, 2ui64, &p);
  _RBX->soundDoneSoundString = p;
  MemFile_ReadData(memFile, 4ui64, &p);
  _RBX->adsrIndex = p;
  MemFile_ReadData(memFile, 4ui64, &_RBX->playbackId);
  MemFile_ReadData(memFile, 4ui64, &_RBX->secondaryId);
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+0FCh], xmm0 }
  MemFile_ReadData(memFile, 0xCui64, &_RBX->submixAttenuation);
  MemFile_ReadData(memFile, 0xCui64, &_RBX->submixLpf);
  MemFile_ReadData(memFile, 0xCui64, &_RBX->submixHpf);
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+100h], xmm0 }
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbx+104h], xmm0 }
  SND_SubmixVoiceRestore(memFile, _RBX);
  *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
  __asm { vmovss  dword ptr [rbp+0], xmm0 }
  memset(&origin, 0, sizeof(origin));
}

/*
==============
SND_RestoreVoiceSync
==============
*/
void SND_RestoreVoiceSync(int voiceIndex, MemoryFile *memFile)
{
  __int64 v3; 
  int VoiceIndexForId; 
  sd_voice *v7; 
  int p; 
  unsigned int id; 

  v3 = voiceIndex;
  _RBX = g_sd.voices[voiceIndex];
  MemFile_ReadData(memFile, 1ui64, &p);
  if ( (_BYTE)p )
  {
    if ( _RBX )
    {
      _RBX->isSync = 1;
      *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
      __asm { vmovss  dword ptr [rbx+37Ch], xmm0 }
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncMeter = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStart = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStartFrameOffset = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStartDelayBeats = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStartFadeBeats = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStop = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStopBeats = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStopDelayBeats = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStopFadeBeats = p;
      MemFile_ReadData(memFile, 4ui64, &_RBX->syncState);
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncTimestamp = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStartDelayFrames = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStartFadeFrames = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStopDelayFrames = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStopFadeFrames = p;
      MemFile_ReadData(memFile, 1ui64, &p);
      _RBX->syncSoftStart = (_BYTE)p == 1;
      *(double *)&_XMM0 = MemFile_ReadFloat(memFile);
      __asm { vmovss  dword ptr [rbx+3C0h], xmm0 }
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStartDelayFramesDecoded = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStartFadeFramesDecoded = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStopDelayFramesDecoded = p;
      MemFile_ReadData(memFile, 4ui64, &p);
      _RBX->syncStopFadeFramesDecoded = p;
      MemFile_ReadData(memFile, 4ui64, &id);
      VoiceIndexForId = SND_GetVoiceIndexForId(id);
      if ( VoiceIndexForId != -1 )
      {
        v7 = g_sd.voices[v3];
        if ( v7 )
          v7->syncMaster = g_sd.voices[VoiceIndexForId];
      }
    }
  }
}

/*
==============
SND_SV_CheckAndClearEntityHasParams
==============
*/
bool SND_SV_CheckAndClearEntityHasParams(int entNum)
{
  int v1; 
  unsigned __int16 *v2; 
  bool result; 

  v1 = 0;
  while ( 1 )
  {
    v2 = &g_sndSVEntityParamSet[((_BYTE)v1 + (unsigned __int8)(entNum % 64)) & 0x3F];
    if ( *v2 == entNum )
      break;
    if ( (unsigned int)++v1 >= 0x40 )
      return 0;
  }
  result = 1;
  *v2 = 2047;
  return result;
}

/*
==============
SND_SV_SetEntityHasParams
==============
*/
void SND_SV_SetEntityHasParams(int entNum)
{
  char v2; 
  unsigned int i; 
  unsigned __int16 *v4; 
  int v5; 

  v2 = entNum % 64;
  for ( i = 0; i < 0x40; ++i )
  {
    v4 = &g_sndSVEntityParamSet[((_BYTE)i + v2) & 0x3F];
    v5 = *v4;
    if ( v5 == entNum )
      break;
    if ( (_WORD)v5 == 2047 )
    {
      if ( (entNum < 0 || (unsigned int)entNum > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,int>(int)", "unsigned", (unsigned __int16)entNum, "signed", entNum) )
        __debugbreak();
      *v4 = entNum;
      return;
    }
  }
}

/*
==============
SND_Save
==============
*/
void SND_Save(MemoryFile *memFile)
{
  const SndBankInfo **v3; 
  const SndBankInfo *v4; 
  const SndBank *bank; 
  int v6; 
  int *p_streamPriority; 
  snd_channelvolgroup *v8; 
  __int64 v9; 
  SDLocal *v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 i; 
  int v16; 
  TimeLerp *globalContextLerp; 
  __int64 v18; 
  unsigned int *globalContextsFrom; 
  int j; 
  int k; 
  int v22; 
  bool *v23; 
  int *v24; 
  __int64 v25; 
  snd_alias_system_t *p_system; 
  int m; 
  int n; 
  __int64 v30; 
  unsigned __int64 p; 

  if ( SND_Active() )
  {
    SND_ProcessPendingRestore();
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    cls.inUpdateSound = 1;
    Sys_EnterCriticalSection(CRITSECT_SOUND_BANK);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
    Sys_EnterCriticalSection(CRITSECT_SOUND_BANK);
    v3 = (const SndBankInfo **)&g_sb.bankStack[32];
    do
    {
      v4 = *v3;
      bank = (*v3)->bank;
      if ( bank && !bank->streamInfo.alwaysLoaded && v4->bankActive && SND_IsBankInUse(*v3) )
      {
        MemFile_WriteCString(memFile, v4->bank->name);
        LODWORD(p) = v4->streamPriority;
        MemFile_WriteData(memFile, 4ui64, &p);
      }
      ++v3;
    }
    while ( (__int64)v3 < (__int64)&g_sb.loadGate );
    MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
    v6 = 0;
    if ( g_sb.numScriptDetailStreamRequests > 0 )
    {
      p_streamPriority = &g_sb.scriptDetailStreamRequests[0].streamPriority;
      do
      {
        MemFile_WriteCString(memFile, ***((const char ****)p_streamPriority - 1));
        LODWORD(p) = *p_streamPriority;
        MemFile_WriteData(memFile, 4ui64, &p);
        ++v6;
        p_streamPriority += 8;
      }
      while ( v6 < g_sb.numScriptDetailStreamRequests );
    }
    MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
    p = g_sb.scriptedSoundbanksStateBitfield;
    MemFile_WriteData(memFile, 8ui64, &p);
    Sys_LeaveCriticalSection(CRITSECT_SOUND_BANK);
    v8 = &g_snd.channelPriorityVolGroups[1];
    v9 = 3i64;
    do
    {
      MemFile_WriteData(memFile, 0x1804ui64, v8++);
      --v9;
    }
    while ( v9 );
    MemFile_WriteData(memFile, 0x18ui64, g_snd.reverbSetting);
    MemFile_WriteData(memFile, 8ui64, &g_snd.mainReverbLerp);
    MemFile_WriteData(memFile, 4ui64, &g_snd.activeMainReverb);
    MemFile_WriteData(memFile, 8ui64, g_snd.farReverbTimestamp);
    MemFile_WriteData(memFile, 8ui64, g_snd.farReverbIds);
    MemFile_WriteData(memFile, 0x30ui64, g_snd.reverbPosition);
    MemFile_WriteData(memFile, 0x10ui64, g_snd.reverbTrigger);
    MemFile_WriteData(memFile, 0x420ui64, &g_snd.entchanOverrides);
    __asm { vmovss  xmm1, cs:?sdGlob@@3USDLocal@@A.eqLerp; value }
    MemFile_WriteFloat(memFile, *(float *)&_XMM1);
    v11 = &sdGlob;
    v12 = 2i64;
    do
    {
      v13 = 2i64;
      do
      {
        v14 = 256i64;
        do
        {
          MemFile_WriteData(memFile, 0x14ui64, v11);
          v11 = (SDLocal *)((char *)v11 + 20);
          --v14;
        }
        while ( v14 );
        --v13;
      }
      while ( v13 );
      --v12;
    }
    while ( v12 );
    MemFile_WriteData(memFile, 0xD00ui64, g_sndEntityParamInfo);
    MemFile_WriteData(memFile, 0x100ui64, g_sndEntityParamIndex);
    MemFile_WriteData(memFile, 0x80ui64, g_sndSVEntityParamSet);
    MemFile_WriteData(memFile, 0x1804ui64, &g_snd.levelFadeInChannelVols);
    if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10203, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    for ( i = 0i64; (unsigned int)i < g_snd.globals->volmodinfoCount; i = (unsigned int)(i + 1) )
      MemFile_WriteData(memFile, 0x18ui64, &g_snd.volmods[i]);
    v16 = 0;
    globalContextLerp = g_snd.globalContextLerp;
    v18 = 0i64;
    globalContextsFrom = g_snd.globalContextsFrom;
    do
    {
      if ( globalContextsFrom[64] || *globalContextsFrom )
      {
        if ( v16 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,int>(int)", "unsigned", (unsigned __int8)v16, "signed", v18) )
          __debugbreak();
        LOBYTE(p) = v16;
        MemFile_WriteData(memFile, 1ui64, &p);
        LODWORD(p) = globalContextsFrom[64];
        MemFile_WriteData(memFile, 4ui64, &p);
        LODWORD(p) = *globalContextsFrom;
        MemFile_WriteData(memFile, 4ui64, &p);
        MemFile_WriteData(memFile, 8ui64, globalContextLerp);
      }
      ++v16;
      ++v18;
      ++globalContextsFrom;
      ++globalContextLerp;
    }
    while ( v16 < 64 );
    LOBYTE(p) = -1;
    MemFile_WriteData(memFile, 1ui64, &p);
    SND_SaveEntStates(memFile);
    CG_SaveAudioTriggerStates(memFile);
    SND_SubmixSave(memFile);
    SND_SaveMusicStatus(memFile);
    if ( g_snd.driverInitialized )
    {
      for ( j = 32; j < 80; ++j )
        SND_SaveVoice(j, memFile);
    }
    MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
    if ( g_snd.driverInitialized )
    {
      for ( k = 0; k < 32; ++k )
        SND_SaveVoice(k, memFile);
    }
    MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
    if ( g_snd.driverInitialized )
    {
      v22 = 80;
      v23 = &sdGlob.voiceAlloc[80];
      v24 = (int *)&g_snd.chaninfoEntchannel[80];
      v25 = 80i64;
      p_system = &g_snd.voices[80].system;
      while ( 1 )
      {
        if ( (unsigned int)(v22 - 80) > 0xD )
        {
          LODWORD(v30) = v22;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10634, ASSERT_TYPE_ASSERT, "( ( chanIndex >= ((0 + 32) + 48) && chanIndex < ((0 + 32) + 48) + ( SND_TRACK_COUNT + 10 ) ) )", "( chanIndex ) = %i", v30) )
            __debugbreak();
        }
        if ( v22 >= 84 )
          break;
        if ( (unsigned int)(v22 - 80) > 3 )
        {
          if ( (unsigned int)v22 > 0x62 )
          {
            LODWORD(v30) = v22;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v30) )
              __debugbreak();
          }
          if ( !*v23 || *p_system != SASYS_CGAME )
          {
            MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
            goto LABEL_56;
          }
          goto LABEL_54;
        }
LABEL_56:
        ++v22;
        ++v25;
        ++v23;
        p_system += 492;
        ++v24;
        if ( v22 >= 94 )
          goto LABEL_57;
      }
      if ( !*v23 || *p_system != SASYS_CGAME )
        goto LABEL_56;
LABEL_54:
      SND_SaveSoundAlias(*(const SndAlias **)(p_system - 19), memFile);
      LODWORD(p) = truncate_cast<int,__int64>(v25 * 1968 / 1968);
      MemFile_WriteData(memFile, 4ui64, &p);
      *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(v22, 1);
      __asm { vmovaps xmm3, xmm0; fraction }
      SND_SaveVoiceInfo(&g_snd.voices[v25], memFile, *v24, *(float *)&_XMM3);
      goto LABEL_56;
    }
LABEL_57:
    MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
    if ( g_snd.driverInitialized )
    {
      for ( m = 94; m < 99; ++m )
        SND_SaveVoice(m, memFile);
    }
    MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
    for ( n = 0; n < 99; ++n )
      SND_SaveVoiceSync(n, memFile);
    MemFile_WriteData(memFile, 4ui64, &g_snd.playbackIdCounter);
    Sys_LeaveCriticalSection(CRITSECT_SOUND_BANK);
    cls.inUpdateSound = 0;
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  }
}

/*
==============
SND_SaveEntStates
==============
*/
void SND_SaveEntStates(MemoryFile *memFile)
{
  unsigned int v2; 
  __int64 v3; 
  vec3_t *v4; 
  unsigned int *v5; 
  bool v6; 
  unsigned int v7; 
  int v8; 
  __int64 v9; 
  _DWORD *v; 
  unsigned int *v11; 
  vec3_t *v12; 
  vec3_t to; 
  __int64 p; 
  unsigned int v15; 
  __int64 v16; 

  v2 = 0;
  v15 = 0;
  v3 = 0i64;
  v16 = 0i64;
  v4 = &g_snd.entState[0].orientation.m[1];
  v12 = &g_snd.entState[0].orientation.m[1];
  v5 = &g_snd.entState[0].contextTypes[2];
  v11 = &g_snd.entState[0].contextTypes[2];
  do
  {
    v6 = *v5 != 0 || *(v5 - 1) != 0;
    if ( *(v5 - 2) )
      v6 = 1;
    if ( v6 || LODWORD(v4[3].v[1]) != 0 )
    {
      LOBYTE(p) = v2;
      MemFile_WriteData(memFile, 1ui64, &p);
      p = *(_QWORD *)&v4[-2].y;
      MemFile_WriteData(memFile, 8ui64, &p);
      v7 = LODWORD(v4[3].v[1]);
      if ( v7 > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)v7, "unsigned", LODWORD(v4[3].v[1])) )
        __debugbreak();
      LOBYTE(p) = v7;
      MemFile_WriteData(memFile, 1ui64, &p);
      if ( LODWORD(v4[3].v[1]) )
      {
        if ( v4 == (vec3_t *)84 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 875, ASSERT_TYPE_ASSERT, "(sndEntState)", (const char *)&queryFormat, "sndEntState") )
          __debugbreak();
        GetSecureSndVec3(v4 + 2, &to, s_soundorg_aab_X, s_soundorg_aab_Y, s_soundorg_aab_Z);
        MemFile_WriteData(memFile, 0xCui64, &to);
        MemFile_WriteData(memFile, 0xCui64, &v4[-1]);
        MemFile_WriteData(memFile, 0xCui64, v4);
        MemFile_WriteData(memFile, 0xCui64, &v4[1]);
        memset(&to, 0, sizeof(to));
      }
      v8 = 0;
      v9 = 0i64;
      v = (_DWORD *)v4[-7].v;
      do
      {
        LODWORD(p) = *v;
        MemFile_WriteData(memFile, 4ui64, &p);
        if ( *v )
        {
          if ( v8 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,int>(int)", "unsigned", (unsigned __int8)v8, "signed", v9) )
            __debugbreak();
          LOBYTE(p) = v8;
          MemFile_WriteData(memFile, 1ui64, &p);
          LODWORD(p) = v[3];
          MemFile_WriteData(memFile, 4ui64, &p);
          LODWORD(p) = v[6];
          MemFile_WriteData(memFile, 4ui64, &p);
          LODWORD(p) = v[9];
          MemFile_WriteData(memFile, 4ui64, &p);
          LODWORD(p) = v[12];
          MemFile_WriteData(memFile, 4ui64, &p);
        }
        ++v8;
        ++v9;
        ++v;
      }
      while ( v8 < 3 );
      v4 = v12;
      v2 = v15;
      v5 = v11;
      v3 = v16;
    }
    v15 = ++v2;
    v16 = ++v3;
    v5 += 32;
    v11 = v5;
    v4 = (vec3_t *)((char *)v4 + 128);
    v12 = v4;
  }
  while ( v2 < 0x80 );
  LOBYTE(p) = -1;
  MemFile_WriteData(memFile, 1ui64, &p);
}

/*
==============
SND_SaveEntityParamInfo
==============
*/
void SND_SaveEntityParamInfo(MemoryFile *memFile)
{
  MemFile_WriteData(memFile, 0xD00ui64, g_sndEntityParamInfo);
  MemFile_WriteData(memFile, 0x100ui64, g_sndEntityParamIndex);
  MemFile_WriteData(memFile, 0x80ui64, g_sndSVEntityParamSet);
}

/*
==============
SND_SaveEq
==============
*/
void SND_SaveEq(MemoryFile *memFile)
{
  SDLocal *v3; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 

  __asm { vmovss  xmm1, cs:?sdGlob@@3USDLocal@@A.eqLerp; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  v3 = &sdGlob;
  v4 = 2i64;
  do
  {
    v5 = 2i64;
    do
    {
      v6 = 256i64;
      do
      {
        MemFile_WriteData(memFile, 0x14ui64, v3);
        v3 = (SDLocal *)((char *)v3 + 20);
        --v6;
      }
      while ( v6 );
      --v5;
    }
    while ( v5 );
    --v4;
  }
  while ( v4 );
}

/*
==============
SND_SaveMusicStatus
==============
*/
void SND_SaveMusicStatus(MemoryFile *memFile)
{
  SndMusicState **p_state; 
  __int64 v3; 
  __int16 v4; 
  __int64 v5; 
  bool v6; 
  __int16 v7; 
  unsigned int *p_id; 
  const SndMusicState *v9; 
  __int64 v10; 
  const SndMusicAsset *musicCurrentPlaybackAsset; 
  unsigned int p; 

  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10106, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10107, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  p_state = &g_snd.musicPlaybacks[0].state;
  v3 = 16i64;
  v4 = 0;
  v5 = 16i64;
  do
  {
    v6 = *p_state == NULL;
    v7 = v4 + 1;
    p_state += 5;
    if ( v6 )
      v7 = v4;
    v4 = v7;
    --v5;
  }
  while ( v5 );
  LOWORD(p) = v7;
  MemFile_WriteData(memFile, 2ui64, &p);
  p_id = &g_snd.musicPlaybacks[0].id;
  do
  {
    v9 = (const SndMusicState *)*((_QWORD *)p_id - 1);
    if ( v9 )
    {
      SND_SaveSoundMusicState(v9, memFile);
      v10 = *((_QWORD *)p_id - 2);
      if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10047, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
        __debugbreak();
      if ( v10 )
        p = *(_DWORD *)(v10 + 64);
      else
        p = 0;
      MemFile_WriteData(memFile, 4ui64, &p);
      MemFile_WriteData(memFile, 4ui64, p_id);
      MemFile_WriteData(memFile, 4ui64, p_id + 1);
      p = p_id[2];
      MemFile_WriteData(memFile, 4ui64, &p);
      p = p_id[3];
      MemFile_WriteData(memFile, 4ui64, &p);
      p = p_id[4];
      MemFile_WriteData(memFile, 4ui64, &p);
    }
    p_id += 10;
    --v3;
  }
  while ( v3 );
  SND_SaveSoundMusicState(g_snd.musicRequestedState, memFile);
  SND_SaveSoundMusicState(g_snd.musicCurrentState, memFile);
  SND_SaveSoundMusicState(g_snd.musicPreviousState, memFile);
  LOBYTE(p) = g_snd.currentStateLooping;
  MemFile_WriteData(memFile, 1ui64, &p);
  MemFile_WriteData(memFile, 4ui64, &g_snd.musicCurrentStateId);
  musicCurrentPlaybackAsset = NULL;
  if ( g_snd.musicCurrentState )
    musicCurrentPlaybackAsset = g_snd.musicCurrentPlaybackAsset;
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10047, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  if ( musicCurrentPlaybackAsset )
    p = musicCurrentPlaybackAsset->aliasId;
  else
    p = 0;
  MemFile_WriteData(memFile, 4ui64, &p);
}

/*
==============
SND_SaveSoundAlias
==============
*/
void SND_SaveSoundAlias(const SndAlias *alias, MemoryFile *memFile)
{
  SndAliasList *v4; 
  int count; 
  int v6; 
  const SndAlias *head; 
  __int16 p; 

  MemFile_WriteCString(memFile, alias->aliasName);
  if ( !alias->aliasName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14979, ASSERT_TYPE_ASSERT, "(alias->aliasName)", (const char *)&queryFormat, "alias->aliasName") )
    __debugbreak();
  v4 = SND_FindAlias(alias->aliasName);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14982, ASSERT_TYPE_ASSERT, "(aliasList)", (const char *)&queryFormat, "aliasList") )
    __debugbreak();
  count = v4->count;
  v6 = 0;
  head = v4->head;
  if ( count <= 0 )
  {
LABEL_10:
    LOWORD(v6) = 0;
  }
  else
  {
    while ( head != alias )
    {
      ++head;
      if ( ++v6 >= count )
        goto LABEL_10;
    }
  }
  p = v6;
  MemFile_WriteData(memFile, 2ui64, &p);
}

/*
==============
SND_SaveSoundMusicState
==============
*/
void SND_SaveSoundMusicState(const SndMusicState *state, MemoryFile *memFile)
{
  SndMusicStateStatus *p_status; 
  unsigned int p; 

  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10001, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  if ( state )
  {
    p = SND_HashName(state->name);
    MemFile_WriteData(memFile, 4ui64, &p);
    p_status = &state->status;
  }
  else
  {
    p = 0;
    p_status = (SndMusicStateStatus *)&p;
  }
  MemFile_WriteData(memFile, 4ui64, p_status);
}

/*
==============
SND_SaveTransientBanks
==============
*/
void SND_SaveTransientBanks(MemoryFile *memFile)
{
  const SndBankInfo **v2; 
  const SndBankInfo *v3; 
  const SndBank *bank; 
  int v5; 
  int *p_streamPriority; 
  unsigned __int64 p; 

  Sys_EnterCriticalSection(CRITSECT_SOUND_BANK);
  v2 = (const SndBankInfo **)&g_sb.bankStack[32];
  do
  {
    v3 = *v2;
    bank = (*v2)->bank;
    if ( bank && !bank->streamInfo.alwaysLoaded && v3->bankActive && SND_IsBankInUse(*v2) )
    {
      MemFile_WriteCString(memFile, v3->bank->name);
      LODWORD(p) = v3->streamPriority;
      MemFile_WriteData(memFile, 4ui64, &p);
    }
    ++v2;
  }
  while ( (__int64)v2 < (__int64)&g_sb.loadGate );
  MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
  v5 = 0;
  if ( g_sb.numScriptDetailStreamRequests > 0 )
  {
    p_streamPriority = &g_sb.scriptDetailStreamRequests[0].streamPriority;
    do
    {
      MemFile_WriteCString(memFile, ***((const char ****)p_streamPriority - 1));
      LODWORD(p) = *p_streamPriority;
      MemFile_WriteData(memFile, 4ui64, &p);
      ++v5;
      p_streamPriority += 8;
    }
    while ( v5 < g_sb.numScriptDetailStreamRequests );
  }
  MemFile_WriteCString(memFile, (const char *)&queryFormat.fmt + 3);
  p = g_sb.scriptedSoundbanksStateBitfield;
  MemFile_WriteData(memFile, 8ui64, &p);
  Sys_LeaveCriticalSection(CRITSECT_SOUND_BANK);
}

/*
==============
SND_SaveVoice
==============
*/
void SND_SaveVoice(int chanIndex, MemoryFile *memFile)
{
  __int64 v3; 
  const SndVoice *v8; 
  __int64 v11; 

  v3 = chanIndex;
  if ( (unsigned int)chanIndex > 0x62 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10536, ASSERT_TYPE_ASSERT, "( ( chanIndex >= 0 && chanIndex < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( chanIndex ) = %i", chanIndex) )
      __debugbreak();
    if ( (unsigned int)v3 > 0x62 )
    {
      LODWORD(v11) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v11) )
        __debugbreak();
    }
  }
  _R14 = 0x140000000ui64;
  if ( sdGlob.voiceAlloc[v3] )
  {
    _RBX = 1968 * v3;
    if ( LODWORD(g_snd.chaninfoUnweightedPriority[492 * v3 - 48661]) == 1 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vucomiss xmm0, dword ptr [rbx+r14+15C6C3D4h]
      }
      if ( LODWORD(g_snd.chaninfoUnweightedPriority[492 * v3 - 48661]) != 1 )
      {
        SND_SaveSoundAlias(*(const SndAlias **)&g_snd.chaninfoUnweightedPriority[_RBX / 4 - 48680], memFile);
        v8 = &g_snd.voices[_RBX / 0x7B0];
        SND_SaveVoiceIndex(memFile, v8);
        *(double *)&_XMM0 = SND_GetVoiceFractionPlayed(v3, 1);
        __asm { vmovaps xmm3, xmm0; fraction }
        SND_SaveVoiceInfo(v8, memFile, g_snd.chaninfoEntchannel[v3], *(float *)&_XMM3);
      }
    }
  }
}

/*
==============
SND_SaveVoiceIndex
==============
*/
void SND_SaveVoiceIndex(MemoryFile *memFile, const SndVoice *voice)
{
  unsigned __int64 v3; 
  int p; 

  v3 = (__int64)((char *)voice - (char *)g_snd.voices + ((unsigned __int128)(((char *)voice - (char *)g_snd.voices) * (__int128)(__int64)0x8534085340853409ui64) >> 64)) >> 10;
  p = truncate_cast<int,__int64>(v3 + (v3 >> 63));
  MemFile_WriteData(memFile, 4ui64, &p);
}

/*
==============
SND_SaveVoiceInfo
==============
*/

void __fastcall SND_SaveVoiceInfo(const SndVoice *voice, MemoryFile *memFile, int entchannel, double fraction)
{
  __int64 v30; 
  vec3_t outOrigin; 
  unsigned __int64 p; 
  int adsrIndex; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  _RBX = voice;
  if ( !voice && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10251, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice", -2i64) )
    __debugbreak();
  if ( entchannel != (unsigned __int8)entchannel )
  {
    LODWORD(v30) = entchannel;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 10252, ASSERT_TYPE_ASSERT, "( ( entchannel == (entchannel & 0xFF) ) )", "( entchannel ) = %i", v30) )
      __debugbreak();
  }
  p = _RBX->sndEnt;
  MemFile_WriteData(memFile, 8ui64, &p);
  LOBYTE(adsrIndex) = truncate_cast<unsigned char,int>(entchannel);
  MemFile_WriteData(memFile, 1ui64, &adsrIndex);
  __asm { vmovss  xmm1, dword ptr [rbx+54h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+84h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+58h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+5Ch]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+60h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+2Ch]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+30h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+28h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+80h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+38h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+3Ch]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+40h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+44h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+48h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+50h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  LOBYTE(adsrIndex) = _RBX->occlusionMatchesListener;
  MemFile_WriteData(memFile, 1ui64, &adsrIndex);
  __asm { vmovss  xmm1, dword ptr [rbx+0B4h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  MemFile_WriteData(memFile, 0xCui64, &_RBX->offset);
  SndVoice_GetOrigin(_RBX, &outOrigin);
  MemFile_WriteData(memFile, 0xCui64, &outOrigin);
  LOWORD(adsrIndex) = _RBX->soundDoneSoundString;
  MemFile_WriteData(memFile, 2ui64, &adsrIndex);
  adsrIndex = _RBX->adsrIndex;
  MemFile_WriteData(memFile, 4ui64, &adsrIndex);
  MemFile_WriteData(memFile, 4ui64, &_RBX->playbackId);
  MemFile_WriteData(memFile, 4ui64, &_RBX->secondaryId);
  __asm { vmovss  xmm1, dword ptr [rbx+0FCh]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  MemFile_WriteData(memFile, 0xCui64, &_RBX->submixAttenuation);
  MemFile_WriteData(memFile, 0xCui64, &_RBX->submixLpf);
  MemFile_WriteData(memFile, 0xCui64, &_RBX->submixHpf);
  __asm { vmovss  xmm1, dword ptr [rbx+100h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  __asm { vmovss  xmm1, dword ptr [rbx+104h]; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  SND_SubmixVoiceSave(memFile, _RBX);
  __asm { vmovaps xmm1, xmm6; value }
  MemFile_WriteFloat(memFile, *(float *)&_XMM1);
  memset(&outOrigin, 0, sizeof(outOrigin));
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
}

/*
==============
SND_SaveVoiceSync
==============
*/
void SND_SaveVoiceSync(int voiceIndex, MemoryFile *memFile)
{
  sd_voice **voices; 
  sd_voice *syncMaster; 
  unsigned int v8; 
  float *p_p; 
  unsigned __int64 v10; 
  int p; 
  float v12; 

  voices = g_sd.voices;
  _RDI = g_sd.voices[voiceIndex];
  if ( _RDI && _RDI->isSync )
  {
    LOBYTE(p) = 1;
    MemFile_WriteData(memFile, 1ui64, &p);
    __asm { vmovss  xmm1, dword ptr [rdi+37Ch]; value }
    MemFile_WriteFloat(memFile, *(float *)&_XMM1);
    p = _RDI->syncMeter;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStart;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStartFrameOffset;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStartDelayBeats;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStartFadeBeats;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStop;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStopBeats;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStopDelayBeats;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStopFadeBeats;
    MemFile_WriteData(memFile, 4ui64, &p);
    MemFile_WriteData(memFile, 4ui64, &_RDI->syncState);
    p = _RDI->syncTimestamp;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStartDelayFrames;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStartFadeFrames;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStopDelayFrames;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStopFadeFrames;
    MemFile_WriteData(memFile, 4ui64, &p);
    LOBYTE(p) = _RDI->syncSoftStart;
    MemFile_WriteData(memFile, 1ui64, &p);
    __asm { vmovss  xmm1, dword ptr [rdi+3C0h]; value }
    MemFile_WriteFloat(memFile, *(float *)&_XMM1);
    p = _RDI->syncStartDelayFramesDecoded;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStartFadeFramesDecoded;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStopDelayFramesDecoded;
    MemFile_WriteData(memFile, 4ui64, &p);
    p = _RDI->syncStopFadeFramesDecoded;
    MemFile_WriteData(memFile, 4ui64, &p);
    syncMaster = _RDI->syncMaster;
    v8 = 0;
    v12 = 0.0;
    while ( syncMaster != *voices )
    {
      ++v8;
      ++voices;
      if ( v8 >= 0x63 )
      {
        p_p = &v12;
        v10 = 4i64;
        goto LABEL_9;
      }
    }
    p_p = &v12;
    v10 = 4i64;
    v12 = g_snd.chaninfoUnweightedPriority[492 * v8 - 48701];
  }
  else
  {
    LOBYTE(p) = 0;
    p_p = (float *)&p;
    v10 = 1i64;
  }
LABEL_9:
  MemFile_WriteData(memFile, v10, p_p);
}

/*
==============
SND_ScalePitchOnEnt
==============
*/

void __fastcall SND_ScalePitchOnEnt(unsigned __int64 sndEnt, double pitch, int msec)
{
  float pitcha; 

  __asm { vmovss  [rsp+pitch], xmm1 }
  SND_SetEntityParamInfoData(sndEnt, &pitcha, NULL, msec);
}

/*
==============
SND_ScaleVoicePitchById
==============
*/

bool __fastcall SND_ScaleVoicePitchById(unsigned int id, double pitch, int msec)
{
  SndVoice *PlaybackVoice; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  PlaybackVoice = SND_GetPlaybackVoice(id);
  if ( PlaybackVoice )
  {
    __asm
    {
      vmovss  xmm3, cs:__real@40000000; max
      vmovss  xmm2, cs:__real@3a83126f; min
      vmovaps xmm1, xmm6; value
    }
    SND_SetParamValue(&PlaybackVoice->pitchInfo, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, msec);
    LOBYTE(PlaybackVoice) = 1;
    __asm { vmovaps xmm6, [rsp+48h+var_18] }
  }
  else
  {
    __asm { vmovaps xmm6, [rsp+48h+var_18] }
  }
  return (char)PlaybackVoice;
}

/*
==============
SND_ScaleVoiceVolumeById
==============
*/

bool __fastcall SND_ScaleVoiceVolumeById(unsigned int id, double volume, int msec)
{
  SndVoice *PlaybackVoice; 
  SndVoice *v7; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  PlaybackVoice = SND_GetPlaybackVoice(id);
  v7 = PlaybackVoice;
  if ( PlaybackVoice )
  {
    __asm
    {
      vmovss  xmm2, cs:__real@40800000; max
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm0, xmm6; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovss  xmm3, cs:__real@3f800000; max
      vxorps  xmm2, xmm2, xmm2; min
      vmovaps xmm1, xmm0; value
    }
    SND_SetParamValue(&v7->volumeInfo, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, msec);
    LOBYTE(PlaybackVoice) = 1;
    __asm { vmovaps xmm6, [rsp+48h+var_18] }
  }
  else
  {
    __asm { vmovaps xmm6, [rsp+48h+var_18] }
  }
  return (char)PlaybackVoice;
}

/*
==============
SND_ScaleVolumeOnEnt
==============
*/

void __fastcall SND_ScaleVolumeOnEnt(unsigned __int64 sndEnt, double volume, int msec)
{
  float volumea; 

  __asm { vmovss  [rsp+volume], xmm1 }
  SND_SetEntityParamInfoData(sndEnt, NULL, &volumea, msec);
}

/*
==============
SND_SetAliasValue_f
==============
*/
void SND_SetAliasValue_f()
{
  const char *v0; 
  const SndAliasList *Alias; 
  const char *v2; 
  const char *v3; 

  if ( Cmd_Argc() == 4 )
  {
    v0 = Cmd_Argv(1);
    Alias = SND_FindAlias(v0);
    if ( Alias )
    {
      v2 = Cmd_Argv(2);
      v3 = Cmd_Argv(3);
      SND_ChangeSoundAliasListValue(Alias, v2, v3);
    }
    else
    {
      Com_Printf(9, "snd_setAliasValue: unknown alias '%s'\n", v0);
    }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_setAliasValue <aliasListName> <columnName> <value>\n");
  }
}

/*
==============
SND_SetAmbientEvents
==============
*/

void __fastcall SND_SetAmbientEvents(const LocalClientNum_t localClientNum, const SoundTable *soundTable, const AmbientDef *ambientDef, double strength)
{
  unsigned __int64 SndEntHandle; 
  float volume; 

  _RBP = g_ambGlob;
  __asm
  {
    vmovaps [rsp+38h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  _RBX = localClientNum;
  if ( g_ambGlob[localClientNum].ambientDef != ambientDef )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  [rsp+38h+volume], xmm0
    }
    SndEntHandle = CG_GenerateSndEntHandle(localClientNum, localClientNum + 4353);
    SND_SetEntityParamInfoData(SndEntHandle, NULL, &volume, 1000);
    g_ambGlob[_RBX].nextPlayTime += 1000;
    g_ambGlob[_RBX].ambientDef = ambientDef;
    g_ambGlob[_RBX].lastPlayedElem = NULL;
    g_ambGlob[_RBX].playTime = 0;
    g_ambGlob[_RBX].soundTable = soundTable;
  }
  __asm
  {
    vmovss  dword ptr [rbp+rbx*8+28h], xmm6
    vmovaps xmm6, [rsp+38h+var_18]
  }
}

/*
==============
SND_SetBackgroundTrackVolumeScale
==============
*/

void __fastcall SND_SetBackgroundTrackVolumeScale(int track, double volumeScale, int fadeTime)
{
  __int64 v8; 
  __int64 v11; 
  __int64 v13; 
  unsigned int v14; 
  bool *v15; 
  __int64 v23; 
  char v27; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  v8 = track;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmm6, xmm1
  }
  if ( (track & 0xFFFFFFFD) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6263, ASSERT_TYPE_ASSERT, "( ( track == SND_TRACK_AMBIENT_PRIMARY_0 || track == SND_TRACK_AMBIENT_PRIMARY_1 ) )", "( track ) = %i", track) )
    __debugbreak();
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm6, xmm7
  }
  if ( fadeTime < 0 )
  {
    LODWORD(v23) = fadeTime;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6265, ASSERT_TYPE_ASSERT, "( ( fadeTime >= 0 ) )", "( fadeTime ) = %i", v23) )
      __debugbreak();
  }
  if ( !(_DWORD)v8 || (v11 = 1i64, (_DWORD)v8 == 2) )
    v11 = 2i64;
  __asm { vmovss  xmm8, cs:__real@3f800000 }
  v13 = 0i64;
  v14 = v8 + 80;
  v15 = &sdGlob.voiceAlloc[v8 + 80];
  do
  {
    if ( v14 > 0x62 )
    {
      LODWORD(v23) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v23) )
        __debugbreak();
    }
    if ( v15[v13] )
    {
      __asm
      {
        vmovaps xmm3, xmm8; max
        vmovaps xmm2, xmm7; min
        vmovaps xmm1, xmm6; value
      }
      SND_SetParamValue((snd_param_info_t *)&g_snd.chaninfoUnweightedPriority[492 * v14 - 48694], *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fadeTime);
    }
    ++v14;
    ++v13;
  }
  while ( v13 < v11 );
  __asm { vmovaps xmm6, [rsp+78h+var_28] }
  _R11 = &v27;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm7, [rsp+78h+var_38]
  }
}

/*
==============
SND_SetChannelVolume
==============
*/

void __fastcall SND_SetChannelVolume(unsigned int channel, double channelvolume, int fademsec)
{
  __int64 v8; 
  bool v9; 
  bool v10; 
  bool v11; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  v8 = channel;
  if ( CL_GetLocalClientActiveCount() <= 1 )
  {
    __asm { vmovaps [rsp+58h+var_28], xmm8 }
    if ( !g_snd.globals || (v9 = (unsigned int)v8 < g_snd.globals->entchannelCount, v10 = (unsigned int)v8 <= g_snd.globals->entchannelCount, (unsigned int)v8 >= g_snd.globals->entchannelCount) )
    {
      v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6771, ASSERT_TYPE_ASSERT, "(channel >= 0 && channel < SND_GetEntChannelCount())", (const char *)&queryFormat, "channel >= 0 && channel < SND_GetEntChannelCount()");
      v9 = 0;
      v10 = !v11;
      if ( v11 )
        __debugbreak();
    }
    __asm
    {
      vxorps  xmm8, xmm8, xmm8
      vcomiss xmm6, xmm8
    }
    if ( v9 )
      goto LABEL_14;
    __asm { vcomiss xmm6, cs:__real@3f800000 }
    if ( !v10 )
    {
LABEL_14:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6772, ASSERT_TYPE_ASSERT, "(channelvolume >= 0.0f && channelvolume <= 1.0f)", (const char *)&queryFormat, "channelvolume >= 0.0f && channelvolume <= 1.0f") )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm3, cs:__real@3f800000; max
      vxorps  xmm2, xmm2, xmm2; min
      vmovaps xmm1, xmm6; value
    }
    SND_SetParamValue(&g_snd.levelFadeInChannelVols.channelvol[v8], *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fademsec);
    __asm { vmovaps xmm8, [rsp+58h+var_28] }
  }
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
SND_SetChannelVolumes
==============
*/
void SND_SetChannelVolumes(int priority, const float *channelvolume, int fademsec)
{
  __int64 v6; 
  int v9; 
  snd_channelvolgroup *v10; 
  bool *p_active; 

  v6 = priority;
  _R14 = channelvolume;
  if ( CL_GetLocalClientActiveCount() <= 1 )
  {
    __asm { vmovaps [rsp+48h+var_18], xmm6 }
    if ( (unsigned int)(v6 - 1) > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6786, ASSERT_TYPE_ASSERT, "( ( priority > SND_CHANNELVOLPRIO_NONE && priority < SND_CHANNELVOLPRIO_COUNT ) )", "( priority ) = %i", v6) )
      __debugbreak();
    if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6787, ASSERT_TYPE_ASSERT, "(channelvolume)", (const char *)&queryFormat, "channelvolume") )
      __debugbreak();
    if ( fademsec < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6788, ASSERT_TYPE_ASSERT, "(fademsec >= 0)", (const char *)&queryFormat, "fademsec >= 0") )
      __debugbreak();
    __asm { vmovss  xmm6, cs:__real@3f800000 }
    v9 = 1;
    v10 = &g_snd.channelPriorityVolGroups[v6];
    if ( fademsec >= 1 )
      v9 = fademsec;
    _RBX = 0i64;
    v10->active = 1;
    while ( g_snd.globals && (unsigned int)_RBX < g_snd.globals->entchannelCount )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [r14+rbx*4]; value
        vmovaps xmm3, xmm6; max
        vxorps  xmm2, xmm2, xmm2; min
      }
      SND_SetParamValue(&v10->channelvol[_RBX], *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, v9);
      _RBX = (unsigned int)(_RBX + 1);
    }
    __asm { vmovaps xmm6, [rsp+48h+var_18] }
    if ( (_DWORD)v6 != g_snd.currentChannelPriority )
    {
      if ( v6 + 1 >= 4 )
      {
LABEL_22:
        g_snd.currentChannelPriority = v6;
      }
      else
      {
        p_active = &g_snd.channelPriorityVolGroups[v6 + 1].active;
        while ( !*p_active )
        {
          p_active += 6148;
          if ( (__int64)p_active >= (__int64)&g_snd.entChanOcclusionParams[50][1].attnLevel4 )
            goto LABEL_22;
        }
      }
    }
  }
}

/*
==============
SND_SetConstrainedMode
==============
*/
void SND_SetConstrainedMode(void)
{
  Sys_UpdateSoundThreadAffinities(1);
}

/*
==============
SND_SetContext
==============
*/

void __fastcall SND_SetContext(unsigned int type, unsigned int value, double fadeTime)
{
  int ContextIndex; 

  __asm
  {
    vmovaps [rsp+38h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  ContextIndex = SND_FindContextIndex(type);
  if ( ContextIndex >= 0 )
  {
    _RCX = ContextIndex;
    _RDX = &g_snd;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vucomiss xmm6, xmm0
    }
    g_snd.globalContextsFrom[ContextIndex] = g_snd.globalContextsTo[ContextIndex];
    g_snd.globalContextsTo[ContextIndex] = value;
    if ( ContextIndex )
    {
      __asm
      {
        vmovss  xmm0, cs:__real@3a83126f
        vdivss  xmm1, xmm0, xmm6
        vmovss  dword ptr [rdx+rcx*8+145288h], xmm1
      }
      g_snd.globalContextLerp[ContextIndex].current = 0.0;
      __asm { vmovaps xmm6, [rsp+38h+var_18] }
      return;
    }
    g_snd.globalContextLerp[0] = (TimeLerp)1065353216i64;
  }
  __asm { vmovaps xmm6, [rsp+38h+var_18] }
}

/*
==============
SND_SetEntContext
==============
*/

void __fastcall SND_SetEntContext(unsigned __int64 handle, unsigned int type, unsigned int value, double fadeTime)
{
  SndEntState *EntState; 
  int v9; 
  unsigned int v10; 
  SndEntState *v11; 
  int v12; 

  if ( type )
  {
    __asm
    {
      vmovaps [rsp+38h+var_18], xmm6
      vmovaps xmm6, xmm3
    }
    EntState = SND_FindEntState(handle, 1);
    if ( EntState )
    {
      v9 = -1;
      v10 = 0;
      v11 = EntState;
      while ( v11->contextTypes[0] != type )
      {
        v12 = v10;
        if ( v11->contextTypes[0] )
          v12 = v9;
        ++v10;
        v11 = (SndEntState *)((char *)v11 + 4);
        v9 = v12;
        if ( v10 >= 3 )
          goto LABEL_10;
      }
      v9 = v10;
LABEL_10:
      if ( v9 != -1 )
      {
        __asm
        {
          vmulss  xmm0, xmm6, cs:__real@447a0000
          vcvttss2si ecx, xmm0
        }
        EntState->contextValuesFrom[v9] = EntState->contextValuesTo[v9];
        EntState->contextValuesTo[v9] = value;
        EntState->contextFadeLength[v9] = _ECX;
        EntState->contextFadeTime[v9] = g_snd.time + _ECX;
        EntState->contextTypes[v9] = type;
        __asm { vmovaps xmm6, [rsp+38h+var_18] }
        return;
      }
      Com_PrintError(9, "Failed to find free entity sound context slot for type 0x%x, value 0x%x\n", type, value);
    }
    __asm { vmovaps xmm6, [rsp+38h+var_18] }
  }
}

/*
==============
SND_SetEntState
==============
*/
void SND_SetEntState(unsigned __int64 handle, const vec3_t *origin, const tmat33_t<vec3_t> *orientation)
{
  const vec3_t *v5; 
  SndEntState *EntState; 
  SndEntState *v19; 
  int v20; 
  int v21; 
  int v22; 
  int v23; 
  int v24; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 

  __asm
  {
    vmovss  xmm0, dword ptr [rdx]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  _RDI = orientation;
  v5 = origin;
  if ( (v20 & 0x7F800000) == 2139095040 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+4]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v21 & 0x7F800000) == 2139095040 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+8]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v22 & 0x7F800000) == 2139095040 )
  {
LABEL_28:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14019, ASSERT_TYPE_SANITY, "( !IS_NAN( ( origin )[0] ) && !IS_NAN( ( origin )[1] ) && !IS_NAN( ( origin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( origin )[0] ) && !IS_NAN( ( origin )[1] ) && !IS_NAN( ( origin )[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v23 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v24 & 0x7F800000) == 2139095040 )
    goto LABEL_29;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v25 & 0x7F800000) == 2139095040 )
  {
LABEL_29:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14020, ASSERT_TYPE_SANITY, "( !IS_NAN( ( orientation[0] )[0] ) && !IS_NAN( ( orientation[0] )[1] ) && !IS_NAN( ( orientation[0] )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( orientation[0] )[0] ) && !IS_NAN( ( orientation[0] )[1] ) && !IS_NAN( ( orientation[0] )[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+0Ch]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v26 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+10h]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v27 & 0x7F800000) == 2139095040 )
    goto LABEL_30;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+14h]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v28 & 0x7F800000) == 2139095040 )
  {
LABEL_30:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14021, ASSERT_TYPE_SANITY, "( !IS_NAN( ( orientation[1] )[0] ) && !IS_NAN( ( orientation[1] )[1] ) && !IS_NAN( ( orientation[1] )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( orientation[1] )[0] ) && !IS_NAN( ( orientation[1] )[1] ) && !IS_NAN( ( orientation[1] )[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+18h]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v29 & 0x7F800000) == 2139095040 )
    goto LABEL_31;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+1Ch]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v30 & 0x7F800000) == 2139095040 )
    goto LABEL_31;
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+20h]
    vmovss  [rsp+38h+arg_8], xmm0
  }
  if ( (v31 & 0x7F800000) == 2139095040 )
  {
LABEL_31:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14022, ASSERT_TYPE_SANITY, "( !IS_NAN( ( orientation[2] )[0] ) && !IS_NAN( ( orientation[2] )[1] ) && !IS_NAN( ( orientation[2] )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( orientation[2] )[0] ) && !IS_NAN( ( orientation[2] )[1] ) && !IS_NAN( ( orientation[2] )[2] )") )
      __debugbreak();
  }
  EntState = SND_FindEntState(handle, 1);
  v19 = EntState;
  if ( EntState && EntState->lastUsed != g_snd.frame )
  {
    if ( EntState->handle != handle )
      memset_0(EntState, 0, sizeof(SndEntState));
    SndEntState_SetOrigin(v19, v5);
    AxisCopy(_RDI, &v19->orientation);
    v19->hasPosition = 1;
    v19->lastUsed = g_snd.frame;
  }
}

/*
==============
SND_SetEntityParamInfoData
==============
*/
void SND_SetEntityParamInfoData(unsigned __int64 sndEnt, const float *pitch, const float *volume, int msec)
{
  unsigned __int64 v5; 
  unsigned __int64 v10; 
  EntityParamInfo *EntityParamInfo; 

  v5 = sndEnt & 0x1FFFFFFFFi64;
  _R14 = volume;
  _RBP = pitch;
  if ( (sndEnt & 0x1FFFFFFFFi64) - 5411 <= 0x1F || v5 - 2049 <= 0x8FF || v5 <= 0x7FD || v5 - 5571 <= 0x7A120 )
  {
    v10 = (unsigned __int64)&g_sndEntityParamFence & 3;
    do
    {
      if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&g_sndEntityParamFence) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(&g_sndEntityParamFence, 1, 0) == 1 );
    EntityParamInfo = SND_GetEntityParamInfo(sndEnt);
    if ( EntityParamInfo || (EntityParamInfo = SND_GetNewEntityParamInfo(sndEnt)) != NULL )
    {
      if ( _RBP )
      {
        __asm
        {
          vmovss  xmm3, cs:__real@40000000; max
          vmovss  xmm2, cs:__real@3a83126f; min
          vmovss  xmm1, dword ptr [rbp+0]; value
        }
        SND_SetParamValue(&EntityParamInfo->pitch, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, msec);
      }
      if ( _R14 )
      {
        __asm
        {
          vmovss  xmm3, cs:__real@40800000; max
          vmovss  xmm1, dword ptr [r14]; value
          vxorps  xmm2, xmm2, xmm2; min
        }
        SND_SetParamValue(&EntityParamInfo->volume, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, msec);
      }
    }
    if ( v10 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&g_sndEntityParamFence) )
        __debugbreak();
    }
    _InterlockedExchange(&g_sndEntityParamFence, 0);
  }
}

/*
==============
SND_SetEq
==============
*/
void SND_SetEq(const char *channelName, int eqIndex, int band, SND_EQTYPE type, float gain, float freq, float q)
{
  int EntChannelFromName; 
  float v15; 
  float v16; 
  float v17; 

  EntChannelFromName = SND_GetEntChannelFromName(channelName);
  if ( EntChannelFromName == -1 )
  {
    Com_PrintError(9, "Unknown channel name (%s), please check channel definitions file\n", channelName);
  }
  else
  {
    __asm
    {
      vmovss  xmm0, [rsp+48h+q]
      vmovss  xmm1, [rsp+48h+freq]
      vmovss  [rsp+48h+var_18], xmm0
      vmovss  xmm0, [rsp+48h+gain]
      vmovss  [rsp+48h+var_20], xmm1
      vmovss  [rsp+48h+var_28], xmm0
    }
    SND_SetEqParams(EntChannelFromName, eqIndex, band, type, v15, v16, v17);
  }
}

/*
==============
SND_SetEqEntChannel
==============
*/
void SND_SetEqEntChannel(int entChannel, int eqIndex, int band, SND_EQTYPE type, float gain, float freq, float q)
{
  if ( entChannel != -1 )
    SND_SetEqParams(entChannel, eqIndex, band, type, gain, freq, q);
}

/*
==============
SND_SetEqFreq
==============
*/

void __fastcall SND_SetEqFreq(int entchannel, int eqIndex, int band, double freq)
{
  __int64 v6; 
  __int64 v7; 
  __int64 v8; 
  bool v10; 
  bool v11; 
  bool v12; 
  __int64 v18; 
  double v20; 
  __int64 v21; 
  int v22; 

  v6 = entchannel;
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  v7 = band;
  v8 = eqIndex;
  __asm { vmovaps xmm6, xmm3 }
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v22 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 891, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v22) )
      __debugbreak();
  }
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(v21) = 2;
    LODWORD(v18) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 892, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v18, v21) )
      __debugbreak();
  }
  v10 = (unsigned int)v8 < 2;
  v11 = (unsigned int)v8 <= 2;
  if ( (unsigned int)v8 >= 2 )
  {
    LODWORD(v21) = 2;
    LODWORD(v18) = v8;
    v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 893, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v18, v21);
    v10 = 0;
    v11 = !v12;
    if ( v12 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v10 )
    goto LABEL_12;
  __asm { vcomiss xmm6, cs:__real@46bb8000 }
  if ( !v11 )
  {
LABEL_12:
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+58h+var_30], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 894, ASSERT_TYPE_ASSERT, "( ( freq >= 0 && freq <= ( 24000.0f ) ) )", "( freq ) = %g", v20) )
      __debugbreak();
  }
  _RCX = &sdGlob;
  _RAX = v6 + ((v7 + 2 * v8) << 8);
  __asm
  {
    vmovss  dword ptr [rcx+rax*4+8], xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
  sdGlob.eqParams[0][0][_RAX].enabled = 1;
}

/*
==============
SND_SetEqFreq_f
==============
*/

void __fastcall SND_SetEqFreq_f(double _XMM0_8)
{
  const char *v3; 
  signed int EntChannelFromName; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  unsigned int v8; 
  __int64 v9; 
  char v10; 
  char v11; 
  bool v14; 
  bool v15; 
  bool v16; 
  __int64 v26; 
  double v27; 
  __int64 v28; 

  if ( Cmd_Argc() == 5 )
  {
    v3 = Cmd_Argv(1);
    EntChannelFromName = SND_GetEntChannelFromName(v3);
    v5 = EntChannelFromName;
    if ( EntChannelFromName == -1 )
    {
      Com_Printf(9, "Unknown channel name (%s), please check channel definitions file\n", v3);
    }
    else
    {
      v6 = Cmd_ArgInt(2);
      v7 = (int)v6;
      if ( v6 > 1 )
      {
        Com_Printf(9, "invalid 'eqIndex' %i, must be >= 0 and < %i\n", v6, 2i64);
      }
      else
      {
        v8 = Cmd_ArgInt(3);
        v9 = (int)v8;
        if ( v8 <= 1 )
        {
          __asm
          {
            vmovaps [rsp+68h+var_18], xmm6
            vmovaps [rsp+68h+var_28], xmm8
          }
          _XMM0_8 = Cmd_ArgFloat(4);
          __asm
          {
            vxorps  xmm8, xmm8, xmm8
            vcomiss xmm0, xmm8
            vmovaps xmm6, xmm0
          }
          if ( v10 )
            goto LABEL_25;
          __asm { vcomiss xmm0, cs:__real@46bb8000 }
          if ( !(v10 | v11) )
          {
LABEL_25:
            __asm
            {
              vmovsd  xmm3, cs:__real@40d7700000000000
              vcvtss2sd xmm2, xmm6, xmm6
              vmovq   r9, xmm3
              vmovq   r8, xmm2
            }
            Com_Printf(9, "invalid 'freq' %f, must be >= 0 and < %f\n", *(double *)&_XMM2, *(double *)&_XMM3);
          }
          else
          {
            if ( (unsigned int)v5 >= 0x100 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 891, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v5, 256) )
              __debugbreak();
            if ( (unsigned int)v9 >= 2 )
            {
              LODWORD(v28) = 2;
              LODWORD(v26) = v9;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 892, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v26, v28) )
                __debugbreak();
            }
            v14 = (unsigned int)v7 < 2;
            v15 = (unsigned int)v7 <= 2;
            if ( (unsigned int)v7 >= 2 )
            {
              LODWORD(v28) = 2;
              LODWORD(v26) = v7;
              v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 893, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v26, v28);
              v14 = 0;
              v15 = !v16;
              if ( v16 )
                __debugbreak();
            }
            __asm { vcomiss xmm6, xmm8 }
            if ( v14 )
              goto LABEL_21;
            __asm { vcomiss xmm6, cs:__real@46bb8000 }
            if ( !v15 )
            {
LABEL_21:
              __asm
              {
                vcvtss2sd xmm0, xmm6, xmm6
                vmovsd  [rsp+68h+var_40], xmm0
              }
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 894, ASSERT_TYPE_ASSERT, "( ( freq >= 0 && freq <= ( 24000.0f ) ) )", "( freq ) = %g", v27) )
                __debugbreak();
            }
            _RCX = &sdGlob;
            _RAX = v5 + ((v9 + 2 * v7) << 8);
            __asm { vmovss  dword ptr [rcx+rax*4+8], xmm6 }
            sdGlob.eqParams[0][0][_RAX].enabled = 1;
          }
          __asm
          {
            vmovaps xmm6, [rsp+68h+var_18]
            vmovaps xmm8, [rsp+68h+var_28]
          }
        }
        else
        {
          Com_Printf(9, "invalid 'band' %i, must be >= 0 and < %i\n", v8, 2i64);
        }
      }
    }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_setEqFreq <const char *channelName> <int eqIndex> <int band> <float freq>\n");
  }
}

/*
==============
SND_SetEqGain
==============
*/

void __fastcall SND_SetEqGain(int entchannel, int eqIndex, int band, double gain)
{
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 
  __int64 v12; 
  __int64 v14; 
  int v15; 

  v5 = entchannel;
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  v6 = band;
  v7 = eqIndex;
  __asm { vmovaps xmm6, xmm3 }
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v15 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 903, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v15) )
      __debugbreak();
  }
  if ( (unsigned int)v6 >= 2 )
  {
    LODWORD(v14) = 2;
    LODWORD(v12) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 904, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v12, v14) )
      __debugbreak();
  }
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(v14) = 2;
    LODWORD(v12) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 905, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v12, v14) )
      __debugbreak();
  }
  _RCX = &sdGlob;
  _RAX = v5 + ((v6 + 2 * v7) << 8);
  __asm
  {
    vmovss  dword ptr [rcx+rax*4+4], xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
  sdGlob.eqParams[0][0][_RAX].enabled = 1;
}

/*
==============
SND_SetEqGain_f
==============
*/

void __fastcall SND_SetEqGain_f(double _XMM0_8)
{
  const char *v2; 
  signed int EntChannelFromName; 
  __int64 v4; 
  unsigned int v5; 
  __int64 v6; 
  unsigned int v7; 
  __int64 v8; 
  __int64 v13; 
  __int64 v14; 

  if ( Cmd_Argc() == 5 )
  {
    v2 = Cmd_Argv(1);
    EntChannelFromName = SND_GetEntChannelFromName(v2);
    v4 = EntChannelFromName;
    if ( EntChannelFromName == -1 )
    {
      Com_Printf(9, "Unknown channel name (%s), please check channel definitions file\n", v2);
    }
    else
    {
      v5 = Cmd_ArgInt(2);
      v6 = (int)v5;
      if ( v5 > 1 )
      {
        Com_Printf(9, "invalid 'eqIndex' %i, must be >= 0 and < %i\n", v5, 2i64);
      }
      else
      {
        v7 = Cmd_ArgInt(3);
        v8 = (int)v7;
        if ( v7 <= 1 )
        {
          __asm { vmovaps [rsp+58h+var_18], xmm6 }
          _XMM0_8 = Cmd_ArgFloat(4);
          __asm { vmovaps xmm6, xmm0 }
          if ( (unsigned int)v4 >= 0x100 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 903, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v4, 256) )
            __debugbreak();
          if ( (unsigned int)v8 >= 2 )
          {
            LODWORD(v14) = 2;
            LODWORD(v13) = v8;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 904, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v13, v14) )
              __debugbreak();
          }
          if ( (unsigned int)v6 >= 2 )
          {
            LODWORD(v14) = 2;
            LODWORD(v13) = v6;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 905, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v13, v14) )
              __debugbreak();
          }
          _RCX = &sdGlob;
          _RAX = v4 + ((v8 + 2 * v6) << 8);
          __asm
          {
            vmovss  dword ptr [rcx+rax*4+4], xmm6
            vmovaps xmm6, [rsp+58h+var_18]
          }
          sdGlob.eqParams[0][0][_RAX].enabled = 1;
        }
        else
        {
          Com_Printf(9, "invalid 'band' %i, must be >= 0 and < %i\n", v7, 2i64);
        }
      }
    }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_setEqGain <const char *channelName> <int eqIndex> <int band> <float gain>\n");
  }
}

/*
==============
SND_SetEqLerp
==============
*/

void __fastcall SND_SetEqLerp(double lerp, double _XMM1_8)
{
  double v7; 

  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps xmm6, xmm0
    vcomiss xmm0, cs:__real@3f800000
    vcvtss2sd xmm0, xmm6, xmm6
    vmovsd  [rsp+48h+var_20], xmm0
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 857, ASSERT_TYPE_ASSERT, "( ( lerp >= 0.0 && lerp <= 1.0f ) )", "( lerp ) = %g", v7) )
    __debugbreak();
  __asm
  {
    vmovss  cs:?sdGlob@@3USDLocal@@A.eqLerp, xmm6; SDLocal sdGlob
    vmovaps xmm6, [rsp+48h+var_18]
  }
}

/*
==============
SND_SetEqParams
==============
*/
void SND_SetEqParams(int entchannel, int eqIndex, int band, SND_EQTYPE type, float gain, float freq, float q)
{
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  bool v15; 
  bool v16; 
  bool v17; 
  bool v21; 
  __int64 v31; 
  double v33; 
  double v34; 
  __int64 v35; 
  int v36; 
  char v39; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  v12 = entchannel;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
  }
  v13 = band;
  v14 = eqIndex;
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v36 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 864, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v36) )
      __debugbreak();
  }
  if ( (unsigned int)v13 >= 2 )
  {
    LODWORD(v35) = 2;
    LODWORD(v31) = v13;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 865, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v31, v35) )
      __debugbreak();
  }
  v15 = (unsigned int)v14 < 2;
  v16 = (unsigned int)v14 <= 2;
  if ( (unsigned int)v14 >= 2 )
  {
    LODWORD(v35) = 2;
    LODWORD(v31) = v14;
    v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 866, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v31, v35);
    v15 = 0;
    v16 = !v17;
    if ( v17 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm6, [rsp+78h+freq]
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm6, xmm7
  }
  if ( v15 )
    goto LABEL_20;
  __asm { vcomiss xmm6, cs:__real@46bb8000 }
  if ( !v16 )
  {
LABEL_20:
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+78h+var_50], xmm0
    }
    v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 867, ASSERT_TYPE_ASSERT, "( ( freq >= 0 && freq <= ( 24000.0f ) ) )", "( freq ) = %g", v33);
    v16 = !v21;
    if ( v21 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm8, [rsp+78h+q]
    vcomiss xmm8, xmm7
  }
  if ( v16 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm8, xmm8
      vmovsd  [rsp+78h+var_50], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 868, ASSERT_TYPE_ASSERT, "( ( q > 0 ) )", "( q ) = %g", v34) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, [rsp+78h+gain]
    vmovaps xmm7, [rsp+78h+var_28]
  }
  _RCX = &sdGlob;
  _R11 = &v39;
  _RAX = v12 + ((v13 + 2 * v14) << 8);
  __asm
  {
    vmovss  dword ptr [rcx+rax*4+8], xmm6
    vmovaps xmm6, [rsp+78h+var_18]
    vmovss  dword ptr [rcx+rax*4+0Ch], xmm8
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  sdGlob.eqParams[0][0][_RAX].type = type;
  __asm { vmovss  dword ptr [rcx+rax*4+4], xmm0 }
  sdGlob.eqParams[0][0][_RAX].enabled = 1;
}

/*
==============
SND_SetEqQ
==============
*/

void __fastcall SND_SetEqQ(int entchannel, int eqIndex, int band, double q)
{
  __int64 v6; 
  __int64 v7; 
  __int64 v8; 
  bool v10; 
  bool v11; 
  __int64 v17; 
  double v19; 
  __int64 v20; 
  int v21; 

  v6 = entchannel;
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  v7 = band;
  v8 = eqIndex;
  __asm { vmovaps xmm6, xmm3 }
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v21 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 914, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v21) )
      __debugbreak();
  }
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(v20) = 2;
    LODWORD(v17) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 915, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v17, v20) )
      __debugbreak();
  }
  v10 = (unsigned int)v8 <= 2;
  if ( (unsigned int)v8 >= 2 )
  {
    LODWORD(v20) = 2;
    LODWORD(v17) = v8;
    v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 916, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v17, v20);
    v10 = !v11;
    if ( v11 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v10 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+58h+var_30], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 917, ASSERT_TYPE_ASSERT, "( ( q > 0 ) )", "( q ) = %g", v19) )
      __debugbreak();
  }
  _RCX = &sdGlob;
  _RAX = v6 + ((v7 + 2 * v8) << 8);
  __asm
  {
    vmovss  dword ptr [rcx+rax*4+0Ch], xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
  sdGlob.eqParams[0][0][_RAX].enabled = 1;
}

/*
==============
SND_SetEqQ_f
==============
*/

void __fastcall SND_SetEqQ_f(double _XMM0_8)
{
  const char *v3; 
  signed int EntChannelFromName; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  unsigned int v8; 
  __int64 v9; 
  char v12; 
  char v13; 
  bool v18; 
  bool v19; 
  __int64 v23; 
  double v24; 
  __int64 v25; 

  if ( Cmd_Argc() == 5 )
  {
    v3 = Cmd_Argv(1);
    EntChannelFromName = SND_GetEntChannelFromName(v3);
    v5 = EntChannelFromName;
    if ( EntChannelFromName == -1 )
    {
      Com_Printf(9, "Unknown channel name (%s), please check channel definitions file\n", v3);
    }
    else
    {
      v6 = Cmd_ArgInt(2);
      v7 = (int)v6;
      if ( v6 > 1 )
      {
        Com_Printf(9, "invalid 'eqIndex' %i, must be >= 0 and < %i\n", v6, 2i64);
      }
      else
      {
        v8 = Cmd_ArgInt(3);
        v9 = (int)v8;
        if ( v8 <= 1 )
        {
          __asm
          {
            vmovaps [rsp+68h+var_18], xmm6
            vmovaps [rsp+68h+var_28], xmm7
          }
          _XMM0_8 = Cmd_ArgFloat(4);
          __asm
          {
            vxorps  xmm7, xmm7, xmm7
            vcomiss xmm0, xmm7
            vmovaps xmm6, xmm0
          }
          if ( v12 | v13 )
          {
            __asm
            {
              vcvtss2sd xmm2, xmm6, xmm0
              vmovq   r8, xmm2
            }
            Com_Printf(9, "invalid 'q' %f, must be > 0\n", *(double *)&_XMM2);
          }
          else
          {
            if ( (unsigned int)v5 >= 0x100 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 914, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v5, 256) )
              __debugbreak();
            if ( (unsigned int)v9 >= 2 )
            {
              LODWORD(v25) = 2;
              LODWORD(v23) = v9;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 915, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v23, v25) )
                __debugbreak();
            }
            v18 = (unsigned int)v7 <= 2;
            if ( (unsigned int)v7 >= 2 )
            {
              LODWORD(v25) = 2;
              LODWORD(v23) = v7;
              v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 916, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v23, v25);
              v18 = !v19;
              if ( v19 )
                __debugbreak();
            }
            __asm { vcomiss xmm6, xmm7 }
            if ( v18 )
            {
              __asm
              {
                vcvtss2sd xmm0, xmm6, xmm6
                vmovsd  [rsp+68h+var_40], xmm0
              }
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 917, ASSERT_TYPE_ASSERT, "( ( q > 0 ) )", "( q ) = %g", v24) )
                __debugbreak();
            }
            _RCX = &sdGlob;
            _RAX = v5 + ((v9 + 2 * v7) << 8);
            __asm { vmovss  dword ptr [rcx+rax*4+0Ch], xmm6 }
            sdGlob.eqParams[0][0][_RAX].enabled = 1;
          }
          __asm
          {
            vmovaps xmm6, [rsp+68h+var_18]
            vmovaps xmm7, [rsp+68h+var_28]
          }
        }
        else
        {
          Com_Printf(9, "invalid 'band' %i, must be >= 0 and < %i\n", v8, 2i64);
        }
      }
    }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_setEqQ <const char *channelName> <int eqIndex> <int band> <float q>\n");
  }
}

/*
==============
SND_SetEqType
==============
*/
void SND_SetEqType(int entchannel, int eqIndex, int band, SND_EQTYPE type)
{
  __int64 v4; 
  __int64 v6; 
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v11; 
  int v12; 

  v4 = entchannel;
  v6 = band;
  v7 = eqIndex;
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v12 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 880, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v12) )
      __debugbreak();
  }
  if ( (unsigned int)v6 >= 2 )
  {
    LODWORD(v11) = 2;
    LODWORD(v9) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 881, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v9, v11) )
      __debugbreak();
  }
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(v11) = 2;
    LODWORD(v9) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 882, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v9, v11) )
      __debugbreak();
  }
  v8 = v4 + ((v6 + 2 * v7) << 8);
  sdGlob.eqParams[0][0][v8].type = type;
  sdGlob.eqParams[0][0][v8].enabled = 1;
}

/*
==============
SND_SetEqType_f
==============
*/
void SND_SetEqType_f()
{
  const char *v0; 
  signed int EntChannelFromName; 
  __int64 v2; 
  unsigned int v3; 
  __int64 v4; 
  unsigned int v5; 
  __int64 v6; 
  const char *v7; 
  SND_EQTYPE v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 

  if ( Cmd_Argc() == 5 )
  {
    v0 = Cmd_Argv(1);
    EntChannelFromName = SND_GetEntChannelFromName(v0);
    v2 = EntChannelFromName;
    if ( EntChannelFromName == -1 )
    {
      Com_Printf(9, "Unknown channel name (%s), please check channel definitions file\n", v0);
    }
    else
    {
      v3 = Cmd_ArgInt(2);
      v4 = (int)v3;
      if ( v3 > 1 )
      {
        Com_Printf(9, "invalid 'eqIndex' %i, must be >= 0 and < %i\n", v3, 2i64);
      }
      else
      {
        v5 = Cmd_ArgInt(3);
        v6 = (int)v5;
        if ( v5 <= 1 )
        {
          v7 = Cmd_Argv(4);
          v8 = (unsigned int)SND_EqTypeFromString(v7);
          if ( v8 != SND_EQTYPE_COUNT )
          {
            if ( (unsigned int)v2 >= 0x100 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 880, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", v2, 256) )
              __debugbreak();
            if ( (unsigned int)v6 >= 2 )
            {
              LODWORD(v11) = 2;
              LODWORD(v10) = v6;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 881, ASSERT_TYPE_ASSERT, "(unsigned)( band ) < (unsigned)( 2 )", "band doesn't index SND_MAX_EQBANDS\n\t%i not in [0, %i)", v10, v11) )
                __debugbreak();
            }
            if ( (unsigned int)v4 >= 2 )
            {
              LODWORD(v11) = 2;
              LODWORD(v10) = v4;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 882, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( 2 )", "eqIndex doesn't index SND_EQINDEX_COUNT\n\t%i not in [0, %i)", v10, v11) )
                __debugbreak();
            }
            v9 = v2 + ((v6 + 2 * v4) << 8);
            sdGlob.eqParams[0][0][v9].enabled = 1;
            sdGlob.eqParams[0][0][v9].type = v8;
          }
        }
        else
        {
          Com_Printf(9, "invalid 'band' %i, must be >= 0 and < %i\n", v5, 2i64);
        }
      }
    }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_setEqType <const char *channelName> <int eqIndex> <int band> <const char *type>\n");
  }
}

/*
==============
SND_SetEq_f
==============
*/

void __fastcall SND_SetEq_f(double _XMM0_8)
{
  __int64 i; 
  const char *EntChannelName; 
  int v9; 
  int j; 
  const char *v19; 
  int EntChannelFromName; 
  unsigned int v21; 
  int v22; 
  unsigned int v23; 
  int v24; 
  const char *v25; 
  SND_EQTYPE v26; 
  char v28; 
  char v29; 
  const char *v32; 
  float v43; 
  double v44; 
  float v45; 
  double v46; 
  float v47; 
  double v48; 
  __int128 v49; 

  if ( Cmd_Argc() == 8 )
  {
    v19 = Cmd_Argv(1);
    EntChannelFromName = SND_GetEntChannelFromName(v19);
    if ( EntChannelFromName == -1 )
    {
      Com_Printf(9, "Unknown channel name (%s), please check channel definitions file\n", v19);
    }
    else
    {
      v21 = Cmd_ArgInt(2);
      v22 = v21;
      if ( v21 > 1 )
      {
        Com_Printf(9, "invalid 'eqIndex' %i, must be >= 0 and < %i\n", v21, 2i64);
      }
      else
      {
        v23 = Cmd_ArgInt(3);
        v24 = v23;
        if ( v23 <= 1 )
        {
          v25 = Cmd_Argv(4);
          v26 = (unsigned int)SND_EqTypeFromString(v25);
          if ( v26 != SND_EQTYPE_COUNT )
          {
            __asm
            {
              vmovaps [rsp+98h+var_18], xmm6
              vmovaps [rsp+98h+var_28], xmm7
              vmovaps [rsp+98h+var_38], xmm8
            }
            _XMM0_8 = Cmd_ArgFloat(5);
            __asm { vmovaps xmm8, xmm0 }
            _XMM0_8 = Cmd_ArgFloat(6);
            __asm
            {
              vxorps  xmm7, xmm7, xmm7
              vcomiss xmm0, xmm7
              vmovaps xmm6, xmm0
            }
            if ( v28 )
              goto LABEL_25;
            __asm { vcomiss xmm0, cs:__real@46bb8000 }
            if ( !(v28 | v29) )
            {
LABEL_25:
              __asm
              {
                vmovsd  xmm3, cs:__real@40d7700000000000
                vcvtss2sd xmm2, xmm6, xmm6
                vmovq   r9, xmm3
                vmovq   r8, xmm2
              }
              Com_Printf(9, "invalid 'freq' %f, must be >= 0 and <= %f\n", *(double *)&_XMM2, *(double *)&_XMM3);
            }
            else
            {
              v32 = Cmd_Argv(7);
              _XMM0_8 = atof(v32);
              __asm
              {
                vcvtsd2ss xmm1, xmm0, xmm0
                vcomiss xmm1, xmm7
              }
              if ( v28 | v29 )
              {
                __asm
                {
                  vcvtss2sd xmm2, xmm1, xmm1
                  vmovq   r8, xmm2
                }
                Com_Printf(9, "invalid 'q' %f, must be > 0\n", *(double *)&_XMM2);
              }
              else
              {
                __asm
                {
                  vmovss  dword ptr [rsp+98h+var_68], xmm1
                  vmovss  dword ptr [rsp+98h+var_70], xmm6
                  vmovss  dword ptr [rsp+98h+var_78], xmm8
                }
                SND_SetEqParams(EntChannelFromName, v22, v24, v26, v43, v45, v47);
              }
            }
            __asm
            {
              vmovaps xmm7, [rsp+98h+var_28]
              vmovaps xmm6, [rsp+98h+var_18]
              vmovaps xmm8, [rsp+98h+var_38]
            }
          }
        }
        else
        {
          Com_Printf(9, "invalid 'band' %i, must be >= 0 and < %i\n", v23, 2i64);
        }
      }
    }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_setEq <const char *channelName> <int eqIndex> <int band> <const char *type> <float gain> <float freq> <float q>\n");
    __asm
    {
      vmovss  xmm2, cs:?sdGlob@@3USDLocal@@A.eqLerp; SDLocal sdGlob
      vcvtss2sd xmm2, xmm2, xmm2
      vmovq   r8, xmm2
    }
    Com_Printf(9, "Current EQ Settings\n---------------\n lerp = %.2f\n", *(double *)&_XMM2);
    for ( i = 0i64; g_snd.globals && (unsigned int)i < g_snd.globals->entchannelCount; i = (unsigned int)(i + 1) )
    {
      EntChannelName = SND_GetEntChannelName(i);
      Com_Printf(9, "+ %s\n", EntChannelName);
      v9 = 0;
      _RBX = (char *)&sdGlob + 20 * i;
      do
      {
        for ( j = 0; j < 2; ++j )
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rbx]
            vmovups [rsp+98h+var_58], xmm0
          }
          if ( (unsigned __int8)*((_DWORD *)_RBX + 4) )
          {
            __asm
            {
              vmovss  xmm0, dword ptr [rsp+98h+var_58+0Ch]
              vmovss  xmm1, dword ptr [rsp+98h+var_58+4]
              vmovss  xmm2, dword ptr [rsp+98h+var_58+8]
              vcvtss2sd xmm0, xmm0, xmm0
              vmovsd  [rsp+98h+var_60], xmm0
              vcvtss2sd xmm1, xmm1, xmm1
              vmovsd  [rsp+98h+var_68], xmm1
              vcvtss2sd xmm2, xmm2, xmm2
              vmovsd  [rsp+98h+var_70], xmm2
            }
            Com_Printf(9, "\t%i %i %s %f Hz %f dB %f q\n", (unsigned int)v9, (unsigned int)j, snd_eqTypeStrings[(int)v49], v44, v46, v48);
          }
          _RBX += 5120;
        }
        ++v9;
      }
      while ( v9 < 2 );
    }
  }
}

/*
==============
SND_SetFullResourcesMode
==============
*/
void SND_SetFullResourcesMode(void)
{
  Sys_UpdateSoundThreadAffinities(0);
}

/*
==============
SND_SetIgnorePauseFlag
==============
*/
void SND_SetIgnorePauseFlag(bool ignorePause)
{
  bool *voiceAlloc; 
  int v3; 
  bool *p_ignorePause; 
  __int64 v5; 

  voiceAlloc = sdGlob.voiceAlloc;
  v3 = 0;
  p_ignorePause = &g_snd.voices[0].ignorePause;
  do
  {
    if ( (unsigned int)v3 > 0x62 )
    {
      LODWORD(v5) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v5) )
        __debugbreak();
    }
    if ( *voiceAlloc )
      *p_ignorePause = ignorePause;
    ++v3;
    ++voiceAlloc;
    p_ignorePause += 1968;
  }
  while ( v3 < 99 );
}

/*
==============
SND_SetLevelFadeIn
==============
*/

void __fastcall SND_SetLevelFadeIn(double volume, int fadetime, double _XMM2_8)
{
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
    vmovaps xmm6, xmm0
  }
  if ( fadetime < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6754, ASSERT_TYPE_ASSERT, "(fadetime >= 0)", (const char *)&queryFormat, "fadetime >= 0") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
  {
    __asm
    {
      vmovss  xmm3, cs:__real@3f800000; max
      vxorps  xmm2, xmm2, xmm2; min
      vmovaps xmm1, xmm6; value
    }
    SND_SetParamValue(&g_snd.scriptSoundFade, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fadetime);
  }
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
  }
}

/*
==============
SND_SetListener
==============
*/
void SND_SetListener(LocalClientNum_t localClientNum, int playerStateClientNum, const vec3_t *origin, const tmat33_t<vec3_t> *axis, const vec3_t *velocity)
{
  __int64 v7; 
  unsigned __int64 v9; 
  snd_listener *v12; 
  int v25; 
  int v26; 

  v7 = localClientNum;
  if ( g_snd.driverInitialized && !(unsigned __int8)CL_GetLocalClientFrontEntState(localClientNum) )
  {
    if ( (unsigned int)v7 >= 2 )
    {
      v26 = 2;
      v25 = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3032, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v25, v26) )
        __debugbreak();
    }
    v9 = (unsigned __int64)&g_snd.listenerFence & 3;
    do
    {
      if ( v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
    _RSI = v7 << 7;
    AxisCopy(axis, &g_snd.listeners[v7].orient.axis);
    _RBP = &g_snd;
    v12 = &g_snd.listeners[v7];
    v12->orient.origin.v[0] = origin->v[0];
    v12->orient.origin.v[1] = origin->v[1];
    v12->orient.origin.v[2] = origin->v[2];
    OrientationInvert(&v12->orient, &g_snd.listeners[v7].inverse);
    _RAX = velocity;
    __asm
    {
      vmovss  xmm0, dword ptr [rax]
      vmovss  xmm2, dword ptr [rax+4]
      vmovss  xmm3, dword ptr [rax+8]
      vmulss  xmm1, xmm0, xmm0
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vsqrtss xmm0, xmm2, xmm2
      vmulss  xmm3, xmm0, cs:__real@3d68ba2f
      vmovss  dword ptr [rsi+rbp+7940h], xmm3
    }
    *(int *)((char *)&g_snd.listeners[0].playerStateClientNum + _RSI) = playerStateClientNum;
    *(LocalClientNum_t *)((char *)&g_snd.listeners[0].localClientNum + _RSI) = v7;
    *(&g_snd.listeners[0].active + _RSI) = 1;
    *(int *)((char *)&g_snd.listeners[0].controllerIndex + _RSI) = CL_Mgr_GetControllerFromClient((LocalClientNum_t)v7);
    if ( v9 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
        __debugbreak();
    }
    _InterlockedExchange(&g_snd.listenerFence, 0);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm0, dword ptr [rsi+rbp+7940h]
    }
  }
}

/*
==============
SND_SetMainReverb
==============
*/

void __fastcall SND_SetMainReverb(const ReverbDef *reverbDef, __int64 a2, __int64 a3, double _XMM3_8)
{
  unsigned int roomTypeId; 
  BOOL v9; 
  __int64 v10; 

  roomTypeId = reverbDef->roomTypeId;
  _EBP = 0;
  _RSI = reverbDef;
  _ER14 = 1;
  if ( sdGlob.currentReverbId[0] == roomTypeId )
  {
    v9 = 0;
  }
  else if ( sdGlob.currentReverbId[1] == roomTypeId )
  {
    v9 = 1;
  }
  else
  {
    v9 = g_snd.activeMainReverb != RVB_MAIN_B;
    SND_SetReverbParams(roomTypeId, (ReverbDescriptor)v9, 0);
  }
  g_snd.activeMainReverb = v9;
  g_snd.reverbSetting[v9].presetId = roomTypeId;
  g_snd.reverbSetting[g_snd.activeMainReverb].drylevel = _RSI->dryLevel;
  g_snd.reverbSetting[g_snd.activeMainReverb].wetlevel = _RSI->wetLevel;
  v10 = 0i64;
  _ECX = g_snd.activeMainReverb;
  if ( g_snd.activeMainReverb != RVB_MAIN_B )
    v10 = 1i64;
  if ( !g_snd.reverbSetting[v10].presetId )
  {
    __asm
    {
      vmovss  xmm2, cs:__real@3f800000
      vmovd   xmm0, ecx
      vxorps  xmm4, xmm4, xmm4
      vmovd   xmm1, r14d
      vpcmpeqd xmm3, xmm0, xmm1
      vblendvps xmm0, xmm4, xmm2, xmm3
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm4; snd_local_t g_snd
    }
LABEL_14:
    __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm0; snd_local_t g_snd }
    return;
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rsi+50h]
    vxorps  xmm3, xmm3, xmm3
    vucomiss xmm2, xmm3
  }
  if ( g_snd.activeMainReverb == RVB_MAIN_B )
  {
    __asm { vmovd   xmm1, ebp }
    _EAX = g_snd.activeMainReverb == RVB_MAIN_B;
    __asm
    {
      vmovd   xmm0, eax
      vpcmpeqd xmm2, xmm0, xmm1
      vmovss  xmm1, cs:__real@3f800000
      vblendvps xmm0, xmm1, xmm3, xmm2
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm3; snd_local_t g_snd
    }
    goto LABEL_14;
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vdivss  xmm1, xmm0, xmm2
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm1; snd_local_t g_snd
    vmovss  xmm0, cs:__real@ba83126f
    vdivss  xmm1, xmm0, xmm2
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm1; snd_local_t g_snd
  }
}

/*
==============
SND_SetMainReverbBlended
==============
*/

void __fastcall SND_SetMainReverbBlended(const ReverbDef *fromDef, const ReverbDef *toDef, double lerp)
{
  unsigned int roomTypeId; 
  int v7; 
  ReverbDescriptor v8; 
  unsigned int v9; 
  int v14; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 

  roomTypeId = fromDef->roomTypeId;
  v7 = 4;
  v8 = RVB_MAIN_A;
  v9 = toDef->roomTypeId;
  _RBP = toDef;
  _R14 = fromDef;
  __asm { vmovaps [rsp+68h+var_28], xmm6 }
  _EBX = 1;
  __asm
  {
    vmovaps [rsp+68h+var_38], xmm7
    vmovaps [rsp+68h+var_48], xmm8
    vmovaps xmm7, xmm2
  }
  if ( sdGlob.currentReverbId[0] == roomTypeId )
  {
    v14 = 0;
  }
  else
  {
    v14 = 4;
    if ( sdGlob.currentReverbId[1] == roomTypeId )
      v14 = 1;
  }
  if ( sdGlob.currentReverbId[0] == v9 )
  {
    v7 = 0;
  }
  else if ( sdGlob.currentReverbId[1] == v9 )
  {
    v7 = 1;
  }
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vxorps  xmm6, xmm6, xmm6
  }
  if ( v14 == 4 )
  {
    if ( v7 == 4 )
    {
      SND_SetReverbParams(roomTypeId, RVB_MAIN_A, 0);
      SND_SetReverbParams(v9, RVB_MAIN_B, 0);
      g_snd.activeMainReverb = RVB_MAIN_B;
      __asm
      {
        vmovss  xmm0, dword ptr [r14+48h]
        vmovss  cs:?g_snd@@3Usnd_local_t@@A.reverbSetting.drylevel, xmm0; snd_local_t g_snd
        vmovss  xmm1, dword ptr [r14+4Ch]
        vmovss  cs:?g_snd@@3Usnd_local_t@@A.reverbSetting.wetlevel, xmm1; snd_local_t g_snd
      }
      g_snd.reverbSetting[0].presetId = roomTypeId;
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+48h]
        vmovss  cs:?g_snd@@3Usnd_local_t@@A.reverbSetting.drylevel+0Ch, xmm0; snd_local_t g_snd
        vmovss  xmm1, dword ptr [rbp+4Ch]
        vsubss  xmm0, xmm8, xmm7
        vmovss  cs:?g_snd@@3Usnd_local_t@@A.reverbSetting.wetlevel+0Ch, xmm1; snd_local_t g_snd
        vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm0; snd_local_t g_snd
      }
      g_snd.reverbSetting[1].presetId = v9;
      goto LABEL_20;
    }
    LOBYTE(v8) = v7 == 0;
    v22 = (unsigned int)v8;
    SND_SetReverbParams(roomTypeId, v8, 0);
    v23 = v22;
    g_snd.reverbSetting[v23].drylevel = _R14->dryLevel;
    g_snd.reverbSetting[v23].wetlevel = _R14->wetLevel;
    g_snd.reverbSetting[v23].presetId = roomTypeId;
  }
  else if ( v7 == 4 )
  {
    LOBYTE(v8) = v14 == 0;
    v24 = (unsigned int)v8;
    SND_SetReverbParams(v9, v8, 0);
    v25 = v24;
    g_snd.reverbSetting[v25].drylevel = _RBP->dryLevel;
    g_snd.reverbSetting[v25].wetlevel = _RBP->wetLevel;
    g_snd.reverbSetting[v25].presetId = v9;
  }
  else if ( v14 == v7 )
  {
    __asm
    {
      vmovd   xmm0, cs:?g_snd@@3Usnd_local_t@@A.activeMainReverb; snd_local_t g_snd
      vmovd   xmm1, ebx
      vpcmpeqd xmm2, xmm0, xmm1
      vblendvps xmm7, xmm8, xmm6, xmm2
    }
  }
  if ( g_snd.activeMainReverb == RVB_MAIN_B )
  {
    __asm
    {
      vsubss  xmm0, xmm8, xmm7
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm0; snd_local_t g_snd
    }
  }
  else
  {
    __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.current, xmm7; snd_local_t g_snd }
  }
LABEL_20:
  __asm
  {
    vmovaps xmm7, [rsp+68h+var_38]
    vmovaps xmm8, [rsp+68h+var_48]
    vmovss  cs:?g_snd@@3Usnd_local_t@@A.mainReverbLerp.rateMS, xmm6; snd_local_t g_snd
    vmovaps xmm6, [rsp+68h+var_28]
  }
}

/*
==============
SND_SetMusicState
==============
*/

void __fastcall SND_SetMusicState(unsigned int stateId)
{
  SNDL_SetMusicState(stateId);
}

/*
==============
SND_SetMusicState
==============
*/

void __fastcall SND_SetMusicState(unsigned int stateId, const unsigned int *assetIdPlaylist, unsigned int assetIdCount)
{
  SNDL_SetMusicState(stateId, assetIdPlaylist, assetIdCount);
}

/*
==============
SND_SetMusicState
==============
*/
void SND_SetMusicState(const char *stateName)
{
  const char *v1; 
  char v2; 
  unsigned int v3; 
  char v4; 

  v1 = stateName;
  if ( stateName && (v2 = *stateName) != 0 )
  {
    v3 = 5381;
    do
    {
      ++v1;
      v4 = v2 | 0x20;
      if ( (unsigned int)(v2 - 65) >= 0x1A )
        v4 = v2;
      v3 = 65599 * v3 + v4;
      v2 = *v1;
    }
    while ( *v1 );
    if ( !v3 )
      v3 = 1;
  }
  else
  {
    v3 = 0;
    if ( stateName && *stateName )
      Com_PrintError(9, "SOUND: Unknown music state '%s' %x\n", stateName, 0i64);
  }
  SNDL_SetMusicState(v3);
}

/*
==============
SND_SetOcclusionFilterSingleIndex
==============
*/
void SND_SetOcclusionFilterSingleIndex(int entchannel, int eqIndex, OccludeDef *occludeDef)
{
  __int64 v3; 
  __int64 v5; 
  unsigned __int64 v6; 
  __int64 v7; 
  __int64 v9; 
  int v10; 

  v3 = entchannel;
  v5 = eqIndex;
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v10 = 256;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7519, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( ( sizeof( *array_counter( g_snd.entChanOcclusionParams ) ) + 0 ) )", "entchannel doesn't index ARRAY_COUNT( g_snd.entChanOcclusionParams )\n\t%i not in [0, %i)", entchannel, v10) )
      __debugbreak();
  }
  if ( (unsigned int)v5 >= 2 )
  {
    LODWORD(v9) = 2;
    LODWORD(v7) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7520, ASSERT_TYPE_ASSERT, "(unsigned)( eqIndex ) < (unsigned)( ( sizeof( *array_counter( g_snd.entChanOcclusionParams[0] ) ) + 0 ) )", "eqIndex doesn't index ARRAY_COUNT( g_snd.entChanOcclusionParams[0] )\n\t%i not in [0, %i)", v7, v9) )
      __debugbreak();
  }
  v6 = 9 * (v5 + 2 * v3);
  g_snd.entChanOcclusionParams[0][v6 / 9].enabled = 1;
  g_snd.entChanFullOcclusionDisabled[v6 - 4607] = LODWORD(occludeDef->cutoffLevel1);
  g_snd.entChanFullOcclusionDisabled[v6 - 4606] = LODWORD(occludeDef->cutoffLevel2);
  g_snd.entChanFullOcclusionDisabled[v6 - 4605] = LODWORD(occludeDef->cutoffLevel3);
  g_snd.entChanFullOcclusionDisabled[v6 - 4604] = LODWORD(occludeDef->cutoffLevel4);
  g_snd.entChanFullOcclusionDisabled[v6 - 4603] = LODWORD(occludeDef->attnLevel1);
  g_snd.entChanFullOcclusionDisabled[v6 - 4602] = LODWORD(occludeDef->attnLevel2);
  g_snd.entChanFullOcclusionDisabled[v6 - 4601] = LODWORD(occludeDef->attnLevel3);
  g_snd.entChanFullOcclusionDisabled[v6 - 4600] = LODWORD(occludeDef->attnLevel4);
}

/*
==============
SND_SetParamValue
==============
*/

void __fastcall SND_SetParamValue(snd_param_info_t *info, double value, double min, double max, int msec)
{
  char v23; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps [rsp+78h+var_28], xmm7
  }
  _RBX = info;
  __asm
  {
    vmovaps [rsp+78h+var_38], xmm8
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm1, xmm7
    vmovaps [rsp+78h+var_48], xmm9
    vmovaps xmm8, xmm3
    vmovaps xmm9, xmm2
    vmovaps xmm6, xmm1
  }
  if ( !info && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4705, ASSERT_TYPE_ASSERT, "(info)", (const char *)&queryFormat, "info") )
    __debugbreak();
  if ( msec )
  {
    __asm
    {
      vmovaps xmm2, xmm8; max
      vmovaps xmm1, xmm9; min
      vmovaps xmm0, xmm6; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vcomiss xmm0, dword ptr [rbx]
      vmovss  xmm1, cs:__real@3f800000
      vxorps  xmm2, xmm2, xmm2
      vcvtsi2ss xmm2, xmm2, edi
      vdivss  xmm4, xmm1, xmm2
      vsubss  xmm1, xmm0, dword ptr [rbx]
      vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vmovss  dword ptr [rbx+10h], xmm1
      vmovss  dword ptr [rbx+4], xmm0
    }
    if ( v23 )
    {
      __asm { vxorps  xmm0, xmm4, cs:__xmm@80000000800000008000000080000000 }
      _RBX->goalfraction = 1.0;
      __asm { vmovss  dword ptr [rbx+8], xmm0 }
    }
    else
    {
      _RBX->goalfraction = 0.0;
      __asm { vmovss  dword ptr [rbx+8], xmm4 }
    }
  }
  else
  {
    __asm
    {
      vmovss  dword ptr [rbx+4], xmm6
      vmovss  dword ptr [rbx], xmm6
      vmovss  dword ptr [rbx+8], xmm7
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+78h+var_18]
    vmovaps xmm7, [rsp+78h+var_28]
    vmovaps xmm8, [rsp+78h+var_38]
    vmovaps xmm9, [rsp+78h+var_48]
  }
}

/*
==============
SND_SetPlaybackIdNotPlayed
==============
*/
__int64 SND_SetPlaybackIdNotPlayed(int index)
{
  __int64 v1; 

  v1 = index;
  if ( (unsigned int)index > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3056, ASSERT_TYPE_ASSERT, "(index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "index >= 0 && index < SND_MAX_VOICES") )
    __debugbreak();
  g_snd.chaninfoUnweightedPriority[492 * v1 - 48701] = 0.0;
  return 0i64;
}

/*
==============
SND_SetReverbParams
==============
*/
void SND_SetReverbParams(const unsigned int id, ReverbDescriptor index, bool fadeOut)
{
  __int64 v3; 
  unsigned int v4; 
  const SndSendEffectParams *Radverb; 
  int v52; 
  snd_rv_params params; 
  snd_quad_five_tap_delay_params v54; 

  v3 = index;
  v4 = 0;
  if ( (unsigned int)index >= RVB_MAX_NUM )
  {
    v52 = 4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1676, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( RVB_MAX_NUM )", "index doesn't index RVB_MAX_NUM\n\t%i not in [0, %i)", index, v52) )
      __debugbreak();
  }
  SND_RvParamsDefault(&params);
  SND_DelayParamsDefault(&v54);
  _RCX = SND_GetRadverb(id);
  if ( _RCX || (Radverb = SND_GetRadverb(g_snd.defaultHash), id = g_snd.defaultHash, (_RCX = Radverb) != NULL) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+48h]
      vmovss  [rsp+130h+params.earlyTime], xmm0
      vmovss  xmm1, dword ptr [rcx+4Ch]
      vmovss  [rsp+130h+params.lateTime], xmm1
      vmovss  xmm0, dword ptr [rcx+50h]
      vmovss  [rsp+130h+params.earlyGain], xmm0
      vmovss  xmm1, dword ptr [rcx+54h]
      vmovss  [rsp+130h+params.lateGain], xmm1
      vmovss  xmm0, dword ptr [rcx+5Ch]
      vmovss  [rsp+130h+params.returnGain], xmm0
      vmovss  xmm1, dword ptr [rcx+60h]
      vmovss  [rsp+130h+params.earlyLpf], xmm1
      vmovss  xmm0, dword ptr [rcx+64h]
      vmovss  [rsp+130h+params.lateLpf], xmm0
      vmovss  xmm1, dword ptr [rcx+68h]
      vmovss  [rsp+130h+params.inputLpf], xmm1
      vmovss  xmm0, dword ptr [rcx+6Ch]
      vmovss  [rsp+130h+params.dampLpf], xmm0
      vmovss  xmm1, dword ptr [rcx+74h]
      vmovss  [rsp+130h+params.dryGain], xmm1
      vmovss  xmm0, dword ptr [rcx+78h]
      vmovss  [rsp+130h+params.earlySize], xmm0
      vmovss  xmm1, dword ptr [rcx+7Ch]
      vmovss  [rbp+30h+params.lateSize], xmm1
      vmovss  xmm0, dword ptr [rcx+80h]
      vmovss  [rbp+30h+params.diffusion], xmm0
      vmovss  xmm1, dword ptr [rcx+84h]
      vmovss  [rbp+30h+params.rearLevel], xmm1
    }
    params.fade = fadeOut;
    params.fadeTimeStamp = g_snd.time;
    v54.params[0].enabled = _RCX->delay1enabled;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+8Ch]
      vmovss  [rbp+30h+var_A0.params.delayTimeMS], xmm0
      vmovss  xmm1, dword ptr [rcx+90h]
      vmovss  [rbp+30h+var_A0.params.level], xmm1
      vmovss  xmm0, dword ptr [rcx+94h]
      vmovss  [rbp+30h+var_A0.params.lpfCutoff], xmm0
      vmovss  xmm1, dword ptr [rcx+98h]
      vmovss  [rbp+30h+var_A0.params.hpfCutoff], xmm1
    }
    v54.params[1].enabled = _RCX->delay2enabled;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+0A0h]
      vmovss  [rbp+30h+var_A0.params.delayTimeMS+14h], xmm0
      vmovss  xmm1, dword ptr [rcx+0A4h]
      vmovss  [rbp+30h+var_A0.params.level+14h], xmm1
      vmovss  xmm0, dword ptr [rcx+0A8h]
      vmovss  [rbp+30h+var_A0.params.lpfCutoff+14h], xmm0
      vmovss  xmm1, dword ptr [rcx+0ACh]
      vmovss  [rbp+30h+var_A0.params.hpfCutoff+14h], xmm1
    }
    v54.params[2].enabled = _RCX->delay3enabled;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+0B4h]
      vmovss  [rbp+30h+var_A0.params.delayTimeMS+28h], xmm0
      vmovss  xmm1, dword ptr [rcx+0B8h]
      vmovss  [rbp+30h+var_A0.params.level+28h], xmm1
      vmovss  xmm0, dword ptr [rcx+0BCh]
      vmovss  [rbp+30h+var_A0.params.lpfCutoff+28h], xmm0
      vmovss  xmm1, dword ptr [rcx+0C0h]
      vmovss  [rbp+30h+var_A0.params.hpfCutoff+28h], xmm1
    }
    v54.params[3].enabled = _RCX->delay4enabled;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+0C8h]
      vmovss  [rbp+30h+var_A0.params.delayTimeMS+3Ch], xmm0
      vmovss  xmm1, dword ptr [rcx+0CCh]
      vmovss  [rbp+30h+var_A0.params.level+3Ch], xmm1
      vmovss  xmm0, dword ptr [rcx+0D0h]
      vmovss  [rbp+30h+var_A0.params.lpfCutoff+3Ch], xmm0
      vmovss  xmm1, dword ptr [rcx+0D4h]
      vmovss  [rbp+30h+var_A0.params.hpfCutoff+3Ch], xmm1
    }
    v54.params[4].enabled = _RCX->delay5enabled;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+0DCh]
      vmovss  [rbp+30h+var_A0.params.delayTimeMS+50h], xmm0
      vmovss  xmm1, dword ptr [rcx+0E0h]
      vmovss  [rbp+30h+var_A0.params.level+50h], xmm1
      vmovss  xmm0, dword ptr [rcx+0E4h]
      vmovss  [rbp+30h+var_A0.params.lpfCutoff+50h], xmm0
      vmovss  xmm1, dword ptr [rcx+0E8h]
      vmovss  [rbp+30h+var_A0.params.hpfCutoff+50h], xmm1
    }
    v4 = id;
  }
  _RCX = &sdGlob.currentReverbParams[v3];
  _RAX = &params;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovups ymmword ptr [rcx], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rcx+20h], ymm0
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups ymmword ptr [rcx+40h], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovups ymmword ptr [rcx+60h], ymm0
    vmovups ymmword ptr [rcx+80h], ymm1
    vmovups xmm1, xmmword ptr [rax+0A0h]
  }
  *(float *)&_RAX = v54.params[4].hpfCutoff;
  __asm { vmovups xmmword ptr [rcx+0A0h], xmm1 }
  LODWORD(_RCX->delayParams.params[4].hpfCutoff) = (_DWORD)_RAX;
  sdGlob.currentReverbId[v3] = v4;
}

/*
==============
SND_SetTimeLerp
==============
*/

void __fastcall SND_SetTimeLerp(TimeLerp *lerp, double time, double _XMM2_8, double _XMM3_8)
{
  char v4; 

  __asm
  {
    vxorps  xmm2, xmm2, xmm2
    vucomiss xmm1, xmm2
  }
  if ( v4 )
  {
    __asm { vxorps  xmm3, xmm3, xmm3 }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3a83126f
      vdivss  xmm3, xmm0, xmm1
    }
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vcmpneqss xmm1, xmm1, xmm2
    vblendvps xmm1, xmm0, xmm2, xmm1
    vmovss  dword ptr [rcx], xmm1
    vmovss  dword ptr [rcx+4], xmm3
  }
}

/*
==============
SND_SetTimeScaleLerp
==============
*/

void __fastcall SND_SetTimeScaleLerp(const int entchannel, double lerp)
{
  bool v6; 
  bool v7; 
  bool v8; 
  int v13; 

  _RBX = entchannel;
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  v6 = (unsigned int)entchannel < 0x100;
  v7 = (unsigned int)entchannel <= 0x100;
  if ( (unsigned int)entchannel >= 0x100 )
  {
    v13 = 256;
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6046, ASSERT_TYPE_ASSERT, "(unsigned)( entchannel ) < (unsigned)( 256 )", "entchannel doesn't index SND_MAX_ENTCHANNELS\n\t%i not in [0, %i)", entchannel, v13);
    v6 = 0;
    v7 = !v8;
    if ( v8 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v6 )
    goto LABEL_11;
  __asm { vcomiss xmm6, cs:__real@3f800000 }
  if ( !v7 )
  {
LABEL_11:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6047, ASSERT_TYPE_ASSERT, "(lerp >= 0.0f && lerp <= 1.0f)", (const char *)&queryFormat, "lerp >= 0.0f && lerp <= 1.0f") )
      __debugbreak();
  }
  _RCX = g_snd.entchanOverrides.timescaleLerp;
  __asm
  {
    vmovss  dword ptr [rcx+rbx*4], xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
}

/*
==============
SND_SetUIPause
==============
*/
void SND_SetUIPause(bool paused)
{
  g_snd.uiPaused = paused;
}

/*
==============
SND_SetUpVoiceParams
==============
*/
void SND_SetUpVoiceParams(SndVoiceParams *params, const SndAlias *alias, unsigned __int64 sndEnt, snd_alias_system_t system)
{
  __int64 v8; 
  unsigned __int64 v18; 
  unsigned __int64 v21; 
  EntityParamInfo *EntityParamInfo; 
  int flags; 
  int v31; 
  unsigned __int64 v32; 
  unsigned __int64 v33; 
  LocalClientNum_t *p_localClientNum; 
  unsigned int i; 
  __int64 v37; 

  _RBP = params;
  _RCX = &g_snd;
  v8 = (unsigned __int8)(alias->flags >> 10);
  _ER12 = system;
  __asm { vmovaps [rsp+78h+var_38], xmm6 }
  _RAX = 9 * v8;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+rax*8+8210h]
    vmovups ymmword ptr [rbp+0], ymm0
  }
  _RBP->occlusionParams0.attnLevel4 = g_snd.entChanOcclusionParams[v8][0].attnLevel4;
  _RAX = 9 * v8;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+rax*8+8234h]
    vmovups ymmword ptr [rbp+24h], ymm0
  }
  _RBP->occlusionParams1.attnLevel4 = g_snd.entChanOcclusionParams[v8][1].attnLevel4;
  *(double *)&_XMM0 = SND_GetTimescaleLerp(v8);
  __asm
  {
    vmulss  xmm1, xmm0, cs:?g_snd@@3Usnd_local_t@@A.timescale; snd_local_t g_snd
    vmovss  xmm6, cs:__real@3f800000
  }
  _RBP->entityVolume = 1.0;
  _RBP->entityPitch = 1.0;
  v18 = sndEnt & 0x1FFFFFFFFi64;
  __asm
  {
    vsubss  xmm0, xmm6, xmm0
    vaddss  xmm1, xmm1, xmm0
    vmovss  dword ptr [rbp+48h], xmm1
  }
  if ( (sndEnt & 0x1FFFFFFFFi64) - 5411 > 0x1F && v18 - 2049 > 0x8FF && v18 > 0x7FD && v18 - 5571 > 0x7A120 )
  {
    _EDI = 0;
  }
  else
  {
    v21 = (unsigned __int64)&g_sndEntityParamFence & 3;
    do
    {
      if ( v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&g_sndEntityParamFence) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(&g_sndEntityParamFence, 1, 0) == 1 );
    EntityParamInfo = SND_GetEntityParamInfo(sndEnt);
    if ( EntityParamInfo )
    {
      if ( _RBP != (SndVoiceParams *)-80i64 )
        _RBP->entityPitch = EntityParamInfo->pitch.value;
      if ( _RBP != (SndVoiceParams *)-76i64 )
        _RBP->entityVolume = EntityParamInfo->volume.value;
    }
    if ( v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)&g_sndEntityParamFence) )
      __debugbreak();
    _EDI = 0;
    _InterlockedExchange(&g_sndEntityParamFence, 0);
  }
  __asm { vmovd   xmm1, edi }
  _RBP->entChannelVol = SND_GetCurrentPriorityChannelGroup()->channelvol[v8].value;
  _RBP->levelFadeInVol = g_snd.levelFadeInChannelVols.channelvol[v8].value;
  __asm
  {
    vmovd   xmm0, r12d
    vpcmpeqd xmm2, xmm0, xmm1
  }
  _RBP->volModValue = g_snd.volmods[alias->volModIndex].value;
  __asm
  {
    vmovss  xmm1, cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.value; snd_local_t g_snd
    vblendvps xmm0, xmm1, xmm6, xmm2
    vmovss  dword ptr [rbp+60h], xmm0
  }
  *(double *)&_XMM0 = SND_SubmixGetVolmodAttenuation(alias->volModIndex);
  __asm { vmovss  dword ptr [rbp+64h], xmm0 }
  _RBP->focusCone = SND_SubmixGetVolmodFocusCone(alias->volModIndex);
  *(double *)&_XMM0 = SND_SubmixGetVolmodFocusAmount(alias->volModIndex);
  __asm
  {
    vmovss  dword ptr [rbp+70h], xmm0
    vmovss  xmm1, cs:?g_snd@@3Usnd_local_t@@A.volume; snd_local_t g_snd
    vmovss  dword ptr [rbp+74h], xmm1
  }
  *(_QWORD *)&_RBP->gpadSound = 0i64;
  flags = alias->flags;
  v31 = (flags >> 22) & 3;
  if ( v31 )
  {
    v32 = (sndEnt >> 33) & 3;
    if ( (unsigned int)v32 >= 2 )
    {
      LODWORD(v37) = v32;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16313, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v37, 2) )
        __debugbreak();
    }
    v33 = (unsigned __int64)&g_snd.listenerFence & 3;
    do
    {
      if ( v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
        __debugbreak();
    }
    while ( _InterlockedCompareExchange(&g_snd.listenerFence, 1, 0) == 1 );
    p_localClientNum = &g_snd.listeners[0].localClientNum;
    for ( i = 0; i < 2; ++i )
    {
      if ( *((_BYTE *)p_localClientNum + 4) && *p_localClientNum == (_DWORD)v32 )
        break;
      p_localClientNum += 32;
    }
    if ( v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.listenerFence) )
      __debugbreak();
    _InterlockedExchange(&g_snd.listenerFence, 0);
    params->gpadFlags = 0;
    if ( (flags & 0xC00000) == 0x400000 )
    {
      params->gpadSound = SGP_NONE;
    }
    else
    {
      if ( (flags & 0xC00000) == 0x800000 )
        v31 = 3;
      params->gpadSound = v31;
    }
  }
  __asm { vmovaps xmm6, [rsp+78h+var_38] }
}

/*
==============
SND_SetVoiceStartInfo
==============
*/
void SND_SetVoiceStartInfo(int index, const SndStartAliasInfo *startInfo)
{
  __int64 v6; 
  SndEntState *EntState; 
  const tmat33_t<vec3_t> *v9; 
  unsigned int duck; 
  const SndDuck *DuckById; 
  __int64 v122; 
  __int64 v145; 
  int v146; 
  int v147; 
  int v148; 
  int v149; 
  int v150; 
  int v151; 
  int v152; 
  int v153; 
  vec3_t outOrigin; 
  __int64 v155; 
  tmat33_t<vec3_t> out; 
  char v157; 
  void *retaddr; 

  _RAX = &retaddr;
  v155 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _RSI = startInfo;
  v6 = index;
  if ( (unsigned int)index > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3420, ASSERT_TYPE_ASSERT, "(index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "index >= 0 && index < SND_MAX_VOICES") )
    __debugbreak();
  if ( _RSI->system > (unsigned int)SASYS_CGAME )
  {
    LODWORD(v145) = _RSI->system;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3421, ASSERT_TYPE_ASSERT, "( ( startInfo->system >= 0 && startInfo->system < SASYS_COUNT ) )", "( startInfo->system ) = %i", v145) )
      __debugbreak();
  }
  if ( !_RSI->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3422, ASSERT_TYPE_ASSERT, "(startInfo->alias)", (const char *)&queryFormat, "startInfo->alias") )
    __debugbreak();
  if ( _RSI->startDelayUs < 0 )
  {
    LODWORD(v145) = _RSI->startDelayUs;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3423, ASSERT_TYPE_ASSERT, "( ( startInfo->startDelayUs >= 0 ) )", "( startInfo->startDelayUs ) = %i", v145) )
      __debugbreak();
  }
  _RBX = &g_snd.voices[v6];
  if ( (_RSI->sndEnt & 0x1FFFFFFFFi64) == 2048 || !SND_IsEntChannel3D((unsigned __int8)(_RSI->alias->flags >> 10)) )
  {
    *(_QWORD *)_RBX->offset.v = 0i64;
    _RBX->offset.v[2] = 0.0;
    if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.h", 941, ASSERT_TYPE_ASSERT, "(sndVoice)", (const char *)&queryFormat, "sndVoice") )
      __debugbreak();
    SetSecureSndVec3(&vec3_origin, &_RBX->org.origin, s_soundvoiceorg_aab_X, s_soundvoiceorg_aab_Y, s_soundvoiceorg_aab_Z);
  }
  else
  {
    EntState = SND_FindEntState(_RSI->sndEnt, 0);
    v9 = (const tmat33_t<vec3_t> *)EntState;
    if ( EntState && EntState->hasPosition )
    {
      SndEntState_GetOrigin(EntState, &outOrigin);
      AxisCopy(v9 + 2, &out);
      _RDI = &_RSI->org;
      __asm
      {
        vmovss  xmm0, dword ptr [rdi]
        vmovss  [rsp+0E8h+var_A8], xmm0
      }
      if ( (v146 & 0x7F800000) == 2139095040 )
        goto LABEL_74;
      __asm
      {
        vmovss  xmm0, dword ptr [rsi+14h]
        vmovss  [rsp+0E8h+var_A8], xmm0
      }
      if ( (v147 & 0x7F800000) == 2139095040 )
        goto LABEL_74;
      __asm
      {
        vmovss  xmm0, dword ptr [rsi+18h]
        vmovss  [rsp+0E8h+var_A8], xmm0
      }
      if ( (v148 & 0x7F800000) == 2139095040 )
      {
LABEL_74:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3440, ASSERT_TYPE_SANITY, "( !IS_NAN( ( startInfo->org )[0] ) && !IS_NAN( ( startInfo->org )[1] ) && !IS_NAN( ( startInfo->org )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( startInfo->org )[0] ) && !IS_NAN( ( startInfo->org )[1] ) && !IS_NAN( ( startInfo->org )[2] )") )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi]
        vsubss  xmm7, xmm0, dword ptr [rsp+0E8h+outOrigin]
        vmovss  xmm1, dword ptr [rdi+4]
        vsubss  xmm5, xmm1, dword ptr [rsp+0E8h+outOrigin+4]
        vmovss  xmm0, dword ptr [rdi+8]
        vsubss  xmm6, xmm0, dword ptr [rsp+0E8h+outOrigin+8]
        vmulss  xmm3, xmm5, dword ptr [rsp+0E8h+out+4]
        vmulss  xmm2, xmm7, dword ptr [rsp+0E8h+out]
        vaddss  xmm4, xmm3, xmm2
        vmulss  xmm0, xmm6, dword ptr [rsp+0E8h+out+8]
        vaddss  xmm2, xmm4, xmm0
        vmovss  dword ptr [rbx+98h], xmm2
        vmulss  xmm3, xmm7, dword ptr [rsp+0E8h+out+0Ch]
        vmulss  xmm2, xmm5, dword ptr [rsp+0E8h+out+10h]
        vaddss  xmm4, xmm3, xmm2
        vmulss  xmm1, xmm6, dword ptr [rsp+0E8h+out+14h]
        vaddss  xmm2, xmm4, xmm1
        vmovss  dword ptr [rbx+9Ch], xmm2
        vmulss  xmm3, xmm7, dword ptr [rsp+0E8h+out+18h]
        vmulss  xmm2, xmm5, dword ptr [rsp+0E8h+out+1Ch]
        vaddss  xmm4, xmm3, xmm2
        vmulss  xmm1, xmm6, dword ptr [rsp+0E8h+out+20h]
        vaddss  xmm2, xmm4, xmm1
        vmovss  dword ptr [rbx+0A0h], xmm2
        vmovss  xmm0, dword ptr [rbx+98h]
        vmovss  [rsp+0E8h+var_A8], xmm0
      }
      if ( (v149 & 0x7F800000) == 2139095040 )
        goto LABEL_75;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+9Ch]
        vmovss  [rsp+0E8h+var_A8], xmm0
      }
      if ( (v150 & 0x7F800000) == 2139095040 )
        goto LABEL_75;
      __asm { vmovss  [rsp+0E8h+var_A8], xmm2 }
      if ( (v151 & 0x7F800000) == 2139095040 )
      {
LABEL_75:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3445, ASSERT_TYPE_SANITY, "( !IS_NAN( ( voice->offset )[0] ) && !IS_NAN( ( voice->offset )[1] ) && !IS_NAN( ( voice->offset )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( voice->offset )[0] ) && !IS_NAN( ( voice->offset )[1] ) && !IS_NAN( ( voice->offset )[2] )") )
          __debugbreak();
      }
    }
    else
    {
      _RDI = &_RSI->org;
      _RBX->offset.v[0] = _RSI->org.v[0];
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+4]
        vmovss  dword ptr [rbx+9Ch], xmm0
        vmovss  xmm1, dword ptr [rdi+8]
        vmovss  dword ptr [rbx+0A0h], xmm1
      }
    }
    SndVoice_SetOrigin(&g_snd.voices[v6], _RDI);
    memset(&outOrigin, 0, sizeof(outOrigin));
  }
  _RBX->propagationTriggerIndex = 1024;
  _RBX->reverbDef = NULL;
  _RBX->assetEntry = _RSI->assetEntry;
  _RBX->sndEnt = _RSI->sndEnt;
  g_snd.chaninfoEntchannel[v6] = (unsigned __int8)(_RSI->alias->flags >> 10);
  _RBX->priorityVolume = _RSI->priorityVolume;
  _RBX->priorityAttenuation = _RSI->priorityAttenuation;
  SND_RecalcChaninfoPriority(v6);
  _RBX->basevolume = _RSI->volume;
  _RBX->volumeScale = _RSI->volumeScale;
  _RBX->distanceScale = _RSI->distanceScale;
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm1, xmm7; initValue
  }
  SND_InitParameter(&_RBX->volumeInfo, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm7; initValue }
  SND_InitParameter(&_RBX->pitchInfo, *(float *)&_XMM1);
  _RBX->contextLerpVolume = _RSI->contextLerpVolume;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+34h]
    vmovss  dword ptr [rbx+54h], xmm0
  }
  _RBX->pitchScale = _RSI->pitchScale;
  __asm { vmovss  [rsp+0E8h+var_A8], xmm0 }
  if ( (v152 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3475, ASSERT_TYPE_SANITY, "( !IS_NAN( voice->basepitch ) )", (const char *)&queryFormat, "!IS_NAN( voice->basepitch )") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+84h]
    vmovss  [rsp+0E8h+var_A8], xmm0
  }
  if ( (v153 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3476, ASSERT_TYPE_SANITY, "( !IS_NAN( voice->pitchScale ) )", (const char *)&queryFormat, "!IS_NAN( voice->pitchScale )") )
    __debugbreak();
  _RBX->alias = _RSI->alias;
  _RBX->looptime = g_snd.looptime;
  _RBX->paused = 1;
  _RBX->system = _RSI->system;
  _RBX->startFraction = _RSI->fraction;
  _RBX->lfeScale = _RSI->lfeScale;
  _RBX->occlusionMatchesListener = 1;
  _RBX->occlusionAmount = 0.0;
  _RBX->occlusionWaitId = 0;
  _RBX->lpfCutoff = _RSI->lpfCutoff;
  _RBX->hpfCutoff = _RSI->hpfCutoff;
  *(_DWORD *)&_RBX->wasRestored = 0;
  _RBX->startTimeMSec = g_snd.time;
  _RBX->adsrIndex = _RSI->adsrIndex;
  SndVoice_GetOrigin(&g_snd.voices[v6], &_RBX->dopplerEffectLastPos);
  _RBX->dopplerEffectPitch = 1.0;
  _RBX->waitingForDoppler = 2;
  _RBX->soundFileInfo.loadingState = SFLS_LOADING;
  _RBX->soundFileInfo.srcChannelCount = _RSI->assetEntry->channelCount;
  _RBX->soundFileInfo.baserate = _RSI->assetEntry->frameRate;
  _RBX->autoSimId = _RSI->autoSimId;
  _RBX->submixRef = NULL;
  duck = _RSI->alias->duck;
  if ( duck )
    DuckById = SND_GetDuckById(duck);
  else
    DuckById = NULL;
  _RBX->submixDef = DuckById;
  _RBX->framesPlayed = 0i64;
  *(_QWORD *)&_RBX->masterEnvelope = 0i64;
  _RBX->masterSlaveLerp = 0.0;
  _RBX->cullingEnvelope = 1.0;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rsi+50h]
    vmulss  xmm1, xmm0, cs:__real@3a83126f; time
  }
  SND_FaderSetRateTime(&_RBX->fadeInOut, *(float *)&_XMM1);
  _RBX->fadeInOut.goal = 1.0;
  __asm
  {
    vmovss  xmm2, dword ptr [rbx+120h]
    vmovss  xmm0, dword ptr [rbx+128h]
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcmpless xmm1, xmm0, cs:__real@80000000
    vblendvps xmm0, xmm2, xmm7, xmm1
    vmovss  dword ptr [rbx+120h], xmm0
    vmovss  xmm6, cs:__real@40800000
    vmovaps xmm1, xmm6; r
  }
  SND_FaderSetRate(&_RBX->submixAttenuation, *(float *)&_XMM1);
  _RBX->submixAttenuation.goal = 1.0;
  _RBX->submixAttenuation.value = 1.0;
  __asm { vmovaps xmm1, xmm6; r }
  SND_FaderSetRate(&_RBX->submixLpf, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm7; g }
  SND_FaderSetGoal(&_RBX->submixLpf, *(float *)&_XMM1);
  _RBX->submixLpf.value = _RBX->submixLpf.goal;
  __asm { vmovaps xmm1, xmm6; r }
  SND_FaderSetRate(&_RBX->submixHpf, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm7; g }
  SND_FaderSetGoal(&_RBX->submixHpf, *(float *)&_XMM1);
  _RBX->submixHpf.value = _RBX->submixHpf.goal;
  _RBP = DCONST_DVARFLT_snd_occfadetime;
  if ( !DCONST_DVARFLT_snd_occfadetime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occfadetime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBP);
  __asm { vmovss  xmm1, dword ptr [rbp+28h]; time }
  SND_FaderSetRateTime(&_RBX->occlusionVolume, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm7; g }
  SND_FaderSetGoal(&_RBX->occlusionVolume, *(float *)&_XMM1);
  _RBX->occlusionVolume.value = _RBX->occlusionVolume.goal;
  _RBP = DCONST_DVARFLT_snd_occfadetime;
  if ( !DCONST_DVARFLT_snd_occfadetime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occfadetime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBP);
  __asm { vmovss  xmm1, dword ptr [rbp+28h]; time }
  SND_FaderSetRateTime(&_RBX->occlusionCutoff, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm7; g }
  SND_FaderSetGoal(&_RBX->occlusionCutoff, *(float *)&_XMM1);
  _RBX->occlusionCutoff.value = _RBX->occlusionCutoff.goal;
  _R12 = SND_GetVfCurveById(_RSI->alias->volumeFalloffCurve);
  _R14 = SND_GetLpfCurveById(_RSI->alias->lpfCurve);
  _R15 = SND_GetHpfCurveById(_RSI->alias->hpfCurve);
  _R13 = SND_GetRvbCurveById(_RSI->alias->reverbSendCurve);
  _RDI = SND_GetSpeakerMapById(_RSI->alias->speakerMap);
  _RBP = SND_GetDopplerPresetById(_RSI->alias->dopplerPreset);
  _RSI = SND_GetOcclusionShapeById(_RSI->alias->occlusionShape);
  if ( !_R12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3572, ASSERT_TYPE_ASSERT, "(vfCurve)", (const char *)&queryFormat, "vfCurve") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3573, ASSERT_TYPE_ASSERT, "(lpfCurve)", (const char *)&queryFormat, "lpfCurve") )
    __debugbreak();
  if ( !_R15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3574, ASSERT_TYPE_ASSERT, "(hpfCurve)", (const char *)&queryFormat, "hpfCurve") )
    __debugbreak();
  if ( !_R13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3575, ASSERT_TYPE_ASSERT, "(rvbCurve)", (const char *)&queryFormat, "rvbCurve") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3576, ASSERT_TYPE_ASSERT, "(speakerMap)", (const char *)&queryFormat, "speakerMap") )
    __debugbreak();
  if ( !_RBP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3577, ASSERT_TYPE_ASSERT, "(dopplerPreset)", (const char *)&queryFormat, "dopplerPreset") )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3578, ASSERT_TYPE_ASSERT, "(occlusionShape)", (const char *)&queryFormat, "occlusionShape") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [r12]
    vmovups xmmword ptr [rbx+20Ch], xmm0
    vmovups xmm1, xmmword ptr [r12+10h]
    vmovups xmmword ptr [rbx+21Ch], xmm1
    vmovups xmm0, xmmword ptr [r12+20h]
    vmovups xmmword ptr [rbx+22Ch], xmm0
    vmovups xmm1, xmmword ptr [r12+30h]
    vmovups xmmword ptr [rbx+23Ch], xmm1
    vmovups xmm0, xmmword ptr [r12+40h]
    vmovups xmmword ptr [rbx+24Ch], xmm0
    vmovups xmm1, xmmword ptr [r12+50h]
    vmovups xmmword ptr [rbx+25Ch], xmm1
    vmovups xmm0, xmmword ptr [r12+60h]
    vmovups xmmword ptr [rbx+26Ch], xmm0
    vmovups xmm0, xmmword ptr [r12+70h]
    vmovups xmmword ptr [rbx+27Ch], xmm0
    vmovups xmm1, xmmword ptr [r12+80h]
    vmovups xmmword ptr [rbx+28Ch], xmm1
    vmovups xmm0, xmmword ptr [r12+90h]
    vmovups xmmword ptr [rbx+29Ch], xmm0
    vmovups xmm1, xmmword ptr [r12+0A0h]
    vmovups xmmword ptr [rbx+2ACh], xmm1
    vmovups xmm0, xmmword ptr [r12+0B0h]
    vmovups xmmword ptr [rbx+2BCh], xmm0
  }
  _RBX->vfCurve.points[15] = _R12->points[15];
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmmword ptr [rbx+2D4h], xmm0
    vmovups xmm1, xmmword ptr [r14+10h]
    vmovups xmmword ptr [rbx+2E4h], xmm1
    vmovups xmm0, xmmword ptr [r14+20h]
    vmovups xmmword ptr [rbx+2F4h], xmm0
    vmovups xmm1, xmmword ptr [r14+30h]
    vmovups xmmword ptr [rbx+304h], xmm1
    vmovups xmm0, xmmword ptr [r14+40h]
    vmovups xmmword ptr [rbx+314h], xmm0
    vmovups xmm1, xmmword ptr [r14+50h]
    vmovups xmmword ptr [rbx+324h], xmm1
    vmovups xmm0, xmmword ptr [r14+60h]
    vmovups xmmword ptr [rbx+334h], xmm0
    vmovups xmm1, xmmword ptr [r14+70h]
    vmovups xmmword ptr [rbx+344h], xmm1
    vmovups xmm0, xmmword ptr [r14+80h]
    vmovups xmmword ptr [rbx+354h], xmm0
    vmovups xmm1, xmmword ptr [r14+90h]
    vmovups xmmword ptr [rbx+364h], xmm1
    vmovups xmm0, xmmword ptr [r14+0A0h]
    vmovups xmmword ptr [rbx+374h], xmm0
    vmovups xmm1, xmmword ptr [r14+0B0h]
    vmovups xmmword ptr [rbx+384h], xmm1
  }
  _RBX->lpfCurve.points[15] = _R14->points[15];
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rbx+39Ch], xmm0
    vmovups xmm1, xmmword ptr [r15+10h]
    vmovups xmmword ptr [rbx+3ACh], xmm1
    vmovups xmm0, xmmword ptr [r15+20h]
    vmovups xmmword ptr [rbx+3BCh], xmm0
    vmovups xmm1, xmmword ptr [r15+30h]
    vmovups xmmword ptr [rbx+3CCh], xmm1
    vmovups xmm0, xmmword ptr [r15+40h]
    vmovups xmmword ptr [rbx+3DCh], xmm0
    vmovups xmm1, xmmword ptr [r15+50h]
    vmovups xmmword ptr [rbx+3ECh], xmm1
    vmovups xmm0, xmmword ptr [r15+60h]
    vmovups xmmword ptr [rbx+3FCh], xmm0
    vmovups xmm1, xmmword ptr [r15+70h]
    vmovups xmmword ptr [rbx+40Ch], xmm1
    vmovups xmm0, xmmword ptr [r15+80h]
    vmovups xmmword ptr [rbx+41Ch], xmm0
    vmovups xmm1, xmmword ptr [r15+90h]
    vmovups xmmword ptr [rbx+42Ch], xmm1
    vmovups xmm0, xmmword ptr [r15+0A0h]
    vmovups xmmword ptr [rbx+43Ch], xmm0
    vmovups xmm1, xmmword ptr [r15+0B0h]
    vmovups xmmword ptr [rbx+44Ch], xmm1
  }
  _RBX->hpfCurve.points[15] = _R15->points[15];
  __asm
  {
    vmovups xmm0, xmmword ptr [r13+0]
    vmovups xmmword ptr [rbx+464h], xmm0
    vmovups xmm1, xmmword ptr [r13+10h]
    vmovups xmmword ptr [rbx+474h], xmm1
    vmovups xmm0, xmmword ptr [r13+20h]
    vmovups xmmword ptr [rbx+484h], xmm0
    vmovups xmm1, xmmword ptr [r13+30h]
    vmovups xmmword ptr [rbx+494h], xmm1
    vmovups xmm0, xmmword ptr [r13+40h]
    vmovups xmmword ptr [rbx+4A4h], xmm0
    vmovups xmm1, xmmword ptr [r13+50h]
    vmovups xmmword ptr [rbx+4B4h], xmm1
    vmovups xmm0, xmmword ptr [r13+60h]
    vmovups xmmword ptr [rbx+4C4h], xmm0
    vmovups xmm1, xmmword ptr [r13+70h]
    vmovups xmmword ptr [rbx+4D4h], xmm1
    vmovups xmm0, xmmword ptr [r13+80h]
    vmovups xmmword ptr [rbx+4E4h], xmm0
    vmovups xmm1, xmmword ptr [r13+90h]
    vmovups xmmword ptr [rbx+4F4h], xmm1
    vmovups xmm0, xmmword ptr [r13+0A0h]
    vmovups xmmword ptr [rbx+504h], xmm0
    vmovups xmm1, xmmword ptr [r13+0B0h]
    vmovups xmmword ptr [rbx+514h], xmm1
  }
  _RBX->rvbCurve.points[15] = _R13->points[15];
  _RCX = &_RBX->speakerMap;
  v122 = 3i64;
  do
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rcx], xmm0
      vmovups xmm1, xmmword ptr [rdi+10h]
      vmovups xmmword ptr [rcx+10h], xmm1
      vmovups xmm0, xmmword ptr [rdi+20h]
      vmovups xmmword ptr [rcx+20h], xmm0
      vmovups xmm1, xmmword ptr [rdi+30h]
      vmovups xmmword ptr [rcx+30h], xmm1
      vmovups xmm0, xmmword ptr [rdi+40h]
      vmovups xmmword ptr [rcx+40h], xmm0
      vmovups xmm1, xmmword ptr [rdi+50h]
      vmovups xmmword ptr [rcx+50h], xmm1
      vmovups xmm0, xmmword ptr [rdi+60h]
      vmovups xmmword ptr [rcx+60h], xmm0
    }
    _RCX = (SpeakerMap *)((char *)_RCX + 128);
    __asm
    {
      vmovups xmm1, xmmword ptr [rdi+70h]
      vmovups xmmword ptr [rcx-10h], xmm1
    }
    _RDI = (const SpeakerMap *)((char *)_RDI + 128);
    --v122;
  }
  while ( v122 );
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rcx], xmm0
    vmovups xmm1, xmmword ptr [rdi+10h]
    vmovups xmmword ptr [rcx+10h], xmm1
    vmovups xmm0, xmmword ptr [rdi+20h]
    vmovups xmmword ptr [rcx+20h], xmm0
    vmovups xmm1, xmmword ptr [rdi+30h]
    vmovups xmmword ptr [rcx+30h], xmm1
  }
  _RCX->id = _RDI->id;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+0]
    vmovups ymmword ptr [rbx+6F0h], ymm0
    vmovups ymm1, ymmword ptr [rbp+20h]
    vmovups ymmword ptr [rbx+710h], ymm1
    vmovups xmm0, xmmword ptr [rbp+40h]
    vmovups xmmword ptr [rbx+730h], xmm0
    vmovsd  xmm1, qword ptr [rbp+50h]
    vmovsd  qword ptr [rbx+740h], xmm1
    vmovups ymm0, ymmword ptr [rsi]
    vmovups ymmword ptr [rbx+748h], ymm0
    vmovups ymm1, ymmword ptr [rsi+20h]
    vmovups ymmword ptr [rbx+768h], ymm1
    vmovups ymm0, ymmword ptr [rsi+40h]
    vmovups ymmword ptr [rbx+788h], ymm0
  }
  _RBX->occlusionShape.pitchOffsetAngle = _RSI->pitchOffsetAngle;
  _R11 = &v157;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
SND_SetVolModValue
==============
*/

void __fastcall SND_SetVolModValue(unsigned int volmodindex, double value, int msec)
{
  __int64 v7; 
  int v9; 
  __int64 v13; 
  unsigned int volmodinfoCount; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  v7 = volmodindex;
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4821, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v7 >= g_snd.globals->volmodinfoCount )
  {
    volmodinfoCount = g_snd.globals->volmodinfoCount;
    LODWORD(v13) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4822, ASSERT_TYPE_ASSERT, "(unsigned)( volmodindex ) < (unsigned)( g_snd.globals->volmodinfoCount )", "volmodindex doesn't index g_snd.globals->volmodinfoCount\n\t%i not in [0, %i)", v13, volmodinfoCount) )
      __debugbreak();
  }
  __asm { vmovss  xmm3, cs:__real@3f800000; max }
  v9 = 1;
  if ( msec > 1 )
    v9 = msec;
  __asm
  {
    vxorps  xmm2, xmm2, xmm2; min
    vmovaps xmm1, xmm6; value
  }
  SND_SetParamValue(&g_snd.volmods[v7], *(double *)&_XMM1, *(double *)&_XMM2, *(double *)&_XMM3, v9);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
SND_SetWorldPosition
==============
*/
char SND_SetWorldPosition(unsigned int id, const vec3_t *origin)
{
  unsigned int *p_playbackId; 
  unsigned int v4; 
  __int64 v6; 

  p_playbackId = &g_snd.voices[0].playbackId;
  v4 = 0;
  while ( *p_playbackId != id )
  {
    ++v4;
    p_playbackId += 492;
    if ( v4 >= 0x63 )
      return 0;
  }
  v6 = (int)v4;
  if ( (g_snd.voices[v6].sndEnt & 0x1FFFFFFFFi64) != 2046 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15214, ASSERT_TYPE_ASSERT, "(SndEnt_GetEntIndex( g_snd.voices[chanIdx].sndEnt ) == ENTITYNUM_WORLD)", "%s\n\tSND_SetPos: You may only set the position of a sound for \"world\" entities", "SndEnt_GetEntIndex( g_snd.voices[chanIdx].sndEnt ) == ENTITYNUM_WORLD") )
    __debugbreak();
  g_snd.voices[v6].offset.v[0] = origin->v[0];
  g_snd.voices[v6].offset.v[1] = origin->v[1];
  g_snd.voices[v6].offset.v[2] = origin->v[2];
  return 1;
}

/*
==============
SND_SetWorldPosition
==============
*/
char SND_SetWorldPosition(unsigned int id, const vec3_t *origin, unsigned __int64 sndEnt)
{
  unsigned int *p_playbackId; 
  unsigned int v5; 
  float *v7; 

  p_playbackId = &g_snd.voices[0].playbackId;
  v5 = 0;
  while ( *p_playbackId != id )
  {
    ++v5;
    p_playbackId += 492;
    if ( v5 >= 0x63 )
      return 0;
  }
  if ( !SND_IsWorldEntity(sndEnt) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15231, ASSERT_TYPE_ASSERT, "(SND_IsWorldEntity( sndEnt ))", "%s\n\tSND_SetPos: You may only set the position of a sound for \"world\" entities", "SND_IsWorldEntity( sndEnt )") )
    __debugbreak();
  v7 = &g_snd.chaninfoUnweightedPriority[492 * v5 - 48670];
  *v7 = origin->v[0];
  v7[1] = origin->v[1];
  v7[2] = origin->v[2];
  return 1;
}

/*
==============
SND_ShouldDrawOcclusionForAlias
==============
*/
bool SND_ShouldDrawOcclusionForAlias(const snd_listener *listener, const SndAlias *alias, const vec3_t *emitter)
{
  const dvar_t *v6; 
  bool v9; 
  const dvar_t *v38; 
  const char *string; 
  char v40; 
  char *v41; 
  char dest[128]; 

  v6 = DCONST_DVARINT_snd_occlusionDebug;
  _RBP = emitter;
  if ( !DCONST_DVARINT_snd_occlusionDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  v9 = v6->current.integer == 0;
  if ( !v6->current.integer )
    return 0;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0]
    vmovss  xmm1, dword ptr [rbp+4]
    vmovaps [rsp+118h+var_28], xmm6
    vsubss  xmm6, xmm1, dword ptr [rsi+4]
    vmovaps [rsp+118h+var_38], xmm7
    vmovaps [rsp+118h+var_48], xmm8
    vsubss  xmm8, xmm0, dword ptr [rsi]
    vmovss  xmm0, dword ptr [rbp+8]
    vsubss  xmm7, xmm0, dword ptr [rsi+8]
    vmulss  xmm0, xmm7, xmm7
    vmulss  xmm2, xmm6, xmm6
    vmulss  xmm1, xmm8, xmm8
    vaddss  xmm3, xmm2, xmm1
    vmovss  xmm1, cs:__real@3f800000
    vaddss  xmm2, xmm3, xmm0
    vsqrtss xmm4, xmm2, xmm2
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm1, xmm0
    vdivss  xmm5, xmm1, xmm0
    vmulss  xmm0, xmm6, xmm5
    vmulss  xmm3, xmm0, dword ptr [rsi+10h]
    vmovaps xmm6, [rsp+118h+var_28]
    vmulss  xmm1, xmm8, xmm5
    vmulss  xmm2, xmm1, dword ptr [rsi+0Ch]
    vmovaps xmm8, [rsp+118h+var_48]
    vmulss  xmm0, xmm7, xmm5
    vmulss  xmm1, xmm0, dword ptr [rsi+14h]
    vmovaps xmm7, [rsp+118h+var_38]
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm3, xmm4, xmm1
    vxorps  xmm2, xmm2, xmm2
    vcomiss xmm3, xmm2
  }
  if ( v9 )
    return 0;
  v38 = DCONST_DVARSTR_snd_occlusionDebugAlias;
  if ( !DCONST_DVARSTR_snd_occlusionDebugAlias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_occlusionDebugAlias") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v38);
  string = v38->current.string;
  memset_0(dest, 0, sizeof(dest));
  v40 = 0;
  if ( string )
  {
    if ( alias )
    {
      Core_strcpy(dest, 0x80ui64, string);
      v41 = strtok(dest, "%");
      if ( v41 )
      {
        while ( !*v41 || !strstr_0(alias->aliasName, v41) )
        {
          v41 = strtok(NULL, "%");
          if ( !v41 )
            return !dest[0] || v40;
        }
        v40 = 1;
      }
    }
  }
  return !dest[0] || v40;
}

/*
==============
SND_ShouldInit
==============
*/
char SND_ShouldInit()
{
  return 1;
}

/*
==============
SND_ShutdownDriver
==============
*/
void SND_ShutdownDriver(void)
{
  SND_StopSounds(SND_STOP_ALL);
  SD_Shutdown();
  g_snd.driverInitialized = 0;
}

/*
==============
SND_SoftReset
==============
*/

void __fastcall SND_SoftReset(double _XMM0_8)
{
  int *p_playTime; 
  unsigned int v2; 
  ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *mp_next; 
  ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *v4; 
  ntl::fixed_list<OcclusionLine,594,0> *v5; 

  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_WEAPON_REFLECT);
  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
  CG_SndAutoSimReset();
  SND_Stop3DSounds();
  p_playTime = &g_ambGlob[0].playTime;
  v2 = 0;
  do
  {
    v2 += 2;
    *(_QWORD *)(p_playTime - 1) = 0i64;
    p_playTime[1] = 0;
    *((_BYTE *)p_playTime + 8) = 0;
    *(_QWORD *)(p_playTime + 3) = 0i64;
    *(_QWORD *)(p_playTime + 7) = 0i64;
    *(_QWORD *)(p_playTime + 5) = 0i64;
    p_playTime[9] = 0;
    *(_QWORD *)(p_playTime + 11) = 0i64;
    p_playTime[13] = 0;
    *((_BYTE *)p_playTime + 56) = 0;
    *(_QWORD *)(p_playTime + 15) = 0i64;
    *(_QWORD *)(p_playTime + 19) = 0i64;
    *(_QWORD *)(p_playTime + 17) = 0i64;
    p_playTime[21] = 0;
    p_playTime += 24;
  }
  while ( v2 < 2 );
  SND_InitEntityParamInfo();
  SND_InitWeaponRelection();
  SND_InitGlobalContexts();
  memset_0(g_snd.entState, 0, sizeof(g_snd.entState));
  s_FXPlaySoundCount = 0;
  s_FXPlaySoundHead = 0;
  SND_ClearAllOcclusionSettings();
  mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)s_occlusionLines.m_listHead.m_sentinel.mp_next;
  *(_QWORD *)g_snd.entChanFullOcclusionDisabled = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[2] = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[4] = 0i64;
  *(_QWORD *)&g_snd.entChanFullOcclusionDisabled[6] = 0i64;
  if ( (ntl::internal::list_head_base<ntl::internal::list_node<OcclusionLine> > *)s_occlusionLines.m_listHead.m_sentinel.mp_next != &s_occlusionLines.m_listHead )
  {
    v4 = s_occlusionLines.m_freelist.m_head.mp_next;
    do
    {
      v5 = (ntl::fixed_list<OcclusionLine,594,0> *)mp_next[1].mp_next;
      mp_next->mp_next = v4;
      v4 = mp_next;
      s_occlusionLines.m_freelist.m_head.mp_next = mp_next;
      mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)v5;
    }
    while ( v5 != (ntl::fixed_list<OcclusionLine,594,0> *)&s_occlusionLines.m_listHead );
  }
  __asm { vxorps  xmm0, xmm0, xmm0; fadeTimeSec }
  s_occlusionLines.m_listHead.m_sentinel.mp_prev = &s_occlusionLines.m_listHead.m_sentinel;
  s_occlusionLines.m_listHead.m_sentinel.mp_next = &s_occlusionLines.m_listHead.m_sentinel;
  SND_SubmixClearAll(*(float *)&_XMM0);
  s_notifiesCount = 0;
  *(_QWORD *)g_snd.paSpeakerDisabledArray = 0i64;
  s_notifiesHead = 0;
  memset_0(g_snd.delayedWeaponSounds, 0, sizeof(g_snd.delayedWeaponSounds));
  memset_0(g_snd.delayedBulletEvents, 0, sizeof(g_snd.delayedBulletEvents));
  SND_BankDetailStreaming_Init();
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
}

/*
==============
SND_SoloChannel_f
==============
*/
void SND_SoloChannel_f()
{
  const char *v4; 
  unsigned int v5; 
  __int64 v7; 
  const char *EntChannelName; 
  signed __int64 v9; 
  unsigned int v10; 
  __int64 v11; 
  unsigned int v12; 
  unsigned int v13; 
  unsigned int v14; 

  if ( Cmd_Argc() == 2 )
  {
    __asm
    {
      vmovaps [rsp+78h+var_38], xmm6
      vmovaps [rsp+78h+var_48], xmm7
      vmovss  xmm6, cs:__real@3f800000
    }
    _ER14 = 0;
    v4 = Cmd_Argv(1);
    v5 = 0;
    __asm { vxorps  xmm7, xmm7, xmm7 }
    while ( g_snd.globals && v5 < g_snd.globals->entchannelCount )
    {
      v7 = 0x7FFFFFFFi64;
      EntChannelName = SND_GetEntChannelName(v5);
      if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !EntChannelName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v9 = v4 - EntChannelName;
      while ( 1 )
      {
        v10 = (unsigned __int8)EntChannelName[v9];
        v11 = v7;
        v12 = *(unsigned __int8 *)EntChannelName++;
        --v7;
        if ( !v11 )
        {
LABEL_21:
          _EAX = 0;
          goto LABEL_22;
        }
        if ( v10 != v12 )
        {
          v13 = v10 + 32;
          if ( v10 - 65 > 0x19 )
            v13 = v10;
          v10 = v13;
          v14 = v12 + 32;
          if ( v12 - 65 > 0x19 )
            v14 = v12;
          if ( v10 != v14 )
            break;
        }
        if ( !v10 )
          goto LABEL_21;
      }
      _EAX = 1;
      if ( v10 < v14 )
        _EAX = -1;
LABEL_22:
      __asm
      {
        vmovd   xmm1, r14d
        vmovd   xmm0, eax
        vpcmpeqd xmm2, xmm0, xmm1
        vblendvps xmm1, xmm7, xmm6, xmm2; channelvolume
      }
      SND_SetChannelVolume(v5++, *(float *)&_XMM1, 0);
    }
    __asm
    {
      vmovaps xmm6, [rsp+78h+var_38]
      vmovaps xmm7, [rsp+78h+var_48]
    }
  }
  else
  {
    Com_Printf(9, "USAGE: snd_soloChannel <string channelName>\n");
  }
}

/*
==============
SND_SpatializeVoice
==============
*/
void SND_SpatializeVoice(const SndVoice *voice, float *volumes, const vec3_t *delta, const snd_listener *listener, const float dist)
{
  __int64 v15; 
  const dvar_t *v16; 
  bool IsChannelMissionVOChannel; 
  __int64 v18; 
  const dvar_t *v19; 
  bool has71Pan; 
  int srcChannelCount; 
  int v44; 
  int v46; 
  char v51; 
  char v52; 
  __int64 includeCenterChannel; 
  float spreadMinDista; 
  float spreadMinDistb; 
  float spreadMinDist; 
  float v76; 
  float v77; 
  float v78; 
  float v79; 
  float v80; 
  float v81; 
  float v82; 
  float v83; 
  float v84; 

  _RSI = voice;
  Profile_Begin(476);
  v15 = (unsigned __int8)(_RSI->alias->flags >> 10);
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2188, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v15 >= g_snd.globals->entchannelCount )
  {
    LODWORD(includeCenterChannel) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2189, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", includeCenterChannel) )
      __debugbreak();
  }
  v16 = DCONST_DVARBOOL_snd_enable_capture_mode;
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v16);
  if ( v16->current.enabled )
    IsChannelMissionVOChannel = SND_IsChannelMissionVOChannel(v15);
  else
    IsChannelMissionVOChannel = g_snd.globals->entchannelInfo[v15].centerSpeakerPan;
  v18 = (unsigned __int8)(_RSI->alias->flags >> 10);
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2209, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v18 >= g_snd.globals->entchannelCount )
  {
    LODWORD(includeCenterChannel) = v18;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2210, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", includeCenterChannel) )
      __debugbreak();
  }
  v19 = DCONST_DVARBOOL_snd_enable_capture_mode;
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v19);
  if ( v19->current.enabled )
    has71Pan = SND_IsChannelMissionVOChannel(v18);
  else
    has71Pan = g_snd.globals->entchannelInfo[v18].has71Pan;
  __asm { vmovaps [rsp+0B8h+var_38], xmm6 }
  if ( g_snd.playback_channels < 16 )
  {
    if ( has71Pan && g_snd.playback_channels >= 8 )
    {
      _RCX = _RSI->alias;
      __asm
      {
        vmovss  xmm6, [rsp+0B8h+dist]
        vxorps  xmm0, xmm0, xmm0
        vmovaps xmm3, xmm6; dist
        vmovss  xmm1, dword ptr [rcx+0CCh]
        vcvtsi2ss xmm0, xmm0, eax
        vmovss  [rsp+0B8h+var_70], xmm0
        vmovss  xmm0, dword ptr [rcx+0C8h]
        vmovss  [rsp+0B8h+var_78], xmm1
        vmovss  xmm1, dword ptr [rcx+0C4h]
        vmovss  [rsp+0B8h+var_80], xmm0
        vmovss  [rsp+0B8h+spreadMinDist], xmm1
      }
      SND_Spatialize71(volumes, delta, listener, *(const float *)&_XMM3, _RSI->soundFileInfo.srcChannelCount, IsChannelMissionVOChannel, spreadMinDistb, v77, v80, v83);
    }
    else
    {
      _RAX = _RSI->alias;
      __asm { vmovss  xmm6, [rsp+0B8h+dist] }
      srcChannelCount = _RSI->soundFileInfo.srcChannelCount;
      __asm
      {
        vxorps  xmm3, xmm3, xmm3
        vmovss  xmm0, dword ptr [rax+0CCh]
        vmovss  xmm1, dword ptr [rax+0C8h]
        vmovss  xmm2, dword ptr [rax+0C4h]
        vcvtsi2ss xmm3, xmm3, eax
        vmovss  [rsp+0B8h+var_70], xmm3
        vmovss  [rsp+0B8h+var_78], xmm0
        vmovss  [rsp+0B8h+var_80], xmm1
        vmovss  [rsp+0B8h+spreadMinDist], xmm2
        vmovaps xmm3, xmm6; dist
      }
      if ( g_snd.playback_channels <= 2 )
      {
        IsChannelMissionVOChannel = 0;
        SND_SpatializeStereo(volumes, delta, listener, *(const float *)&_XMM3, srcChannelCount, 0, spreadMinDist, v78, v81, v84);
      }
      else
      {
        SND_Spatialize51(volumes, delta, listener, *(const float *)&_XMM3, srcChannelCount, IsChannelMissionVOChannel, spreadMinDist, v78, v81, v84);
      }
    }
  }
  else
  {
    _RCX = _RSI->alias;
    IsChannelMissionVOChannel = 1;
    __asm
    {
      vmovss  xmm6, [rsp+0B8h+dist]
      vxorps  xmm0, xmm0, xmm0
      vmovaps xmm3, xmm6; dist
      vmovss  xmm1, dword ptr [rcx+0CCh]
      vcvtsi2ss xmm0, xmm0, eax
      vmovss  [rsp+0B8h+var_70], xmm0
      vmovss  xmm0, dword ptr [rcx+0C8h]
      vmovss  [rsp+0B8h+var_78], xmm1
      vmovss  xmm1, dword ptr [rcx+0C4h]
      vmovss  [rsp+0B8h+var_80], xmm0
      vmovss  [rsp+0B8h+spreadMinDist], xmm1
    }
    SND_Spatialize7144(volumes, delta, listener, *(const float *)&_XMM3, _RSI->soundFileInfo.srcChannelCount, 1, spreadMinDista, v76, v79, v82);
  }
  v44 = 0;
  if ( _RSI->soundFileInfo.srcChannelCount > 0 )
  {
    __asm
    {
      vmovaps [rsp+0B8h+var_48], xmm7
      vmovaps [rsp+0B8h+var_58], xmm8
      vmovss  xmm8, cs:__real@3f800000
      vmovaps [rsp+0B8h+var_68], xmm9
    }
    v46 = 0;
    __asm { vxorps  xmm9, xmm9, xmm9 }
    do
    {
      _RDI = _RSI->alias;
      __asm { vmovss  xmm7, dword ptr [rsi+0FCh] }
      if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12139, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
        __debugbreak();
      _RBX = DCONST_DVARFLT_snd_omnidirectionalPercentage;
      if ( !DCONST_DVARFLT_snd_omnidirectionalPercentage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_omnidirectionalPercentage") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm3, dword ptr [rdi+0A0h]
        vcomiss xmm3, dword ptr [rbx+28h]
      }
      if ( !(v51 | v52) )
      {
        _RBX = DCONST_DVARFLT_snd_omnidirectionalPercentage;
        if ( !DCONST_DVARFLT_snd_omnidirectionalPercentage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_omnidirectionalPercentage") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm3, dword ptr [rbx+28h] }
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+98h]
        vsubss  xmm2, xmm6, xmm0
        vcomiss xmm2, xmm9
      }
      if ( v51 | v52 )
      {
        __asm { vmovss  xmm3, dword ptr [rdi+0A0h] }
      }
      else
      {
        __asm
        {
          vmovss  xmm1, dword ptr [rdi+9Ch]
          vucomiss xmm1, xmm0
        }
        if ( !v52 )
        {
          __asm
          {
            vsubss  xmm0, xmm1, xmm0
            vdivss  xmm4, xmm2, xmm0
            vcomiss xmm4, xmm8
          }
          if ( v51 )
          {
            __asm
            {
              vmovss  xmm0, dword ptr [rdi+0A0h]
              vsubss  xmm2, xmm0, xmm3
              vsubss  xmm1, xmm8, xmm4
              vmulss  xmm0, xmm2, xmm1
              vaddss  xmm3, xmm0, xmm3; omniPercentage
            }
          }
        }
      }
      _RAX = _RSI->alias;
      __asm
      {
        vmovss  dword ptr [rsp+0B8h+includeCenterChannel], xmm7
        vmovss  xmm2, dword ptr [rax+7Ch]; centerPercentage
        vmovss  xmm1, dword ptr [rax+78h]; lfePercentage
      }
      SND_ApplyVolumeCoefficientAdjustments(&volumes[v46], *(double *)&_XMM1, *(double *)&_XMM2, *(double *)&_XMM3, IsChannelMissionVOChannel);
      ++v44;
      v46 += 16;
    }
    while ( v44 < _RSI->soundFileInfo.srcChannelCount );
    __asm
    {
      vmovaps xmm9, [rsp+0B8h+var_68]
      vmovaps xmm8, [rsp+0B8h+var_58]
      vmovaps xmm7, [rsp+0B8h+var_48]
    }
  }
  __asm { vmovaps xmm6, [rsp+0B8h+var_38] }
  Profile_EndInternal(NULL);
}

/*
==============
SND_StartAlias
==============
*/
unsigned int SND_StartAlias(SndStartAliasInfo *startAliasInfo, SndAliasGroupTracking *inOutTracking, int *outVoiceIndex)
{
  const dvar_t *v8; 
  __int64 v9; 
  int v10; 
  int v11; 
  snd_entchannel_info_t *v12; 
  char v13; 
  int v14; 
  char v15; 
  const char *v16; 
  char v17; 
  char v18; 
  bool IsEntChannel3D; 
  bool v27; 
  const SndCurve *VfCurveById; 
  int flags; 
  int v40; 
  int FreeVoice; 
  float fmt; 
  __int64 v44; 
  SndVoiceParams params; 

  _RBX = startAliasInfo;
  if ( !startAliasInfo->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3801, ASSERT_TYPE_ASSERT, "(startAliasInfo->alias)", (const char *)&queryFormat, "startAliasInfo->alias") )
    __debugbreak();
  *outVoiceIndex = -1;
  v8 = DCONST_DVARBOOL_snd_enable_capture_mode;
  v9 = (unsigned __int8)(_RBX->alias->flags >> 10);
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  v10 = 0;
  if ( v8->current.enabled )
  {
    if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16435, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
      __debugbreak();
    if ( (unsigned int)v9 >= g_snd.globals->entchannelCount )
    {
      LODWORD(v44) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16436, ASSERT_TYPE_ASSERT, "( ( entChannel >= 0 && entChannel < g_snd.globals->entchannelCount ) )", "( entChannel ) = %i", v44) )
        __debugbreak();
    }
    v11 = 5381;
    v12 = &g_snd.globals->entchannelInfo[v9];
    if ( v12 && (v13 = v12->name[0]) != 0 )
    {
      v14 = 5381;
      do
      {
        v12 = (snd_entchannel_info_t *)((char *)v12 + 1);
        v15 = v13 | 0x20;
        if ( (unsigned int)(v13 - 65) >= 0x1A )
          v15 = v13;
        v14 = 65599 * v14 + v15;
        v13 = v12->name[0];
      }
      while ( v12->name[0] );
      if ( !v14 )
        v14 = 1;
    }
    else
    {
      v14 = 0;
    }
    v16 = S_QUAD_AMBIENCE_CHANNEL;
    if ( S_QUAD_AMBIENCE_CHANNEL && (v17 = *S_QUAD_AMBIENCE_CHANNEL) != 0 )
    {
      do
      {
        ++v16;
        v18 = v17 | 0x20;
        if ( (unsigned int)(v17 - 65) >= 0x1A )
          v18 = v17;
        v11 = 65599 * v11 + v18;
        v17 = *v16;
      }
      while ( *v16 );
      if ( !v11 )
        v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    if ( v14 == v11 )
      return 0;
  }
  __asm
  {
    vmovaps [rsp+108h+var_38], xmm6
    vmovaps [rsp+108h+var_48], xmm7
  }
  IsEntChannel3D = SND_IsEntChannel3D(v9);
  __asm
  {
    vmovss  xmm7, dword ptr [rbx+20h]
    vmovss  xmm6, dword ptr [rbx+1Ch]
  }
  SND_SetUpVoiceParams(&params, _RBX->alias, _RBX->sndEnt, _RBX->system);
  __asm
  {
    vmulss  xmm0, xmm6, xmm7
    vmulss  xmm1, xmm0, [rsp+108h+params.entChannelVol]
    vmulss  xmm2, xmm1, [rsp+108h+params.levelFadeInVol]
    vmulss  xmm3, xmm2, [rsp+108h+params.volModValue]
    vmulss  xmm6, xmm3, [rsp+108h+params.entityVolume]
  }
  v27 = Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80);
  __asm { vmovaps xmm7, [rsp+108h+var_48] }
  if ( !v27 )
    __asm { vmulss  xmm6, xmm6, [rsp+108h+params.scriptSoundFade] }
  __asm
  {
    vmulss  xmm0, xmm6, [rsp+108h+params.globalVolume]; val
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  dword ptr [rbx+28h], xmm0 }
  if ( IsEntChannel3D )
  {
    if ( !SND_AnyActiveListeners() )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444E7870, 148i64, _RBX->alias->aliasName);
    VfCurveById = SND_GetVfCurveById(_RBX->alias->volumeFalloffCurve);
    if ( !VfCurveById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3827, ASSERT_TYPE_ASSERT, "(vfCurve)", (const char *)&queryFormat, "vfCurve") )
      __debugbreak();
    _RAX = _RBX->alias;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+24h]
      vmovss  dword ptr [rsp+108h+fmt], xmm0
      vmovss  xmm3, dword ptr [rax+68h]; distMax
      vmovss  xmm2, dword ptr [rax+64h]; distMin
    }
    *(double *)&_XMM0 = SND_Get3DDistanceAttenuation(&_RBX->org, VfCurveById, *(float *)&_XMM2, *(float *)&_XMM3, fmt);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm
  {
    vmovss  dword ptr [rbx+2Ch], xmm6
    vmovaps xmm6, [rsp+108h+var_38]
  }
  flags = _RBX->alias->flags;
  if ( (flags & 0x380u) <= 0x100 )
  {
    if ( (flags & 0x380) == 128 )
    {
      v10 = 94;
      v40 = 5;
    }
    else if ( IsEntChannel3D )
    {
      v10 = 32;
      v40 = 48;
    }
    else
    {
      v40 = 32;
    }
  }
  else
  {
    v10 = 84;
    v40 = 10;
  }
  FreeVoice = SND_FindFreeVoice(_RBX, v9, v10, v40, inOutTracking);
  if ( FreeVoice == -1 )
    return 0;
  *outVoiceIndex = FreeVoice;
  return SND_StartAliasOnVoiceIndex(_RBX, FreeVoice);
}

/*
==============
SND_StartAliasOnVoiceIndex
==============
*/

__int64 __fastcall SND_StartAliasOnVoiceIndex(SndStartAliasInfo *startAliasInfo, int index, double _XMM2_8)
{
  __int64 v7; 
  SndVoice *v9; 
  __int64 v10; 
  const char *assetFileName; 
  __int64 result; 
  int flags; 
  unsigned __int64 v17; 
  char v18; 
  char v21; 
  unsigned int playbackIdCounter; 
  unsigned int v41; 
  __int64 v45; 
  vec3_t outOrigin; 
  __int64 v47; 
  char dest[128]; 
  char v49; 
  void *retaddr; 

  _RAX = &retaddr;
  v47 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  v7 = index;
  _RBX = startAliasInfo;
  if ( !Sys_InCriticalSection(CRITSECT_SOUND_UPDATE) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1191, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_SOUND_UPDATE ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_SOUND_UPDATE )") )
    __debugbreak();
  if ( !_RBX->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1192, ASSERT_TYPE_ASSERT, "(startAliasInfo->alias)", (const char *)&queryFormat, "startAliasInfo->alias") )
    __debugbreak();
  v9 = &g_snd.voices[v7];
  v10 = (unsigned __int8)(_RBX->alias->flags >> 10);
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2153, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( (unsigned int)v10 >= g_snd.globals->entchannelCount )
  {
    LODWORD(v45) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 2154, ASSERT_TYPE_ASSERT, "( ( entchannel >= 0 && entchannel < g_snd.globals->entchannelCount ) )", "( entchannel ) = %i", v45) )
      __debugbreak();
  }
  _RDX = 124 * v10;
  _RCX = g_snd.globals->entchannelInfo;
  __asm { vmovss  xmm7, dword ptr [rdx+rcx+78h] }
  if ( !SND_HasFreeVoice(v10) )
    goto LABEL_18;
  if ( !_RBX->assetExists )
  {
    assetFileName = "null";
    if ( _RBX->alias->assetFileName )
      assetFileName = _RBX->alias->assetFileName;
    Core_strcpy(dest, 0x80ui64, assetFileName);
    Com_PrintError(1, "Tried to play streamed sound '%s' from alias '%s', but it was not found at load time.\n", dest, _RBX->alias->aliasName);
    goto LABEL_18;
  }
  SND_DebugAliasPrint(v9->alias != NULL, v9->alias, "Stop voice requested by SND_StartAliasOnVoiceIndex()");
  SND_StopVoice(v7);
  SND_SetVoiceStartInfo(v7, _RBX);
  SND_AddVoice(v10);
  flags = _RBX->alias->flags;
  v17 = 65 * v7;
  if ( (flags & 0x300000) == 0x200000 )
  {
    sdGlob.voiceParams[v17 / 0x41].bus = SND_BUS_LICENCED;
  }
  else if ( (flags & 0x300000) == 0x100000 )
  {
    sdGlob.voiceParams[v17 / 0x41].bus = SND_BUS_MUSIC;
  }
  else
  {
    sdGlob.voiceParams[v17 / 0x41].bus = SND_GetEntChannelSubmixBus((unsigned __int8)(flags >> 10));
  }
  sdGlob.currentReverbId[v17 - 6434] = SND_GetEntChannelSendFlag((unsigned __int8)(_RBX->alias->flags >> 10));
  sdGlob.currentReverbId[v17 - 6433] = 1065353216;
  SND_InitEQBankParams((SndEQBankParams *)&sdGlob.currentReverbId[v17 - 6393]);
  sdGlob.currentReverbId[v17 - 6372] = -1082130432;
  sdGlob.currentReverbId[v17 - 6371] = -1082130432;
  v18 = 0;
  if ( (_RBX->alias->flags & 2) != 0 )
  {
    *(double *)&_XMM0 = I_random();
    __asm { vmovss  dword ptr [rbx+40h], xmm0 }
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm6, dword ptr [rbx+40h]
  }
  if ( !v18 )
    goto LABEL_32;
  SND_GetSoundFileLengthMS(_RBX->assetEntry);
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+40h]
    vucomiss xmm1, xmm6
  }
  if ( v21 )
  {
    _EBP = _RBX->timeshift;
    if ( _EBP )
      goto LABEL_33;
    if ( (_RBX->alias->flags & 2) != 0 )
    {
      *(double *)&_XMM0 = I_random();
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, edi
        vmulss  xmm0, xmm0, xmm1
        vaddss  xmm3, xmm0, cs:__real@3f000000
        vxorps  xmm2, xmm2, xmm2
        vmovss  xmm1, xmm2, xmm3
        vxorps  xmm0, xmm0, xmm0
        vroundss xmm1, xmm0, xmm1, 1
        vcvttss2si ebp, xmm1
      }
      _EBP = _EBP & 0xFFFFFF00;
      goto LABEL_33;
    }
LABEL_32:
    _EBP = 0;
    goto LABEL_33;
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vmulss  xmm1, xmm0, xmm1
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm1, xmm0, xmm3, 1
    vcvttss2si ebp, xmm1
  }
LABEL_33:
  if ( !_RBX->preDelayed && SND_IsEntChannel3D(v10) )
  {
    __asm { vcomiss xmm7, xmm6 }
    SndVoice_GetOrigin(&g_snd.voices[v7], &outOrigin);
    *(double *)&_XMM0 = SND_DistSqToNearestListener(&outOrigin);
    __asm
    {
      vsqrtss xmm1, xmm0, xmm0
      vmulss  xmm2, xmm1, xmm7
      vmulss  xmm3, xmm2, cs:__real@428ae38e
      vcvttss2si eax, xmm3
    }
    _RBX->startDelayUs += _EAX;
    memset(&outOrigin, 0, sizeof(outOrigin));
  }
  sdGlob.voiceAlloc[v7] = 1;
  if ( SD_StartAlias(_RBX, v7, _EBP) )
  {
    if ( v9->soundFileInfo.loadingState == SFLS_UNLOADED )
    {
LABEL_18:
      result = 0i64;
      goto LABEL_57;
    }
    if ( (unsigned int)v7 > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3068, ASSERT_TYPE_ASSERT, "(index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "index >= 0 && index < SND_MAX_VOICES") )
      __debugbreak();
    if ( v9->soundFileInfo.loadingState == SFLS_UNLOADED && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3072, ASSERT_TYPE_ASSERT, "(voice->soundFileInfo.loadingState != SFLS_UNLOADED)", (const char *)&queryFormat, "voice->soundFileInfo.loadingState != SFLS_UNLOADED") )
      __debugbreak();
    if ( !v9->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3073, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
      __debugbreak();
    playbackIdCounter = g_snd.playbackIdCounter;
    if ( g_snd.playbackIdCounter > 0x7FFFFFFF )
      playbackIdCounter = 1;
    g_snd.playbackIdCounter = playbackIdCounter;
    v41 = playbackIdCounter;
    if ( (v9->alias->flags & 1) != 0 )
      v41 = playbackIdCounter | 0x80000000;
    g_snd.playbackIdCounter = playbackIdCounter + 1;
    v9->playbackId = v41;
    SND_SetUpVoiceParams(&v9->params, v9->alias, v9->sndEnt, v9->system);
    result = v41;
  }
  else
  {
    if ( (unsigned int)v7 > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3056, ASSERT_TYPE_ASSERT, "(index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "index >= 0 && index < SND_MAX_VOICES") )
      __debugbreak();
    g_snd.chaninfoUnweightedPriority[492 * v7 - 48701] = 0.0;
    result = 0i64;
  }
LABEL_57:
  _R11 = &v49;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
SND_StartBackground
==============
*/

__int64 __fastcall SND_StartBackground(LocalClientNum_t localClientNum, int track, const SndAlias *alias, double startVolumeScale, int fadetime, float fraction, snd_alias_system_t system, int secondaryGroupId)
{
  bool v19; 
  bool v20; 
  bool v21; 
  const char *assetFileName; 
  __int64 result; 
  const char *v27; 
  int v44; 
  const SndAlias *v46; 
  unsigned int started; 
  int startDelayMax; 
  int startDelay; 
  __int64 v66; 
  double v67; 
  int v68; 
  ScopedCriticalSection v69; 
  SndStartAliasInfo info; 
  char dest[128]; 
  char v72; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmm10, xmm3
  }
  _RBX = alias;
  if ( !Sys_InCriticalSection(CRITSECT_SOUND_UPDATE) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6128, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_SOUND_UPDATE ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_SOUND_UPDATE )") )
    __debugbreak();
  v19 = (unsigned int)track < 3;
  v20 = (unsigned int)track <= 3;
  if ( (unsigned int)track > 3 )
  {
    LODWORD(v66) = track;
    v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6129, ASSERT_TYPE_ASSERT, "( ( track >= 0 && track < SND_TRACK_COUNT ) )", "( track ) = %i", v66);
    v19 = 0;
    v20 = !v21;
    if ( v21 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vmovss  xmm8, cs:__real@3f800000
    vmovss  xmm9, [rbp+110h+fraction]
    vcomiss xmm9, xmm7
  }
  if ( v19 )
    goto LABEL_46;
  __asm { vcomiss xmm9, xmm8 }
  if ( !v20 )
  {
LABEL_46:
    __asm
    {
      vcvtss2sd xmm0, xmm9, xmm9
      vmovsd  [rsp+210h+var_1E8], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6130, ASSERT_TYPE_ASSERT, "( ( fraction >= 0 && fraction <= 1 ) )", "( fraction ) = %g", v67) )
      __debugbreak();
  }
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6131, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
    __debugbreak();
  __asm { vcomiss xmm10, xmm7 }
  if ( fadetime < 0 )
  {
    LODWORD(v66) = fadetime;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6133, ASSERT_TYPE_ASSERT, "( ( fadetime >= 0 ) )", "( fadetime ) = %i", v66) )
      __debugbreak();
  }
  if ( SND_IsEntChannel3D((unsigned __int8)(_RBX->flags >> 10)) )
  {
    assetFileName = "null";
    if ( _RBX->assetFileName )
      assetFileName = _RBX->assetFileName;
    Core_strcpy(dest, 0x80ui64, assetFileName);
    Com_PrintError(9, "Alias: %s Sound: %s played as an ambient track uses a 3D channel type\n", _RBX->aliasName, dest);
    result = 0i64;
  }
  else if ( (_RBX->flags & 0x380u) > 0x100 )
  {
    __asm { vmovss  xmm6, dword ptr [rbx+4Ch] }
    *(double *)&_XMM0 = I_random();
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+50h]
      vsubss  xmm2, xmm1, xmm6
      vmulss  xmm0, xmm0, xmm2
      vaddss  xmm0, xmm0, xmm6; val
      vmovss  xmm2, cs:__real@40800000; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovaps xmm11, xmm0
      vmovss  xmm6, dword ptr [rbx+58h]
    }
    *(double *)&_XMM0 = I_random();
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+5Ch]
      vsubss  xmm2, xmm1, xmm6
      vmulss  xmm3, xmm0, xmm2
      vaddss  xmm0, xmm3, xmm6; val
      vmovss  xmm2, cs:__real@40000000; max
      vmovss  xmm1, cs:__real@3a83126f; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm6, xmm0 }
    v44 = track + 80;
    if ( (unsigned int)(v44 - 80) > 0xD )
    {
      LODWORD(v66) = v44;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6153, ASSERT_TYPE_ASSERT, "( ( voiceIndex >= ((0 + 32) + 48) && voiceIndex < ((0 + 32) + 48) + ( SND_TRACK_COUNT + 10 ) ) )", "( voiceIndex ) = %i", v66) )
        __debugbreak();
    }
    ScopedCriticalSection::ScopedCriticalSection(&v69, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
    _R12 = &g_snd;
    if ( !SND_IsVoiceFree(v44) )
    {
      v46 = g_snd.voices[v44].alias;
      SND_DebugAliasPrint(v46 != NULL, v46, "Stop voice requested by SND_StartBackground()");
      SND_StopVoice(v44);
    }
    started = 0;
    if ( _RBX->assetId )
    {
      _R14 = v44;
      __asm
      {
        vmovss  dword ptr [r14+r12+0CA84h], xmm6
        vmovss  dword ptr [rsp+210h+var_1E0], xmm6
      }
      if ( (v68 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6169, ASSERT_TYPE_SANITY, "( !IS_NAN( pitch ) )", (const char *)&queryFormat, "!IS_NAN( pitch )") )
        __debugbreak();
      __asm { vmovaps xmm1, xmm6; initValue }
      SND_InitParameter(&g_snd.voices[_R14].pitchInfo, *(float *)&_XMM1);
      __asm { vmovss  dword ptr [r14+r12+0CA58h], xmm11 }
      g_snd.voices[_R14].occlusionAmount = 0.0;
      g_snd.voices[_R14].occlusionWaitId = 0;
      info.alias = _RBX;
      info.sndEnt = 2048i64;
      __asm
      {
        vmovss  dword ptr [rsp+210h+info.org], xmm7
        vmovss  dword ptr [rsp+210h+info.org+4], xmm7
        vmovss  dword ptr [rsp+210h+info.org+8], xmm7
        vmovss  [rsp+210h+info.volume], xmm11
        vmovss  [rsp+210h+info.volumeScale], xmm8
        vmovaps xmm2, xmm8; max
        vxorps  xmm1, xmm1, xmm1; min
        vmovaps xmm0, xmm11; val
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovss  [rsp+210h+info.priorityVolume], xmm0
        vmovss  [rsp+210h+info.priorityAttenuation], xmm8
        vmovss  [rbp+110h+info.contextLerpVolume], xmm8
        vmovss  [rbp+110h+info.pitch], xmm6
        vmovss  [rbp+110h+info.pitchScale], xmm8
      }
      info.timeshift = 0;
      __asm { vmovss  [rbp+110h+info.fraction], xmm9 }
      startDelayMax = _RBX->startDelayMax;
      startDelay = _RBX->startDelay;
      if ( startDelayMax > startDelay )
        startDelay = I_irand(startDelay, startDelayMax);
      info.startDelayUs = 1000 * startDelay;
      info.system = system;
      info.adsrIndex = -1;
      info.fadeTime = 0;
      info.autoSimId = -1;
      info.autoSimTimeStamp = 0i64;
      info.autoSimShotCount = SND_WEAP_SHOT_FIRST;
      __asm
      {
        vmovss  [rbp+110h+info.lfeScale], xmm8
        vmovss  xmm0, cs:__real@bf800000
        vmovss  [rbp+110h+info.lpfCutoff], xmm0
        vmovss  [rbp+110h+info.hpfCutoff], xmm0
      }
      info.secondaryGroupId = secondaryGroupId;
      info.preDelayed = 0;
      if ( SND_FindAssetsForVoice(&info) )
      {
        started = SND_StartAliasOnVoiceIndex(&info, v44);
        if ( started )
        {
          __asm
          {
            vmovaps xmm3, xmm8; max
            vxorps  xmm2, xmm2, xmm2; min
            vmovaps xmm1, xmm10; value
          }
          SND_SetParamValue(&g_snd.voices[_R14].volumeInfo, *(double *)&_XMM1, *(double *)&_XMM2, *(double *)&_XMM3, fadetime);
        }
        SND_DebugAliasPrint(started != 0, _RBX, "Started");
      }
      else if ( ++snd_errorLimit < 1000 )
      {
        Com_PrintError(9, "Background alias %s's sound data was not yet loaded when played.\n", info.alias->aliasName);
      }
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v69);
    result = started;
  }
  else
  {
    v27 = "null";
    if ( _RBX->assetFileName )
      v27 = _RBX->assetFileName;
    Core_strcpy(dest, 0x80ui64, v27);
    Com_PrintError(9, "Alias %s Sound %s played as an ambient track is not streamed\n", _RBX->aliasName, dest);
    result = 0i64;
  }
  _R11 = &v72;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
  return result;
}

/*
==============
SND_StartBulletEvent
==============
*/
void SND_StartBulletEvent(int id)
{
  __int64 v1; 
  int v3; 

  v1 = id;
  if ( (unsigned int)id >= 0x40 )
  {
    v3 = 64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 7639, ASSERT_TYPE_ASSERT, "(unsigned)( id ) < (unsigned)( ( sizeof( *array_counter( g_snd.delayedBulletEvents ) ) + 0 ) )", "id doesn't index ARRAY_COUNT( g_snd.delayedBulletEvents )\n\t%i not in [0, %i)", id, v3) )
      __debugbreak();
  }
  if ( (int)v1 >= 0 && (unsigned int)v1 < 0x40 )
    *(_DWORD *)g_snd.delayedBulletEvents[v1].state = 1;
}

/*
==============
SND_Stop3DSounds
==============
*/
void SND_Stop3DSounds()
{
  int v0; 
  bool *voiceAlloc; 
  const SndAlias **p_alias; 
  __int64 v3; 

  v0 = 0;
  voiceAlloc = sdGlob.voiceAlloc;
  p_alias = &g_snd.voices[0].alias;
  do
  {
    if ( (unsigned int)v0 > 0x62 )
    {
      LODWORD(v3) = v0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v3) )
        __debugbreak();
    }
    if ( *voiceAlloc && SND_IsEntChannel3D((unsigned __int8)((*p_alias)->flags >> 10)) )
    {
      SND_DebugAliasPrint(*p_alias != NULL, *p_alias, "Stop voice requested by SND_Stop3DSounds()");
      SND_StopVoice(v0);
    }
    ++v0;
    ++voiceAlloc;
    p_alias += 246;
  }
  while ( v0 < 99 );
}

/*
==============
SND_StopAmbient
==============
*/
void SND_StopAmbient(int fadetime)
{
  if ( g_snd.driverInitialized )
  {
    if ( fadetime < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6709, ASSERT_TYPE_ASSERT, "( ( fadetime >= 0 ) )", "( fadetime ) = %i", fadetime) )
      __debugbreak();
    SND_StopBackground(0, fadetime);
    SND_StopBackground(1, fadetime);
    SND_StopBackground(2, fadetime);
    SND_StopBackground(3, fadetime);
  }
}

/*
==============
SND_StopAmbientAlias
==============
*/
void SND_StopAmbientAlias(const char *aliasName, int fadeTime)
{
  int v4; 
  bool v5; 
  int v6; 
  __int64 v7; 
  __int64 v8; 
  ScopedCriticalSection v9; 

  if ( !aliasName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6720, ASSERT_TYPE_ASSERT, "(aliasName != 0)", (const char *)&queryFormat, "aliasName != NULL") )
    __debugbreak();
  if ( fadeTime < 0 )
  {
    LODWORD(v7) = fadeTime;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6721, ASSERT_TYPE_ASSERT, "( ( fadeTime >= 0 ) )", "( fadeTime ) = %i", v7) )
      __debugbreak();
  }
  ScopedCriticalSection::ScopedCriticalSection(&v9, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  v4 = 0;
  v5 = 1;
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v8) = 2;
      LODWORD(v7) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6249, ASSERT_TYPE_ASSERT, "(unsigned)( number ) < (unsigned)( 2 )", "number doesn't index SND_NUM_AMBIENT_TRACKS\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    if ( SND_IsAliasPlayingOnTrack(aliasName, v4 != 0 ? 2 : 0) )
      break;
    v5 = (unsigned int)++v4 < 2;
    if ( v4 >= 2 )
      goto LABEL_23;
  }
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v7) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6249, ASSERT_TYPE_ASSERT, "(unsigned)( number ) < (unsigned)( 2 )", "number doesn't index SND_NUM_AMBIENT_TRACKS\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  SND_StopBackground(v4 != 0 ? 2 : 0, fadeTime);
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v7) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6249, ASSERT_TYPE_ASSERT, "(unsigned)( number ) < (unsigned)( 2 )", "number doesn't index SND_NUM_AMBIENT_TRACKS\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  v6 = 1;
  if ( v4 )
    v6 = 3;
  SND_StopBackground(v6, fadeTime);
LABEL_23:
  ScopedCriticalSection::~ScopedCriticalSection(&v9);
}

/*
==============
SND_StopAutoSim
==============
*/
void SND_StopAutoSim(int autoSimId)
{
  unsigned int v2; 
  bool *voiceAlloc; 
  unsigned int v4; 
  const SndAlias **p_alias; 
  int *p_autoSimId; 

  if ( autoSimId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15255, ASSERT_TYPE_ASSERT, "(autoSimId != -1)", (const char *)&queryFormat, "autoSimId != INVALID_AUTOSIM_ID") )
    __debugbreak();
  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  v2 = 0;
  voiceAlloc = sdGlob.voiceAlloc;
  v4 = 0;
  p_alias = &g_snd.voices[0].alias;
  do
  {
    if ( *voiceAlloc && *((_DWORD *)p_alias + 30) == autoSimId )
    {
      SND_DebugAliasPrint(*p_alias != NULL, *p_alias, "Stop voice requested by SND_StopAutoSim()");
      SND_StopVoice(v4);
    }
    ++v4;
    ++voiceAlloc;
    p_alias += 246;
  }
  while ( v4 < 0x63 );
  p_autoSimId = &g_sd.voicePool[0].autoSimId;
  do
  {
    if ( *p_autoSimId == autoSimId )
      SD_StopHeldAutoSimVoice(v2);
    ++v2;
    p_autoSimId += 266;
  }
  while ( v2 < 0xC6 );
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
}

/*
==============
SND_StopBackground
==============
*/

void __fastcall SND_StopBackground(int track, int fadetime, double _XMM2_8)
{
  __int64 v5; 
  unsigned __int64 v6; 
  __int64 v11; 
  ScopedCriticalSection v13; 

  v5 = track;
  if ( (unsigned int)track > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6225, ASSERT_TYPE_ASSERT, "( ( track >= 0 && track < SND_TRACK_COUNT ) )", "( track ) = %i", track) )
    __debugbreak();
  if ( fadetime < 0 )
  {
    LODWORD(v11) = fadetime;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6226, ASSERT_TYPE_ASSERT, "( ( fadetime >= 0 ) )", "( fadetime ) = %i", v11) )
      __debugbreak();
  }
  ScopedCriticalSection::ScopedCriticalSection(&v13, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  if ( (unsigned int)(v5 + 80) > 0x62 )
  {
    LODWORD(v11) = v5 + 80;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v11) )
      __debugbreak();
  }
  v6 = v5 + 80;
  if ( sdGlob.voiceAlloc[v5 + 80] )
  {
    if ( fadetime <= 0 )
      goto LABEL_14;
    _RCX = (snd_param_info_t *)&g_snd.chaninfoUnweightedPriority[492 * v6 - 48694];
    __asm
    {
      vxorps  xmm1, xmm1, xmm1; value
      vcomiss xmm1, dword ptr [rcx]
    }
    if ( is_mul_ok(0x7B0ui64, v6) )
    {
LABEL_14:
      SND_DebugAliasPrint(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v6 - 48680] != 0i64, *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[492 * v6 - 48680], "Stop voice requested by SND_StopBackground()");
      SND_StopVoice(v5 + 80);
    }
    else
    {
      __asm
      {
        vmovss  xmm3, cs:__real@3f800000; max
        vxorps  xmm2, xmm2, xmm2; min
      }
      SND_SetParamValue(_RCX, *(double *)&_XMM1, *(double *)&_XMM2, *(double *)&_XMM3, fadetime);
    }
  }
  ScopedCriticalSection::~ScopedCriticalSection(&v13);
}

/*
==============
SND_StopMusicState
==============
*/

void __fastcall SND_StopMusicState(unsigned int stateId)
{
  SNDL_StopMusicState(stateId);
}

/*
==============
SND_StopMusicState
==============
*/
void SND_StopMusicState(const char *stateName)
{
  const char *v1; 
  char v2; 
  unsigned int v3; 
  char v4; 

  v1 = stateName;
  if ( stateName && (v2 = *stateName) != 0 )
  {
    v3 = 5381;
    do
    {
      ++v1;
      v4 = v2 | 0x20;
      if ( (unsigned int)(v2 - 65) >= 0x1A )
        v4 = v2;
      v3 = 65599 * v3 + v4;
      v2 = *v1;
    }
    while ( *v1 );
    if ( !v3 )
      v3 = 1;
  }
  else
  {
    v3 = 0;
    if ( stateName && *stateName )
      Com_PrintError(9, "SOUND: Unknown music state '%s' %x\n", stateName, 0i64);
  }
  SNDL_StopMusicState(v3);
}

/*
==============
SND_StopMusicState
==============
*/

void __fastcall SND_StopMusicState(const unsigned int *stateIdArray, unsigned int arrayCount)
{
  SNDL_StopMusicState(stateIdArray, arrayCount);
}

/*
==============
SND_StopSoundAliasAndSecondariesByAliasId
==============
*/
__int64 SND_StopSoundAliasAndSecondariesByAliasId(unsigned int aliasId, LocalClientNum_t localClientNum, int entnum)
{
  unsigned __int64 SndEntHandle; 
  int v5; 
  int v6; 
  __int64 v7; 
  const SndAlias **p_alias; 
  const SndAlias *v9; 
  unsigned __int8 v10; 
  sd_voice **voices; 
  sd_voice *v13; 
  unsigned int secondaryGroupId; 
  __int64 v15; 
  ScopedCriticalSection v16; 

  SndEntHandle = CG_GenerateSndEntHandle(localClientNum, entnum);
  ScopedCriticalSection::ScopedCriticalSection(&v16, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  v5 = 0;
  v6 = 0;
  v7 = 0i64;
  p_alias = &g_snd.voices[0].alias;
  while ( 1 )
  {
    if ( (unsigned int)v6 > 0x62 )
    {
      LODWORD(v15) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v15) )
        __debugbreak();
    }
    if ( sdGlob.voiceAlloc[v7] && *(p_alias - 12) == (const SndAlias *)SndEntHandle )
    {
      v9 = *p_alias;
      if ( (*p_alias)->id == aliasId )
        break;
    }
    ++v6;
    ++v7;
    p_alias += 246;
    if ( v6 >= 99 )
    {
      v10 = 0;
      goto LABEL_10;
    }
  }
  voices = g_sd.voices;
  v13 = g_sd.voices[v6];
  if ( v13 && (secondaryGroupId = v13->secondaryGroupId) != 0 )
  {
    do
    {
      if ( *voices && (*voices)->secondaryGroupId == secondaryGroupId )
      {
        SND_DebugAliasPrint(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v7 - 48680] != 0i64, *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[492 * v7 - 48680], "Stop voice requested by SND_StopSoundAliasAndSecondariesByAliasId()");
        SND_StopVoice(v5);
      }
      ++v5;
      ++voices;
    }
    while ( v5 < 99 );
    v10 = 1;
  }
  else
  {
    SND_DebugAliasPrint(v9 != NULL, v9, "Stop voice requested by SND_StopSoundAliasAndSecondariesByAliasId()");
    SND_StopVoice(v6);
    v10 = 1;
  }
LABEL_10:
  ScopedCriticalSection::~ScopedCriticalSection(&v16);
  return v10;
}

/*
==============
SND_StopSoundAliasById
==============
*/
bool SND_StopSoundAliasById(unsigned int id)
{
  int v3; 
  int v4; 
  __int64 v5; 
  unsigned int *p_playbackId; 
  sd_voice **voices; 
  sd_voice *v8; 
  unsigned int secondaryGroupId; 
  const SndAlias *alias; 
  ScopedCriticalSection v11; 

  if ( !id )
    return 0;
  ScopedCriticalSection::ScopedCriticalSection(&v11, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  v3 = 0;
  v4 = 0;
  v5 = 0i64;
  p_playbackId = &g_snd.voices[0].playbackId;
  while ( *p_playbackId != id )
  {
    ++v4;
    ++v5;
    p_playbackId += 492;
    if ( (__int64)p_playbackId >= (__int64)&g_snd.chaninfoUnweightedPriority[7] )
      goto LABEL_16;
  }
  voices = g_sd.voices;
  v8 = g_sd.voices[v4];
  if ( v8 && (secondaryGroupId = v8->secondaryGroupId) != 0 )
  {
    do
    {
      if ( *voices )
      {
        if ( (*voices)->secondaryGroupId == secondaryGroupId )
        {
          SND_DebugAliasPrint(g_snd.voices[v5].alias != NULL, g_snd.voices[v5].alias, "Stop voice requested by SND_StopSoundAliasById()");
          SND_StopVoice(v3);
        }
      }
      ++v3;
      ++voices;
    }
    while ( v3 < 99 );
  }
  else
  {
    alias = g_snd.voices[v4].alias;
    SND_DebugAliasPrint(alias != NULL, alias, "Stop voice requested by SND_StopSoundAliasById()");
    SND_StopVoice(v4);
  }
  LOBYTE(v3) = 1;
LABEL_16:
  ScopedCriticalSection::~ScopedCriticalSection(&v11);
  return v3;
}

/*
==============
SND_StopSoundAliasOnEnt
==============
*/
void SND_StopSoundAliasOnEnt(unsigned __int64 sndEnt, const char *aliasName)
{
  SND_StopSoundsInternal(sndEnt, aliasName, 0xFFFFFFFF);
}

/*
==============
SND_StopSoundChannelOnEnt
==============
*/
void SND_StopSoundChannelOnEnt(unsigned __int64 sndEnt, unsigned int channelNum)
{
  __int64 v4; 

  if ( channelNum == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4887, ASSERT_TYPE_ASSERT, "(channelNum != (0xFFFFFFFF))", (const char *)&queryFormat, "channelNum != SND_ENTCHANNEL_NONE") )
    __debugbreak();
  if ( !g_snd.globals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4888, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
    __debugbreak();
  if ( channelNum >= g_snd.globals->entchannelCount )
  {
    LODWORD(v4) = channelNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4889, ASSERT_TYPE_ASSERT, "(unsigned)( channelNum ) < (unsigned)( g_snd.globals->entchannelCount )", "channelNum doesn't index g_snd.globals->entchannelCount\n\t%i not in [0, %i)", v4, g_snd.globals->entchannelCount) )
      __debugbreak();
  }
  SND_StopSoundsInternal(sndEnt, NULL, channelNum);
}

/*
==============
SND_StopSounds
==============
*/
void SND_StopSounds(snd_stopsounds_arg_t which)
{
  char v1; 
  __int64 i; 
  SndVirtualLoop *virtualLoops; 
  int v4; 
  bool *voiceAlloc; 
  const SndAlias **p_alias; 
  int j; 
  int k; 
  int m; 
  int n; 
  __int64 v11; 

  v1 = which;
  if ( !g_snd.driverInitialized )
    return;
  for ( i = 0i64; Sys_InCriticalSection(CRITSECT_SOUND_UPDATE); i = (unsigned int)(i + 1) )
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  Sys_WaitWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK);
  if ( (int)i > 0 )
  {
    do
    {
      Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
      --i;
    }
    while ( i );
  }
  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "wait_workers");
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
  Sys_ProfEndNamedEvent();
  g_snd.nextVirtualLoopHandle = 0;
  virtualLoops = g_snd.virtualLoops;
  do
  {
    virtualLoops->handle = -1;
    ++virtualLoops;
  }
  while ( (__int64)virtualLoops < (__int64)&g_snd.nextVirtualLoopHandle );
  SND_DeferredPlaybackInit();
  v4 = 0;
  voiceAlloc = sdGlob.voiceAlloc;
  p_alias = &g_snd.voices[0].alias;
  do
  {
    if ( (unsigned int)v4 > 0x62 )
    {
      LODWORD(v11) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v11) )
        __debugbreak();
    }
    if ( *voiceAlloc )
    {
      if ( (unsigned int)(v4 - 80) > 0xD )
      {
        if ( (v1 & 8) != 0 )
          goto LABEL_21;
LABEL_20:
        SND_DebugAliasPrint(*p_alias != NULL, *p_alias, "Stop voice requested by SND_StopSounds()");
        SND_StopVoice(v4);
        goto LABEL_21;
      }
      if ( ((v1 & 2) == 0 || (unsigned int)(SND_GetEntChannelSubmixBus((unsigned __int8)((*p_alias)->flags >> 10)) - 12) > 1) && ((v1 & 4) == 0 || (unsigned int)(v4 - 80) > 3) )
        goto LABEL_20;
    }
LABEL_21:
    ++v4;
    ++voiceAlloc;
    p_alias += 246;
  }
  while ( v4 < 99 );
  if ( (v1 & 1) == 0 )
    SND_ClearReverbs();
  if ( (v1 & 0x10) == 0 )
  {
    for ( j = 1; j < 4; ++j )
      SND_DeactivateChannelVolumes(j, 0);
  }
  for ( k = 0; k < 256; ++k )
  {
    for ( m = 0; m < 2; ++m )
    {
      for ( n = 0; n < 2; ++n )
        SND_DisableEq(k, m, n);
    }
  }
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
}

/*
==============
SND_StopSoundsInternal
==============
*/
void SND_StopSoundsInternal(unsigned __int64 sndEnt, const char *aliasName, const unsigned int entChannel)
{
  int v6; 
  bool *voiceAlloc; 
  const char ***p_alias; 
  unsigned int *i; 
  const char **v10; 
  int v11; 
  const char *v12; 
  const SndAlias *v13; 
  bool v14; 
  __int64 v15; 

  if ( g_snd.driverInitialized )
  {
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    v6 = 0;
    voiceAlloc = sdGlob.voiceAlloc;
    p_alias = (const char ***)&g_snd.voices[0].alias;
    for ( i = g_snd.chaninfoEntchannel; ; ++i )
    {
      if ( *(p_alias - 12) != (const char **)sndEnt || entChannel != -1 && *i != entChannel )
        goto LABEL_16;
      if ( (unsigned int)v6 > 0x62 )
      {
        LODWORD(v15) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v15) )
          __debugbreak();
      }
      if ( !*voiceAlloc )
        goto LABEL_16;
      if ( aliasName )
      {
        if ( !*p_alias || I_stricmp(**p_alias, aliasName) )
          goto LABEL_16;
        v10 = *p_alias;
        v11 = I_stricmp(**p_alias, aliasName);
        v12 = "stopped on entity by name";
        v13 = (const SndAlias *)v10;
        v14 = v11 == 0;
      }
      else
      {
        v13 = (const SndAlias *)*p_alias;
        v12 = "stopped all on entity";
        v14 = *p_alias != NULL;
      }
      SND_DebugAliasPrint(v14, v13, v12);
      SND_StopVoice(v6);
LABEL_16:
      ++v6;
      p_alias += 246;
      ++voiceAlloc;
      if ( v6 >= 99 )
      {
        Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
        return;
      }
    }
  }
}

/*
==============
SND_StopSoundsOnEnt
==============
*/
void SND_StopSoundsOnEnt(unsigned __int64 sndEnt)
{
  int v2; 
  bool *voiceAlloc; 
  const SndAlias **p_alias; 
  __int64 v5; 

  if ( g_snd.driverInitialized )
  {
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    v2 = 0;
    voiceAlloc = sdGlob.voiceAlloc;
    p_alias = &g_snd.voices[0].alias;
    do
    {
      if ( *(p_alias - 12) == (const SndAlias *)sndEnt )
      {
        if ( (unsigned int)v2 > 0x62 )
        {
          LODWORD(v5) = v2;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v5) )
            __debugbreak();
        }
        if ( *voiceAlloc )
        {
          SND_DebugAliasPrint(*p_alias != NULL, *p_alias, "stopped all on entity");
          SND_StopVoice(v2);
        }
      }
      ++v2;
      p_alias += 246;
      ++voiceAlloc;
    }
    while ( v2 < 99 );
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  }
}

/*
==============
SND_StopVirtualLoopSound
==============
*/
void SND_StopVirtualLoopSound(int handle)
{
  int v2; 
  SndVirtualLoop *virtualLoops; 
  ScopedCriticalSection v4; 

  ScopedCriticalSection::ScopedCriticalSection(&v4, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  v2 = 0;
  virtualLoops = g_snd.virtualLoops;
  while ( virtualLoops->handle != handle )
  {
    ++v2;
    if ( (__int64)++virtualLoops >= (__int64)&g_snd.nextVirtualLoopHandle )
    {
      ScopedCriticalSection::~ScopedCriticalSection(&v4);
      return;
    }
  }
  g_snd.virtualLoops[v2].handle = -1;
  ScopedCriticalSection::~ScopedCriticalSection(&v4);
}

/*
==============
SND_StopVoice
==============
*/
void SND_StopVoice(int index)
{
  __int64 v1; 
  volatile signed __int32 *v2; 

  v1 = index;
  v2 = &g_snd.voiceBusyUpdating[index];
  do
  {
    if ( ((unsigned __int8)v2 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.voiceBusyUpdating[v1]) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(v2, 1, 0) == 1 );
  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  SND_StopVoiceWithoutLock(v1);
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
  if ( ((unsigned __int8)v2 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 93, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.voiceBusyUpdating[v1]) )
    __debugbreak();
  _InterlockedExchange(v2, 0);
}

/*
==============
SND_StopVoiceAndClearTracking
==============
*/
void SND_StopVoiceAndClearTracking(int index, SndAliasGroupTracking *inOutTracking)
{
  __int64 v2; 
  int v3; 
  int numVoices; 
  int *voiceIndices; 

  v2 = index;
  v3 = 0;
  numVoices = inOutTracking->numVoices;
  if ( numVoices > 0 )
  {
    voiceIndices = inOutTracking->voiceIndices;
    while ( *voiceIndices != (_DWORD)v2 )
    {
      ++v3;
      ++voiceIndices;
      if ( v3 >= numVoices )
        goto LABEL_7;
    }
    SND_DebugAliasPrint(1, *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[492 * v2 - 48680], "stopped a secondary alias that was part of our tracked group");
    inOutTracking->voiceIndices[v3] = *(&inOutTracking->secondaryGroupId + inOutTracking->numVoices);
    inOutTracking->voicePlaybackIds[v3] = inOutTracking->voiceIndices[inOutTracking->numVoices-- + 19];
  }
LABEL_7:
  SND_StopVoice(v2);
}

/*
==============
SND_StopVoiceById
==============
*/
void SND_StopVoiceById(unsigned int id)
{
  int VoiceIndexForId; 
  int v3; 

  Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
  VoiceIndexForId = SND_GetVoiceIndexForId(id);
  v3 = VoiceIndexForId;
  if ( VoiceIndexForId != -1 )
  {
    SND_DebugAliasPrint(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * VoiceIndexForId - 48680] != 0i64, *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[492 * VoiceIndexForId - 48680], "Stop voice requested by SND_StopVoiceById()");
    SND_StopVoice(v3);
  }
  Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
}

/*
==============
SND_StopVoiceWithoutLock
==============
*/
void SND_StopVoiceWithoutLock(int index)
{
  __int64 v1; 
  SndVoice *v2; 
  __int64 v3; 

  v1 = index;
  if ( !Sys_InCriticalSection(CRITSECT_SOUND_UPDATE) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1068, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_SOUND_UPDATE ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_SOUND_UPDATE )") )
    __debugbreak();
  if ( (unsigned int)v1 > 0x62 )
  {
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v3) )
      __debugbreak();
  }
  if ( sdGlob.voiceAlloc[v1] )
  {
    v2 = &g_snd.voices[v1];
    if ( v2->alias )
    {
      v2->occlusionWaitId = 0;
      if ( v2->soundDoneSoundString )
      {
        if ( !v2->alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 3373, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
          __debugbreak();
        SND_QueueSoundDoneNotify(v2->sndEnt & 0x1FFFFFFFFi64, v2->soundDoneSoundString);
      }
      SND_SubmixStopFromVoice(&g_snd.voices[v1]);
      v2->paused = 0;
      v2->soundFileInfo.loadingState = SFLS_UNLOADED;
      v2->alias = NULL;
      v2->startTimeMSec = 0;
      v2->adsrIndex = -1;
      *(_QWORD *)v2->dopplerEffectLastPos.v = 0i64;
      v2->dopplerEffectLastPos.v[2] = 0.0;
      *(_QWORD *)&v2->playbackId = 0i64;
      v2->occlusionAmount = 0.0;
      v2->waitingForDoppler = 0;
      v2->ignorePause = 0;
      v2->dopplerEffectPitch = 1.0;
      v2->autoSimId = -1;
    }
    SND_RemoveVoice(g_snd.chaninfoEntchannel[v1]);
    g_snd.chaninfoEntchannel[v1] = -1;
    SD_StopVoice(v1);
    sdGlob.voiceAlloc[v1] = 0;
  }
}

/*
==============
SND_SyncAmbientTracks
==============
*/
int SND_SyncAmbientTracks(int index)
{
  int result; 

  result = SND_SyncAmbientTracks_Internal(index, 0, 1);
  if ( result == index )
    return SND_SyncAmbientTracks_Internal(index, 2, 3);
  return result;
}

/*
==============
SND_SyncAmbientTracks_Internal
==============
*/
__int64 SND_SyncAmbientTracks_Internal(int index, int ambientPrimary, int ambientSecondary)
{
  unsigned int v3; 
  __int64 v5; 
  const SndAlias **p_alias; 

  v3 = index;
  if ( index != ambientSecondary + 80 )
    return (unsigned int)index;
  v5 = ambientPrimary + 80i64;
  if ( g_snd.voices[v5].soundFileInfo.loadingState == SFLS_UNLOADED )
    return (unsigned int)index;
  p_alias = &g_snd.voices[index].alias;
  if ( !*p_alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 13016, ASSERT_TYPE_ASSERT, "(g_snd.voices[index].alias)", (const char *)&queryFormat, "g_snd.voices[index].alias") )
    __debugbreak();
  if ( !g_snd.voices[v5].alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 13017, ASSERT_TYPE_ASSERT, "(g_snd.voices[((0 + 32) + 48) + ambientPrimary].alias)", (const char *)&queryFormat, "g_snd.voices[SND_FIRST_STREAM_VOICE + ambientPrimary].alias") )
    __debugbreak();
  if ( (*p_alias)->startDelay == g_snd.voices[v5].alias->startDelay )
    return (unsigned int)(ambientPrimary + 80);
  return v3;
}

/*
==============
SND_UnpauseVoice
==============
*/
void SND_UnpauseVoice(int index)
{
  __int64 v1; 
  __int64 v2; 

  v1 = index;
  if ( !Sys_IsMainThread() && !Sys_IsRenderThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1152, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsRenderThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsRenderThread()") )
    __debugbreak();
  if ( (unsigned int)v1 > 0x62 )
  {
    LODWORD(v2) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1153, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v2) )
      __debugbreak();
  }
  LOBYTE(g_snd.chaninfoUnweightedPriority[492 * v1 - 48664]) = 0;
  SD_UpdateVoice(v1, 0);
}

/*
==============
SND_UnpauseVoiceThatWasStartedPaused
==============
*/
void SND_UnpauseVoiceThatWasStartedPaused(int index)
{
  __int64 v1; 

  v1 = index;
  if ( (unsigned int)index > 0x62 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", index) )
    __debugbreak();
  if ( sdGlob.voiceAlloc[v1] && (!g_snd.paused || !SND_IsPausable((unsigned __int8)(*(int *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v1 - 48680] + 112i64) >> 10))) )
    SND_UnpauseVoice(v1);
}

/*
==============
SND_Update
==============
*/
void SND_Update()
{
  int v6; 
  int v7; 
  unsigned __int64 v8; 
  char paused; 
  bool IsLocalServerPaused; 
  bool *voiceAlloc; 
  bool v12; 
  bool v22; 
  bool v25; 
  unsigned __int8 v29; 
  int v36; 
  bool *v37; 
  __int64 v41; 
  bool v42; 
  bool v43; 
  int v49; 
  bool *p_paused; 
  const dvar_t *v51; 
  __int64 v58; 
  double v59; 
  double v60; 
  double v61; 
  int frametime; 
  ScopedCriticalSection v63; 
  __int64 v64; 
  char v66; 
  void *retaddr; 
  bool data; 
  int globalMasterPriorityID; 
  float globalMasterPriorityVal; 
  float globalMasterPercentage; 

  _RAX = &retaddr;
  v64 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps [rsp+0E8h+var_88], xmm10
  }
  if ( !cls.soundStarted || !g_snd.driverInitialized )
    goto LABEL_94;
  v6 = Sys_Milliseconds();
  v7 = v6 - g_snd.time;
  frametime = v6 - g_snd.time;
  g_snd.time = v6;
  v8 = Sys_Microseconds();
  *(_QWORD *)&v63._s = v8;
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "SND_Update");
  ++g_snd.frame;
  SND_UpdateDebug();
  Com_DevhostUpdate(24);
  if ( SND_Active() && Com_DevhostSystemActive(3) )
    SND_DevhostFrameBegin(g_snd.time, g_snd.frame, g_snd.paused);
  SD_PreUpdate(v7);
  paused = g_snd.paused;
  data = g_snd.paused;
  if ( !g_snd.hasPendingRestore || Sys_IsMainThread() )
  {
    if ( Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
    {
      if ( !CL_Pause_IsGamePaused() )
      {
LABEL_13:
        if ( !g_snd.uiPaused )
        {
          paused = 0;
LABEL_16:
          data = paused;
          goto LABEL_17;
        }
LABEL_15:
        paused = 1;
        goto LABEL_16;
      }
      IsLocalServerPaused = Com_MP_GetIsLocalServerPaused();
    }
    else
    {
      IsLocalServerPaused = CL_Pause_IsGamePaused();
    }
    if ( IsLocalServerPaused )
      goto LABEL_15;
    goto LABEL_13;
  }
LABEL_17:
  Sys_ProfBeginNamedEvent(0xFFD8BFD8, "wait_workers");
  if ( !s_soundPhysicsQueryBlock )
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
  Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
  Sys_ProfEndNamedEvent();
  voiceAlloc = sdGlob.voiceAlloc;
  if ( paused )
  {
    SND_UpdateMasterVolumes(0);
  }
  else
  {
    v12 = CL_GetLocalClientActiveCount() > 1;
    SND_ProcessPendingRestore();
    SND_UpdateMasterVolumes(v7);
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vcvtsi2ss xmm6, xmm6, r13d
    }
    _RBX = g_snd.globalContextLerp;
    __asm
    {
      vmovss  xmm9, cs:__real@3f800000
      vxorps  xmm8, xmm8, xmm8
    }
    do
    {
      __asm
      {
        vmulss  xmm0, xmm6, dword ptr [rbx+4]
        vaddss  xmm0, xmm0, dword ptr [rbx]; val
        vmovaps xmm2, xmm9; max
        vmovaps xmm1, xmm8; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [rbx], xmm0 }
      ++_RBX;
    }
    while ( (__int64)_RBX < (__int64)&g_snd.globalContextLerp[64] );
    *(double *)&_XMM0 = Com_GetTimescaleForSnd();
    __asm
    {
      vcmpless xmm1, xmm0, xmm8
      vblendvps xmm7, xmm0, xmm9, xmm1
      vmovss  [rsp+0E8h+globalMasterPriorityID], xmm7
      vucomiss xmm7, cs:?g_snd@@3Usnd_local_t@@A.timescale; snd_local_t g_snd
    }
    if ( !v22 )
    {
      __asm { vucomiss xmm7, xmm8 }
      if ( v22 )
      {
        v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8000, ASSERT_TYPE_ASSERT, "(timescale)", (const char *)&queryFormat, "timescale");
        v22 = !v25;
        if ( v25 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.timescale; snd_local_t g_snd
        vucomiss xmm0, xmm8
      }
      if ( v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 8001, ASSERT_TYPE_ASSERT, "(g_snd.timescale)", (const char *)&queryFormat, "g_snd.timescale") )
        __debugbreak();
      __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.timescale, xmm7; snd_local_t g_snd }
    }
    __asm { vmulss  xmm0, xmm6, cs:__real@3a83126f; dt }
    SND_SubmixUpdate(*(float *)&_XMM0, v12);
    LOBYTE(globalMasterPriorityID) = 0;
    __asm
    {
      vmovss  [rsp+0E8h+globalMasterPriorityVal], xmm8
      vmovss  [rsp+0E8h+globalMasterPercentage], xmm8
    }
    SND_UpdatePerChannelMasterSettings(0, 99, (unsigned __int8 *)&globalMasterPriorityID, &globalMasterPriorityVal, &globalMasterPercentage);
    __asm { vmulss  xmm6, xmm6, cs:__real@3c23d70a }
    v29 = globalMasterPriorityID;
    g_snd.masterPriorityID = globalMasterPriorityID;
    __asm
    {
      vmovss  xmm0, [rsp+0E8h+globalMasterPriorityVal]
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.masterPriorityVal, xmm0; snd_local_t g_snd
      vmovss  xmm1, cs:?g_snd@@3Usnd_local_t@@A.masterPercentage; snd_local_t g_snd
      vmovss  xmm2, [rsp+0E8h+globalMasterPercentage]
      vcomiss xmm1, xmm2
    }
    if ( v42 || v22 )
    {
      __asm
      {
        vaddss  xmm0, xmm1, xmm6
        vminss  xmm1, xmm0, xmm2
      }
    }
    else
    {
      __asm
      {
        vsubss  xmm0, xmm1, xmm6
        vmaxss  xmm1, xmm0, xmm2
      }
    }
    __asm { vmovss  cs:?g_snd@@3Usnd_local_t@@A.masterPercentage, xmm1; snd_local_t g_snd }
    v36 = 0;
    v37 = sdGlob.voiceAlloc;
    _RBX = &g_snd.voices[0].masterSlaveLerp;
    __asm
    {
      vmovsd  xmm7, cs:__real@3ff0000000000000
      vxorpd  xmm10, xmm10, xmm10
    }
    do
    {
      if ( (unsigned int)v36 > 0x62 )
      {
        LODWORD(v58) = v36;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v58) )
          __debugbreak();
      }
      if ( *v37 )
      {
        if ( _RBX == (float *)376 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15933, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
          __debugbreak();
        v41 = *((_QWORD *)_RBX - 33);
        v42 = 0;
        v43 = v29 == 0;
        if ( v29 && (v42 = v29 < *(_BYTE *)(v41 + 209), v43 = v29 <= *(_BYTE *)(v41 + 209), v29 > *(_BYTE *)(v41 + 209)) )
        {
          __asm
          {
            vaddss  xmm0, xmm6, dword ptr [rbx]
            vminss  xmm1, xmm0, xmm9
          }
        }
        else
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx]
            vsubss  xmm1, xmm0, xmm6
            vmaxss  xmm1, xmm1, xmm8
          }
        }
        __asm
        {
          vmovss  dword ptr [rbx], xmm1
          vcomiss xmm1, xmm8
        }
        if ( v42 )
          goto LABEL_97;
        __asm { vcomiss xmm1, xmm9 }
        if ( !v43 )
        {
LABEL_97:
          __asm
          {
            vcvtss2sd xmm0, xmm1, xmm1
            vmovsd  [rsp+0E8h+var_B0], xmm7
            vmovsd  [rsp+0E8h+var_B8], xmm10
            vmovsd  [rsp+0E8h+var_C0], xmm0
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16086, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( voice->masterSlaveLerp ) && ( voice->masterSlaveLerp ) <= ( 1.0f )", "voice->masterSlaveLerp not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", v59, v60, v61) )
            __debugbreak();
        }
      }
      ++v36;
      ++v37;
      _RBX += 492;
    }
    while ( v36 < 99 );
    SND_MusicUpdate();
    voiceAlloc = sdGlob.voiceAlloc;
    paused = data;
    v7 = frametime;
    LODWORD(v8) = v63._s;
  }
  if ( paused != g_snd.paused )
  {
    if ( paused )
    {
      SND_PauseSounds();
      if ( paused != g_snd.paused && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 9206, ASSERT_TYPE_ASSERT, "(paused == g_snd.paused)", (const char *)&queryFormat, "paused == g_snd.paused") )
        __debugbreak();
    }
    else if ( g_snd.paused )
    {
      if ( g_snd.driverInitialized )
      {
        v49 = 0;
        p_paused = &g_snd.voices[0].paused;
        do
        {
          if ( (unsigned int)v49 > 0x62 )
          {
            LODWORD(v58) = v49;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v58) )
              __debugbreak();
          }
          if ( *voiceAlloc && *p_paused )
            SND_UnpauseVoice(v49);
          ++v49;
          ++voiceAlloc;
          p_paused += 1968;
        }
        while ( v49 < 99 );
        LODWORD(v8) = v63._s;
      }
      g_snd.paused = 0;
      g_snd.pausetime = 0;
    }
  }
  SND_UpdateAllVoices(v7);
  SND_ProcessCLQueue();
  SD_PostUpdate(v7);
  if ( SND_Active() && Com_DevhostSystemActive(3) )
  {
    if ( !g_snd.bankUpdateStatus )
      SND_BankDevhost();
    if ( !s_soundPhysicsQueryBlock )
      Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_OCCLUSION);
    Sys_WaitWorkerCmdsOnlyOfType(WRKCMD_SOUND_VOICE_UPDATE);
    SND_DevhostFrameEnd();
  }
  v51 = DCONST_DVARBOOL_snd_enable_capture_mode;
  if ( !DCONST_DVARBOOL_snd_enable_capture_mode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_enable_capture_mode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v51);
  if ( v51->current.enabled && g_snd.driverInitialized )
  {
    ScopedCriticalSection::ScopedCriticalSection(&v63, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
    if ( sdGlob.voiceAlloc[80] )
    {
      SND_DebugAliasPrint(g_snd.voices[80].alias != NULL, g_snd.voices[80].alias, "Stop voice requested by SND_StopBackground()");
      SND_StopVoice(80);
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v63);
    ScopedCriticalSection::ScopedCriticalSection(&v63, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
    if ( sdGlob.voiceAlloc[81] )
    {
      SND_DebugAliasPrint(g_snd.voices[81].alias != NULL, g_snd.voices[81].alias, "Stop voice requested by SND_StopBackground()");
      SND_StopVoice(81);
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v63);
    ScopedCriticalSection::ScopedCriticalSection(&v63, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
    if ( sdGlob.voiceAlloc[82] )
    {
      SND_DebugAliasPrint(g_snd.voices[82].alias != NULL, g_snd.voices[82].alias, "Stop voice requested by SND_StopBackground()");
      SND_StopVoice(82);
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v63);
    ScopedCriticalSection::ScopedCriticalSection(&v63, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
    if ( sdGlob.voiceAlloc[83] )
    {
      SND_DebugAliasPrint(g_snd.voices[83].alias != NULL, g_snd.voices[83].alias, "Stop voice requested by SND_StopBackground()");
      SND_StopVoice(83);
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v63);
  }
  if ( !CL_AnyLocalClientStateActive() && !Sys_ExistsWorkerCmdsOfType(WRKCMD_SOUND_DEFERRED_PLAYBACK) )
    Sys_AddWorkerCmd(WRKCMD_SOUND_DEFERRED_PLAYBACK, &data);
  g_snd.clientFrameUsec = Sys_Microseconds() - v8;
  Sys_ProfEndNamedEvent();
LABEL_94:
  _R11 = &v66;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
SND_UpdateAllVoices
==============
*/
void SND_UpdateAllVoices(int frametime)
{
  volatile int *voiceBusyUpdating; 
  volatile unsigned int *p_occlusionWaitId; 
  int i; 
  int data[4]; 

  voiceBusyUpdating = g_snd.voiceBusyUpdating;
  p_occlusionWaitId = &g_snd.voices[0].occlusionWaitId;
  for ( i = 0; i < 99; ++i )
  {
    if ( ((unsigned __int8)voiceBusyUpdating & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)voiceBusyUpdating) )
      __debugbreak();
    if ( !_InterlockedCompareExchange(voiceBusyUpdating, 1, 0) )
    {
      if ( !Sys_IsMainThread() && !Sys_IsRenderThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1594, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread() || Sys_IsRenderThread())", (const char *)&queryFormat, "Sys_IsMainThread() || Sys_IsRenderThread()") )
        __debugbreak();
      if ( *((_DWORD *)p_occlusionWaitId - 96) )
      {
        Sys_ProfBeginNamedEvent(0xFFD8BFD8, "SND_UpdateVoice");
        if ( !*((_BYTE *)p_occlusionWaitId - 208) && !*p_occlusionWaitId )
        {
          if ( SD_IsVoiceDone(i) )
          {
            SND_DebugAliasPrint(*((_QWORD *)p_occlusionWaitId - 34) != 0i64, *((const SndAlias **)p_occlusionWaitId - 34), "Stopped voice because it's done");
            SND_StopVoiceWithoutLock(i);
          }
          else
          {
            data[0] = *((_DWORD *)p_occlusionWaitId - 89);
            data[1] = i;
            data[2] = frametime;
            Sys_InterlockedCompareExchange(voiceBusyUpdating, 0, 1);
            if ( Sys_TryAddWorkerCmd(WRKCMD_SOUND_VOICE_UPDATE, data) )
            {
              Sys_ProfEndNamedEvent();
              goto LABEL_20;
            }
            do
            {
              if ( ((unsigned __int8)voiceBusyUpdating & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)voiceBusyUpdating) )
                __debugbreak();
            }
            while ( _InterlockedCompareExchange(voiceBusyUpdating, 1, 0) == 1 );
            if ( data[0] == *((_DWORD *)p_occlusionWaitId - 89) )
              SND_UpdateAndStartVoice(i, frametime);
          }
        }
        Sys_ProfEndNamedEvent();
      }
      if ( ((unsigned __int8)voiceBusyUpdating & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)voiceBusyUpdating) )
        __debugbreak();
      _InterlockedCompareExchange(voiceBusyUpdating, 0, 1);
    }
LABEL_20:
    ++voiceBusyUpdating;
    p_occlusionWaitId += 492;
  }
}

/*
==============
SND_UpdateAndStartVoice
==============
*/
void SND_UpdateAndStartVoice(int voiceIndex, int frametime)
{
  __int64 v8; 
  __int64 v11; 
  SndVoice *v12; 
  __int64 v13; 
  bool v21; 
  bool v22; 
  __int64 v34; 
  bool v37; 
  bool v38; 
  __int64 v53; 

  _R12 = 0x140000000ui64;
  v8 = voiceIndex;
  _RDI = 1968i64 * voiceIndex;
  v11 = (unsigned int)voiceIndex;
  v12 = &g_snd.voices[_RDI / 0x7B0];
  if ( !*(_QWORD *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48680] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1423, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
    __debugbreak();
  if ( SD_StreamReady(v11) && (*(_DWORD *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48680] + 180i64) == g_snd.defaultHash || !SND_IsEntChannel3D((unsigned __int8)(*(int *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v11 - 48680] + 112i64) >> 10)) || SLODWORD(g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48611]) <= 0) )
  {
    __asm
    {
      vmovaps [rsp+0B8h+var_38], xmm6
      vmovaps [rsp+0B8h+var_48], xmm7
      vmovaps [rsp+0B8h+var_58], xmm8
      vmovaps [rsp+0B8h+var_68], xmm9
      vmovaps [rsp+0B8h+var_78], xmm10
    }
    if ( v12->soundFileInfo.loadingState == SFLS_LOADING )
    {
      v13 = *(_QWORD *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48680];
      frametime = 0;
      v12->soundFileInfo.loadingState = SFLS_LOADED;
      if ( *(_QWORD *)(v13 + 8) )
      {
        if ( !LOBYTE(g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48699]) )
          g_snd.voices[_RDI / 0x7B0].triggerSubtitle = 1;
      }
    }
    SND_SetUpVoiceParams((SndVoiceParams *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48610], *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48680], *(_QWORD *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48704], SLODWORD(g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48661]));
    SND_CalculateOcclusionValues(v11, frametime);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+r12+15C6C304h]
      vmulss  xmm1, xmm0, dword ptr [rdi+r12+15C6C334h]
      vmulss  xmm6, xmm1, dword ptr [rdi+r12+15C6C3A8h]
    }
    SND_UpdateParameter((snd_param_info_t *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48686], frametime, 0);
    __asm
    {
      vmulss  xmm0, xmm6, dword ptr [rbx]
      vmulss  xmm1, xmm0, dword ptr [rdi+r12+15C6C480h]
      vmulss  xmm0, xmm1, dword ptr [rdi+r12+15C6C488h]
    }
    _RAX = 260 * v8;
    __asm { vmovss  dword ptr [rax+r12+15C4CE0Ch], xmm0 }
    v21 = (unsigned int)v11 < 0x63;
    if ( (unsigned int)v11 >= 0x63 )
    {
      LODWORD(v53) = v11;
      v22 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 13283, ASSERT_TYPE_ASSERT, "(unsigned)( voiceIndex ) < (unsigned)( ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) )", "voiceIndex doesn't index SND_MAX_VOICES\n\t%i not in [0, %i)", v53, 99);
      v21 = 0;
      if ( v22 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm2, dword ptr [rdi+r12+15C6C420h]
      vmovss  xmm1, dword ptr [rdi+r12+15C6C424h]
      vcomiss xmm2, xmm1
      vmovss  xmm4, cs:__real@3aa3d70a
      vxorps  xmm7, xmm7, xmm7
      vcvtsi2ss xmm7, xmm7, ebp
    }
    if ( v21 )
    {
      __asm
      {
        vmulss  xmm0, xmm7, xmm4
        vsubss  xmm1, xmm1, xmm0
        vmaxss  xmm3, xmm1, xmm2
      }
    }
    else
    {
      __asm { vmovaps xmm3, xmm2 }
    }
    __asm { vmovss  dword ptr [rdi+r12+15C6C424h], xmm3 }
    if ( *(_BYTE *)(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48680] + 209i64) )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rdi+r12+15C6C42Ch]
        vcomiss xmm2, xmm1
        vmovss  dword ptr [rdi+r12+15C6C42Ch], xmm2
      }
    }
    *(float *)&_XMM0 = SND_CalcVoiceVolume(frametime, &g_snd.voices[_RDI / 0x7B0]);
    __asm
    {
      vmovss  xmm6, cs:__real@3f800000
      vmovaps xmm2, xmm6; max
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm10, xmm0
      vxorps  xmm9, xmm9, xmm9
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    v34 = *(_QWORD *)&g_snd.chaninfoUnweightedPriority[_RDI / 4 - 48680];
    __asm
    {
      vmulss  xmm1, xmm0, dword ptr [rdi+r12+15C6C42Ch]
      vmovss  xmm8, dword ptr [rdi+r12+15C6C428h]
      vmovss  dword ptr [rdi+r12+15C6C2DCh], xmm1
      vmovss  dword ptr [rdi+r12+15C6C2E4h], xmm10
    }
    v37 = v34 == 0;
    if ( !v34 )
    {
      v38 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15956, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias");
      v37 = !v38;
      if ( v38 )
        __debugbreak();
    }
    __asm { vcomiss xmm8, xmm9 }
    if ( !v37 )
    {
      __asm
      {
        vsubss  xmm0, xmm6, cs:?g_snd@@3Usnd_local_t@@A.masterPercentage; snd_local_t g_snd
        vmulss  xmm2, xmm0, dword ptr [rbx+0D8h]
        vmulss  xmm3, xmm2, xmm8
        vmovss  xmm2, cs:__real@42c80000; max
        vsubss  xmm0, xmm6, xmm8
        vaddss  xmm0, xmm3, xmm0; val
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovaps xmm6, xmm0 }
    }
    __asm { vmulss  xmm2, xmm6, xmm10; voiceVolume }
    SND_ApplySpeakerParams(v11, frametime, *(const float *)&_XMM2);
    SND_RecalcChaninfoPriority(v11);
    __asm { vmulss  xmm1, xmm7, cs:__real@3a83126f; dt }
    SND_SubmixSetOnVoiceStart(&g_snd.voices[_RDI / 0x7B0], *(float *)&_XMM1);
    __asm
    {
      vmovaps xmm10, [rsp+0B8h+var_78]
      vmovaps xmm9, [rsp+0B8h+var_68]
      vmovaps xmm8, [rsp+0B8h+var_58]
      vmovaps xmm7, [rsp+0B8h+var_48]
      vmovaps xmm6, [rsp+0B8h+var_38]
    }
    if ( SD_VoiceStarted(v11) )
      SD_UpdateVoice(v11, frametime);
    else
      SD_StartVoice(v11);
  }
}

/*
==============
SND_UpdateDebug
==============
*/

void __fastcall SND_UpdateDebug(__int64 a1, __int64 a2, double _XMM2_8)
{
  const dvar_t *v9; 
  const char *string; 
  int v11; 
  const char ***p_aliasList; 
  int handle; 
  int v14; 
  SndVirtualLoop *virtualLoops; 
  unsigned int v16; 
  const char ***p_alias; 
  const dvar_t *v18; 
  const char *v19; 
  SndAliasList *Alias; 
  const SndAliasList *v30; 
  char flags; 
  unsigned __int64 SndEntHandle; 
  const dvar_t *v38; 
  const dvar_t *v40; 
  const char *v41; 
  const char *v42; 
  unsigned int v43; 
  unsigned int v44; 
  float fmt; 
  ScopedCriticalSection v48; 
  snd_listener outListener; 
  _OWORD v52[2]; 
  void *retaddr; 

  _R11 = &retaddr;
  _RBP = v52;
  __asm { vmovaps xmmword ptr [r11-48h], xmm7 }
  v9 = DVARSTR_snd_stop_alias;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_stop_alias") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  string = v9->current.string;
  if ( string && *string )
  {
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    v11 = 0;
    p_aliasList = (const char ***)&g_snd.virtualLoops[0].aliasList;
    while ( *((_DWORD *)p_aliasList - 2) == -1 || !strstr_0(**p_aliasList, string) )
    {
      ++v11;
      p_aliasList += 6;
      if ( (__int64)p_aliasList >= (__int64)&g_snd.globalContextsFrom[1] )
        goto LABEL_17;
    }
    handle = g_snd.virtualLoops[v11].handle;
    ScopedCriticalSection::ScopedCriticalSection(&v48, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
    v14 = 0;
    virtualLoops = g_snd.virtualLoops;
    while ( virtualLoops->handle != handle )
    {
      ++v14;
      if ( (__int64)++virtualLoops >= (__int64)&g_snd.nextVirtualLoopHandle )
        goto LABEL_16;
    }
    g_snd.virtualLoops[v14].handle = -1;
LABEL_16:
    ScopedCriticalSection::~ScopedCriticalSection(&v48);
LABEL_17:
    v16 = 0;
    p_alias = (const char ***)&g_snd.voices[0].alias;
    do
    {
      if ( sdGlob.voiceAlloc[v16] && strstr_0(**p_alias, string) )
        SND_StopVoice(v16);
      ++v16;
      p_alias += 246;
    }
    while ( v16 < 0x63 );
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    Dvar_SetString_Internal(DVARSTR_snd_stop_alias, (const char *)&queryFormat.fmt + 3);
  }
  v18 = DVARSTR_snd_start_alias;
  if ( !DVARSTR_snd_start_alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_start_alias") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v18);
  v19 = v18->current.string;
  _RBX = DCONST_DVARFLT_snd_start_alias_distance;
  if ( !DCONST_DVARFLT_snd_start_alias_distance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_start_alias_distance") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+28h]
    vxorps  xmm7, xmm7, xmm7
  }
  if ( v19 && *v19 )
  {
    __asm
    {
      vmovaps [rsp+140h+var_58+8], xmm8
      vmovaps [rsp+140h+var_68+8], xmm9
    }
    SND_GetListener(LOCAL_CLIENT_0, &outListener);
    __asm
    {
      vmulss  xmm0, xmm6, dword ptr [rsp+140h+outListener.orient.axis]
      vaddss  xmm8, xmm0, dword ptr [rsp+140h+outListener.orient.origin]
      vmulss  xmm1, xmm6, dword ptr [rsp+140h+outListener.orient.axis+4]
      vmulss  xmm0, xmm6, dword ptr [rsp+140h+outListener.orient.axis+8]
      vaddss  xmm6, xmm0, dword ptr [rsp+140h+outListener.orient.origin+8]
      vaddss  xmm9, xmm1, dword ptr [rsp+140h+outListener.orient.origin+4]
      vmovss  dword ptr [rsp+140h+var_100._next], xmm6
      vmovss  [rsp+140h+var_100._s], xmm8
      vmovss  dword ptr [rsp+140h+var_100._hasOwnership], xmm9
    }
    Alias = SND_FindAlias(v19);
    v30 = Alias;
    if ( Alias )
    {
      flags = Alias->head->flags;
      SndEntHandle = CG_GenerateSndEntHandle(LOCAL_CLIENT_0, 2046);
      if ( (flags & 1) != 0 )
      {
        __asm
        {
          vmovss  xmm3, cs:__real@3f800000; volume
          vmovss  dword ptr [rsp+140h+fmt], xmm3
        }
        SND_PlayVirtualLoopSoundInternal(v30, SndEntHandle, (const vec3_t *)&v48, *(double *)&_XMM3, fmt, 0);
      }
      else
      {
        __asm
        {
          vmovss  xmm0, cs:__real@bf800000
          vmovaps xmm1, cs:__xmm@3f8000003f8000003f8000003f800000
        }
        LODWORD(outListener.orient.axis.m[0].v[0]) = 1;
        __asm
        {
          vmovss  dword ptr [rbp+40h+outListener.inverse.axis+1Ch], xmm0
          vmovss  dword ptr [rbp+40h+outListener.inverse.axis+20h], xmm0
          vmovaps xmmword ptr [rsp+140h+outListener.orient.axis+4], xmm1
          vmovss  [rbp+40h+outListener.velocity], xmm7
          vmovss  dword ptr [rsp+140h+outListener.orient.axis+1Ch], xmm8
          vmovss  dword ptr [rsp+140h+outListener.orient.axis+20h], xmm9
          vmovss  dword ptr [rbp+40h+outListener.inverse.origin], xmm6
        }
        outListener.inverse.axis.m[0].v[0] = 0.0;
        outListener.inverse.axis.m[1].v[2] = 0.0;
        LOBYTE(outListener.inverse.axis.row2.v[0]) = 0;
        outListener.velocityVect.v[0] = 0.0;
        *(_QWORD *)&outListener.velocityVect.y = -1i64;
        outListener.playerStateClientNum = -1;
        outListener.localClientNum = LOCAL_CLIENT_0;
        *(_WORD *)&outListener.active = 0;
        *(_QWORD *)outListener.orient.origin.v = v30;
        outListener.orient.origin.v[2] = 0.0;
        *(_QWORD *)&outListener.orient.axis.row1.z = SndEntHandle;
        *(_QWORD *)&outListener.inverse.origin.y = 0xFFFFFFFF00000000ui64;
        *(_OWORD *)&outListener.inverse.axis.row0.y = 0xFFFFFFFF00000001ui64;
        SND_PlaySoundAliasFromParams((const SndPlayParams *)&outListener, 0);
      }
    }
    Dvar_SetString_Internal(DVARSTR_snd_start_alias, (const char *)&queryFormat.fmt + 3);
    __asm
    {
      vmovaps xmm9, [rsp+140h+var_68+8]
      vmovaps xmm8, [rsp+140h+var_58+8]
    }
  }
  v38 = DCONST_DVARSTR_snd_debug_context_type;
  __asm { vmovaps xmm6, [rsp+140h+var_38+8] }
  if ( !DCONST_DVARSTR_snd_debug_context_type && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debug_context_type") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v38);
  v40 = DCONST_DVARSTR_snd_debug_context_value;
  v41 = v38->current.string;
  if ( !DCONST_DVARSTR_snd_debug_context_value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_debug_context_value") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v40);
  if ( v41 )
  {
    if ( *v41 )
    {
      v42 = v40->current.string;
      if ( v42 )
      {
        if ( *v42 )
        {
          v43 = SND_HashName(v42);
          v44 = SND_HashName(v41);
          __asm { vxorps  xmm2, xmm2, xmm2; fadeTime }
          SND_SetContext(v44, v43, *(float *)&_XMM2);
        }
      }
    }
  }
  __asm { vmovaps xmm7, [rsp+140h+var_48+8] }
}

/*
==============
SND_UpdateDelayedWeaponSoundQueue
==============
*/
void SND_UpdateDelayedWeaponSoundQueue(int gameFrameDelta, const int controllerIndex)
{
  int *p_timeStampMS; 
  unsigned int i; 
  unsigned int v16; 
  int v17; 
  int v18; 
  int v19; 
  const SndAliasList *v20; 
  const SndAliasList *v24; 
  const SndAliasList *v28; 
  unsigned __int64 v32; 
  unsigned __int64 v33; 
  __int64 v34; 
  const char *HitMarkerAlias; 
  __int64 v36; 
  const char *v37; 
  const char *v38; 
  const SndAliasList *Alias; 
  unsigned __int64 SndEntHandle; 
  unsigned int v41; 
  int VoiceIndexForId; 
  int v43; 
  unsigned int v44; 
  int v45; 
  int v46; 
  unsigned int v47; 
  unsigned __int64 v48; 
  float fmt; 
  float hand; 
  SndPlayParams inParams; 
  char v54; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-38h], xmm6 }
  _RBX = DCONST_DVARFLT_snd_autoSim_predictWindowMs;
  if ( !DCONST_DVARFLT_snd_autoSim_predictWindowMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_autoSim_predictWindowMs") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vcvttss2si esi, dword ptr [rbx+28h] }
  p_timeStampMS = &g_snd.delayedWeaponSounds[0].timeStampMS;
  for ( i = 0; i < 0x40; ++i )
  {
    if ( *(p_timeStampMS - 1) )
    {
      *p_timeStampMS -= gameFrameDelta;
      if ( *p_timeStampMS < _ESI )
      {
        SND_FinishPlayingWeaponSound((const SndPlayParams *)(p_timeStampMS + 3), 0, *(const WeaponSFXPackage **)(p_timeStampMS + 35), *((_BYTE *)p_timeStampMS + 4), 0, WEAPON_HAND_DEFAULT);
        *(p_timeStampMS - 1) = 0;
      }
    }
    p_timeStampMS += 38;
  }
  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovss  xmm6, cs:__real@3f800000
    vxorps  xmm1, xmm1, xmm1
    vmovups xmmword ptr [rbp+57h+inParams.volumeScale], xmm0
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+57h+inParams.lpfCutoff], xmm0
    vmovss  [rbp+57h+inParams.hpfCutoff], xmm0
    vmovss  dword ptr [rbp+57h+inParams.org], xmm1
    vmovss  dword ptr [rbp+57h+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+57h+inParams.org+8], xmm1
    vmovss  [rbp+57h+inParams.startOffsetFraction], xmm1
  }
  inParams.aliasList = NULL;
  _RDI = &g_snd.delayedBulletEvents[0].whizInPos.v[2];
  *(_QWORD *)&inParams.aliasId = 0i64;
  inParams.sndEnt = 0i64;
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.system = SASYS_CGAME;
  v16 = 0;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  inParams.additionalStartDelayUs = 0;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  do
  {
    v17 = *((_DWORD *)_RDI - 13);
    if ( !v17 )
      goto LABEL_42;
    v18 = *((_DWORD *)_RDI - 5);
    *((_DWORD *)_RDI + 9) -= gameFrameDelta;
    v19 = v18 - gameFrameDelta;
    *((_DWORD *)_RDI - 5) = v19;
    if ( v17 == 1 )
    {
      if ( v19 > 0 )
        goto LABEL_42;
      inParams.sndEnt = *(_QWORD *)(_RDI + 13);
      v20 = *(const SndAliasList **)(_RDI - 7);
      if ( v20 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rdi-8]
          vmovss  xmm1, dword ptr [rdi-4]
          vmovss  dword ptr [rbp+57h+inParams.org], xmm0
          vmovss  xmm0, dword ptr [rdi]
        }
        inParams.aliasList = v20;
        __asm
        {
          vmovss  dword ptr [rbp+57h+inParams.org+8], xmm0
          vmovss  dword ptr [rbp+57h+inParams.org+4], xmm1
        }
        SND_PlaySoundAliasFromParams(&inParams, 1);
      }
      v24 = *(const SndAliasList **)(_RDI - 11);
      if ( v24 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rdi-8]
          vmovss  xmm1, dword ptr [rdi-4]
          vmovss  dword ptr [rbp+57h+inParams.org], xmm0
          vmovss  xmm0, dword ptr [rdi]
        }
        inParams.aliasList = v24;
        __asm
        {
          vmovss  dword ptr [rbp+57h+inParams.org+8], xmm0
          vmovss  dword ptr [rbp+57h+inParams.org+4], xmm1
        }
        SND_PlaySoundAliasFromParams(&inParams, 1);
      }
      v28 = *(const SndAliasList **)(_RDI - 9);
      if ( v28 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rdi+4]
          vmovss  xmm1, dword ptr [rdi+8]
          vmovss  dword ptr [rbp+57h+inParams.org], xmm0
          vmovss  xmm0, dword ptr [rdi+0Ch]
        }
        inParams.aliasList = v28;
        __asm
        {
          vmovss  dword ptr [rbp+57h+inParams.org+8], xmm0
          vmovss  dword ptr [rbp+57h+inParams.org+4], xmm1
        }
        SND_PlaySoundAliasFromParams(&inParams, 1);
      }
      *((_DWORD *)_RDI - 13) = 2;
    }
    else if ( v17 != 2 )
    {
      goto LABEL_42;
    }
    if ( *((int *)_RDI + 9) <= 0 )
    {
      v32 = *(_QWORD *)(_RDI + 15);
      v33 = v32 & 0x1FFFFFFFFi64;
      v34 = (v32 >> 33) & 3;
      if ( v33 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v33, "unsigned", v33) )
        __debugbreak();
      if ( *((_BYTE *)_RDI + 68) )
      {
        HitMarkerAlias = GamerProfile_GetHitMarkerAlias(controllerIndex);
        v36 = *((int *)_RDI + 18);
        if ( (_DWORD)v36 )
        {
          v37 = s_hitmarkerSuffix[v36];
          v38 = GamerProfile_GetHitMarkerAlias(controllerIndex);
          HitMarkerAlias = j_va("%s%s", v38, v37);
        }
        Alias = SND_FindAlias(HitMarkerAlias);
        if ( Alias )
        {
          SndEntHandle = CG_GenerateSndEntHandle((const LocalClientNum_t)v34, v33);
          __asm
          {
            vmovss  [rsp+110h+hand], xmm6
            vmovss  dword ptr [rsp+110h+fmt], xmm6
          }
          SND_PlaySurfaceSound_Internal(Alias, 0, *((_DWORD *)_RDI + 7), SndEntHandle, fmt, hand, 0, (const vec3_t *)(_RDI + 4), 1);
        }
      }
      if ( *(_QWORD *)(_RDI + 11) )
      {
        v41 = *((_DWORD *)_RDI - 4);
        if ( v41 )
        {
          Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
          VoiceIndexForId = SND_GetVoiceIndexForId(v41);
          v43 = VoiceIndexForId;
          if ( VoiceIndexForId != -1 )
          {
            SND_DebugAliasPrint(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * VoiceIndexForId - 48680] != 0i64, *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[492 * VoiceIndexForId - 48680], "Stop voice requested by SND_StopVoiceById()");
            SND_StopVoice(v43);
          }
          Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
        }
        v44 = *((_DWORD *)_RDI - 3);
        if ( v44 )
        {
          Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
          v45 = SND_GetVoiceIndexForId(v44);
          v46 = v45;
          if ( v45 != -1 )
          {
            SND_DebugAliasPrint(*(_QWORD *)&g_snd.chaninfoUnweightedPriority[492 * v45 - 48680] != 0i64, *(const SndAlias **)&g_snd.chaninfoUnweightedPriority[492 * v45 - 48680], "Stop voice requested by SND_StopVoiceById()");
            SND_StopVoice(v46);
          }
          Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
        }
        if ( *(_QWORD *)(_RDI + 11) )
        {
          v47 = *((_DWORD *)_RDI + 8);
          v48 = CG_GenerateSndEntHandle((const LocalClientNum_t)v34, v33);
          SND_PlayExplosionSound_Internal(*(const SndAliasList **)(_RDI + 11), 0, *((_DWORD *)_RDI + 7), v48, (const vec3_t *)(_RDI + 4), v47, 1);
        }
      }
      *(_RDI - 13) = 0.0;
    }
LABEL_42:
    ++v16;
    _RDI += 32;
  }
  while ( v16 < 0x40 );
  _R11 = &v54;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
SND_UpdateEntVolumes
==============
*/
void SND_UpdateEntVolumes(int frametime)
{
  unsigned int v9; 
  bool v13; 
  __int64 v26; 
  char v30; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps [rsp+98h+var_38], xmm6 }
  _RBX = &g_sndEntityParamInfo[0].volume.goalvalue;
  __asm
  {
    vmovaps xmmword ptr [r11-68h], xmm9
    vmovss  xmm9, cs:__real@3f800000
    vmovaps [rsp+98h+var_48], xmm7
    vmovaps xmmword ptr [r11-58h], xmm8
  }
  v9 = 0;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  do
  {
    if ( *((_DWORD *)_RBX - 8) != 2047 )
    {
      _RDI = _RBX - 1;
      if ( _RBX == (float *)4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6965, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
        __debugbreak();
      if ( frametime < 0 )
      {
        LODWORD(v26) = frametime;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6966, ASSERT_TYPE_ASSERT, "( ( dt_msec >= 0 ) )", "( dt_msec ) = %i", v26) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi]
        vcomiss xmm0, xmm6
      }
      v13 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND);
      __asm { vmovss  xmm3, dword ptr [rbx+4] }
      if ( v13 )
      {
        __asm
        {
          vcomiss xmm3, xmm6
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, esi
          vmulss  xmm1, xmm0, xmm3
          vaddss  xmm2, xmm1, dword ptr [rdi]
          vmovss  xmm0, dword ptr [rbx]
          vmovss  dword ptr [rdi], xmm2
          vcomiss xmm2, xmm0
          vmovss  dword ptr [rdi], xmm0
        }
        _RBX[1] = 0.0;
      }
      else
      {
        __asm
        {
          vucomiss xmm3, xmm6
          vmovss  xmm0, dword ptr [rbx]
          vcomiss xmm0, xmm6
          vmovss  dword ptr [rdi], xmm0
        }
        _RBX[3] = 0.0;
      }
      SND_UpdateParameter(&g_sndEntityParamInfo[v9].pitch, frametime, 0);
    }
    ++v9;
    _RBX += 13;
  }
  while ( v9 < 0x40 );
  __asm { vmovaps xmm8, [rsp+98h+var_58] }
  _R11 = &v30;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm7, [rsp+98h+var_48]
    vmovaps xmm6, [rsp+98h+var_38]
  }
}

/*
==============
SND_UpdateLoopingSounds
==============
*/
void SND_UpdateLoopingSounds(bool deferred)
{
  int v5; 
  __int64 v9; 
  const SndAliasList *v10; 
  unsigned __int64 v13; 
  unsigned __int64 v14; 
  volatile int *voiceBusyUpdating; 
  char v22; 
  const char *v23; 
  SndPlayParams inParams; 
  tmat33_t<vec3_t> axis_out; 
  void *retaddr; 

  _R11 = &retaddr;
  if ( g_snd.driverInitialized && !g_snd.paused )
  {
    __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
    Sys_ProfBeginNamedEvent(0xFFD8BFD8, "SND_UpdateLoopingSounds");
    Sys_EnterCriticalSection(CRITSECT_SOUND_UPDATE);
    __asm { vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000 }
    v5 = 0;
    inParams.playbackType = SPT_BLEND;
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vmovups xmmword ptr [rsp+110h+inParams.volumeScale], xmm0
      vmovss  xmm0, cs:__real@bf800000
      vmovss  [rbp+10h+inParams.lpfCutoff], xmm0
      vmovss  [rbp+10h+inParams.hpfCutoff], xmm0
      vmovss  dword ptr [rsp+110h+inParams.org], xmm6
      vmovss  dword ptr [rsp+110h+inParams.org+4], xmm6
      vmovss  dword ptr [rsp+110h+inParams.org+8], xmm6
      vmovss  [rbp+10h+inParams.startOffsetFraction], xmm6
    }
    inParams.aliasList = NULL;
    _RBX = &g_snd.virtualLoops[0].org.v[2];
    inParams.aliasId = 0;
    v9 = 198i64;
    inParams.sndEnt = 0i64;
    inParams.timeshift = 0;
    inParams.adsrIndex = -1;
    inParams.fadeTime = 0;
    inParams.system = SASYS_CGAME;
    inParams.autoSimId = -1;
    inParams.autoSimTimeStamp = 0i64;
    inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
    inParams.startPaused = 0;
    inParams.additionalStartDelayUs = 0;
    *(_QWORD *)&inParams.surfaceType = -1i64;
    inParams.contextIndex2 = -1;
    inParams.reflectionClass = 0;
    *(_WORD *)&inParams.isADS = 0;
    do
    {
      if ( *((_DWORD *)_RBX - 8) != -1 )
      {
        v10 = (const SndAliasList *)*((_QWORD *)_RBX - 3);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+4]
          vmovss  xmm1, dword ptr [rbx+8]
        }
        v13 = *((_QWORD *)_RBX - 2);
        __asm
        {
          vmovss  [rsp+110h+inParams.volumeScale], xmm0
          vmovss  [rsp+110h+inParams.pitch], xmm1
        }
        inParams.aliasList = v10;
        inParams.sndEnt = v13;
        if ( *((_BYTE *)_RBX + 12) )
        {
          v14 = v13 & 0x1FFFFFFFFi64;
          if ( (v13 & 0x1FFFFFFFFi64) - 5411 <= 0x1F || v14 - 2049 <= 0x8FF || v14 <= 0x7FD || v14 - 5571 <= 0x7A120 )
            CG_SND_GetSoundEntityOrientation(v13, (vec3_t *)(_RBX - 2), &axis_out);
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rbx-8]
          vmovss  xmm1, dword ptr [rbx-4]
          vmovss  dword ptr [rsp+110h+inParams.org], xmm0
          vmovss  xmm0, dword ptr [rbx]
          vmovss  dword ptr [rsp+110h+inParams.org+8], xmm0
          vmovss  dword ptr [rsp+110h+inParams.org+4], xmm1
        }
        *((_DWORD *)_RBX - 7) = SND_PlaySoundAliasFromParams(&inParams, 0);
      }
      _RBX += 12;
      --v9;
    }
    while ( v9 );
    if ( !g_snd.updateWasDeferred || deferred )
    {
      _RBX = &g_snd.voices[0].fadeInOut;
      g_snd.updateWasDeferred = deferred;
      voiceBusyUpdating = g_snd.voiceBusyUpdating;
      do
      {
        if ( !SND_IsVoiceFree(v5) && !Sys_InterlockedCompareExchange(voiceBusyUpdating, 1, 0) )
        {
          if ( !*(_QWORD *)&_RBX[-15].goal && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6924, ASSERT_TYPE_ASSERT, "(voice.alias)", (const char *)&queryFormat, "voice.alias", inParams.aliasList, *(_QWORD *)&inParams.aliasId, *(_QWORD *)&inParams.volumeScale, *(_QWORD *)&inParams.pitch, inParams.sndEnt) )
            __debugbreak();
          if ( (*(_BYTE *)(*(_QWORD *)&_RBX[-15].goal + 112i64) & 1) != 0 && (*(_QWORD *)&_RBX[-23].goal & 0x1FFFFFFFFi64) != 2048 && LODWORD(_RBX[-22].value) != g_snd.looptime )
          {
            __asm { vmovaps xmm1, xmm6; g }
            SND_FaderSetGoal(_RBX, *(float *)&_XMM1);
            __asm { vucomiss xmm6, dword ptr [rbx] }
            if ( v22 )
            {
              v23 = j_va("Stopped looping voice %d due to lack of update this frame (looptime %d)", (unsigned int)v5, _RBX[-22].value);
              SND_DebugAliasPrint(1, *(const SndAlias **)&_RBX[-15].goal, v23);
              SND_StopVoiceWithoutLock(v5);
            }
          }
          Sys_InterlockedCompareExchange(voiceBusyUpdating, 0, 1);
        }
        ++v5;
        ++voiceBusyUpdating;
        _RBX += 164;
      }
      while ( v5 < 99 );
    }
    else
    {
      g_snd.updateWasDeferred = 0;
    }
    g_snd.looptime = g_snd.time;
    Sys_LeaveCriticalSection(CRITSECT_SOUND_UPDATE);
    Sys_ProfEndNamedEvent();
    __asm { vmovaps xmm6, [rsp+110h+var_38+8] }
  }
}

/*
==============
SND_UpdateMasterVolumes
==============
*/
void SND_UpdateMasterVolumes(int frametime)
{
  __int64 v6; 
  unsigned int i; 
  const SndGlobals *globals; 
  __int64 v9; 
  int currentChannelPriority; 
  const dvar_t *v12; 
  const dvar_t *v14; 
  __int64 v19; 
  __int64 v20; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vxorps  xmm6, xmm6, xmm6
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
  {
    __asm
    {
      vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.scriptSoundFade.goalrate; snd_local_t g_snd
      vucomiss xmm0, xmm6
    }
  }
  v6 = 0i64;
  for ( i = 0; ; ++i )
  {
    globals = g_snd.globals;
    if ( !g_snd.globals || i >= g_snd.globals->entchannelCount )
      break;
    if ( !g_snd.paused || !SND_IsPausable(i) )
    {
      v9 = i;
      SND_UpdateParameter(&g_snd.levelFadeInChannelVols.channelvol[v9], frametime, 1);
      currentChannelPriority = g_snd.currentChannelPriority;
      if ( g_snd.currentChannelPriority >= 4u )
      {
        LODWORD(v20) = 4;
        LODWORD(v19) = g_snd.currentChannelPriority;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 612, ASSERT_TYPE_ASSERT, "(unsigned)( g_snd.currentChannelPriority ) < (unsigned)( ( sizeof( *array_counter( g_snd.channelPriorityVolGroups ) ) + 0 ) )", "g_snd.currentChannelPriority doesn't index ARRAY_COUNT( g_snd.channelPriorityVolGroups )\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
        currentChannelPriority = g_snd.currentChannelPriority;
      }
      SND_UpdateParameter(&g_snd.channelPriorityVolGroups[currentChannelPriority].channelvol[v9], frametime, 1);
    }
  }
  if ( !g_snd.paused )
  {
    while ( 1 )
    {
      if ( !globals )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 4831, ASSERT_TYPE_ASSERT, "(g_snd.globals)", (const char *)&queryFormat, "g_snd.globals") )
          __debugbreak();
        globals = g_snd.globals;
      }
      if ( (unsigned int)v6 >= globals->volmodinfoCount )
        break;
      SND_UpdateParameter(&g_snd.volmods[v6], frametime, 1);
      globals = g_snd.globals;
      v6 = (unsigned int)(v6 + 1);
    }
  }
  SND_UpdateParameter(&g_snd.mastervol, frametime, 1);
  if ( g_snd.stopSoundsAfterMasterFade )
  {
    __asm
    {
      vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.mastervol.value; snd_local_t g_snd
      vucomiss xmm0, xmm6
    }
    if ( !g_snd.stopSoundsAfterMasterFade )
    {
      g_snd.stopSoundsAfterMasterFade = 0;
      SND_StopSounds(SND_STOP_ALL);
    }
  }
  v12 = DVARBOOL_snd_volume_mute;
  if ( !DVARBOOL_snd_volume_mute && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_volume_mute") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  if ( v12->current.enabled )
  {
    __asm
    {
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.volume, xmm6; snd_local_t g_snd
      vmovaps xmm6, [rsp+68h+var_28]
    }
  }
  else
  {
    v14 = DVARFLT_profileMenuOption_volume;
    if ( !DVARFLT_profileMenuOption_volume && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "profileMenuOption_volume") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    __asm
    {
      vmovss  xmm0, cs:?g_snd@@3Usnd_local_t@@A.mastervol.value; snd_local_t g_snd
      vmulss  xmm1, xmm0, dword ptr [rbx+28h]
      vmovaps xmm6, [rsp+68h+var_28]
      vmulss  xmm1, xmm1, dword ptr [rax+8]
      vmovss  cs:?g_snd@@3Usnd_local_t@@A.volume, xmm1; snd_local_t g_snd
    }
  }
}

/*
==============
SND_UpdateParameter
==============
*/
void SND_UpdateParameter(snd_param_info_t *paramInfo, int dt_msec, bool nonLinear)
{
  bool v9; 
  bool v10; 
  __int64 v20; 

  __asm { vmovaps [rsp+68h+var_18], xmm6 }
  _RBX = paramInfo;
  if ( !paramInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6965, ASSERT_TYPE_ASSERT, "(paramInfo)", (const char *)&queryFormat, "paramInfo") )
    __debugbreak();
  if ( dt_msec < 0 )
  {
    LODWORD(v20) = dt_msec;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 6966, ASSERT_TYPE_ASSERT, "( ( dt_msec >= 0 ) )", "( dt_msec ) = %i", v20) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
  }
  v9 = !nonLinear;
  if ( !nonLinear || (v10 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND), v9 = !v10, v10) )
  {
    __asm
    {
      vmovss  xmm2, dword ptr [rbx+8]
      vcomiss xmm2, xmm6
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, edi
      vmulss  xmm1, xmm0, xmm2
      vaddss  xmm3, xmm1, dword ptr [rbx]
      vmovss  xmm0, dword ptr [rbx+4]
      vmovss  dword ptr [rbx], xmm3
      vcomiss xmm3, xmm0
    }
    if ( !v9 )
    {
      __asm { vmovss  dword ptr [rbx], xmm0 }
      _RBX->goalrate = 0.0;
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+8]
      vucomiss xmm1, xmm6
      vmovss  xmm0, dword ptr [rbx+4]
      vcomiss xmm0, xmm6
      vmovss  dword ptr [rbx], xmm0
    }
    _RBX->goalgain = 0.0;
  }
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
}

/*
==============
SND_UpdatePerChannelMasterSettings
==============
*/
void SND_UpdatePerChannelMasterSettings(const int firstChanIdx, const int lastChanIdx, unsigned __int8 *globalMasterPriorityID, float *globalMasterPriorityVal, float *globalMasterPercentage)
{
  __int64 v8; 
  int v13; 
  bool *v14; 
  float *v15; 
  unsigned __int8 v17; 
  char v18; 
  bool v19; 
  bool v24; 
  const SndVoice *v29; 
  int v30; 
  bool *v33; 
  SndVoice *v34; 
  __int64 v35; 
  __int64 v36; 

  v8 = firstChanIdx;
  if ( (unsigned int)firstChanIdx >= 0x63 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15997, ASSERT_TYPE_ASSERT, "(unsigned)( firstChanIdx ) < (unsigned)( ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) )", "firstChanIdx doesn't index SND_MAX_VOICES\n\t%i not in [0, %i)", firstChanIdx, 99) )
    __debugbreak();
  if ( (unsigned int)lastChanIdx >= 0x64 )
  {
    LODWORD(v36) = 100;
    LODWORD(v35) = lastChanIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15998, ASSERT_TYPE_ASSERT, "(unsigned)( lastChanIdx ) < (unsigned)( ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) + 1 )", "lastChanIdx doesn't index SND_MAX_VOICES + 1\n\t%i not in [0, %i)", v35, v36) )
      __debugbreak();
  }
  if ( !globalMasterPriorityID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15999, ASSERT_TYPE_ASSERT, "(globalMasterPriorityID)", (const char *)&queryFormat, "globalMasterPriorityID") )
    __debugbreak();
  if ( !globalMasterPriorityVal && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16000, ASSERT_TYPE_ASSERT, "(globalMasterPriorityVal)", (const char *)&queryFormat, "globalMasterPriorityVal") )
    __debugbreak();
  _R14 = globalMasterPercentage;
  if ( !globalMasterPercentage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16001, ASSERT_TYPE_ASSERT, "(globalMasterPercentage)", (const char *)&queryFormat, "globalMasterPercentage") )
    __debugbreak();
  v13 = v8;
  if ( (int)v8 < lastChanIdx )
  {
    __asm
    {
      vmovaps [rsp+0A8h+var_68], xmm7
      vmovaps [rsp+0A8h+var_58], xmm6
    }
    v14 = &sdGlob.voiceAlloc[v8];
    v15 = &g_snd.chaninfoUnweightedPriority[492 * v8 - 48680];
    __asm { vxorps  xmm7, xmm7, xmm7 }
    do
    {
      if ( (unsigned int)v13 > 0x62 )
      {
        LODWORD(v35) = v13;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v35) )
          __debugbreak();
      }
      if ( *v14 )
      {
        if ( v15 == (float *)112 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15933, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
          __debugbreak();
        v17 = *(_BYTE *)(*(_QWORD *)v15 + 209i64);
        if ( !*(_QWORD *)v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15972, ASSERT_TYPE_ASSERT, "(voice->alias)", (const char *)&queryFormat, "voice->alias") )
          __debugbreak();
        *(float *)&_XMM0 = SND_CalcVoiceVolume(0, (SndVoice *)(v15 - 28));
        __asm { vmulss  xmm6, xmm0, dword ptr [rbx+104h] }
        _RAX = *(_QWORD *)v15;
        __asm
        {
          vmovss  xmm0, dword ptr [rax+0DCh]
          vcomiss xmm6, xmm0
        }
        if ( v18 )
        {
          __asm { vcomiss xmm0, xmm7 }
          if ( v18 )
          {
            v24 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15983, ASSERT_TYPE_ASSERT, "(voice->alias->masterThreshold >= 0.0f)", (const char *)&queryFormat, "voice->alias->masterThreshold >= 0.0f");
            v18 = 0;
            v19 = !v24;
            if ( v24 )
              __debugbreak();
          }
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vdivss  xmm1, xmm6, dword ptr [rax+0DCh]
            vcvtsi2ss xmm0, xmm0, eax
            vmulss  xmm0, xmm1, xmm0
          }
        }
        else
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
          }
        }
        __asm { vucomiss xmm0, xmm7 }
        if ( !v19 )
        {
          _RSI = globalMasterPriorityVal;
          __asm { vcomiss xmm0, dword ptr [rsi] }
          if ( !(v18 | v19) )
          {
            __asm { vmovss  dword ptr [rsi], xmm0 }
            v29 = (const SndVoice *)(v15 - 28);
            if ( *globalMasterPriorityID == v17 )
            {
              *(double *)&_XMM0 = SND_GetMasterPercent(v29);
              __asm { vcomiss xmm0, dword ptr [r14] }
              if ( !(v18 | v19) )
                __asm { vmovss  dword ptr [r14], xmm0 }
            }
            else
            {
              *globalMasterPriorityID = v17;
              *(double *)&_XMM0 = SND_GetMasterPercent(v29);
              __asm { vmovss  dword ptr [r14], xmm0 }
            }
          }
        }
      }
      ++v13;
      ++v14;
      v15 += 492;
    }
    while ( v13 < lastChanIdx );
    v30 = firstChanIdx;
    __asm
    {
      vmovaps xmm7, [rsp+0A8h+var_68]
      vmovaps xmm6, [rsp+0A8h+var_58]
    }
    if ( firstChanIdx < lastChanIdx )
    {
      v33 = &sdGlob.voiceAlloc[firstChanIdx];
      v34 = &g_snd.voices[firstChanIdx];
      do
      {
        if ( (unsigned int)v30 > 0x62 )
        {
          LODWORD(v35) = v30;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", v35) )
            __debugbreak();
        }
        if ( *v33 )
        {
          if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 15933, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
            __debugbreak();
          if ( v34->alias->masterPriority == *globalMasterPriorityID )
          {
            *(double *)&_XMM0 = SND_GetMasterPercent(v34);
            __asm { vcomiss xmm0, dword ptr [r14] }
            if ( !(v18 | v19) )
              __asm { vmovss  dword ptr [r14], xmm0 }
          }
        }
        ++v30;
        ++v33;
        ++v34;
      }
      while ( v30 < lastChanIdx );
    }
  }
}

/*
==============
SND_UpdateSpeakerMap
==============
*/
void SND_UpdateSpeakerMap(const SndVoice *voice, const SpeakerMap *speakerMap, float *volumes)
{
  __int64 srcChannelCount; 
  bool v6; 
  unsigned int v7; 
  __int64 v8; 
  char *v9; 
  int v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  float *v14; 
  int v15; 
  __int64 v16; 
  unsigned __int64 v17; 
  int v18; 
  float *v19; 
  int v20; 
  int v21; 
  float *v22; 
  __int64 v23; 
  __int64 v24; 

  srcChannelCount = voice->soundFileInfo.srcChannelCount;
  _R12 = volumes;
  _RSI = voice;
  v6 = (voice->alias->flags & 4) != 0;
  if ( g_snd.playback_channels < 16 )
  {
    if ( g_snd.playback_channels < 8 )
    {
      if ( g_snd.playback_channels == 6 )
      {
        v7 = 6;
        if ( (_DWORD)srcChannelCount == 2 )
        {
          v8 = 116i64;
        }
        else
        {
          if ( (_DWORD)srcChannelCount != 1 )
            goto LABEL_23;
          v8 = 92i64;
        }
      }
      else
      {
        if ( g_snd.playback_channels != 2 )
          goto LABEL_23;
        v7 = 2;
        if ( (_DWORD)srcChannelCount == 2 )
        {
          v8 = 76i64;
        }
        else
        {
          if ( (_DWORD)srcChannelCount != 1 )
            goto LABEL_23;
          v8 = 68i64;
        }
      }
    }
    else
    {
      v7 = 8;
      if ( (_DWORD)srcChannelCount == 2 )
      {
        v8 = 196i64;
      }
      else
      {
        if ( (_DWORD)srcChannelCount != 1 )
          goto LABEL_23;
        v8 = 164i64;
      }
    }
LABEL_21:
    v9 = &speakerMap->name[v8];
    if ( &speakerMap->name[v8] )
      goto LABEL_28;
    goto LABEL_26;
  }
  v7 = 16;
  if ( (_DWORD)srcChannelCount == 2 )
  {
    v8 = 324i64;
    goto LABEL_21;
  }
  if ( (_DWORD)srcChannelCount == 1 )
  {
    v8 = 260i64;
    goto LABEL_21;
  }
LABEL_23:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 14967, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid audio channel count") )
    __debugbreak();
  v7 = 0;
  v9 = NULL;
LABEL_26:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12371, ASSERT_TYPE_ASSERT, "(speakerLevels)", (const char *)&queryFormat, "speakerLevels") )
    __debugbreak();
LABEL_28:
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12372, ASSERT_TYPE_ASSERT, "(outChannels > 0)", (const char *)&queryFormat, "outChannels > 0") )
    __debugbreak();
  if ( (int)(srcChannelCount * v7) > 32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12373, ASSERT_TYPE_ASSERT, "(inChannels*outChannels <= ((( 2 ))*(( 16 ))))", (const char *)&queryFormat, "inChannels*outChannels <= SPEAKER_ARRAY_SIZE") )
    __debugbreak();
  v10 = 0;
  v11 = v7;
  v12 = srcChannelCount;
  if ( v7 )
  {
    v13 = 0i64;
    v14 = _R12 + 32;
    do
    {
      v15 = 0;
      v16 = 0i64;
      if ( v12 >= 4 )
      {
        v17 = ((unsigned __int64)(v12 - 4) >> 2) + 1;
        v18 = v10 + 2 * v7;
        v19 = v14;
        v15 = 4 * v17;
        v16 = 4 * v17;
        do
        {
          v19 += 64;
          *(v19 - 96) = *(float *)&v9[4 * (v18 - 2 * v7)];
          *(v19 - 80) = *(float *)&v9[4 * (v18 - v7)];
          v20 = v18 + v7;
          *(v19 - 64) = *(float *)&v9[4 * v18];
          v18 += 4 * v7;
          *(v19 - 48) = *(float *)&v9[4 * v20];
          --v17;
        }
        while ( v17 );
        _R12 = volumes;
        v11 = v7;
      }
      if ( v16 < v12 )
      {
        v21 = v10 + v7 * v15;
        v22 = &_R12[16 * v16 + v13];
        v23 = v12 - v16;
        do
        {
          v24 = v21;
          v22 += 16;
          v21 += v7;
          *(v22 - 16) = *(float *)&v9[4 * v24];
          --v23;
        }
        while ( v23 );
      }
      ++v10;
      ++v13;
      ++v14;
    }
    while ( v13 < v11 );
    _RSI = voice;
    LODWORD(srcChannelCount) = v12;
  }
  if ( v7 > 2 )
  {
    if ( v6 )
    {
      _RAX = _RSI->alias;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+78h]
        vmulss  xmm1, xmm0, dword ptr [rsi+0FCh]
        vmovss  dword ptr [r12+0Ch], xmm1
      }
      if ( (_DWORD)srcChannelCount == 2 )
      {
        _RAX = _RSI->alias;
        __asm
        {
          vmovss  xmm0, dword ptr [rax+78h]
          vmulss  xmm1, xmm0, dword ptr [rsi+0FCh]
          vmovss  dword ptr [r12+4Ch], xmm1
        }
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rsi+0FCh]
        vmulss  xmm1, xmm0, dword ptr [r12+0Ch]
        vmovss  dword ptr [r12+0Ch], xmm1
      }
      if ( (_DWORD)srcChannelCount == 2 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rsi+0FCh]
          vmulss  xmm1, xmm0, dword ptr [r12+4Ch]
          vmovss  dword ptr [r12+4Ch], xmm1
        }
      }
    }
  }
}

/*
==============
SND_UpdateVehicle
==============
*/
void SND_UpdateVehicle(const SndAliasList *aliasList, LocalClientNum_t localClientNum, int entNum, vec3_t *origin, float throttle, float brake)
{
  unsigned int v14; 
  int v15; 
  bool *v16; 
  unsigned int *p_playbackId; 
  int timeshift; 
  __int64 system; 
  ScopedCriticalSection v29; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  ScopedCriticalSection::ScopedCriticalSection(&v29, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  v14 = SND_PlaySoundAlias(aliasList, localClientNum, entNum, origin, 0, SASYS_CGAME);
  if ( v14 )
  {
    v15 = 94;
    v16 = &sdGlob.voiceAlloc[94];
    p_playbackId = &g_snd.voices[94].playbackId;
    __asm
    {
      vmovss  xmm7, [rsp+0C8h+arg_28]
      vmovss  xmm8, [rsp+0C8h+arg_20]
      vxorps  xmm6, xmm6, xmm6
    }
    do
    {
      if ( (unsigned int)v15 > 0x62 )
      {
        LODWORD(system) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", system) )
          __debugbreak();
      }
      if ( *v16 && *p_playbackId == v14 )
      {
        __asm
        {
          vmovss  [rsp+0C8h+timeshift], xmm6
          vmovaps xmm3, xmm6; rpm
          vmovaps xmm2, xmm7; brake
          vmovaps xmm1, xmm8; throttle
        }
        SD_UpdateVehicle(v15, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, *(float *)&timeshift, 0, 1);
      }
      ++v15;
      p_playbackId += 492;
      ++v16;
    }
    while ( v15 < 99 );
  }
  ScopedCriticalSection::~ScopedCriticalSection(&v29);
  __asm
  {
    vmovaps xmm6, [rsp+0C8h+var_48]
    vmovaps xmm7, [rsp+0C8h+var_58]
    vmovaps xmm8, [rsp+0C8h+var_68]
  }
}

/*
==============
SND_UpdateVehicle
==============
*/
void SND_UpdateVehicle(const SndAliasList *aliasList, LocalClientNum_t localClientNum, int entNum, vec3_t *origin, float throttle, float brake, float rpm, float velocity, int gear, float distanceScale)
{
  unsigned int v27; 
  int v28; 
  bool *v29; 
  unsigned int *p_playbackId; 
  float fmt; 
  __int64 geara; 
  ScopedCriticalSection v45; 
  SndPlayParams inParams; 
  char v47; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _R14 = origin;
  ScopedCriticalSection::ScopedCriticalSection(&v45, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  inParams.aliasId = 0;
  inParams.playbackType = SPT_BLEND;
  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rsp+160h+inParams.volumeScale], xmm0
  }
  inParams.sndEnt = 0i64;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovss  dword ptr [rbp+60h+inParams.org], xmm1
    vmovss  dword ptr [rbp+60h+inParams.org+4], xmm1
    vmovss  dword ptr [rbp+60h+inParams.org+8], xmm1
  }
  inParams.timeshift = 0;
  inParams.adsrIndex = -1;
  inParams.fadeTime = 0;
  inParams.system = SASYS_CGAME;
  inParams.autoSimId = -1;
  inParams.autoSimTimeStamp = 0i64;
  inParams.autoSimShotCount = SND_WEAP_SHOT_UNCOUNTED;
  inParams.startPaused = 0;
  __asm
  {
    vmovss  xmm0, cs:__real@bf800000
    vmovss  [rbp+60h+inParams.lpfCutoff], xmm0
    vmovss  [rbp+60h+inParams.hpfCutoff], xmm0
    vmovss  [rbp+60h+inParams.startOffsetFraction], xmm1
  }
  inParams.additionalStartDelayUs = 0;
  *(_QWORD *)&inParams.surfaceType = -1i64;
  inParams.contextIndex2 = -1;
  inParams.reflectionClass = 0;
  *(_WORD *)&inParams.isADS = 0;
  inParams.aliasList = aliasList;
  inParams.sndEnt = CG_GenerateSndEntHandle(localClientNum, entNum);
  __asm
  {
    vmovss  xmm0, dword ptr [r14]
    vmovss  dword ptr [rbp+60h+inParams.org], xmm0
    vmovss  xmm1, dword ptr [r14+4]
    vmovss  dword ptr [rbp+60h+inParams.org+4], xmm1
    vmovss  xmm0, dword ptr [r14+8]
    vmovss  dword ptr [rbp+60h+inParams.org+8], xmm0
  }
  inParams.timeshift = 0;
  __asm
  {
    vmovss  xmm1, [rbp+60h+arg_48]
    vmovss  [rsp+160h+inParams.distanceScale], xmm1
  }
  inParams.system = SASYS_CGAME;
  v27 = SND_PlaySoundAliasFromParams(&inParams, 0);
  if ( v27 )
  {
    v28 = 94;
    v29 = &sdGlob.voiceAlloc[94];
    p_playbackId = &g_snd.voices[94].playbackId;
    __asm
    {
      vmovss  xmm6, [rbp+60h+arg_38]
      vmovss  xmm7, [rbp+60h+arg_30]
      vmovss  xmm8, [rbp+60h+arg_28]
      vmovss  xmm9, [rbp+60h+arg_20]
    }
    do
    {
      if ( (unsigned int)v28 > 0x62 )
      {
        LODWORD(geara) = v28;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 1119, ASSERT_TYPE_ASSERT, "( ( index >= 0 && index < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) ) )", "( index ) = %i", geara) )
          __debugbreak();
      }
      if ( *v29 && *p_playbackId == v27 )
      {
        __asm
        {
          vmovss  dword ptr [rsp+160h+fmt], xmm6
          vmovaps xmm3, xmm7; rpm
          vmovaps xmm2, xmm8; brake
          vmovaps xmm1, xmm9; throttle
        }
        SD_UpdateVehicle(v28, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmt, gear, 0);
      }
      ++v28;
      p_playbackId += 492;
      ++v29;
    }
    while ( v28 < 99 );
  }
  ScopedCriticalSection::~ScopedCriticalSection(&v45);
  _R11 = &v47;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
SND_UpdateVirtualLoopSound
==============
*/

__int64 __fastcall SND_UpdateVirtualLoopSound(int handle, const vec3_t *org, double volume, double pitch)
{
  int v10; 
  unsigned __int8 v12; 
  __int64 result; 
  ScopedCriticalSection v19; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps xmm6, xmm3
    vmovaps xmm7, xmm2
  }
  _RDI = org;
  ScopedCriticalSection::ScopedCriticalSection(&v19, CRITSECT_SOUND_UPDATE, SCOPED_CRITSECT_NORMAL);
  v10 = 0;
  _RAX = g_snd.virtualLoops;
  while ( _RAX->handle != handle )
  {
    ++v10;
    if ( (__int64)++_RAX >= (__int64)&g_snd.nextVirtualLoopHandle )
    {
      Com_PrintError(9, "SND_UpdateVirtualLoopSound: Handle %d not found.\n", (unsigned int)handle);
      v12 = 0;
      goto LABEL_6;
    }
  }
  __asm
  {
    vmovss  dword ptr [rax+24h], xmm7
    vmovss  dword ptr [rax+28h], xmm6
  }
  _RCX = &g_snd.virtualLoops[v10].org;
  _RCX->v[0] = _RDI->v[0];
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4]
    vmovss  dword ptr [rcx+4], xmm0
    vmovss  xmm1, dword ptr [rdi+8]
    vmovss  dword ptr [rcx+8], xmm1
  }
  v12 = 1;
LABEL_6:
  ScopedCriticalSection::~ScopedCriticalSection(&v19);
  result = v12;
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
  return result;
}

/*
==============
SND_UpdateVoicePosition
==============
*/
void SND_UpdateVoicePosition(SndVoice *voice, SecureVec3 *outVoicePosition, tmat33_t<vec3_t> *outVoiceMatrix)
{
  SndEntState *EntState; 
  const tmat33_t<vec3_t> *v7; 
  int v32; 
  int v33; 
  int v34; 

  _RBX = outVoicePosition;
  _RBP = voice;
  EntState = SND_FindEntState(voice->sndEnt, 0);
  v7 = (const tmat33_t<vec3_t> *)EntState;
  if ( EntState && EntState->hasPosition )
  {
    SndEntState_GetOrigin(EntState, (vec3_t *)_RBX);
    AxisCopy(v7 + 2, outVoiceMatrix);
  }
  else
  {
    *(_QWORD *)&_RBX->x = 0i64;
    _RBX->z = 0.0;
    AxisClear(outVoiceMatrix);
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  [rsp+38h+arg_0], xmm0
  }
  if ( (v32 & 0x7F800000) == 2139095040 )
    goto LABEL_13;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  [rsp+38h+arg_0], xmm0
  }
  if ( (v33 & 0x7F800000) == 2139095040 )
    goto LABEL_13;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+8]
    vmovss  [rsp+38h+arg_0], xmm0
  }
  if ( (v34 & 0x7F800000) == 2139095040 )
  {
LABEL_13:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 12527, ASSERT_TYPE_SANITY, "( !IS_NAN( ( outVoicePosition )[0] ) && !IS_NAN( ( outVoicePosition )[1] ) && !IS_NAN( ( outVoicePosition )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( outVoicePosition )[0] ) && !IS_NAN( ( outVoicePosition )[1] ) && !IS_NAN( ( outVoicePosition )[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm2, dword ptr [rbp+98h]
    vmulss  xmm0, xmm2, dword ptr [rsi]
    vaddss  xmm3, xmm0, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm3
    vmulss  xmm0, xmm2, dword ptr [rsi+4]
    vaddss  xmm1, xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rbx+4], xmm1
    vmulss  xmm0, xmm2, dword ptr [rsi+8]
    vaddss  xmm1, xmm0, dword ptr [rbx+8]
    vmovss  dword ptr [rbx+8], xmm1
    vmovss  xmm2, dword ptr [rbp+9Ch]
    vmulss  xmm0, xmm2, dword ptr [rsi+0Ch]
    vaddss  xmm3, xmm0, xmm3
    vmovss  dword ptr [rbx], xmm3
    vmulss  xmm0, xmm2, dword ptr [rsi+10h]
    vaddss  xmm1, xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rbx+4], xmm1
    vmulss  xmm0, xmm2, dword ptr [rsi+14h]
    vaddss  xmm1, xmm0, dword ptr [rbx+8]
    vmovss  dword ptr [rbx+8], xmm1
    vmovss  xmm2, dword ptr [rbp+0A0h]
    vmulss  xmm0, xmm2, dword ptr [rsi+18h]
    vaddss  xmm1, xmm0, xmm3
    vmovss  dword ptr [rbx], xmm1
    vmulss  xmm0, xmm2, dword ptr [rsi+1Ch]
    vaddss  xmm1, xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rbx+4], xmm1
    vmulss  xmm0, xmm2, dword ptr [rsi+20h]
    vaddss  xmm1, xmm0, dword ptr [rbx+8]
    vmovss  dword ptr [rbx+8], xmm1
  }
  SndVoice_SetOrigin(_RBP, (const vec3_t *)_RBX);
  _RBP->orientation.v[0] = outVoiceMatrix->m[0].v[0];
  _RBP->orientation.v[1] = outVoiceMatrix->m[0].v[1];
  _RBP->orientation.v[2] = outVoiceMatrix->m[0].v[2];
}

/*
==============
SND_VoiceSetStartSync
==============
*/

void __fastcall SND_VoiceSetStartSync(SndVoice *voice, bool startSync, double syncPeriodFrames, int meter, int offsetFrames, int delayBeats, int fadeBeats)
{
  signed __int64 v12; 
  unsigned int i; 
  SndVoice *PlaybackVoice; 
  SndVoice *v16; 
  __int64 v17; 

  __asm
  {
    vmovaps [rsp+78h+var_38], xmm6
    vmovaps xmm6, xmm2
  }
  if ( !voice && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16144, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
    __debugbreak();
  v12 = voice - g_snd.voices;
  if ( (int)v12 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16149, ASSERT_TYPE_ASSERT, "(voiceIndex >= 0)", (const char *)&queryFormat, "voiceIndex >= 0") )
    __debugbreak();
  if ( (int)v12 >= 99 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16150, ASSERT_TYPE_ASSERT, "(voiceIndex < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "voiceIndex < SND_MAX_VOICES") )
    __debugbreak();
  __asm { vmovaps xmm2, xmm6; syncPeriodFrames }
  SD_SetVoiceStartSync(v12, startSync, *(float *)&_XMM2, meter, offsetFrames, delayBeats, fadeBeats);
  for ( i = voice->secondaryId; i; i = v16->secondaryId )
  {
    PlaybackVoice = SND_GetPlaybackVoice(i);
    v16 = PlaybackVoice;
    if ( !PlaybackVoice )
      break;
    v17 = PlaybackVoice - g_snd.voices;
    if ( (int)v17 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16171, ASSERT_TYPE_ASSERT, "(secondaryVoiceIndex >= 0)", (const char *)&queryFormat, "secondaryVoiceIndex >= 0") )
      __debugbreak();
    if ( (int)v17 >= 99 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16172, ASSERT_TYPE_ASSERT, "(secondaryVoiceIndex < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "secondaryVoiceIndex < SND_MAX_VOICES") )
      __debugbreak();
    __asm { vmovaps xmm2, xmm6; syncPeriodFrames }
    SD_SetVoiceStartSync(v17, startSync, *(float *)&_XMM2, meter, offsetFrames, delayBeats, fadeBeats);
  }
  __asm { vmovaps xmm6, [rsp+78h+var_38] }
}

/*
==============
SND_VoiceSetStopSync
==============
*/
void SND_VoiceSetStopSync(SndVoice *voice, bool stopSync, int delayBeats, int fadeBeats)
{
  int v8; 
  unsigned int i; 
  SndVoice *PlaybackVoice; 
  SndVoice *v11; 
  __int64 v12; 

  if ( !voice && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16195, ASSERT_TYPE_ASSERT, "(voice)", (const char *)&queryFormat, "voice") )
    __debugbreak();
  v8 = truncate_cast<int,__int64>(voice - g_snd.voices);
  if ( v8 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16200, ASSERT_TYPE_ASSERT, "(voiceIndex >= 0)", (const char *)&queryFormat, "voiceIndex >= 0") )
    __debugbreak();
  if ( v8 >= 99 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16201, ASSERT_TYPE_ASSERT, "(voiceIndex < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "voiceIndex < SND_MAX_VOICES") )
    __debugbreak();
  SD_SetVoiceStopSync(v8, stopSync, delayBeats, fadeBeats);
  for ( i = voice->secondaryId; i; i = v11->secondaryId )
  {
    PlaybackVoice = SND_GetPlaybackVoice(i);
    v11 = PlaybackVoice;
    if ( !PlaybackVoice )
      break;
    v12 = PlaybackVoice - g_snd.voices;
    if ( (unsigned __int64)(v12 + 0x80000000i64) > 0xFFFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,__int64>(__int64)", "signed", (int)v12, "signed", v12) )
      __debugbreak();
    if ( (int)v12 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16219, ASSERT_TYPE_ASSERT, "(secondaryVoiceIndex >= 0)", (const char *)&queryFormat, "secondaryVoiceIndex >= 0") )
      __debugbreak();
    if ( (int)v12 >= 99 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 16220, ASSERT_TYPE_ASSERT, "(secondaryVoiceIndex < ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ))", (const char *)&queryFormat, "secondaryVoiceIndex < SND_MAX_VOICES") )
      __debugbreak();
    SD_SetVoiceStopSync(v12, stopSync, delayBeats, fadeBeats);
  }
}

/*
==============
SND_VoiceUpdateWorker
==============
*/
void SND_VoiceUpdateWorker(const void *const cmdInfo)
{
  __int64 v1; 
  __int64 v2; 
  volatile signed __int32 *v4; 

  v1 = *((int *)cmdInfo + 1);
  v2 = v1;
  v4 = &g_snd.voiceBusyUpdating[v1];
  do
  {
    if ( (((unsigned __int8)((unsigned __int8)&g_snd + 4 * v1) + 28) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.voiceBusyUpdating[v1]) )
      __debugbreak();
  }
  while ( _InterlockedCompareExchange(v4, 1, 0) == 1 );
  if ( *(_DWORD *)cmdInfo == g_snd.voices[v2].playbackId && *(_DWORD *)cmdInfo && !g_snd.voices[v2].paused )
    SND_UpdateAndStartVoice(v1, *((_DWORD *)cmdInfo + 2));
  if ( (((unsigned __int8)((unsigned __int8)&g_snd + 4 * v1) + 28) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &g_snd.voiceBusyUpdating[v1]) )
    __debugbreak();
  _InterlockedCompareExchange(v4, 0, 1);
}

/*
==============
EntityDebugDrawOffset::SetOffset
==============
*/
void EntityDebugDrawOffset::SetOffset(EntityDebugDrawOffset *this, unsigned __int64 entIndex, int offset)
{
  int v4; 
  int numEntIndices; 
  EntityDebugDrawOffset *v8; 
  int v9; 
  int v10; 

  v4 = 0;
  numEntIndices = this->numEntIndices;
  if ( numEntIndices <= 0 )
  {
LABEL_5:
    if ( (unsigned int)numEntIndices >= 0x63 )
    {
      v10 = 99;
      v9 = numEntIndices;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\snd\\snd.cpp", 300, ASSERT_TYPE_ASSERT, "(unsigned)( numEntIndices ) < (unsigned)( ( 48 + ( SND_TRACK_COUNT + 10 ) + 32 + 5 ) )", "numEntIndices doesn't index SND_MAX_VOICES\n\t%i not in [0, %i)", v9, v10) )
        __debugbreak();
    }
    this->entIndices[this->numEntIndices] = entIndex;
    this->offsets[this->numEntIndices++] = offset;
  }
  else
  {
    v8 = this;
    while ( v8->entIndices[0] != entIndex )
    {
      ++v4;
      v8 = (EntityDebugDrawOffset *)((char *)v8 + 8);
      if ( v4 >= numEntIndices )
        goto LABEL_5;
    }
    this->offsets[v4] = offset;
  }
}

