/*
==============
RBT_DV_CreateClearMaterialDebugInfo
==============
*/

void __fastcall RBT_DV_CreateClearMaterialDebugInfo(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_CreateClearMaterialDebugInfo@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_CreateClearCountsAndIndices
==============
*/

void __fastcall RBT_DV_CreateClearCountsAndIndices(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_CreateClearCountsAndIndices@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_PipelineIndirectArgs
==============
*/

void __fastcall RBT_DV_PipelineIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineIndirectArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_PipelineGenerateClusteringData
==============
*/

void __fastcall RBT_DV_PipelineGenerateClusteringData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineGenerateClusteringData@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DV_PipelineCullingPart0IndirectArgs<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineCullingPart0IndirectArgs<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DV_PipelineCullingPart0IndirectArgs@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_DV_PipelineCullingPart1
==============
*/

void __fastcall RBT_DV_PipelineCullingPart1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineCullingPart1@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_FillCluster_Part1
==============
*/

void __fastcall RBT_DV_FillCluster_Part1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_FillCluster_Part1@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_PipelineGenerateMaterialDebugInfo
==============
*/

void __fastcall RBT_DV_PipelineGenerateMaterialDebugInfo(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineGenerateMaterialDebugInfo@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DV_PipelineIndirectArgs<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineIndirectArgs<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  return ??$cRBT_DV_PipelineIndirectArgs@UR_TG_Handle@@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
RBT_DV_PipelineCullingPart0IndirectArgs
==============
*/

void __fastcall RBT_DV_PipelineCullingPart0IndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineCullingPart0IndirectArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_FillCluster_Part2
==============
*/

void __fastcall RBT_DV_FillCluster_Part2(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_FillCluster_Part2@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DV_CreatePipelineBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_CreatePipelineBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  return ??$cRBT_DV_CreatePipelineBuffers@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBT_DV_PipelineGenerateClusteringData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineGenerateClusteringData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_DV_PipelineGenerateClusteringData@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
cRBT_DV_PipelineCopyDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineCopyDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>)
{
  return ??$cRBT_DV_PipelineCopyDebugInfo@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>);
}

/*
==============
RBTD_DV_Show3DDebug
==============
*/

void __fastcall RBTD_DV_Show3DDebug(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DV_Show3DDebug@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_PipelineGenerateDrawData
==============
*/

void __fastcall RBT_DV_PipelineGenerateDrawData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineGenerateDrawData@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_PipelineStreamingData
==============
*/

void __fastcall RBT_DV_PipelineStreamingData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineStreamingData@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
R_TG_DV_Pipeline
==============
*/

void __fastcall R_TG_DV_Pipeline(R_TG_Script *pScript, bool floatZOcclusionCulling, bool floatZStreamOcclusionCulling, bool decalVolumeDebug, R_TG_Handle nullBuffer, R_TG_Handle nullRwBuffer, R_TG_Handle nullTexture, R_TG_Handle floatZ, R_TG_Handle *outDecalsClusterData, R_TG_Handle *outDecalsDrawData, R_TG_Handle *outDecalsCount, R_TG_Handle *outDecalIndirectArgs, R_TG_Handle *outCullDecalsCountBuffer, R_TG_Handle *outCullStaticIndicesBuffer, R_TG_Handle *outCullImpactMarkIndicesBuffer, R_TG_Handle *outStaticDecals, R_TG_Handle *outStaticDecalsMapIndex, R_TG_Handle syncToken)
{
  ?R_TG_DV_Pipeline@@YAXPEAUR_TG_Script@@_N11UR_TG_Handle@@222AEAU2@333333332@Z(pScript, floatZOcclusionCulling, floatZStreamOcclusionCulling, decalVolumeDebug, nullBuffer, nullRwBuffer, nullTexture, floatZ, outDecalsClusterData, outDecalsDrawData, outDecalsCount, outDecalIndirectArgs, outCullDecalsCountBuffer, outCullStaticIndicesBuffer, outCullImpactMarkIndicesBuffer, outStaticDecals, outStaticDecalsMapIndex, syncToken);
}

/*
==============
cRBT_DV_PipelineGenerateDrawData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineGenerateDrawData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_DV_PipelineGenerateDrawData@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
cRBT_DV_PipelineCullingPart1<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineCullingPart1<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  return ??$cRBT_DV_PipelineCullingPart1@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
cRBTD_DV_Show3DDebug<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_DV_Show3DDebug<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  return ??$cRBTD_DV_Show3DDebug@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
cRBT_DV_FillCluster_Part2<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_FillCluster_Part2<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DV_FillCluster_Part2@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_DV_PipelineStreamingDataTransfer<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineStreamingDataTransfer<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_DV_PipelineStreamingDataTransfer@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_DV_PipelineClearBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineClearBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  return ??$cRBT_DV_PipelineClearBuffers@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
RBT_DV_PipelineCopyDebugInfo
==============
*/

void __fastcall RBT_DV_PipelineCopyDebugInfo(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineCopyDebugInfo@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DV_PipelineCullingPart0<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineCullingPart0<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DV_PipelineCullingPart0@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_DV_PipelineGenerateMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineGenerateMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>)
{
  return ??$cRBT_DV_PipelineGenerateMaterialDebugInfo@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>);
}

/*
==============
RBT_DV_PipelineClearBuffers
==============
*/

void __fastcall RBT_DV_PipelineClearBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineClearBuffers@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_DV_PipelineCullingPart2
==============
*/

void __fastcall RBT_DV_PipelineCullingPart2(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineCullingPart2@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
R_TGS_DV_FillCluster
==============
*/

void __fastcall R_TGS_DV_FillCluster(R_TG_Script *pScript, bool reserveOnly, bool asyncQueue, bool floatZOcclusionCulling, bool floatZStreamOcclusionCulling, bool decalVolumeDebug, R_TG_Handle nullBuffer, R_TG_Handle nullRwBuffer, R_TG_Handle nullTexture, R_TG_Handle floatZ, R_TG_Handle *outDecalIndices, R_TG_Handle *outDecalDrawData, R_TG_Handle *outDecalDebugData, R_TG_Handle *outDecalIndirectArgs, R_TG_Handle syncToken)
{
  ?R_TGS_DV_FillCluster@@YAXPEAUR_TG_Script@@_N1111UR_TG_Handle@@222AEAU2@3332@Z(pScript, reserveOnly, asyncQueue, floatZOcclusionCulling, floatZStreamOcclusionCulling, decalVolumeDebug, nullBuffer, nullRwBuffer, nullTexture, floatZ, outDecalIndices, outDecalDrawData, outDecalDebugData, outDecalIndirectArgs, syncToken);
}

/*
==============
RBT_DV_PipelineStreamingDataTransfer
==============
*/

void __fastcall RBT_DV_PipelineStreamingDataTransfer(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineStreamingDataTransfer@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DV_CreateClearMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_CreateClearMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DV_CreateClearMaterialDebugInfo@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_DV_PipelineCullingPart0
==============
*/

void __fastcall RBT_DV_PipelineCullingPart0(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DV_PipelineCullingPart0@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DV_PipelineStreamingData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineStreamingData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  return ??$cRBT_DV_PipelineStreamingData@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_DV_PipelineCullingPart2<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DV_PipelineCullingPart2<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_DV_PipelineCullingPart2@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBTD_DV_Show3DDebug<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_DV_Show3DDebug<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBTD_DV_Show3DDebug.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
cRBT_DV_CreateClearMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_CreateClearMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_CreateClearMaterialDebugInfo.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_CreatePipelineBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_CreatePipelineBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DV_CreatePipelineBuffers.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBT_DV_FillCluster_Part2<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_FillCluster_Part2<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_FillCluster_Part2.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_PipelineClearBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineClearBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DV_PipelineClearBuffers.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_DV_PipelineCopyDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineCopyDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DV_PipelineCopyDebugInfo.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>);
}

/*
==============
cRBT_DV_PipelineCullingPart0<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineCullingPart0<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_PipelineCullingPart0.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_PipelineCullingPart0IndirectArgs<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineCullingPart0IndirectArgs<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_PipelineCullingPart0IndirectArgs.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_PipelineCullingPart1<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineCullingPart1<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DV_PipelineCullingPart1.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
cRBT_DV_PipelineCullingPart2<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineCullingPart2<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_PipelineCullingPart2.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_PipelineGenerateClusteringData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineGenerateClusteringData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_PipelineGenerateClusteringData.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_PipelineGenerateDrawData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineGenerateDrawData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_PipelineGenerateDrawData.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_PipelineGenerateMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineGenerateMaterialDebugInfo<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DV_PipelineGenerateMaterialDebugInfo.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>);
}

/*
==============
cRBT_DV_PipelineIndirectArgs<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineIndirectArgs<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v11; 
  unsigned int v12; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_PipelineIndirectArgs.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v11 = stack.handleArgCount + 1;
  stack.handleArgCount = v11;
  if ( (unsigned int)v11 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v11 = stack.handleArgCount;
  }
  stack.handleArgs[v11] = &<args_2>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_3>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_DV_PipelineStreamingData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineStreamingData<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DV_PipelineStreamingData.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>);
}

/*
==============
cRBT_DV_PipelineStreamingDataTransfer<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DV_PipelineStreamingDataTransfer<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_PipelineStreamingDataTransfer.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBTD_DV_Show3DDebug
==============
*/
void RBTD_DV_Show3DDebug(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *v9; 
  R_RT_Image *blackImage; 
  R_RT_Image *p_m_image; 
  R_RT_Image *v18; 
  R_RT_Image *v21; 
  R_RT_Handle v27; 
  R_RT_DepthHandle v28; 
  R_RT_ColorHandle v29; 
  const GfxWrappedBuffer *v30; 
  const GfxWrappedRWBuffer *WrappedBuffer; 

  _R13 = gfxContext;
  _RBP = taskInfo;
  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
  v9 = R_RT_Handle::GetWrappedBuffer(_RBP->attachments + 1);
  _R10 = _RBP->attachments;
  blackImage = (R_RT_Image *)rgp.blackImage;
  v30 = v9;
  __asm
  {
    vmovups ymm0, ymmword ptr [r10+40h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+0F8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_ECX )
  {
    R_RT_Handle::GetSurface(&v27);
    blackImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = _RBP->attachments;
  p_m_image = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+60h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+0F8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RCX )
  {
    R_RT_Handle::GetSurface(&v27);
    p_m_image = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = _RBP->attachments;
  v18 = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+80h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+0F8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RCX )
  {
    R_RT_Handle::GetSurface(&v27);
    v18 = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  _RCX = _RBP->attachments;
  v21 = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+0A0h]
    vmovd   r8d, xmm0
    vmovups ymmword ptr [rsp+0F8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_ER8 )
  {
    R_RT_Handle::GetSurface(&v27);
    v21 = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+0B8h]
    vmovups ymm1, ymmword ptr [rbp+38h]
    vmovups [rsp+0F8h+var_78], ymm0
    vmovups xmm0, xmmword ptr [r13+0]
    vmovups [rsp+0F8h+var_58], ymm1
    vmovups xmmword ptr [rsp+0F8h+var_98.m_surfaceID], xmm0
  }
  R_DecalVolumes_Show3DDebug((GfxCmdBufContext *)&v27, viewInfo, data, &v29, &v28, WrappedBuffer, v30, &blackImage->m_base, &v18->m_base, &p_m_image->m_base, &v21->m_base, 1);
}

/*
==============
RBT_DV_CreateClearCountsAndIndices
==============
*/
void RBT_DV_CreateClearCountsAndIndices(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int DecalCount; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  unsigned int NumClusteringPasses; 
  const DecalVolumeClusteringPass *ClusteringPass; 
  unsigned int v11; 
  const GfxWrappedRWBuffer *v12; 
  __int64 v13; 
  __int64 v14; 
  const R_RT_Surface *Surface; 

  DecalCount = R_DecalVolumes_GetDecalCount(data);
  R_DecalVolume_CalculateClusterResolutionPerPass(viewInfo->sceneViewport.width, viewInfo->sceneViewport.height);
  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
  NumClusteringPasses = R_DecalVolume_GetNumClusteringPasses();
  ClusteringPass = R_DecalVolume_GetClusteringPass(NumClusteringPasses - 1);
  R_DecalVolume_ClearClusterHeader(computeState, ClusteringPass->nCellsX * ClusteringPass->nCellsY * ClusteringPass->nCellsZ, WrappedBuffer);
  if ( DecalCount )
  {
    v11 = R_DecalVolume_GetNumClusteringPasses();
    v12 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    R_DecalVolume_ClearBuffer(computeState, v12, 0x18u, 0);
    if ( v11 > 1 )
    {
      v13 = 2i64;
      v14 = v11 - 1;
      do
      {
        Surface = R_RT_Handle::GetSurface(&taskInfo->attachments[v13]);
        if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        R_DecalVolume_ClearBuffer(computeState, (const GfxWrappedRWBuffer *)&Surface->1080, 0x1Cu, 0);
        ++v13;
        --v14;
      }
      while ( v14 );
    }
  }
}

/*
==============
RBT_DV_CreateClearMaterialDebugInfo
==============
*/
void RBT_DV_CreateClearMaterialDebugInfo(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v8; 

  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
  v8 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
  if ( R_DecalVolumes_GetDecalCount(data) )
    R_DecalVolume_PipelineClearMaterialInfoBuffers(computeState, WrappedBuffer, v8);
}

/*
==============
RBT_DV_FillCluster_Part1
==============
*/
void RBT_DV_FillCluster_Part1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  unsigned int NumClusteringPasses; 
  R_RT_Handle *attachments; 
  unsigned int v14; 
  bool lastPass; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v17; 
  const GfxWrappedRWBuffer *v18; 
  R_RT_Handle *v19; 
  unsigned int maxCellIndirectionsPerBucket; 
  const DecalVolumeClusteringPass *ClusteringPass; 
  const GfxWrappedRWBuffer *v22; 
  R_RT_Handle *v23; 
  const GfxWrappedRWBuffer *v24; 
  R_RT_Handle *v25; 
  const GfxWrappedRWBuffer *v26; 
  R_RT_Handle *v27; 
  const GfxWrappedRWBuffer *v28; 
  R_RT_Handle *v29; 
  DecalVolumeFillClusterResourcePtrs fcrp; 
  DecalVolumeCsConstants clusterConstantsTmp; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    v9 = *taskInfo->pTaskData;
    NumClusteringPasses = R_DecalVolume_GetNumClusteringPasses();
    attachments = taskInfo->attachments;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vpxor   xmm1, xmm1, xmm1
    }
    v14 = NumClusteringPasses - 1;
    __asm { vmovdqu xmmword ptr [rsp+3C8h+var_388.outCellIndirection], xmm0 }
    lastPass = v9 == NumClusteringPasses - 1;
    fcrp.inClusteringData = NULL;
    fcrp.inClusteringDataCount = NULL;
    __asm
    {
      vmovdqu xmmword ptr [rsp+3C8h+var_388.inDecalIndices], xmm1
      vmovdqu xmmword ptr [rsp+3C8h+var_388.inCellIndirectionCount], xmm0
    }
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(attachments);
    v17 = taskInfo->attachments + 1;
    fcrp.outDecalIndices = WrappedBuffer;
    fcrp.outDecalIndicesCount = R_RT_Handle::GetWrappedBuffer(v17);
    if ( v9 != v14 )
    {
      v18 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 2);
      v19 = taskInfo->attachments + 3;
      fcrp.outCellIndirection = v18;
      fcrp.outCellIndirectionCount = R_RT_Handle::GetWrappedBuffer(v19);
    }
    R_DecalVolume_BuildDecalVolumeCsConstants(viewInfo, &clusterConstantsTmp);
    maxCellIndirectionsPerBucket = -1;
    ClusteringPass = R_DecalVolume_GetClusteringPass(v9);
    if ( v9 )
    {
      maxCellIndirectionsPerBucket = R_DecalVolume_GetClusteringPass(v9 - 1)->maxCellIndirectionsPerBucket;
      v22 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 4);
      v23 = taskInfo->attachments + 5;
      fcrp.inDecalIndices = v22;
      v24 = R_RT_Handle::GetWrappedBuffer(v23);
      v25 = taskInfo->attachments + 6;
      fcrp.inCellIndirection = v24;
      v26 = R_RT_Handle::GetWrappedBuffer(v25);
      v27 = taskInfo->attachments + 7;
      fcrp.inCellIndirectionCount = v26;
      fcrp.inIndirectArgs = R_RT_Handle::GetWrappedBuffer(v27);
    }
    v28 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 8);
    v29 = taskInfo->attachments + 9;
    fcrp.inClusteringData = v28;
    fcrp.inClusteringDataCount = R_RT_Handle::GetWrappedBuffer(v29);
    R_DecalVolume_FillCluster_Part1(computeState, ClusteringPass, maxCellIndirectionsPerBucket, v9, lastPass, &clusterConstantsTmp, &fcrp);
  }
}

/*
==============
RBT_DV_FillCluster_Part2
==============
*/
void RBT_DV_FillCluster_Part2(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v7; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v7 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
    R_DecalVolume_FillCluster_Part2(computeState, v7, WrappedBuffer);
  }
}

/*
==============
RBT_DV_PipelineClearBuffers
==============
*/
void RBT_DV_PipelineClearBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v8; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v10; 
  const GfxWrappedRWBuffer *cullDecalsCount; 
  const GfxWrappedRWBuffer *materialLods; 
  const GfxWrappedRWBuffer *decalCount; 
  GfxWrappedRWBuffer *maskLodsBuffer; 

  if ( computeState->computeContextType == COMPUTE_CONTEXT_TYPE_GFX )
    R_UnlockGfxImmediateContext();
  R_DecalVolumes_Wait(data, viewInfo);
  if ( computeState->computeContextType == COMPUTE_CONTEXT_TYPE_GFX )
    R_LockGfxImmediateContext();
  v8 = R_DecalVolumes_GetDecalCount(data);
  R_DecalVolumes_UpdateGpuBuffers(computeState, viewInfo, data, v8);
  R_DecalVolumesGrid_UpdateGpuBuffers(data);
  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
  v10 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
  cullDecalsCount = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 2);
  materialLods = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 3);
  maskLodsBuffer = (GfxWrappedRWBuffer *)R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 4);
  decalCount = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 5);
  if ( v8 )
    R_DecalVolume_PipelineClearBuffers(computeState, data->decalVolumeIndex, WrappedBuffer, v10, cullDecalsCount, materialLods, maskLodsBuffer, decalCount);
}

/*
==============
RBT_DV_PipelineCopyDebugInfo
==============
*/
void RBT_DV_PipelineCopyDebugInfo(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  GfxWrappedBuffer **v6; 
  __int64 v7; 
  __int64 v8; 
  R_RT_Handle *v9; 
  const R_RT_Surface *Surface; 
  const GfxWrappedRWBuffer *decalIndicesCounts; 
  const GfxWrappedRWBuffer *materialInfoCount; 
  const GfxWrappedRWBuffer *materialInfo; 
  GfxWrappedBuffer *cellIndirectionCount[6]; 

  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
  materialInfo = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
  materialInfoCount = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 2);
  decalIndicesCounts = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 3);
  v6 = cellIndirectionCount;
  memset(cellIndirectionCount, 0, sizeof(cellIndirectionCount));
  v7 = 4i64;
  v8 = 5i64;
  do
  {
    v9 = &taskInfo->attachments[v7];
    if ( v9->m_surfaceID )
    {
      Surface = R_RT_Handle::GetSurface(v9);
      if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
        __debugbreak();
      *v6 = (GfxWrappedBuffer *)&Surface->1080;
    }
    ++v7;
    ++v6;
    --v8;
  }
  while ( v8 );
  R_DecalVolume_PipelineCopyDebugInfo(computeState, data->decalVolumeIndex, WrappedBuffer, materialInfo, materialInfoCount, decalIndicesCounts, (const GfxWrappedBuffer **)cellIndirectionCount);
}

/*
==============
RBT_DV_PipelineCullingPart0
==============
*/
void RBT_DV_PipelineCullingPart0(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int DecalCount; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v10; 
  const GfxWrappedRWBuffer *v11; 
  R_RT_Handle *v12; 
  const GfxWrappedRWBuffer *v13; 
  unsigned int decalVolumeIndex; 
  DecalVolumePiplineCullingPart0ResourcePtrs res; 

  DecalCount = R_DecalVolumes_GetDecalCount(data);
  if ( DecalCount )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v10 = taskInfo->attachments + 1;
    res.cullDecalsCountBuffer = WrappedBuffer;
    v11 = R_RT_Handle::GetWrappedBuffer(v10);
    v12 = taskInfo->attachments + 2;
    res.staticDecals = v11;
    v13 = R_RT_Handle::GetWrappedBuffer(v12);
    decalVolumeIndex = data->decalVolumeIndex;
    res.staticDecalsMapIndex = v13;
    R_DecalVolume_PipelineCullingPart0(computeState, viewInfo, decalVolumeIndex, DecalCount, &res);
  }
}

/*
==============
RBT_DV_PipelineCullingPart0IndirectArgs
==============
*/
void RBT_DV_PipelineCullingPart0IndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *collectionsIndirectArgs; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    collectionsIndirectArgs = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
    R_DecalVolume_PipelineCullingPart0IndirectArgs(computeState, viewInfo, data->decalVolumeIndex, WrappedBuffer, collectionsIndirectArgs);
  }
}

/*
==============
RBT_DV_PipelineCullingPart1
==============
*/
void RBT_DV_PipelineCullingPart1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int DecalCount; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v11; 
  const GfxWrappedRWBuffer *v12; 
  R_RT_Handle *v13; 
  const GfxWrappedRWBuffer *v14; 
  R_RT_Handle *v15; 
  const GfxWrappedRWBuffer *v16; 
  R_RT_Handle *v17; 
  const GfxWrappedRWBuffer *v18; 
  R_RT_Handle *v19; 
  const GfxWrappedRWBuffer *v20; 
  R_RT_Handle *v21; 
  const GfxWrappedRWBuffer *v22; 
  R_RT_Handle *v23; 
  unsigned int decalVolumeIndex; 
  R_RT_Handle v28; 
  DecalVolumePiplineCullingPart1ResourcePtrs res; 

  DecalCount = R_DecalVolumes_GetDecalCount(data);
  if ( DecalCount )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v11 = taskInfo->attachments + 1;
    res.materialLods = WrappedBuffer;
    v12 = R_RT_Handle::GetWrappedBuffer(v11);
    v13 = taskInfo->attachments + 2;
    res.maskLods = v12;
    v14 = R_RT_Handle::GetWrappedBuffer(v13);
    v15 = taskInfo->attachments + 3;
    res.staticDecals = v14;
    v16 = R_RT_Handle::GetWrappedBuffer(v15);
    v17 = taskInfo->attachments + 4;
    res.staticDecalsMapIndex = v16;
    v18 = R_RT_Handle::GetWrappedBuffer(v17);
    v19 = taskInfo->attachments + 5;
    res.decalsCountBuffer = v18;
    v20 = R_RT_Handle::GetWrappedBuffer(v19);
    v21 = taskInfo->attachments + 6;
    res.collectionsIndirectArgs = v20;
    v22 = R_RT_Handle::GetWrappedBuffer(v21);
    v23 = taskInfo->attachments + 7;
    res.cullStaticIndicesBuffer = v22;
    res.cullImpactMarkIndicesBuffer = R_RT_Handle::GetWrappedBuffer(v23);
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+100h]
      vmovd   eax, xmm0
      vmovups [rsp+108h+var_B8], ymm0
      vmovups ymmword ptr [rsp+108h+var_D8.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v28);
      if ( (R_RT_Handle::GetSurface(&v28)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+108h+var_D8.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+108h+var_D8.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        __asm { vmovups ymm0, [rsp+108h+var_B8] }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    decalVolumeIndex = data->decalVolumeIndex;
    __asm { vmovups ymmword ptr [rsp+108h+res.occlusionTexture.baseclass_0.m_surfaceID], ymm0 }
    R_DecalVolume_PipelineCullingPart1(computeState, viewInfo, decalVolumeIndex, DecalCount, &res);
  }
}

/*
==============
RBT_DV_PipelineCullingPart2
==============
*/
void RBT_DV_PipelineCullingPart2(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v9; 
  const GfxWrappedRWBuffer *v10; 
  unsigned int decalVolumeIndex; 
  DecalVolumePiplineCullingPart2ResourcePtrs res; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v9 = taskInfo->attachments + 1;
    res.cullStaticIndicesBuffer = WrappedBuffer;
    v10 = R_RT_Handle::GetWrappedBuffer(v9);
    decalVolumeIndex = data->decalVolumeIndex;
    res.cullMarkIndicesBuffer = v10;
    R_DecalVolume_PipelineCullingPart2(computeState, viewInfo, decalVolumeIndex, &res);
  }
}

/*
==============
RBT_DV_PipelineGenerateClusteringData
==============
*/
void RBT_DV_PipelineGenerateClusteringData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v9; 
  const GfxWrappedRWBuffer *v10; 
  R_RT_Handle *v11; 
  const GfxWrappedRWBuffer *v12; 
  R_RT_Handle *v13; 
  const GfxWrappedRWBuffer *v14; 
  R_RT_Handle *v15; 
  const GfxWrappedRWBuffer *v16; 
  R_RT_Handle *v17; 
  const GfxWrappedRWBuffer *v18; 
  unsigned int decalVolumeIndex; 
  DecalVolumePiplineGenerateResourcePtrs res; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v9 = taskInfo->attachments + 1;
    res.cullDecalsCount = WrappedBuffer;
    v10 = R_RT_Handle::GetWrappedBuffer(v9);
    v11 = taskInfo->attachments + 2;
    res.cullStaticIndices = v10;
    v12 = R_RT_Handle::GetWrappedBuffer(v11);
    v13 = taskInfo->attachments + 3;
    res.cullImpactMarkIndices = v12;
    v14 = R_RT_Handle::GetWrappedBuffer(v13);
    v15 = taskInfo->attachments + 4;
    res.outputData = v14;
    v16 = R_RT_Handle::GetWrappedBuffer(v15);
    v17 = taskInfo->attachments + 5;
    res.indirectArgs = v16;
    v18 = R_RT_Handle::GetWrappedBuffer(v17);
    decalVolumeIndex = data->decalVolumeIndex;
    res.staticDecals = v18;
    R_DecalVolume_PipelineGenerateClusteringData(computeState, viewInfo, decalVolumeIndex, &res);
  }
}

/*
==============
RBT_DV_PipelineGenerateDrawData
==============
*/
void RBT_DV_PipelineGenerateDrawData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v9; 
  const GfxWrappedRWBuffer *v10; 
  R_RT_Handle *v11; 
  const GfxWrappedRWBuffer *v12; 
  R_RT_Handle *v13; 
  const GfxWrappedRWBuffer *v14; 
  R_RT_Handle *v15; 
  const GfxWrappedRWBuffer *v16; 
  R_RT_Handle *v17; 
  const GfxWrappedRWBuffer *v18; 
  unsigned int decalVolumeIndex; 
  DecalVolumePiplineGenerateResourcePtrs res; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v9 = taskInfo->attachments + 1;
    res.cullDecalsCount = WrappedBuffer;
    v10 = R_RT_Handle::GetWrappedBuffer(v9);
    v11 = taskInfo->attachments + 2;
    res.cullStaticIndices = v10;
    v12 = R_RT_Handle::GetWrappedBuffer(v11);
    v13 = taskInfo->attachments + 3;
    res.cullImpactMarkIndices = v12;
    v14 = R_RT_Handle::GetWrappedBuffer(v13);
    v15 = taskInfo->attachments + 4;
    res.outputData = v14;
    v16 = R_RT_Handle::GetWrappedBuffer(v15);
    v17 = taskInfo->attachments + 5;
    res.indirectArgs = v16;
    v18 = R_RT_Handle::GetWrappedBuffer(v17);
    decalVolumeIndex = data->decalVolumeIndex;
    res.staticDecals = v18;
    R_DecalVolume_PipelineGenerateDrawData(computeState, viewInfo, decalVolumeIndex, &res);
  }
}

/*
==============
RBT_DV_PipelineGenerateMaterialDebugInfo
==============
*/
void RBT_DV_PipelineGenerateMaterialDebugInfo(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v9; 
  const GfxWrappedRWBuffer *v10; 
  R_RT_Handle *v11; 
  const GfxWrappedRWBuffer *v12; 
  R_RT_Handle *v13; 
  const GfxWrappedRWBuffer *v14; 
  R_RT_Handle *v15; 
  const GfxWrappedRWBuffer *v16; 
  R_RT_Handle *v17; 
  const GfxWrappedRWBuffer *v18; 
  R_RT_Handle *v19; 
  const GfxWrappedRWBuffer *v20; 
  R_RT_Handle *v21; 
  const GfxWrappedRWBuffer *v22; 
  R_RT_Handle *v23; 
  const GfxWrappedRWBuffer *v24; 
  unsigned int decalVolumeIndex; 
  DecalVolumePiplineMaterialDebugInfoResourcePtrs res; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v9 = taskInfo->attachments + 1;
    res.cullDecalsCount = WrappedBuffer;
    v10 = R_RT_Handle::GetWrappedBuffer(v9);
    v11 = taskInfo->attachments + 2;
    res.cullStaticIndices = v10;
    v12 = R_RT_Handle::GetWrappedBuffer(v11);
    v13 = taskInfo->attachments + 3;
    res.cullImpactMarkIndices = v12;
    v14 = R_RT_Handle::GetWrappedBuffer(v13);
    v15 = taskInfo->attachments + 4;
    res.materialDebugInfo = v14;
    v16 = R_RT_Handle::GetWrappedBuffer(v15);
    v17 = taskInfo->attachments + 5;
    res.materialDebugInfoCount = v16;
    v18 = R_RT_Handle::GetWrappedBuffer(v17);
    v19 = taskInfo->attachments + 6;
    res.decalVolumesDebug = v18;
    v20 = R_RT_Handle::GetWrappedBuffer(v19);
    v21 = taskInfo->attachments + 7;
    res.indirectArgs = v20;
    v22 = R_RT_Handle::GetWrappedBuffer(v21);
    v23 = taskInfo->attachments + 8;
    res.staticDecals = v22;
    v24 = R_RT_Handle::GetWrappedBuffer(v23);
    decalVolumeIndex = data->decalVolumeIndex;
    res.staticDecalsMapIndex = v24;
    R_DecalVolume_PipelineGenerateMaterialDebugInfo(computeState, viewInfo, decalVolumeIndex, &res);
  }
}

/*
==============
RBT_DV_PipelineIndirectArgs
==============
*/
void RBT_DV_PipelineIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v7; 
  const GfxWrappedRWBuffer *v8; 

  if ( R_DecalVolumes_GetDecalCount(data) )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v7 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
    v8 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 2);
    R_DecalVolume_PipelineIndirectArgs(computeState, WrappedBuffer, v7, v8);
  }
}

/*
==============
RBT_DV_PipelineStreamingData
==============
*/
void RBT_DV_PipelineStreamingData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int DecalCount; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v11; 
  const GfxWrappedRWBuffer *v12; 
  R_RT_Handle *v13; 
  const GfxWrappedRWBuffer *v14; 
  R_RT_Handle *v15; 
  const GfxWrappedRWBuffer *v16; 
  R_RT_Handle *v17; 
  const GfxWrappedRWBuffer *v18; 
  R_RT_Handle *v19; 
  R_RT_Handle *v27; 
  const GfxWrappedRWBuffer *v28; 
  R_RT_Handle *v29; 
  const GfxWrappedRWBuffer *v30; 
  unsigned int decalVolumeIndex; 
  DecalVolumePiplineStreamingDataResourcePtrs res; 
  R_RT_Handle v33; 
  __m256i v34; 

  DecalCount = R_DecalVolumes_GetDecalCount(data);
  if ( DecalCount )
  {
    WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
    v11 = taskInfo->attachments + 1;
    res.cullDecalsCount = WrappedBuffer;
    v12 = R_RT_Handle::GetWrappedBuffer(v11);
    v13 = taskInfo->attachments + 2;
    res.cullStaticIndices = v12;
    v14 = R_RT_Handle::GetWrappedBuffer(v13);
    v15 = taskInfo->attachments + 3;
    res.cullImpactMarkIndices = v14;
    v16 = R_RT_Handle::GetWrappedBuffer(v15);
    v17 = taskInfo->attachments + 4;
    res.indirectArgs = v16;
    v18 = R_RT_Handle::GetWrappedBuffer(v17);
    v19 = taskInfo->attachments + 5;
    res.staticDecals = v18;
    if ( !R_RT_Handle::IsValid(v19) )
    {
      __asm { vpxor   xmm0, xmm0, xmm0 }
      v33.m_surfaceID = 0;
      v33.m_tracking.m_allocCounter = 0;
      _RAX = &v33;
      __asm { vmovdqu xmmword ptr [rsp+108h+var_78.m_tracking.m_name], xmm0 }
      goto LABEL_13;
    }
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+0A0h]
      vmovd   eax, xmm0
      vmovups [rsp+108h+var_58], ymm0
      vmovups ymmword ptr [rsp+108h+var_78.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v33);
      if ( (R_RT_Handle::GetSurface(&v33)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()", res.staticDecals, res.cullDecalsCount, res.cullStaticIndices, res.cullImpactMarkIndices, res.indirectArgs) )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+108h+var_78.m_surfaceID] }
        __debugbreak();
        __asm { vmovups [rsp+108h+var_58], ymm0 }
        _RAX = (R_RT_Handle *)&v34;
        goto LABEL_13;
      }
      __asm { vmovups ymm0, ymmword ptr [rsp+108h+var_78.m_surfaceID] }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        __asm { vmovups ymm0, [rsp+108h+var_58] }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", res.staticDecals, res.cullDecalsCount, res.cullStaticIndices, res.cullImpactMarkIndices, res.indirectArgs) )
        {
          __debugbreak();
          __asm { vmovups [rsp+108h+var_58], ymm0 }
          _RAX = (R_RT_Handle *)&v34;
LABEL_13:
          __asm { vmovups ymm0, ymmword ptr [rax] }
          v27 = taskInfo->attachments + 6;
          __asm { vmovups ymmword ptr [rsp+108h+res.occlusionTexture.baseclass_0.m_surfaceID], ymm0 }
          v28 = R_RT_Handle::GetWrappedBuffer(v27);
          v29 = taskInfo->attachments + 7;
          res.materialLods = v28;
          v30 = R_RT_Handle::GetWrappedBuffer(v29);
          decalVolumeIndex = data->decalVolumeIndex;
          res.maskLods = v30;
          R_DecalVolume_PipelineStreamingData(computeState, viewInfo, decalVolumeIndex, DecalCount, &res);
          return;
        }
      }
    }
    __asm { vmovups [rsp+108h+var_58], ymm0 }
    _RAX = (R_RT_Handle *)&v34;
    goto LABEL_13;
  }
}

/*
==============
RBT_DV_PipelineStreamingDataTransfer
==============
*/
void RBT_DV_PipelineStreamingDataTransfer(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const GfxWrappedRWBuffer *WrappedBuffer; 
  const GfxWrappedRWBuffer *v8; 

  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments);
  v8 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1);
  R_DecalVolume_PipelineCopyLODData(computeState, data->decalVolumeIndex, WrappedBuffer, v8);
}

/*
==============
R_TGS_DV_FillCluster
==============
*/
void R_TGS_DV_FillCluster(R_TG_Script *pScript, bool reserveOnly, bool asyncQueue, bool floatZOcclusionCulling, bool floatZStreamOcclusionCulling, bool decalVolumeDebug, R_TG_Handle nullBuffer, R_TG_Handle nullRwBuffer, R_TG_Handle nullTexture, R_TG_Handle floatZ, R_TG_Handle *outDecalIndices, R_TG_Handle *outDecalDrawData, R_TG_Handle *outDecalDebugData, R_TG_Handle *outDecalIndirectArgs, R_TG_Handle syncToken)
{
  R_TG_Handle *v16; 
  R_TG_Handle *outDecalsDrawData; 
  R_TG_Script *v19; 
  DecalVolumeClustering *p_outClustering; 
  unsigned int v21; 
  unsigned int v22; 
  R_TG_Handle *v23; 
  unsigned int index; 
  __int64 v25; 
  R_TG_Handle *v26; 
  __int64 v27; 
  R_TG_Handle *v28; 
  __int64 v29; 
  R_TG_Handle *v30; 
  __int64 v31; 
  R_TG_Script *v32; 
  unsigned int *p_maxDecalIndices; 
  __int64 v34; 
  __int64 v35; 
  unsigned int m_index; 
  __int64 handleArgCount; 
  unsigned int v38; 
  unsigned int v39; 
  unsigned int v40; 
  R_TG_Handle *v41; 
  __int64 i; 
  unsigned int v43; 
  __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  __int64 v47; 
  __int64 v48; 
  __int64 v49; 
  __int64 v50; 
  unsigned int v51; 
  unsigned int v52; 
  __int64 v53; 
  R_TG_Handle *v54; 
  unsigned int *v55; 
  R_TG_Handle *v56; 
  unsigned int v57; 
  __int64 v58; 
  __int64 v59; 
  __int64 v60; 
  __int64 v61; 
  __int64 v62; 
  __int64 v63; 
  __int64 v64; 
  __int64 v65; 
  __int64 v66; 
  unsigned int v67; 
  __int64 v68; 
  R_TG_Handle *v69; 
  R_TG_Handle *v70; 
  R_TG_Handle *v71; 
  R_TG_Handle *v72; 
  unsigned int *v73; 
  R_TG_Handle *v74; 
  unsigned int v75; 
  __int64 v76; 
  __int64 v77; 
  __int64 v78; 
  __int64 v79; 
  __int64 v80; 
  __int64 v81; 
  __int64 v82; 
  __int64 v83; 
  __int64 v84; 
  unsigned int v85; 
  __int64 v86; 
  __int64 v87; 
  __int64 v88; 
  __int64 v89; 
  __int64 v90; 
  __int64 v91; 
  __int64 v92; 
  __int64 v93; 
  __int64 v94; 
  unsigned int v95; 
  __int64 v96; 
  __int64 v97; 
  unsigned int v98; 
  __int64 v99; 
  __int64 v100; 
  __int64 v101; 
  __int64 v102; 
  __int64 v103; 
  __int64 v104; 
  __int64 v105; 
  __int64 v106; 
  unsigned int v107; 
  __int64 v108; 
  unsigned int v109; 
  unsigned int numClusteringPasses; 
  R_TG_Handle v112; 
  R_TG_Handle v113; 
  DecalVolumeClustering *v114; 
  R_TG_Handle outDecalsClusterData; 
  R_TG_Handle outDecalsCount; 
  R_TG_Handle outCullDecalsCountBuffer; 
  R_TG_Handle outCullStaticIndicesBuffer; 
  R_TG_Handle outCullImpactMarkIndicesBuffer; 
  R_TG_Handle outStaticDecals; 
  R_TG_Handle outStaticDecalsMapIndex; 
  R_TG_Script *pScripta; 
  R_TG_Handle *v123; 
  unsigned int *p_index; 
  __int64 v125; 
  unsigned __int64 v126; 
  R_TG_Handle *v127; 
  R_TG_Handle *v128; 
  R_TG_AddTaskStack stack; 
  R_TG_AddTaskStack v130; 
  R_TG_AddTaskStack v131; 
  R_TG_AddTaskStack arguments; 
  DecalVolumeClustering outClustering; 
  R_TG_Handle v134; 
  R_TG_Handle v135; 
  R_TG_Handle v136; 
  R_TG_Handle v137; 
  R_TG_Handle v138; 
  R_TG_Handle v139[6]; 
  R_TG_Handle v140[6]; 
  R_TG_Handle value[6]; 

  v16 = outDecalIndirectArgs;
  outDecalsDrawData = outDecalDrawData;
  v19 = pScript;
  v127 = outDecalIndices;
  v123 = outDecalDebugData;
  pScripta = pScript;
  v128 = outDecalIndirectArgs;
  outDecalsClusterData.index = -1;
  outDecalsCount.index = -1;
  outCullDecalsCountBuffer.index = -1;
  outCullImpactMarkIndicesBuffer.index = -1;
  outCullStaticIndicesBuffer.index = -1;
  outStaticDecals.index = -1;
  outStaticDecalsMapIndex.index = -1;
  if ( asyncQueue )
    cAsyncBegin(pScript);
  R_TG_DV_Pipeline(v19, floatZOcclusionCulling, floatZStreamOcclusionCulling, decalVolumeDebug, nullBuffer, nullRwBuffer, nullTexture, floatZ, &outDecalsClusterData, outDecalsDrawData, &outDecalsCount, v16, &outCullDecalsCountBuffer, &outCullStaticIndicesBuffer, &outCullImpactMarkIndicesBuffer, &outStaticDecals, &outStaticDecalsMapIndex, syncToken);
  if ( reserveOnly )
    p_outClustering = &outClustering;
  else
    p_outClustering = R_DecalVolume_GetClustering();
  v21 = v19->sceneSize.v[1];
  v22 = v19->sceneSize.v[0];
  v114 = p_outClustering;
  R_DecalVolume_InitClustering(v22, v21, 0, p_outClustering);
  v23 = &v134;
  numClusteringPasses = p_outClustering->numClusteringPasses;
  index = numClusteringPasses - 1;
  v25 = 5i64;
  v112.index = numClusteringPasses - 1;
  do
  {
    R_TG_Handle::R_TG_Handle(v23++);
    --v25;
  }
  while ( v25 );
  v26 = value;
  v27 = 5i64;
  do
  {
    R_TG_Handle::R_TG_Handle(v26++);
    --v27;
  }
  while ( v27 );
  v28 = v140;
  v29 = 5i64;
  do
  {
    R_TG_Handle::R_TG_Handle(v28++);
    --v29;
  }
  while ( v29 );
  v30 = v139;
  v31 = 6i64;
  do
  {
    R_TG_Handle::R_TG_Handle(v30++);
    --v31;
  }
  while ( v31 );
  v113.index = -1;
  if ( numClusteringPasses != 1 )
  {
    v32 = pScripta;
    p_maxDecalIndices = &p_outClustering->clusteringPasses[0].maxDecalIndices;
    v34 = index;
    v35 = 0i64;
    do
    {
      memset_0(&stack, 0, sizeof(stack));
      m_index = g_R_TG_Def_RBT_DV_CreateBuffers.m_index;
      stack.handleArgs[0] = (unsigned int *)((char *)&v134.index + v35 * 4);
      handleArgCount = stack.handleArgCount + 1;
      stack.handleArgCount = handleArgCount;
      if ( (unsigned int)handleArgCount >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        handleArgCount = stack.handleArgCount;
      }
      v38 = p_maxDecalIndices[2];
      stack.handleArgs[handleArgCount] = &value[v35].index;
      if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      stack.paramArgs[stack.paramArgCount++] = v38;
      if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v39 = *p_maxDecalIndices;
      stack.handleArgs[stack.handleArgCount] = &v140[v35].index;
      if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      stack.paramArgs[stack.paramArgCount++] = v39;
      if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      stack.handleArgs[stack.handleArgCount++] = &v139[v35].index;
      R_TG_AddTask(v32, m_index, &stack);
      ++v35;
      p_maxDecalIndices += 18;
      --v34;
    }
    while ( v34 );
    p_outClustering = v114;
    v19 = pScripta;
    index = v112.index;
  }
  if ( index < 5 )
  {
    v40 = nullRwBuffer.index;
    v41 = &v134 + index;
    for ( i = 5 - index; i; --i )
    {
      v41->index = v40;
      ++v41;
    }
  }
  memset_0(&stack, 0, sizeof(stack));
  ++stack.paramArgCount;
  v43 = g_R_TG_Def_RBT_DV_CreateClearCountsAndIndices.m_index;
  stack.paramArgs[0] = p_outClustering->clusteringPasses[index].maxDecalIndices;
  if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
    __debugbreak();
  stack.handleArgs[stack.handleArgCount] = (unsigned int *)&v113;
  v44 = stack.handleArgCount + 1;
  stack.handleArgCount = v44;
  if ( (unsigned int)v44 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v44 = stack.handleArgCount;
  }
  v126 = 4i64 * index;
  stack.handleArgs[v44] = &v139[v126 / 4].index;
  v45 = stack.handleArgCount + 1;
  stack.handleArgCount = v45;
  if ( (unsigned int)v45 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v45 = stack.handleArgCount;
  }
  stack.handleArgs[v45] = (unsigned int *)&v134;
  v46 = stack.handleArgCount + 1;
  stack.handleArgCount = v46;
  if ( (unsigned int)v46 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v46 = stack.handleArgCount;
  }
  stack.handleArgs[v46] = (unsigned int *)&v135;
  v47 = stack.handleArgCount + 1;
  stack.handleArgCount = v47;
  if ( (unsigned int)v47 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v47 = stack.handleArgCount;
  }
  stack.handleArgs[v47] = (unsigned int *)&v136;
  v48 = stack.handleArgCount + 1;
  stack.handleArgCount = v48;
  if ( (unsigned int)v48 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v48 = stack.handleArgCount;
  }
  stack.handleArgs[v48] = (unsigned int *)&v137;
  v49 = stack.handleArgCount + 1;
  stack.handleArgCount = v49;
  if ( (unsigned int)v49 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v49 = stack.handleArgCount;
  }
  stack.handleArgs[v49] = (unsigned int *)&v138;
  v50 = stack.handleArgCount + 1;
  stack.handleArgCount = v50;
  if ( (unsigned int)v50 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v50 = stack.handleArgCount;
  }
  stack.handleArgs[v50] = (unsigned int *)&syncToken;
  ++stack.handleArgCount;
  R_TG_AddTask(v19, v43, &stack);
  v51 = numClusteringPasses;
  v52 = 0;
  for ( LODWORD(v114) = 0; v52 < v51; LODWORD(v114) = v52 )
  {
    v53 = v52;
    v125 = v53 * 4;
    v54 = &v139[v53];
    if ( v52 )
    {
      v68 = v52 - 1;
      v69 = &value[v68];
      v70 = &v134 + v68;
      p_index = &v69->index;
      v71 = &v140[v68];
      v72 = &v139[v68];
      if ( v52 >= v112.index )
      {
        memset_0(&stack, 0, sizeof(stack));
        ++stack.paramArgCount;
        v85 = g_R_TG_Def_RBT_DV_FillCluster_Part1.m_index;
        stack.paramArgs[0] = v52;
        if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        stack.handleArgs[stack.handleArgCount] = &v54->index;
        v86 = stack.handleArgCount + 1;
        stack.handleArgCount = v86;
        if ( (unsigned int)v86 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v86 = stack.handleArgCount;
        }
        stack.handleArgs[v86] = (unsigned int *)&v113;
        v87 = stack.handleArgCount + 1;
        stack.handleArgCount = v87;
        if ( (unsigned int)v87 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v87 = stack.handleArgCount;
        }
        stack.handleArgs[v87] = (unsigned int *)&nullRwBuffer;
        v88 = stack.handleArgCount + 1;
        stack.handleArgCount = v88;
        if ( (unsigned int)v88 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v88 = stack.handleArgCount;
        }
        stack.handleArgs[v88] = (unsigned int *)&nullRwBuffer;
        v89 = stack.handleArgCount + 1;
        stack.handleArgCount = v89;
        if ( (unsigned int)v89 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v89 = stack.handleArgCount;
        }
        stack.handleArgs[v89] = &v72->index;
        v90 = stack.handleArgCount + 1;
        stack.handleArgCount = v90;
        if ( (unsigned int)v90 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v90 = stack.handleArgCount;
        }
        stack.handleArgs[v90] = &v71->index;
        v91 = stack.handleArgCount + 1;
        stack.handleArgCount = v91;
        if ( (unsigned int)v91 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v91 = stack.handleArgCount;
        }
        stack.handleArgs[v91] = &v70->index;
        v92 = stack.handleArgCount + 1;
        stack.handleArgCount = v92;
        if ( (unsigned int)v92 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v92 = stack.handleArgCount;
        }
        stack.handleArgs[v92] = &v69->index;
        v93 = stack.handleArgCount + 1;
        stack.handleArgCount = v93;
        if ( (unsigned int)v93 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v93 = stack.handleArgCount;
        }
        stack.handleArgs[v93] = (unsigned int *)&outDecalsClusterData;
        v94 = stack.handleArgCount + 1;
        stack.handleArgCount = v94;
        if ( (unsigned int)v94 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v94 = stack.handleArgCount;
        }
        v19 = pScripta;
        stack.handleArgs[v94] = (unsigned int *)&outDecalsCount;
        ++stack.handleArgCount;
        R_TG_AddTask(v19, v85, &stack);
      }
      else
      {
        v73 = (unsigned int *)((char *)&v134.index + v53 * 4);
        v74 = &v140[v53];
        memset_0(&v131, 0, sizeof(v131));
        ++v131.paramArgCount;
        v75 = g_R_TG_Def_RBT_DV_FillCluster_Part1.m_index;
        v131.paramArgs[0] = (unsigned int)v114;
        if ( v131.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v131.handleArgs[v131.handleArgCount] = &v54->index;
        v76 = v131.handleArgCount + 1;
        v131.handleArgCount = v76;
        if ( (unsigned int)v76 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v76 = v131.handleArgCount;
        }
        v131.handleArgs[v76] = (unsigned int *)&v113;
        v77 = v131.handleArgCount + 1;
        v131.handleArgCount = v77;
        if ( (unsigned int)v77 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v77 = v131.handleArgCount;
        }
        v131.handleArgs[v77] = &v74->index;
        v78 = v131.handleArgCount + 1;
        v131.handleArgCount = v78;
        if ( (unsigned int)v78 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v78 = v131.handleArgCount;
        }
        v131.handleArgs[v78] = v73;
        v79 = v131.handleArgCount + 1;
        v131.handleArgCount = v79;
        if ( (unsigned int)v79 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v79 = v131.handleArgCount;
        }
        v131.handleArgs[v79] = &v72->index;
        v80 = v131.handleArgCount + 1;
        v131.handleArgCount = v80;
        if ( (unsigned int)v80 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v80 = v131.handleArgCount;
        }
        v131.handleArgs[v80] = &v71->index;
        v81 = v131.handleArgCount + 1;
        v131.handleArgCount = v81;
        if ( (unsigned int)v81 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v81 = v131.handleArgCount;
        }
        v131.handleArgs[v81] = &v70->index;
        v82 = v131.handleArgCount + 1;
        v131.handleArgCount = v82;
        if ( (unsigned int)v82 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v82 = v131.handleArgCount;
        }
        v131.handleArgs[v82] = p_index;
        v83 = v131.handleArgCount + 1;
        v131.handleArgCount = v83;
        if ( (unsigned int)v83 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v83 = v131.handleArgCount;
        }
        v131.handleArgs[v83] = (unsigned int *)&outDecalsClusterData;
        v84 = v131.handleArgCount + 1;
        v131.handleArgCount = v84;
        if ( (unsigned int)v84 >= 0x1E )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
            __debugbreak();
          v84 = v131.handleArgCount;
        }
        v19 = pScripta;
        v131.handleArgs[v84] = (unsigned int *)&outDecalsCount;
        ++v131.handleArgCount;
        R_TG_AddTask(v19, v75, &v131);
        v52 = (unsigned int)v114;
      }
      v51 = numClusteringPasses;
    }
    else
    {
      v55 = (unsigned int *)((char *)&v134.index + v53 * 4);
      v56 = &v140[v53];
      memset_0(&v130, 0, sizeof(v130));
      ++v130.paramArgCount;
      v57 = g_R_TG_Def_RBT_DV_FillCluster_Part1.m_index;
      v130.paramArgs[0] = 0;
      if ( v130.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v130.handleArgs[v130.handleArgCount] = &v54->index;
      v58 = v130.handleArgCount + 1;
      v130.handleArgCount = v58;
      if ( (unsigned int)v58 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v58 = v130.handleArgCount;
      }
      v130.handleArgs[v58] = (unsigned int *)&v113;
      v59 = v130.handleArgCount + 1;
      v130.handleArgCount = v59;
      if ( (unsigned int)v59 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v59 = v130.handleArgCount;
      }
      v130.handleArgs[v59] = &v56->index;
      v60 = v130.handleArgCount + 1;
      v130.handleArgCount = v60;
      if ( (unsigned int)v60 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v60 = v130.handleArgCount;
      }
      v130.handleArgs[v60] = v55;
      v61 = v130.handleArgCount + 1;
      v130.handleArgCount = v61;
      if ( (unsigned int)v61 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v61 = v130.handleArgCount;
      }
      v130.handleArgs[v61] = (unsigned int *)&nullBuffer;
      v62 = v130.handleArgCount + 1;
      v130.handleArgCount = v62;
      if ( (unsigned int)v62 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v62 = v130.handleArgCount;
      }
      v130.handleArgs[v62] = (unsigned int *)&nullBuffer;
      v63 = v130.handleArgCount + 1;
      v130.handleArgCount = v63;
      if ( (unsigned int)v63 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v63 = v130.handleArgCount;
      }
      v130.handleArgs[v63] = (unsigned int *)&nullBuffer;
      v64 = v130.handleArgCount + 1;
      v130.handleArgCount = v64;
      if ( (unsigned int)v64 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v64 = v130.handleArgCount;
      }
      v130.handleArgs[v64] = (unsigned int *)&nullBuffer;
      v65 = v130.handleArgCount + 1;
      v130.handleArgCount = v65;
      if ( (unsigned int)v65 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v65 = v130.handleArgCount;
      }
      v130.handleArgs[v65] = (unsigned int *)&outDecalsClusterData;
      v66 = v130.handleArgCount + 1;
      v130.handleArgCount = v66;
      if ( (unsigned int)v66 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v66 = v130.handleArgCount;
      }
      v67 = v57;
      v19 = pScripta;
      v130.handleArgs[v66] = (unsigned int *)&outDecalsCount;
      ++v130.handleArgCount;
      R_TG_AddTask(v19, v67, &v130);
    }
    if ( v52 != v112.index )
    {
      memset_0(&arguments, 0, sizeof(arguments));
      R_TG_AddTask<R_TG_Handle>(v19, g_R_TG_Def_RBT_DV_FillCluster_Part2.m_index, &arguments, (R_TG_Handle *)((char *)value + v125), (R_TG_Handle *)((char *)&v134 + v125));
    }
    ++v52;
  }
  v127->index = (unsigned int)v139[v126 / 4];
  if ( decalVolumeDebug )
  {
    LODWORD(v114) = -1;
    v112.index = -1;
    numClusteringPasses = -1;
    memset_0(&stack, 0, sizeof(stack));
    v95 = g_R_TG_Def_RBT_DV_CreateClearMaterialDebugInfo.m_index;
    stack.handleArgs[0] = (unsigned int *)&v114;
    v96 = stack.handleArgCount + 1;
    stack.handleArgCount = v96;
    if ( (unsigned int)v96 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v96 = stack.handleArgCount;
    }
    stack.handleArgs[v96] = (unsigned int *)&v112;
    v97 = stack.handleArgCount + 1;
    stack.handleArgCount = v97;
    if ( (unsigned int)v97 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v97 = stack.handleArgCount;
    }
    stack.handleArgs[v97] = &numClusteringPasses;
    ++stack.handleArgCount;
    R_TG_AddTask(v19, v95, &stack);
    memset_0(&stack, 0, sizeof(stack));
    v98 = g_R_TG_Def_RBT_DV_PipelineGenerateMaterialDebugInfo.m_index;
    stack.handleArgs[0] = (unsigned int *)&outCullDecalsCountBuffer;
    v99 = stack.handleArgCount + 1;
    stack.handleArgCount = v99;
    if ( (unsigned int)v99 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v99 = stack.handleArgCount;
    }
    stack.handleArgs[v99] = (unsigned int *)&outCullStaticIndicesBuffer;
    v100 = stack.handleArgCount + 1;
    stack.handleArgCount = v100;
    if ( (unsigned int)v100 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v100 = stack.handleArgCount;
    }
    stack.handleArgs[v100] = (unsigned int *)&outCullImpactMarkIndicesBuffer;
    v101 = stack.handleArgCount + 1;
    stack.handleArgCount = v101;
    if ( (unsigned int)v101 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v101 = stack.handleArgCount;
    }
    stack.handleArgs[v101] = (unsigned int *)&v114;
    v102 = stack.handleArgCount + 1;
    stack.handleArgCount = v102;
    if ( (unsigned int)v102 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v102 = stack.handleArgCount;
    }
    stack.handleArgs[v102] = (unsigned int *)&v112;
    v103 = stack.handleArgCount + 1;
    stack.handleArgCount = v103;
    if ( (unsigned int)v103 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v103 = stack.handleArgCount;
    }
    stack.handleArgs[v103] = &numClusteringPasses;
    v104 = stack.handleArgCount + 1;
    stack.handleArgCount = v104;
    if ( (unsigned int)v104 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v104 = stack.handleArgCount;
    }
    stack.handleArgs[v104] = &v128->index;
    v105 = stack.handleArgCount + 1;
    stack.handleArgCount = v105;
    if ( (unsigned int)v105 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v105 = stack.handleArgCount;
    }
    stack.handleArgs[v105] = (unsigned int *)&outStaticDecals;
    v106 = stack.handleArgCount + 1;
    stack.handleArgCount = v106;
    if ( (unsigned int)v106 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v106 = stack.handleArgCount;
    }
    stack.handleArgs[v106] = (unsigned int *)&outStaticDecalsMapIndex;
    ++stack.handleArgCount;
    R_TG_AddTask(v19, v98, &stack);
    memset_0(&stack, 0, sizeof(stack));
    v107 = g_R_TG_Def_RBT_DV_PipelineCopyDebugInfo.m_index;
    stack.handleArgs[0] = (unsigned int *)&outCullDecalsCountBuffer;
    v108 = stack.handleArgCount + 1;
    stack.handleArgCount = v108;
    if ( (unsigned int)v108 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v108 = stack.handleArgCount;
    }
    stack.handleArgs[v108] = (unsigned int *)&v114;
    ++stack.handleArgCount;
    R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(v19, v107, &stack, &v112, &v113, &v134, &v135, &v136, &v137, &v138);
    v109 = numClusteringPasses;
  }
  else
  {
    v109 = nullBuffer.index;
  }
  v123->index = v109;
  if ( asyncQueue )
    cAsyncEnd(v19);
}

/*
==============
R_TG_DV_Pipeline
==============
*/
void R_TG_DV_Pipeline(R_TG_Script *pScript, bool floatZOcclusionCulling, bool floatZStreamOcclusionCulling, bool decalVolumeDebug, R_TG_Handle nullBuffer, R_TG_Handle nullRwBuffer, R_TG_Handle nullTexture, R_TG_Handle floatZ, R_TG_Handle *outDecalsClusterData, R_TG_Handle *outDecalsDrawData, R_TG_Handle *outDecalsCount, R_TG_Handle *outDecalIndirectArgs, R_TG_Handle *outCullDecalsCountBuffer, R_TG_Handle *outCullStaticIndicesBuffer, R_TG_Handle *outCullImpactMarkIndicesBuffer, R_TG_Handle *outStaticDecals, R_TG_Handle *outStaticDecalsMapIndex, R_TG_Handle syncToken)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  __int64 v28; 
  __int64 v29; 
  R_TG_Handle *v30; 
  __int64 v31; 
  R_TG_Handle *v32; 
  __int64 v33; 
  R_TG_Handle *v34; 
  __int64 v35; 
  unsigned int v36; 
  __int64 v37; 
  __int64 v38; 
  __int64 v39; 
  __int64 v40; 
  __int64 v41; 
  __int64 v42; 
  unsigned int v43; 
  __int64 v44; 
  __int64 v45; 
  unsigned int v46; 
  __int64 v47; 
  R_TG_Handle *p_floatZ; 
  unsigned int v49; 
  __int64 v50; 
  __int64 v51; 
  __int64 v52; 
  __int64 v53; 
  __int64 v54; 
  __int64 v55; 
  __int64 v56; 
  __int64 v57; 
  __int64 v58; 
  unsigned int v59; 
  __int64 v60; 
  __int64 v61; 
  unsigned int v62; 
  __int64 v63; 
  __int64 v64; 
  __int64 v65; 
  unsigned int v66; 
  __int64 v67; 
  __int64 v68; 
  __int64 v69; 
  __int64 v70; 
  __int64 v71; 
  unsigned int v72; 
  __int64 v73; 
  __int64 v74; 
  __int64 v75; 
  __int64 v76; 
  __int64 v77; 
  R_TG_Handle *p_nullTexture; 
  unsigned int v79; 
  __int64 v80; 
  __int64 v81; 
  __int64 v82; 
  __int64 v83; 
  __int64 v84; 
  __int64 v85; 
  __int64 v86; 
  unsigned int v87; 
  __int64 v88; 
  unsigned int index; 
  unsigned int v90; 
  unsigned int v91; 
  unsigned int v92; 
  unsigned int v93; 
  bool v94; 
  unsigned int v95; 
  int v96; 
  int v97; 
  unsigned int v98; 
  int v99; 
  R_TG_Handle *v100; 
  R_TG_Handle *v101; 
  R_TG_Handle *v102; 
  R_TG_Handle *v103; 
  R_TG_Handle *v104; 
  R_TG_Handle *v105; 
  R_TG_AddTaskStack stack; 

  v100 = outDecalIndirectArgs;
  v101 = outCullDecalsCountBuffer;
  v102 = outCullStaticIndicesBuffer;
  v103 = outCullImpactMarkIndicesBuffer;
  v105 = outStaticDecals;
  v104 = outStaticDecalsMapIndex;
  v94 = decalVolumeDebug;
  v90 = -1;
  v93 = -1;
  v95 = -1;
  v91 = -1;
  v92 = -1;
  v96 = -1;
  v97 = -1;
  v98 = -1;
  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_DV_CreatePipelineBuffers.m_index;
  stack.handleArgs[0] = &v90;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &v93;
  v23 = stack.handleArgCount + 1;
  stack.handleArgCount = v23;
  if ( (unsigned int)v23 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v23 = stack.handleArgCount;
  }
  stack.handleArgs[v23] = &v95;
  v24 = stack.handleArgCount + 1;
  stack.handleArgCount = v24;
  if ( (unsigned int)v24 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v24 = stack.handleArgCount;
  }
  stack.handleArgs[v24] = &v98;
  v25 = stack.handleArgCount + 1;
  stack.handleArgCount = v25;
  if ( (unsigned int)v25 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v25 = stack.handleArgCount;
  }
  stack.handleArgs[v25] = &v91;
  v26 = stack.handleArgCount + 1;
  stack.handleArgCount = v26;
  if ( (unsigned int)v26 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v26 = stack.handleArgCount;
  }
  stack.handleArgs[v26] = &v92;
  v27 = stack.handleArgCount + 1;
  stack.handleArgCount = v27;
  if ( (unsigned int)v27 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v27 = stack.handleArgCount;
  }
  stack.handleArgs[v27] = (unsigned int *)&v96;
  v28 = stack.handleArgCount + 1;
  stack.handleArgCount = v28;
  if ( (unsigned int)v28 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v28 = stack.handleArgCount;
  }
  stack.handleArgs[v28] = (unsigned int *)&v97;
  v29 = stack.handleArgCount + 1;
  stack.handleArgCount = v29;
  if ( (unsigned int)v29 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v29 = stack.handleArgCount;
  }
  v30 = outDecalsCount;
  stack.handleArgs[v29] = &outDecalsCount->index;
  v31 = stack.handleArgCount + 1;
  stack.handleArgCount = v31;
  if ( (unsigned int)v31 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v31 = stack.handleArgCount;
  }
  v32 = outDecalsClusterData;
  stack.handleArgs[v31] = &outDecalsClusterData->index;
  v33 = stack.handleArgCount + 1;
  stack.handleArgCount = v33;
  if ( (unsigned int)v33 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v33 = stack.handleArgCount;
  }
  v34 = outDecalsDrawData;
  stack.handleArgs[v33] = &outDecalsDrawData->index;
  v35 = stack.handleArgCount + 1;
  stack.handleArgCount = v35;
  if ( (unsigned int)v35 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v35 = stack.handleArgCount;
  }
  stack.handleArgs[v35] = (unsigned int *)&syncToken;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, m_index, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v36 = g_R_TG_Def_RBT_DV_PipelineClearBuffers.m_index;
  stack.handleArgs[0] = &v91;
  v37 = stack.handleArgCount + 1;
  stack.handleArgCount = v37;
  if ( (unsigned int)v37 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v37 = stack.handleArgCount;
  }
  stack.handleArgs[v37] = &v93;
  v38 = stack.handleArgCount + 1;
  stack.handleArgCount = v38;
  if ( (unsigned int)v38 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v38 = stack.handleArgCount;
  }
  stack.handleArgs[v38] = &v90;
  v39 = stack.handleArgCount + 1;
  stack.handleArgCount = v39;
  if ( (unsigned int)v39 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v39 = stack.handleArgCount;
  }
  stack.handleArgs[v39] = (unsigned int *)&v96;
  v40 = stack.handleArgCount + 1;
  stack.handleArgCount = v40;
  if ( (unsigned int)v40 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v40 = stack.handleArgCount;
  }
  stack.handleArgs[v40] = (unsigned int *)&v97;
  v41 = stack.handleArgCount + 1;
  stack.handleArgCount = v41;
  if ( (unsigned int)v41 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v41 = stack.handleArgCount;
  }
  stack.handleArgs[v41] = &v30->index;
  v42 = stack.handleArgCount + 1;
  stack.handleArgCount = v42;
  if ( (unsigned int)v42 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v42 = stack.handleArgCount;
  }
  stack.handleArgs[v42] = (unsigned int *)&syncToken;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v36, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v43 = g_R_TG_Def_RBT_DV_PipelineCullingPart0.m_index;
  stack.handleArgs[0] = &v90;
  v44 = stack.handleArgCount + 1;
  stack.handleArgCount = v44;
  if ( (unsigned int)v44 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v44 = stack.handleArgCount;
  }
  stack.handleArgs[v44] = &v95;
  v45 = stack.handleArgCount + 1;
  stack.handleArgCount = v45;
  if ( (unsigned int)v45 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v45 = stack.handleArgCount;
  }
  stack.handleArgs[v45] = &v98;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v43, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v46 = g_R_TG_Def_RBT_DV_PipelineCullingPart0IndirectArgs.m_index;
  stack.handleArgs[0] = &v90;
  v47 = stack.handleArgCount + 1;
  stack.handleArgCount = v47;
  if ( (unsigned int)v47 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v47 = stack.handleArgCount;
  }
  stack.handleArgs[v47] = &v92;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v46, &stack);
  v99 = -1;
  p_floatZ = &floatZ;
  if ( !floatZOcclusionCulling )
    p_floatZ = &nullTexture;
  memset_0(&stack, 0, sizeof(stack));
  v49 = g_R_TG_Def_RBT_DV_PipelineCullingPart1.m_index;
  stack.handleArgs[0] = (unsigned int *)&v99;
  v50 = stack.handleArgCount + 1;
  stack.handleArgCount = v50;
  if ( (unsigned int)v50 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v50 = stack.handleArgCount;
  }
  stack.handleArgs[v50] = (unsigned int *)&v96;
  v51 = stack.handleArgCount + 1;
  stack.handleArgCount = v51;
  if ( (unsigned int)v51 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v51 = stack.handleArgCount;
  }
  stack.handleArgs[v51] = (unsigned int *)&v97;
  v52 = stack.handleArgCount + 1;
  stack.handleArgCount = v52;
  if ( (unsigned int)v52 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v52 = stack.handleArgCount;
  }
  stack.handleArgs[v52] = &v95;
  v53 = stack.handleArgCount + 1;
  stack.handleArgCount = v53;
  if ( (unsigned int)v53 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v53 = stack.handleArgCount;
  }
  stack.handleArgs[v53] = &v98;
  v54 = stack.handleArgCount + 1;
  stack.handleArgCount = v54;
  if ( (unsigned int)v54 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v54 = stack.handleArgCount;
  }
  stack.handleArgs[v54] = &v90;
  v55 = stack.handleArgCount + 1;
  stack.handleArgCount = v55;
  if ( (unsigned int)v55 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v55 = stack.handleArgCount;
  }
  stack.handleArgs[v55] = &v92;
  v56 = stack.handleArgCount + 1;
  stack.handleArgCount = v56;
  if ( (unsigned int)v56 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v56 = stack.handleArgCount;
  }
  stack.handleArgs[v56] = &v91;
  v57 = stack.handleArgCount + 1;
  stack.handleArgCount = v57;
  if ( (unsigned int)v57 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v57 = stack.handleArgCount;
  }
  stack.handleArgs[v57] = &v93;
  v58 = stack.handleArgCount + 1;
  stack.handleArgCount = v58;
  if ( (unsigned int)v58 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v58 = stack.handleArgCount;
  }
  stack.handleArgs[v58] = &p_floatZ->index;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v49, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v59 = g_R_TG_Def_RBT_DV_PipelineCullingPart2.m_index;
  stack.handleArgs[0] = &v91;
  v60 = stack.handleArgCount + 1;
  stack.handleArgCount = v60;
  if ( (unsigned int)v60 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v60 = stack.handleArgCount;
  }
  stack.handleArgs[v60] = &v93;
  v61 = stack.handleArgCount + 1;
  stack.handleArgCount = v61;
  if ( (unsigned int)v61 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v61 = stack.handleArgCount;
  }
  stack.handleArgs[v61] = (unsigned int *)&v99;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v59, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v62 = g_R_TG_Def_RBT_DV_PipelineIndirectArgs.m_index;
  stack.handleArgs[0] = &v90;
  v63 = stack.handleArgCount + 1;
  stack.handleArgCount = v63;
  if ( (unsigned int)v63 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v63 = stack.handleArgCount;
  }
  stack.handleArgs[v63] = &v30->index;
  v64 = stack.handleArgCount + 1;
  stack.handleArgCount = v64;
  if ( (unsigned int)v64 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v64 = stack.handleArgCount;
  }
  stack.handleArgs[v64] = &v92;
  v65 = stack.handleArgCount + 1;
  stack.handleArgCount = v65;
  if ( (unsigned int)v65 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v65 = stack.handleArgCount;
  }
  stack.handleArgs[v65] = &v91;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v62, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v66 = g_R_TG_Def_RBT_DV_PipelineGenerateClusteringData.m_index;
  stack.handleArgs[0] = &v90;
  v67 = stack.handleArgCount + 1;
  stack.handleArgCount = v67;
  if ( (unsigned int)v67 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v67 = stack.handleArgCount;
  }
  stack.handleArgs[v67] = &v91;
  v68 = stack.handleArgCount + 1;
  stack.handleArgCount = v68;
  if ( (unsigned int)v68 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v68 = stack.handleArgCount;
  }
  stack.handleArgs[v68] = &v93;
  v69 = stack.handleArgCount + 1;
  stack.handleArgCount = v69;
  if ( (unsigned int)v69 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v69 = stack.handleArgCount;
  }
  stack.handleArgs[v69] = &v32->index;
  v70 = stack.handleArgCount + 1;
  stack.handleArgCount = v70;
  if ( (unsigned int)v70 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v70 = stack.handleArgCount;
  }
  stack.handleArgs[v70] = &v92;
  v71 = stack.handleArgCount + 1;
  stack.handleArgCount = v71;
  if ( (unsigned int)v71 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v71 = stack.handleArgCount;
  }
  stack.handleArgs[v71] = &v95;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v66, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v72 = g_R_TG_Def_RBT_DV_PipelineGenerateDrawData.m_index;
  stack.handleArgs[0] = &v90;
  v73 = stack.handleArgCount + 1;
  stack.handleArgCount = v73;
  if ( (unsigned int)v73 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v73 = stack.handleArgCount;
  }
  stack.handleArgs[v73] = &v91;
  v74 = stack.handleArgCount + 1;
  stack.handleArgCount = v74;
  if ( (unsigned int)v74 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v74 = stack.handleArgCount;
  }
  stack.handleArgs[v74] = &v93;
  v75 = stack.handleArgCount + 1;
  stack.handleArgCount = v75;
  if ( (unsigned int)v75 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v75 = stack.handleArgCount;
  }
  stack.handleArgs[v75] = &v34->index;
  v76 = stack.handleArgCount + 1;
  stack.handleArgCount = v76;
  if ( (unsigned int)v76 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v76 = stack.handleArgCount;
  }
  stack.handleArgs[v76] = &v92;
  v77 = stack.handleArgCount + 1;
  stack.handleArgCount = v77;
  if ( (unsigned int)v77 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v77 = stack.handleArgCount;
  }
  stack.handleArgs[v77] = &v95;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v72, &stack);
  p_nullTexture = &floatZ;
  if ( !floatZStreamOcclusionCulling )
    p_nullTexture = &nullTexture;
  memset_0(&stack, 0, sizeof(stack));
  v79 = g_R_TG_Def_RBT_DV_PipelineStreamingData.m_index;
  stack.handleArgs[0] = &v90;
  v80 = stack.handleArgCount + 1;
  stack.handleArgCount = v80;
  if ( (unsigned int)v80 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v80 = stack.handleArgCount;
  }
  stack.handleArgs[v80] = &v91;
  v81 = stack.handleArgCount + 1;
  stack.handleArgCount = v81;
  if ( (unsigned int)v81 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v81 = stack.handleArgCount;
  }
  stack.handleArgs[v81] = &v93;
  v82 = stack.handleArgCount + 1;
  stack.handleArgCount = v82;
  if ( (unsigned int)v82 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v82 = stack.handleArgCount;
  }
  stack.handleArgs[v82] = &v92;
  v83 = stack.handleArgCount + 1;
  stack.handleArgCount = v83;
  if ( (unsigned int)v83 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v83 = stack.handleArgCount;
  }
  stack.handleArgs[v83] = &v95;
  v84 = stack.handleArgCount + 1;
  stack.handleArgCount = v84;
  if ( (unsigned int)v84 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v84 = stack.handleArgCount;
  }
  stack.handleArgs[v84] = &p_nullTexture->index;
  v85 = stack.handleArgCount + 1;
  stack.handleArgCount = v85;
  if ( (unsigned int)v85 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v85 = stack.handleArgCount;
  }
  stack.handleArgs[v85] = (unsigned int *)&v96;
  v86 = stack.handleArgCount + 1;
  stack.handleArgCount = v86;
  if ( (unsigned int)v86 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v86 = stack.handleArgCount;
  }
  stack.handleArgs[v86] = (unsigned int *)&v97;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v79, &stack);
  memset_0(&stack, 0, sizeof(stack));
  v87 = g_R_TG_Def_RBT_DV_PipelineStreamingDataTransfer.m_index;
  stack.handleArgs[0] = (unsigned int *)&v96;
  v88 = stack.handleArgCount + 1;
  stack.handleArgCount = v88;
  if ( (unsigned int)v88 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v88 = stack.handleArgCount;
  }
  stack.handleArgs[v88] = (unsigned int *)&v97;
  ++stack.handleArgCount;
  R_TG_AddTask(pScript, v87, &stack);
  if ( v94 )
  {
    v100->index = v92;
    v101->index = v90;
    v102->index = v91;
    v103->index = v93;
    v105->index = v95;
    index = v98;
  }
  else
  {
    index = nullBuffer.index;
    v100->index = nullBuffer.index;
    v101->index = nullBuffer.index;
    v102->index = nullBuffer.index;
    v103->index = nullBuffer.index;
  }
  v104->index = index;
}

