/*
==============
ParticleModuleVectorFieldGraph::Init
==============
*/

void __fastcall ParticleModuleVectorFieldGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleVectorFieldGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleRotationGraph::Init
==============
*/

void __fastcall ParticleModuleRotationGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleRotationGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModulePositionGraph::Update
==============
*/

void __fastcall ParticleModulePositionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModulePositionGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleEmissiveGraph::Init
==============
*/

void __fastcall ParticleModuleEmissiveGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleEmissiveGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleVelocityGraph::Init
==============
*/

void __fastcall ParticleModuleVelocityGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleVelocityGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleRotationGraph::Update
==============
*/

void __fastcall ParticleModuleRotationGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleRotationGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleIntensityGraph::Update
==============
*/

void __fastcall ParticleModuleIntensityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleIntensityGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleSizeGraph::Init
==============
*/

void __fastcall ParticleModuleSizeGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleSizeGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleAttractor::Update
==============
*/

void __fastcall ParticleModuleAttractor::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleAttractor@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleTemperatureGraph::Update
==============
*/

void __fastcall ParticleModuleTemperatureGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleTemperatureGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleSizeGraph::Update
==============
*/

void __fastcall ParticleModuleSizeGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleSizeGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleTemperatureGraph::Init
==============
*/

void __fastcall ParticleModuleTemperatureGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleTemperatureGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleIntensityGraph::Init
==============
*/

void __fastcall ParticleModuleIntensityGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleIntensityGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleEmissionGraph::GetSpawnRate
==============
*/

double __fastcall ParticleModuleEmissionGraph::GetSpawnRate(ParticleModuleEmissionGraph *this, float time, unsigned __int16 randomSeed)
{
  double result; 

  *(float *)&result = ?GetSpawnRate@ParticleModuleEmissionGraph@@QEBAMMG@Z(this, time, randomSeed);
  return result;
}

/*
==============
ParticleModuleColorGraph::Init
==============
*/

void __fastcall ParticleModuleColorGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleColorGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleVelocityGraph::Update
==============
*/

void __fastcall ParticleModuleVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleVelocityGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleForce::Update
==============
*/

void __fastcall ParticleModuleForce::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleForce@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleScaleByDistance::Update
==============
*/

void __fastcall ParticleModuleScaleByDistance::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleScaleByDistance@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleSizeLerp::Update
==============
*/

void __fastcall ParticleModuleSizeLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleSizeLerp@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleEmissionGraph::Init
==============
*/

void __fastcall ParticleModuleEmissionGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleEmissionGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleForceDragGraph::Update
==============
*/

void __fastcall ParticleModuleForceDragGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleForceDragGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePhysicsRayCast::Update
==============
*/

void __fastcall ParticleModulePhysicsRayCast::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModulePhysicsRayCast@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleParentVelocityGraph::Init
==============
*/

void __fastcall ParticleModuleParentVelocityGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleParentVelocityGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleShaderGraph::Init
==============
*/

void __fastcall ParticleModuleShaderGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleShaderGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleShaderGraph::Update
==============
*/

void __fastcall ParticleModuleShaderGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleShaderGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleParentVelocityGraph::Update
==============
*/

void __fastcall ParticleModuleParentVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleParentVelocityGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePositionGraph::Init
==============
*/

void __fastcall ParticleModulePositionGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModulePositionGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleEmissiveGraph::Update
==============
*/

void __fastcall ParticleModuleEmissiveGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleEmissiveGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleEmissionGraph::Update
==============
*/

void __fastcall ParticleModuleEmissionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleEmissionGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleForceDragGraph::Init
==============
*/

void __fastcall ParticleModuleForceDragGraph::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleForceDragGraph@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleVectorFieldGraph::Update
==============
*/

void __fastcall ParticleModuleVectorFieldGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleVectorFieldGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleRotationGraph3D::Init
==============
*/

void __fastcall ParticleModuleRotationGraph3D::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleRotationGraph3D@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleGravity::Update
==============
*/

void __fastcall ParticleModuleGravity::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleGravity@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleScaleByDistance::Init
==============
*/

void __fastcall ParticleModuleScaleByDistance::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleScaleByDistance@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleGravity::Init
==============
*/

void __fastcall ParticleModuleGravity::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModuleGravity@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModulePhysicsLight::InitPhysicsParticles
==============
*/

void __fastcall ParticleModulePhysicsLight::InitPhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  ?InitPhysicsParticles@ParticleModulePhysicsLight@@QEBAXPEAUParticleData@@IPEAVParticleState@@@Z(this, pParticleData, particleCountEmit, pParticleState);
}

/*
==============
ParticleModuleColorGraph::Update
==============
*/

void __fastcall ParticleModuleColorGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleColorGraph@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePhysicsLight::CreatePhysicsParticles
==============
*/

void __fastcall ParticleModulePhysicsLight::CreatePhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleOffset, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  ?CreatePhysicsParticles@ParticleModulePhysicsLight@@QEBAXPEAUParticleData@@IIPEAVParticleState@@@Z(this, pParticleData, particleOffset, particleCountEmit, pParticleState);
}

/*
==============
ParticleModulePhysicsRayCast::Init
==============
*/

void __fastcall ParticleModulePhysicsRayCast::Init(ParticleModule *pModuleBase)
{
  ?Init@ParticleModulePhysicsRayCast@@SAXPEAUParticleModule@@@Z(pModuleBase);
}

/*
==============
ParticleModuleRotationGraph3D::Update
==============
*/

void __fastcall ParticleModuleRotationGraph3D::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleRotationGraph3D@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleAttractor::DebugDraw
==============
*/

void __fastcall ParticleModuleAttractor::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  ?DebugDraw@ParticleModuleAttractor@@SAXPEBUParticleModule@@PEBVParticleEmitter@@PEBUParticleData@@PEBVParticleState@@@Z(pModuleBase, pEmitterOwner, pParticleData, pParticleState);
}

/*
==============
ParticleModulePhysicsLight::Update
==============
*/

void __fastcall ParticleModulePhysicsLight::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModulePhysicsLight@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, dt, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModuleColorLerp::Update
==============
*/

void __fastcall ParticleModuleColorLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ?Update@ParticleModuleColorLerp@@SAXPEBUParticleModule@@PEAUParticleData@@IIMPEBVParticleEmitter@@PEBVParticleState@@@Z(pModuleBase, pParticleData, particleOffset, particleCount, __formal, pEmitterOwner, pParticleState);
}

/*
==============
ParticleModulePhysicsLight::CreatePhysicsParticles
==============
*/
void ParticleModulePhysicsLight::CreatePhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleOffset, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  __int64 v17; 
  HavokPhysicsFX_Pipeline *m_physicsFXPipelineInstance; 
  int m_physicsFXShapeIndex; 
  unsigned int *FlagsArrayAtIndex; 
  const vector4 *EmitterTransform; 
  __int64 v22; 
  int *v23; 
  int Particles; 
  unsigned int v25; 
  unsigned int v26; 
  signed __int64 v27; 
  float4 *v29; 
  signed __int64 v31; 
  signed __int64 v33; 
  int v36; 
  const ParticleStateDef *m_pStateDef; 
  char v40; 
  bool v41; 
  const float4 *v43; 
  float4 *v44; 
  const char *VFXName; 
  const char *v100; 
  const char *v104; 
  const char *v108; 
  Physics_WorldId v109; 
  ParticleSystem *SystemOwner; 
  const ParticleSystemDef *Def; 
  unsigned int v131; 
  unsigned int v132; 
  char *fmt; 
  __int64 v134; 
  __int64 v135; 
  int v137; 
  int v138; 
  int v139; 
  int v140; 
  int v141; 
  int v142; 
  int v143; 
  int v144; 
  int v145; 
  bool m_ignoreEmitterOrientation; 
  Physics_WorldId m_physicsWorldId; 
  float4 *RotationRateArrayAtIndex; 
  signed __int64 v150; 
  float4 *RotationAngleArrayAtIndex; 
  signed __int64 v152; 
  int *particleIds; 
  int *particleIdsa; 
  unsigned __int8 *v155; 
  signed __int64 v156; 
  float4 *VelocityArrayAtIndex; 
  signed __int64 v158; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v160; 
  float4 *PositionArrayAtIndex; 
  float4 *SizeArrayAtIndex; 
  signed __int64 v163; 
  ParticleEmitter *m_pEmitterOwner; 
  ParticleModuleScaleByDistance *pModuleScaleByDistance; 
  signed __int64 v166; 
  vec3_t position; 
  vec3_t velocity; 
  vec3_t v169; 
  vec4_t orientation; 
  vec4_t quat; 

  v17 = particleOffset;
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1280, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1281, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  m_physicsFXPipelineInstance = pParticleState->m_physicsFXPipelineInstance;
  if ( !m_physicsFXPipelineInstance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1284, ASSERT_TYPE_ASSERT, "(physicsFXPipeline)", (const char *)&queryFormat, "physicsFXPipeline") )
    __debugbreak();
  m_physicsFXShapeIndex = pParticleState->m_physicsFXShapeIndex;
  particleIds = ParticleState::GetPhysicsFXParticleIDList(pParticleState);
  if ( !particleIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1289, ASSERT_TYPE_ASSERT, "(physicsFXParticleIDList)", (const char *)&queryFormat, "physicsFXParticleIDList") )
    __debugbreak();
  m_physicsWorldId = pParticleState->m_physicsWorldId;
  PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, v17);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, v17);
  SizeArrayAtIndex = Particle_GetSizeArrayAtIndex(pParticleData, v17);
  RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, v17);
  RotationAngleArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, v17);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, v17);
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = (ParticleEmitter *)pParticleState->m_pEmitterOwner;
  EmitterTransform = ParticleEmitter::GetEmitterTransform(m_pEmitterOwner, pParticleState);
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, v17);
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v17 >= pParticleData->m_particleCountMax )
  {
    LODWORD(v134) = v17;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v134, pParticleData->m_particleCountMax) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 361, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v22 = v17;
  v155 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_CAMERA_DISTANCE)[v22 * 4];
  pModuleScaleByDistance = (ParticleModuleScaleByDistance *)pParticleState->m_pModuleScaleByDistance;
  if ( !pModuleScaleByDistance && (pParticleState->m_pStateDef->flags & 0x800000000i64) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1307, ASSERT_TYPE_ASSERT, "(pModuleScaleByDistance || !pParticleState->HasFlag( PARTICLE_STATE_DEF_FLAG_SCALE_BY_DISTANCE ))", (const char *)&queryFormat, "pModuleScaleByDistance || !pParticleState->HasFlag( PARTICLE_STATE_DEF_FLAG_SCALE_BY_DISTANCE )") )
    __debugbreak();
  v23 = &particleIds[v22];
  particleIdsa = v23;
  Particles = PhysicsFX_CreateParticles(m_physicsWorldId, m_physicsFXPipelineInstance, m_physicsFXShapeIndex, particleCountEmit, v23);
  v25 = particleCountEmit;
  if ( Particles != particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1312, ASSERT_TYPE_ASSERT, "(static_cast<uint>( numParticlesAllocated ) == particleCountEmit)", (const char *)&queryFormat, "static_cast<uint>( numParticlesAllocated ) == particleCountEmit") )
    __debugbreak();
  m_ignoreEmitterOrientation = this->m_ignoreEmitterOrientation;
  if ( !m_ignoreEmitterOrientation )
    Particle_RotMatrixToQuatVec(EmitterTransform, &quat);
  v26 = 0;
  if ( particleCountEmit )
  {
    v27 = (char *)v23 - (char *)RandomSeedArrayAtIndex;
    _R8 = v155 - (unsigned __int8 *)RandomSeedArrayAtIndex;
    v29 = PositionArrayAtIndex;
    _R11 = (char *)SizeArrayAtIndex - (char *)VelocityArrayAtIndex;
    v150 = (char *)RotationRateArrayAtIndex - (char *)VelocityArrayAtIndex;
    v31 = (char *)RandomSeedArrayAtIndex - (char *)FlagsArrayAtIndex;
    v152 = (char *)RotationAngleArrayAtIndex - (char *)VelocityArrayAtIndex;
    _RSI = PositionArrayAtIndex;
    __asm { vmovaps [rsp+1E0h+var_48+8], xmm6 }
    v33 = (char *)VelocityArrayAtIndex - (char *)PositionArrayAtIndex;
    __asm
    {
      vmovaps [rsp+1E0h+var_D8+8], xmm15
      vmovaps [rsp+1E0h+var_58+8], xmm7
      vmovaps [rsp+1E0h+var_68+8], xmm8
      vmovaps [rsp+1E0h+var_78+8], xmm9
      vmovaps [rsp+1E0h+var_88+8], xmm10
      vmovaps [rsp+1E0h+var_98+8], xmm11
      vmovaps [rsp+1E0h+var_A8+8], xmm12
      vmovaps [rsp+1E0h+var_B8+8], xmm13
      vmovaps [rsp+1E0h+var_C8+8], xmm14
    }
    v166 = (char *)v23 - (char *)RandomSeedArrayAtIndex;
    v163 = (char *)SizeArrayAtIndex - (char *)VelocityArrayAtIndex;
    v156 = v155 - (unsigned __int8 *)RandomSeedArrayAtIndex;
    v160 = (char *)RandomSeedArrayAtIndex - (char *)FlagsArrayAtIndex;
    v158 = (char *)VelocityArrayAtIndex - (char *)PositionArrayAtIndex;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    do
    {
      _RDX = (int *)((char *)FlagsArrayAtIndex + v31);
      v36 = *(unsigned int *)((char *)FlagsArrayAtIndex + v31 + v27);
      _RDI = (char *)_RSI + v33;
      m_pStateDef = pParticleState->m_pStateDef;
      __asm { vmovups xmm15, xmmword ptr [rdi+r11] }
      v40 = 0;
      v41 = (m_pStateDef->flags & 0x800000000i64) == 0;
      if ( (m_pStateDef->flags & 0x800000000i64) != 0 )
      {
        __asm { vmovss  xmm2, dword ptr [rdx+r8]; cameraDistance }
        ParticleEmitter::GetScaleFactorByCameraDistance(m_pEmitterOwner, pModuleScaleByDistance, *(float *)&_XMM2, *_RDX);
        v29 = PositionArrayAtIndex;
        __asm { vmulss  xmm15, xmm15, xmm0 }
      }
      __asm { vcomiss xmm15, xmm6 }
      if ( v40 | v41 || !PhysicsFX_IsValidParticlePosition(&v29[v26]) )
      {
        SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner(m_pEmitterOwner);
        Def = ParticleSystem::GetDef(SystemOwner);
        __asm
        {
          vmovups xmm2, xmmword ptr [rsi]
          vbroadcastss xmm1, dword ptr [rsi+4]
          vbroadcastss xmm0, dword ptr [rsi+8]
          vcvtss2sd xmm3, xmm1, xmm1
          vcvtss2sd xmm2, xmm2, xmm2
          vcvtss2sd xmm4, xmm0, xmm0
          vmovq   r9, xmm3
          vmovq   r8, xmm2
          vmovsd  [rsp+1E0h+fmt], xmm4
        }
        Com_PrintWarning(21, "WARNING: Particle position of (%f,%f,%f) outside PHYSICS_FX_MAX_POS, or zero scale for effect: %s\n", _R8, _R9, fmt, Def->name);
        *FlagsArrayAtIndex |= 1u;
        v109 = m_physicsWorldId;
      }
      else
      {
        __asm { vmovups xmm1, xmmword ptr [rsi] }
        _RAX = v150;
        __asm
        {
          vmovss  dword ptr [rbp+0E0h+position], xmm1
          vextractps dword ptr [rbp+0E0h+position+4], xmm1, 1
          vextractps dword ptr [rbp+0E0h+position+8], xmm1, 2
          vmovups xmm2, xmmword ptr [rdi]
          vmovss  dword ptr [rbp+0E0h+velocity], xmm2
          vextractps dword ptr [rbp+0E0h+velocity+4], xmm2, 1
          vextractps dword ptr [rbp+0E0h+velocity+8], xmm2, 2
          vmovups xmm2, xmmword ptr [rdi+rax]
        }
        _RAX = v152;
        __asm
        {
          vmovss  dword ptr [rbp+0E0h+var_110], xmm2
          vextractps dword ptr [rbp+0E0h+var_110+4], xmm2, 1
          vextractps dword ptr [rbp+0E0h+var_110+8], xmm2, 2
          vmovups xmm0, xmmword ptr [rdi+rax]
        }
        Float4RadianToQuat(v44, v43);
        __asm { vmovups xmm11, xmm0 }
        if ( m_ignoreEmitterOrientation )
        {
          __asm
          {
            vmovups xmmword ptr [rbp+0E0h+orientation], xmm11
            vmovss  xmm14, dword ptr [rbp+0E0h+orientation+8]
            vmovss  xmm13, dword ptr [rbp+0E0h+orientation+4]
            vmovss  xmm12, dword ptr [rbp+0E0h+orientation]
            vshufps xmm4, xmm11, xmm11, 0FFh
          }
        }
        else
        {
          __asm
          {
            vmovss  xmm6, dword ptr [rbp+0E0h+quat+8]
            vmovss  xmm4, dword ptr [rbp+0E0h+quat+4]
            vmovss  xmm10, dword ptr [rbp+0E0h+quat+0Ch]
            vmovss  xmm8, dword ptr [rbp+0E0h+quat]
            vshufps xmm9, xmm0, xmm0, 0FFh
            vshufps xmm7, xmm0, xmm0, 55h ; 'U'
            vshufps xmm5, xmm11, xmm11, 0AAh ; 'ª'
            vmulss  xmm0, xmm7, xmm6
            vmulss  xmm2, xmm11, xmm10
            vmulss  xmm1, xmm9, xmm8
            vaddss  xmm3, xmm2, xmm1
            vaddss  xmm1, xmm3, xmm0
            vmulss  xmm0, xmm5, xmm4
            vsubss  xmm12, xmm1, xmm0
            vmulss  xmm1, xmm4, xmm9
            vmulss  xmm0, xmm6, xmm11
            vsubss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm7, xmm10
            vaddss  xmm3, xmm2, xmm1
            vmulss  xmm1, xmm4, xmm11
            vmulss  xmm0, xmm5, xmm8
            vaddss  xmm13, xmm3, xmm0
            vmulss  xmm0, xmm6, xmm9
            vaddss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm7, xmm8
            vsubss  xmm3, xmm2, xmm1
            vmulss  xmm0, xmm5, xmm10
            vaddss  xmm14, xmm3, xmm0
            vmulss  xmm0, xmm11, xmm8
            vmulss  xmm1, xmm10, xmm9
            vsubss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm4, xmm7
            vmulss  xmm0, xmm5, xmm6
            vsubss  xmm3, xmm2, xmm1
            vsubss  xmm4, xmm3, xmm0
            vmovss  dword ptr [rbp+0E0h+orientation+0Ch], xmm4
            vmovss  dword ptr [rbp+0E0h+orientation], xmm12
            vmovss  dword ptr [rbp+0E0h+orientation+4], xmm13
            vmovss  dword ptr [rbp+0E0h+orientation+8], xmm14
            vxorps  xmm6, xmm6, xmm6
          }
        }
        __asm
        {
          vmulss  xmm1, xmm12, xmm12
          vmulss  xmm0, xmm13, xmm13
          vaddss  xmm2, xmm1, xmm0
          vmulss  xmm1, xmm14, xmm14
          vaddss  xmm3, xmm2, xmm1
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm2, xmm3, xmm0
          vsubss  xmm1, xmm2, cs:__real@3f800000
          vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vcomiss xmm1, cs:__real@3b03126f
        }
        VFXName = ParticleState::GetVFXName(pParticleState);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1362, ASSERT_TYPE_ASSERT, "(Vec4IsNormalized( orientation ))", "%s\n\tVFX ERROR: Unnormalized quat when initializing HavokFX particle: %s\n", "Vec4IsNormalized( orientation )", VFXName) )
          __debugbreak();
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+position]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v137 & 0x7F800000) == 2139095040 )
          goto LABEL_72;
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+position+4]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v138 & 0x7F800000) == 2139095040 )
          goto LABEL_72;
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+position+8]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v139 & 0x7F800000) == 2139095040 )
        {
LABEL_72:
          v100 = ParticleState::GetVFXName(pParticleState);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1364, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( position )[0] ) && !IS_NAN( ( position )[1] ) && !IS_NAN( ( position )[2] ) ) )", "fx %s", v100) )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+velocity]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v140 & 0x7F800000) == 2139095040 )
          goto LABEL_73;
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+velocity+4]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v141 & 0x7F800000) == 2139095040 )
          goto LABEL_73;
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+velocity+8]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v142 & 0x7F800000) == 2139095040 )
        {
LABEL_73:
          v104 = ParticleState::GetVFXName(pParticleState);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1365, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( velocity )[0] ) && !IS_NAN( ( velocity )[1] ) && !IS_NAN( ( velocity )[2] ) ) )", "fx %s", v104) )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+var_110]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v143 & 0x7F800000) == 2139095040 )
          goto LABEL_74;
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+var_110+4]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v144 & 0x7F800000) == 2139095040 )
          goto LABEL_74;
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0E0h+var_110+8]
          vmovss  [rsp+1E0h+var_1A0], xmm0
        }
        if ( (v145 & 0x7F800000) == 2139095040 )
        {
LABEL_74:
          v108 = ParticleState::GetVFXName(pParticleState);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1366, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( angularVelocity )[0] ) && !IS_NAN( ( angularVelocity )[1] ) && !IS_NAN( ( angularVelocity )[2] ) ) )", "fx %s", v108) )
            __debugbreak();
        }
        v109 = m_physicsWorldId;
        PhysicsFX_SetParticlePosition(m_physicsWorldId, m_physicsFXPipelineInstance, v36, &position);
        PhysicsFX_SetParticleLinearVelocity(m_physicsWorldId, m_physicsFXPipelineInstance, v36, &velocity);
        PhysicsFX_SetParticleAngularVelocity(m_physicsWorldId, m_physicsFXPipelineInstance, v36, &v169);
        __asm { vmovaps xmm3, xmm15; scale }
        PhysicsFX_SetParticleScale(m_physicsWorldId, m_physicsFXPipelineInstance, v36, *(float *)&_XMM3);
        PhysicsFX_SetParticleOrientation(m_physicsWorldId, m_physicsFXPipelineInstance, v36, &orientation);
      }
      v25 = particleCountEmit;
      PhysicsFX_ParticlesUpdated(v109, m_physicsFXPipelineInstance, particleCountEmit, particleIdsa);
      ++v26;
      _R8 = v156;
      v31 = v160;
      v27 = v166;
      ++_RSI;
      v29 = PositionArrayAtIndex;
      _R11 = v163;
      *FlagsArrayAtIndex = *FlagsArrayAtIndex & 0xFFFFFFBD | 0x40;
      ++FlagsArrayAtIndex;
      v33 = v158;
    }
    while ( v26 < particleCountEmit );
    __asm
    {
      vmovaps xmm15, [rsp+1E0h+var_D8+8]
      vmovaps xmm14, [rsp+1E0h+var_C8+8]
      vmovaps xmm13, [rsp+1E0h+var_B8+8]
      vmovaps xmm12, [rsp+1E0h+var_A8+8]
      vmovaps xmm11, [rsp+1E0h+var_98+8]
      vmovaps xmm10, [rsp+1E0h+var_88+8]
      vmovaps xmm9, [rsp+1E0h+var_78+8]
      vmovaps xmm8, [rsp+1E0h+var_68+8]
      vmovaps xmm7, [rsp+1E0h+var_58+8]
      vmovaps xmm6, [rsp+1E0h+var_48+8]
    }
  }
  v131 = v25 + pParticleState->m_numPhysicsFXParticles;
  v132 = pParticleState->m_particleCountMax + 1;
  pParticleState->m_numPhysicsFXParticles = v131;
  if ( v131 >= v132 )
  {
    LODWORD(v135) = v132;
    LODWORD(v134) = v131;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 565, ASSERT_TYPE_ASSERT, "(unsigned)( m_numPhysicsFXParticles ) < (unsigned)( m_particleCountMax + 1 )", "m_numPhysicsFXParticles doesn't index m_particleCountMax + 1\n\t%i not in [0, %i)", v134, v135) )
      __debugbreak();
  }
}

/*
==============
ParticleModuleAttractor::DebugDraw
==============
*/
void ParticleModuleAttractor::DebugDraw(const ParticleModule *pModuleBase, const ParticleEmitter *pEmitterOwner, const ParticleData *pParticleData, const ParticleState *pParticleState)
{
  vec3_t center; 

  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 474, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 475, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 476, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 477, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( ParticleModule::GlobalModuleDebugDraw((ParticleModule *)pModuleBase) )
  {
    _RAX = ParticleEmitter::GetEmitterPos((ParticleEmitter *)pEmitterOwner, pParticleState);
    __asm
    {
      vmovups xmm1, xmmword ptr [rax]
      vaddps  xmm2, xmm1, xmmword ptr [rbx+20h]
      vmovss  xmm1, cs:__real@40a00000; radius
      vmovss  dword ptr [rsp+78h+center], xmm2
      vextractps dword ptr [rsp+78h+center+4], xmm2, 1
      vextractps dword ptr [rsp+78h+center+8], xmm2, 2
    }
    Particle_DebugSphere(&center, *(float *)&_XMM1, &colorLtGreen, 1, 0);
  }
}

/*
==============
ParticleModuleEmissionGraph::GetSpawnRate
==============
*/

float __fastcall ParticleModuleEmissionGraph::GetSpawnRate(ParticleModuleEmissionGraph *this, double time, unsigned __int16 randomSeed)
{
  unsigned int v8; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps [rsp+48h+var_28], xmm7
    vmovaps xmm7, xmm1
  }
  v8 = this->m_flags >> 4;
  *(double *)&_XMM0 = Particle_GetCurveValue(this->m_curves, *(const float *)&time);
  __asm { vmulss  xmm6, xmm0, dword ptr [rdi+1Ch] }
  if ( (v8 & 1) != 0 )
  {
    __asm { vmovaps xmm1, xmm7; time }
    *(double *)&_XMM0 = Particle_GetCurveValue(&this->m_curves[1], *(const float *)&_XMM1);
    __asm
    {
      vmulss  xmm4, xmm0, dword ptr [rdi+2Ch]
      vmovss  xmm0, cs:__real@3f800000
      vsubss  xmm1, xmm0, dword ptr [rcx+rax*4]
      vmulss  xmm2, xmm4, dword ptr [rcx+rax*4]
      vmulss  xmm3, xmm1, xmm6
      vaddss  xmm0, xmm3, xmm2
    }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
  __asm
  {
    vmovaps xmm6, [rsp+48h+var_18]
    vmovaps xmm7, [rsp+48h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
ParticleModuleColorGraph::Init
==============
*/
void ParticleModuleColorGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
}

/*
==============
ParticleModuleEmissionGraph::Init
==============
*/
void ParticleModuleEmissionGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase->m_flags |= 0x200u;
}

/*
==============
ParticleModuleEmissiveGraph::Init
==============
*/
void ParticleModuleEmissiveGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
  pModuleBase[19].m_flags = 1065353216;
  pModuleBase[21].m_flags = 1065353216;
  pModuleBase[11].m_flags = 0;
  pModuleBase[21].m_flags = 0;
}

/*
==============
ParticleModuleForceDragGraph::Init
==============
*/
void ParticleModuleForceDragGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleGravity::Init
==============
*/
void ParticleModuleGravity::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 1065353216;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModuleIntensityGraph::Init
==============
*/
void ParticleModuleIntensityGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleParentVelocityGraph::Init
==============
*/
void ParticleModuleParentVelocityGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModulePhysicsRayCast::Init
==============
*/
void ParticleModulePhysicsRayCast::Init(ParticleModule *pModuleBase)
{
  *(_DWORD *)&pModuleBase[1].m_type = 1065353216;
  pModuleBase[1].m_flags = 1065353216;
}

/*
==============
ParticleModulePositionGraph::Init
==============
*/
void ParticleModulePositionGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
}

/*
==============
ParticleModuleRotationGraph3D::Init
==============
*/
void ParticleModuleRotationGraph3D::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 0;
  pModuleBase[5].m_flags = 0;
  pModuleBase[7].m_flags = 0;
  pModuleBase[9].m_flags = 0;
  pModuleBase[11].m_flags = 0;
  pModuleBase[13].m_flags = 0;
}

/*
==============
ParticleModuleRotationGraph::Init
==============
*/
void ParticleModuleRotationGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 0;
  pModuleBase[5].m_flags = 0;
}

/*
==============
ParticleModuleScaleByDistance::Init
==============
*/
void ParticleModuleScaleByDistance::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  *(_DWORD *)&pModuleBase[6].m_type = 1148846080;
}

/*
==============
ParticleModuleShaderGraph::Init
==============
*/
void ParticleModuleShaderGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
  pModuleBase[15].m_flags = 1065353216;
  pModuleBase[17].m_flags = 1065353216;
  pModuleBase[19].m_flags = 1065353216;
  pModuleBase[21].m_flags = 1065353216;
  pModuleBase[23].m_flags = 1065353216;
  pModuleBase[25].m_flags = 1065353216;
}

/*
==============
ParticleModuleSizeGraph::Init
==============
*/
void ParticleModuleSizeGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
}

/*
==============
ParticleModuleTemperatureGraph::Init
==============
*/
void ParticleModuleTemperatureGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleVectorFieldGraph::Init
==============
*/
void ParticleModuleVectorFieldGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
}

/*
==============
ParticleModuleVelocityGraph::Init
==============
*/
void ParticleModuleVelocityGraph::Init(ParticleModule *pModuleBase)
{
  pModuleBase[3].m_flags = 1065353216;
  pModuleBase[5].m_flags = 1065353216;
  pModuleBase[7].m_flags = 1065353216;
  pModuleBase[9].m_flags = 1065353216;
  pModuleBase[11].m_flags = 1065353216;
  pModuleBase[13].m_flags = 1065353216;
}

/*
==============
ParticleModulePhysicsLight::InitPhysicsParticles
==============
*/
void ParticleModulePhysicsLight::InitPhysicsParticles(ParticleModulePhysicsLight *this, ParticleData *pParticleData, const unsigned int particleCountEmit, ParticleState *pParticleState)
{
  unsigned int m_particleCountRunning; 
  const ParticleEmitter *m_pEmitterOwner; 
  LocalClientNum_t m_localClientNum; 
  const ParticleSystem *SystemOwner; 
  ParticleSystemHandle particleSystemHandle; 
  unsigned int v16; 
  unsigned int *v24; 
  __int64 v25; 

  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1397, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !particleCountEmit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1398, ASSERT_TYPE_ASSERT, "(particleCountEmit > 0)", (const char *)&queryFormat, "particleCountEmit > 0") )
    __debugbreak();
  if ( particleCountEmit + pParticleData->m_particleCountRunning > pParticleData->m_particleCountMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1399, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax())", (const char *)&queryFormat, "pParticleData->GetParticleCountRunning() + particleCountEmit <= pParticleData->GetParticleCountMax()") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1400, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  m_particleCountRunning = pParticleData->m_particleCountRunning;
  _R14 = Particle_GetFlagsArrayAtIndex(pParticleData, m_particleCountRunning);
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  m_pEmitterOwner = pParticleState->m_pEmitterOwner;
  m_localClientNum = m_pEmitterOwner->m_pSystemOwner->m_localClientNum;
  if ( !m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  SystemOwner = ParticleEmitter::GetSystemOwner((ParticleEmitter *)pParticleState->m_pEmitterOwner);
  if ( SystemOwner->m_systemHandle == PARTICLE_SYSTEM_INVALID_HANDLE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlesystem.h", 196, ASSERT_TYPE_ASSERT, "(m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE)", (const char *)&queryFormat, "m_systemHandle != PARTICLE_SYSTEM_INVALID_HANDLE") )
    __debugbreak();
  particleSystemHandle = SystemOwner->m_systemHandle;
  if ( !pParticleState->m_pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 341, ASSERT_TYPE_ASSERT, "(m_pEmitterOwner)", (const char *)&queryFormat, "m_pEmitterOwner") )
    __debugbreak();
  Particle_AddDeferredPhysicsFXCreate(m_localClientNum, this, pParticleData, m_particleCountRunning, particleCountEmit, pParticleState, pParticleState->m_pEmitterOwner, particleSystemHandle);
  _RDX = 0i64;
  if ( particleCountEmit )
  {
    if ( particleCountEmit >= 0x10 )
    {
      __asm { vmovdqu xmm2, cs:__xmm@00000002000000020000000200000002 }
      v16 = 8;
      do
      {
        __asm
        {
          vpor    xmm1, xmm2, xmmword ptr [r14+rdx*4]
          vmovdqu xmmword ptr [r14+rdx*4], xmm1
        }
        _RAX = v16 - 4;
        _RDX = (unsigned int)(_RDX + 16);
        __asm
        {
          vpor    xmm1, xmm2, xmmword ptr [r14+rax*4]
          vmovdqu xmmword ptr [r14+rax*4], xmm1
        }
        _RAX = v16;
        __asm
        {
          vpor    xmm1, xmm2, xmmword ptr [r14+rax*4]
          vmovdqu xmmword ptr [r14+rax*4], xmm1
        }
        _RAX = v16 + 4;
        v16 += 16;
        __asm
        {
          vpor    xmm1, xmm2, xmmword ptr [r14+rax*4]
          vmovdqu xmmword ptr [r14+rax*4], xmm1
        }
      }
      while ( (unsigned int)_RDX < (particleCountEmit & 0xFFFFFFF0) );
    }
    if ( (unsigned int)_RDX < particleCountEmit )
    {
      v24 = &_R14[_RDX];
      v25 = particleCountEmit - (unsigned int)_RDX;
      do
      {
        *v24++ |= 2u;
        --v25;
      }
      while ( v25 );
    }
  }
}

/*
==============
Particle_TransformForceRelativeToEffectOrigin
==============
*/
void Particle_TransformForceRelativeToEffectOrigin(const float4 *spawnQuat, const vector4 *rEmitterTransformTranspose, bool worldForce, const float4 *force, float4 *outForceTransformed)
{
  _RAX = outForceTransformed;
  if ( worldForce )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [r9]
      vshufps xmm2, xmm0, xmm0, 0
      vshufps xmm4, xmm0, xmm0, 55h ; 'U'
      vshufps xmm5, xmm0, xmm0, 0AAh ; 'ª'
      vmulps  xmm0, xmm2, xmmword ptr [rdx]
      vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm4, xmmword ptr [rdx+10h]
      vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmulps  xmm0, xmm5, xmmword ptr [rdx+20h]
      vaddps  xmm1, xmm0, xmm3
      vaddps  xmm1, xmm2, xmm1
      vmovups xmmword ptr [rax], xmm1
      vandps  xmm0, xmm1, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
      vmovups xmmword ptr [rax], xmm0
    }
  }
  else
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rcx]
      vmovaps [rsp+48h+var_18], xmm6
      vshufps xmm6, xmm0, xmm0, 0C9h ; 'É'
      vmovaps [rsp+48h+var_28], xmm7
      vshufps xmm7, xmm0, xmm0, 0D2h ; 'Ò'
      vshufps xmm5, xmm0, xmm0, 0FFh
      vmovaps [rsp+48h+var_38], xmm8
      vmovups xmm8, xmmword ptr [r9]
      vshufps xmm0, xmm8, xmm8, 0D2h ; 'Ò'
      vmulps  xmm3, xmm0, xmm6
      vshufps xmm1, xmm8, xmm8, 0C9h ; 'É'
      vmulps  xmm2, xmm1, xmm7
      vsubps  xmm0, xmm3, xmm2
      vaddps  xmm4, xmm0, xmm0
      vmulps  xmm0, xmm5, xmm4
      vaddps  xmm5, xmm0, xmm8
      vmovaps xmm8, [rsp+48h+var_38]
      vshufps xmm1, xmm4, xmm4, 0D2h ; 'Ò'
      vmulps  xmm3, xmm1, xmm6
      vmovaps xmm6, [rsp+48h+var_18]
      vshufps xmm0, xmm4, xmm4, 0C9h ; 'É'
      vmulps  xmm2, xmm0, xmm7
      vmovaps xmm7, [rsp+48h+var_28]
      vsubps  xmm1, xmm3, xmm2
      vaddps  xmm3, xmm1, xmm5
      vmovups xmmword ptr [rax], xmm3
    }
  }
}

/*
==============
Particle_UpdateForceRayCast
==============
*/
void Particle_UpdateForceRayCast(const ParticleModuleForce *pModule, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, float dt, const vector4 *rEmitterTransform, bool noLerp, bool applyTransform, bool hasVelocityGraph, float emitterLife)
{
  __int64 v13; 
  unsigned int *FlagsArrayAtIndex; 
  float *SpawnTimeArrayAtIndex; 
  signed __int64 v21; 
  __int64 v22; 
  bool v38; 
  int *RandomSeedArrayAtIndex; 
  int *v40; 
  signed __int64 v44; 
  __int64 v45; 
  __int64 v74; 

  v13 = particleCount;
  _RSI = pModule;
  if ( !pModule && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 823, ASSERT_TYPE_ASSERT, "(pModule)", (const char *)&queryFormat, "pModule") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 824, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( (unsigned int)v13 + particleOffset >= pParticleData->m_particleCountRunning + 1 )
  {
    LODWORD(v74) = v13 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 825, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountRunning() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountRunning() + 1\n\t%i not in [0, %i)", v74, pParticleData->m_particleCountRunning + 1) )
      __debugbreak();
  }
  __asm { vmovaps [rsp+0A8h+var_48], xmm6 }
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, particleOffset);
  SpawnTimeArrayAtIndex = Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  _RBX = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  if ( noLerp )
  {
    if ( (_DWORD)v13 )
    {
      __asm { vmovss  xmm5, [rsp+0A8h+emitterLife] }
      v21 = (char *)FlagsArrayAtIndex - (char *)SpawnTimeArrayAtIndex;
      v22 = v13;
      __asm { vmovss  xmm6, [rsp+0A8h+dt] }
      do
      {
        if ( (*(_DWORD *)((_BYTE *)SpawnTimeArrayAtIndex + v21) & 0x10) == 0 )
        {
          if ( !applyTransform || (*(_DWORD *)((_BYTE *)SpawnTimeArrayAtIndex + v21) & 8) != 0 )
          {
            __asm { vmovups xmm4, xmmword ptr [rsi+10h] }
          }
          else
          {
            __asm
            {
              vmovups xmm0, xmmword ptr [rsi+10h]
              vshufps xmm1, xmm0, xmm0, 0AAh ; 'ª'
              vmulps  xmm1, xmm1, xmmword ptr [r9+20h]
              vshufps xmm2, xmm0, xmm0, 55h ; 'U'
              vshufps xmm3, xmm0, xmm0, 0
              vmulps  xmm0, xmm2, xmmword ptr [r9+10h]
              vaddps  xmm2, xmm0, xmm1
              vmulps  xmm0, xmm3, xmmword ptr [r9]
              vaddps  xmm4, xmm0, xmm2
            }
          }
          if ( !hasVelocityGraph || (*(_DWORD *)((_BYTE *)SpawnTimeArrayAtIndex + v21) & 8) != 0 )
            __asm { vmovaps xmm0, xmm6 }
          else
            __asm { vsubss  xmm0, xmm5, dword ptr [rdi] }
          __asm
          {
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmm4
            vaddps  xmm1, xmm0, xmmword ptr [rbx]
            vmovups xmmword ptr [rbx], xmm1
          }
        }
        ++SpawnTimeArrayAtIndex;
        ++_RBX;
        --v22;
      }
      while ( v22 );
    }
  }
  else
  {
    v38 = (_RSI->m_flags & 0x20) != 0;
    RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
    v40 = RandomSeedArrayAtIndex;
    __asm
    {
      vbroadcastss xmm6, [rsp+0A8h+dt]
      vmovups xmm5, xmm6
    }
    if ( (_DWORD)v13 )
    {
      _RBP = fx_randomTable;
      v44 = (char *)FlagsArrayAtIndex - (char *)RandomSeedArrayAtIndex;
      __asm { vmovaps [rsp+0A8h+var_58], xmm7 }
      v45 = v13;
      __asm { vmovss  xmm7, [rsp+0A8h+emitterLife] }
      do
      {
        if ( (*(int *)((char *)v40 + v44) & 0x10) == 0 )
        {
          if ( hasVelocityGraph && (*(int *)((char *)v40 + v44) & 8) != 0 )
            __asm { vmovups xmm5, xmm6 }
          _RDX = *v40;
          __asm { vmovups xmm0, xmmword ptr [rsi+20h] }
          if ( v38 )
          {
            __asm
            {
              vsubps  xmm0, xmm0, xmmword ptr [rsi+10h]
              vxorps  xmm1, xmm1, xmm1
              vinsertps xmm1, xmm1, dword ptr [rbp+rdx*4+0B0h], 0
              vinsertps xmm1, xmm1, dword ptr [rbp+rdx*4+0B4h], 10h
              vinsertps xmm1, xmm1, dword ptr [rbp+rdx*4+0B8h], 20h ; ' '
              vmulps  xmm1, xmm1, xmm0
              vaddps  xmm3, xmm1, xmmword ptr [rsi+10h]
            }
          }
          else
          {
            __asm
            {
              vsubps  xmm1, xmm0, xmmword ptr [rsi+10h]
              vbroadcastss xmm0, dword ptr [rbp+rdx*4+0B0h]
              vmulps  xmm0, xmm1, xmm0
              vaddps  xmm3, xmm0, xmmword ptr [rsi+10h]
            }
          }
          if ( hasVelocityGraph && (*(int *)((char *)v40 + v44) & 8) == 0 )
          {
            __asm
            {
              vsubss  xmm5, xmm7, dword ptr [rdi+rcx]
              vshufps xmm5, xmm5, xmm5, 0
            }
          }
          if ( !applyTransform || (*(int *)((char *)v40 + v44) & 8) != 0 )
          {
            __asm
            {
              vmulps  xmm0, xmm3, xmm5
              vaddps  xmm1, xmm0, xmmword ptr [rbx]
              vmovups xmmword ptr [rbx], xmm1
            }
          }
          else
          {
            __asm
            {
              vshufps xmm2, xmm3, xmm3, 55h ; 'U'
              vmulps  xmm0, xmm2, xmmword ptr [r11+10h]
              vshufps xmm1, xmm3, xmm3, 0AAh ; 'ª'
              vmulps  xmm1, xmm1, xmmword ptr [r11+20h]
              vaddps  xmm2, xmm0, xmm1
              vshufps xmm4, xmm3, xmm3, 0
              vmulps  xmm0, xmm4, xmmword ptr [r11]
              vaddps  xmm1, xmm0, xmm2
              vmulps  xmm2, xmm1, xmm5
              vaddps  xmm3, xmm2, xmmword ptr [rbx]
              vmovups xmmword ptr [rbx], xmm3
            }
          }
        }
        ++v40;
        ++_RBX;
        --v45;
      }
      while ( v45 );
      __asm { vmovaps xmm7, [rsp+0A8h+var_58] }
    }
  }
  __asm { vmovaps xmm6, [rsp+0A8h+var_48] }
}

/*
==============
Particle_UpdateForceRelativeToEffectOrigin
==============
*/
void Particle_UpdateForceRelativeToEffectOrigin(const ParticleModuleForce *pModule, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const ParticleState *pParticleState, float dt, const vector4 *rEmitterTransform, bool noLerp, bool applyTransform, bool useWorldForce, bool hasVelocityGraph, float emitterLife, ParticleRelativeVelocityType relativeVelocityType)
{
  __int64 v21; 
  bool v23; 
  bool v24; 
  float *SpawnTimeArrayAtIndex; 
  unsigned __int8 *ParticleDataArray; 
  unsigned int v28; 
  unsigned __int8 *v29; 
  ParticleEmitter *EmitterOwner; 
  const vector4 *EmitterTransformTranspose; 
  unsigned int v34; 
  bool v43; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v47; 
  __int64 v49; 
  __int64 v99; 
  __int64 v100; 
  bool v102; 
  ParticleState *v103; 
  float4 outForceTransformed; 

  v21 = particleCount;
  _R15 = pModule;
  if ( !pModule && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 920, ASSERT_TYPE_ASSERT, "(pModule)", (const char *)&queryFormat, "pModule") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 921, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( (unsigned int)v21 + particleOffset >= pParticleData->m_particleCountRunning + 1 )
  {
    LODWORD(v99) = v21 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 922, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountRunning() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountRunning() + 1\n\t%i not in [0, %i)", v99, pParticleData->m_particleCountRunning + 1) )
      __debugbreak();
  }
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 923, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( applyTransform || relativeVelocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO )
  {
    v23 = useWorldForce;
    v24 = !hasVelocityGraph || useWorldForce;
  }
  else
  {
    v23 = useWorldForce;
    v24 = 0;
  }
  SpawnTimeArrayAtIndex = Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  _RBX = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( particleOffset >= pParticleData->m_particleCountMax )
  {
    LODWORD(v100) = pParticleData->m_particleCountMax;
    LODWORD(v99) = particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v99, v100) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 345, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  ParticleDataArray = ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_SPAWN_QUAT);
  v28 = particleOffset;
  v29 = &ParticleDataArray[16 * particleOffset];
  if ( v24 )
  {
    EmitterOwner = (ParticleEmitter *)ParticleState::GetEmitterOwner((ParticleState *)pParticleState);
    EmitterTransformTranspose = ParticleEmitter::GetEmitterTransformTranspose(EmitterOwner, pParticleState);
    v28 = particleOffset;
  }
  else
  {
    EmitterTransformTranspose = rEmitterTransform;
  }
  v103 = (ParticleState *)EmitterTransformTranspose;
  __asm { vmovaps [rsp+108h+var_58], xmm6 }
  if ( noLerp )
  {
    _R9 = &_R15->m_forceMin;
    if ( !applyTransform )
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [r9]
        vmovups xmmword ptr [rsp+108h+outForceTransformed.v], xmm0
      }
    }
    v34 = 0;
    if ( hasVelocityGraph )
    {
      if ( (_DWORD)v21 )
      {
        __asm { vmovss  xmm6, [rsp+108h+emitterLife] }
        do
        {
          if ( v24 )
            Particle_TransformForceRelativeToEffectOrigin((const float4 *)&v29[16 * v34], EmitterTransformTranspose, v23, _R9, &outForceTransformed);
          __asm { vsubss  xmm0, xmm6, dword ptr [rdi] }
          EmitterTransformTranspose = (const vector4 *)v103;
          ++v34;
          __asm
          {
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmmword ptr [rsp+108h+outForceTransformed.v]
            vaddps  xmm1, xmm0, xmmword ptr [rbx]
            vmovups xmmword ptr [rbx], xmm1
          }
          ++_RBX;
          ++SpawnTimeArrayAtIndex;
        }
        while ( v34 < (unsigned int)v21 );
      }
    }
    else if ( (_DWORD)v21 )
    {
      __asm { vbroadcastss xmm6, [rsp+108h+dt] }
      do
      {
        if ( v24 )
          Particle_TransformForceRelativeToEffectOrigin((const float4 *)&v29[16 * v34], EmitterTransformTranspose, v23, _R9, &outForceTransformed);
        __asm
        {
          vmulps  xmm1, xmm6, xmmword ptr [rsp+108h+outForceTransformed.v]
          vaddps  xmm2, xmm1, xmmword ptr [rbx]
        }
        EmitterTransformTranspose = (const vector4 *)v103;
        ++v34;
        __asm { vmovups xmmword ptr [rbx], xmm2 }
        ++_RBX;
      }
      while ( v34 < (unsigned int)v21 );
    }
  }
  else
  {
    v43 = (_R15->m_flags & 0x20) != 0;
    __asm { vmovaps [rsp+108h+var_78], xmm8 }
    v102 = v43;
    RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, v28);
    __asm { vbroadcastss xmm8, [rsp+108h+dt] }
    if ( (_DWORD)v21 )
    {
      _R11 = fx_randomTable;
      v47 = (char *)RandomSeedArrayAtIndex - (char *)SpawnTimeArrayAtIndex;
      _R12 = v29 - (unsigned __int8 *)_RBX;
      __asm { vmovaps [rsp+108h+var_88], xmm9 }
      v49 = v21;
      __asm
      {
        vmovaps [rsp+108h+var_98], xmm10
        vmovss  xmm10, [rsp+108h+emitterLife]
        vmovaps [rsp+108h+var_68], xmm7
      }
      do
      {
        _RAX = *(int *)((char *)SpawnTimeArrayAtIndex + v47);
        __asm { vmovups xmm0, xmmword ptr [r15+20h] }
        if ( v102 )
        {
          __asm
          {
            vsubps  xmm0, xmm0, xmmword ptr [r15+10h]
            vxorps  xmm1, xmm1, xmm1
            vinsertps xmm1, xmm1, dword ptr [r11+rax*4+0B0h], 0
            vinsertps xmm1, xmm1, dword ptr [r11+rax*4+0B4h], 10h
            vinsertps xmm1, xmm1, dword ptr [r11+rax*4+0B8h], 20h ; ' '
            vmulps  xmm1, xmm1, xmm0
            vaddps  xmm9, xmm1, xmmword ptr [r15+10h]
          }
        }
        else
        {
          __asm
          {
            vsubps  xmm1, xmm0, xmmword ptr [r15+10h]
            vbroadcastss xmm0, dword ptr [r11+rax*4+0B0h]
            vmulps  xmm0, xmm1, xmm0
            vaddps  xmm9, xmm0, xmmword ptr [r15+10h]
          }
        }
        if ( hasVelocityGraph )
        {
          __asm
          {
            vsubss  xmm8, xmm10, dword ptr [rdi]
            vshufps xmm8, xmm8, xmm8, 0
          }
        }
        if ( v24 )
        {
          if ( v23 )
          {
            __asm
            {
              vshufps xmm2, xmm9, xmm9, 0
              vmulps  xmm0, xmm2, xmmword ptr [rcx]
              vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
              vshufps xmm4, xmm9, xmm9, 55h ; 'U'
              vmulps  xmm0, xmm4, xmmword ptr [rcx+10h]
              vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
              vshufps xmm5, xmm9, xmm9, 0AAh ; 'ª'
              vmulps  xmm0, xmm5, xmmword ptr [rcx+20h]
              vaddps  xmm1, xmm0, xmm3
              vaddps  xmm2, xmm2, xmm1
              vandps  xmm9, xmm2, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
            }
          }
          else
          {
            __asm
            {
              vmovups xmm0, xmmword ptr [rbx+r12]
              vshufps xmm7, xmm0, xmm0, 0D2h ; 'Ò'
              vshufps xmm6, xmm0, xmm0, 0C9h ; 'É'
              vshufps xmm5, xmm0, xmm0, 0FFh
              vshufps xmm0, xmm9, xmm9, 0D2h ; 'Ò'
              vmulps  xmm3, xmm0, xmm6
              vshufps xmm1, xmm9, xmm9, 0C9h ; 'É'
              vmulps  xmm2, xmm1, xmm7
              vsubps  xmm0, xmm3, xmm2
              vaddps  xmm4, xmm0, xmm0
              vmulps  xmm0, xmm5, xmm4
              vaddps  xmm5, xmm0, xmm9
              vshufps xmm1, xmm4, xmm4, 0D2h ; 'Ò'
              vshufps xmm0, xmm4, xmm4, 0C9h ; 'É'
              vmulps  xmm2, xmm0, xmm7
              vmulps  xmm3, xmm1, xmm6
              vsubps  xmm1, xmm3, xmm2
              vaddps  xmm9, xmm1, xmm5
            }
          }
        }
        __asm
        {
          vmulps  xmm0, xmm8, xmm9
          vaddps  xmm1, xmm0, xmmword ptr [rbx]
          vmovups xmmword ptr [rbx], xmm1
        }
        ++_RBX;
        ++SpawnTimeArrayAtIndex;
        --v49;
      }
      while ( v49 );
      __asm
      {
        vmovaps xmm10, [rsp+108h+var_98]
        vmovaps xmm9, [rsp+108h+var_88]
        vmovaps xmm7, [rsp+108h+var_68]
      }
    }
    __asm { vmovaps xmm8, [rsp+108h+var_78] }
  }
  __asm { vmovaps xmm6, [rsp+108h+var_58] }
}

/*
==============
ParticleModuleAttractor::Update
==============
*/
void ParticleModuleAttractor::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v12; 
  unsigned int *FlagsArrayAtIndex; 
  __int64 v25; 
  __int64 v47; 
  __int64 v48; 

  __asm
  {
    vmovaps [rsp+0B8h+var_48], xmm6
    vmovaps [rsp+0B8h+var_58], xmm7
  }
  _R12 = pEmitterOwner;
  v12 = particleCount;
  _RDI = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v12 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v47) = v12 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v47, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (_RDI->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 425, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  Particle_GetPositionArrayAtIndex(pParticleData, particleOffset);
  _RSI = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, particleOffset);
  __asm { vmovss  xmm7, dword ptr [r12+174h] }
  v48 = pParticleState->m_pStateDef->flags & 0x300;
  Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  __asm { vxorps  xmm6, xmm6, xmm6 }
  _RAX = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  __asm
  {
    vmovups xmm1, xmmword ptr [rax+30h]
    vshufps xmm0, xmm1, xmm6, 0FAh ; 'ú'
    vshufps xmm1, xmm1, xmm0, 84h ; ''
    vaddps  xmm5, xmm1, xmmword ptr [rdi+20h]
  }
  if ( (_DWORD)v12 )
  {
    __asm { vmovss  xmm4, [rsp+0B8h+dt] }
    _RAX = 0i64;
    v25 = v12;
    do
    {
      __asm
      {
        vsubps  xmm2, xmm5, xmmword ptr [rax+r8]
        vmulps  xmm1, xmm2, xmm2
        vinsertps xmm0, xmm1, xmm1, 8
        vhaddps xmm3, xmm0, xmm0
      }
      if ( LOBYTE(_RDI[2].m_flags) )
      {
        __asm
        {
          vhaddps xmm0, xmm3, xmm3
          vcomiss xmm0, dword ptr [rdi+1Ch]
        }
        if ( !LOBYTE(_RDI[2].m_flags) )
          *FlagsArrayAtIndex |= 1u;
      }
      __asm
      {
        vinsertps xmm0, xmm1, xmm1, 8
        vhaddps xmm1, xmm0, xmm0
        vhaddps xmm0, xmm1, xmm1
        vsqrtps xmm1, xmm0
        vdivps  xmm3, xmm2, xmm1
      }
      if ( v48 )
      {
        __asm
        {
          vsubss  xmm0, xmm7, dword ptr [rbx+rbp]
          vmulss  xmm1, xmm0, dword ptr [rdi+18h]
          vshufps xmm1, xmm1, xmm1, 0
          vmulps  xmm1, xmm1, xmm3
          vaddps  xmm0, xmm1, xmmword ptr [rax+rsi]
          vmovups xmmword ptr [rax+rsi], xmm0
        }
      }
      else
      {
        __asm
        {
          vmulss  xmm0, xmm4, dword ptr [rdi+18h]
          vshufps xmm0, xmm0, xmm0, 0
          vmulps  xmm0, xmm0, xmm3
          vaddps  xmm1, xmm0, xmmword ptr [rax+rsi]
          vmovups xmmword ptr [rax+rsi], xmm1
        }
      }
      _RAX += 16i64;
      ++FlagsArrayAtIndex;
      --v25;
    }
    while ( v25 );
  }
  __asm
  {
    vmovaps xmm6, [rsp+0B8h+var_48]
    vmovaps xmm7, [rsp+0B8h+var_58]
  }
}

/*
==============
ParticleModuleColorGraph::Update
==============
*/
void ParticleModuleColorGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  unsigned int m_flags; 
  bool useLength; 
  bool v17; 
  char v20; 
  unsigned int v24; 
  signed __int64 v27; 
  __int64 v29; 
  __int64 v50; 
  bool v52; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v54; 
  float4 outCurve; 
  float4 v56; 

  _R15 = pParticleState;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R12 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v50) = particleCount + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v50, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 500, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_flags = pModuleBase->m_flags;
  useLength = pParticleState->m_moduleGraphLengthData.useLength;
  v17 = (m_flags & 0x10) != 0;
  v52 = (m_flags & 0x20) != 0;
  if ( useLength && (m_flags & 0x300) != 768 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 509, ASSERT_TYPE_ASSERT, "(!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL ))", (const char *)&queryFormat, "!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL )") )
    __debugbreak();
  __asm { vmovaps [rsp+0E8h+var_58], xmm6 }
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  _RBX = (const ParticleState *)Particle_GetColorArrayAtIndex(pParticleData, particleOffset);
  _RSI = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  if ( (pModuleBase->m_flags & 4) != 0 || useLength )
  {
    v20 = 0;
    if ( useLength )
    {
      __asm { vmovss  xmm6, dword ptr [r15+24h] }
      _RBX = pParticleState;
    }
    else
    {
      __asm { vmovss  xmm6, dword ptr [r12+178h] }
    }
    __asm { vmovaps xmm1, xmm6; time }
    Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1, &outCurve);
    if ( v17 )
    {
      __asm { vmovaps xmm1, xmm6; time }
      Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[10], *(const float *)&_XMM1, &v56);
    }
  }
  else
  {
    v20 = 1;
  }
  v24 = 1;
  if ( !useLength )
    v24 = particleCount;
  if ( v24 )
  {
    _RDX = fx_randomTable;
    __asm { vmovups xmm3, xmmword ptr [rsp+0E8h+outCurve.v] }
    v27 = (char *)RandomSeedArrayAtIndex - (char *)_RSI;
    __asm
    {
      vmovaps [rsp+0E8h+var_68], xmm7
      vmovups xmm7, xmmword ptr [rsp+0E8h+var_88.v]
    }
    v54 = (char *)RandomSeedArrayAtIndex - (char *)_RSI;
    v29 = v24;
    while ( 1 )
    {
      _RBP = *(int *)((char *)_RSI + v27);
      if ( v20 )
      {
        __asm
        {
          vmovss  xmm6, dword ptr [rsi]
          vmovaps xmm1, xmm6; time
        }
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1, &outCurve);
        if ( !v17 )
        {
          __asm { vmovups xmm3, xmmword ptr [rsp+0E8h+outCurve.v] }
          goto LABEL_42;
        }
        __asm { vmovaps xmm1, xmm6; time }
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[10], *(const float *)&_XMM1, &v56);
        __asm
        {
          vmovups xmm3, xmmword ptr [rsp+0E8h+outCurve.v]
          vmovups xmm7, xmmword ptr [rsp+0E8h+var_88.v]
        }
        _RDX = fx_randomTable;
      }
      if ( v17 )
      {
        __asm { vsubps  xmm0, xmm7, xmm3 }
        if ( v52 )
        {
          __asm
          {
            vmovss  xmm1, dword ptr [rdx+rbp*4+64h]
            vinsertps xmm1, xmm1, dword ptr [rdx+rbp*4+68h], 10h
            vinsertps xmm1, xmm1, dword ptr [rdx+rbp*4+6Ch], 20h ; ' '
            vinsertps xmm1, xmm1, dword ptr [rdx+rbp*4+70h], 30h ; '0'
            vmulps  xmm1, xmm1, xmm0
            vaddps  xmm2, xmm1, xmm3
          }
        }
        else
        {
          __asm
          {
            vbroadcastss xmm1, dword ptr [rdx+rbp*4+60h]
            vmulps  xmm1, xmm1, xmm0
            vaddps  xmm2, xmm1, xmm3
          }
        }
        goto LABEL_43;
      }
LABEL_42:
      __asm { vmovups xmm2, xmm3 }
      _RDX = fx_randomTable;
LABEL_43:
      if ( LOBYTE(pModuleBase[1].m_flags) )
      {
        __asm
        {
          vshufps xmm1, xmm2, xmm2, 0FFh
          vshufps xmm1, xmm1, xmm1, 0
          vmulps  xmm2, xmm1, xmm2
          vshufps xmm0, xmm2, xmmword ptr cs:?g_one@@3Ufloat4@@B.v, 0FAh ; 'ú'; float4 const g_one
          vshufps xmm2, xmm2, xmm0, 84h ; ''
        }
      }
      if ( LOBYTE(pModuleBase[1].m_type) )
      {
        __asm { vmovups xmmword ptr [rbx], xmm2 }
      }
      else
      {
        __asm
        {
          vmulps  xmm0, xmm2, xmmword ptr [rbx]
          vmovups xmmword ptr [rbx], xmm0
        }
      }
      v27 = v54;
      ++_RSI;
      _RBX = (const ParticleState *)((char *)_RBX + 16);
      if ( !--v29 )
      {
        __asm { vmovaps xmm7, [rsp+0E8h+var_68] }
        break;
      }
    }
  }
  __asm { vmovaps xmm6, [rsp+0E8h+var_58] }
}

/*
==============
ParticleModuleColorLerp::Update
==============
*/
void ParticleModuleColorLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  __int64 v22; 
  __int64 v26; 

  v7 = particleCount;
  _RDI = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R14 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v26) = v7 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v26, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (_RDI->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 605, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  _RAX = Particle_GetColorArrayAtIndex(pParticleData, particleOffset);
  _RSI = _RAX;
  if ( (_RDI->m_flags & 4) != 0 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi+20h]
      vsubps  xmm1, xmm0, xmmword ptr [rdi+10h]
      vbroadcastss xmm0, dword ptr [r14+178h]
      vmulps  xmm0, xmm1, xmm0
      vaddps  xmm3, xmm0, xmmword ptr [rdi+10h]
    }
    if ( (_DWORD)v7 )
    {
      __asm { vmovups xmmword ptr [rax], xmm3 }
      qmemcpy(&_RAX[1], _RAX, 8 * ((unsigned __int64)(16 * v7 - 9) >> 3));
    }
  }
  else
  {
    _RAX = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi+20h]
      vsubps  xmm2, xmm0, xmmword ptr [rdi+10h]
    }
    if ( (_DWORD)v7 )
    {
      v22 = v7;
      do
      {
        ++_RSI;
        __asm { vbroadcastss xmm0, dword ptr [rax] }
        ++_RAX;
        __asm
        {
          vmulps  xmm0, xmm0, xmm2
          vaddps  xmm1, xmm0, xmmword ptr [rdi+10h]
          vmovups xmmword ptr [rsi-10h], xmm1
        }
        --v22;
      }
      while ( v22 );
    }
  }
}

/*
==============
ParticleModuleEmissionGraph::Update
==============
*/
void ParticleModuleEmissionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount)
{
  ;
}

/*
==============
ParticleModuleEmissiveGraph::Update
==============
*/
void ParticleModuleEmissiveGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ParticleData *v13; 
  __int64 v14; 
  __int64 v16; 
  unsigned int m_flags; 
  bool v22; 
  bool v23; 
  signed __int64 v32; 
  __int64 v33; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 
  bool v60; 
  bool v61; 
  float4 v64; 
  float4 outCurve; 
  int *RandomSeedArrayAtIndex; 
  ParticleData *v67; 
  const ParticleEmitter *v68; 

  _R15 = pEmitterOwner;
  v13 = pParticleData;
  v14 = particleCount;
  v16 = particleOffset;
  v68 = pEmitterOwner;
  __asm { vmovaps [rsp+138h+var_98], xmm10 }
  v67 = pParticleData;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (int)v14 + (int)v16 >= v13->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v14 + v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, v13->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 660, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 357, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v16 >= v13->m_particleCountMax )
  {
    LODWORD(rCurve2) = v13->m_particleCountMax;
    LODWORD(rCurve1) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 357, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 357, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  __asm { vmovaps [rsp+138h+var_88], xmm9 }
  _RDI = &ParticleData::GetParticleDataArray(v13, PARTICLE_DATA_EMISSIVE)[16 * v16];
  m_flags = pModuleBase->m_flags;
  v61 = (m_flags & 0x20) != 0;
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(v13, v16);
  _RBP = Particle_GetLifeArrayAtIndex(v13, v16);
  __asm
  {
    vmovups xmm10, cs:__xmm@000000003f8000003f8000003f800000
    vinsertps xmm10, xmm10, dword ptr [rbx+4Ch], 30h ; '0'
  }
  v22 = (pModuleBase->m_flags & 4) == 0;
  v60 = v22;
  v23 = (m_flags & 0x10) != 0;
  if ( v23 )
  {
    __asm
    {
      vmovups xmm9, cs:__xmm@000000003f8000003f8000003f800000
      vinsertps xmm9, xmm9, dword ptr [rbx+9Ch], 30h ; '0'
    }
  }
  else
  {
    __asm { vmovups xmm9, xmmword ptr [rsp+138h+outCurve.v] }
  }
  __asm
  {
    vmovaps [rsp+138h+var_58], xmm6
    vmovaps [rsp+138h+var_68], xmm7
    vmovaps [rsp+138h+var_78], xmm8
  }
  if ( v22 )
  {
    __asm { vmovups xmm6, xmmword ptr [rsp+138h+outCurve.v] }
    goto LABEL_35;
  }
  __asm
  {
    vmovss  xmm7, dword ptr [r15+178h]
    vmovaps xmm1, xmm7; time
  }
  Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1, &outCurve);
  __asm
  {
    vmulps  xmm6, xmm10, xmmword ptr [rsp+138h+outCurve.v]
    vmovups xmmword ptr [rsp+138h+outCurve.v], xmm6
  }
  if ( !v23 )
  {
LABEL_35:
    __asm { vmovups xmm8, xmmword ptr [rsp+138h+var_D8.v] }
    goto LABEL_36;
  }
  __asm { vmovaps xmm1, xmm7; time }
  Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[12], *(const float *)&_XMM1, &v64);
  __asm
  {
    vmulps  xmm8, xmm9, xmmword ptr [rsp+138h+var_D8.v]
    vmovups xmmword ptr [rsp+138h+var_D8.v], xmm8
  }
LABEL_36:
  if ( !(_DWORD)v14 )
    goto LABEL_51;
  _RCX = fx_randomTable;
  v32 = (char *)RandomSeedArrayAtIndex - (char *)_RBP;
  v33 = v14;
  do
  {
    _R14 = *(int *)((char *)_RBP + v32);
    if ( v60 )
    {
      __asm
      {
        vmovss  xmm7, dword ptr [rbp+0]
        vmovaps xmm1, xmm7; time
      }
      Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1, &outCurve);
      __asm
      {
        vmulps  xmm6, xmm10, xmmword ptr [rsp+138h+outCurve.v]
        vmovups xmmword ptr [rsp+138h+outCurve.v], xmm6
      }
      if ( !v23 )
        goto LABEL_45;
      __asm { vmovaps xmm1, xmm7; time }
      Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[12], *(const float *)&_XMM1, &v64);
      __asm
      {
        vmulps  xmm8, xmm9, xmmword ptr [rsp+138h+var_D8.v]
        vmovups xmmword ptr [rsp+138h+var_D8.v], xmm8
      }
      _RCX = fx_randomTable;
    }
    if ( v23 )
    {
      __asm { vmovss  xmm0, dword ptr [rcx+r14*4+74h] }
      if ( v61 )
      {
        __asm
        {
          vmovss  xmm1, dword ptr [rcx+r14*4+64h]
          vinsertps xmm1, xmm1, dword ptr [rcx+r14*4+68h], 10h
          vinsertps xmm1, xmm1, dword ptr [rcx+r14*4+6Ch], 20h ; ' '
          vinsertps xmm1, xmm1, xmm0, 30h ; '0'
          vsubps  xmm0, xmm8, xmm6
          vmulps  xmm1, xmm1, xmm0
          vaddps  xmm2, xmm1, xmm6
        }
      }
      else
      {
        __asm
        {
          vsubps  xmm1, xmm8, xmm6
          vshufps xmm0, xmm0, xmm0, 0
          vmulps  xmm0, xmm1, xmm0
          vaddps  xmm2, xmm0, xmm6
        }
      }
      goto LABEL_46;
    }
LABEL_45:
    __asm { vmovdqa xmm2, xmm6 }
    _RCX = fx_randomTable;
LABEL_46:
    if ( LOBYTE(pModuleBase[1].m_type) )
    {
      __asm { vmovups xmmword ptr [rdi], xmm2 }
    }
    else
    {
      __asm
      {
        vmulps  xmm0, xmm2, xmmword ptr [rdi]
        vmovups xmmword ptr [rdi], xmm0
      }
    }
    ++_RBP;
    _RDI += 16;
    --v33;
  }
  while ( v33 );
  v13 = v67;
  LODWORD(v16) = particleOffset;
  LODWORD(v14) = particleCount;
  _R15 = v68;
LABEL_51:
  __asm
  {
    vmovaps xmm10, [rsp+138h+var_98]
    vmovaps xmm9, [rsp+138h+var_88]
    vmovaps xmm8, [rsp+138h+var_78]
    vmovaps xmm7, [rsp+138h+var_68]
    vmovaps xmm6, [rsp+138h+var_58]
  }
  if ( (pParticleState->m_pStateDef->flags & 0x40000000000i64) != 0 )
  {
    if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 358, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    if ( (unsigned int)v16 >= v13->m_particleCountMax )
    {
      LODWORD(rCurve2) = v13->m_particleCountMax;
      LODWORD(rCurve1) = v16;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 358, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
        __debugbreak();
    }
    if ( !v13->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 358, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    floatArray = (float *)&ParticleData::GetParticleDataArray(v13, PARTICLE_DATA_LIGHTING_FRAC)[4 * (unsigned int)v16];
    rCurve2a = (ParticleCurveDef *)&pModuleBase[20];
    rCurve1a = (ParticleCurveDef *)&pModuleBase[10];
    if ( LOBYTE(pModuleBase[1].m_type) )
      ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, v13, v16, v14, _R15, rCurve1a, rCurve2a, FXRAND_LIGHTING_FRAC, floatArray);
    else
      ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, v13, v16, v14, _R15, rCurve1a, rCurve2a, FXRAND_LIGHTING_FRAC, floatArray);
  }
}

/*
==============
ParticleModuleForce::Update
==============
*/
void ParticleModuleForce::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v14; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  ParticleRelativeVelocityType m_velocityType; 
  ParticleRelativeVelocityType v17; 
  bool v18; 
  bool v19; 
  unsigned __int64 flags; 
  bool applyTransform; 
  bool v23; 
  float *SpawnTimeArrayAtIndex; 
  const ParticleModuleInitRelativeVelocity *v28; 
  ParticleRelativeVelocityType v29; 
  bool v30; 
  unsigned int m_flags; 
  bool noLerp; 
  __int64 v57; 
  __int64 v64; 
  bool v66; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v70; 
  __int64 v71; 
  float fmt; 
  vector4 *rEmitterTransform; 
  float rEmitterTransforma; 
  float useWorldForce; 
  float v101; 
  bool hasVelocityGraph; 
  bool v103; 
  ParticleRelativeVelocityType relativeVelocityType; 
  unsigned __int64 v107; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-58h], xmm7 }
  _RSI = pModuleBase;
  v14 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v14 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rEmitterTransform) = v14 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rEmitterTransform, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (_RSI->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1000, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
  if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 )
    m_velocityType = PARTICLE_RELATIVE_VELOCITY_TYPE_LOCAL;
  else
    m_velocityType = m_pModuleInitRelativeVelocity->m_velocityType;
  relativeVelocityType = m_velocityType;
  v18 = 0;
  if ( m_pModuleInitRelativeVelocity )
  {
    if ( (m_pModuleInitRelativeVelocity->m_flags & 1) == 0 )
    {
      v17 = m_pModuleInitRelativeVelocity->m_velocityType;
      if ( v17 == PARTICLE_RELATIVE_VELOCITY_TYPE_WORLD || v17 == PARTICLE_RELATIVE_VELOCITY_TYPE_WORLD_WITH_BOLT_INFO )
        v18 = 1;
    }
  }
  v19 = (_RSI->m_flags & 0x80) != 0 || v18;
  v103 = v19;
  flags = pParticleState->m_pStateDef->flags;
  v107 = flags & 0x300;
  hasVelocityGraph = (flags & 0x300) != 0;
  if ( (flags & 0x100) != 0 && !v18 || m_velocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_COUNT )
    applyTransform = v19;
  else
    applyTransform = !v19;
  _RAX = pEmitterOwner;
  v23 = (flags & 0x200000) != 0;
  __asm { vmovss  xmm7, dword ptr [rax+174h] }
  _RBX = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  SpawnTimeArrayAtIndex = Particle_GetSpawnTimeArrayAtIndex(pParticleData, particleOffset);
  _RDX = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  v28 = pParticleState->m_pModuleInitRelativeVelocity;
  v30 = 0;
  if ( v28 )
  {
    if ( (v28->m_flags & 1) == 0 )
    {
      v29 = v28->m_velocityType;
      if ( v29 == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN || v29 == PARTICLE_RELATIVE_VELOCITY_TYPE_RELATIVE_TO_EFFECT_ORIGIN_WITH_BOLT_INFO )
        v30 = 1;
    }
  }
  m_flags = _RSI->m_flags;
  noLerp = (m_flags & 0x40) != 0;
  if ( applyTransform && relativeVelocityType == PARTICLE_RELATIVE_VELOCITY_TYPE_COUNT )
  {
    __asm
    {
      vmovups xmm1, xmmword ptr [rdx+20h]
      vshufps xmm4, xmm1, xmmword ptr [rdx+30h], 44h ; 'D'
      vshufps xmm5, xmm1, xmmword ptr [rdx+30h], 0EEh ; 'î'
      vmovups xmm3, xmmword ptr [rdx]
      vshufps xmm2, xmm3, xmmword ptr [rdx+10h], 0EEh ; 'î'
      vmovaps [rsp+188h+var_48], xmm6
      vshufps xmm6, xmm3, xmmword ptr [rdx+10h], 44h ; 'D'
      vshufps xmm0, xmm6, xmm4, 88h ; ''
      vshufps xmm1, xmm6, xmm4, 0DDh ; 'Ý'
      vmovaps xmm6, [rsp+188h+var_48]
      vmovups xmmword ptr [rsp+188h+var_E8+10h], xmm1
      vmovups xmmword ptr [rsp+188h+var_E8], xmm0
      vshufps xmm0, xmm2, xmm5, 88h ; ''
      vshufps xmm1, xmm2, xmm5, 0DDh ; 'Ý'
      vmovups xmmword ptr [rsp+188h+var_C8], xmm0
      vmovups ymm0, [rsp+188h+var_E8]
      vmovups xmmword ptr [rsp+188h+var_C8+10h], xmm1
      vmovups ymm1, [rsp+188h+var_C8]
      vmovups [rsp+188h+var_A8], ymm0
      vmovups [rsp+188h+var_88], ymm1
    }
  }
  if ( v23 )
  {
    __asm
    {
      vmovss  xmm0, [rsp+188h+dt]
      vmovss  dword ptr [rsp+188h+useWorldForce], xmm7
      vmovss  dword ptr [rsp+188h+fmt], xmm0
    }
    Particle_UpdateForceRayCast((const ParticleModuleForce *)_RSI, pParticleData, particleOffset, v14, fmt, _RDX, noLerp, applyTransform, hasVelocityGraph, useWorldForce);
  }
  else if ( v30 )
  {
    __asm
    {
      vmovss  xmm0, [rsp+188h+dt]
      vmovss  [rsp+188h+var_130], xmm7
      vmovss  dword ptr [rsp+188h+rEmitterTransform], xmm0
    }
    Particle_UpdateForceRelativeToEffectOrigin((const ParticleModuleForce *)_RSI, pParticleData, particleOffset, v14, pParticleState, rEmitterTransforma, _RDX, noLerp, applyTransform, v103, hasVelocityGraph, v101, relativeVelocityType);
  }
  else if ( (_RSI->m_flags & 0x40) != 0 )
  {
    if ( applyTransform )
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rsi+10h]
        vshufps xmm1, xmm0, xmm0, 0AAh ; 'ª'
        vmulps  xmm1, xmm1, xmmword ptr [r9+20h]
        vshufps xmm2, xmm0, xmm0, 55h ; 'U'
        vshufps xmm3, xmm0, xmm0, 0
        vmulps  xmm0, xmm2, xmmword ptr [r9+10h]
        vaddps  xmm2, xmm0, xmm1
        vmulps  xmm0, xmm3, xmmword ptr [r9]
        vaddps  xmm4, xmm0, xmm2
      }
    }
    else
    {
      __asm { vmovups xmm4, xmmword ptr [rsi+10h] }
    }
    if ( v107 )
    {
      if ( (_DWORD)v14 )
      {
        v57 = v14;
        do
        {
          ++_RBX;
          __asm { vsubss  xmm0, xmm7, dword ptr [rdi] }
          ++SpawnTimeArrayAtIndex;
          __asm
          {
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmm4
            vaddps  xmm1, xmm0, xmmword ptr [rbx-10h]
            vmovups xmmword ptr [rbx-10h], xmm1
          }
          --v57;
        }
        while ( v57 );
      }
    }
    else
    {
      __asm
      {
        vbroadcastss xmm0, [rsp+188h+dt]
        vmulps  xmm1, xmm0, xmm4
      }
      if ( (_DWORD)v14 )
      {
        v64 = v14;
        do
        {
          __asm
          {
            vaddps  xmm0, xmm1, xmmword ptr [rbx]
            vmovups xmmword ptr [rbx], xmm0
          }
          ++_RBX;
          --v64;
        }
        while ( v64 );
      }
    }
  }
  else
  {
    v66 = (m_flags & 0x20) != 0;
    RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
    __asm { vbroadcastss xmm5, [rsp+188h+dt] }
    if ( (_DWORD)v14 )
    {
      _R9 = fx_randomTable;
      v70 = (char *)RandomSeedArrayAtIndex - (char *)SpawnTimeArrayAtIndex;
      v71 = v14;
      do
      {
        _RAX = *(int *)((char *)SpawnTimeArrayAtIndex + v70);
        __asm { vmovups xmm0, xmmword ptr [rsi+20h] }
        if ( v66 )
        {
          __asm
          {
            vsubps  xmm0, xmm0, xmmword ptr [rsi+10h]
            vxorps  xmm1, xmm1, xmm1
            vinsertps xmm1, xmm1, dword ptr [r9+rax*4+0B0h], 0
            vinsertps xmm1, xmm1, dword ptr [r9+rax*4+0B4h], 10h
            vinsertps xmm1, xmm1, dword ptr [r9+rax*4+0B8h], 20h ; ' '
            vmulps  xmm1, xmm1, xmm0
            vaddps  xmm3, xmm1, xmmword ptr [rsi+10h]
          }
        }
        else
        {
          __asm
          {
            vsubps  xmm1, xmm0, xmmword ptr [rsi+10h]
            vbroadcastss xmm0, dword ptr [r9+rax*4+0B0h]
            vmulps  xmm0, xmm1, xmm0
            vaddps  xmm3, xmm0, xmmword ptr [rsi+10h]
          }
        }
        if ( v107 )
        {
          __asm
          {
            vsubss  xmm5, xmm7, dword ptr [rdi]
            vshufps xmm5, xmm5, xmm5, 0
          }
        }
        if ( applyTransform )
        {
          __asm
          {
            vshufps xmm2, xmm3, xmm3, 55h ; 'U'
            vshufps xmm1, xmm3, xmm3, 0AAh ; 'ª'
            vshufps xmm4, xmm3, xmm3, 0
            vmulps  xmm0, xmm2, xmmword ptr [rax+10h]
            vmulps  xmm1, xmm1, xmmword ptr [rax+20h]
            vaddps  xmm2, xmm0, xmm1
            vmulps  xmm0, xmm4, xmmword ptr [rax]
            vaddps  xmm1, xmm0, xmm2
            vmulps  xmm2, xmm1, xmm5
            vaddps  xmm3, xmm2, xmmword ptr [rbx]
            vmovups xmmword ptr [rbx], xmm3
          }
        }
        else
        {
          __asm
          {
            vmulps  xmm0, xmm3, xmm5
            vaddps  xmm1, xmm0, xmmword ptr [rbx]
            vmovups xmmword ptr [rbx], xmm1
          }
        }
        ++SpawnTimeArrayAtIndex;
        ++_RBX;
        --v71;
      }
      while ( v71 );
    }
  }
  __asm { vmovaps xmm7, [rsp+188h+var_58] }
}

/*
==============
ParticleModuleForceDragGraph::Update
==============
*/
void ParticleModuleForceDragGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v12; 
  float4 *VelocityArrayAtIndex; 
  __int64 v54; 
  __int64 v63; 
  __int64 v75; 

  __asm { vmovaps [rsp+0D8h+var_68], xmm7 }
  v12 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R12 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v12 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v75) = v12 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v75, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1115, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  __asm { vmovaps [rsp+0D8h+var_88], xmm9 }
  _R15 = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  _RSI = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  __asm { vmovss  xmm7, dword ptr [r12+178h] }
  _RDI = VelocityArrayAtIndex;
  if ( (_DWORD)v12 )
  {
    __asm
    {
      vmovaps [rsp+0D8h+var_58], xmm6
      vmovaps [rsp+0D8h+var_78], xmm8
    }
    if ( (pModuleBase->m_flags & 0x10) != 0 )
    {
      __asm
      {
        vmovss  xmm9, [rsp+0D8h+dt]
        vmovss  xmm8, cs:__real@3f800000
      }
      if ( (pModuleBase->m_flags & 4) != 0 )
      {
        do
        {
          __asm { vmovaps xmm1, xmm7; time }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
          __asm
          {
            vmulss  xmm6, xmm0, dword ptr [r12+0Ch]
            vmovaps xmm1, xmm7; time
          }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], *(const float *)&_XMM1);
          __asm
          {
            vmulss  xmm3, xmm0, dword ptr [rsi+0Ch]
            vsubss  xmm0, xmm8, dword ptr [rbp+rbx*4+3Ch]
            vmulss  xmm1, xmm3, dword ptr [rbp+rbx*4+3Ch]
            vmulss  xmm2, xmm0, xmm6
            vaddss  xmm2, xmm2, xmm1
            vmulss  xmm0, xmm2, xmm9
            vsubss  xmm0, xmm8, xmm0; val
            vmovaps xmm2, xmm8; max
            vxorps  xmm1, xmm1, xmm1; min
          }
          *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
          ++_RDI;
          ++_R15;
          __asm
          {
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmmword ptr [rdi-10h]
            vmovups xmmword ptr [rdi-10h], xmm0
          }
          --v12;
        }
        while ( v12 );
      }
      else
      {
        _RSI = (char *)_RSI - (char *)_R15;
        do
        {
          __asm
          {
            vmovss  xmm6, dword ptr [rsi+r15]
            vmovaps xmm1, xmm6; time
          }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
          __asm
          {
            vmulss  xmm7, xmm0, dword ptr [r13+0Ch]
            vmovaps xmm1, xmm6; time
          }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], *(const float *)&_XMM1);
          __asm
          {
            vmulss  xmm3, xmm0, dword ptr [r12+0Ch]
            vsubss  xmm0, xmm8, dword ptr [rbp+rbx*4+3Ch]
            vmulss  xmm1, xmm3, dword ptr [rbp+rbx*4+3Ch]
            vmulss  xmm2, xmm0, xmm7
            vaddss  xmm2, xmm2, xmm1
            vmulss  xmm0, xmm2, xmm9
            vsubss  xmm0, xmm8, xmm0; val
            vmovaps xmm2, xmm8; max
            vxorps  xmm1, xmm1, xmm1; min
          }
          *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
          ++_RDI;
          ++_R15;
          __asm
          {
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmmword ptr [rdi-10h]
            vmovups xmmword ptr [rdi-10h], xmm0
          }
          --v12;
        }
        while ( v12 );
      }
    }
    else
    {
      __asm { vmovss  xmm6, cs:__real@3f800000 }
      if ( (pModuleBase->m_flags & 4) != 0 )
      {
        __asm { vmovss  xmm8, [rsp+0D8h+dt] }
        v63 = v12;
        do
        {
          __asm { vmovaps xmm1, xmm7; time }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
          __asm
          {
            vmulss  xmm1, xmm0, dword ptr [rbx+1Ch]
            vmulss  xmm2, xmm1, xmm8
            vsubss  xmm0, xmm6, xmm2; val
            vmovaps xmm2, xmm6; max
            vxorps  xmm1, xmm1, xmm1; min
          }
          *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
          ++_RDI;
          __asm
          {
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmmword ptr [rdi-10h]
            vmovups xmmword ptr [rdi-10h], xmm0
          }
          --v63;
        }
        while ( v63 );
      }
      else
      {
        __asm { vmovss  xmm7, [rsp+0D8h+dt] }
        v54 = v12;
        do
        {
          __asm { vmovss  xmm1, dword ptr [rsi]; time }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
          __asm
          {
            vmulss  xmm1, xmm0, dword ptr [rbx+1Ch]
            vmulss  xmm2, xmm1, xmm7
            vsubss  xmm0, xmm6, xmm2; val
            vmovaps xmm2, xmm6; max
            vxorps  xmm1, xmm1, xmm1; min
          }
          *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
          ++_RDI;
          ++_RSI;
          __asm
          {
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmmword ptr [rdi-10h]
            vmovups xmmword ptr [rdi-10h], xmm0
          }
          --v54;
        }
        while ( v54 );
      }
    }
    __asm
    {
      vmovaps xmm6, [rsp+0D8h+var_58]
      vmovaps xmm8, [rsp+0D8h+var_78]
    }
  }
  __asm
  {
    vmovaps xmm9, [rsp+0D8h+var_88]
    vmovaps xmm7, [rsp+0D8h+var_68]
  }
}

/*
==============
ParticleModuleGravity::Update
==============
*/
void ParticleModuleGravity::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount)
{
  ;
}

/*
==============
ParticleModuleIntensityGraph::Update
==============
*/
void ParticleModuleIntensityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 

  v7 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleCount >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v7 + particleCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1184, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 359, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v7 >= pParticleData->m_particleCountMax )
  {
    LODWORD(rCurve2) = pParticleData->m_particleCountMax;
    LODWORD(rCurve1) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 359, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 359, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_INTENSITY)[4 * v7];
  rCurve2a = (ParticleCurveDef *)&pModuleBase[4];
  rCurve1a = (ParticleCurveDef *)&pModuleBase[2];
  if ( LOBYTE(pModuleBase[1].m_type) )
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_INTENSITY, floatArray);
  else
    ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_INTENSITY, floatArray);
}

/*
==============
ParticleModuleParentVelocityGraph::Update
==============
*/
void ParticleModuleParentVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v10; 
  __int64 v11; 
  float *floatArray; 
  __int64 v14; 
  __int64 v19; 
  __int64 v30; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve2; 

  v10 = particleCount;
  v11 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (int)v10 + (int)v11 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v10 + v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1218, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( (pModuleBase->m_flags & 0x200) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1220, ASSERT_TYPE_ASSERT, "(pModuleBase->HasFlag( PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL ))", (const char *)&queryFormat, "pModuleBase->HasFlag( PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL )") )
    __debugbreak();
  if ( pParticleState->m_pStateDef->elementType != 10 )
  {
    _RBX = Particle_GetVelocityArrayAtIndex(pParticleData, v11);
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 362, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    if ( (unsigned int)v11 >= pParticleData->m_particleCountMax )
    {
      LODWORD(rCurve2) = pParticleData->m_particleCountMax;
      LODWORD(rCurve1) = v11;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 362, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
        __debugbreak();
    }
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 362, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_PARENT_VELOCITY);
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 363, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    if ( (unsigned int)v11 >= pParticleData->m_particleCountMax )
    {
      LODWORD(rCurve2) = pParticleData->m_particleCountMax;
      LODWORD(rCurve1) = v11;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 363, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
        __debugbreak();
    }
    if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 363, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
      __debugbreak();
    floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_INHERIT_PERCENTAGE)[4 * v11];
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v11, v10, pEmitterOwner, (const ParticleCurveDef *)&pModuleBase[2], (const ParticleCurveDef *)&pModuleBase[4], FXRAND_EMISSIVE, floatArray);
    if ( (pParticleState->m_pStateDef->flags & 0x300) != 0 )
    {
      if ( (_DWORD)v10 )
      {
        v14 = v10;
        do
        {
          ++_RBX;
          __asm { vbroadcastss xmm0, dword ptr [rdi] }
          ++floatArray;
          __asm
          {
            vmulps  xmm0, xmm0, xmmword ptr [rsi+rbx-10h]
            vaddps  xmm1, xmm0, xmmword ptr [rbx-10h]
            vmovups xmmword ptr [rbx-10h], xmm1
          }
          --v14;
        }
        while ( v14 );
      }
    }
    else
    {
      Particle_GetRandomSeedArrayAtIndex(pParticleData, v11);
      _RCX = pParticleState->m_pModuleInitAttributes;
      if ( (_DWORD)v10 )
      {
        if ( _RCX )
        {
          v19 = v10;
          do
          {
            ++_RBX;
            ++floatArray;
            __asm
            {
              vmovups xmm0, xmmword ptr [rcx+60h]
              vsubps  xmm0, xmm0, xmmword ptr [rcx+50h]
              vxorps  xmm1, xmm1, xmm1
              vinsertps xmm1, xmm1, dword ptr [r9+rax*4], 0
              vinsertps xmm1, xmm1, dword ptr [r9+rax*4+4], 10h
              vinsertps xmm1, xmm1, dword ptr [r9+rax*4+8], 20h ; ' '
              vmulps  xmm1, xmm1, xmm0
              vaddps  xmm2, xmm1, xmmword ptr [rcx+50h]
              vmovups xmmword ptr [rbx-10h], xmm2
              vbroadcastss xmm0, dword ptr [rdi-4]
              vmulps  xmm0, xmm0, xmmword ptr [rbx+rsi-10h]
              vaddps  xmm1, xmm0, xmm2
              vmovups xmmword ptr [rbx-10h], xmm1
            }
            --v19;
          }
          while ( v19 );
        }
        else
        {
          v30 = v10;
          do
          {
            ++_RBX;
            __asm { vbroadcastss xmm0, dword ptr [rdi] }
            ++floatArray;
            __asm
            {
              vmulps  xmm0, xmm0, xmmword ptr [rbx+rsi-10h]
              vmovups xmmword ptr [rbx-10h], xmm0
            }
            --v30;
          }
          while ( v30 );
        }
      }
    }
  }
}

/*
==============
ParticleModulePhysicsLight::Update
==============
*/
void ParticleModulePhysicsLight::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v16; 
  unsigned int *FlagsArrayAtIndex; 
  char *v18; 
  int *PhysicsFXParticleIDList; 
  HavokPhysicsFX_Pipeline *m_physicsFXPipelineInstance; 
  Physics_WorldId m_physicsWorldId; 
  ParticleSystem *SystemOwner; 
  const ParticleSystemDef *Def; 
  unsigned int v26; 
  unsigned __int64 v27; 
  unsigned int v28; 
  __int64 v32; 
  ParticleSystem *v38; 
  const ParticleSystemDef *v39; 
  bool v43; 
  ParticleSystem *v44; 
  const ParticleSystemDef *v45; 
  bool v46; 
  ParticleSystem *v60; 
  const ParticleSystemDef *v61; 
  bool v65; 
  const float4 *v78; 
  __int64 v85; 
  int v86; 
  int v87; 
  int v88; 
  int v89; 
  int v90; 
  int v91; 
  bool impact; 
  Physics_WorldId worldId; 
  int *v94; 
  unsigned int v95; 
  float4 *VelocityArrayAtIndex; 
  float4 *PositionArrayAtIndex; 
  const float4 *RotationAngleArrayAtIndex; 
  Particle_OnImpactData *v99; 
  unsigned __int64 v100; 
  const ParticleModulePhysicsLight *m_pModulePhysicsLight; 
  vector3 *rotMatrix; 
  float4 v103; 
  float4 v104; 
  float4 v105; 
  float4 v106; 
  float4 v107; 
  __int128 v108; 
  __int128 v109; 
  vec4_t orientation; 
  vec4_t quat; 
  Particle_OnImpactData data; 

  v95 = particleCount;
  v16 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + (unsigned int)v16 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v85) = particleCount + v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v85, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1421, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !particle_enable_physics_light->current.enabled )
    R_WarnOncePerFrame(R_WARN_VFX_PHYSICS_DISABLED, "(ParticleModulePhysicsLight::Update)");
  if ( (pParticleState->m_pStateDef->flags & 0x400) != 0 )
  {
    PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, v16);
    VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, v16);
    RotationAngleArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, v16);
    FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, v16);
    m_pModulePhysicsLight = pParticleState->m_pModulePhysicsLight;
    v18 = (char *)FlagsArrayAtIndex;
    rotMatrix = (vector3 *)ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
    if ( m_pModulePhysicsLight )
    {
      if ( !pParticleState->m_physicsFXParticleIDList )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 555, ASSERT_TYPE_ASSERT, "(m_physicsFXParticleIDList)", (const char *)&queryFormat, "m_physicsFXParticleIDList") )
          __debugbreak();
        if ( !pParticleState->m_physicsFXParticleIDList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1457, ASSERT_TYPE_ASSERT, "(pParticleState->GetPhysicsFXParticleIDList())", (const char *)&queryFormat, "pParticleState->GetPhysicsFXParticleIDList()") )
          __debugbreak();
      }
      PhysicsFXParticleIDList = ParticleState::GetPhysicsFXParticleIDList((ParticleState *)pParticleState);
      m_physicsFXPipelineInstance = pParticleState->m_physicsFXPipelineInstance;
      v94 = &PhysicsFXParticleIDList[v16];
      m_physicsWorldId = pParticleState->m_physicsWorldId;
      worldId = m_physicsWorldId;
      if ( !m_physicsFXPipelineInstance )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1461, ASSERT_TYPE_ASSERT, "(physicsFXPipeline)", (const char *)&queryFormat, "physicsFXPipeline") )
          __debugbreak();
        m_physicsWorldId = worldId;
      }
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vxorps  xmm1, xmm1, xmm1
        vmovups [rbp+120h+var_110], xmm0
        vmovups [rbp+120h+var_100], xmm1
      }
      if ( particleCount )
      {
        if ( !PhysicsFX_HasPipeline(m_physicsWorldId, m_physicsFXPipelineInstance) )
        {
          SystemOwner = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
          Def = ParticleSystem::GetDef(SystemOwner);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1472, ASSERT_TYPE_ASSERT, "(particleCount == 0 || PhysicsFX_HasPipeline( physicsWorldID, physicsFXPipeline ))", "%s\n\tERROR: The effect %s somehow managed to get its pipeline deleted\n", "particleCount == 0 || PhysicsFX_HasPipeline( physicsWorldID, physicsFXPipeline )", Def->name) )
            __debugbreak();
        }
      }
      pEmitterOwner->m_numPhysicsFX += particleCount;
      v26 = 0;
      v27 = (unsigned __int64)LODWORD(pParticleState->m_pStateDef->flags) >> 16;
      LOBYTE(v27) = HIWORD(LODWORD(pParticleState->m_pStateDef->flags)) & 1;
      v100 = v27;
      if ( (_BYTE)v27 )
      {
        if ( !pParticleState->m_onImpactDataList )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 455, ASSERT_TYPE_ASSERT, "(m_onImpactDataList)", (const char *)&queryFormat, "m_onImpactDataList") )
            __debugbreak();
          if ( !pParticleState->m_onImpactDataList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1479, ASSERT_TYPE_ASSERT, "(!handleImpacts || pParticleState->GetOnImpactDataList())", (const char *)&queryFormat, "!handleImpacts || pParticleState->GetOnImpactDataList()") )
            __debugbreak();
        }
        v99 = &ParticleState::GetOnImpactDataList((ParticleState *)pParticleState)[v16];
        if ( !v99 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1481, ASSERT_TYPE_ASSERT, "(!handleImpacts || pImpactDataList)", (const char *)&queryFormat, "!handleImpacts || pImpactDataList") )
          __debugbreak();
      }
      else
      {
        v99 = NULL;
      }
      v28 = v95;
      if ( v95 )
      {
        PositionArrayAtIndex = (float4 *)((char *)PositionArrayAtIndex - (__int64)VelocityArrayAtIndex);
        _RSI = RotationAngleArrayAtIndex;
        __asm
        {
          vmovaps [rsp+220h+var_40], xmm6
          vmovss  xmm6, cs:__real@34000000
          vmovaps [rsp+220h+var_50], xmm7
          vmovss  xmm7, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
        }
        VelocityArrayAtIndex = (float4 *)((char *)VelocityArrayAtIndex - (__int64)RotationAngleArrayAtIndex);
        __asm { vmovaps [rsp+220h+var_60], xmm8 }
        v32 = (char *)v94 - v18;
        __asm
        {
          vmovss  xmm8, cs:__real@3f800000
          vmovaps [rsp+220h+var_70], xmm9
          vmovss  xmm9, cs:__real@3b03126f
        }
        v94 = (int *)((char *)v94 - v18);
        do
        {
          if ( (*v18 & 2) == 0 )
          {
            PhysicsFX_GetParticlePosition(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v18[v32], (vec3_t *)&v108);
            PhysicsFX_GetParticleLinearVelocity(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v18[(_QWORD)v94], (vec3_t *)&v109);
            PhysicsFX_GetParticleOrientation(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v18[(_QWORD)v94], &orientation);
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+120h+var_110]
              vmovss  [rsp+220h+var_1C0], xmm0
            }
            if ( (v86 & 0x7F800000) == 2139095040 )
              goto LABEL_76;
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+120h+var_110+4]
              vmovss  [rsp+220h+var_1C0], xmm0
            }
            if ( (v87 & 0x7F800000) == 2139095040 )
              goto LABEL_76;
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+120h+var_110+8]
              vmovss  [rsp+220h+var_1C0], xmm0
            }
            if ( (v88 & 0x7F800000) == 2139095040 )
            {
LABEL_76:
              v38 = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
              v39 = ParticleSystem::GetDef(v38);
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1516, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( position )[0] ) && !IS_NAN( ( position )[1] ) && !IS_NAN( ( position )[2] ) ) )", "VFX ERROR: NAN in position coming from HavokFX: %s\n", v39->name) )
                __debugbreak();
            }
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+120h+var_100]
              vmovss  [rsp+220h+var_1C0], xmm0
            }
            if ( (v89 & 0x7F800000) == 2139095040 )
              goto LABEL_77;
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+120h+var_100+4]
              vmovss  [rsp+220h+var_1C0], xmm0
            }
            if ( (v90 & 0x7F800000) == 2139095040 )
              goto LABEL_77;
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+120h+var_100+8]
              vmovss  [rsp+220h+var_1C0], xmm0
            }
            v43 = (v91 & 0x7F800000u) < 0x7F800000;
            if ( (v91 & 0x7F800000) == 2139095040 )
            {
LABEL_77:
              v44 = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
              v45 = ParticleSystem::GetDef(v44);
              v46 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1517, ASSERT_TYPE_ASSERT, "( ( !IS_NAN( ( velocity )[0] ) && !IS_NAN( ( velocity )[1] ) && !IS_NAN( ( velocity )[2] ) ) )", "VFX ERROR: NAN in velocity coming from HavokFX: %s\n", v45->name);
              v43 = 0;
              if ( v46 )
                __debugbreak();
            }
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+120h+orientation]
              vmovss  xmm1, dword ptr [rbp+120h+orientation+4]
              vmulss  xmm3, xmm0, xmm0
              vmovss  xmm0, dword ptr [rbp+120h+orientation+8]
              vmulss  xmm2, xmm1, xmm1
              vaddss  xmm4, xmm3, xmm2
              vmovss  xmm2, dword ptr [rbp+120h+orientation+0Ch]
              vmulss  xmm1, xmm0, xmm0
              vaddss  xmm3, xmm4, xmm1
              vmulss  xmm0, xmm2, xmm2
              vaddss  xmm1, xmm3, xmm0
              vsubss  xmm3, xmm1, xmm8
              vandps  xmm3, xmm3, xmm7
              vcomiss xmm3, xmm9
            }
            if ( !v43 )
            {
              v60 = (ParticleSystem *)ParticleEmitter::GetSystemOwner((ParticleEmitter *)pEmitterOwner);
              v61 = ParticleSystem::GetDef(v60);
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1518, ASSERT_TYPE_ASSERT, "(Vec4IsNormalized( orientation ))", "%s\n\tVFX ERROR: Unnormalized quat coming from HavokFX: %s\n", "Vec4IsNormalized( orientation )", v61->name) )
                __debugbreak();
            }
            __asm { vmovaps xmm0, [rbp+120h+var_110] }
            _RCX = PositionArrayAtIndex;
            _RAX = (char *)VelocityArrayAtIndex + (_QWORD)_RSI;
            v65 = (_BYTE)v100 == 0;
            __asm
            {
              vmovups xmmword ptr [rax+rcx], xmm0
              vmovaps xmm1, [rbp+120h+var_100]
              vmovups xmmword ptr [rax], xmm1
              vmovaps xmm0, xmmword ptr [rbp+120h+orientation]
              vmovups xmmword ptr [rsi], xmm0
            }
            if ( !v65 )
            {
              PhysicsFX_GetParticleImpactAndClear(worldId, m_physicsFXPipelineInstance, *(_DWORD *)&v18[(_QWORD)v94], &impact, &data);
              if ( impact )
              {
                __asm
                {
                  vmovups xmm3, xmmword ptr [rbp+120h+data.incomingVelocity.v]
                  vmulps  xmm0, xmm3, xmm3
                  vinsertps xmm1, xmm0, xmm0, 8
                  vhaddps xmm2, xmm1, xmm1
                  vhaddps xmm0, xmm2, xmm2
                  vcomiss xmm0, xmm6
                }
                if ( m_pModulePhysicsLight->m_ignoreEmitterOrientation )
                {
                  Particle_RotMatrixToQuatVec(rotMatrix, &quat);
                  _RCX = RotationAngleArrayAtIndex;
                  __asm { vmovups xmm1, xmmword ptr [rbp+120h+quat] }
                  _RAX = 2i64 * v26;
                  __asm { vmovups xmm0, xmmword ptr [rcx+rax*8] }
                  Float4QuatMultiply(RotationAngleArrayAtIndex, v78, &v103);
                  __asm
                  {
                    vmovups xmm3, xmmword ptr [rbp+120h+data.incomingVelocity.v]
                    vmovups xmm0, [rbp+120h+var_160]
                  }
                }
                else
                {
                  __asm
                  {
                    vmovups xmm0, xmmword ptr [rsi]
                    vmovups [rbp+120h+var_160], xmm0
                  }
                }
                __asm
                {
                  vmovups xmm1, xmmword ptr [rbp+120h+data.pos.v]
                  vmovdqa [rbp+120h+var_150], xmm0
                  vmovups xmm0, xmmword ptr [rbp+120h+data.normal.v]
                  vmovdqa [rbp+120h+var_140], xmm3
                  vmovdqa [rbp+120h+var_130], xmm0
                  vmovdqa [rbp+120h+var_120], xmm1
                }
                ParticleState::FillImpactData((ParticleState *)pParticleState, &v99[v26], &v107, &v106, &v105, data.surfaceFlags, data.entNum, data.hitType, data.partName, &v104, pEmitterOwner);
                *(_DWORD *)v18 |= 4u;
                v28 = v95;
              }
            }
            *(_DWORD *)v18 &= ~0x40u;
            v32 = (__int64)v94;
          }
          ++v26;
          ++_RSI;
          v18 += 4;
        }
        while ( v26 < v28 );
        __asm
        {
          vmovaps xmm9, [rsp+220h+var_70]
          vmovaps xmm8, [rsp+220h+var_60]
          vmovaps xmm7, [rsp+220h+var_50]
          vmovaps xmm6, [rsp+220h+var_40]
        }
      }
    }
  }
}

/*
==============
ParticleModulePhysicsRayCast::Update
==============
*/
void ParticleModulePhysicsRayCast::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  ParticleEmitter *v14; 
  __int64 v17; 
  __int64 m_localClientNum; 
  unsigned int *FlagsArrayAtIndex; 
  int *RandomSeedArrayAtIndex; 
  int integer; 
  bool v23; 
  unsigned __int64 v24; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  int v32; 
  char m_type; 
  int v34; 
  int v35; 
  char v36; 
  int v38; 
  const ParticleStateDef *m_pStateDef; 
  unsigned __int64 v40; 
  char v41; 
  unsigned int v43; 
  signed __int64 v44; 
  unsigned int v48; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  __int64 v64; 
  __int64 v65; 
  __int64 v68; 
  __int64 v69; 
  __int64 v70; 
  int v71; 
  const ParticleModule *v72; 
  bool v90; 
  const float4 *v110; 
  const float4 *v114; 
  const float4 *v115; 
  int v140; 
  __int64 v142; 
  __int64 v143; 
  int v144; 
  __int64 v145; 
  __int64 v146; 
  unsigned int v147; 
  TraceHitType v148; 
  scr_string_t v149; 
  bool v150; 
  unsigned __int8 *v152; 
  signed __int64 v153; 
  float4 *PositionArrayAtIndex; 
  signed __int64 v155; 
  float4 v156; 
  unsigned int particleIndex; 
  int brushMask; 
  int *v159; 
  const ParticleModule *v160; 
  float4 *VelocityArrayAtIndex; 
  Particle_OnImpactData *v162; 
  __int64 v163; 
  unsigned __int64 v164; 
  ParticleData *pParticleDataa; 
  vector3 *rotMatrix; 
  float4 v167; 
  float4 v168; 
  float4 v169; 
  vec3_t end; 
  vec3_t start; 
  __int128 v172; 
  __int128 v173; 
  vec4_t quat; 

  __asm { vmovaps [rsp+220h+var_80], xmm9 }
  v14 = (ParticleEmitter *)pEmitterOwner;
  v17 = particleOffset;
  particleIndex = particleOffset;
  pParticleDataa = pParticleData;
  v160 = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + (unsigned int)v17 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v142) = particleCount + v17;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v142, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1593, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_localClientNum = pEmitterOwner->m_pSystemOwner->m_localClientNum;
  PositionArrayAtIndex = Particle_GetPositionArrayAtIndex(pParticleData, v17);
  VelocityArrayAtIndex = Particle_GetVelocityArrayAtIndex(pParticleData, v17);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, v17);
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, v17);
  v90 = pParticleData->m_pParticleData == NULL;
  v159 = RandomSeedArrayAtIndex;
  if ( v90 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 364, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v17 >= pParticleData->m_particleCountMax )
  {
    LODWORD(v145) = pParticleData->m_particleCountMax;
    LODWORD(v142) = v17;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 364, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", v142, v145) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 364, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  v152 = &ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_RAY_CAST_HANDLE)[4 * v17];
  rotMatrix = (vector3 *)ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  pEmitterOwner->m_numRayCasts += particleCount;
  integer = particle_override_raycast_contents_mask_solid->current.integer;
  v23 = 1;
  if ( integer )
    v23 = integer == 1;
  LODWORD(v24) = 0;
  v25 = v23 ? 0x811 : 0;
  v156.v.m128_u64[0] = 0i64;
  v26 = particle_override_raycast_contents_vehicle->current.integer;
  v27 = 1;
  if ( v26 )
    v27 = v26 == 1;
  v28 = (v27 << 23) | v25;
  v29 = particle_override_raycast_contents_item->current.integer;
  v30 = *((_BYTE *)&pModuleBase[5].m_type + 3) == 0;
  if ( v29 )
    v30 = v29 == 1;
  v31 = (v30 << 8) | v28;
  v32 = particle_override_raycast_contents_item_clip->current.integer;
  m_type = pModuleBase[5].m_type;
  if ( v32 )
    m_type = v32 == 1;
  v34 = (m_type != 0 ? 0x400 : 0) | v31;
  v35 = particle_override_raycast_contents_water->current.integer;
  v36 = *((_BYTE *)&pModuleBase[5].m_type + 2);
  if ( v35 )
    v36 = v35 == 1;
  __asm { vbroadcastss xmm9, [rbp+120h+dt] }
  v38 = (v36 != 0 ? 0x20 : 0) | v34;
  m_pStateDef = pParticleState->m_pStateDef;
  brushMask = v38;
  v40 = (unsigned __int64)LODWORD(m_pStateDef->flags) >> 16;
  LOBYTE(v40) = v40 & 1;
  v164 = v40;
  if ( (_BYTE)v40 )
  {
    if ( !pParticleState->m_onImpactDataList )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlestate.h", 455, ASSERT_TYPE_ASSERT, "(m_onImpactDataList)", (const char *)&queryFormat, "m_onImpactDataList") )
        __debugbreak();
      if ( !pParticleState->m_onImpactDataList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1620, ASSERT_TYPE_ASSERT, "(!handleImpacts || pParticleState->GetOnImpactDataList())", (const char *)&queryFormat, "!handleImpacts || pParticleState->GetOnImpactDataList()") )
        __debugbreak();
    }
    v162 = &ParticleState::GetOnImpactDataList((ParticleState *)pParticleState)[v17];
    if ( !v162 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1622, ASSERT_TYPE_ASSERT, "(!handleImpacts || pImpactDataList)", (const char *)&queryFormat, "!handleImpacts || pImpactDataList") )
      __debugbreak();
  }
  else
  {
    v162 = NULL;
  }
  if ( (unsigned int)m_localClientNum >= 2 )
  {
    LODWORD(v145) = 2;
    LODWORD(v142) = m_localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 623, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v142, v145) )
      __debugbreak();
    LODWORD(v146) = 2;
    LODWORD(v143) = m_localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 609, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v143, v146) )
      __debugbreak();
  }
  v41 = g_particleDeferredPhysicsRayCastIndex[m_localClientNum] - 1;
  v163 = 2 * m_localClientNum;
  v150 = g_particleDeferredPhysicsRayCastResultValid[m_localClientNum][v41 & 1];
  if ( particleCount )
  {
    v155 = (char *)PositionArrayAtIndex - (char *)VelocityArrayAtIndex;
    _R12 = VelocityArrayAtIndex;
    v159 = (int *)((char *)v159 - (__int64)FlagsArrayAtIndex);
    v43 = particleCount;
    v44 = v152 - (unsigned __int8 *)FlagsArrayAtIndex;
    __asm
    {
      vmovaps [rsp+220h+var_90], xmm10
      vmovss  xmm10, cs:__real@3f800000
      vmovaps [rsp+220h+var_A0], xmm11
      vmovss  xmm11, cs:__real@34000000
      vmovaps [rsp+220h+var_B0], xmm12
      vmovaps [rsp+220h+var_50], xmm6
      vmovaps [rsp+220h+var_60], xmm7
    }
    v153 = v152 - (unsigned __int8 *)FlagsArrayAtIndex;
    __asm
    {
      vxorps  xmm12, xmm12, xmm12
      vmovaps [rsp+220h+var_70], xmm8
    }
    while ( (*(_BYTE *)FlagsArrayAtIndex & 0x10) != 0 )
    {
LABEL_110:
      v24 = (unsigned int)(v24 + 1);
      ++_R12;
      v156.v.m128_u64[0] = v24;
      ++FlagsArrayAtIndex;
      if ( (unsigned int)v24 >= v43 )
      {
        __asm
        {
          vmovaps xmm12, [rsp+220h+var_B0]
          vmovaps xmm11, [rsp+220h+var_A0]
          vmovaps xmm10, [rsp+220h+var_90]
          vmovaps xmm8, [rsp+220h+var_70]
          vmovaps xmm7, [rsp+220h+var_60]
          vmovaps xmm6, [rsp+220h+var_50]
        }
        goto LABEL_112;
      }
    }
    if ( (pParticleState->m_pStateDef->flags & 2) != 0 || (pParticleState->m_pStateDef->flags & 0x10000000) != 0 )
    {
      v48 = v14->m_pSystemOwner->m_localClientNum;
      if ( (pParticleState->m_pStateDef->flags & 0x10000000) != 0 )
      {
        if ( v48 >= 2 )
        {
          LODWORD(v145) = 2;
          LODWORD(v142) = v14->m_pSystemOwner->m_localClientNum;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v142, v145) )
            __debugbreak();
        }
      }
      else if ( v48 >= 2 )
      {
        LODWORD(v145) = 2;
        LODWORD(v142) = v14->m_pSystemOwner->m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v142, v145) )
          __debugbreak();
      }
      v44 = v153;
    }
    else
    {
      ParticleEmitter::GetSystemOwner(v14);
    }
    m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
    if ( !m_pModuleInitRelativeVelocity || (m_pModuleInitRelativeVelocity->m_flags & 1) != 0 || ((m_pModuleInitRelativeVelocity->m_velocityType - 3) & 0xFFFFFFFD) != 0 )
    {
      _RAX = v155;
      __asm { vmovups xmm6, xmmword ptr [rax+r12] }
    }
    else
    {
      _RAX = v155;
      __asm
      {
        vmovups xmm0, xmmword ptr [rax+r12]
        vshufps xmm2, xmm0, xmm0, 0AAh ; 'ª'
        vshufps xmm3, xmm0, xmm0, 55h ; 'U'
        vshufps xmm4, xmm0, xmm0, 0
        vmulps  xmm0, xmm2, xmmword ptr [rcx+20h]
        vaddps  xmm2, xmm0, xmmword ptr [rcx+30h]
        vmulps  xmm0, xmm3, xmmword ptr [rcx+10h]
        vaddps  xmm1, xmm0, xmm2
        vmulps  xmm0, xmm4, xmmword ptr [rcx]
        vaddps  xmm6, xmm0, xmm1
      }
    }
    if ( (pParticleState->m_pStateDef->flags & 0x10000000) != 0 )
    {
      ParticleEmitter::GetSystemOwner(v14);
      __asm { vaddps  xmm6, xmm6, xmmword ptr [rax+30h] }
    }
    v90 = (*(_BYTE *)FlagsArrayAtIndex & 0x20) == 0;
    __asm
    {
      vmulps  xmm0, xmm9, xmmword ptr [r12]
      vaddps  xmm1, xmm0, xmm6
      vmovss  dword ptr [rbp+120h+end], xmm1
      vextractps dword ptr [rbp+120h+end+4], xmm1, 1
      vextractps dword ptr [rbp+120h+end+8], xmm1, 2
      vmovss  dword ptr [rbp+120h+start], xmm6
      vextractps dword ptr [rbp+120h+start+4], xmm6, 1
      vextractps dword ptr [rbp+120h+start+8], xmm6, 2
    }
    if ( v90 )
      goto LABEL_108;
    v64 = *(unsigned int *)((char *)FlagsArrayAtIndex + v44);
    if ( (_DWORD)v64 != 2048 && v150 )
    {
      if ( (unsigned int)m_localClientNum >= 2 )
      {
        LODWORD(v145) = 2;
        LODWORD(v142) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 631, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v142, v145) )
          __debugbreak();
      }
      if ( (unsigned int)v64 >= 0x800 )
      {
        LODWORD(v145) = 2048;
        LODWORD(v142) = v64;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 632, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( PARTICLE_DEFERRED_PHYSICS_RAY_CAST_LIST_MAX )", "index doesn't index PARTICLE_DEFERRED_PHYSICS_RAY_CAST_LIST_MAX\n\t%i not in [0, %i)", v142, v145) )
          __debugbreak();
      }
      if ( (unsigned int)m_localClientNum >= 2 )
      {
        LODWORD(v145) = 2;
        LODWORD(v142) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_shared.h", 609, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v142, v145) )
          __debugbreak();
      }
      v65 = v64 + ((v163 + (((unsigned __int8)g_particleDeferredPhysicsRayCastIndex[m_localClientNum] - 1) & 1)) << 11);
      _RBX = (_DWORD *)&g_particleDeferredPhysicsRayCastCreateList[0][0][v65].results.fraction;
      __asm
      {
        vmovss  xmm7, dword ptr [rbx]
        vcomiss xmm7, xmm10
      }
      if ( __CFADD__(g_particleDeferredPhysicsRayCastCreateList, 144 * v65) )
      {
        if ( _RBX[9] == 1 )
        {
          v68 = (int)_RBX[11];
          if ( (unsigned int)v68 >= 0x7FE || (v160->m_flags & 0x20000) != 0 || !particle_raycast_ignore_wztrain_killswitch->current.enabled )
          {
            v14 = (ParticleEmitter *)pEmitterOwner;
          }
          else
          {
            if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
            {
              LODWORD(v145) = m_localClientNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", v145) )
                __debugbreak();
            }
            if ( (unsigned int)m_localClientNum >= CgEntitySystem::ms_allocatedCount )
            {
              LODWORD(v145) = CgEntitySystem::ms_allocatedCount;
              LODWORD(v142) = m_localClientNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v142, v145) )
                __debugbreak();
            }
            if ( !CgEntitySystem::ms_entitySystemArray[m_localClientNum] )
            {
              LODWORD(v145) = m_localClientNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", v145) )
                __debugbreak();
            }
            v24 = (unsigned __int64)CgEntitySystem::ms_entitySystemArray[m_localClientNum];
            if ( (unsigned int)v68 >= 0x800 )
            {
              LODWORD(v145) = 2048;
              LODWORD(v142) = v68;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v142, v145) )
                __debugbreak();
            }
            v69 = 760 * v68;
            v14 = (ParticleEmitter *)pEmitterOwner;
            v70 = v69 + v24 + 16;
            LODWORD(v24) = v156.v.m128_i32[0];
            if ( v70 && (*(_BYTE *)(v70 + 524) & 0x20) != 0 )
              goto LABEL_107;
          }
        }
        __asm { vmovss  xmm0, dword ptr [rbx+10h] }
        HIDWORD(v172) = 0;
        __asm
        {
          vmovups xmm8, xmmword ptr [rbp+30h]
          vmovss  xmm8, xmm8, xmm0
          vinsertps xmm8, xmm8, dword ptr [rbx+14h], 10h
          vinsertps xmm8, xmm8, dword ptr [rbx+18h], 20h ; ' '
        }
        *FlagsArrayAtIndex |= 8u;
        __asm
        {
          vmovups xmm0, xmmword ptr [r12]
          vmulps  xmm1, xmm0, xmm0
          vinsertps xmm2, xmm1, xmm1, 8
          vhaddps xmm0, xmm2, xmm2
          vhaddps xmm1, xmm0, xmm0
          vmovups xmmword ptr [rbp+30h], xmm8
        }
        v90 = (_BYTE)v164 == 0;
        if ( (_BYTE)v164 )
        {
          __asm
          {
            vcomiss xmm1, xmm11
            vmovss  xmm0, dword ptr [rbx+64h]
            vsubss  xmm1, xmm0, dword ptr [rbx+58h]
            vmovss  xmm0, dword ptr [rbx+68h]
            vmulss  xmm2, xmm1, xmm7
            vsubss  xmm1, xmm0, dword ptr [rbx+5Ch]
            vaddss  xmm6, xmm2, dword ptr [rbx+58h]
            vmovss  xmm0, dword ptr [rbx+6Ch]
            vmulss  xmm2, xmm1, xmm7
            vaddss  xmm5, xmm2, dword ptr [rbx+5Ch]
            vsubss  xmm1, xmm0, dword ptr [rbx+60h]
            vmulss  xmm2, xmm1, xmm7
            vaddss  xmm4, xmm2, dword ptr [rbx+60h]
          }
          HIDWORD(v173) = 0;
          __asm
          {
            vmovups xmm7, xmmword ptr [rbp+40h]
            vmovss  xmm7, xmm7, xmm6
            vinsertps xmm7, xmm7, xmm5, 10h
            vinsertps xmm7, xmm7, xmm4, 20h ; ' '
            vmovups xmmword ptr [rbp+40h], xmm7
          }
          _RAX = Particle_GetRotationAngleArrayAtIndex(pParticleDataa, particleIndex);
          _RCX = (char *)_R12 - (char *)VelocityArrayAtIndex;
          __asm { vmovups xmm0, xmmword ptr [rcx+rax] }
          Float4RadianToQuat((float4 *)((char *)_R12 - (char *)VelocityArrayAtIndex), v110);
          __asm
          {
            vmovups xmm6, xmm0
            vmovdqa [rbp+120h+var_1A0], xmm0
          }
          Particle_RotMatrixToQuatVec(rotMatrix, &quat);
          __asm
          {
            vmovups xmm1, xmmword ptr [rbp+120h+quat]
            vmovups xmm0, xmm6
          }
          Float4QuatMultiply(v115, v114, &v156);
          __asm
          {
            vmovups xmm0, [rbp+120h+var_1A0]
            vmovups xmm1, xmmword ptr [r12]
            vmovdqa [rbp+120h+var_1A0], xmm0
            vmovups [rbp+120h+var_140], xmm1
          }
          v149 = _RBX[14];
          v148 = _RBX[9];
          v147 = _RBX[11];
          v144 = _RBX[7];
          __asm
          {
            vmovdqa [rbp+120h+var_130], xmm8
            vmovdqa [rbp+120h+var_120], xmm7
          }
          ParticleState::FillImpactData((ParticleState *)pParticleState, &v162[(unsigned int)v24], &v169, &v168, &v167, v144, v147, v148, v149, &v156, v14);
          v90 = 0;
          *FlagsArrayAtIndex |= 4u;
        }
        _RCX = 0x140000000ui64;
        _RAX = *(int *)((char *)FlagsArrayAtIndex + (_QWORD)v159);
        __asm
        {
          vmovss  xmm2, ds:(rva ?fx_randomTable@@3QBMB+44h)[rcx+rax*4]; float const near * const fx_randomTable
          vsubss  xmm0, xmm10, xmm2
          vmulss  xmm1, xmm0, dword ptr [rax+8]
          vmulss  xmm0, xmm2, dword ptr [rax+0Ch]
          vaddss  xmm4, xmm1, xmm0
          vcomiss xmm4, xmm12
          vmulps  xmm0, xmm8, xmmword ptr [r12]
          vinsertps xmm2, xmm0, xmm0, 8
          vhaddps xmm1, xmm2, xmm2
          vhaddps xmm3, xmm1, xmm1
          vmulps  xmm2, xmm3, cs:__xmm@c0000000c0000000c0000000c0000000
          vmulps  xmm0, xmm8, xmm2
          vaddps  xmm3, xmm0, xmmword ptr [r12]
          vmulps  xmm1, xmm3, xmm3
          vhaddps xmm0, xmm1, xmm1
          vhaddps xmm2, xmm0, xmm0
        }
        if ( v90 )
          goto LABEL_119;
        __asm
        {
          vmovups xmm0, xmmword ptr cs:VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_1442.v
          vcmpltps xmm1, xmm0, xmm2
          vmovmskps eax, xmm1
        }
        if ( (_EAX & 0xF) != 15 )
        {
LABEL_119:
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vmovups xmmword ptr [r12], xmm0
          }
          v140 = *FlagsArrayAtIndex | 0x10;
        }
        else
        {
          __asm
          {
            vmovaps xmm0, xmm4
            vshufps xmm0, xmm0, xmm0, 0
            vmulps  xmm0, xmm0, xmm3
            vmovups xmmword ptr [r12], xmm0
          }
          v140 = *FlagsArrayAtIndex;
        }
        v44 = v153;
        *FlagsArrayAtIndex = v140 & 0xFFFFFFDF;
        *(unsigned int *)((char *)FlagsArrayAtIndex + v153) = 2048;
        goto LABEL_109;
      }
    }
LABEL_107:
    v44 = v153;
LABEL_108:
    v71 = brushMask;
    v72 = v160;
    *FlagsArrayAtIndex |= 0x20u;
    *(unsigned int *)((char *)FlagsArrayAtIndex + v44) = Particle_AddDeferredPhysicsRayCastCreate((LocalClientNum_t)m_localClientNum, &start, &end, (const Bounds *)&v72[2], v71);
LABEL_109:
    v43 = particleCount;
    goto LABEL_110;
  }
LABEL_112:
  __asm { vmovaps xmm9, [rsp+220h+var_80] }
}

/*
==============
ParticleModulePositionGraph::Update
==============
*/
void ParticleModulePositionGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float dt, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  unsigned int m_flags; 
  bool useLength; 
  bool v25; 
  bool v28; 
  unsigned int v58; 
  __int64 v60; 
  __int64 v94; 
  __int128 v95; 
  __int64 v96; 
  char v106; 

  __asm
  {
    vmovaps [rsp+138h+var_A8], xmm11
    vmovaps [rsp+138h+var_B8], xmm12
  }
  _R15 = pParticleState;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R13 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleCount + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v94) = particleCount + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v94, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1745, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  m_flags = pModuleBase->m_flags;
  useLength = pParticleState->m_moduleGraphLengthData.useLength;
  v25 = (m_flags & 0x10) != 0;
  if ( useLength && (m_flags & 0x300) != 768 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1756, ASSERT_TYPE_ASSERT, "(!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL ))", (const char *)&queryFormat, "!getValueByLength || pModuleBase->HasAllFlags( PARTICLE_MODULE_FLAG_GRAPH_BY_LENGTH | PARTICLE_MODULE_FLAG_UPDATE_EXTERNAL )") )
    __debugbreak();
  Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  _RBX = Particle_GetPositionArrayAtIndex(pParticleData, particleOffset);
  *(_QWORD *)&v95 = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  _RSI = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  v28 = (pModuleBase->m_flags & 4) == 0 && !useLength;
  __asm
  {
    vmovaps [rsp+138h+var_98], xmm10
    vxorps  xmm11, xmm11, xmm11
    vinsertps xmm11, xmm11, dword ptr [rdi+1Ch], 0
    vinsertps xmm11, xmm11, dword ptr [rdi+2Ch], 10h
    vinsertps xmm11, xmm11, dword ptr [rdi+3Ch], 20h ; ' '
  }
  if ( v25 )
  {
    __asm
    {
      vxorps  xmm10, xmm10, xmm10
      vinsertps xmm10, xmm10, dword ptr [rdi+4Ch], 0
      vinsertps xmm10, xmm10, dword ptr [rdi+5Ch], 10h
      vinsertps xmm10, xmm10, dword ptr [rdi+6Ch], 20h ; ' '
    }
  }
  else
  {
    __asm { vmovups xmm10, [rsp+138h+var_E8] }
  }
  __asm
  {
    vmovaps [rsp+138h+var_58], xmm6
    vmovaps [rsp+138h+var_68], xmm7
    vmovaps [rsp+138h+var_78], xmm8
    vmovaps [rsp+138h+var_88], xmm9
    vmovaps [rsp+138h+var_C8], xmm13
    vmovss  xmm0, cs:__real@3f800000
    vdivss  xmm12, xmm0, [rsp+138h+dt]
    vshufps xmm12, xmm12, xmm12, 0
  }
  if ( v28 )
  {
    __asm { vmovups xmm8, [rsp+138h+var_E8] }
  }
  else
  {
    if ( useLength )
    {
      __asm { vmovss  xmm9, dword ptr [r15+24h] }
      _RBX = &pParticleState->m_moduleGraphLengthData.position;
    }
    else
    {
      __asm { vmovss  xmm9, dword ptr [r13+178h] }
    }
    __asm { vmovaps xmm1, xmm9; time }
    *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], *(const float *)&_XMM1);
    __asm
    {
      vmovaps xmm1, xmm9; time
      vmovaps xmm7, xmm0
    }
    *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], *(const float *)&_XMM1);
    __asm
    {
      vmovaps xmm1, xmm9; time
      vmovaps xmm6, xmm0
    }
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
    __asm
    {
      vxorps  xmm2, xmm2, xmm2
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm6, 10h
      vinsertps xmm2, xmm2, xmm7, 20h ; ' '
      vmulps  xmm8, xmm11, xmm2
    }
    if ( v25 )
    {
      __asm { vmovaps xmm1, xmm9; time }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm9; time
        vmovaps xmm7, xmm0
      }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm9; time
        vmovaps xmm6, xmm0
      }
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], *(const float *)&_XMM1);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
        vmulps  xmm13, xmm10, xmm1
      }
      goto LABEL_38;
    }
  }
  __asm { vmovups xmm13, [rsp+138h+var_E8] }
LABEL_38:
  v58 = 1;
  if ( !useLength )
    v58 = particleCount;
  if ( v58 )
  {
    _RDX = v95 - (_QWORD)_RBX;
    v96 = v95 - (_QWORD)_RBX;
    v60 = v58;
    do
    {
      if ( v28 )
      {
        __asm
        {
          vmovss  xmm9, dword ptr [rsi]
          vmovaps xmm1, xmm9; time
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm9; time
          vmovaps xmm7, xmm0
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm9; time
          vmovaps xmm6, xmm0
        }
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
        __asm
        {
          vxorps  xmm2, xmm2, xmm2
          vinsertps xmm2, xmm2, xmm0, 0
          vinsertps xmm2, xmm2, xmm6, 10h
          vinsertps xmm2, xmm2, xmm7, 20h ; ' '
          vmulps  xmm8, xmm11, xmm2
        }
        if ( v25 )
        {
          __asm { vmovaps xmm1, xmm9; time }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], *(const float *)&_XMM1);
          __asm
          {
            vmovaps xmm1, xmm9; time
            vmovaps xmm7, xmm0
          }
          *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], *(const float *)&_XMM1);
          __asm
          {
            vmovaps xmm1, xmm9; time
            vmovaps xmm6, xmm0
          }
          Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], *(const float *)&_XMM1);
          __asm
          {
            vxorps  xmm1, xmm1, xmm1
            vinsertps xmm1, xmm1, xmm0, 0
            vinsertps xmm1, xmm1, xmm6, 10h
            vinsertps xmm1, xmm1, xmm7, 20h ; ' '
            vmulps  xmm13, xmm10, xmm1
          }
        }
        _RDX = v96;
      }
      __asm { vmovups xmm3, xmmword ptr [rbx] }
      if ( v25 )
      {
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vinsertps xmm1, xmm1, dword ptr [r13+r14*4+18h], 0
          vinsertps xmm1, xmm1, dword ptr [r13+r14*4+1Ch], 10h
          vinsertps xmm1, xmm1, dword ptr [r13+r14*4+20h], 20h ; ' '
          vsubps  xmm0, xmm13, xmm8
          vmulps  xmm1, xmm1, xmm0
          vaddps  xmm2, xmm1, xmm8
          vmovups xmmword ptr [rbx], xmm2
        }
      }
      else
      {
        __asm { vmovups xmmword ptr [rbx], xmm8 }
      }
      __asm
      {
        vmovups xmm0, xmmword ptr [rbx]
        vsubps  xmm0, xmm0, xmm3
        vmulps  xmm1, xmm0, xmm12
        vmovups xmmword ptr [rdx+rbx], xmm1
      }
      ++_RBX;
      ++_RSI;
      --v60;
    }
    while ( v60 );
  }
  __asm
  {
    vmovaps xmm13, [rsp+138h+var_C8]
    vmovaps xmm10, [rsp+138h+var_98]
    vmovaps xmm9, [rsp+138h+var_88]
    vmovaps xmm8, [rsp+138h+var_78]
    vmovaps xmm7, [rsp+138h+var_68]
    vmovaps xmm6, [rsp+138h+var_58]
  }
  _R11 = &v106;
  __asm
  {
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
  }
}

/*
==============
ParticleModuleRotationGraph3D::Update
==============
*/
void ParticleModuleRotationGraph3D::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v17; 
  bool v22; 
  float4 *RotationRateArrayAtIndex; 
  __int64 i; 
  __int64 v82; 

  __asm { vmovaps [rsp+118h+var_A8], xmm11 }
  v17 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R13 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v17 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v82) = v17 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v82, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1939, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  v22 = (pModuleBase->m_flags & 0x10) != 0;
  Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  if ( LOBYTE(pModuleBase[1].m_type) )
    RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, particleOffset);
  else
    RotationRateArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, particleOffset);
  __asm { vmovaps [rsp+118h+var_88], xmm9 }
  _RSI = RotationRateArrayAtIndex;
  _RDI = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  __asm
  {
    vxorps  xmm11, xmm11, xmm11
    vinsertps xmm11, xmm11, dword ptr [rbx+1Ch], 0
    vinsertps xmm11, xmm11, dword ptr [rbx+2Ch], 10h
    vinsertps xmm11, xmm11, dword ptr [rbx+3Ch], 20h ; ' '
  }
  if ( v22 )
  {
    __asm
    {
      vxorps  xmm9, xmm9, xmm9
      vinsertps xmm9, xmm9, dword ptr [rbx+4Ch], 0
      vinsertps xmm9, xmm9, dword ptr [rbx+5Ch], 10h
      vinsertps xmm9, xmm9, dword ptr [rbx+6Ch], 20h ; ' '
    }
  }
  else
  {
    __asm { vmovups xmm9, [rsp+118h+var_D8] }
  }
  __asm
  {
    vmovaps [rsp+118h+var_58], xmm6
    vmovaps [rsp+118h+var_68], xmm7
    vmovaps [rsp+118h+var_78], xmm8
    vmovaps [rsp+118h+var_98], xmm10
    vmovaps [rsp+118h+var_B8], xmm12
  }
  if ( (pModuleBase->m_flags & 4) != 0 )
  {
    __asm
    {
      vmovss  xmm10, dword ptr [r13+178h]
      vmovaps xmm1, xmm10; time
    }
    *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], *(const float *)&_XMM1);
    __asm
    {
      vmovaps xmm1, xmm10; time
      vmovaps xmm7, xmm0
    }
    *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], *(const float *)&_XMM1);
    __asm
    {
      vmovaps xmm1, xmm10; time
      vmovaps xmm6, xmm0
    }
    Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
    __asm
    {
      vxorps  xmm2, xmm2, xmm2
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm6, 10h
      vinsertps xmm2, xmm2, xmm7, 20h ; ' '
      vmulps  xmm8, xmm11, xmm2
    }
    if ( v22 )
    {
      __asm { vmovaps xmm1, xmm10; time }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm10; time
        vmovaps xmm7, xmm0
      }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm10; time
        vmovaps xmm6, xmm0
      }
      Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], *(const float *)&_XMM1);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
        vmulps  xmm12, xmm9, xmm1
      }
      goto LABEL_30;
    }
  }
  else
  {
    __asm { vmovups xmm8, [rsp+118h+var_D8] }
  }
  __asm { vmovups xmm12, [rsp+118h+var_D8] }
LABEL_30:
  if ( (_DWORD)v17 )
  {
    for ( i = v17; i; --i )
    {
      if ( (pModuleBase->m_flags & 4) == 0 )
      {
        __asm
        {
          vmovss  xmm10, dword ptr [rdi]
          vmovaps xmm1, xmm10; time
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[6], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm10; time
          vmovaps xmm7, xmm0
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[4], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm10; time
          vmovaps xmm6, xmm0
        }
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1);
        __asm
        {
          vxorps  xmm2, xmm2, xmm2
          vinsertps xmm2, xmm2, xmm0, 0
          vinsertps xmm2, xmm2, xmm6, 10h
          vinsertps xmm2, xmm2, xmm7, 20h ; ' '
          vmulps  xmm8, xmm11, xmm2
        }
        if ( !v22 )
          goto LABEL_37;
        __asm { vmovaps xmm1, xmm10; time }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[12], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm10; time
          vmovaps xmm7, xmm0
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[10], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm10; time
          vmovaps xmm6, xmm0
        }
        Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[8], *(const float *)&_XMM1);
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vinsertps xmm1, xmm1, xmm0, 0
          vinsertps xmm1, xmm1, xmm6, 10h
          vinsertps xmm1, xmm1, xmm7, 20h ; ' '
          vmulps  xmm12, xmm9, xmm1
        }
      }
      if ( !v22 )
      {
LABEL_37:
        __asm { vmovdqa xmm2, xmm8 }
        goto LABEL_38;
      }
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, dword ptr [r13+r15*4+88h], 0
        vinsertps xmm1, xmm1, dword ptr [r13+r15*4+8Ch], 10h
        vinsertps xmm1, xmm1, dword ptr [r13+r15*4+90h], 20h ; ' '
        vsubps  xmm0, xmm12, xmm8
        vmulps  xmm1, xmm1, xmm0
        vaddps  xmm2, xmm1, xmm8
      }
LABEL_38:
      __asm
      {
        vshufps xmm0, xmm2, xmm2, 0C9h ; 'É'
        vmovups xmmword ptr [rsi], xmm0
      }
      ++_RSI;
      ++_RDI;
    }
  }
  __asm
  {
    vmovaps xmm12, [rsp+118h+var_B8]
    vmovaps xmm10, [rsp+118h+var_98]
    vmovaps xmm9, [rsp+118h+var_88]
    vmovaps xmm8, [rsp+118h+var_78]
    vmovaps xmm7, [rsp+118h+var_68]
    vmovaps xmm6, [rsp+118h+var_58]
    vmovaps xmm11, [rsp+118h+var_A8]
  }
}

/*
==============
ParticleModuleRotationGraph::Update
==============
*/
void ParticleModuleRotationGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v16; 
  bool v21; 
  float4 *RotationRateArrayAtIndex; 
  bool v25; 
  __int64 v31; 
  __int64 v48; 
  char v55; 

  __asm
  {
    vmovaps [rsp+0C8h+var_68], xmm9
    vmovaps [rsp+0C8h+var_78], xmm10
  }
  v16 = particleCount;
  _RSI = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R15 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( particleOffset + (unsigned int)v16 >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v48) = particleOffset + v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v48, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (_RSI->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1870, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  __asm
  {
    vmovss  xmm9, dword ptr [rsi+1Ch]
    vmovss  xmm10, dword ptr [rsi+2Ch]
  }
  v21 = (_RSI->m_flags & 0x10) != 0;
  Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  if ( LOBYTE(_RSI[1].m_type) )
    RotationRateArrayAtIndex = Particle_GetRotationRateArrayAtIndex(pParticleData, particleOffset);
  else
    RotationRateArrayAtIndex = Particle_GetRotationAngleArrayAtIndex(pParticleData, particleOffset);
  __asm
  {
    vmovaps [rsp+0C8h+var_38], xmm6
    vmovaps [rsp+0C8h+var_48], xmm7
    vmovaps [rsp+0C8h+var_58], xmm8
  }
  _RDI = RotationRateArrayAtIndex;
  _RBX = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  v25 = (_RSI->m_flags & 4) == 0;
  if ( (_RSI->m_flags & 4) != 0 )
  {
    __asm
    {
      vmovss  xmm6, dword ptr [r15+178h]
      vmovaps xmm1, xmm6; time
    }
    *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RSI[2], *(const float *)&_XMM1);
    __asm { vmulss  xmm7, xmm0, xmm9 }
    if ( v21 )
    {
      __asm { vmovaps xmm1, xmm6; time }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RSI[4], *(const float *)&_XMM1);
      __asm { vmulss  xmm8, xmm0, xmm10 }
      goto LABEL_27;
    }
  }
  else
  {
    __asm { vmovss  xmm7, [rsp+0C8h+arg_10] }
  }
  __asm { vmovss  xmm8, [rsp+0C8h+arg_10] }
LABEL_27:
  if ( (_DWORD)v16 )
  {
    v31 = v16;
    __asm
    {
      vmovaps [rsp+0C8h+var_88], xmm11
      vmovss  xmm11, cs:__real@3f800000
    }
    while ( 1 )
    {
      if ( v25 )
      {
        __asm
        {
          vmovss  xmm6, dword ptr [rbx]
          vmovaps xmm1, xmm6; time
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RSI[2], *(const float *)&_XMM1);
        __asm { vmulss  xmm7, xmm0, xmm9 }
        if ( !v21 )
          goto LABEL_34;
        __asm { vmovaps xmm1, xmm6; time }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RSI[4], *(const float *)&_XMM1);
        __asm { vmulss  xmm8, xmm0, xmm10 }
      }
      if ( !v21 )
      {
LABEL_34:
        __asm
        {
          vmovaps xmm0, xmm7
          vshufps xmm0, xmm0, xmm0, 0
          vmovups xmmword ptr [rdi], xmm0
        }
        goto LABEL_35;
      }
      __asm
      {
        vsubss  xmm0, xmm11, dword ptr [r13+r15*4+0]
        vmulss  xmm1, xmm8, dword ptr [r13+r15*4+0]
        vmulss  xmm2, xmm0, xmm7
        vaddss  xmm3, xmm2, xmm1
        vshufps xmm3, xmm3, xmm3, 0
        vmovups xmmword ptr [rdi], xmm3
      }
LABEL_35:
      ++_RBX;
      ++_RDI;
      if ( !--v31 )
      {
        __asm { vmovaps xmm11, [rsp+0C8h+var_88] }
        break;
      }
    }
  }
  __asm { vmovaps xmm8, [rsp+0C8h+var_58] }
  _R11 = &v55;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm7, [rsp+0C8h+var_48]
    vmovaps xmm6, [rsp+0C8h+var_38]
  }
}

/*
==============
ParticleModuleScaleByDistance::Update
==============
*/
void ParticleModuleScaleByDistance::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount)
{
  ;
}

/*
==============
ParticleModuleShaderGraph::Update
==============
*/
void ParticleModuleShaderGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v12; 
  ParticleShaderParams *ShaderParamsArray; 
  __int64 v37; 
  float4 outCurve; 
  float4 v39; 

  v12 = particleCount;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _RBP = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v12 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v37) = v12 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v37, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 763, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( pParticleState->m_pModuleInitMaterial )
  {
    _RDI = Particle_GetLifeArray(pParticleData);
    ShaderParamsArray = Particle_GetShaderParamsArray(pParticleData);
    _RSI = ShaderParamsArray;
    if ( (_DWORD)v12 )
    {
      _R14 = &ShaderParamsArray->params0.v[2];
      __asm
      {
        vmovaps [rsp+0E8h+var_58], xmm6
        vmovaps [rsp+0E8h+var_68], xmm7
        vmovaps [rsp+0E8h+var_78], xmm8
        vmovaps [rsp+0E8h+var_88], xmm9
      }
      do
      {
        if ( (pModuleBase->m_flags & 4) != 0 )
          __asm { vmovss  xmm9, dword ptr [rbp+178h] }
        else
          __asm { vmovss  xmm9, dword ptr [rdi] }
        __asm { vmovaps xmm1, xmm9; time }
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[2], *(const float *)&_XMM1, &outCurve);
        __asm { vmovaps xmm1, xmm9; time }
        Particle_GetColorValueFromCurveList((const ParticleCurveDef *)&pModuleBase[10], *(const float *)&_XMM1, &v39);
        __asm { vmovaps xmm1, xmm9; time }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[18], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm9; time
          vmovaps xmm8, xmm0
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[20], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm9; time
          vmovaps xmm7, xmm0
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[22], *(const float *)&_XMM1);
        __asm
        {
          vmovaps xmm1, xmm9; time
          vmovaps xmm6, xmm0
        }
        *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&pModuleBase[24], *(const float *)&_XMM1);
        __asm
        {
          vmovups xmm1, xmmword ptr [rsp+0E8h+outCurve.v]
          vmovups xmm2, xmmword ptr [rsp+0E8h+var_98.v]
          vmovups xmmword ptr [rsi], xmm1
          vmovups xmmword ptr [rsi+10h], xmm2
          vmovss  dword ptr [r14-8], xmm8
          vmovss  dword ptr [r14-4], xmm7
          vmovss  dword ptr [r14], xmm6
          vmovss  dword ptr [r14+4], xmm0
        }
        _R14 += 12;
        ++_RSI;
        ++_RDI;
        --v12;
      }
      while ( v12 );
      __asm
      {
        vmovaps xmm9, [rsp+0E8h+var_88]
        vmovaps xmm8, [rsp+0E8h+var_78]
        vmovaps xmm7, [rsp+0E8h+var_68]
        vmovaps xmm6, [rsp+0E8h+var_58]
      }
    }
  }
}

/*
==============
ParticleModuleSizeGraph::Update
==============
*/
void ParticleModuleSizeGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v8; 
  float4 *float4Array; 
  const float *LifeArrayAtIndex; 
  bool v18; 
  __int64 v27; 
  __int64 useEmitterLife; 
  const ParticleCurveDef *useEmitterLifea; 
  float emitterLifea; 
  const ParticleCurveDef *emitterLife; 

  v8 = particleCount;
  _RBX = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _RBP = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v8 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(useEmitterLife) = v8 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", useEmitterLife, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (_RBX->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2053, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  float4Array = Particle_GetSizeArrayAtIndex(pParticleData, particleOffset);
  _RSI = float4Array;
  if ( (_RBX->m_flags & 0x1000) != 0 )
  {
    __asm { vmovaps [rsp+0B8h+var_58], xmm6 }
    LifeArrayAtIndex = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
    _RDI = LifeArrayAtIndex;
    __asm { vmovss  xmm6, dword ptr [rbp+178h] }
    v18 = (_RBX->m_flags & 4) != 0;
    if ( LOBYTE(_RBX[1].m_type) )
    {
      if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 386, ASSERT_TYPE_ASSERT, "(outputArray)", (const char *)&queryFormat, "outputArray") )
        __debugbreak();
      if ( !(_DWORD)v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 387, ASSERT_TYPE_ASSERT, "(numParticles > 0)", (const char *)&queryFormat, "numParticles > 0") )
        __debugbreak();
      if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 388, ASSERT_TYPE_ASSERT, "(lifeArray)", (const char *)&queryFormat, "lifeArray") )
        __debugbreak();
      __asm { vmovups xmm0, xmmword ptr [rbx+80h] }
      if ( v18 )
      {
        __asm
        {
          vsubps  xmm1, xmm0, xmmword ptr [rbx+70h]
          vmovaps xmm0, xmm6
          vshufps xmm0, xmm0, xmm0, 0
          vmulps  xmm0, xmm1, xmm0
          vaddps  xmm3, xmm0, xmmword ptr [rbx+70h]
        }
        if ( (_DWORD)v8 )
        {
          __asm { vmovups xmmword ptr [rsi], xmm3 }
          qmemcpy(&_RSI[1], _RSI, 8 * ((unsigned __int64)(16 * v8 - 9) >> 3));
        }
      }
      else
      {
        __asm { vsubps  xmm2, xmm0, xmmword ptr [rbx+70h] }
        if ( (_DWORD)v8 )
        {
          v27 = v8;
          do
          {
            ++_RSI;
            __asm { vbroadcastss xmm0, dword ptr [rdi] }
            ++_RDI;
            __asm
            {
              vmulps  xmm0, xmm0, xmm2
              vaddps  xmm1, xmm0, xmmword ptr [rbx+70h]
              vmovups xmmword ptr [rsi-10h], xmm1
            }
            --v27;
          }
          while ( v27 );
        }
      }
    }
    else
    {
      __asm { vmovss  [rsp+0B8h+emitterLife], xmm6 }
      ParticleModuleGraph_LerpFloat4Array_1_((const float4 *)&_RBX[14], (const float4 *)&_RBX[16], _RSI, v8, LifeArrayAtIndex, v18, emitterLifea);
    }
    __asm { vmovaps xmm6, [rsp+0B8h+var_58] }
  }
  else
  {
    emitterLife = (const ParticleCurveDef *)&_RBX[8];
    useEmitterLifea = (const ParticleCurveDef *)&_RBX[2];
    if ( LOBYTE(_RBX[1].m_type) )
      ParticleModuleGraph_UpdateFloat4Array_0_(_RBX, pParticleData, particleOffset, v8, pEmitterOwner, useEmitterLifea, emitterLife, FXRAND_SIZE_0, FXRAND_SIZE_1, FXRAND_SIZE_2, float4Array);
    else
      ParticleModuleGraph_UpdateFloat4Array_1_(_RBX, pParticleData, particleOffset, v8, pEmitterOwner, useEmitterLifea, emitterLife, FXRAND_SIZE_0, FXRAND_SIZE_1, FXRAND_SIZE_2, float4Array);
  }
}

/*
==============
ParticleModuleSizeLerp::Update
==============
*/
void ParticleModuleSizeLerp::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v8; 
  __int64 v22; 
  __int64 v27; 

  v8 = particleCount;
  _RDI = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  _R14 = pEmitterOwner;
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v8 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v27) = v8 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v27, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (_RDI->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2085, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  _RAX = Particle_GetSizeArrayAtIndex(pParticleData, particleOffset);
  _RSI = _RAX;
  __asm { vmovups xmm0, xmmword ptr [rdi+20h] }
  if ( (_RDI->m_flags & 4) != 0 )
  {
    __asm
    {
      vsubps  xmm1, xmm0, xmmword ptr [rdi+10h]
      vbroadcastss xmm0, dword ptr [r14+178h]
      vmulps  xmm0, xmm1, xmm0
      vaddps  xmm3, xmm0, xmmword ptr [rdi+10h]
    }
    if ( (_DWORD)v8 )
    {
      __asm { vmovups xmmword ptr [rax], xmm3 }
      qmemcpy(&_RAX[1], _RAX, 8 * ((unsigned __int64)(16 * v8 - 9) >> 3));
    }
  }
  else
  {
    __asm
    {
      vmovaps [rsp+88h+var_38], xmm6
      vsubps  xmm6, xmm0, xmmword ptr [rdi+10h]
    }
    _RAX = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
    if ( (_DWORD)v8 )
    {
      v22 = v8;
      do
      {
        ++_RSI;
        __asm { vbroadcastss xmm0, dword ptr [rax] }
        ++_RAX;
        __asm
        {
          vmulps  xmm0, xmm0, xmm6
          vaddps  xmm1, xmm0, xmmword ptr [rdi+10h]
          vmovups xmmword ptr [rsi-10h], xmm1
        }
        --v22;
      }
      while ( v22 );
    }
    __asm { vmovaps xmm6, [rsp+88h+var_38] }
  }
}

/*
==============
ParticleModuleTemperatureGraph::Update
==============
*/
void ParticleModuleTemperatureGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 

  v7 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleCount >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v7 + particleCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 1201, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 360, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v7 >= pParticleData->m_particleCountMax )
  {
    LODWORD(rCurve2) = pParticleData->m_particleCountMax;
    LODWORD(rCurve1) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 360, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 360, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_TEMPERATURE)[4 * v7];
  rCurve2a = (ParticleCurveDef *)&pModuleBase[4];
  rCurve1a = (ParticleCurveDef *)&pModuleBase[2];
  if ( LOBYTE(pModuleBase[1].m_type) )
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_TEMPERATURE, floatArray);
  else
    ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_TEMPERATURE, floatArray);
}

/*
==============
ParticleModuleVectorFieldGraph::Update
==============
*/
void ParticleModuleVectorFieldGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v7; 
  ParticleCurveDef *rCurve1; 
  ParticleCurveDef *rCurve1a; 
  ParticleCurveDef *rCurve2; 
  ParticleCurveDef *rCurve2a; 
  float *floatArray; 

  v7 = particleOffset;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v7 + particleCount >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(rCurve1) = v7 + particleCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", rCurve1, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (pModuleBase->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2294, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 366, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  if ( (unsigned int)v7 >= pParticleData->m_particleCountMax )
  {
    LODWORD(rCurve2) = pParticleData->m_particleCountMax;
    LODWORD(rCurve1) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 366, ASSERT_TYPE_ASSERT, "(unsigned)( particleIndex ) < (unsigned)( pParticleData->GetParticleCountMax() )", "particleIndex doesn't index pParticleData->GetParticleCountMax()\n\t%i not in [0, %i)", rCurve1, rCurve2) )
      __debugbreak();
  }
  if ( !pParticleData->m_pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particle.h", 366, ASSERT_TYPE_ASSERT, "(pParticleData->GetParticleData())", (const char *)&queryFormat, "pParticleData->GetParticleData()") )
    __debugbreak();
  floatArray = (float *)&ParticleData::GetParticleDataArray(pParticleData, PARTICLE_DATA_VECTOR_FIELD_SCALE)[4 * v7];
  rCurve2a = (ParticleCurveDef *)&pModuleBase[4];
  rCurve1a = (ParticleCurveDef *)&pModuleBase[2];
  if ( LOBYTE(pModuleBase[1].m_type) )
    ParticleModuleGraph_UpdateFloatArray_0_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_VECTOR_FIELD_SCALE, floatArray);
  else
    ParticleModuleGraph_UpdateFloatArray_1_(pModuleBase, pParticleData, v7, particleCount, pEmitterOwner, rCurve1a, rCurve2a, FXRAND_VECTOR_FIELD_SCALE, floatArray);
}

/*
==============
ParticleModuleVelocityGraph::Update
==============
*/
void ParticleModuleVelocityGraph::Update(const ParticleModule *pModuleBase, ParticleData *pParticleData, unsigned int particleOffset, unsigned int particleCount, const float __formal, const ParticleEmitter *pEmitterOwner, const ParticleState *pParticleState)
{
  __int64 v22; 
  unsigned int *FlagsArrayAtIndex; 
  const ParticleModuleInitRelativeVelocity *m_pModuleInitRelativeVelocity; 
  bool v28; 
  bool v29; 
  unsigned int m_flags; 
  bool v31; 
  signed __int64 v62; 
  signed __int64 v63; 
  bool v64; 
  __int64 v110; 
  bool v111; 
  bool v112; 
  bool v113; 
  unsigned int *v114; 
  signed __int64 v115; 
  __int128 v116; 
  bool v117; 
  int *RandomSeedArrayAtIndex; 
  signed __int64 v119; 
  bool v120; 
  bool v121; 
  bool v122; 

  __asm { vmovaps [rsp+168h+var_A8], xmm11 }
  _R12 = pEmitterOwner;
  v22 = particleCount;
  _RBX = pModuleBase;
  if ( !pModuleBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pModuleBase)", (const char *)&queryFormat, "pModuleBase") )
    __debugbreak();
  if ( !pParticleData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pParticleData)", (const char *)&queryFormat, "pParticleData") )
    __debugbreak();
  if ( !pEmitterOwner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pEmitterOwner)", (const char *)&queryFormat, "pEmitterOwner") )
    __debugbreak();
  if ( !pParticleState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pParticleState)", (const char *)&queryFormat, "pParticleState") )
    __debugbreak();
  if ( (unsigned int)v22 + particleOffset >= pParticleData->m_particleCountMax + 1 )
  {
    LODWORD(v110) = v22 + particleOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(unsigned)( particleOffset + particleCount ) < (unsigned)( pParticleData->GetParticleCountMax() + 1 )", "particleOffset + particleCount doesn't index pParticleData->GetParticleCountMax() + 1\n\t%i not in [0, %i)", v110, pParticleData->m_particleCountMax + 1) )
      __debugbreak();
  }
  if ( (_RBX->m_flags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2121, ASSERT_TYPE_ASSERT, "(pModule->IsEnabled())", (const char *)&queryFormat, "pModule->IsEnabled()") )
    __debugbreak();
  v120 = (_RBX->m_flags & 0x10) != 0;
  RandomSeedArrayAtIndex = Particle_GetRandomSeedArrayAtIndex(pParticleData, particleOffset);
  _RBP = Particle_GetVelocityArrayAtIndex(pParticleData, particleOffset);
  _RDI = Particle_GetLifeArrayAtIndex(pParticleData, particleOffset);
  FlagsArrayAtIndex = Particle_GetFlagsArrayAtIndex(pParticleData, particleOffset);
  m_pModuleInitRelativeVelocity = pParticleState->m_pModuleInitRelativeVelocity;
  v114 = FlagsArrayAtIndex;
  v117 = (pParticleState->m_pStateDef->flags & 0x200000) != 0;
  v28 = m_pModuleInitRelativeVelocity && (m_pModuleInitRelativeVelocity->m_flags & 1) == 0 && ((m_pModuleInitRelativeVelocity->m_velocityType - 3) & 0xFFFFFFFD) == 0;
  v112 = v28;
  v122 = (_RBX->m_flags & 0x80) != 0;
  v121 = (_RBX->m_flags & 0x400) != 0;
  v29 = (_RBX->m_flags & 0x80) != 0 && ((_RBX->m_flags & 0x400) != 0 || v28);
  v111 = (_RBX->m_flags & 0x400) != 0 || v28 && (_RBX->m_flags & 0x80) != 0;
  *(_QWORD *)&v116 = ParticleEmitter::GetEmitterTransform((ParticleEmitter *)pEmitterOwner, pParticleState);
  if ( v29 )
    *(_QWORD *)&v116 = ParticleEmitter::GetEmitterTransformTranspose((ParticleEmitter *)pEmitterOwner, pParticleState);
  m_flags = _RBX->m_flags;
  v31 = (m_flags & 0x1000) != 0;
  __asm { vmovaps [rsp+168h+var_C8], xmm13 }
  v113 = v31;
  __asm { vmovaps [rsp+168h+var_D8], xmm14 }
  if ( (m_flags & 0x1000) != 0 )
  {
    __asm { vmovups xmm0, xmmword ptr [rbx+80h] }
    if ( (m_flags & 4) == 0 )
    {
      __asm
      {
        vsubps  xmm14, xmm0, xmmword ptr [rbx+70h]
        vmovups xmm13, [rsp+168h+var_118]
      }
      goto LABEL_42;
    }
    __asm
    {
      vsubps  xmm1, xmm0, xmmword ptr [rbx+70h]
      vbroadcastss xmm0, dword ptr [r12+178h]
      vmulps  xmm0, xmm1, xmm0
      vaddps  xmm13, xmm0, xmmword ptr [rbx+70h]
    }
  }
  else
  {
    __asm { vmovups xmm13, [rsp+168h+var_118] }
  }
  __asm { vmovups xmm14, [rsp+168h+var_118] }
LABEL_42:
  __asm
  {
    vmovaps [rsp+168h+var_98], xmm10
    vxorps  xmm11, xmm11, xmm11
    vinsertps xmm11, xmm11, dword ptr [rbx+1Ch], 0
    vinsertps xmm11, xmm11, dword ptr [rbx+2Ch], 10h
    vinsertps xmm11, xmm11, dword ptr [rbx+3Ch], 20h ; ' '
  }
  if ( v120 )
  {
    __asm
    {
      vxorps  xmm10, xmm10, xmm10
      vinsertps xmm10, xmm10, dword ptr [rbx+4Ch], 0
      vinsertps xmm10, xmm10, dword ptr [rbx+5Ch], 10h
      vinsertps xmm10, xmm10, dword ptr [rbx+6Ch], 20h ; ' '
    }
  }
  else
  {
    __asm { vmovups xmm10, [rsp+168h+var_118] }
  }
  __asm
  {
    vmovaps [rsp+168h+var_58], xmm6
    vmovaps [rsp+168h+var_68], xmm7
    vmovaps [rsp+168h+var_78], xmm8
    vmovaps [rsp+168h+var_88], xmm9
    vmovaps [rsp+168h+var_B8], xmm12
  }
  if ( (m_flags & 4) != 0 )
  {
    __asm
    {
      vmovss  xmm8, dword ptr [r12+178h]
      vmovaps xmm1, xmm8; time
    }
    *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[6], *(const float *)&_XMM1);
    __asm
    {
      vmovaps xmm1, xmm8; time
      vmovaps xmm7, xmm0
    }
    *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[4], *(const float *)&_XMM1);
    __asm
    {
      vmovaps xmm1, xmm8; time
      vmovaps xmm6, xmm0
    }
    Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[2], *(const float *)&_XMM1);
    __asm
    {
      vxorps  xmm2, xmm2, xmm2
      vinsertps xmm2, xmm2, xmm0, 0
      vinsertps xmm2, xmm2, xmm6, 10h
      vinsertps xmm2, xmm2, xmm7, 20h ; ' '
      vmulps  xmm9, xmm11, xmm2
    }
    if ( v120 )
    {
      __asm { vmovaps xmm1, xmm8; time }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[12], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm8; time
        vmovaps xmm7, xmm0
      }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[10], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm8; time
        vmovaps xmm6, xmm0
      }
      Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[8], *(const float *)&_XMM1);
      v31 = v113;
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
        vmulps  xmm12, xmm10, xmm1
      }
      goto LABEL_51;
    }
    v31 = v113;
  }
  else
  {
    __asm { vmovups xmm9, [rsp+168h+var_118] }
  }
  __asm { vmovups xmm12, [rsp+168h+var_118] }
LABEL_51:
  if ( (_DWORD)v22 )
  {
    v62 = (char *)v114 - (char *)RandomSeedArrayAtIndex;
    v63 = (char *)RandomSeedArrayAtIndex - (char *)_RDI;
    v64 = v117;
    v119 = (char *)RandomSeedArrayAtIndex - (char *)_RDI;
    v115 = v62;
    while ( v64 && (*((_BYTE *)_RDI + v62 + v63) & 8) != 0 )
    {
LABEL_75:
      v63 = v119;
      v31 = v113;
      ++_RDI;
      ++_RBP;
      if ( !--v22 )
        goto LABEL_76;
    }
    if ( v31 )
    {
      if ( (_RBX->m_flags & 4) != 0 )
      {
        __asm { vmovdqa xmm6, xmm13 }
      }
      else
      {
        __asm
        {
          vbroadcastss xmm0, dword ptr [rdi]
          vmulps  xmm0, xmm0, xmm14
          vaddps  xmm6, xmm0, xmmword ptr [rbx+70h]
        }
      }
      goto LABEL_65;
    }
    if ( (_RBX->m_flags & 4) == 0 )
    {
      __asm
      {
        vmovss  xmm8, dword ptr [rdi]
        vmovaps xmm1, xmm8; time
      }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[6], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm8; time
        vmovaps xmm7, xmm0
      }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[4], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm8; time
        vmovaps xmm6, xmm0
      }
      Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[2], *(const float *)&_XMM1);
      __asm
      {
        vxorps  xmm2, xmm2, xmm2
        vinsertps xmm2, xmm2, xmm0, 0
        vinsertps xmm2, xmm2, xmm6, 10h
        vinsertps xmm2, xmm2, xmm7, 20h ; ' '
        vmulps  xmm9, xmm11, xmm2
      }
      if ( !v120 )
        goto LABEL_64;
      __asm { vmovaps xmm1, xmm8; time }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[12], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm8; time
        vmovaps xmm7, xmm0
      }
      *(double *)&_XMM0 = Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[10], *(const float *)&_XMM1);
      __asm
      {
        vmovaps xmm1, xmm8; time
        vmovaps xmm6, xmm0
      }
      Particle_GetCurveValue((const ParticleCurveDef *)&_RBX[8], *(const float *)&_XMM1);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, xmm0, 0
        vinsertps xmm1, xmm1, xmm6, 10h
        vinsertps xmm1, xmm1, xmm7, 20h ; ' '
        vmulps  xmm12, xmm10, xmm1
      }
    }
    if ( v120 )
    {
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vinsertps xmm1, xmm1, dword ptr [r9+rsi*4], 0
        vinsertps xmm1, xmm1, dword ptr [r9+rsi*4+4], 10h
        vinsertps xmm1, xmm1, dword ptr [r9+rsi*4+8], 20h ; ' '
        vsubps  xmm0, xmm12, xmm9
        vmulps  xmm1, xmm1, xmm0
        vaddps  xmm6, xmm1, xmm9
      }
LABEL_65:
      if ( v111 )
      {
        if ( v121 )
        {
          __asm
          {
            vshufps xmm2, xmm6, xmm6, 55h ; 'U'
            vshufps xmm1, xmm6, xmm6, 0AAh ; 'ª'
            vshufps xmm4, xmm6, xmm6, 0
            vmulps  xmm0, xmm2, xmmword ptr [rsi+10h]
            vmulps  xmm1, xmm1, xmmword ptr [rsi+20h]
            vaddps  xmm3, xmm0, xmm1
            vmulps  xmm0, xmm4, xmmword ptr [rsi]
            vaddps  xmm1, xmm0, xmm3
            vaddps  xmm2, xmm1, xmmword ptr [rbp+0]
            vmovups xmmword ptr [rbp+0], xmm2
          }
        }
        else
        {
          if ( (!v112 || !v122) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemoduleupdate.cpp", 2280, ASSERT_TYPE_ASSERT, "(hasBoltInfo && useWorldSpace)", (const char *)&queryFormat, "hasBoltInfo && useWorldSpace") )
            __debugbreak();
          __asm
          {
            vshufps xmm2, xmm6, xmm6, 0
            vshufps xmm4, xmm6, xmm6, 55h ; 'U'
            vshufps xmm5, xmm6, xmm6, 0AAh ; 'ª'
            vmulps  xmm0, xmm2, xmmword ptr [rsi]
            vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
            vmulps  xmm0, xmm4, xmmword ptr [rsi+10h]
            vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
            vmulps  xmm0, xmm5, xmmword ptr [rsi+20h]
            vaddps  xmm1, xmm0, xmm3
            vaddps  xmm1, xmm2, xmm1
            vmovups xmmword ptr [rbp+0], xmm1
            vandps  xmm0, xmm1, xmmword ptr cs:?g_keepXYZ@@3Ufloat4@@B.v; float4 const g_keepXYZ
            vmovups xmmword ptr [rbp+0], xmm0
          }
        }
      }
      else
      {
        __asm { vmovups xmmword ptr [rbp+0], xmm6 }
      }
      v64 = v117;
      v62 = v115;
      goto LABEL_75;
    }
LABEL_64:
    __asm { vmovdqa xmm6, xmm9 }
    goto LABEL_65;
  }
LABEL_76:
  __asm
  {
    vmovaps xmm14, [rsp+168h+var_D8]
    vmovaps xmm13, [rsp+168h+var_C8]
    vmovaps xmm12, [rsp+168h+var_B8]
    vmovaps xmm10, [rsp+168h+var_98]
    vmovaps xmm9, [rsp+168h+var_88]
    vmovaps xmm8, [rsp+168h+var_78]
    vmovaps xmm7, [rsp+168h+var_68]
    vmovaps xmm6, [rsp+168h+var_58]
    vmovaps xmm11, [rsp+168h+var_A8]
  }
}

