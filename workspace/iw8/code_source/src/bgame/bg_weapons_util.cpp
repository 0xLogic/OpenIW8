/*
==============
BG_AimAssistRange
==============
*/

void __fastcall BG_AimAssistRange(const Weapon *r_weapon, bool isAlternate, float *aimAssistRange, float *aimAssistRangeAds)
{
  ?BG_AimAssistRange@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, aimAssistRange, aimAssistRangeAds);
}

/*
==============
BG_PlayerWeaponGetEquippedSlot
==============
*/

WeaponSlot __fastcall BG_PlayerWeaponGetEquippedSlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_PlayerWeaponGetEquippedSlot@@YA?AW4WeaponSlot@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_SprintOutTime
==============
*/

int __fastcall BG_SprintOutTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintOutTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetCharacterModelRangeByType
==============
*/

bool __fastcall BG_GetCharacterModelRangeByType(DObj *obj, const CharacterModelType (*dobjModelTypes)[32], const CharacterModelType modelTypeSearched, const int startModelIndex, const int finishModelIndex, int *outFirst, int *outLast)
{
  return ?BG_GetCharacterModelRangeByType@@YA_NPEAUDObj@@AEAY0CA@$$CBW4CharacterModelType@@W42@HHPEAH3@Z(obj, dobjModelTypes, modelTypeSearched, startModelIndex, finishModelIndex, outFirst, outLast);
}

/*
==============
BG_ProjDudEffect
==============
*/

FxCombinedDef __fastcall BG_ProjDudEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjDudEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BlastLeftTime
==============
*/

int __fastcall BG_BlastLeftTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastLeftTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_PlayAltGesturesForOffhandWeapons
==============
*/

bool __fastcall BG_PlayAltGesturesForOffhandWeapons(const Weapon *r_weapon)
{
  return ?BG_PlayAltGesturesForOffhandWeapons@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SprintOutInterruptTime
==============
*/

int __fastcall BG_SprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintOutInterruptTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponLaserSettings
==============
*/

void __fastcall BG_GetWeaponLaserSettings(const Weapon *r_weapon, const bool isAlternate, LaserSettings *outLaserSettings)
{
  ?BG_GetWeaponLaserSettings@@YAXAEBUWeapon@@_NAEAULaserSettings@@@Z(r_weapon, isAlternate, outLaserSettings);
}

/*
==============
BG_SetWeaponDelay
==============
*/

void __fastcall BG_SetWeaponDelay(const BgWeaponMap *weaponMap, playerState_s *ps, const PlayerHandIndex hand, int weaponDelay, const char *const reason)
{
  ?BG_SetWeaponDelay@@YAXPEBVBgWeaponMap@@PEAUplayerState_s@@W4PlayerHandIndex@@HQEBD@Z(weaponMap, ps, hand, weaponDelay, reason);
}

/*
==============
BG_Weapon_GetCameraFireEffectDurationSec
==============
*/

double __fastcall BG_Weapon_GetCameraFireEffectDurationSec(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_Weapon_GetCameraFireEffectDurationSec@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSShouldShowCrosshair
==============
*/

bool __fastcall BG_ADSShouldShowCrosshair(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSShouldShowCrosshair@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ADSBobFactor
==============
*/

double __fastcall BG_ADSBobFactor(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSBobFactor@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetReticleType
==============
*/

ReticleType __fastcall BG_GetReticleType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetReticleType@@YA?AW4ReticleType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HideWarningIcons
==============
*/

bool __fastcall BG_HideWarningIcons(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HideWarningIcons@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponsUtil_RandomizeWeapon
==============
*/

void __fastcall BG_WeaponsUtil_RandomizeWeapon(Weapon *inOutWeapon, unsigned int *randSeed)
{
  ?BG_WeaponsUtil_RandomizeWeapon@@YAXAEAUWeapon@@PEAI@Z(inOutWeapon, randSeed);
}

/*
==============
BG_UseSmoothViewKick
==============
*/

bool __fastcall BG_UseSmoothViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseSmoothViewKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_TakePlayerWeapon
==============
*/

int __fastcall BG_TakePlayerWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const BgHandler *const handler, const Weapon *r_weapon, int gameTime)
{
  return ?BG_TakePlayerWeapon@@YAHPEAVBgWeaponMap@@PEAUplayerState_s@@QEBVBgHandler@@AEBUWeapon@@H@Z(weaponMap, ps, handler, r_weapon, gameTime);
}

/*
==============
BG_DoubleRiotShieldCheck
==============
*/

bool __fastcall BG_DoubleRiotShieldCheck(const BgWeaponMap *weaponMap, const Weapon *weaponToPickUp, const playerState_s *ps)
{
  return ?BG_DoubleRiotShieldCheck@@YA_NPEBVBgWeaponMap@@AEBUWeapon@@PEBUplayerState_s@@@Z(weaponMap, weaponToPickUp, ps);
}

/*
==============
BG_GetMeleeComboSeqCount
==============
*/

int __fastcall BG_GetMeleeComboSeqCount(const Weapon *r_weapon)
{
  return ?BG_GetMeleeComboSeqCount@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_RechamberWhileADS
==============
*/

bool __fastcall BG_RechamberWhileADS(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_RechamberWhileADS@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_MeleeImpactRumble
==============
*/

RumbleInfo *__fastcall BG_MeleeImpactRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_MeleeImpactRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponFieldTime
==============
*/

unsigned __int16 __fastcall BG_GetWeaponFieldTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset)
{
  return ?BG_GetWeaponFieldTime@@YAGPEBUplayerState_s@@AEBUWeapon@@_N2_J@Z(ps, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_LadderAimRaiseInterruptTime
==============
*/

int __fastcall BG_LadderAimRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimRaiseInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ReloadAddTime
==============
*/

int __fastcall BG_ReloadAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  return ?BG_ReloadAddTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2H2AEA_N@Z(ps, r_weapon, isAlternate, isDualWielding, ammoInClip, isSecondRound, hasFastReloadOverride);
}

/*
==============
BG_EmptyRaiseTime
==============
*/

int __fastcall BG_EmptyRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_EmptyRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHudOutlineOccludedOutlineColor
==============
*/

void __fastcall BG_GetHudOutlineOccludedOutlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineOccludedOutlineColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/

bool __fastcall TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  return ?GetTagNameAndBoneIndexForCharacter@TagPair@@QEBA_NPEBUDObj@@PEBUcharacterInfo_t@@QEBW4CharacterModelType@@HPEAW4scr_string_t@@PEAE@Z(this, obj, ci, modelTypesToSearch, modelTypeCount, outTagName, outBoneIndex);
}

/*
==============
BG_GetShelvedDamageForRange
==============
*/

int __fastcall BG_GetShelvedDamageForRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float range)
{
  return ?BG_GetShelvedDamageForRange@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_NMM@Z(damageCalcType, r_weapon, isAlternate, rangeScale, range);
}

/*
==============
BG_GetGameDefaultWeaponAnim
==============
*/

XAnimParts *__fastcall BG_GetGameDefaultWeaponAnim(int animIndex)
{
  return ?BG_GetGameDefaultWeaponAnim@@YAPEAUXAnimParts@@H@Z(animIndex);
}

/*
==============
BG_GetBallisticInfo
==============
*/

const BallisticInfo *__fastcall BG_GetBallisticInfo(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetBallisticInfo@@YAPEBUBallisticInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjExplosionReflectionClass
==============
*/

unsigned int __fastcall BG_ProjExplosionReflectionClass(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionReflectionClass@@YAIAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjTimeoutSound
==============
*/

const SndAliasList *__fastcall BG_ProjTimeoutSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTimeoutSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasUnderbarrelShotgun
==============
*/

int __fastcall BG_HasUnderbarrelShotgun(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelShotgun@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BGSpreadSetting::CalculateSpread
==============
*/

void __fastcall BGSpreadSetting::CalculateSpread(BGSpreadSetting *this, int shotIndex, float *spreadMinOut, float *spreadMaxOut, float *angleMinOut, float *angleMaxOut)
{
  ?CalculateSpread@BGSpreadSetting@@QEAAXHPEAM000@Z(this, shotIndex, spreadMinOut, spreadMaxOut, angleMinOut, angleMaxOut);
}

/*
==============
BG_FireRumble
==============
*/

RumbleInfo *__fastcall BG_FireRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_FireRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SetGlobalAmmoForAmmoType
==============
*/

void __fastcall BG_SetGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  ?BG_SetGlobalAmmoForAmmoType@@YAXPEAUplayerState_s@@AEBUAmmoStore@@H@Z(ps, r_ammoType, ammoCount);
}

/*
==============
BG_GetPenetrateType
==============
*/

PenetrateType __fastcall BG_GetPenetrateType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetPenetrateType@@YA?AW4PenetrateType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsPlayingVehicleOccupancyAnims
==============
*/

bool __fastcall BG_IsPlayingVehicleOccupancyAnims(const characterInfo_t *ci)
{
  return ?BG_IsPlayingVehicleOccupancyAnims@@YA_NPEBUcharacterInfo_t@@@Z(ci);
}

/*
==============
BG_PreFireSound
==============
*/

const SndAliasList *__fastcall BG_PreFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  return ?BG_PreFireSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayer);
}

/*
==============
BG_GetWeaponOffhandClass
==============
*/

OffhandClass __fastcall BG_GetWeaponOffhandClass(const Weapon *r_weapon)
{
  return ?BG_GetWeaponOffhandClass@@YA?AW4OffhandClass@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_IdleCrouchFactor
==============
*/

double __fastcall BG_IdleCrouchFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_IdleCrouchFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ProjTimeoutEffect
==============
*/

FxCombinedDef __fastcall BG_ProjTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTimeoutEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsEnergyBullet
==============
*/

bool __fastcall BG_IsEnergyBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsEnergyBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ApplyWeaponAnglesToShootingDirection
==============
*/

void __fastcall BG_ApplyWeaponAnglesToShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t *angles, const vec3_t (*anglesCategorized)[30], const vec3_t *oldAngles, vec3_t *outNewAngles, vec3_t *outShootingAnglesLocal)
{
  ?BG_ApplyWeaponAnglesToShootingDirection@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEBTvec3_t@@AEAY0BO@$$CBT4@4AEAT4@6@Z(weaponMap, ps, r_weapon, isAlternate, angles, anglesCategorized, oldAngles, outNewAngles, outShootingAnglesLocal);
}

/*
==============
BG_WeaponCharge_GetChargeMaxSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeMaxSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeMaxSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_RaiseTime
==============
*/

int __fastcall BG_RaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ProjWhizByEnabled
==============
*/

bool __fastcall BG_ProjWhizByEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjWhizByEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TimedDetonation
==============
*/

bool __fastcall BG_TimedDetonation(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TimedDetonation@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_RechamberTimeOneHanded
==============
*/

int __fastcall BG_RechamberTimeOneHanded(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RechamberTimeOneHanded@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AddParachuteModelToCorpse
==============
*/

int __fastcall BG_AddParachuteModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddParachuteModelToCorpse@@YAHHPEBUcorpseReferenceCharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetMountEnterExitDuration
==============
*/

void __fastcall BG_GetMountEnterExitDuration(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, int *outEnterDurationMs, int *outExitDurationMs)
{
  ?BG_GetMountEnterExitDuration@@YAXW4ContextMountType@@AEBUWeapon@@_NPEAH3@Z(mountType, r_weapon, isAlternate, outEnterDurationMs, outExitDurationMs);
}

/*
==============
BG_IsBallWeapon
==============
*/

bool __fastcall BG_IsBallWeapon(const Weapon *r_weapon)
{
  return ?BG_IsBallWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SuperSprintOutInterruptTime
==============
*/

int __fastcall BG_SuperSprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SuperSprintOutInterruptTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponSticksToPlayers
==============
*/

bool __fastcall BG_WeaponSticksToPlayers(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToPlayers@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Interpolated
==============
*/

void __fastcall BG_BuildExplosionDamageRangeInfo_Interpolated(const float innerDamage, const float outerDamage, const float damageRadius, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  ?BG_BuildExplosionDamageRangeInfo_Interpolated@@YAXMMMAEAUBgExplosionDamageRangeInfo@@@Z(innerDamage, outerDamage, damageRadius, outDamageRangeInfo);
}

/*
==============
BG_GetMountGunIdleScale
==============
*/

double __fastcall BG_GetMountGunIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountGunIdleScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ReloadStartAddTime
==============
*/

int __fastcall BG_ReloadStartAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  return ?BG_ReloadStartAddTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2H2AEA_N@Z(ps, r_weapon, isAlternate, isDualWielding, ammoInClip, isSecondRound, hasFastReloadOverride);
}

/*
==============
BG_ExplosionUsesSteppedDamage
==============
*/

bool __fastcall BG_ExplosionUsesSteppedDamage(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ExplosionUsesSteppedDamage@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WalkLoopTime
==============
*/

int __fastcall BG_WalkLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_WalkLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MoveCycleJogTime
==============
*/

int __fastcall BG_MoveCycleJogTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleJogTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponMeleeAnimProperties
==============
*/

int __fastcall BG_GetWeaponMeleeAnimProperties(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool isUsingAlternateMelee, bool *outIsRandomized, MeleeAnimType *outAnimType, unsigned __int8 *outAnimSets)
{
  return ?BG_GetWeaponMeleeAnimProperties@@YAHPEBUplayerState_s@@AEBUWeapon@@_N22PEA_NPEAW4MeleeAnimType@@PEAE@Z(ps, r_weapon, isAlternate, isDualWielding, isUsingAlternateMelee, outIsRandomized, outAnimType, outAnimSets);
}

/*
==============
BG_BlastFrontTime
==============
*/

int __fastcall BG_BlastFrontTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastFrontTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponCharge_GetFireAtMaxDamageMultiplier
==============
*/

double __fastcall BG_WeaponCharge_GetFireAtMaxDamageMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetFireAtMaxDamageMultiplier@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetWeaponAttachmentsUsingHighStockPriority
==============
*/

unsigned int __fastcall BG_GetWeaponAttachmentsUsingHighStockPriority(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  return ?BG_GetWeaponAttachmentsUsingHighStockPriority@@YAIAEBUWeapon@@_NQEAPEBUWeaponAttachment@@@Z(r_weapon, isAlternate, attachments);
}

/*
==============
BG_TurretWeaponUses3pIK
==============
*/

bool __fastcall BG_TurretWeaponUses3pIK(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretWeaponUses3pIK@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadEmptyTime
==============
*/

int __fastcall BG_ReloadEmptyTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEmptyTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4AEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, hasFastReloadOverride);
}

/*
==============
BG_WeaponBulletFire_GetExplRadius
==============
*/

double __fastcall BG_WeaponBulletFire_GetExplRadius(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponBulletFire_GetExplRadius@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_LeapOutTime
==============
*/

int __fastcall BG_LeapOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LeapOutTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponCanAutoReload
==============
*/

bool __fastcall BG_WeaponCanAutoReload(const playerState_s *ps, const Weapon *currentWeapon, bool isAlternate)
{
  return ?BG_WeaponCanAutoReload@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, currentWeapon, isAlternate);
}

/*
==============
BG_ScaleKickValue
==============
*/

void __fastcall BG_ScaleKickValue(float *kickPitch, float *kickYaw, const float kickMagMin)
{
  ?BG_ScaleKickValue@@YAXPEAM0M@Z(kickPitch, kickYaw, kickMagMin);
}

/*
==============
BG_SkydiveSuperDiveOutTime
==============
*/

int __fastcall BG_SkydiveSuperDiveOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveSuperDiveOutTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetMinMaxDamage
==============
*/

void __fastcall BG_GetMinMaxDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMinDamage, int *outMaxDamage)
{
  ?BG_GetMinMaxDamage@@YAXW4WeaponDamageCalcType@@AEBUWeapon@@_NAEAH3@Z(damageCalcType, r_weapon, isAlternate, outMinDamage, outMaxDamage);
}

/*
==============
BG_AltDropAkimboTime
==============
*/

int __fastcall BG_AltDropAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltDropAkimboTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/

weapClass_t __fastcall BG_GetWeaponClassForAnimCondition(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponClassForAnimCondition@@YA?AW4weapClass_t@@PEBUentityState_t@@AEBUWeapon@@_N@Z(es, r_weapon, isAlternate);
}

/*
==============
BG_ExplosionForceRadius
==============
*/

int __fastcall BG_ExplosionForceRadius(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ExplosionForceRadius@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSAccel
==============
*/

void __fastcall BG_GetADSAccel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsOutToInAccelSec, float *outAdsInToOutAccelSec)
{
  ?BG_GetADSAccel@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4@Z(weaponMap, ps, r_weapon, isAlternate, outAdsOutToInAccelSec, outAdsInToOutAccelSec);
}

/*
==============
BG_GetWeaponInspectTime
==============
*/

int __fastcall BG_GetWeaponInspectTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_GetWeaponInspectTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetMountFOVScale
==============
*/

double __fastcall BG_GetMountFOVScale(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountFOVScale@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetHeatSmokeProperties
==============
*/

void __fastcall BG_GetHeatSmokeProperties(const Weapon *weapon, const bool isAlternate, float *outSmokeStartThreshold, float *outSmokeStopThreshold)
{
  ?BG_GetHeatSmokeProperties@@YAXAEBUWeapon@@_NAEAM2@Z(weapon, isAlternate, outSmokeStartThreshold, outSmokeStopThreshold);
}

/*
==============
BG_PlayerOffhandGetSlotName
==============
*/

scr_string_t __fastcall BG_PlayerOffhandGetSlotName(const OffhandSlot slot)
{
  return ?BG_PlayerOffhandGetSlotName@@YA?AW4scr_string_t@@W4OffhandSlot@@@Z(slot);
}

/*
==============
BG_DPadIcon
==============
*/

Material *__fastcall BG_DPadIcon(const Weapon *r_weapon, bool isAlternate, bool isActive)
{
  return ?BG_DPadIcon@@YAPEAUMaterial@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isActive);
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObjByModelRange
==============
*/

void __fastcall BG_UpdateWeaponHidePartBitsForDObjByModelRange(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel, int lastModelInclusive)
{
  ?BG_UpdateWeaponHidePartBitsForDObjByModelRange@@YAXPEAUDObj@@AEBUWeapon@@_NHH@Z(obj, r_weapon, isViewModel, startModel, lastModelInclusive);
}

/*
==============
BGSpreadSetting::Init
==============
*/

void __fastcall BGSpreadSetting::Init(BGSpreadSetting *this, float angleStart, int shotCount, float initSpreadMin, float initSpreadMax)
{
  ?Init@BGSpreadSetting@@QEAAXMHMM@Z(this, angleStart, shotCount, initSpreadMin, initSpreadMax);
}

/*
==============
BG_IsSilenced
==============
*/

bool __fastcall BG_IsSilenced(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsSilenced@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSDamageRangeScale
==============
*/

double __fastcall BG_GetADSDamageRangeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSDamageRangeScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetAdvancedIdleSettings
==============
*/

void __fastcall BG_GetAdvancedIdleSettings(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, AdvancedIdleSettings *outAdvancedIdleSettings)
{
  ?BG_GetAdvancedIdleSettings@@YAXV?$bitarray@$0EA@@@AEBUWeapon@@_NPEAUAdvancedIdleSettings@@@Z(perks, r_weapon, isAlternate, outAdvancedIdleSettings);
}

/*
==============
BG_ProjIgnitionSound
==============
*/

const SndAliasList *__fastcall BG_ProjIgnitionSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjIgnitionSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ShouldSpread
==============
*/

bool __fastcall BG_WeaponBulletFire_ShouldSpread(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ShouldSpread@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_MultipleReloadInterruptTime
==============
*/

int __fastcall BG_MultipleReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t animIndex)
{
  return ?BG_MultipleReloadInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4W4weapAnimFiles_t@@@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, animIndex);
}

/*
==============
BG_GetAdsFireAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsFireAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsFireAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_IsPredictedProjectileWeapon
==============
*/

bool __fastcall BG_IsPredictedProjectileWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsPredictedProjectileWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponFireRecoil
==============
*/

void __fastcall BG_WeaponFireRecoil(const BgWeaponMap *weaponMap, const playerState_s *ps, PlayerHandIndex hand, const float pitchMove, const float yawMove, const vec2_t *gunKickAngles, const vec2_t *viewKickAngles, vec2_t *outGunKickAVel, bool *outGunNeedsToCrossCenter, vec3_t *outViewKickAVel, bool *outViewNeedsToCrossCenter)
{
  ?BG_WeaponFireRecoil@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@W4PlayerHandIndex@@MMAEBTvec2_t@@3AEAT4@AEA_NAEATvec3_t@@5@Z(weaponMap, ps, hand, pitchMove, yawMove, gunKickAngles, viewKickAngles, outGunKickAVel, outGunNeedsToCrossCenter, outViewKickAVel, outViewNeedsToCrossCenter);
}

/*
==============
BG_CalculateEaseMotionFactor
==============
*/

double __fastcall BG_CalculateEaseMotionFactor(const float weaponPosFrac, AdsOffsetInterpolationType lerpType)
{
  double result; 

  *(float *)&result = ?BG_CalculateEaseMotionFactor@@YAMMW4AdsOffsetInterpolationType@@@Z(weaponPosFrac, lerpType);
  return result;
}

/*
==============
BG_SmoothFadeSniperScene
==============
*/

void __fastcall BG_SmoothFadeSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, float adsFrac)
{
  ?BG_SmoothFadeSniperScene@@YAXAEBUWeapon@@_NPEAUDObj@@M@Z(r_weapon, isAlternate, obj, adsFrac);
}

/*
==============
BG_GetGrenadeDangerIconDistance
==============
*/

double __fastcall BG_GetGrenadeDangerIconDistance(const Weapon *r_weapon, bool isAlternate, const float defaultValue)
{
  double result; 

  *(float *)&result = ?BG_GetGrenadeDangerIconDistance@@YAMAEBUWeapon@@_NM@Z(r_weapon, isAlternate, defaultValue);
  return result;
}

/*
==============
BG_MoveCycleSuperSprintTime
==============
*/

int __fastcall BG_MoveCycleSuperSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleSuperSprintTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AddIgnoreEntToBP
==============
*/

void __fastcall BG_AddIgnoreEntToBP(BulletFireParams *bp, int entityIndex)
{
  ?BG_AddIgnoreEntToBP@@YAXPEAUBulletFireParams@@H@Z(bp, entityIndex);
}

/*
==============
BG_IsUsingWorldIKTargets
==============
*/

bool __fastcall BG_IsUsingWorldIKTargets(const characterInfo_t *ci)
{
  return ?BG_IsUsingWorldIKTargets@@YA_NPEBUcharacterInfo_t@@@Z(ci);
}

/*
==============
BgWeaponScalarAccumulator::ApplyAdditiveScale
==============
*/

void __fastcall BgWeaponScalarAccumulator::ApplyAdditiveScale(BgWeaponScalarAccumulator *this, const float scale)
{
  ?ApplyAdditiveScale@BgWeaponScalarAccumulator@@QEAAXM@Z(this, scale);
}

/*
==============
BG_LadderAimRaiseTime
==============
*/

int __fastcall BG_LadderAimRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_DangerIcon
==============
*/

Material *__fastcall BG_DangerIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DangerIcon@@YAPEAUMaterial@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsHighPrecisionClientFireEventEnabled
==============
*/

bool __fastcall BG_IsHighPrecisionClientFireEventEnabled(const int eventId, const entityState_t *es)
{
  return ?BG_IsHighPrecisionClientFireEventEnabled@@YA_NHPEBUentityState_t@@@Z(eventId, es);
}

/*
==============
BG_HasDualFOV
==============
*/

bool __fastcall BG_HasDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasDualFOV@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponSfxPackageSound
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSfxPackageSound(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  return ?BG_GetWeaponSfxPackageSound@@YAPEBUSndAliasList@@PEBUWeaponSFXPackage@@_J@Z(sfxPackage, offset);
}

/*
==============
BG_GetWeaponPrimaryAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetWeaponPrimaryAttachment(const Weapon *r_weapon, const AttachmentSlot attachment)
{
  return ?BG_GetWeaponPrimaryAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@W4AttachmentSlot@@@Z(r_weapon, attachment);
}

/*
==============
BG_ADSFireAnimFrac
==============
*/

double __fastcall BG_ADSFireAnimFrac(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSFireAnimFrac@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSMovementAnimBlendFrac
==============
*/

void __fastcall BG_ADSMovementAnimBlendFrac(const Weapon *r_weapon, bool isAlternate, float *outStartFrac, float *outEndFrac)
{
  ?BG_ADSMovementAnimBlendFrac@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, outStartFrac, outEndFrac);
}

/*
==============
BG_ShowBoneByModelRange
==============
*/

unsigned __int8 __fastcall BG_ShowBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  return ?BG_ShowBoneByModelRange@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@HH@Z(bone, obj, partBits, startModel, lastModelInclusive);
}

/*
==============
BG_GetOffhandOverCookIsNotLethal
==============
*/

bool __fastcall BG_GetOffhandOverCookIsNotLethal(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOffhandOverCookIsNotLethal@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PlayerWeaponIsSlotFull
==============
*/

bool __fastcall BG_PlayerWeaponIsSlotFull(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  return ?BG_PlayerWeaponIsSlotFull@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@W4WeaponSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_WeaponResetADSReloadFraction
==============
*/

void __fastcall BG_WeaponResetADSReloadFraction(playerState_s *ps)
{
  ?BG_WeaponResetADSReloadFraction@@YAXPEAUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetBulletTerminationRange
==============
*/

double __fastcall BG_GetBulletTerminationRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetBulletTerminationRange@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponCharge_GetChargeUpToDownSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeUpToDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeUpToDownSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_LadderAimADSRaiseInterruptTime
==============
*/

int __fastcall BG_LadderAimADSRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimADSRaiseInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetFirstEquippedOffhandByClass
==============
*/

const Weapon *__fastcall BG_GetFirstEquippedOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return ?BG_GetFirstEquippedOffhandByClass@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@H@Z(weaponMap, ps, offhandClass);
}

/*
==============
BG_IsMeleeComboWeapon
==============
*/

bool __fastcall BG_IsMeleeComboWeapon(const Weapon *r_weapon)
{
  return ?BG_IsMeleeComboWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_ReloadDisabled
==============
*/

bool __fastcall BG_ReloadDisabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ReloadDisabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetFootstepFromAnim
==============
*/

FootstepAnimType __fastcall BG_GetFootstepFromAnim(weapAnimFiles_t animIndex)
{
  return ?BG_GetFootstepFromAnim@@YA?AW4FootstepAnimType@@W4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_ReloadMultipleTimePercentageBased
==============
*/

int __fastcall BG_ReloadMultipleTimePercentageBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  return ?BG_ReloadMultipleTimePercentageBased@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_NAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, hasFastReloadOverride);
}

/*
==============
BG_GetMeleeAutoAimMaxPitchMovement
==============
*/

double __fastcall BG_GetMeleeAutoAimMaxPitchMovement(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimMaxPitchMovement@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HasVRLegendaryScope
==============
*/

bool __fastcall BG_HasVRLegendaryScope(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_HasVRLegendaryScope@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_InitPlayerWeapons
==============
*/

void __fastcall BG_InitPlayerWeapons(playerState_s *ps)
{
  ?BG_InitPlayerWeapons@@YAXPEAUplayerState_s@@@Z(ps);
}

/*
==============
TagPair::IsEmpty
==============
*/

bool __fastcall TagPair::IsEmpty(TagPair *this)
{
  return ?IsEmpty@TagPair@@QEBA_NXZ(this);
}

/*
==============
BG_WeaponCharge_GetMeterBoneCount
==============
*/

unsigned int __fastcall BG_WeaponCharge_GetMeterBoneCount(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetMeterBoneCount@@YAIAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponAnglesForShootingDirection
==============
*/

void __fastcall BG_GetWeaponAnglesForShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t (*anglesCategorized)[30], vec3_t *outAngles)
{
  ?BG_GetWeaponAnglesForShootingDirection@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEAY0BO@$$CBTvec3_t@@AEAT4@@Z(weaponMap, ps, r_weapon, isAlternate, anglesCategorized, outAngles);
}

/*
==============
BG_DisableProjectileCrumpleCheck
==============
*/

bool __fastcall BG_DisableProjectileCrumpleCheck(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DisableProjectileCrumpleCheck@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountViewmodelOffset
==============
*/

double __fastcall BG_GetMountViewmodelOffset(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewmodelOffset@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_EndingGunKickPercent
==============
*/

double __fastcall BG_EndingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_EndingGunKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_ExplosionReactiveEmitterDelay
==============
*/

double __fastcall BG_ExplosionReactiveEmitterDelay(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ExplosionReactiveEmitterDelay@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponCharge_GetEmptyCooldown
==============
*/

double __fastcall BG_WeaponCharge_GetEmptyCooldown(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetEmptyCooldown@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetFirstEquippedWeaponBySlot
==============
*/

const Weapon *__fastcall BG_GetFirstEquippedWeaponBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  return ?BG_GetFirstEquippedWeaponBySlot@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@W4WeaponSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_GetFireTime
==============
*/

void __fastcall BG_GetFireTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  ?BG_GetFireTime@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3HPEAH4@Z(weaponMap, ps, r_weapon, isAlternate, isDualWielding, shotCount, fireTime, fireDelay);
}

/*
==============
BG_GetMeleeDamage
==============
*/

int __fastcall BG_GetMeleeDamage(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMeleeDamage@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetHudOutlineScriptControlled
==============
*/

bool __fastcall BG_GetHudOutlineScriptControlled(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineScriptControlled@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_PlayerUsesNVGHalfADS
==============
*/

bool __fastcall BG_PlayerUsesNVGHalfADS(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_PlayerUsesNVGHalfADS@@YA_NPEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_UsingSniperScope
==============
*/

int __fastcall BG_UsingSniperScope(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_UsingSniperScope@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_GetOtherAdsUpAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetOtherAdsUpAnim(const weapAnimFiles_t adsAnim)
{
  return ?BG_GetOtherAdsUpAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(adsAnim);
}

/*
==============
BG_IsBallPassValid
==============
*/

bool __fastcall BG_IsBallPassValid(const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsBallPassValid@@YA_NPEBUplayerState_s@@AEBUWeapon@@@Z(ps, r_weapon);
}

/*
==============
BG_GetFireTimerLerpToADSScale
==============
*/

double __fastcall BG_GetFireTimerLerpToADSScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetFireTimerLerpToADSScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsLadderWeapon
==============
*/

bool __fastcall BG_IsLadderWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsLadderWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsAnimInWeaponPackages
==============
*/

bool __fastcall BG_IsAnimInWeaponPackages(const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const int meleeComboSeqIdx, const weapAnimFiles_t animType)
{
  return ?BG_IsAnimInWeaponPackages@@YA_NAEBUWeapon@@_N1HW4weapAnimFiles_t@@@Z(r_weapon, isAlternate, isDualWielding, meleeComboSeqIdx, animType);
}

/*
==============
BG_ValidateWeaponNumber
==============
*/

bool __fastcall BG_ValidateWeaponNumber(const Weapon *r_weapon)
{
  return ?BG_ValidateWeaponNumber@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetSprintAdditiveAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetSprintAdditiveAnim(weapAnimFiles_t relativeAnim)
{
  return ?BG_GetSprintAdditiveAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(relativeAnim);
}

/*
==============
BG_GetMeleeHeight
==============
*/

double __fastcall BG_GetMeleeHeight(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeHeight@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsBeamStyleTracer
==============
*/

bool __fastcall BG_IsBeamStyleTracer(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsBeamStyleTracer@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseLeftTriggerAltFireMode
==============
*/

bool __fastcall BG_UseLeftTriggerAltFireMode(const Weapon *r_weapon)
{
  return ?BG_UseLeftTriggerAltFireMode@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_ViewShellEjectEffect
==============
*/

FxCombinedDef __fastcall BG_ViewShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ViewShellEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateLastWeaponHand
==============
*/

void __fastcall BG_UpdateLastWeaponHand(const BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *weapon)
{
  ?BG_UpdateLastWeaponHand@@YAXPEBVBgWeaponMap@@PEAUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, weapon);
}

/*
==============
BG_GetADSGunBobSettings
==============
*/

void __fastcall BG_GetADSGunBobSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *adsGunBobPitchScale, float *adsGunBobYawScale, float *adsGunBobTiltPitchScale, float *adsGunBobTiltYawScale, float *adsGunBobTiltRollScale, float *adsGunBobTiltOffset)
{
  ?BG_GetADSGunBobSettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM44444@Z(weaponMap, ps, r_weapon, isAlternate, adsGunBobPitchScale, adsGunBobYawScale, adsGunBobTiltPitchScale, adsGunBobTiltYawScale, adsGunBobTiltRollScale, adsGunBobTiltOffset);
}

/*
==============
BG_HasThermalScope
==============
*/

bool __fastcall BG_HasThermalScope(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasThermalScope@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_WeaponHasStreamedModelsErrorCheck
==============
*/

bool __fastcall BG_WeaponHasStreamedModelsErrorCheck(const Weapon *weapon)
{
  return ?BG_WeaponHasStreamedModelsErrorCheck@@YA_NAEBUWeapon@@@Z(weapon);
}

/*
==============
BG_InitClientWeapons
==============
*/

void __fastcall BG_InitClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  ?BG_InitClientWeapons@@YAXPEAVBgWeaponMap@@PEAUclientState_t@@@Z(weaponMap, cs);
}

/*
==============
BG_EquipWeapon
==============
*/

bool __fastcall BG_EquipWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_EquipWeapon@@YA_NPEAVBgWeaponMap@@PEAUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_ADSReloadFovXOffset
==============
*/

double __fastcall BG_ADSReloadFovXOffset(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSReloadFovXOffset@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(handler, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::SetPrimaryTagName
==============
*/

void __fastcall TagPair::SetPrimaryTagName(TagPair *this, scr_string_t tagName)
{
  ?SetPrimaryTagName@TagPair@@QEAAXW4scr_string_t@@@Z(this, tagName);
}

/*
==============
BG_BoltActionReloadIncludesRechamber
==============
*/

bool __fastcall BG_BoltActionReloadIncludesRechamber(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_BoltActionReloadIncludesRechamber@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjBodyEffect
==============
*/

FxCombinedDef __fastcall BG_ProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjBodyEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetChargeUpSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeUpSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_WeapHasDetonator
==============
*/

bool __fastcall BG_WeapHasDetonator(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeapHasDetonator@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_StunnedTimeEnd
==============
*/

int __fastcall BG_StunnedTimeEnd(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_StunnedTimeEnd@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_UpdatedWeaponBonesByModelRange
==============
*/

void __fastcall BG_UpdatedWeaponBonesByModelRange(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  ?BG_UpdatedWeaponBonesByModelRange@@YAXAEBUWeapon@@PEAUDObj@@HH@Z(r_weapon, obj, startModel, lastModelInclusive);
}

/*
==============
BG_GetMidDamage
==============
*/

void __fastcall BG_GetMidDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMid1Damage, int *outMid2Damage, int *outMid3Damage)
{
  ?BG_GetMidDamage@@YAXW4WeaponDamageCalcType@@AEBUWeapon@@_NAEAH33@Z(damageCalcType, r_weapon, isAlternate, outMid1Damage, outMid2Damage, outMid3Damage);
}

/*
==============
BG_AltOverride3POutTime
==============
*/

int __fastcall BG_AltOverride3POutTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltOverride3POutTime@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_IsLastShotWeaponEvent
==============
*/

bool __fastcall BG_IsLastShotWeaponEvent(int event)
{
  return ?BG_IsLastShotWeaponEvent@@YA_NH@Z(event);
}

/*
==============
BG_IsMeleeOnlyWeapon
==============
*/

bool __fastcall BG_IsMeleeOnlyWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsMeleeOnlyWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponSfxPackageSoundLookup
==============
*/

SndAliasLookup __fastcall BG_GetWeaponSfxPackageSoundLookup(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  return ?BG_GetWeaponSfxPackageSoundLookup@@YA?AUSndAliasLookup@@PEBUWeaponSFXPackage@@_J@Z(sfxPackage, offset);
}

/*
==============
BG_GetMeleeAutoAimMaxYawMovement
==============
*/

double __fastcall BG_GetMeleeAutoAimMaxYawMovement(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimMaxYawMovement@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AltDropADSTime
==============
*/

int __fastcall BG_AltDropADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltDropADSTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetFirstAvailableOffhandByClass
==============
*/

const Weapon *__fastcall BG_GetFirstAvailableOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return ?BG_GetFirstAvailableOffhandByClass@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@H@Z(weaponMap, ps, offhandClass);
}

/*
==============
BG_GetMeleeRange
==============
*/

double __fastcall BG_GetMeleeRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const bool getChargeRange)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeRange@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@_N@Z(weaponMap, ps, getChargeRange);
  return result;
}

/*
==============
BG_ScopeOutlinesVehicles
==============
*/

bool __fastcall BG_ScopeOutlinesVehicles(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesVehicles@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_EndingViewKickPercent
==============
*/

double __fastcall BG_EndingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_EndingViewKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_ScopeToggleOnTime
==============
*/

int __fastcall BG_ScopeToggleOnTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOnTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_HasUnderbarrelWeapon
==============
*/

int __fastcall BG_HasUnderbarrelWeapon(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelWeapon@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetWeaponSoundWithFallback
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSoundWithFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSoundWithFallback@@YAPEBUSndAliasList@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_AddParachuteModel
==============
*/

int __fastcall BG_AddParachuteModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddParachuteModel@@YAHPEBUcharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetMeleeAutoAimLerp
==============
*/

double __fastcall BG_GetMeleeAutoAimLerp(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimLerp@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetDamageRange
==============
*/

void __fastcall BG_GetDamageRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float *minDamageRange, float *maxDamageRange)
{
  ?BG_GetDamageRange@@YAXW4WeaponDamageCalcType@@AEBUWeapon@@_NMPEAM3@Z(damageCalcType, r_weapon, isAlternate, rangeScale, minDamageRange, maxDamageRange);
}

/*
==============
BG_GetUnderbarrelAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetUnderbarrelAttachment(const Weapon *r_weapon)
{
  return ?BG_GetUnderbarrelAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetMountViewCenterScale
==============
*/

double __fastcall BG_GetMountViewCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewCenterScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_BreachRaiseTime
==============
*/

int __fastcall BG_BreachRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BreachRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObj
==============
*/

void __fastcall BG_UpdateWeaponHidePartBitsForDObj(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel)
{
  ?BG_UpdateWeaponHidePartBitsForDObj@@YAXPEAUDObj@@AEBUWeapon@@_NH@Z(obj, r_weapon, isViewModel, startModel);
}

/*
==============
BG_ReloadEndRechamberInterruptTime
==============
*/

int __fastcall BG_ReloadEndRechamberInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadEndRechamberInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ScopeOutlinesTurrets
==============
*/

bool __fastcall BG_ScopeOutlinesTurrets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesTurrets@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasLadderHand
==============
*/

bool __fastcall BG_HasLadderHand(const playerState_s *ps)
{
  return ?BG_HasLadderHand@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_ReloadEmptyAddTime
==============
*/

int __fastcall BG_ReloadEmptyAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEmptyAddTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2HAEA_N@Z(ps, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetViewKickMaintainFraction
==============
*/

double __fastcall BG_GetViewKickMaintainFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetViewKickMaintainFraction@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_PlayerWeaponCountWeaponsBySlot
==============
*/

unsigned int __fastcall BG_PlayerWeaponCountWeaponsBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  return ?BG_PlayerWeaponCountWeaponsBySlot@@YAIPEBVBgWeaponMap@@PEBUplayerState_s@@W4WeaponSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_GetOverlayReticle
==============
*/

weapOverlayReticle_t __fastcall BG_GetOverlayReticle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOverlayReticle@@YA?AW4weapOverlayReticle_t@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_NoADSWhenMagIsEmpty
==============
*/

bool __fastcall BG_NoADSWhenMagIsEmpty(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_NoADSWhenMagIsEmpty@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponIsDualWield
==============
*/

bool __fastcall BG_WeaponIsDualWield(const Weapon *r_weapon)
{
  return ?BG_WeaponIsDualWield@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_AnyUnderbarrelWeaponEquipped
==============
*/

int __fastcall BG_AnyUnderbarrelWeaponEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_AnyUnderbarrelWeaponEquipped@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_SkydiveParachuteFastLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteFastLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteFastLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_SprintInTime
==============
*/

int __fastcall BG_SprintInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintInTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetViewKickSpeed
==============
*/

void __fastcall BG_GetViewKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickAccel, float *hipViewKickReturnAccelScale, float *hipViewKickReturnSpeedCurveScale, float *adsViewKickAccel, float *adsViewKickReturnAccelScale, float *adsViewKickReturnSpeedCurveScale)
{
  ?BG_GetViewKickSpeed@@YAXPEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@_NPEAM44444@Z(weaponMap, ps, r_weapon, isAlternate, hipViewKickAccel, hipViewKickReturnAccelScale, hipViewKickReturnSpeedCurveScale, adsViewKickAccel, adsViewKickReturnAccelScale, adsViewKickReturnSpeedCurveScale);
}

/*
==============
BG_ProjExplosionEffect
==============
*/

FxCombinedDef __fastcall BG_ProjExplosionEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetEnemyLaserType
==============
*/

const LaserDef *__fastcall BG_GetEnemyLaserType(const Weapon *r_weapon, bool isBeamDraw)
{
  return ?BG_GetEnemyLaserType@@YAPEBULaserDef@@AEBUWeapon@@_N@Z(r_weapon, isBeamDraw);
}

/*
==============
BG_GetMoveSpeedScale
==============
*/

void __fastcall BG_GetMoveSpeedScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *moveSpeedScaleOut, float *adsMoveSpeedScaleOut)
{
  ?BG_GetMoveSpeedScale@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4@Z(weaponMap, ps, r_weapon, isAlternate, moveSpeedScaleOut, adsMoveSpeedScaleOut);
}

/*
==============
BG_ADSResetZoomLevelOnToggle
==============
*/

bool __fastcall BG_ADSResetZoomLevelOnToggle(BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSResetZoomLevelOnToggle@@YA_NPEAVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_QuickRaiseTime
==============
*/

int __fastcall BG_QuickRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_QuickRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_TurretMaxCorrectionAngle
==============
*/

double __fastcall BG_TurretMaxCorrectionAngle(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_TurretMaxCorrectionAngle@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponsUtil_ChooseNextWeaponIdx
==============
*/

unsigned __int16 __fastcall BG_WeaponsUtil_ChooseNextWeaponIdx(unsigned int *randSeed, const unsigned __int16 lastWeaponIdx)
{
  return ?BG_WeaponsUtil_ChooseNextWeaponIdx@@YAGPEAIG@Z(randSeed, lastWeaponIdx);
}

/*
==============
BG_GetCenterReticle
==============
*/

void __fastcall BG_GetCenterReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleCenter, int *reticleCenterSize, bool *shouldPulse)
{
  ?BG_GetCenterReticle@@YAXAEBUWeapon@@_NPEAPEAUMaterial@@PEAHPEA_N@Z(r_weapon, isAlternate, reticleCenter, reticleCenterSize, shouldPulse);
}

/*
==============
BG_IsADSFireOnly
==============
*/

bool __fastcall BG_IsADSFireOnly(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsADSFireOnly@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SkydiveFreefallRaiseTime
==============
*/

int __fastcall BG_SkydiveFreefallRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveFreefallRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_ProceduralGunMotionDisabled
==============
*/

bool __fastcall BG_ProceduralGunMotionDisabled(const playerState_s *ps)
{
  return ?BG_ProceduralGunMotionDisabled@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_WeaponADSFractionAffectedByReload
==============
*/

double __fastcall BG_WeaponADSFractionAffectedByReload(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_WeaponADSFractionAffectedByReload@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
  return result;
}

/*
==============
BG_CurrentWeaponSupportsDualFOV
==============
*/

bool __fastcall BG_CurrentWeaponSupportsDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_CurrentWeaponSupportsDualFOV@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_UseAngularGunKick
==============
*/

bool __fastcall BG_UseAngularGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseAngularGunKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_ExplosionForceScalar
==============
*/

double __fastcall BG_ExplosionForceScalar(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ExplosionForceScalar@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_TurretSpinSound
==============
*/

SndAliasLookup __fastcall BG_TurretSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretSpinSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ScopeToggleOffTime
==============
*/

int __fastcall BG_ScopeToggleOffTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOffTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHudOutlineFill
==============
*/

bool __fastcall BG_GetHudOutlineFill(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineFill@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_KickAngles
==============
*/

void __fastcall BG_KickAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, int updateFrameTime, int *inOutKickTimeRemaining, vec3_t *inOutKickAVel, vec3_t *inOutRawKickAngles, vec3_t *outKickAngles, bool *inOutKickNeedsToCrossCenter)
{
  ?BG_KickAngles@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@HAEAHAEATvec3_t@@33AEA_N@Z(weaponMap, ps, updateFrameTime, inOutKickTimeRemaining, inOutKickAVel, inOutRawKickAngles, outKickAngles, inOutKickNeedsToCrossCenter);
}

/*
==============
BG_HasForegrip
==============
*/

int __fastcall BG_HasForegrip(const Weapon *r_weapon)
{
  return ?BG_HasForegrip@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_HasHoldBreathAbility
==============
*/

int __fastcall BG_HasHoldBreathAbility(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_HasHoldBreathAbility@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_GetAttachmentModel
==============
*/

const XModel *__fastcall BG_GetAttachmentModel(const WeaponAttachment *weaponAttachment, const int attachmentVariationIndex, bool isViewModel)
{
  return ?BG_GetAttachmentModel@@YAPEBUXModel@@PEBUWeaponAttachment@@H_N@Z(weaponAttachment, attachmentVariationIndex, isViewModel);
}

/*
==============
BG_UsesContinousAdsIdleTransiton
==============
*/

bool __fastcall BG_UsesContinousAdsIdleTransiton(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UsesContinousAdsIdleTransiton@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountRumble
==============
*/

RumbleInfo *__fastcall BG_GetMountRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMountRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAngularViewKickSettings
==============
*/

void __fastcall BG_GetAngularViewKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularViewKickDir, float *hipAngularViewKickDev, float *hipAngularViewKickStrengthMin, float *hipAngularViewKickStrengthMax, float *hipAngularViewKickPitchScale, float *adsAngularViewKickDir, float *adsAngularViewKickDev, float *adsAngularViewKickStrengthMin, float *adsAngularViewKickStrengthMax, float *adsAngularViewKickPitchScale)
{
  ?BG_GetAngularViewKickSettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NHPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, bulletNum, hipAngularViewKickDir, hipAngularViewKickDev, hipAngularViewKickStrengthMin, hipAngularViewKickStrengthMax, hipAngularViewKickPitchScale, adsAngularViewKickDir, adsAngularViewKickDev, adsAngularViewKickStrengthMin, adsAngularViewKickStrengthMax, adsAngularViewKickPitchScale);
}

/*
==============
BG_ScopeOutlinesLockOn
==============
*/

bool __fastcall BG_ScopeOutlinesLockOn(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesLockOn@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasVariableZoom
==============
*/

bool __fastcall BG_HasVariableZoom(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasVariableZoom@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetLocationDamageMultipliers
==============
*/

const float *__fastcall BG_GetLocationDamageMultipliers(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetLocationDamageMultipliers@@YAPEBMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HoldingBreath
==============
*/

int __fastcall BG_HoldingBreath(const playerState_s *ps)
{
  return ?BG_HoldingBreath@@YAHPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetMountTransitionEnabled
==============
*/

bool __fastcall BG_GetMountTransitionEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMountTransitionEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_RequireAmmoUsedPerShot
==============
*/

bool __fastcall BG_RequireAmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_RequireAmmoUsedPerShot@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TurretSpawnsProjectileAtMuzzle
==============
*/

bool __fastcall BG_TurretSpawnsProjectileAtMuzzle(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretSpawnsProjectileAtMuzzle@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadInterruptTime
==============
*/

int __fastcall BG_ReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ClearClientWeapons
==============
*/

void __fastcall BG_ClearClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  ?BG_ClearClientWeapons@@YAXPEAVBgWeaponMap@@PEAUclientState_t@@@Z(weaponMap, cs);
}

/*
==============
BG_GetFootstepFromGesture
==============
*/

FootstepAnimType __fastcall BG_GetFootstepFromGesture(gestureAnimType_t gestureIndex)
{
  return ?BG_GetFootstepFromGesture@@YA?AW4FootstepAnimType@@W4gestureAnimType_t@@@Z(gestureIndex);
}

/*
==============
BG_GetAdsLastShotAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsLastShotAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsLastShotAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_IsRifleBullet
==============
*/

bool __fastcall BG_IsRifleBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsRifleBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateWeaponGlass
==============
*/

void __fastcall BG_UpdateWeaponGlass(const float adsFrac, DObj *const obj, const bool adsSmoothFade)
{
  ?BG_UpdateWeaponGlass@@YAXMQEAUDObj@@_N@Z(adsFrac, obj, adsSmoothFade);
}

/*
==============
BG_CanHybridToggle
==============
*/

bool __fastcall BG_CanHybridToggle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_CanHybridToggle@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_IsMeleeAnimState
==============
*/

bool __fastcall BG_IsMeleeAnimState(int animState)
{
  return ?BG_IsMeleeAnimState@@YA_NH@Z(animState);
}

/*
==============
BG_LadderAimADSRaiseTime
==============
*/

int __fastcall BG_LadderAimADSRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimADSRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_IsWeaponValid
==============
*/

bool __fastcall BG_IsWeaponValid(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsWeaponValid@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_PlayerLastWeaponHandForViewWeapon
==============
*/

PlayerHandIndex __fastcall BG_PlayerLastWeaponHandForViewWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_PlayerLastWeaponHandForViewWeapon@@YA?AW4PlayerHandIndex@@PEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_CalculateKickPolar
==============
*/

void __fastcall BG_CalculateKickPolar(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel)
{
  ?BG_CalculateKickPolar@@YAXPEBVBgWeaponMap@@_NPEBUplayerState_s@@AEBUWeapon@@_NPEAIPEAM6@Z(weaponMap, isViewKick, ps, r_weapon, isAlternate, holdrand, outPitchAVel, outYawAVel);
}

/*
==============
BG_HideBone
==============
*/

unsigned __int8 __fastcall BG_HideBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return ?BG_HideBone@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@H@Z(bone, obj, partBits, startModel);
}

/*
==============
BG_GetHeatProperties
==============
*/

void __fastcall BG_GetHeatProperties(const Weapon *weapon, const bool isAlternate, float *outAccumulationPerShot, float *outDissipationPerSecond)
{
  ?BG_GetHeatProperties@@YAXAEBUWeapon@@_NAEAM2@Z(weapon, isAlternate, outAccumulationPerShot, outDissipationPerSecond);
}

/*
==============
BG_GetLUICrosshairWidget
==============
*/

const char *__fastcall BG_GetLUICrosshairWidget(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_GetLUICrosshairWidget@@YAPEBDAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ClearAgentWeapons
==============
*/

void __fastcall BG_ClearAgentWeapons(BgWeaponMap *weaponMap, agentState_s *as)
{
  ?BG_ClearAgentWeapons@@YAXPEAVBgWeaponMap@@PEAUagentState_s@@@Z(weaponMap, as);
}

/*
==============
BG_ConvertWeaponToHexString
==============
*/

void __fastcall BG_ConvertWeaponToHexString(const Weapon *r_weapon, char *outHexString, int outStringLength)
{
  ?BG_ConvertWeaponToHexString@@YAXAEBUWeapon@@PEADH@Z(r_weapon, outHexString, outStringLength);
}

/*
==============
BG_ProjDudSound
==============
*/

const SndAliasList *__fastcall BG_ProjDudSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjDudSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ADSReloadTransTime
==============
*/

int __fastcall BG_ADSReloadTransTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSReloadTransTime@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelEntityState
==============
*/

int __fastcall BG_WeaponDoesNotFullyAnimateViewmodelEntityState(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponDoesNotFullyAnimateViewmodelEntityState@@YAHPEBUentityState_t@@AEBUWeapon@@_N@Z(es, r_weapon, isAlternate);
}

/*
==============
BG_IsPlayingLadderAnims
==============
*/

bool __fastcall BG_IsPlayingLadderAnims(const characterInfo_t *ci)
{
  return ?BG_IsPlayingLadderAnims@@YA_NPEBUcharacterInfo_t@@@Z(ci);
}

/*
==============
BG_HipSpreadFireAdd
==============
*/

double __fastcall BG_HipSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_HipSpreadFireAdd@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetTargetAssistType
==============
*/

targetAssistType_t __fastcall BG_GetTargetAssistType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetTargetAssistType@@YA?AW4targetAssistType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_Weapons_GetScriptedAnimEvent
==============
*/

scriptedAnimEvent_t __fastcall BG_Weapons_GetScriptedAnimEvent(const Weapon *offHandWeapon)
{
  return ?BG_Weapons_GetScriptedAnimEvent@@YA?AW4scriptedAnimEvent_t@@AEBUWeapon@@@Z(offHandWeapon);
}

/*
==============
BG_GetSprintOutTimeScale
==============
*/

double __fastcall BG_GetSprintOutTimeScale(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetSprintOutTimeScale@@YAMPEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetSwayScalar
==============
*/

double __fastcall BG_GetSwayScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const int gameTime)
{
  double result; 

  *(float *)&result = ?BG_GetSwayScalar@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NH@Z(weaponMap, ps, r_weapon, isAlternate, gameTime);
  return result;
}

/*
==============
BG_IsWeaponRecoilDelayed
==============
*/

bool __fastcall BG_IsWeaponRecoilDelayed(const pmove_t *pm, const playerState_s *ps)
{
  return ?BG_IsWeaponRecoilDelayed@@YA_NPEBVpmove_t@@PEBUplayerState_s@@@Z(pm, ps);
}

/*
==============
BG_GetScopeDriftLerpInTime
==============
*/

double __fastcall BG_GetScopeDriftLerpInTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftLerpInTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetSprintAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetSprintAnim(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t relativeAnim)
{
  return ?BG_GetSprintAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@AEBUWeapon@@_N2W41@@Z(ps, r_weapon, isAlternate, isDualWielding, relativeAnim);
}

/*
==============
BG_WeaponCharge_GetLossWhenIdle
==============
*/

double __fastcall BG_WeaponCharge_GetLossWhenIdle(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetLossWhenIdle@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AutoAimRange
==============
*/

double __fastcall BG_AutoAimRange(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_AutoAimRange@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSZoomFov
==============
*/

double __fastcall BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSZoomFov@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(handler, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetADSGunBobBulletDirScale
==============
*/

double __fastcall BG_GetADSGunBobBulletDirScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSGunBobBulletDirScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetAllWeaponAttachments
==============
*/

unsigned int __fastcall BG_GetAllWeaponAttachments(const Weapon *r_weapon, const WeaponAttachment **attachments)
{
  return ?BG_GetAllWeaponAttachments@@YAIAEBUWeapon@@QEAPEBUWeaponAttachment@@@Z(r_weapon, attachments);
}

/*
==============
BG_AmmoUsedPerShot
==============
*/

int __fastcall BG_AmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AmmoUsedPerShot@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMeleeRangeByWeapon
==============
*/

double __fastcall BG_GetMeleeRangeByWeapon(const Weapon *r_weapon, const bool isAlternate, const bool getChargeRange, const bool hasExtendedMelee, const EffectiveStance stance, const bool isSliding)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeRangeByWeapon@@YAMAEBUWeapon@@_N11W4EffectiveStance@@1@Z(r_weapon, isAlternate, getChargeRange, hasExtendedMelee, stance, isSliding);
  return result;
}

/*
==============
BG_GetMeleeCountToFinisher
==============
*/

bool __fastcall BG_GetMeleeCountToFinisher(const Weapon *r_weapon, bool isAlternate, int *outCountToFinisher)
{
  return ?BG_GetMeleeCountToFinisher@@YA_NAEBUWeapon@@_NPEAH@Z(r_weapon, isAlternate, outCountToFinisher);
}

/*
==============
BG_WeaponAIFuseTime
==============
*/

int __fastcall BG_WeaponAIFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponAIFuseTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetBallisticMuzzleVelocityScale
==============
*/

double __fastcall BG_GetBallisticMuzzleVelocityScale(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetBallisticMuzzleVelocityScale@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_SkydiveParachuteSlowHardLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteSlowHardLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteSlowHardLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetTurretFireType
==============
*/

turretFireType_t __fastcall BG_GetTurretFireType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetTurretFireType@@YA?AW4turretFireType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_InheritsPerks
==============
*/

bool __fastcall BG_InheritsPerks(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_InheritsPerks@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseFastReload
==============
*/

bool __fastcall BG_UseFastReload(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseFastReload@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetScopeLensSettings
==============
*/

void __fastcall BG_GetScopeLensSettings(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const float adsFrac, const BgHybridScopeFraction *hybridScopeFraction, GfxScopeInfo *settingOut)
{
  ?BG_GetScopeLensSettings@@YAXPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_NMAEBUBgHybridScopeFraction@@PEAUGfxScopeInfo@@@Z(handler, ps, r_weapon, isAlternate, adsFrac, hybridScopeFraction, settingOut);
}

/*
==============
BG_AltOverride3PInTime
==============
*/

int __fastcall BG_AltOverride3PInTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltOverride3PInTime@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHudOutlineDepthTest
==============
*/

bool __fastcall BG_GetHudOutlineDepthTest(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineDepthTest@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_AddWeaponAttachmentModels
==============
*/

void __fastcall BG_AddWeaponAttachmentModels(const Weapon *r_weapon, const PlayerHandIndex hand, bool isDualWield, bool useViewModel, bool ignoreCollision, bool stowedWeapon, DObjModel *dobjModels, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels, const DObjCamoParams *camoParams)
{
  ?BG_AddWeaponAttachmentModels@@YAXAEBUWeapon@@W4PlayerHandIndex@@_N222PEAUDObjModel@@GPEAGPEAVXAnimWeaponIKModelsContainer@@PEBUDObjCamoParams@@@Z(r_weapon, hand, isDualWield, useViewModel, ignoreCollision, stowedWeapon, dobjModels, maxModels, numModels, outWeaponIKModels, camoParams);
}

/*
==============
BG_GetTargetAssistBehavior
==============
*/

targetAssistBehavior_t __fastcall BG_GetTargetAssistBehavior(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetTargetAssistBehavior@@YA?AW4targetAssistBehavior_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsMeleeOnlyAxe
==============
*/

bool __fastcall BG_IsMeleeOnlyAxe(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsMeleeOnlyAxe@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ExplodeOnImpact
==============
*/

bool __fastcall BG_WeaponBulletFire_ExplodeOnImpact(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ExplodeOnImpact@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_GetADSSwayScalars
==============
*/

void __fastcall BG_GetADSSwayScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsSwayMaxAngleScale, float *outAdsSwayLerpSpeedScale, float *outAdsSwayScaleScale)
{
  ?BG_GetADSSwayScalars@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM44@Z(weaponMap, ps, r_weapon, isAlternate, outAdsSwayMaxAngleScale, outAdsSwayLerpSpeedScale, outAdsSwayScaleScale);
}

/*
==============
BG_GetHudOutlineWidth
==============
*/

double __fastcall BG_GetHudOutlineWidth(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_GetHudOutlineWidth@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
  return result;
}

/*
==============
BG_GetWeaponThermalPlayerFadeDistStartAndEnd
==============
*/

bool __fastcall BG_GetWeaponThermalPlayerFadeDistStartAndEnd(const Weapon *r_weapon, const bool isAlternate, vec2_t *outStartAndEnd)
{
  return ?BG_GetWeaponThermalPlayerFadeDistStartAndEnd@@YA_NAEBUWeapon@@_NAEATvec2_t@@@Z(r_weapon, isAlternate, outStartAndEnd);
}

/*
==============
BG_ProjectileActivateDist
==============
*/

int __fastcall BG_ProjectileActivateDist(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjectileActivateDist@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponType
==============
*/

weapType_t __fastcall BG_GetWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponType@@YA?AW4weapType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ValidateWeapon
==============
*/

bool __fastcall BG_ValidateWeapon(const Weapon *r_weapon)
{
  return ?BG_ValidateWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteSlowSoftLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteSlowSoftLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetADSReloadNVGFOV
==============
*/

double __fastcall BG_GetADSReloadNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  double result; 

  *(float *)&result = ?BG_GetADSReloadNVGFOV@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, getWeaponValues);
  return result;
}

/*
==============
BG_CanAttachmentHybridToggle
==============
*/

bool __fastcall BG_CanAttachmentHybridToggle(const WeaponAttachment *attachment)
{
  return ?BG_CanAttachmentHybridToggle@@YA_NPEBUWeaponAttachment@@@Z(attachment);
}

/*
==============
BG_WeaponBulletFire_GetHitEvent
==============
*/

unsigned int __fastcall BG_WeaponBulletFire_GetHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  return ?BG_WeaponBulletFire_GetHitEvent@@YAII_N@Z(meansOfDeath, serverPlayerHitEvent);
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingVelocity
==============
*/

double __fastcall BG_SkydiveParachuteSlowSoftLandingVelocity(const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_SkydiveParachuteSlowSoftLandingVelocity@@YAMPEBUplayerState_s@@@Z(ps);
  return result;
}

/*
==============
BG_SlideSpreadFireAdd
==============
*/

double __fastcall BG_SlideSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_SlideSpreadFireAdd@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_Weapons_AttachWorldIKTargets
==============
*/

unsigned __int16 __fastcall BG_Weapons_AttachWorldIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModel, bool isServer, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_Weapons_AttachWorldIKTargets@@YAGPEAUDObjModel@@GPEBUcharacterInfo_t@@PEAUXModel@@_NAEAY0CA@W4CharacterModelType@@@Z(dobjModels, numModels, ci, ikTargetModel, isServer, outModelTypes);
}

/*
==============
BG_GetHudOutlineAltInScopeColor
==============
*/

void __fastcall BG_GetHudOutlineAltInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineAltInScopeColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_GetOtherAdsDownAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetOtherAdsDownAnim(const weapAnimFiles_t adsAnim)
{
  return ?BG_GetOtherAdsDownAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(adsAnim);
}

/*
==============
BG_HasDefaultViewModel
==============
*/

bool __fastcall BG_HasDefaultViewModel(const Weapon *r_weapon)
{
  return ?BG_HasDefaultViewModel@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_CanPlayerHaveWeapon
==============
*/

bool __fastcall BG_CanPlayerHaveWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_CanPlayerHaveWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSCrosshairBlendFracs
==============
*/

void __fastcall BG_GetADSCrosshairBlendFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool adsIn, float *outBlendStart, float *outBlendEnd)
{
  ?BG_GetADSCrosshairBlendFracs@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N3PEAM4@Z(weaponMap, ps, r_weapon, isAlternate, adsIn, outBlendStart, outBlendEnd);
}

/*
==============
BG_IsRiotShield
==============
*/

bool __fastcall BG_IsRiotShield(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsRiotShield@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SkydiveParachuteDetachTime
==============
*/

int __fastcall BG_SkydiveParachuteDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteDetachTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_IsTopMountYawClamped
==============
*/

bool __fastcall BG_IsTopMountYawClamped(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsTopMountYawClamped@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PlayerLastWeaponHandForWeapon
==============
*/

PlayerHandIndex __fastcall BG_PlayerLastWeaponHandForWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_PlayerLastWeaponHandForWeapon@@YA?AW4PlayerHandIndex@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_IsWeaponLaserEndViewCenterInAds
==============
*/

bool __fastcall BG_IsWeaponLaserEndViewCenterInAds(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsWeaponLaserEndViewCenterInAds@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponsUtil_AdvanceWeapon
==============
*/

bool __fastcall BG_WeaponsUtil_AdvanceWeapon(Weapon *inOutWeapon)
{
  return ?BG_WeaponsUtil_AdvanceWeapon@@YA_NAEAUWeapon@@@Z(inOutWeapon);
}

/*
==============
BG_IsBoltAction
==============
*/

bool __fastcall BG_IsBoltAction(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsBoltAction@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ViewFlashADSEffect
==============
*/

FxCombinedDef __fastcall BG_ViewFlashADSEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  return ?BG_ViewFlashADSEffect@@YA?AUFxCombinedDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N2@Z(perks, r_weapon, isAlternate, isFirstFlash);
}

/*
==============
BG_UniqueAmmoUnderbarrelAttachment
==============
*/

const WeaponAttachment *__fastcall BG_UniqueAmmoUnderbarrelAttachment(const Weapon *weapon, const bool isAlternate)
{
  return ?BG_UniqueAmmoUnderbarrelAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@_N@Z(weapon, isAlternate);
}

/*
==============
BG_CalculateKickBox
==============
*/

void __fastcall BG_CalculateKickBox(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel, float *outMinMagnitude)
{
  ?BG_CalculateKickBox@@YAXPEBVBgWeaponMap@@_NPEBUplayerState_s@@AEBUWeapon@@_NPEAIPEAM66@Z(weaponMap, isViewKick, ps, r_weapon, isAlternate, holdrand, outPitchAVel, outYawAVel, outMinMagnitude);
}

/*
==============
BG_ProjExplosionSound
==============
*/

const SndAliasList *__fastcall BG_ProjExplosionSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsUsingDualFOV
==============
*/

bool __fastcall BG_IsUsingDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_IsUsingDualFOV@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
TagPair::GetPrimaryTagName
==============
*/

scr_string_t __fastcall TagPair::GetPrimaryTagName(TagPair *this)
{
  return ?GetPrimaryTagName@TagPair@@QEBA?AW4scr_string_t@@XZ(this);
}

/*
==============
BG_HideSniperScene
==============
*/

void __fastcall BG_HideSniperScene(const Weapon *r_weapon, DObj *obj)
{
  ?BG_HideSniperScene@@YAXAEBUWeapon@@PEAUDObj@@@Z(r_weapon, obj);
}

/*
==============
BG_Weapon_FiresOnWeaponSwitch
==============
*/

int __fastcall BG_Weapon_FiresOnWeaponSwitch(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_Weapon_FiresOnWeaponSwitch@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeapDetonateType
==============
*/

WeapDetonateType __fastcall BG_WeapDetonateType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeapDetonateType@@YA?AW4WeapDetonateType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasVRScope
==============
*/

bool __fastcall BG_HasVRScope(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_HasVRScope@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponExplicitHideTags
==============
*/

void __fastcall BG_GetWeaponExplicitHideTags(const Weapon *r_weapon, const bool isAlternate, const bool isViewModel, const unsigned __int64 hideTagBufferSize, scr_string_t *outHideTagBuffer, unsigned __int64 *outHideTagCount)
{
  ?BG_GetWeaponExplicitHideTags@@YAXAEBUWeapon@@_N1_KQEAW4scr_string_t@@PEA_K@Z(r_weapon, isAlternate, isViewModel, hideTagBufferSize, outHideTagBuffer, outHideTagCount);
}

/*
==============
BG_ProjTrailEffect
==============
*/

FxCombinedDef __fastcall BG_ProjTrailEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTrailEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetHybridScopeEnablerAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetHybridScopeEnablerAttachment(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **outDataAttachment)
{
  return ?BG_GetHybridScopeEnablerAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@_NPEAPEBU1@@Z(r_weapon, isAlternate, outDataAttachment);
}

/*
==============
BG_ShowHideTagsBasedOnAltMode
==============
*/

void __fastcall BG_ShowHideTagsBasedOnAltMode(const Weapon *r_weapon, DObj *obj, bool isAlternate, bool raisingToAlt, bool hideReticle, bool overrideHamr, bool hamrOn)
{
  ?BG_ShowHideTagsBasedOnAltMode@@YAXAEBUWeapon@@PEAUDObj@@_N2222@Z(r_weapon, obj, isAlternate, raisingToAlt, hideReticle, overrideHamr, hamrOn);
}

/*
==============
TagPair::TagPair
==============
*/

void __fastcall TagPair::TagPair(TagPair *this, scr_string_t primaryTagName, scr_string_t fallbackTagName)
{
  ??0TagPair@@QEAA@W4scr_string_t@@0@Z(this, primaryTagName, fallbackTagName);
}

/*
==============
BG_IsFistsWeapon
==============
*/

bool __fastcall BG_IsFistsWeapon(const Weapon *r_weapon)
{
  return ?BG_IsFistsWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_WeaponGetNotetrackMilliseconds
==============
*/

int __fastcall BG_WeaponGetNotetrackMilliseconds(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler, const scr_string_t notetrackName, int *outDuration)
{
  return ?BG_WeaponGetNotetrackMilliseconds@@YAHPEBUplayerState_s@@W4PlayerHandIndex@@_NW4weapAnimFiles_t@@PEBVBgHandler@@W4scr_string_t@@PEAH@Z(ps, hand, bIsAlternate, eWeaponAnim, pmoveHandler, notetrackName, outDuration);
}

/*
==============
BG_WeaponCharge_GetHudReveal
==============
*/

bool __fastcall BG_WeaponCharge_GetHudReveal(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetHudReveal@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsBeamWeapon
==============
*/

bool __fastcall BG_IsBeamWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsBeamWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_FireSound
==============
*/

const SndAliasList *__fastcall BG_FireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  return ?BG_FireSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayer);
}

/*
==============
BG_ADSZoomFov
==============
*/

double __fastcall BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, const bool getWeaponValues, bool *outIsNVGForcedFov)
{
  double result; 

  *(float *)&result = ?BG_ADSZoomFov@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_NAEBUBgHybridScopeFraction@@_NAEA_N@Z(handler, ps, r_weapon, isAlternate, hybridScopeFractionInfo, getWeaponValues, outIsNVGForcedFov);
  return result;
}

/*
==============
BG_GetAllWeaponAttachmentsWithIds
==============
*/

unsigned int __fastcall BG_GetAllWeaponAttachmentsWithIds(const Weapon *r_weapon, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  return ?BG_GetAllWeaponAttachmentsWithIds@@YAIAEBUWeapon@@QEAPEBUWeaponAttachment@@QEAE@Z(r_weapon, attachments, attachmentIds);
}

/*
==============
BG_IsWeaponUsableInState
==============
*/

bool __fastcall BG_IsWeaponUsableInState(const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsWeaponUsableInState@@YA_NPEBUplayerState_s@@AEBUWeapon@@@Z(ps, r_weapon);
}

/*
==============
BG_OffhandUnderbarrelInitAllowed
==============
*/

int __fastcall BG_OffhandUnderbarrelInitAllowed(const playerState_s *ps)
{
  return ?BG_OffhandUnderbarrelInitAllowed@@YAHPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetProjectileSpeed
==============
*/

void __fastcall BG_GetProjectileSpeed(const Weapon *r_weapon, bool isAlternate, int *projectileSpeed, int *projectileSpeedUp)
{
  ?BG_GetProjectileSpeed@@YAXAEBUWeapon@@_NPEAH2@Z(r_weapon, isAlternate, projectileSpeed, projectileSpeedUp);
}

/*
==============
BG_ViewModelBlendSpaceExists
==============
*/

int __fastcall BG_ViewModelBlendSpaceExists(const playerState_s *ps, WeaponBlendSpaceType blendSpaceType, const BgHandler *pmoveHandler)
{
  return ?BG_ViewModelBlendSpaceExists@@YAHPEBUplayerState_s@@W4WeaponBlendSpaceType@@PEBVBgHandler@@@Z(ps, blendSpaceType, pmoveHandler);
}

/*
==============
BG_UseAngularViewKick
==============
*/

bool __fastcall BG_UseAngularViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseAngularViewKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetScopeAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetScopeAttachment(const Weapon *r_weapon)
{
  return ?BG_GetScopeAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetKickOpposedInputScalar
==============
*/

double __fastcall BG_GetKickOpposedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetKickOpposedInputScalar@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsAdsVisionSetActive
==============
*/

bool __fastcall BG_IsAdsVisionSetActive(const BgHandler *handler, const playerState_s *ps, const Weapon *weapon, bool isAlternate, BgAdsVisionSetInfo *outVisionSetInfo)
{
  return ?BG_IsAdsVisionSetActive@@YA_NPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@_NAEAUBgAdsVisionSetInfo@@@Z(handler, ps, weapon, isAlternate, outVisionSetInfo);
}

/*
==============
BG_Weapon_GetPrimaryAttachmentIndex
==============
*/

unsigned __int16 __fastcall BG_Weapon_GetPrimaryAttachmentIndex(const Weapon *weapon, const AttachmentSlot *slot)
{
  return ?BG_Weapon_GetPrimaryAttachmentIndex@@YAGAEBUWeapon@@AEBW4AttachmentSlot@@@Z(weapon, slot);
}

/*
==============
BG_HeatSmokeEffect
==============
*/

void __fastcall BG_HeatSmokeEffect(const Weapon *r_weapon, bool isAlternate, bool isViewmodel, FxCombinedDef *muzzleSmoke, FxCombinedDef *barrelSmoke, FxCombinedDef *ejectionPortSmoke)
{
  ?BG_HeatSmokeEffect@@YAXAEBUWeapon@@_N1PEAUFxCombinedDef@@22@Z(r_weapon, isAlternate, isViewmodel, muzzleSmoke, barrelSmoke, ejectionPortSmoke);
}

/*
==============
BG_ProjectileModel
==============
*/

XModel *__fastcall BG_ProjectileModel(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjectileModel@@YAPEAUXModel@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSViewBobSettingsScale
==============
*/

double __fastcall BG_GetADSViewBobSettingsScale(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSViewBobSettingsScale@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_MapWeaponAnimIndexToMeleeIndex
==============
*/

weapMeleeAnimFiles_t __fastcall BG_MapWeaponAnimIndexToMeleeIndex(weapAnimFiles_t animIndex)
{
  return ?BG_MapWeaponAnimIndexToMeleeIndex@@YA?AW4weapMeleeAnimFiles_t@@W4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_WeaponSticksToTurrets
==============
*/

bool __fastcall BG_WeaponSticksToTurrets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToTurrets@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsOffhandWeaponType
==============
*/

int __fastcall BG_IsOffhandWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsOffhandWeaponType@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HasUnderbarrelAmmo
==============
*/

bool __fastcall BG_HasUnderbarrelAmmo(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelAmmo@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetADSZoomLevelFraction
==============
*/

double __fastcall BG_GetADSZoomLevelFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const int gameTime)
{
  double result; 

  *(float *)&result = ?BG_GetADSZoomLevelFraction@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NH@Z(weaponMap, ps, weapon, isAlternate, gameTime);
  return result;
}

/*
==============
BG_StunnedTimeBegin
==============
*/

int __fastcall BG_StunnedTimeBegin(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_StunnedTimeBegin@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ReloadTime
==============
*/

int __fastcall BG_ReloadTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetScopeDriftSteadyFactor
==============
*/

double __fastcall BG_GetScopeDriftSteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftSteadyFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_StartAmmo
==============
*/

int __fastcall BG_StartAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  return ?BG_StartAmmo@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, hasIncreasedOffhandAmmoPerk);
}

/*
==============
BG_UseFastOffhand
==============
*/

bool __fastcall BG_UseFastOffhand(const playerState_s *ps, const BgWeaponMap *weaponMap)
{
  return ?BG_UseFastOffhand@@YA_NPEBUplayerState_s@@PEBVBgWeaponMap@@@Z(ps, weaponMap);
}

/*
==============
BG_ShowBone
==============
*/

unsigned __int8 __fastcall BG_ShowBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return ?BG_ShowBone@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@H@Z(bone, obj, partBits, startModel);
}

/*
==============
BG_SyncedFOVInDualFOV
==============
*/

bool __fastcall BG_SyncedFOVInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SyncedFOVInDualFOV@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsFauxFists
==============
*/

bool __fastcall BG_IsFauxFists(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsFauxFists@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_AltRaiseAkimboTime
==============
*/

int __fastcall BG_AltRaiseAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltRaiseAkimboTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_BlurSceneAdsInFraction
==============
*/

double __fastcall BG_BlurSceneAdsInFraction(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_BlurSceneAdsInFraction@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsValidWeapon
==============
*/

bool __fastcall BG_IsValidWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsValidWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetShelvedDamageRanges
==============
*/

int __fastcall BG_GetShelvedDamageRanges(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, float *rangeArray, int size)
{
  return ?BG_GetShelvedDamageRanges@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_NMPEAMH@Z(damageCalcType, r_weapon, isAlternate, rangeScale, rangeArray, size);
}

/*
==============
BG_GetViewKickYawAndPitch
==============
*/

void __fastcall BG_GetViewKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickPitchMin, float *hipViewKickPitchMax, float *hipViewKickYawMin, float *hipViewKickYawMax, float *hipViewKickMagMin, float *adsViewKickPitchMin, float *adsViewKickPitchMax, float *adsViewKickYawMin, float *adsViewKickYawMax, float *adsViewKickMagMin)
{
  ?BG_GetViewKickYawAndPitch@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, hipViewKickPitchMin, hipViewKickPitchMax, hipViewKickYawMin, hipViewKickYawMax, hipViewKickMagMin, adsViewKickPitchMin, adsViewKickPitchMax, adsViewKickYawMin, adsViewKickYawMax, adsViewKickMagMin);
}

/*
==============
BG_IsForceForegripIK
==============
*/

bool __fastcall BG_IsForceForegripIK(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_IsForceForegripIK@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ChargeWeaponLoopTime
==============
*/

int __fastcall BG_ChargeWeaponLoopTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ChargeWeaponLoopTime@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@AEBUWeapon@@_N3@Z(ps, animIndex, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHipOffsetLerpType
==============
*/

void __fastcall BG_GetHipOffsetLerpType(const Weapon *r_weapon, bool isAlternate, AdsOffsetInterpolationType *outHipOffsetLerpType)
{
  ?BG_GetHipOffsetLerpType@@YAXAEBUWeapon@@_NPEAW4AdsOffsetInterpolationType@@@Z(r_weapon, isAlternate, outHipOffsetLerpType);
}

/*
==============
BG_GetHitmarkerType
==============
*/

int __fastcall BG_GetHitmarkerType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetHitmarkerType@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetViewKickMaxAngles
==============
*/

void __fastcall BG_GetViewKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  ?BG_GetViewKickMaxAngles@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEATvec2_t@@@Z(weaponMap, ps, r_weapon, isAlternate, outMaxAngles);
}

/*
==============
BG_AltSharesAmmo
==============
*/

bool __fastcall BG_AltSharesAmmo(const Weapon *r_weapon)
{
  return ?BG_AltSharesAmmo@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BgWeaponScalarAccumulator::Reset
==============
*/

void __fastcall BgWeaponScalarAccumulator::Reset(BgWeaponScalarAccumulator *this)
{
  ?Reset@BgWeaponScalarAccumulator@@QEAAXXZ(this);
}

/*
==============
BG_AltRaiseADSTime
==============
*/

int __fastcall BG_AltRaiseADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltRaiseADSTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MaxAmmo
==============
*/

int __fastcall BG_MaxAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  return ?BG_MaxAmmo@@YAHAEBUWeapon@@_N1@Z(r_weapon, isAlternate, hasIncreasedOffhandAmmoPerk);
}

/*
==============
BG_NoPartialReload
==============
*/

bool __fastcall BG_NoPartialReload(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_NoPartialReload@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ViewFlashEffect
==============
*/

FxCombinedDef __fastcall BG_ViewFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  return ?BG_ViewFlashEffect@@YA?AUFxCombinedDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N2@Z(perks, r_weapon, isAlternate, isFirstFlash);
}

/*
==============
BG_RechamberTime
==============
*/

int __fastcall BG_RechamberTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RechamberTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ADSReloadEnabled
==============
*/

bool __fastcall BG_ADSReloadEnabled(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_ADSReloadEnabled@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_ThrowingBackGrenade
==============
*/

bool __fastcall BG_ThrowingBackGrenade(const playerState_s *ps)
{
  return ?BG_ThrowingBackGrenade@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetPlayerDamageRange
==============
*/

void __fastcall BG_GetPlayerDamageRange(const WeaponDamageCalcType damageCalcType, const BgWeaponMap *weaponMap, const playerState_s *ps, const bitarray<64> *r_perks, const Weapon *r_weapon, bool isAlternate, float *minDamageRange, float *maxDamageRange)
{
  ?BG_GetPlayerDamageRange@@YAXW4WeaponDamageCalcType@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBV?$bitarray@$0EA@@@AEBUWeapon@@_NPEAM6@Z(damageCalcType, weaponMap, ps, r_perks, r_weapon, isAlternate, minDamageRange, maxDamageRange);
}

/*
==============
BG_GetHudOutlineFillColor1
==============
*/

void __fastcall BG_GetHudOutlineFillColor1(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineFillColor1@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_DestabilizeDistance
==============
*/

int __fastcall BG_DestabilizeDistance(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DestabilizeDistance@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_DropTime
==============
*/

int __fastcall BG_DropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_DropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetOffhandAllowsSprint
==============
*/

bool __fastcall BG_GetOffhandAllowsSprint(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOffhandAllowsSprint@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LadderClimbDropTime
==============
*/

int __fastcall BG_LadderClimbDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderClimbDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponCharge_GetMeterBoneMaxCount
==============
*/

unsigned int __fastcall BG_WeaponCharge_GetMeterBoneMaxCount()
{
  return ?BG_WeaponCharge_GetMeterBoneMaxCount@@YAIXZ();
}

/*
==============
BG_AltRaiseTime
==============
*/

int __fastcall BG_AltRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_Weapon_SetPrimaryAttachmentIndex
==============
*/

void __fastcall BG_Weapon_SetPrimaryAttachmentIndex(const AttachmentSlot *slot, const unsigned __int16 attachmentIndex, Weapon *outWeapon)
{
  ?BG_Weapon_SetPrimaryAttachmentIndex@@YAXAEBW4AttachmentSlot@@GAEAUWeapon@@@Z(slot, attachmentIndex, outWeapon);
}

/*
==============
BG_UseQuickSwitchAnims
==============
*/

bool __fastcall BG_UseQuickSwitchAnims(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const BgHandler *pmoveHandler, const bool checkRaise)
{
  return ?BG_UseQuickSwitchAnims@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N2PEBVBgHandler@@2@Z(ps, r_weapon, isAlternate, isDualWielding, pmoveHandler, checkRaise);
}

/*
==============
BG_WorldShellEjectEffect
==============
*/

FxCombinedDef __fastcall BG_WorldShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WorldShellEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponsUtil_ChooseRandomWeaponIdx
==============
*/

unsigned __int16 __fastcall BG_WeaponsUtil_ChooseRandomWeaponIdx(unsigned int *randSeed, const unsigned __int16 lastWeaponIdx)
{
  return ?BG_WeaponsUtil_ChooseRandomWeaponIdx@@YAGPEAIG@Z(randSeed, lastWeaponIdx);
}

/*
==============
BG_UseADSFireAnim
==============
*/

bool __fastcall BG_UseADSFireAnim(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_UseADSFireAnim@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_GetMountViewKickScale
==============
*/

double __fastcall BG_GetMountViewKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewKickScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HybridToggleIsAllowed
==============
*/

bool __fastcall BG_HybridToggleIsAllowed(const BgWeaponMap *weaponMap, const playerState_s *ps, const BgHandler *handler)
{
  return ?BG_HybridToggleIsAllowed@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@PEBVBgHandler@@@Z(weaponMap, ps, handler);
}

/*
==============
BG_CreateWeaponFireParam
==============
*/

unsigned int __fastcall BG_CreateWeaponFireParam(int boneIndex, const Weapon *r_weaponID)
{
  return ?BG_CreateWeaponFireParam@@YAIHAEBUWeapon@@@Z(boneIndex, r_weaponID);
}

/*
==============
BG_WeaponCharge_GetMeterBoneName
==============
*/

scr_string_t __fastcall BG_WeaponCharge_GetMeterBoneName(unsigned int chargeIndex)
{
  return ?BG_WeaponCharge_GetMeterBoneName@@YA?AW4scr_string_t@@I@Z(chargeIndex);
}

/*
==============
BG_ConvertWeaponFromHexString
==============
*/

Weapon *__fastcall BG_ConvertWeaponFromHexString(Weapon *result, const char *hexString)
{
  return ?BG_ConvertWeaponFromHexString@@YA?AUWeapon@@PEBD@Z(result, hexString);
}

/*
==============
BG_OffhandIsUnderbarrelWeapon
==============
*/

int __fastcall BG_OffhandIsUnderbarrelWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, unsigned __int64 whichOffhandButton)
{
  return ?BG_OffhandIsUnderbarrelWeapon@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@_K@Z(weaponMap, ps, whichOffhandButton);
}

/*
==============
BG_ShotCount
==============
*/

int __fastcall BG_ShotCount(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShotCount@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetType
==============
*/

WeaponChargeType __fastcall BG_WeaponCharge_GetType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetType@@YA?AW4WeaponChargeType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_DestabilizationRateTime
==============
*/

double __fastcall BG_DestabilizationRateTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_DestabilizationRateTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetSlideSpread
==============
*/

void __fastcall BG_GetSlideSpread(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMax)
{
  ?BG_GetSlideSpread@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, outSlideSpreadMin, outSlideSpreadMax);
}

/*
==============
BG_GetWeaponAttachments
==============
*/

unsigned int __fastcall BG_GetWeaponAttachments(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  return ?BG_GetWeaponAttachments@@YAIAEBUWeapon@@_NQEAPEBUWeaponAttachment@@@Z(r_weapon, isAlternate, attachments);
}

/*
==============
BG_GetWeaponDismembermentEnabled
==============
*/

bool __fastcall BG_GetWeaponDismembermentEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_GetWeaponDismembermentEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BlocksNVGADS
==============
*/

bool __fastcall BG_BlocksNVGADS(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_BlocksNVGADS@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponGetPlayerAnimType
==============
*/

int __fastcall BG_WeaponGetPlayerAnimType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponGetPlayerAnimType@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsMountTopStrafeEnabled
==============
*/

bool __fastcall BG_IsMountTopStrafeEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsMountTopStrafeEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_SkydiveParachuteStillLandingTime
==============
*/

int __fastcall BG_SkydiveParachuteStillLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteStillLandingTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetStandWeaponOffset
==============
*/

void __fastcall BG_GetStandWeaponOffset(const Weapon *r_weapon, bool isAlternate, vec3_t *outStandOffset, vec3_t *outStandOffsetAngles, vec3_t *outStandOffsetPivot)
{
  ?BG_GetStandWeaponOffset@@YAXAEBUWeapon@@_NAEATvec3_t@@22@Z(r_weapon, isAlternate, outStandOffset, outStandOffsetAngles, outStandOffsetPivot);
}

/*
==============
BG_GetNextSpectateViewWeapons
==============
*/

bool __fastcall BG_GetNextSpectateViewWeapons(const BgWeaponMap *const weaponMap, const characterInfo_t *const ci, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  return ?BG_GetNextSpectateViewWeapons@@YA_NQEBVBgWeaponMap@@QEBUcharacterInfo_t@@AEAY0BI@UWeapon@@AEAI@Z(weaponMap, ci, outViewWeapons, inOutWeaponCount);
}

/*
==============
BG_WorldLastShotEjectEffect
==============
*/

FxCombinedDef __fastcall BG_WorldLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WorldLastShotEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TracerType
==============
*/

TracerDef *__fastcall BG_TracerType(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TracerType@@YAPEAUTracerDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_ValidateWeaponAttachment
==============
*/

bool __fastcall BG_ValidateWeaponAttachment(const WeaponCompleteDef *const weapCompleteDef, const AttachmentSlot slot, const unsigned __int16 weaponAttachmentIndex)
{
  return ?BG_ValidateWeaponAttachment@@YA_NQEBUWeaponCompleteDef@@W4AttachmentSlot@@G@Z(weapCompleteDef, slot, weaponAttachmentIndex);
}

/*
==============
BG_IsMeleeAnimHit
==============
*/

bool __fastcall BG_IsMeleeAnimHit(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnimHit@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_GetMeleeWidth
==============
*/

double __fastcall BG_GetMeleeWidth(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeWidth@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes
==============
*/

unsigned __int8 __fastcall TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, const scr_string_t tagName)
{
  return ?GetBoneIndexForTagNameMatchingCharacterModelTypes@TagPair@@SAEPEBUDObj@@PEBUcharacterInfo_t@@QEBW4CharacterModelType@@HW4scr_string_t@@@Z(obj, ci, modelTypesToSearch, modelTypeCount, tagName);
}

/*
==============
BG_WeaponCharge_GetMeterEffect
==============
*/

FxCombinedDef __fastcall BG_WeaponCharge_GetMeterEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetMeterEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ScopeOutlinesAgents
==============
*/

bool __fastcall BG_ScopeOutlinesAgents(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesAgents@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetSfxPackage
==============
*/

WeaponSFXPackage *__fastcall BG_GetSfxPackage(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetSfxPackage@@YAPEAUWeaponSFXPackage@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BurstFireIsAuto
==============
*/

bool __fastcall BG_BurstFireIsAuto(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_BurstFireIsAuto@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateWeaponGlassDebug
==============
*/

void __fastcall BG_UpdateWeaponGlassDebug(const float adsFrac, DObj *const obj)
{
  ?BG_UpdateWeaponGlassDebug@@YAXMQEAUDObj@@@Z(adsFrac, obj);
}

/*
==============
BG_OneHandedViewModelAnimsValid
==============
*/

int __fastcall BG_OneHandedViewModelAnimsValid(const WeaponDef *weapDef)
{
  return ?BG_OneHandedViewModelAnimsValid@@YAHPEBUWeaponDef@@@Z(weapDef);
}

/*
==============
BG_ADSBobRate
==============
*/

double __fastcall BG_ADSBobRate(const Weapon *r_weapon, const bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSBobRate@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsThermalEnabled
==============
*/

bool __fastcall BG_IsThermalEnabled(const BgWeaponMap *weaponMap, const Weapon *r_weapon, const playerState_s *ps)
{
  return ?BG_IsThermalEnabled@@YA_NPEBVBgWeaponMap@@AEBUWeapon@@PEBUplayerState_s@@@Z(weaponMap, r_weapon, ps);
}

/*
==============
BG_TurretUsesBulletCorrection
==============
*/

bool __fastcall BG_TurretUsesBulletCorrection(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretUsesBulletCorrection@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountViewIdleScale
==============
*/

double __fastcall BG_GetMountViewIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountViewIdleScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::GetTagNameAndBoneIndex
==============
*/

bool __fastcall TagPair::GetTagNameAndBoneIndex(TagPair *this, const DObj *obj, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  return ?GetTagNameAndBoneIndex@TagPair@@QEBA_NPEBUDObj@@PEAW4scr_string_t@@PEAE@Z(this, obj, outTagName, outBoneIndex);
}

/*
==============
BG_GetExplosionDamageFromRangeInfo
==============
*/

double __fastcall BG_GetExplosionDamageFromRangeInfo(const BgExplosionDamageRangeInfo *damageRangeInfo, const float distance)
{
  double result; 

  *(float *)&result = ?BG_GetExplosionDamageFromRangeInfo@@YAMAEBUBgExplosionDamageRangeInfo@@M@Z(damageRangeInfo, distance);
  return result;
}

/*
==============
BG_GetAllWeaponAttachmentsCount
==============
*/

unsigned int __fastcall BG_GetAllWeaponAttachmentsCount(const Weapon *r_weapon)
{
  return ?BG_GetAllWeaponAttachmentsCount@@YAIAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_IsAimDownSight
==============
*/

bool __fastcall BG_IsAimDownSight(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsAimDownSight@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IdleProneFactor
==============
*/

double __fastcall BG_IdleProneFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_IdleProneFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
TagPair::GetFallbackTagName
==============
*/

scr_string_t __fastcall TagPair::GetFallbackTagName(TagPair *this)
{
  return ?GetFallbackTagName@TagPair@@QEBA?AW4scr_string_t@@XZ(this);
}

/*
==============
BG_LeapInTime
==============
*/

int __fastcall BG_LeapInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LeapInTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetADSZoomLevelWeights
==============
*/

void __fastcall BG_GetADSZoomLevelWeights(const float adsZoomLevelFraction, float *outZoomLevelWeights)
{
  ?BG_GetADSZoomLevelWeights@@YAXMQEAM@Z(adsZoomLevelFraction, outZoomLevelWeights);
}

/*
==============
BG_PlayerHasCompatibleWeapon
==============
*/

bool __fastcall BG_PlayerHasCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PlayerHasCompatibleWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_GetMountGunCenterScale
==============
*/

double __fastcall BG_GetMountGunCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountGunCenterScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_RechamberBoltTime
==============
*/

int __fastcall BG_RechamberBoltTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_RechamberBoltTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_IsLadderAiming
==============
*/

bool __fastcall BG_IsLadderAiming(const Weapon *currentWeapon, const playerState_s *ps, bool isAlternate)
{
  return ?BG_IsLadderAiming@@YA_NAEBUWeapon@@PEBUplayerState_s@@_N@Z(currentWeapon, ps, isAlternate);
}

/*
==============
BG_GetScopeDriftDelay
==============
*/

double __fastcall BG_GetScopeDriftDelay(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftDelay@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ValidateWeaponNumberOffhand
==============
*/

bool __fastcall BG_ValidateWeaponNumberOffhand(const Weapon *r_weapon)
{
  return ?BG_ValidateWeaponNumberOffhand@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetScopeDriftUnsteadyFactor
==============
*/

double __fastcall BG_GetScopeDriftUnsteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftUnsteadyFactor@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AimAssistSlowdown
==============
*/

void __fastcall BG_AimAssistSlowdown(const Weapon *r_weapon, bool isAlternate, float *aimAssistPitchSlowdown, float *aimAssistPitchSlowdownAds, float *aimAssistYawSlowdown, float *aimAssistYawSlowdownAds)
{
  ?BG_AimAssistSlowdown@@YAXAEBUWeapon@@_NPEAM222@Z(r_weapon, isAlternate, aimAssistPitchSlowdown, aimAssistPitchSlowdownAds, aimAssistYawSlowdown, aimAssistYawSlowdownAds);
}

/*
==============
BG_UpdateVisibilitySlingBones
==============
*/

void __fastcall BG_UpdateVisibilitySlingBones(const entityState_t *es, DObj *obj, bool isClientCorpse, const Weapon *r_heldWeapon, const Weapon *r_stowedWeapon, int heldWeaponIndex, int stowedWeaponIndex, bool clientOnly, bool forceShowBones)
{
  ?BG_UpdateVisibilitySlingBones@@YAXPEBUentityState_t@@PEAUDObj@@_NAEBUWeapon@@3HH22@Z(es, obj, isClientCorpse, r_heldWeapon, r_stowedWeapon, heldWeaponIndex, stowedWeaponIndex, clientOnly, forceShowBones);
}

/*
==============
BG_GetNotetrackOverrides
==============
*/

bool __fastcall BG_GetNotetrackOverrides(const Weapon *r_weapon, bool isAlternate, unsigned int *numMappings, const scr_string_t **keys, const scr_string_t **values)
{
  return ?BG_GetNotetrackOverrides@@YA_NAEBUWeapon@@_NPEAIPEAPEBW4scr_string_t@@3@Z(r_weapon, isAlternate, numMappings, keys, values);
}

/*
==============
BG_Weapons_AttachHeldWeapon
==============
*/

unsigned __int16 __fastcall BG_Weapons_AttachHeldWeapon(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, int *outWeaponModelIndex1, int *outWeaponModelIndex2, bool isServer, XAnimWeaponIKModelsContainer *outWeaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_Weapons_AttachHeldWeapon@@YAGPEAUDObjModel@@GPEBUcharacterInfo_t@@PEAH2_NPEAVXAnimWeaponIKModelsContainer@@AEAY0CA@W4CharacterModelType@@@Z(dobjModels, numModels, ci, outWeaponModelIndex1, outWeaponModelIndex2, isServer, outWeaponIKModels, outModelTypes);
}

/*
==============
BG_GetMeleeAutoAimHeight
==============
*/

double __fastcall BG_GetMeleeAutoAimHeight(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimHeight@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetWeaponFlashTagname
==============
*/

TagPair *__fastcall BG_GetWeaponFlashTagname(TagPair *result, const Weapon *r_weapon, bool isAlternate, int chamberIndex)
{
  return ?BG_GetWeaponFlashTagname@@YA?AVTagPair@@AEBUWeapon@@_NH@Z(result, r_weapon, isAlternate, chamberIndex);
}

/*
==============
BG_WeaponBulletFire_GetClientHitEvent
==============
*/

unsigned int __fastcall BG_WeaponBulletFire_GetClientHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  return ?BG_WeaponBulletFire_GetClientHitEvent@@YAII_N@Z(meansOfDeath, serverPlayerHitEvent);
}

/*
==============
BG_GetHudOutlineInScopeColor
==============
*/

void __fastcall BG_GetHudOutlineInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineInScopeColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_GetWeaponSoundLookup
==============
*/

SndAliasLookup __fastcall BG_GetWeaponSoundLookup(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSoundLookup@@YA?AUSndAliasLookup@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_GetHudOutlineWeapon
==============
*/

bool __fastcall BG_GetHudOutlineWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_GetHudOutlineWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_WeaponCharge_GetChargeDownToUpSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeDownToUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeDownToUpSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_GetHandFromWeaponEvent
==============
*/

PlayerHandIndex __fastcall BG_GetHandFromWeaponEvent(int event)
{
  return ?BG_GetHandFromWeaponEvent@@YA?AW4PlayerHandIndex@@H@Z(event);
}

/*
==============
BG_Weapon_CheckFriendlyFire
==============
*/

bool __fastcall BG_Weapon_CheckFriendlyFire(const playerState_s *ps)
{
  return ?BG_Weapon_CheckFriendlyFire@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetOverrideAttachmentWhenApplicable
==============
*/

const WeaponAttachment *__fastcall BG_GetOverrideAttachmentWhenApplicable(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  return ?BG_GetOverrideAttachmentWhenApplicable@@YAPEBUWeaponAttachment@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEBU1@3@Z(weaponMap, ps, weapon, isAlternate, attachment, usingHybridScope);
}

/*
==============
BG_WeaponBulletFire_ShouldPenetrate
==============
*/

bool __fastcall BG_WeaponBulletFire_ShouldPenetrate(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ShouldPenetrate@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_ADSSpreadFractions
==============
*/

void __fastcall BG_ADSSpreadFractions(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, float *startFrac, float *endFrac)
{
  ?BG_ADSSpreadFractions@@YAXAEBUWeapon@@_N1AEAM2@Z(r_weapon, isAlternate, isUsingHybridScope, startFrac, endFrac);
}

/*
==============
BG_BuildWeaponAnimArrays
==============
*/

bool __fastcall BG_BuildWeaponAnimArrays(const playerState_s *ps, const Weapon *r_weapon, bool bIsDualWielding, bool bIsAlternate, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  return ?BG_BuildWeaponAnimArrays@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N2QEBURawWeaponAnimArrays@@PEAPEAUXAnimParts@@QEAPEBUBlendSpace2DDef@@45PEAUFootstepAnim@@W4weapAnimFiles_t@@H@Z(ps, r_weapon, bIsDualWielding, bIsAlternate, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
}

/*
==============
BG_AddStreamedViewWeaponsToList
==============
*/

bool __fastcall BG_AddStreamedViewWeaponsToList(const BgWeaponMap *const weaponMap, const playerState_s *const ps, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  return ?BG_AddStreamedViewWeaponsToList@@YA_NQEBVBgWeaponMap@@QEBUplayerState_s@@AEAY0BI@UWeapon@@AEAI@Z(weaponMap, ps, outViewWeapons, inOutWeaponCount);
}

/*
==============
BG_GetDynamicAttachmentSlot
==============
*/

AttachmentSlot __fastcall BG_GetDynamicAttachmentSlot(const DynamicAttachmentType dynamicAttachmentType)
{
  return ?BG_GetDynamicAttachmentSlot@@YA?AW4AttachmentSlot@@W4DynamicAttachmentType@@@Z(dynamicAttachmentType);
}

/*
==============
BG_CalculateRecoilInputScalar
==============
*/

double __fastcall BG_CalculateRecoilInputScalar(float kick, float move, float fkickAlignedInputScalar, float fkickOpposedInputScalar)
{
  double result; 

  *(float *)&result = ?BG_CalculateRecoilInputScalar@@YAMMMMM@Z(kick, move, fkickAlignedInputScalar, fkickOpposedInputScalar);
  return result;
}

/*
==============
BG_CanThermalToggle
==============
*/

bool __fastcall BG_CanThermalToggle(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_CanThermalToggle@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetClipLowAmmo
==============
*/

int __fastcall BG_GetClipLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetClipLowAmmo@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_DestabilizationCurvatureMax
==============
*/

double __fastcall BG_DestabilizationCurvatureMax(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_DestabilizationCurvatureMax@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_turretGetTagForFiringMuzzle
==============
*/

scr_string_t __fastcall BG_turretGetTagForFiringMuzzle(const entityState_t *es, const Weapon *r_weapon)
{
  return ?BG_turretGetTagForFiringMuzzle@@YA?AW4scr_string_t@@PEBUentityState_t@@AEBUWeapon@@@Z(es, r_weapon);
}

/*
==============
BG_GetReloadTimeScale
==============
*/

double __fastcall BG_GetReloadTimeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip, bool isUsingFastReloadStateTimer)
{
  double result; 

  *(float *)&result = ?BG_GetReloadTimeScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NH3@Z(weaponMap, ps, r_weapon, isAlternate, ammoInClip, isUsingFastReloadStateTimer);
  return result;
}

/*
==============
BG_GetWeaponAttachmentsWithIds
==============
*/

unsigned int __fastcall BG_GetWeaponAttachmentsWithIds(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  return ?BG_GetWeaponAttachmentsWithIds@@YAIAEBUWeapon@@_NQEAPEBUWeaponAttachment@@QEAE@Z(r_weapon, isAlternate, attachments, attachmentIds);
}

/*
==============
BG_PlayerWeaponGetSlot
==============
*/

WeaponSlot __fastcall BG_PlayerWeaponGetSlot(const Weapon *r_weapon)
{
  return ?BG_PlayerWeaponGetSlot@@YA?AW4WeaponSlot@@AEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_IsMeleeAnimMiss
==============
*/

bool __fastcall BG_IsMeleeAnimMiss(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnimMiss@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_GetAnimOverrideIdxForMeleeComboSeq
==============
*/

int __fastcall BG_GetAnimOverrideIdxForMeleeComboSeq(const Weapon *r_weapon, const int meleeComboSeqIdx)
{
  return ?BG_GetAnimOverrideIdxForMeleeComboSeq@@YAHAEBUWeapon@@H@Z(r_weapon, meleeComboSeqIdx);
}

/*
==============
BG_ReloadAmmoAdd
==============
*/

int __fastcall BG_ReloadAmmoAdd(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ReloadAmmoAdd@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Stepped
==============
*/

void __fastcall BG_BuildExplosionDamageRangeInfo_Stepped(const float innerRange, const float innerDamage, const float midRange, const float midDamage, const float outerRange, const float outerDamage, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  ?BG_BuildExplosionDamageRangeInfo_Stepped@@YAXMMMMMMAEAUBgExplosionDamageRangeInfo@@@Z(innerRange, innerDamage, midRange, midDamage, outerRange, outerDamage, outDamageRangeInfo);
}

/*
==============
BG_ReloadStartTime
==============
*/

int __fastcall BG_ReloadStartTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadStartTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetSlideSpreadWithDecay
==============
*/

void __fastcall BG_GetSlideSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMoveMax, float *outSlideSpreadMax, float *outSlideSpreadDecayRate, float *outSlideSpreadTurnAdd)
{
  ?BG_GetSlideSpreadWithDecay@@YAXAEBUWeapon@@_NPEAM2222@Z(r_weapon, isAlternate, outSlideSpreadMin, outSlideSpreadMoveMax, outSlideSpreadMax, outSlideSpreadDecayRate, outSlideSpreadTurnAdd);
}

/*
==============
BG_IsMeleeAnimFatal
==============
*/

bool __fastcall BG_IsMeleeAnimFatal(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnimFatal@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_ChargeWeaponOutTime
==============
*/

int __fastcall BG_ChargeWeaponOutTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ChargeWeaponOutTime@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@AEBUWeapon@@_N3@Z(ps, animIndex, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_CrawlLoopTime
==============
*/

int __fastcall BG_CrawlLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_CrawlLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MoveCycleSprintTime
==============
*/

int __fastcall BG_MoveCycleSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleSprintTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetADSZoomLevel
==============
*/

int __fastcall BG_GetADSZoomLevel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const int zoomCount)
{
  return ?BG_GetADSZoomLevel@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@H@Z(weaponMap, ps, r_weapon, zoomCount);
}

/*
==============
BG_GetADSZoomInfo
==============
*/

void __fastcall BG_GetADSZoomInfo(const BgWeaponMap *weaponMap, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, BgAdsZoomInfo *outZoomInfo)
{
  ?BG_GetADSZoomInfo@@YAXPEBVBgWeaponMap@@AEBUWeapon@@_NAEBUBgHybridScopeFraction@@AEAUBgAdsZoomInfo@@@Z(weaponMap, r_weapon, isAlternate, hybridScopeFractionInfo, outZoomInfo);
}

/*
==============
BG_GetDamage
==============
*/

int __fastcall BG_GetDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetDamage@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_N@Z(damageCalcType, r_weapon, isAlternate);
}

/*
==============
BG_IsBoneVisibleOnEitherHand
==============
*/

bool __fastcall BG_IsBoneVisibleOnEitherHand(const LocalClientNum_t localClientNum, const char *bone)
{
  return ?BG_IsBoneVisibleOnEitherHand@@YA_NW4LocalClientNum_t@@PEBD@Z(localClientNum, bone);
}

/*
==============
BG_ChargeWeaponInTime
==============
*/

int __fastcall BG_ChargeWeaponInTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ChargeWeaponInTime@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@AEBUWeapon@@_N3@Z(ps, animIndex, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetGrenadePrimeTime
==============
*/

void __fastcall BG_GetGrenadePrimeTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  ?BG_GetGrenadePrimeTime@@YAXPEBUplayerState_s@@AEBUWeapon@@_NPEAH@Z(ps, r_weapon, isAlternate, time);
}

/*
==============
BG_GetAdsDownAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsDownAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsDownAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_StartingKickBullets
==============
*/

int __fastcall BG_StartingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_StartingKickBullets@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetScopeDriftSteadyTime
==============
*/

double __fastcall BG_GetScopeDriftSteadyTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftSteadyTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsAttachmentHybridThermal
==============
*/

bool __fastcall BG_IsAttachmentHybridThermal(const WeaponAttachment *attachment)
{
  return ?BG_IsAttachmentHybridThermal@@YA_NPEBUWeaponAttachment@@@Z(attachment);
}

/*
==============
BG_CalculateKickMovement
==============
*/

bool __fastcall BG_CalculateKickMovement(float fTimeStep, const vec2_t *maxAngles, float kickPitchScale, float kickYawScale, float recenterAngAcceleration, float fReturnAccelScale, float fReturnSpeedCurveScale, vec2_t *inOutAngles, vec2_t *inOutAngularVel, bool *inOutKickNeedsToCrossCenter)
{
  return ?BG_CalculateKickMovement@@YA_NMAEBTvec2_t@@MMMMMAEAT1@1AEA_N@Z(fTimeStep, maxAngles, kickPitchScale, kickYawScale, recenterAngAcceleration, fReturnAccelScale, fReturnSpeedCurveScale, inOutAngles, inOutAngularVel, inOutKickNeedsToCrossCenter);
}

/*
==============
BG_ViewLastShotEjectEffect
==============
*/

FxCombinedDef __fastcall BG_ViewLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ViewLastShotEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
RawWeaponAnimArrays::RawWeaponAnimArrays
==============
*/

void __fastcall RawWeaponAnimArrays::RawWeaponAnimArrays(RawWeaponAnimArrays *this)
{
  ??0RawWeaponAnimArrays@@QEAA@XZ(this);
}

/*
==============
BG_ScopeOutlinesEnemies
==============
*/

bool __fastcall BG_ScopeOutlinesEnemies(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesEnemies@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_HideSlingBonesForDObj
==============
*/

void __fastcall BG_HideSlingBonesForDObj(DObj *obj, bool hideBones)
{
  ?BG_HideSlingBonesForDObj@@YAXPEAUDObj@@_N@Z(obj, hideBones);
}

/*
==============
BG_WeaponCharge_GetCostPerShot
==============
*/

double __fastcall BG_WeaponCharge_GetCostPerShot(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetCostPerShot@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetWeaponFieldTimeWithDependentAnimation
==============
*/

unsigned __int16 __fastcall BG_GetWeaponFieldTimeWithDependentAnimation(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset, const weapAnimFiles_t dependentAnimType)
{
  return ?BG_GetWeaponFieldTimeWithDependentAnimation@@YAGPEBUplayerState_s@@AEBUWeapon@@_N2_JW4weapAnimFiles_t@@@Z(ps, r_weapon, isAlternate, isDualWielding, offset, dependentAnimType);
}

/*
==============
BG_GetWeaponFireType
==============
*/

weapFireType_t __fastcall BG_GetWeaponFireType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponFireType@@YA?AW4weapFireType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsExecutionDog
==============
*/

bool __fastcall BG_IsExecutionDog(const Weapon *weapon)
{
  return ?BG_IsExecutionDog@@YA_NAEBUWeapon@@@Z(weapon);
}

/*
==============
BG_UsesShelvedDamageFalloff
==============
*/

bool __fastcall BG_UsesShelvedDamageFalloff(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UsesShelvedDamageFalloff@@YA_NW4WeaponDamageCalcType@@AEBUWeapon@@_N@Z(damageCalcType, r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponBurstCount
==============
*/

int __fastcall BG_GetWeaponBurstCount(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponBurstCount@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LeapCancelTime
==============
*/

int __fastcall BG_LeapCancelTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LeapCancelTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_PlayerWeaponGetCycleSlot
==============
*/

WeaponSlot __fastcall BG_PlayerWeaponGetCycleSlot(WeaponSlot currentSlot, int cycleSlot)
{
  return ?BG_PlayerWeaponGetCycleSlot@@YA?AW4WeaponSlot@@W41@H@Z(currentSlot, cycleSlot);
}

/*
==============
BG_Weapons_IsRiotShieldModel
==============
*/

int __fastcall BG_Weapons_IsRiotShieldModel(const XModel *weapModel)
{
  return ?BG_Weapons_IsRiotShieldModel@@YAHPEBUXModel@@@Z(weapModel);
}

/*
==============
BG_GetWeaponSfxPackageSoundWithFallback
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSfxPackageSoundWithFallback(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  return ?BG_GetWeaponSfxPackageSoundWithFallback@@YAPEBUSndAliasList@@PEBUWeaponSFXPackage@@_J@Z(sfxPackage, offset);
}

/*
==============
BG_WeapHasGestureDetonation
==============
*/

bool __fastcall BG_WeapHasGestureDetonation(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeapHasGestureDetonation@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AltDropTime
==============
*/

int __fastcall BG_AltDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_DebugSniperScene
==============
*/

void __fastcall BG_DebugSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, float frac)
{
  ?BG_DebugSniperScene@@YAXAEBUWeapon@@_NPEAUDObj@@M@Z(r_weapon, isAlternate, obj, frac);
}

/*
==============
BG_UnpackClientWeaponFireEventParm
==============
*/

void __fastcall BG_UnpackClientWeaponFireEventParm(const unsigned int eventParm, tmat33_t<vec3_t> *outFireAxis)
{
  ?BG_UnpackClientWeaponFireEventParm@@YAXIAEAT?$tmat33_t@Tvec3_t@@@@@Z(eventParm, outFireAxis);
}

/*
==============
BG_GetMeleeTime
==============
*/

void __fastcall BG_GetMeleeTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outMeleeTime, int *outMeleeDamageTime, int *outMeleeViewLockTime)
{
  ?BG_GetMeleeTime@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@_N22PEAH33@Z(weaponMap, ps, isAlternate, isDualWielding, isFatal, outMeleeTime, outMeleeDamageTime, outMeleeViewLockTime);
}

/*
==============
BG_GetImpactDamageAndModForProjectile
==============
*/

int __fastcall BG_GetImpactDamageAndModForProjectile(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, float rangeScale, const vec3_t *origStart, vec3_t *hitPos, meansOfDeath_t *outMOD)
{
  return ?BG_GetImpactDamageAndModForProjectile@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_NMAEBTvec3_t@@AEAT3@PEAW4meansOfDeath_t@@@Z(damageCalcType, r_weapon, isAlternate, rangeScale, origStart, hitPos, outMOD);
}

/*
==============
BG_GetMinDamage
==============
*/

int __fastcall BG_GetMinDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetMinDamage@@YAHW4WeaponDamageCalcType@@AEBUWeapon@@_N@Z(damageCalcType, r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetChargeDownSound
==============
*/

SndAliasLookup __fastcall BG_WeaponCharge_GetChargeDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  return ?BG_WeaponCharge_GetChargeDownSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayerView);
}

/*
==============
BG_GetWeaponSoundWithWeaponSfxPackageFallback
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSoundWithWeaponSfxPackageFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSoundWithWeaponSfxPackageFallback@@YAPEBUSndAliasList@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_UseScopeDrift
==============
*/

int __fastcall BG_UseScopeDrift(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_UseScopeDrift@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_ProjBeaconEffect
==============
*/

FxCombinedDef __fastcall BG_ProjBeaconEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjBeaconEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AddCarryObjectModel_Internal<characterInfo_t>
==============
*/

int __fastcall BG_AddCarryObjectModel_Internal<characterInfo_t>(const int entityNum, const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ??$BG_AddCarryObjectModel_Internal@UcharacterInfo_t@@@@YAHHPEBUcharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entityNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetSideReticle
==============
*/

void __fastcall BG_GetSideReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleSide, int *reticleSideSize, bool *spin45)
{
  ?BG_GetSideReticle@@YAXAEBUWeapon@@_NPEAPEAUMaterial@@PEAHPEA_N@Z(r_weapon, isAlternate, reticleSide, reticleSideSize, spin45);
}

/*
==============
BG_ScopeToggleOnInterruptTime
==============
*/

int __fastcall BG_ScopeToggleOnInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOnInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetReloadType
==============
*/

ReloadType __fastcall BG_GetReloadType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetReloadType@@YA?AW4ReloadType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PickUpIcon
==============
*/

GfxImage *__fastcall BG_PickUpIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PickUpIcon@@YAPEAUGfxImage@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponAltReloadAnimsEnabled
==============
*/

bool __fastcall BG_GetWeaponAltReloadAnimsEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_GetWeaponAltReloadAnimsEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseFastADSAnims
==============
*/

bool __fastcall BG_UseFastADSAnims(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseFastADSAnims@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponCharge_GetRumble
==============
*/

RumbleInfo *__fastcall BG_WeaponCharge_GetRumble(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponCharge_GetRumble@@YAPEAURumbleInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadEndRechamberTime
==============
*/

int __fastcall BG_ReloadEndRechamberTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, int *outShellEjectTime, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEndRechamberTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEAHAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, outShellEjectTime, hasFastReloadOverride);
}

/*
==============
BG_GetMountGunKickScale
==============
*/

double __fastcall BG_GetMountGunKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMountGunKickScale@@YAMW4ContextMountType@@AEBUWeapon@@_N@Z(mountType, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetGrenadePrimeReadyToThrowTime
==============
*/

void __fastcall BG_GetGrenadePrimeReadyToThrowTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  ?BG_GetGrenadePrimeReadyToThrowTime@@YAXPEBUplayerState_s@@AEBUWeapon@@_NPEAH@Z(ps, r_weapon, isAlternate, time);
}

/*
==============
BG_GetAdsSettleAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsSettleAnim(const playerState_s *ps, const PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsSettleAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@W4PlayerHandIndex@@PEBVBgHandler@@@Z(ps, hand, pmoveHandler);
}

/*
==============
BG_GetADSZoomInFracs
==============
*/

void __fastcall BG_GetADSZoomInFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const bool getWeaponValues, float *adsZoomInFrac, float *adsZoomOutFrac)
{
  ?BG_GetADSZoomInFracs@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N_NPEAM5@Z(weaponMap, ps, r_weapon, isAlternate, getWeaponValues, adsZoomInFrac, adsZoomOutFrac);
}

/*
==============
BG_PreFireTime
==============
*/

int __fastcall BG_PreFireTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_PreFireTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_HasDefaultWorldModel
==============
*/

bool __fastcall BG_HasDefaultWorldModel(const Weapon *r_weapon)
{
  return ?BG_HasDefaultWorldModel@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetMultipleReloadClipPercentage
==============
*/

double __fastcall BG_GetMultipleReloadClipPercentage(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMultipleReloadClipPercentage@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetFireAnimTime
==============
*/

int __fastcall BG_GetFireAnimTime(const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const playerState_s *const ps, const BgHandler *pmoveHandler, const weapAnimFiles_t anim)
{
  return ?BG_GetFireAnimTime@@YAHAEBUWeapon@@_N1QEBUplayerState_s@@PEBVBgHandler@@W4weapAnimFiles_t@@@Z(r_weapon, isAlternate, isDualWielding, ps, pmoveHandler, anim);
}

/*
==============
BG_GetKickAlignedInputScalar
==============
*/

double __fastcall BG_GetKickAlignedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetKickAlignedInputScalar@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetExplosionDamageRangeInfo
==============
*/

void __fastcall BG_GetExplosionDamageRangeInfo(const Weapon *r_weapon, bool isAlternate, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  ?BG_GetExplosionDamageRangeInfo@@YAXAEBUWeapon@@_NAEAUBgExplosionDamageRangeInfo@@@Z(r_weapon, isAlternate, outDamageRangeInfo);
}

/*
==============
BG_IsIncendiaryBullet
==============
*/

bool __fastcall BG_IsIncendiaryBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsIncendiaryBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponAttachmentAdsSmoothFade
==============
*/

bool __fastcall BG_WeaponAttachmentAdsSmoothFade(const Weapon *r_weapon, const bool isAlternate)
{
  return ?BG_WeaponAttachmentAdsSmoothFade@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetOnePieceReticle
==============
*/

Material *__fastcall BG_GetOnePieceReticle(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOnePieceReticle@@YAPEAUMaterial@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LadderClimbRaiseTime
==============
*/

int __fastcall BG_LadderClimbRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderClimbRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetTargetAssistAngleRange
==============
*/

void __fastcall BG_GetTargetAssistAngleRange(const Weapon *r_weapon, bool isAlternate, const float fallbackAngle, const float fallbackRange, float *outAngle, float *outRange)
{
  ?BG_GetTargetAssistAngleRange@@YAXAEBUWeapon@@_NMMPEAM2@Z(r_weapon, isAlternate, fallbackAngle, fallbackRange, outAngle, outRange);
}

/*
==============
BG_AllowWeaponSwitchWhileHoldingGrenade
==============
*/

bool __fastcall BG_AllowWeaponSwitchWhileHoldingGrenade(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AllowWeaponSwitchWhileHoldingGrenade@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetADSHandheldCamScale
==============
*/

void __fastcall BG_GetADSHandheldCamScale(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, bool isAlternate, float *outAdsRotationScale, float *outAdsTranslationScale)
{
  ?BG_GetADSHandheldCamScale@@YAXPEBUplayerState_s@@AEBUBgHybridScopeFraction@@AEBUWeapon@@_NPEAM4@Z(ps, hybridScopeFraction, weapon, isAlternate, outAdsRotationScale, outAdsTranslationScale);
}

/*
==============
BG_GetOffhandClass
==============
*/

OffhandClass __fastcall BG_GetOffhandClass(const playerState_s *ps, const OffhandSlot slot, const BgWeaponMap *weaponMap)
{
  return ?BG_GetOffhandClass@@YA?AW4OffhandClass@@PEBUplayerState_s@@W4OffhandSlot@@PEBVBgWeaponMap@@@Z(ps, slot, weaponMap);
}

/*
==============
BG_SkydiveSuperDiveInTime
==============
*/

int __fastcall BG_SkydiveSuperDiveInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveSuperDiveInTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetViewAndGunKickScalars
==============
*/

void __fastcall BG_GetViewAndGunKickScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outViewKickPitchScale, float *outViewKickYawScale, float *outGunKickPitchScale, float *outGunKickYawScale)
{
  ?BG_GetViewAndGunKickScalars@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEAM444@Z(weaponMap, ps, r_weapon, isAlternate, outViewKickPitchScale, outViewKickYawScale, outGunKickPitchScale, outGunKickYawScale);
}

/*
==============
BG_IsSwimWeapon
==============
*/

bool __fastcall BG_IsSwimWeapon(const Weapon *r_weapon)
{
  return ?BG_IsSwimWeapon@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_ViewModelAnimExists
==============
*/

int __fastcall BG_ViewModelAnimExists(const playerState_s *ps, weapAnimFiles_t anim, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  return ?BG_ViewModelAnimExists@@YAHPEBUplayerState_s@@W4weapAnimFiles_t@@W4PlayerHandIndex@@PEBVBgHandler@@@Z(ps, anim, hand, pmoveHandler);
}

/*
==============
BG_AssertOffhandIndexOrNone
==============
*/

void __fastcall BG_AssertOffhandIndexOrNone(const Weapon *r_weapon)
{
  ?BG_AssertOffhandIndexOrNone@@YAXAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_MoveCycleWalkTime
==============
*/

int __fastcall BG_MoveCycleWalkTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_MoveCycleWalkTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetMotionBlurProperties
==============
*/

void __fastcall BG_GetMotionBlurProperties(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, const bool isAlternate, const float adsLerp, float *outBlur, int *outBlurDurationMs, float *outBlurDecayExponent)
{
  ?BG_GetMotionBlurProperties@@YAXPEBUplayerState_s@@AEBUBgHybridScopeFraction@@AEBUWeapon@@_NMAEAMAEAH4@Z(ps, hybridScopeFraction, weapon, isAlternate, adsLerp, outBlur, outBlurDurationMs, outBlurDecayExponent);
}

/*
==============
BG_WeaponRadiusDamageDetailTrace
==============
*/

bool __fastcall BG_WeaponRadiusDamageDetailTrace(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponRadiusDamageDetailTrace@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetSwaySettings
==============
*/

void __fastcall BG_GetSwaySettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, SwaySettings *outSwaySettings)
{
  ?BG_GetSwaySettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAUSwaySettings@@@Z(weaponMap, ps, r_weapon, isAlternate, outSwaySettings);
}

/*
==============
BG_WeaponStickinessType
==============
*/

WeapStickinessType __fastcall BG_WeaponStickinessType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponStickinessType@@YA?AW4WeapStickinessType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_GetExplDmgMin
==============
*/

double __fastcall BG_WeaponBulletFire_GetExplDmgMin(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponBulletFire_GetExplDmgMin@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HasUnderbarrelAttachment
==============
*/

bool __fastcall BG_HasUnderbarrelAttachment(const Weapon *r_weapon, bool isAlternate, const scr_string_t attachmentName)
{
  return ?BG_HasUnderbarrelAttachment@@YA_NAEBUWeapon@@_NW4scr_string_t@@@Z(r_weapon, isAlternate, attachmentName);
}

/*
==============
BG_WorldFlashEffect
==============
*/

FxCombinedDef __fastcall BG_WorldFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  return ?BG_WorldFlashEffect@@YA?AUFxCombinedDef@@V?$bitarray@$0EA@@@AEBUWeapon@@_N2@Z(perks, r_weapon, isAlternate, isFirstFlash);
}

/*
==============
BG_Weapon_OffhandDisabled
==============
*/

OffhandDisableResult __fastcall BG_Weapon_OffhandDisabled(const playerState_s *ps)
{
  return ?BG_Weapon_OffhandDisabled@@YA?AW4OffhandDisableResult@@PEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_UpdatedWeaponBones
==============
*/

void __fastcall BG_UpdatedWeaponBones(const Weapon *r_weapon, DObj *obj, int startModel)
{
  ?BG_UpdatedWeaponBones@@YAXAEBUWeapon@@PEAUDObj@@H@Z(r_weapon, obj, startModel);
}

/*
==============
BG_Weapons_GetAttachBone
==============
*/

scr_string_t __fastcall BG_Weapons_GetAttachBone(const characterInfo_t *ci, weapType_t weapType, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand)
{
  return ?BG_Weapons_GetAttachBone@@YA?AW4scr_string_t@@PEBUcharacterInfo_t@@W4weapType_t@@AEBUWeapon@@_NW4PlayerHandIndex@@@Z(ci, weapType, r_weapon, isAlternate, hand);
}

/*
==============
BG_DamageConeAngle
==============
*/

double __fastcall BG_DamageConeAngle(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_DamageConeAngle@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_HasDualFOVEquipped
==============
*/

bool __fastcall BG_HasDualFOVEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_HasDualFOVEquipped@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_ProjImpactExplode
==============
*/

bool __fastcall BG_ProjImpactExplode(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjImpactExplode@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponClass
==============
*/

weapClass_t __fastcall BG_GetWeaponClass(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponClass@@YA?AW4weapClass_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetDamageViewKickScaleValues
==============
*/

void __fastcall BG_GetDamageViewKickScaleValues(const playerState_s *ps, const usercmd_s *cmd, float *viewKickScale, float *viewKickMin, float *viewKickMax)
{
  ?BG_GetDamageViewKickScaleValues@@YAXPEBUplayerState_s@@PEBUusercmd_s@@PEAM22@Z(ps, cmd, viewKickScale, viewKickMin, viewKickMax);
}

/*
==============
BG_GetWeaponInspectEnabled
==============
*/

bool __fastcall BG_GetWeaponInspectEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponInspectEnabled@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsArmorPiercing
==============
*/

bool __fastcall BG_IsArmorPiercing(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsArmorPiercing@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjIgnitionEffect
==============
*/

FxCombinedDef __fastcall BG_ProjIgnitionEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjIgnitionEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetTopMountYawMax
==============
*/

double __fastcall BG_GetTopMountYawMax(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetTopMountYawMax@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_RemoveIgnoreEntFromBP
==============
*/

void __fastcall BG_RemoveIgnoreEntFromBP(BulletFireParams *bp, int entityIndex)
{
  ?BG_RemoveIgnoreEntFromBP@@YAXPEAUBulletFireParams@@H@Z(bp, entityIndex);
}

/*
==============
BG_GetHudOutlineFillColor0
==============
*/

void __fastcall BG_GetHudOutlineFillColor0(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineFillColor0@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_GetADSTransTimes
==============
*/

void __fastcall BG_GetADSTransTimes(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsTransInSpeedMs, float *outAdsTransOutSpeedMs)
{
  ?BG_GetADSTransTimes@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4@Z(weaponMap, ps, r_weapon, isAlternate, outAdsTransInSpeedMs, outAdsTransOutSpeedMs);
}

/*
==============
BG_GetGunKickMaxAngles
==============
*/

void __fastcall BG_GetGunKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  ?BG_GetGunKickMaxAngles@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEATvec2_t@@@Z(weaponMap, ps, r_weapon, isAlternate, outMaxAngles);
}

/*
==============
BG_ClearPlayerWeapons
==============
*/

void __fastcall BG_ClearPlayerWeapons(BgWeaponMap *weaponMap, playerState_s *ps)
{
  ?BG_ClearPlayerWeapons@@YAXPEAVBgWeaponMap@@PEAUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_HoldBreathMaxTime
==============
*/

int __fastcall BG_HoldBreathMaxTime(const playerState_s *const ps)
{
  return ?BG_HoldBreathMaxTime@@YAHQEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_ExplosionRadius
==============
*/

int __fastcall BG_ExplosionRadius(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ExplosionRadius@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelPlayerState
==============
*/

int __fastcall BG_WeaponDoesNotFullyAnimateViewmodelPlayerState(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponDoesNotFullyAnimateViewmodelPlayerState@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_MapWeaponAnimStateToMeleeAnimIndex
==============
*/

weapAnimFiles_t __fastcall BG_MapWeaponAnimStateToMeleeAnimIndex(const playerState_s *ps, bool previous, int animState)
{
  return ?BG_MapWeaponAnimStateToMeleeAnimIndex@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@_NH@Z(ps, previous, animState);
}

/*
==============
BG_ClearMLGSpectatorClientWeapons
==============
*/

void __fastcall BG_ClearMLGSpectatorClientWeapons(BgWeaponMap *weaponMap, MLGSpectatorClientInfo *mlgSpectatorClientInfo)
{
  ?BG_ClearMLGSpectatorClientWeapons@@YAXPEAVBgWeaponMap@@PEAUMLGSpectatorClientInfo@@@Z(weaponMap, mlgSpectatorClientInfo);
}

/*
==============
BG_SkydiveParachuteSlowHardLandingVelocity
==============
*/

double __fastcall BG_SkydiveParachuteSlowHardLandingVelocity(const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_SkydiveParachuteSlowHardLandingVelocity@@YAMPEBUplayerState_s@@@Z(ps);
  return result;
}

/*
==============
BG_WeaponCharge_GetGain
==============
*/

double __fastcall BG_WeaponCharge_GetGain(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponCharge_GetGain@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_IsTargetAssistActive
==============
*/

bool __fastcall BG_IsTargetAssistActive(const playerState_s *ps, const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsTargetAssistActive@@YA_NPEBUplayerState_s@@PEBUentityState_t@@AEBUWeapon@@_N@Z(ps, es, r_weapon, isAlternate);
}

/*
==============
BG_ScopeToggleOffInterruptTime
==============
*/

int __fastcall BG_ScopeToggleOffInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ScopeToggleOffInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponGetAltModePlayerAnimType
==============
*/

int __fastcall BG_WeaponGetAltModePlayerAnimType(const Weapon *r_weapon)
{
  return ?BG_WeaponGetAltModePlayerAnimType@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_LadderVaultTime
==============
*/

int __fastcall BG_LadderVaultTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderVaultTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_SkydiveParachuteMidAirDetachTime
==============
*/

int __fastcall BG_SkydiveParachuteMidAirDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveParachuteMidAirDetachTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
TagPair::SetFallbackTagName
==============
*/

void __fastcall TagPair::SetFallbackTagName(TagPair *this, scr_string_t tagName)
{
  ?SetFallbackTagName@TagPair@@QEAAXW4scr_string_t@@@Z(this, tagName);
}

/*
==============
BG_IsImpalingBullet
==============
*/

bool __fastcall BG_IsImpalingBullet(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsImpalingBullet@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetOffhandMaxHoldTime
==============
*/

int __fastcall BG_GetOffhandMaxHoldTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOffhandMaxHoldTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UseSmoothGunKick
==============
*/

bool __fastcall BG_UseSmoothGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UseSmoothGunKick@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_UsesReverseWeaponSpread
==============
*/

bool __fastcall BG_UsesReverseWeaponSpread(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_UsesReverseWeaponSpread@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PackClientWeaponFireEventParm
==============
*/

unsigned int __fastcall BG_PackClientWeaponFireEventParm(const tmat33_t<vec3_t> *fireAxis)
{
  return ?BG_PackClientWeaponFireEventParm@@YAIAEBT?$tmat33_t@Tvec3_t@@@@@Z(fireAxis);
}

/*
==============
BG_ThrowBackIcon
==============
*/

Material *__fastcall BG_ThrowBackIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ThrowBackIcon@@YAPEAUMaterial@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ProjTrajectoryEvents
==============
*/

bool __fastcall BG_ProjTrajectoryEvents(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjTrajectoryEvents@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ShouldRicochet
==============
*/

bool __fastcall BG_WeaponBulletFire_ShouldRicochet(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_ShouldRicochet@@YA_NV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_Weapon_GetCameraFireEffect
==============
*/

FxCombinedDef __fastcall BG_Weapon_GetCameraFireEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_Weapon_GetCameraFireEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsThrowingAxe
==============
*/

bool __fastcall BG_IsThrowingAxe(const Weapon *r_weapon)
{
  return ?BG_IsThrowingAxe@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BgWeaponScalarAccumulator::GetFinalValue
==============
*/

double __fastcall BgWeaponScalarAccumulator::GetFinalValue(BgWeaponScalarAccumulator *this, const float baseValue)
{
  double result; 

  *(float *)&result = ?GetFinalValue@BgWeaponScalarAccumulator@@QEBAMM@Z(this, baseValue);
  return result;
}

/*
==============
BG_WeaponAnimNumberExists
==============
*/

int __fastcall BG_WeaponAnimNumberExists(const BgWeaponMap *weaponMap, const playerState_s *ps, int weaponAnimNumber, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  return ?BG_WeaponAnimNumberExists@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@HW4PlayerHandIndex@@PEBVBgHandler@@@Z(weaponMap, ps, weaponAnimNumber, hand, pmoveHandler);
}

/*
==============
BG_InADS
==============
*/

bool __fastcall BG_InADS(const playerState_s *ps)
{
  return ?BG_InADS@@YA_NPEBUplayerState_s@@@Z(ps);
}

/*
==============
BG_GetWeaponFireEventBoneIndex
==============
*/

int __fastcall BG_GetWeaponFireEventBoneIndex(unsigned int param)
{
  return ?BG_GetWeaponFireEventBoneIndex@@YAHI@Z(param);
}

/*
==============
BG_WeaponSticksToFloors
==============
*/

bool __fastcall BG_WeaponSticksToFloors(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToFloors@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsUsingHybridScope
==============
*/

bool __fastcall BG_IsUsingHybridScope(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  return ?BG_IsUsingHybridScope@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_GetWeaponEffect
==============
*/

FxCombinedDef __fastcall BG_GetWeaponEffect(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
BG_GetADSNVGFOVXOffset
==============
*/

double __fastcall BG_GetADSNVGFOVXOffset(const Weapon *r_weapon, const bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSNVGFOVXOffset@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_Weapons_AttachHeldWeaponIKTargets
==============
*/

unsigned __int16 __fastcall BG_Weapons_AttachHeldWeaponIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModelLeft, XModel *ikTargetModelRight, bool isServer, unsigned int *inOutFirstWeaponModelIdx, unsigned int *inOutFirstWeaponBoneIdx, int *heldWeaponModelIdx1, int *heldWeaponModelIdx2, int *stowedWeaponModelIdx, const XAnimWeaponIKModelsContainer *weaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_Weapons_AttachHeldWeaponIKTargets@@YAGPEAUDObjModel@@GPEBUcharacterInfo_t@@PEAUXModel@@2_NPEAI4PEAH55PEBVXAnimWeaponIKModelsContainer@@AEAY0CA@W4CharacterModelType@@@Z(dobjModels, numModels, ci, ikTargetModelLeft, ikTargetModelRight, isServer, inOutFirstWeaponModelIdx, inOutFirstWeaponBoneIdx, heldWeaponModelIdx1, heldWeaponModelIdx2, stowedWeaponModelIdx, weaponIKModels, outModelTypes);
}

/*
==============
BG_CopyPlayerWeapons
==============
*/

void __fastcall BG_CopyPlayerWeapons(BgWeaponMap *dstWeaponMap, playerState_s *dstPs, const BgWeaponMap *srcWeaponMap, const playerState_s *srcPs)
{
  ?BG_CopyPlayerWeapons@@YAXPEAVBgWeaponMap@@PEAUplayerState_s@@PEBV1@PEBU2@@Z(dstWeaponMap, dstPs, srcWeaponMap, srcPs);
}

/*
==============
BG_RequiredAmmoPerShot
==============
*/

int __fastcall BG_RequiredAmmoPerShot(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_RequiredAmmoPerShot@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponSound
==============
*/

const SndAliasList *__fastcall BG_GetWeaponSound(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  return ?BG_GetWeaponSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N_J@Z(r_weapon, isAlternate, offset);
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/

bool __fastcall TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType modelTypeToSearch, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  return ?GetTagNameAndBoneIndexForCharacter@TagPair@@QEBA_NPEBUDObj@@PEBUcharacterInfo_t@@W4CharacterModelType@@PEAW4scr_string_t@@PEAE@Z(this, obj, ci, modelTypeToSearch, outTagName, outBoneIndex);
}

/*
==============
BG_AlwaysFireAtMaxRangeInAds
==============
*/

bool __fastcall BG_AlwaysFireAtMaxRangeInAds(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AlwaysFireAtMaxRangeInAds@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_ViewMagEjectEffect
==============
*/

FxCombinedDef __fastcall BG_ViewMagEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ViewMagEjectEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponStreamedModels
==============
*/

unsigned int __fastcall BG_GetWeaponStreamedModels(const Weapon *weapon, const XModel *(*outList)[32], const bool viewModel)
{
  return ?BG_GetWeaponStreamedModels@@YAIAEBUWeapon@@AEAY0CA@PEBUXModel@@_N@Z(weapon, outList, viewModel);
}

/*
==============
BG_EmptyDropTime
==============
*/

int __fastcall BG_EmptyDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_EmptyDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_BlurSceneAdsOutFraction
==============
*/

double __fastcall BG_BlurSceneAdsOutFraction(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_BlurSceneAdsOutFraction@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetMountSideRoll
==============
*/

void __fastcall BG_GetMountSideRoll(const Weapon *r_weapon, bool isAlternate, float *outRollDeg, float *outStartFrac, float *outEndFrac)
{
  ?BG_GetMountSideRoll@@YAXAEBUWeapon@@_NAEAM22@Z(r_weapon, isAlternate, outRollDeg, outStartFrac, outEndFrac);
}

/*
==============
BG_QuickDropTime
==============
*/

int __fastcall BG_QuickDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_QuickDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_WeaponBulletFire_GetExplDmg
==============
*/

double __fastcall BG_WeaponBulletFire_GetExplDmg(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WeaponBulletFire_GetExplDmg@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetMeleeAutoAimWidth
==============
*/

double __fastcall BG_GetMeleeAutoAimWidth(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetMeleeAutoAimWidth@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_AdvanceTrace
==============
*/

bool __fastcall BG_AdvanceTrace(BulletFireParams *bp, const trace_t *trace, const vec3_t *hitPos, float dist)
{
  return ?BG_AdvanceTrace@@YA_NPEAUBulletFireParams@@PEBUtrace_t@@AEBTvec3_t@@M@Z(bp, trace, hitPos, dist);
}

/*
==============
BG_IsHighPrecisionClientFireEvent
==============
*/

bool __fastcall BG_IsHighPrecisionClientFireEvent(const int eventId)
{
  return ?BG_IsHighPrecisionClientFireEvent@@YA_NH@Z(eventId);
}

/*
==============
BG_ADSZoomCount
==============
*/

int __fastcall BG_ADSZoomCount(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ADSZoomCount@@YAHPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_AddGlobalAmmoForAmmoType
==============
*/

void __fastcall BG_AddGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  ?BG_AddGlobalAmmoForAmmoType@@YAXPEAUplayerState_s@@AEBUAmmoStore@@H@Z(ps, r_ammoType, ammoCount);
}

/*
==============
BG_AimAssistLockonStrength
==============
*/

double __fastcall BG_AimAssistLockonStrength(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_AimAssistLockonStrength@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_WeaponSticksToWalls
==============
*/

bool __fastcall BG_WeaponSticksToWalls(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToWalls@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_LadderAimDropInterruptTime
==============
*/

int __fastcall BG_LadderAimDropInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimDropInterruptTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ProjIgnitionDelay
==============
*/

int __fastcall BG_ProjIgnitionDelay(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjIgnitionDelay@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetClipSize
==============
*/

int __fastcall BG_GetClipSize(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetClipSize@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetExplosionReactiveMotionParams
==============
*/

void __fastcall BG_GetExplosionReactiveMotionParams(const Weapon *r_weapon, bool isAlternate, float *radiusScale, float *frequencyScale, float *amplitudeScale, float *falloff, float *lifetime)
{
  ?BG_GetExplosionReactiveMotionParams@@YAXAEBUWeapon@@_NPEAM2222@Z(r_weapon, isAlternate, radiusScale, frequencyScale, amplitudeScale, falloff, lifetime);
}

/*
==============
BG_WeaponFuseTime
==============
*/

int __fastcall BG_WeaponFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponFuseTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetHybridScopeInfo
==============
*/

void __fastcall BG_GetHybridScopeInfo(const Weapon *r_weapon, bool isAlternate, BgHybridScopeInfo *outHybridScopeInfo)
{
  ?BG_GetHybridScopeInfo@@YAXAEBUWeapon@@_NAEAUBgHybridScopeInfo@@@Z(r_weapon, isAlternate, outHybridScopeInfo);
}

/*
==============
BG_HasPredictedProjectileAttachment
==============
*/

bool __fastcall BG_HasPredictedProjectileAttachment(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HasPredictedProjectileAttachment@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ReloadEndTime
==============
*/

int __fastcall BG_ReloadEndTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  return ?BG_ReloadEndTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4HAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, ammoInClip, hasFastReloadOverride);
}

/*
==============
BG_GetWeaponOtherAttachment
==============
*/

const WeaponAttachment *__fastcall BG_GetWeaponOtherAttachment(const Weapon *r_weapon, const unsigned int otherIndex)
{
  return ?BG_GetWeaponOtherAttachment@@YAPEBUWeaponAttachment@@AEBUWeapon@@I@Z(r_weapon, otherIndex);
}

/*
==============
BG_GetHipSpread
==============
*/

void __fastcall BG_GetHipSpread(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMax)
{
  ?BG_GetHipSpread@@YAXAEBUWeapon@@_NPEAM222222222@Z(r_weapon, isAlternate, hipSpreadStandMin, hipSpreadStandMax, hipSpreadDuckedMin, hipSpreadDuckedMax, hipSpreadProneMin, hipSpreadProneMax, hipSpreadSprintMin, hipSpreadSprintMax, hipSpreadInAirMin, hipSpreadInAirMax);
}

/*
==============
BG_HasUnderbarrelGL
==============
*/

int __fastcall BG_HasUnderbarrelGL(const Weapon *r_weapon)
{
  return ?BG_HasUnderbarrelGL@@YAHAEBUWeapon@@@Z(r_weapon);
}

/*
==============
TagPair::TagPair
==============
*/

void __fastcall TagPair::TagPair(TagPair *this)
{
  ??0TagPair@@QEAA@XZ(this);
}

/*
==============
BG_AltOverride3PIsADS
==============
*/

bool __fastcall BG_AltOverride3PIsADS(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_AltOverride3PIsADS@@YA_NAEBUWeapon@@_N1@Z(r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_StowedOcclusionTestEnabled
==============
*/

bool __fastcall BG_StowedOcclusionTestEnabled(const Weapon *r_weapon)
{
  return ?BG_StowedOcclusionTestEnabled@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_SkydiveQuickOpenParachuteTime
==============
*/

int __fastcall BG_SkydiveQuickOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveQuickOpenParachuteTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_PredictionGetClientTrajectoryBlendOutTime
==============
*/

int __fastcall BG_PredictionGetClientTrajectoryBlendOutTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PredictionGetClientTrajectoryBlendOutTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetFirstAvailableOffhandBySlot
==============
*/

const Weapon *__fastcall BG_GetFirstAvailableOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  return ?BG_GetFirstAvailableOffhandBySlot@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@W4OffhandSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_IsWeaponHybridThermal
==============
*/

bool __fastcall BG_IsWeaponHybridThermal(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsWeaponHybridThermal@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_GetOverlay
==============
*/

const ADSOverlay *__fastcall BG_GetOverlay(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetOverlay@@YAPEBUADSOverlay@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_TurretStopSpinSound
==============
*/

SndAliasLookup __fastcall BG_TurretStopSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_TurretStopSpinSound@@YA?AUSndAliasLookup@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAdsUpAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetAdsUpAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_GetAdsUpAnim@@YA?AW4weapAnimFiles_t@@PEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_GetHipSpreadWithDecay
==============
*/

void __fastcall BG_GetHipSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMoveMax, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMoveMax, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMoveMax, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMoveMax, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMoveMax, float *hipSpreadInAirMax, float *hipSpreadDecayRate, float *hipSpreadProneDecay, float *hipSpreadDuckedDecay, float *hipSpreadSprintDecay, float *hipSpreadInAirDecay, float *hipSpreadTurnAdd, float *hipSpreadMoveAdd)
{
  ?BG_GetHipSpreadWithDecay@@YAXAEBUWeapon@@_NPEAM222222222222222222222@Z(r_weapon, isAlternate, hipSpreadStandMin, hipSpreadStandMoveMax, hipSpreadStandMax, hipSpreadDuckedMin, hipSpreadDuckedMoveMax, hipSpreadDuckedMax, hipSpreadProneMin, hipSpreadProneMoveMax, hipSpreadProneMax, hipSpreadSprintMin, hipSpreadSprintMoveMax, hipSpreadSprintMax, hipSpreadInAirMin, hipSpreadInAirMoveMax, hipSpreadInAirMax, hipSpreadDecayRate, hipSpreadProneDecay, hipSpreadDuckedDecay, hipSpreadSprintDecay, hipSpreadInAirDecay, hipSpreadTurnAdd, hipSpreadMoveAdd);
}

/*
==============
BG_GetHipIdleValues
==============
*/

void __fastcall BG_GetHipIdleValues(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, float *hipIdleAmount, float *adsIdleAmount, float *hipIdleSpeed, float *adsIdleSpeed)
{
  ?BG_GetHipIdleValues@@YAXV?$bitarray@$0EA@@@AEBUWeapon@@_NPEAM333@Z(perks, r_weapon, isAlternate, hipIdleAmount, adsIdleAmount, hipIdleSpeed, adsIdleSpeed);
}

/*
==============
BG_WarningIconsDelay
==============
*/

double __fastcall BG_WarningIconsDelay(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_WarningIconsDelay@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetScopeDriftLerpOutTime
==============
*/

double __fastcall BG_GetScopeDriftLerpOutTime(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetScopeDriftLerpOutTime@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_CanEquipWeapon
==============
*/

bool __fastcall BG_CanEquipWeapon(const BgWeaponMap *const weaponMap, const playerState_s *const ps, const Weapon *r_weapon)
{
  return ?BG_CanEquipWeapon@@YA_NQEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@@Z(weaponMap, ps, r_weapon);
}

/*
==============
BG_GungHoSprintLoopTime
==============
*/

int __fastcall BG_GungHoSprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_GungHoSprintLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetHyperBurstInfo
==============
*/

const HyperBurstInfo *__fastcall BG_GetHyperBurstInfo(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetHyperBurstInfo@@YAPEBUHyperBurstInfo@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/

weapClass_t __fastcall BG_GetWeaponClassForAnimCondition(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_GetWeaponClassForAnimCondition@@YA?AW4weapClass_t@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_IsMeleeAnim
==============
*/

bool __fastcall BG_IsMeleeAnim(weapAnimFiles_t animIndex)
{
  return ?BG_IsMeleeAnim@@YA_NW4weapAnimFiles_t@@@Z(animIndex);
}

/*
==============
BG_ReloadStartAdd
==============
*/

int __fastcall BG_ReloadStartAdd(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ReloadStartAdd@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetIgnoreHitEntityCount
==============
*/

int __fastcall BG_GetIgnoreHitEntityCount(const BulletFireParams *bp)
{
  return ?BG_GetIgnoreHitEntityCount@@YAHPEBUBulletFireParams@@@Z(bp);
}

/*
==============
BG_ProjExplosionEffectInheritParentDirection
==============
*/

bool __fastcall BG_ProjExplosionEffectInheritParentDirection(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionEffectInheritParentDirection@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>
==============
*/

int __fastcall BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>(const int entityNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ??$BG_AddCarryObjectModel_Internal@UcorpseReferenceCharacterInfo_t@@@@YAHHPEBUcorpseReferenceCharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entityNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_ADSSpread
==============
*/

double __fastcall BG_ADSSpread(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, const bool isUsingNVGHalfADS)
{
  double result; 

  *(float *)&result = ?BG_ADSSpread@@YAMAEBUWeapon@@_N11@Z(r_weapon, isAlternate, isUsingHybridScope, isUsingNVGHalfADS);
  return result;
}

/*
==============
BG_UseFastReloadAnims
==============
*/

bool __fastcall BG_UseFastReloadAnims(const playerState_s *ps, const BgHandler *pmoveHandler, const Weapon *r_weapon, bool isAlternate, PlayerHandIndex hand, int ammoInClip, weapAnimFiles_t reloadAnimFile)
{
  return ?BG_UseFastReloadAnims@@YA_NPEBUplayerState_s@@PEBVBgHandler@@AEBUWeapon@@_NW4PlayerHandIndex@@HW4weapAnimFiles_t@@@Z(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, reloadAnimFile);
}

/*
==============
BG_GetAdsVisionSetInfo
==============
*/

BgAdsVisionSetInfo *__fastcall BG_GetAdsVisionSetInfo(BgAdsVisionSetInfo *result, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, bool isAlternate)
{
  return ?BG_GetAdsVisionSetInfo@@YA?AUBgAdsVisionSetInfo@@PEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(result, weaponMap, ps, weapon, isAlternate);
}

/*
==============
BG_PlayerDualWieldingCompatibleWeapon
==============
*/

bool __fastcall BG_PlayerDualWieldingCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PlayerDualWieldingCompatibleWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_WeaponGetAnimParts
==============
*/

const XAnimParts *__fastcall BG_WeaponGetAnimParts(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler)
{
  return ?BG_WeaponGetAnimParts@@YAPEBUXAnimParts@@PEBUplayerState_s@@W4PlayerHandIndex@@_NW4weapAnimFiles_t@@PEBVBgHandler@@@Z(ps, hand, bIsAlternate, eWeaponAnim, pmoveHandler);
}

/*
==============
BG_ShowViewModelInDualFOV
==============
*/

bool __fastcall BG_ShowViewModelInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShowViewModelInDualFOV@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_UpdateSecondaryWeaponVisibilities
==============
*/

void __fastcall BG_UpdateSecondaryWeaponVisibilities(const BgAnimStatic *bgameAnim, const BgWeaponMap *weaponMap, const entityState_t *es, characterInfo_t *ci)
{
  ?BG_UpdateSecondaryWeaponVisibilities@@YAXPEBUBgAnimStatic@@PEBVBgWeaponMap@@PEBUentityState_t@@PEAUcharacterInfo_t@@@Z(bgameAnim, weaponMap, es, ci);
}

/*
==============
BG_WeaponHasStreamedModels
==============
*/

bool __fastcall BG_WeaponHasStreamedModels(const Weapon *weapon)
{
  return ?BG_WeaponHasStreamedModels@@YA_NAEBUWeapon@@@Z(weapon);
}

/*
==============
BG_LadderAimDropTime
==============
*/

int __fastcall BG_LadderAimDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_LadderAimDropTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_StartingGunKickPercent
==============
*/

double __fastcall BG_StartingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_StartingGunKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_GetFirstEquippedOffhandBySlot
==============
*/

const Weapon *__fastcall BG_GetFirstEquippedOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  return ?BG_GetFirstEquippedOffhandBySlot@@YAAEBUWeapon@@PEBVBgWeaponMap@@PEBUplayerState_s@@W4OffhandSlot@@@Z(weaponMap, ps, slot);
}

/*
==============
BG_ProjDisabledTimeoutEffect
==============
*/

bool __fastcall BG_ProjDisabledTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjDisabledTimeoutEffect@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_ShowSniperScene
==============
*/

void __fastcall BG_ShowSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj)
{
  ?BG_ShowSniperScene@@YAXAEBUWeapon@@_NPEAUDObj@@@Z(r_weapon, isAlternate, obj);
}

/*
==============
BG_HideBoneByModelRange
==============
*/

unsigned __int8 __fastcall BG_HideBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  return ?BG_HideBoneByModelRange@@YAEW4scr_string_t@@PEAUDObj@@PEAUDObjPartBits@@HH@Z(bone, obj, partBits, startModel, lastModelInclusive);
}

/*
==============
BG_GetAltWeapon
==============
*/

const Weapon *__fastcall BG_GetAltWeapon(const Weapon *r_weapon)
{
  return ?BG_GetAltWeapon@@YAAEBUWeapon@@AEBU1@@Z(r_weapon);
}

/*
==============
BG_GetHudOutlineOccludedInteriorColor
==============
*/

void __fastcall BG_GetHudOutlineOccludedInteriorColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineOccludedInteriorColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_SkydiveOpenParachuteTime
==============
*/

int __fastcall BG_SkydiveOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_SkydiveOpenParachuteTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_ScopeOutlinesCharacters
==============
*/

bool __fastcall BG_ScopeOutlinesCharacters(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesCharacters@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetMountEdgeToEyeDistance
==============
*/

void __fastcall BG_GetMountEdgeToEyeDistance(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, float *outForward, float *outAbove)
{
  ?BG_GetMountEdgeToEyeDistance@@YAXW4ContextMountType@@AEBUWeapon@@_NPEAM3@Z(mountType, r_weapon, isAlternate, outForward, outAbove);
}

/*
==============
BG_GetAngularGunKickSettings
==============
*/

void __fastcall BG_GetAngularGunKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularGunKickDir, float *hipAngularGunKickDev, float *hipAngularGunKickStrengthMin, float *hipAngularGunKickStrengthMax, float *hipAngularGunKickPitchScale, float *adsAngularGunKickDir, float *adsAngularGunKickDev, float *adsAngularGunKickStrengthMin, float *adsAngularGunKickStrengthMax, float *adsAngularGunKickPitchScale)
{
  ?BG_GetAngularGunKickSettings@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NHPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, bulletNum, hipAngularGunKickDir, hipAngularGunKickDev, hipAngularGunKickStrengthMin, hipAngularGunKickStrengthMax, hipAngularGunKickPitchScale, adsAngularGunKickDir, adsAngularGunKickDev, adsAngularGunKickStrengthMin, adsAngularGunKickStrengthMax, adsAngularGunKickPitchScale);
}

/*
==============
BG_SetGlobalAmmo
==============
*/

void __fastcall BG_SetGlobalAmmo(playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoCount)
{
  ?BG_SetGlobalAmmo@@YAXPEAUplayerState_s@@AEBUWeapon@@_NH@Z(ps, r_weapon, isAlternate, ammoCount);
}

/*
==============
BG_WeaponsDifferOnlyInVariantForInstantSwitch
==============
*/

int __fastcall BG_WeaponsDifferOnlyInVariantForInstantSwitch(const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeapFlags, const Weapon *r_weaponA, const Weapon *r_weaponB)
{
  return ?BG_WeaponsDifferOnlyInVariantForInstantSwitch@@YAHPEBUplayerState_s@@V?$GameModeFlagContainer@W4PWeaponFlagsCommon@@W4PWeaponFlagsSP@@W4PWeaponFlagsMP@@$0EA@@@AEBUWeapon@@2@Z(ps, prevWeapFlags, r_weaponA, r_weaponB);
}

/*
==============
BG_ReloadEmptyInterruptTime
==============
*/

int __fastcall BG_ReloadEmptyInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadEmptyInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AmmoCounterClip
==============
*/

ammoCounterClipType_t __fastcall BG_AmmoCounterClip(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_AmmoCounterClip@@YA?AW4ammoCounterClipType_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAnimForFootsteps
==============
*/

int __fastcall BG_GetAnimForFootsteps(FootstepAnimType footstepAnim)
{
  return ?BG_GetAnimForFootsteps@@YAHW4FootstepAnimType@@@Z(footstepAnim);
}

/*
==============
BG_ActiveUnderbarrel
==============
*/

bool __fastcall BG_ActiveUnderbarrel(const Weapon *r_weapon)
{
  return ?BG_ActiveUnderbarrel@@YA_NAEBUWeapon@@@Z(r_weapon);
}

/*
==============
BG_GetAmmoIndex
==============
*/

int __fastcall BG_GetAmmoIndex(const Weapon *r_weapon, bool isAlternate, const BgHandler *const handler, const char **outAmmoName)
{
  return ?BG_GetAmmoIndex@@YAHAEBUWeapon@@_NQEBVBgHandler@@PEAPEBD@Z(r_weapon, isAlternate, handler, outAmmoName);
}

/*
==============
BG_MoveTransitionTime
==============
*/

int __fastcall BG_MoveTransitionTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, movementTransition_t transitionType)
{
  return ?BG_MoveTransitionTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2W4movementTransition_t@@@Z(ps, r_weapon, isAlternate, isDualWielding, transitionType);
}

/*
==============
BG_ADSViewBobMult
==============
*/

double __fastcall BG_ADSViewBobMult(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSViewBobMult@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ADSAimPitch
==============
*/

double __fastcall BG_ADSAimPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_ADSAimPitch@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetReloadAnimFileType
==============
*/

ReloadAnimFileType __fastcall BG_GetReloadAnimFileType(weapAnimFiles_t animFile)
{
  return ?BG_GetReloadAnimFileType@@YA?AW4ReloadAnimFileType@@W4weapAnimFiles_t@@@Z(animFile);
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/

double __fastcall BG_CalculateFinalSpreadForWeapon(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, float aimSpreadScale)
{
  double result; 

  *(float *)&result = ?BG_CalculateFinalSpreadForWeapon@@YAMPEBVBgHandler@@PEBUplayerState_s@@AEBUWeapon@@M@Z(handler, ps, r_weapon, aimSpreadScale);
  return result;
}

/*
==============
BG_WeaponBulletFire_GetMethodOfDeath
==============
*/

meansOfDeath_t __fastcall BG_WeaponBulletFire_GetMethodOfDeath(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBulletFire_GetMethodOfDeath@@YA?AW4meansOfDeath_t@@V?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
}

/*
==============
BG_EndingKickBullets
==============
*/

int __fastcall BG_EndingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_EndingKickBullets@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsChargeShotWeapon
==============
*/

bool __fastcall BG_IsChargeShotWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsChargeShotWeapon@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetPenetrateMultiplier
==============
*/

double __fastcall BG_GetPenetrateMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetPenetrateMultiplier@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ScopeOutlinesScriptMovers
==============
*/

bool __fastcall BG_ScopeOutlinesScriptMovers(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ScopeOutlinesScriptMovers@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_AddCarryObjectModel
==============
*/

int __fastcall BG_AddCarryObjectModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddCarryObjectModel@@YAHPEBUcharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_GetHudOutlineOccludedInlineColor
==============
*/

void __fastcall BG_GetHudOutlineOccludedInlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  ?BG_GetHudOutlineOccludedInlineColor@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEATvec4_t@@@Z(weaponMap, ps, outColor);
}

/*
==============
BG_FirstRaiseTime
==============
*/

int __fastcall BG_FirstRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_FirstRaiseTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_VMProjBodyEffect
==============
*/

FxCombinedDef __fastcall BG_VMProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_VMProjBodyEffect@@YA?AUFxCombinedDef@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponFireWeaponID
==============
*/

Weapon *__fastcall BG_GetWeaponFireWeaponID(Weapon *result, unsigned int param)
{
  return ?BG_GetWeaponFireWeaponID@@YA?AUWeapon@@I@Z(result, param);
}

/*
==============
BG_AddCarryObjectModelToCorpse
==============
*/

int __fastcall BG_AddCarryObjectModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  return ?BG_AddCarryObjectModelToCorpse@@YAHHPEBUcorpseReferenceCharacterInfo_t@@PEAUDObjModel@@HIAEAIAEAY0CA@W4CharacterModelType@@@Z(entNum, ci, dobjModels, numModels, totalBoneCountSoFar, outBonesAdded, outModelTypes);
}

/*
==============
BG_DeathAnimDamageType
==============
*/

AnimDamageType __fastcall BG_DeathAnimDamageType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DeathAnimDamageType@@YA?AW4AnimDamageType@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_BlastBackTime
==============
*/

int __fastcall BG_BlastBackTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastBackTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_ReloadMultipleTimeBulletBased
==============
*/

int __fastcall BG_ReloadMultipleTimeBulletBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  return ?BG_ReloadMultipleTimeBulletBased@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_NAEA_N@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, hasFastReloadOverride);
}

/*
==============
BG_GetSpreadForWeapon
==============
*/

void __fastcall BG_GetSpreadForWeapon(const playerState_s *ps, const Weapon *r_weapon, float *minSpread, float *maxSpread)
{
  ?BG_GetSpreadForWeapon@@YAXPEBUplayerState_s@@AEBUWeapon@@PEAM2@Z(ps, r_weapon, minSpread, maxSpread);
}

/*
==============
BG_ShouldApplyWeaponAnglesToShootingDirection
==============
*/

bool __fastcall BG_ShouldApplyWeaponAnglesToShootingDirection(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShouldApplyWeaponAnglesToShootingDirection@@YA_NPEBUplayerState_s@@AEBUWeapon@@_N@Z(ps, r_weapon, isAlternate);
}

/*
==============
BG_Weapon_UsingAutoFireOnSwitchWeapon
==============
*/

bool __fastcall BG_Weapon_UsingAutoFireOnSwitchWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_Weapon_UsingAutoFireOnSwitchWeapon@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_PlayerLastWeaponHand
==============
*/

PlayerHandIndex __fastcall BG_PlayerLastWeaponHand(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  return ?BG_PlayerLastWeaponHand@@YA?AW4PlayerHandIndex@@PEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
}

/*
==============
BG_Weapons_IsRiotShieldModelName
==============
*/

int __fastcall BG_Weapons_IsRiotShieldModelName(const char *const modelName)
{
  return ?BG_Weapons_IsRiotShieldModelName@@YAHQEBD@Z(modelName);
}

/*
==============
BG_ProjExplosionType
==============
*/

weapProjExposion_t __fastcall BG_ProjExplosionType(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionType@@YA?AW4weapProjExposion_t@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_WeaponReloadingFraction
==============
*/

double __fastcall BG_WeaponReloadingFraction(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_WeaponReloadingFraction@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@@Z(weaponMap, ps);
  return result;
}

/*
==============
BG_WeaponSticksToNonStick
==============
*/

bool __fastcall BG_WeaponSticksToNonStick(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToNonStick@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetAdsAlign
==============
*/

bool __fastcall BG_GetAdsAlign(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, vec3_t *outAdsAlignOffset, AdsOffsetInterpolationType *outOffsetLerpType, AdsOffsetInterpolationType *outAlignmentLerpType, bool *outDisableTagAlignX)
{
  return ?BG_GetAdsAlign@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NAEBUBgHybridScopeFraction@@AEATvec3_t@@PEAW4AdsOffsetInterpolationType@@6AEA_N@Z(weaponMap, ps, r_weapon, isAlternate, hybridScopeFractionInfo, outAdsAlignOffset, outOffsetLerpType, outAlignmentLerpType, outDisableTagAlignX);
}

/*
==============
BG_GetGunTiltYawPitchAndRoll
==============
*/

void __fastcall BG_GetGunTiltYawPitchAndRoll(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunTiltPitchFactor, float *hipGunTiltYawFactor, float *hipGunTiltRollFactor, float *hipGunTiltOffset, float *adsGunTiltPitchFactor, float *adsGunTiltYawFactor, float *adsGunTiltRollFactor, float *adsGunTiltOffset)
{
  ?BG_GetGunTiltYawPitchAndRoll@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM4444444@Z(weaponMap, ps, r_weapon, isAlternate, hipGunTiltPitchFactor, hipGunTiltYawFactor, hipGunTiltRollFactor, hipGunTiltOffset, adsGunTiltPitchFactor, adsGunTiltYawFactor, adsGunTiltRollFactor, adsGunTiltOffset);
}

/*
==============
BG_IsMountTypeEnabled
==============
*/

bool __fastcall BG_IsMountTypeEnabled(const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, const ContextMountType mountType)
{
  return ?BG_IsMountTypeEnabled@@YA_NQEBUplayerState_s@@AEBUWeapon@@_NW4ContextMountType@@@Z(ps, r_weapon, isAlternate, mountType);
}

/*
==============
BG_GetEnemyCrossHairRange
==============
*/

double __fastcall BG_GetEnemyCrossHairRange(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetEnemyCrossHairRange@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetADSIdleLerpTime
==============
*/

void __fastcall BG_GetADSIdleLerpTime(const Weapon *r_weapon, bool isAlternate, float *adsIdleLerpStartTime, float *adsIdleLerpTime)
{
  ?BG_GetADSIdleLerpTime@@YAXAEBUWeapon@@_NPEAM2@Z(r_weapon, isAlternate, adsIdleLerpStartTime, adsIdleLerpTime);
}

/*
==============
BG_EmptyFireSound
==============
*/

const SndAliasList *__fastcall BG_EmptyFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  return ?BG_EmptyFireSound@@YAPEBUSndAliasList@@AEBUWeapon@@_N1@Z(r_weapon, isAlternate, isPlayer);
}

/*
==============
BG_GetFriendlyLaserType
==============
*/

const LaserDef *__fastcall BG_GetFriendlyLaserType(const Weapon *r_weapon, const bool isPlayerView, const bool isBeamDraw)
{
  return ?BG_GetFriendlyLaserType@@YAPEBULaserDef@@AEBUWeapon@@_N1@Z(r_weapon, isPlayerView, isBeamDraw);
}

/*
==============
BG_GetADSFireRateScale
==============
*/

double __fastcall BG_GetADSFireRateScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetADSFireRateScale@@YAMPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
  return result;
}

/*
==============
BG_ReloadEndInterruptTime
==============
*/

int __fastcall BG_ReloadEndInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadEndInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_SkydiveParachuteFastLandingVelocity
==============
*/

double __fastcall BG_SkydiveParachuteFastLandingVelocity(const playerState_s *ps)
{
  double result; 

  *(float *)&result = ?BG_SkydiveParachuteFastLandingVelocity@@YAMPEBUplayerState_s@@@Z(ps);
  return result;
}

/*
==============
BgWeaponScalarAccumulator::ApplyMultiplicativeScale
==============
*/

void __fastcall BgWeaponScalarAccumulator::ApplyMultiplicativeScale(BgWeaponScalarAccumulator *this, const float scale)
{
  ?ApplyMultiplicativeScale@BgWeaponScalarAccumulator@@QEAAXM@Z(this, scale);
}

/*
==============
BG_WeaponBlocksProne
==============
*/

bool __fastcall BG_WeaponBlocksProne(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponBlocksProne@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PredictionGetServerTrajectoryBlendInTime
==============
*/

int __fastcall BG_PredictionGetServerTrajectoryBlendInTime(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_PredictionGetServerTrajectoryBlendInTime@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_Weapon_OffhandDisablesHold
==============
*/

int __fastcall BG_Weapon_OffhandDisablesHold(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_Weapon_OffhandDisablesHold@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_IsHitSurfaceTransparent
==============
*/

bool __fastcall BG_IsHitSurfaceTransparent(const trace_t *trace)
{
  return ?BG_IsHitSurfaceTransparent@@YA_NPEBUtrace_t@@@Z(trace);
}

/*
==============
BG_GetADSNVGFOV
==============
*/

double __fastcall BG_GetADSNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  double result; 

  *(float *)&result = ?BG_GetADSNVGFOV@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, getWeaponValues);
  return result;
}

/*
==============
BG_GetGunKickSpeed
==============
*/

void __fastcall BG_GetGunKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickAccel, float *hipGunKickSpeedMax, float *hipGunKickSpeedDecay, float *hipGunKickStaticDecay, float *hipGunKickReturnAccelScale, float *hipGunKickReturnSpeedCurveScale, float *adsGunKickAccel, float *adsGunKickSpeedMax, float *adsGunKickSpeedDecay, float *adsGunKickStaticDecay, float *adsGunKickReturnAccelScale, float *adsGunKickReturnSpeedCurveScale)
{
  ?BG_GetGunKickSpeed@@YAXPEBVBgWeaponMap@@QEBUplayerState_s@@AEBUWeapon@@_NPEAM44444444444@Z(weaponMap, ps, r_weapon, isAlternate, hipGunKickAccel, hipGunKickSpeedMax, hipGunKickSpeedDecay, hipGunKickStaticDecay, hipGunKickReturnAccelScale, hipGunKickReturnSpeedCurveScale, adsGunKickAccel, adsGunKickSpeedMax, adsGunKickSpeedDecay, adsGunKickStaticDecay, adsGunKickReturnAccelScale, adsGunKickReturnSpeedCurveScale);
}

/*
==============
BG_BlastRightTime
==============
*/

int __fastcall BG_BlastRightTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_BlastRightTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_GetWeaponOffhandSlot
==============
*/

OffhandSlot __fastcall BG_GetWeaponOffhandSlot(const playerState_s *ps, const BgWeaponMap *weaponMap, const Weapon *r_weapon)
{
  return ?BG_GetWeaponOffhandSlot@@YA?AW4OffhandSlot@@PEBUplayerState_s@@PEBVBgWeaponMap@@AEBUWeapon@@@Z(ps, weaponMap, r_weapon);
}

/*
==============
BG_GetMeleeInterruptTime
==============
*/

void __fastcall BG_GetMeleeInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outToMeleeInterruptTime, int *outInterruptTime, int *outToFireInterruptTime)
{
  ?BG_GetMeleeInterruptTime@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@_N22PEAH33@Z(weaponMap, ps, isAlternate, isDualWielding, isFatal, outToMeleeInterruptTime, outInterruptTime, outToFireInterruptTime);
}

/*
==============
BG_ShouldBlendFireAnims
==============
*/

bool __fastcall BG_ShouldBlendFireAnims(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ShouldBlendFireAnims@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_StunnedTimeLoop
==============
*/

int __fastcall BG_StunnedTimeLoop(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_StunnedTimeLoop@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_HasADSAltSwitchAnims
==============
*/

bool __fastcall BG_HasADSAltSwitchAnims(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  return ?BG_HasADSAltSwitchAnims@@YA_NPEBUplayerState_s@@PEBVBgHandler@@@Z(ps, pmoveHandler);
}

/*
==============
BG_ReloadStartInterruptTime
==============
*/

int __fastcall BG_ReloadStartInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_ReloadStartInterruptTime@@YAHPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_SprintLoopTime
==============
*/

int __fastcall BG_SprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_SprintLoopTime@@YAHPEBUplayerState_s@@AEBUWeapon@@_N2@Z(ps, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_MapWeaponAnimStateToAnimIndex
==============
*/

weapAnimFiles_t __fastcall BG_MapWeaponAnimStateToAnimIndex(const BgWeaponMap *weaponMap, const playerState_s *ps, int animState, bool previousMelee, const Weapon *r_weapon, bool bIsAlternate, PlayerHandIndex handIndex, const BgHandler *pmoveHandler)
{
  return ?BG_MapWeaponAnimStateToAnimIndex@@YA?AW4weapAnimFiles_t@@PEBVBgWeaponMap@@PEBUplayerState_s@@H_NAEBUWeapon@@2W4PlayerHandIndex@@PEBVBgHandler@@@Z(weaponMap, ps, animState, previousMelee, r_weapon, bIsAlternate, handIndex, pmoveHandler);
}

/*
==============
BG_TargetAssistLosOffsets
==============
*/

void __fastcall BG_TargetAssistLosOffsets(const Weapon *r_weapon, bool isAlternate, float *outForwardOffset, float *outRightOffset, float *outUpOffset)
{
  ?BG_TargetAssistLosOffsets@@YAXAEBUWeapon@@_NPEAM22@Z(r_weapon, isAlternate, outForwardOffset, outRightOffset, outUpOffset);
}

/*
==============
BG_HudIcon
==============
*/

GfxImage *__fastcall BG_HudIcon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_HudIcon@@YAPEAUGfxImage@@AEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_StartingViewKickPercent
==============
*/

double __fastcall BG_StartingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  double result; 

  *(float *)&result = ?BG_StartingViewKickPercent@@YAMAEBUWeapon@@_N1@Z(r_weapon, isAlternate, ads);
  return result;
}

/*
==============
BG_GetFireTimeWithHand
==============
*/

void __fastcall BG_GetFireTimeWithHand(const BgWeaponMap *weaponMap, const playerState_s *ps, const PlayerHandIndex hand, const bool adjustForHyperBurst, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  ?BG_GetFireTimeWithHand@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@W4PlayerHandIndex@@_NAEBUWeapon@@_N5HPEAH6@Z(weaponMap, ps, hand, adjustForHyperBurst, r_weapon, isAlternate, isDualWielding, shotCount, fireTime, fireDelay);
}

/*
==============
BG_ProjExplosionEffectForceNormalUp
==============
*/

bool __fastcall BG_ProjExplosionEffectForceNormalUp(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_ProjExplosionEffectForceNormalUp@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/

double __fastcall BG_CalculateFinalSpreadForWeapon(float weaponPosFrac, float minSpread, float maxSpread, float adsSpread, float aimSpreadScale)
{
  double result; 

  *(float *)&result = ?BG_CalculateFinalSpreadForWeapon@@YAMMMMMM@Z(weaponPosFrac, minSpread, maxSpread, adsSpread, aimSpreadScale);
  return result;
}

/*
==============
BG_WeaponSticksToVehicles
==============
*/

bool __fastcall BG_WeaponSticksToVehicles(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_WeaponSticksToVehicles@@YA_NAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_PlayerWeaponGetSlotName
==============
*/

const char *__fastcall BG_PlayerWeaponGetSlotName(const WeaponSlot slot)
{
  return ?BG_PlayerWeaponGetSlotName@@YAPEBDW4WeaponSlot@@@Z(slot);
}

/*
==============
BG_IsForceUseWeapon
==============
*/

int __fastcall BG_IsForceUseWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_IsForceUseWeapon@@YAHAEBUWeapon@@_N@Z(r_weapon, isAlternate);
}

/*
==============
BG_GetOtherAdsSettleAnim
==============
*/

weapAnimFiles_t __fastcall BG_GetOtherAdsSettleAnim(const weapAnimFiles_t adsSettleAnim)
{
  return ?BG_GetOtherAdsSettleAnim@@YA?AW4weapAnimFiles_t@@W41@@Z(adsSettleAnim);
}

/*
==============
BG_UseFastReloadLowAmmo
==============
*/

bool __fastcall BG_UseFastReloadLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip)
{
  return ?BG_UseFastReloadLowAmmo@@YA_NPEBUplayerState_s@@AEBUWeapon@@_NH@Z(ps, r_weapon, isAlternate, ammoInClip);
}

/*
==============
BG_GetBurstFireCooldown
==============
*/

double __fastcall BG_GetBurstFireCooldown(const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?BG_GetBurstFireCooldown@@YAMAEBUWeapon@@_N@Z(r_weapon, isAlternate);
  return result;
}

/*
==============
BG_GetGunKickYawAndPitch
==============
*/

void __fastcall BG_GetGunKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickPitchMin, float *hipGunKickPitchMax, float *hipGunKickYawMin, float *hipGunKickYawMax, float *hipGunKickMagMin, float *adsGunKickPitchMin, float *adsGunKickPitchMax, float *adsGunKickYawMin, float *adsGunKickYawMax, float *adsGunKickMagMin)
{
  ?BG_GetGunKickYawAndPitch@@YAXPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_NPEAM444444444@Z(weaponMap, ps, r_weapon, isAlternate, hipGunKickPitchMin, hipGunKickPitchMax, hipGunKickYawMin, hipGunKickYawMax, hipGunKickMagMin, adsGunKickPitchMin, adsGunKickPitchMax, adsGunKickYawMin, adsGunKickYawMax, adsGunKickMagMin);
}

/*
==============
BG_DisableInputDrivenViewReturnDampening
==============
*/

bool __fastcall BG_DisableInputDrivenViewReturnDampening(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return ?BG_DisableInputDrivenViewReturnDampening@@YA_NPEBVBgWeaponMap@@PEBUplayerState_s@@AEBUWeapon@@_N@Z(weaponMap, ps, r_weapon, isAlternate);
}

/*
==============
BG_IsUsingFastReloadStateTimer
==============
*/

bool __fastcall BG_IsUsingFastReloadStateTimer(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return ?BG_IsUsingFastReloadStateTimer@@YA_NPEBUplayerState_s@@PEBVBgHandler@@W4PlayerHandIndex@@AEBUWeapon@@_N4@Z(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
}

/*
==============
BG_AddCarryObjectModel_Internal<characterInfo_t>
==============
*/
__int64 BG_AddCarryObjectModel_Internal<characterInfo_t>(const int entityNum, const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v8; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v12; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  v8 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)v8;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v8;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v8]);
  (*outModelTypes)[v8] = CHAR_MODEL_CARRY_OBJECT;
  v12 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v12;
  if ( v12 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v12;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entityNum, fmt, outDObjModel);
  }
  return (unsigned int)(v8 + 1);
}

/*
==============
BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>
==============
*/
__int64 BG_AddCarryObjectModel_Internal<corpseReferenceCharacterInfo_t>(const int entityNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v8; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v12; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  v8 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)v8;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v8;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v8]);
  (*outModelTypes)[v8] = CHAR_MODEL_CARRY_OBJECT;
  v12 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v12;
  if ( v12 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v12;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entityNum, fmt, outDObjModel);
  }
  return (unsigned int)(v8 + 1);
}

/*
==============
RawWeaponAnimArrays::RawWeaponAnimArrays
==============
*/
void RawWeaponAnimArrays::RawWeaponAnimArrays(RawWeaponAnimArrays *this)
{
  memset_0(this, 0, 0x1330ui64);
  memset_0(this->xAnimsAlt, 0, sizeof(this->xAnimsAlt));
  memset_0(this->xAnimsRightHanded, 0, sizeof(this->xAnimsRightHanded));
  memset_0(this->xAnimsLeftHanded, 0, sizeof(this->xAnimsLeftHanded));
  this->blendSpaces[0] = NULL;
  this->blendSpaces[1] = NULL;
  this->blendSpaces[2] = NULL;
  this->blendSpaces[3] = NULL;
  this->blendSpaces[4] = NULL;
  this->blendSpaces[5] = NULL;
  this->blendSpaces[6] = NULL;
  this->blendSpaces[7] = NULL;
  this->blendSpacesAlt[0] = NULL;
  this->blendSpacesAlt[1] = NULL;
  this->blendSpacesAlt[2] = NULL;
  this->blendSpacesAlt[3] = NULL;
  this->blendSpacesAlt[4] = NULL;
  this->blendSpacesAlt[5] = NULL;
  this->blendSpacesAlt[6] = NULL;
  this->blendSpacesAlt[7] = NULL;
  this->blendSpacesRightHanded[0] = NULL;
  this->blendSpacesRightHanded[1] = NULL;
  this->blendSpacesRightHanded[2] = NULL;
  this->blendSpacesRightHanded[3] = NULL;
  this->blendSpacesRightHanded[4] = NULL;
  this->blendSpacesRightHanded[5] = NULL;
  this->blendSpacesRightHanded[6] = NULL;
  this->blendSpacesRightHanded[7] = NULL;
  this->blendSpacesLeftHanded[0] = NULL;
  this->blendSpacesLeftHanded[1] = NULL;
  this->blendSpacesLeftHanded[2] = NULL;
  this->blendSpacesLeftHanded[3] = NULL;
  this->blendSpacesLeftHanded[4] = NULL;
  this->blendSpacesLeftHanded[5] = NULL;
  this->blendSpacesLeftHanded[6] = NULL;
  this->blendSpacesLeftHanded[7] = NULL;
  memset_0(this->footsteps, 0, 0x68D0ui64);
}

/*
==============
TagPair::TagPair
==============
*/
void TagPair::TagPair(TagPair *this, scr_string_t primaryTagName, scr_string_t fallbackTagName)
{
  this->m_primaryTagName = primaryTagName;
  this->m_fallbackTagName = fallbackTagName;
}

/*
==============
TagPair::TagPair
==============
*/
void TagPair::TagPair(TagPair *this)
{
  *this = 0i64;
}

/*
==============
BgWeaponScalarAccumulator::ApplyAdditiveScale
==============
*/

void __fastcall BgWeaponScalarAccumulator::ApplyAdditiveScale(BgWeaponScalarAccumulator *this, double scale)
{
  __asm
  {
    vaddss  xmm0, xmm1, dword ptr [rcx]
    vsubss  xmm1, xmm0, cs:__real@3f800000
    vmovss  dword ptr [rcx], xmm1
  }
}

/*
==============
BgWeaponScalarAccumulator::ApplyMultiplicativeScale
==============
*/

void __fastcall BgWeaponScalarAccumulator::ApplyMultiplicativeScale(BgWeaponScalarAccumulator *this, double scale)
{
  __asm
  {
    vmulss  xmm0, xmm1, dword ptr [rcx+4]
    vmovss  dword ptr [rcx+4], xmm0
  }
}

/*
==============
BG_ADSAimPitch
==============
*/
float BG_ADSAimPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12610, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm { vmovss  xmm6, dword ptr [rax+7D8h] }
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v12, 0) )
    __asm { vmovss  xmm0, dword ptr [rax+0Ch] }
  else
    __asm { vmovaps xmm0, xmm6 }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSBobFactor
==============
*/
float BG_ADSBobFactor(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13381, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovss  xmm6, dword ptr [rbp+4A4h] }
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v12, 0) )
  {
    __asm
    {
      vmovss  xmm2, dword ptr [rax+0A8h]
      vxorps  xmm0, xmm0, xmm0
      vcmpless xmm1, xmm0, xmm2
      vblendvps xmm0, xmm6, xmm2, xmm1
    }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
  __asm { vmovaps xmm6, [rsp+58h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSBobRate
==============
*/
float BG_ADSBobRate(const Weapon *r_weapon, const bool isAlternate)
{
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  __int64 v9; 
  bool v11; 
  bool v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v19[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-28h], xmm6
    vmovss  xmm6, cs:__real@3f800000
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v19, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    __asm
    {
      vmovaps [rsp+198h+var_38], xmm7
      vxorps  xmm7, xmm7, xmm7
    }
    v9 = WeaponAttachments_Internal;
    do
    {
      _RDI = *v7;
      v11 = *v7 == NULL;
      if ( !*v7 )
      {
        v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13360, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v11 = !v12;
        if ( v12 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm1, dword ptr [rdi+374h]
        vcomiss xmm1, xmm7
      }
      if ( !v11 )
        __asm { vmulss  xmm6, xmm6, xmm1 }
      ++v7;
      --v9;
    }
    while ( v9 );
    __asm { vmovaps xmm7, [rsp+198h+var_38] }
  }
  __asm
  {
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+198h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSFireAnimFrac
==============
*/
float BG_ADSFireAnimFrac(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13726, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovss  xmm6, dword ptr [rbp+678h] }
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v11, 0) )
    __asm { vmovss  xmm0, dword ptr [rax+0B8h] }
  else
    __asm { vmovaps xmm0, xmm6 }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSMovementAnimBlendFrac
==============
*/
void BG_ADSMovementAnimBlendFrac(const Weapon *r_weapon, bool isAlternate, float *outStartFrac, float *outEndFrac)
{
  const WeaponDef *v7; 

  if ( !outStartFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13743, ASSERT_TYPE_ASSERT, "(outStartFrac)", (const char *)&queryFormat, "outStartFrac") )
    __debugbreak();
  if ( !outEndFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13744, ASSERT_TYPE_ASSERT, "(outEndFrac)", (const char *)&queryFormat, "outEndFrac") )
    __debugbreak();
  v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outStartFrac = v7->adsMovementAnimLerpStart;
  *outEndFrac = v7->adsMovementAnimLerpEnd;
}

/*
==============
BG_ADSReloadEnabled
==============
*/
bool BG_ADSReloadEnabled(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  const dvar_t *v4; 
  bool v5; 
  int v10; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v13; 
  WeaponAttachment **i; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  AttADSReloadSettings *adsReloadSettings; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = DCONST_DVARMODEBOOL_adsReloadEnabled;
  v5 = isAlternate;
  if ( !DCONST_DVARMODEBOOL_adsReloadEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsReloadEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( !v4->current.enabled )
    return 0;
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v13 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reloadWhileAds;
  for ( i = attachments; ; ++i )
  {
    OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, v5, *i, v13);
    if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22219, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    adsReloadSettings = OverrideAttachmentWhenApplicable->adsReloadSettings;
    if ( adsReloadSettings )
      break;
    v5 = isAlternate;
    if ( ++v10 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reloadWhileAds;
  }
  return adsReloadSettings->reloadWhileADS;
}

/*
==============
BG_ADSReloadFovXOffset
==============
*/
float BG_ADSReloadFovXOffset(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const BgWeaponMap *v12; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v14; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13271, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  _RSI = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( ps && BG_PlayerUsesNVGHalfADS(ps, handler) )
  {
    __asm { vmovss  xmm0, dword ptr [rsi+1A0h] }
  }
  else
  {
    __asm
    {
      vmovaps [rsp+48h+var_18], xmm6
      vmovss  xmm6, dword ptr [rsi+190h]
    }
    v12 = handler->GetWeaponMap(handler);
    v14 = ps && v12 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v12, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
    _RAX = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v14, 0);
    if ( _RAX && _RAX->zoomSettings.weapon.adsReloadFovXOffsetOverride )
      __asm { vmovss  xmm6, dword ptr [rax+84h] }
    __asm
    {
      vmovaps xmm0, xmm6
      vmovaps xmm6, [rsp+48h+var_18]
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSReloadTransTime
==============
*/
__int64 BG_ADSReloadTransTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int iPositionReloadTransTime; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12727, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  iPositionReloadTransTime = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iPositionReloadTransTime;
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings && WeaponAdsSettings->adsReloadTransTime >= 0 )
    return (unsigned int)WeaponAdsSettings->adsReloadTransTime;
  return iPositionReloadTransTime;
}

/*
==============
BG_ADSResetZoomLevelOnToggle
==============
*/
_BOOL8 BG_ADSResetZoomLevelOnToggle(BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponCompleteDef *v8; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v10; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12832, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12833, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v8 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12836, ASSERT_TYPE_ASSERT, "(weapComplDef)", (const char *)&queryFormat, "weapComplDef") )
    __debugbreak();
  v10 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v10, 0);
  if ( WeaponAdsSettings )
    return WeaponAdsSettings->zoomSettings.scene.adsZoomLevelIndexResetOnToggle;
  else
    return v8->zoomSettings.scene.adsZoomLevelIndexResetOnToggle;
}

/*
==============
BG_ADSShouldShowCrosshair
==============
*/
_BOOL8 BG_ADSShouldShowCrosshair(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsShouldShowCrosshair;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20714, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsShouldShowCrosshair;
  }
  return general->adsShouldShowCrosshair;
}

/*
==============
BG_ADSSpread
==============
*/
float BG_ADSSpread(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, const bool isUsingNVGHalfADS)
{
  bool doNotAllowAttachmentsToOverrideSpread; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment **v24; 
  __int64 v25; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v46; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( isUsingNVGHalfADS )
    __asm { vmovss  xmm9, dword ptr [rax+834h] }
  else
    __asm { vmovss  xmm9, dword ptr [rax+830h] }
  doNotAllowAttachmentsToOverrideSpread = _RAX->doNotAllowAttachmentsToOverrideSpread;
  _RAX = BG_GetWeaponAdsSettings(r_weapon, isAlternate, isUsingHybridScope, doNotAllowAttachmentsToOverrideSpread);
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( _RAX )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rax]
      vcmpless xmm0, xmm7, xmm1
      vblendvps xmm9, xmm9, xmm1, xmm0
    }
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)3, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmm8, xmm6
  }
  if ( WeaponAttachments_Internal )
  {
    v24 = (const WeaponAttachment **)attachments;
    v25 = WeaponAttachments_Internal;
    do
    {
      _RBX = *v24;
      if ( *v24 && (!doNotAllowAttachmentsToOverrideSpread || _RBX->type) )
      {
        if ( BG_AttachmentUseMainSettings(*v24, isAlternate, isUsingHybridScope) )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+2E4h]
            vcomiss xmm0, xmm7
          }
        }
        else
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+2E0h]
            vcomiss xmm0, xmm7
            vmovaps xmm0, xmm6
          }
        }
        __asm
        {
          vaddss  xmm0, xmm8, xmm0
          vsubss  xmm8, xmm0, xmm6
        }
      }
      ++v24;
      --v25;
    }
    while ( v25 );
  }
  __asm
  {
    vmaxss  xmm3, xmm8, xmm7
    vsubss  xmm0, xmm6, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm6, xmm2
    vmulss  xmm0, xmm0, xmm9
  }
  _R11 = &v46;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSSpreadFractions
==============
*/
void BG_ADSSpreadFractions(const Weapon *r_weapon, const bool isAlternate, const bool isUsingHybridScope, float *startFrac, float *endFrac)
{
  const WeaponDef *v10; 
  bool doNotAllowAttachmentsToOverrideSpread; 

  _R15 = startFrac;
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _R14 = endFrac;
  doNotAllowAttachmentsToOverrideSpread = v10->doNotAllowAttachmentsToOverrideSpread;
  *_R15 = v10->adsSpreadStartFrac;
  *endFrac = v10->adsSpreadEndFrac;
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, isUsingHybridScope, doNotAllowAttachmentsToOverrideSpread) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax+4]
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
      vmovss  dword ptr [r15], xmm0
      vmovss  xmm0, dword ptr [rax+8]
      vcomiss xmm0, xmm1
      vmovss  dword ptr [r14], xmm0
    }
  }
}

/*
==============
BG_ADSViewBobMult
==============
*/
float BG_ADSViewBobMult(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v14; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v23; 
  __int64 v24; 
  bool v26; 
  bool v27; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v37; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13427, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v14 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovss  xmm7, dword ptr [rbp+4A8h] }
  _RAX = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v14, 0);
  __asm { vxorps  xmm8, xmm8, xmm8 }
  if ( _RAX )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rax+0ACh]
      vcmpless xmm0, xmm8, xmm1
      vblendvps xmm7, xmm7, xmm1, xmm0
    }
  }
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v23 = attachments;
    v24 = WeaponAttachments_Internal;
    do
    {
      _RDI = *v23;
      v26 = *v23 == NULL;
      if ( !*v23 )
      {
        v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13406, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v26 = !v27;
        if ( v27 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+370h]
        vcomiss xmm0, xmm8
      }
      if ( !v26 )
        __asm { vmulss  xmm6, xmm6, xmm0 }
      ++v23;
      --v24;
    }
    while ( v24 );
  }
  __asm { vmulss  xmm0, xmm6, xmm7 }
  _R11 = &v37;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSZoomCount
==============
*/
__int64 BG_ADSZoomCount(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int adsZoomCount; 
  const AttADSSettings *WeaponAdsSettings; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12800, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  if ( BG_CanHybridToggle(ps, r_weapon, isAlternate) )
    return 1i64;
  adsZoomCount = BG_WeaponCompleteDef(r_weapon, isAlternate)->zoomSettings.scene.adsZoomCount;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 0, 0);
  if ( WeaponAdsSettings )
    return (unsigned int)WeaponAdsSettings->zoomSettings.scene.adsZoomCount;
  return adsZoomCount;
}

/*
==============
BG_ADSZoomFov
==============
*/
float BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const BgWeaponMap *v9; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  const BgWeaponMap *v12; 
  char v13; 
  char v14; 
  unsigned int zoomCount; 
  const BgWeaponMap *v19; 
  int ADSZoomLevel; 
  __int64 v23; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13259, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  v9 = handler->GetWeaponMap(handler);
  if ( ps && v9 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v9, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope )
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vmovss  [rsp+0C8h+hybridScopeFractionInfo.fraction], xmm0
    }
    hybridScopeFractionInfo.increasing = 1;
  }
  else
  {
    hybridScopeFractionInfo = 0i64;
  }
  v12 = handler->GetWeaponMap(handler);
  if ( !ps )
    goto LABEL_14;
  if ( !BG_PlayerUsesNVGHalfADS(ps, handler) )
    goto LABEL_14;
  _RAX = BG_WeaponCompleteDef(r_weapon, isAlternate);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm0, dword ptr [rax+194h]
    vcomiss xmm0, xmm1
  }
  if ( v13 | v14 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax+174h]
      vcomiss xmm0, xmm1
    }
    if ( v13 | v14 )
    {
LABEL_14:
      memset(&outZoomInfo, 0, sizeof(outZoomInfo));
      BG_GetADSZoomInfo(v12, r_weapon, isAlternate, &hybridScopeFractionInfo, &outZoomInfo);
      zoomCount = outZoomInfo.zoomCount;
      if ( outZoomInfo.zoomCount )
      {
        v19 = handler->GetWeaponMap(handler);
        ADSZoomLevel = BG_GetADSZoomLevel(v19, ps, r_weapon, zoomCount);
        _RBX = ADSZoomLevel;
        if ( ADSZoomLevel >= zoomCount )
        {
          LODWORD(v23) = ADSZoomLevel;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13251, ASSERT_TYPE_ASSERT, "(unsigned)( adsZoomLevel ) < (unsigned)( adsZoomInfo.zoomCount )", "adsZoomLevel doesn't index adsZoomInfo.zoomCount\n\t%i not in [0, %i)", v23, zoomCount) )
            __debugbreak();
        }
        __asm { vmovss  xmm0, [rsp+rbx*4+0C8h+outZoomInfo.zoomFov] }
      }
      else
      {
        __asm { vmovss  xmm0, cs:__real@42820000 }
      }
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_ADSZoomFov
==============
*/
float BG_ADSZoomFov(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, const bool getWeaponValues, bool *outIsNVGForcedFov)
{
  const BgWeaponMap *v12; 
  unsigned int zoomCount; 
  const BgWeaponMap *v18; 
  int ADSZoomLevel; 
  __int64 v22; 
  BgAdsZoomInfo outZoomInfo; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13224, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  v12 = handler->GetWeaponMap(handler);
  if ( ps && BG_PlayerUsesNVGHalfADS(ps, handler) )
  {
    _RAX = BG_WeaponCompleteDef(r_weapon, isAlternate);
    __asm { vxorps  xmm1, xmm1, xmm1 }
    if ( getWeaponValues )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rax+194h]
        vcomiss xmm0, xmm1
      }
      *outIsNVGForcedFov = 1;
      return *(float *)&_XMM0;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rax+174h]
      vcomiss xmm0, xmm1
    }
  }
  *outIsNVGForcedFov = 0;
  memset(&outZoomInfo, 0, sizeof(outZoomInfo));
  BG_GetADSZoomInfo(v12, r_weapon, isAlternate, hybridScopeFractionInfo, &outZoomInfo);
  zoomCount = outZoomInfo.zoomCount;
  if ( outZoomInfo.zoomCount )
  {
    v18 = handler->GetWeaponMap(handler);
    ADSZoomLevel = BG_GetADSZoomLevel(v18, ps, r_weapon, zoomCount);
    _RBX = ADSZoomLevel;
    if ( ADSZoomLevel >= zoomCount )
    {
      LODWORD(v22) = ADSZoomLevel;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13251, ASSERT_TYPE_ASSERT, "(unsigned)( adsZoomLevel ) < (unsigned)( adsZoomInfo.zoomCount )", "adsZoomLevel doesn't index adsZoomInfo.zoomCount\n\t%i not in [0, %i)", v22, zoomCount) )
        __debugbreak();
    }
    __asm { vmovss  xmm0, [rsp+rbx*4+0C8h+outZoomInfo.zoomFov] }
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@42820000 }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_ActiveUnderbarrel
==============
*/
bool BG_ActiveUnderbarrel(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  return WeaponPrimaryAttachment && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE;
}

/*
==============
BG_AddAttachmentModelToDObjHierarchy
==============
*/
void BG_AddAttachmentModelToDObjHierarchy(const Weapon *r_weapon, DObjModel *dobjModels, const unsigned __int8 attId, const WeaponAttachment *const weaponAttachment, const PlayerHandIndex hand, const bool useViewModel, const bool isDualWield, const DObjCamoParams *camoParams, const bool ignoreCollision, const bool stowedWeapon, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  const XModel *AttachmentModel; 
  bool attachRightWeaponAkimbo; 
  __int64 v19; 
  __int64 v20; 

  if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1728, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1729, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( attId >= 0x1Du )
  {
    LODWORD(v19) = attId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1730, ASSERT_TYPE_ASSERT, "(unsigned)( attId ) < (unsigned)( WEAPON_ATTACHMENT_ID_COUNT )", "attId doesn't index WEAPON_ATTACHMENT_ID_COUNT\n\t%i not in [0, %i)", v19, 29) )
      __debugbreak();
  }
  AttachmentModel = BG_GetAttachmentModel(weaponAttachment, r_weapon->attachmentVariationIndices[attId], useViewModel);
  if ( AttachmentModel )
  {
    if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
    {
      LODWORD(v20) = 2;
      LODWORD(v19) = hand;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1648, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v19, v20) )
        __debugbreak();
    }
    if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1649, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
      __debugbreak();
    if ( isDualWield )
    {
      if ( hand == WEAPON_HAND_DEFAULT )
      {
        attachRightWeaponAkimbo = weaponAttachment->attachRightWeaponAkimbo;
        goto LABEL_22;
      }
      if ( hand == WEAPON_HAND_LEFT )
      {
        attachRightWeaponAkimbo = weaponAttachment->attachLeftWeaponAkimbo;
LABEL_22:
        if ( !attachRightWeaponAkimbo )
          return;
      }
    }
    BG_AddAttachmentModelToTag(hand, r_weapon, weaponAttachment, AttachmentModel, camoParams, ignoreCollision, stowedWeapon, dobjModels, maxModels, numModels, outWeaponIKModels);
  }
}

/*
==============
BG_AddAttachmentModelToTag
==============
*/
void BG_AddAttachmentModelToTag(const PlayerHandIndex hand, const Weapon *r_weapon, const WeaponAttachment *weaponAttachment, const XModel *attachmentModel, const DObjCamoParams *camoParams, bool ignoreCollision, bool stowedWeapon, DObjModel *dobjModels, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  scr_string_t attachPoint; 
  scr_string_t v15; 
  const char *WeaponName; 
  char output[1024]; 

  if ( !attachmentModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1607, ASSERT_TYPE_ASSERT, "(attachmentModel)", (const char *)&queryFormat, "attachmentModel") )
    __debugbreak();
  if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1608, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1609, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !numModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1610, ASSERT_TYPE_ASSERT, "(numModels)", (const char *)&queryFormat, "numModels") )
    __debugbreak();
  if ( *numModels >= maxModels )
  {
    if ( !attachmentModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 121, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
      __debugbreak();
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F572B0, 546i64, maxModels, attachmentModel->name);
  }
  attachPoint = weaponAttachment->attachPoint;
  if ( attachPoint && DObjModelsHasBone(dobjModels, *numModels, attachPoint) )
    v15 = weaponAttachment->attachPoint;
  else
    v15 = 0;
  DObjInitModel(attachmentModel, v15, ignoreCollision, stowedWeapon, camoParams, &dobjModels[*numModels]);
  ++*numModels;
  if ( outWeaponIKModels && weaponAttachment->containsIKTag && !XAnimWeaponIKModelsContainer::AddXModel(outWeaponIKModels, hand, attachmentModel) )
  {
    WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1640, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", 12, WeaponName) )
      __debugbreak();
  }
}

/*
==============
BG_AddCarryObjectModel
==============
*/
__int64 BG_AddCarryObjectModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  unsigned int entityNum; 
  __int64 v9; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v13; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  entityNum = ci->entityNum;
  v9 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)numModels;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v9;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v9]);
  (*outModelTypes)[v9] = CHAR_MODEL_CARRY_OBJECT;
  v13 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v13;
  if ( v13 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v13;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, entityNum, fmt, outDObjModel);
  }
  return (unsigned int)(v9 + 1);
}

/*
==============
BG_AddCarryObjectModelToCorpse
==============
*/
__int64 BG_AddCarryObjectModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v8; 
  const CarryObjectDef *CarryObjectDef; 
  const XModel *carryWorldModel; 
  unsigned int v13; 
  const char *Name; 
  char *fmt; 
  DObjModel *outDObjModel; 

  v8 = numModels;
  *outBonesAdded = 0;
  if ( (ci->carryObjectFlags & 1) == 0 )
    return (unsigned int)numModels;
  CarryObjectDef = BG_GetCarryObjectDef(ci->carryObjectIndex);
  if ( !CarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22897, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  carryWorldModel = CarryObjectDef->carryWorldModel;
  if ( !carryWorldModel )
    return (unsigned int)v8;
  DObjInitModel(carryWorldModel, CarryObjectDef->attachTag, 1, 0, NULL, &dobjModels[v8]);
  (*outModelTypes)[v8] = CHAR_MODEL_CARRY_OBJECT;
  v13 = XModelNumBones(CarryObjectDef->carryWorldModel);
  *outBonesAdded = v13;
  if ( v13 + totalBoneCountSoFar > 0xFE )
  {
    Name = XModelGetName(CarryObjectDef->carryWorldModel);
    LODWORD(outDObjModel) = v13;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for carry object model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entNum, fmt, outDObjModel);
  }
  return (unsigned int)(v8 + 1);
}

/*
==============
BG_AddGlobalAmmoForAmmoType
==============
*/
void BG_AddGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  GlobalAmmo *v6; 
  int v10; 
  bool v11; 
  int v12; 
  int v13; 
  WeaponAmmoType ammoType; 
  int v15; 

  _RBX = r_ammoType;
  v6 = BG_GlobalAmmoForAmmoType(ps, r_ammoType);
  if ( !v6 )
  {
    _RAX = BG_FindGlobalAmmoSlot(ps);
    __asm { vmovups ymm0, ymmword ptr [rbx] }
    v6 = _RAX;
    __asm
    {
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rbx+20h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
    _RAX->ammoCount = 0;
  }
  v10 = v6->ammoCount;
  v11 = ammoCount + v10 < 0;
  v12 = ammoCount + v10;
  v6->ammoCount = v12;
  if ( v11 )
  {
    v15 = v12;
    ammoType = _RBX->ammoType;
    v13 = ammoCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6838, ASSERT_TYPE_ASSERT, "(globalAmmo->ammoCount >= 0)", "%s\n\tAfter adding %i rounds to the ammoCount for ammoType %i, we have %i rounds not in the clip", "globalAmmo->ammoCount >= 0", v13, ammoType, v15) )
      __debugbreak();
  }
}

/*
==============
BG_AddIgnoreEntToBP
==============
*/
void BG_AddIgnoreEntToBP(BulletFireParams *bp, int entityIndex)
{
  int ignoreHitEntCount; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 550, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !BG_IsIgnoreEntInBP(bp, entityIndex) )
  {
    ignoreHitEntCount = bp->ignoreHitEntCount;
    if ( ignoreHitEntCount >= 16 )
    {
      Com_PrintWarning(14, "BG_AddIgnoreEntToBP: %d is too many ignore hit entities.  May want to increase limit (BULLET_MAX_IGNORE_HIT_ENTRIES) of %d. \n", (unsigned int)ignoreHitEntCount, 16i64);
      ignoreHitEntCount = bp->ignoreHitEntCount;
    }
    bp->ignoreHitEntityQueue[ignoreHitEntCount % 16] = entityIndex;
    ++bp->ignoreHitEntCount;
  }
}

/*
==============
BG_AddParachuteModel
==============
*/
__int64 BG_AddParachuteModel(const characterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v9; 
  const SuitDef *SuitDef; 
  int v14; 
  _QWORD *v15; 
  __int64 v16; 
  __int64 v17; 
  scr_string_t tag_ik_loc_le; 
  const XModel *v19; 
  const XModel *v20; 
  scr_string_t tag_ik_loc_ri; 
  const XModel *v22; 
  const XModel *v23; 
  unsigned int v24; 
  const SuitDef *v25; 
  unsigned int v26; 
  unsigned int entityNum; 
  const char *Name; 
  char *fmt; 
  __int64 ignoreCollision; 
  vec3_t offsets; 
  vec4_t quat; 

  v9 = numModels;
  *outBonesAdded = 0;
  if ( !BG_SkydiveAnimStateNeedParachuteModel((const animScriptParachuteState_t)ci->skydiveAnimState) )
    return (unsigned int)v9;
  SuitDef = BG_GetSuitDef(ci->suitIndex);
  if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22944, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  if ( !SuitDef->skydive_parachuteWorldModel )
    return (unsigned int)v9;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+0C8h+offsets], xmm0
    vmovss  dword ptr [rsp+0C8h+offsets+4], xmm0
    vmovss  dword ptr [rsp+0C8h+offsets+8], xmm0
    vmovups xmm0, xmmword ptr cs:?quat_identity@@3Tvec4_t@@B; vec4_t const quat_identity
    vmovups xmmword ptr [rsp+0C8h+quat], xmm0
  }
  DObjInitSubmodel(SuitDef->skydive_parachuteWorldModel, (const scr_string_t)scr_const.j_spine4, 0, &offsets, &quat, 1, 0, NULL, &dobjModels[v9]);
  (*outModelTypes)[v9] = CHAR_MODEL_PARACHUTE;
  v14 = XModelNumBones(SuitDef->skydive_parachuteWorldModel);
  v15 = NtCurrentTeb()->Reserved1[11];
  v16 = tls_index;
  *outBonesAdded += v14;
  if ( !*(_QWORD *)(v15[v16] + 272i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_static.h", 169, ASSERT_TYPE_ASSERT, "(ms_activeBgs)", (const char *)&queryFormat, "ms_activeBgs") )
    __debugbreak();
  v17 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v16) + 272i64);
  if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22974, ASSERT_TYPE_ASSERT, "(bgameStatic)", (const char *)&queryFormat, "bgameStatic") )
    __debugbreak();
  tag_ik_loc_le = scr_const.tag_ik_loc_le;
  v19 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 136i64))(v17);
  DObjInitModel(v19, tag_ik_loc_le, 1, 0, NULL, &dobjModels[v9 + 1]);
  (*outModelTypes)[v9 + 1] = CHAR_MODEL_IK_TARGET;
  v20 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 136i64))(v17);
  *outBonesAdded += XModelNumBones(v20);
  tag_ik_loc_ri = scr_const.tag_ik_loc_ri;
  v22 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 144i64))(v17);
  DObjInitModel(v22, tag_ik_loc_ri, 1, 0, NULL, &dobjModels[v9 + 2]);
  (*outModelTypes)[v9 + 2] = CHAR_MODEL_IK_TARGET;
  v23 = (const XModel *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 144i64))(v17);
  *outBonesAdded += XModelNumBones(v23);
  v24 = v9 + 3;
  if ( totalBoneCountSoFar + *outBonesAdded > 0xFE )
  {
    v25 = BG_GetSuitDef(ci->suitIndex);
    if ( !v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22991, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    v26 = *outBonesAdded;
    entityNum = ci->entityNum;
    Name = XModelGetName(v25->skydive_parachuteWorldModel);
    LODWORD(ignoreCollision) = v26;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for parachute model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, entityNum, fmt, ignoreCollision);
  }
  return v24;
}

/*
==============
BG_AddParachuteModelToCorpse
==============
*/
__int64 BG_AddParachuteModelToCorpse(const int entNum, const corpseReferenceCharacterInfo_t *ci, DObjModel *dobjModels, int numModels, const unsigned int totalBoneCountSoFar, unsigned int *outBonesAdded, CharacterModelType (*outModelTypes)[32])
{
  __int64 v10; 
  const SuitDef *SuitDef; 
  const SuitDef *v15; 
  unsigned int v16; 
  const char *Name; 
  char *fmt; 
  __int64 ignoreCollision; 
  vec3_t offsets; 
  vec4_t quat; 

  v10 = numModels;
  *outBonesAdded = 0;
  if ( !BG_SkydiveAnimStateNeedParachuteModel((const animScriptParachuteState_t)ci->skydiveAnimState) )
    return (unsigned int)v10;
  SuitDef = BG_GetSuitDef(ci->suitIndex);
  if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22944, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  if ( !SuitDef->skydive_parachuteWorldModel )
    return (unsigned int)v10;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+0C8h+offsets], xmm0
    vmovss  dword ptr [rsp+0C8h+offsets+4], xmm0
    vmovss  dword ptr [rsp+0C8h+offsets+8], xmm0
    vmovups xmm0, xmmword ptr cs:?quat_identity@@3Tvec4_t@@B; vec4_t const quat_identity
    vmovups xmmword ptr [rsp+0C8h+quat], xmm0
  }
  DObjInitSubmodel(SuitDef->skydive_parachuteWorldModel, (const scr_string_t)scr_const.j_spine4, 0, &offsets, &quat, 1, 0, NULL, &dobjModels[v10]);
  (*outModelTypes)[v10] = CHAR_MODEL_PARACHUTE;
  *outBonesAdded += XModelNumBones(SuitDef->skydive_parachuteWorldModel);
  if ( totalBoneCountSoFar + *outBonesAdded > 0xFE )
  {
    v15 = BG_GetSuitDef(ci->suitIndex);
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23011, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    v16 = *outBonesAdded;
    Name = XModelGetName(v15->skydive_parachuteWorldModel);
    LODWORD(ignoreCollision) = v16;
    LODWORD(fmt) = totalBoneCountSoFar;
    Com_PrintError(16, "UpdateCharacterDObj: Too many bones for parachute model '%s' used for entity %d. Bones so far: %d. Bones this model would add: %d.\n", Name, (unsigned int)entNum, fmt, ignoreCollision);
  }
  return (unsigned int)(v10 + 1);
}

/*
==============
BG_AddStreamedViewWeaponsToList
==============
*/
char BG_AddStreamedViewWeaponsToList(const BgWeaponMap *const weaponMap, const playerState_s *const ps, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  int v4; 
  WeaponSlot *i; 
  __int64 v11; 

  v4 = 0;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22664, ASSERT_TYPE_ASSERT, "( ( weaponMap != nullptr ) )", "( weaponMap ) = %p", NULL) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22665, ASSERT_TYPE_ASSERT, "( ( ps != nullptr ) )", "( ps ) = %p", NULL) )
    __debugbreak();
  for ( i = &ps->weapEquippedData[0].slot; ; i += 4 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    _RDI = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v4]);
    if ( !BG_WeaponHasStreamedModels(_RDI) || *i == WEAPON_SLOT_EXECUTION )
      goto LABEL_18;
    v11 = *inOutWeaponCount;
    if ( (unsigned int)v11 >= 0x18 )
      break;
    __asm { vmovups ymm0, ymmword ptr [rdi] }
    _RCX = &(*outViewWeapons)[v11];
    __asm
    {
      vmovups ymmword ptr [rcx], ymm0
      vmovups xmm1, xmmword ptr [rdi+20h]
      vmovups xmmword ptr [rcx+20h], xmm1
      vmovsd  xmm0, qword ptr [rdi+30h]
      vmovsd  qword ptr [rcx+30h], xmm0
    }
    *(_DWORD *)&_RCX->weaponCamo = *(_DWORD *)&_RDI->weaponCamo;
    ++*inOutWeaponCount;
LABEL_18:
    if ( (unsigned int)++v4 >= 0xF )
      return 1;
  }
  return 0;
}

/*
==============
BG_AddStreamedWeaponModelToList
==============
*/
void BG_AddStreamedWeaponModelToList(const XModel *const addModel, const XModel *(*outList)[32], unsigned int *outCurListPos)
{
  unsigned int v6; 
  __int64 v7; 
  __int64 v8; 

  if ( !outList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22457, ASSERT_TYPE_ASSERT, "(outList)", (const char *)&queryFormat, "outList") )
    __debugbreak();
  if ( addModel )
  {
    v6 = *outCurListPos;
    v7 = 0i64;
    if ( *outCurListPos )
    {
      while ( (*outList)[v7] != addModel )
      {
        v7 = (unsigned int)(v7 + 1);
        if ( (unsigned int)v7 >= v6 )
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      if ( v6 >= 0x20 )
      {
        LODWORD(v8) = *outCurListPos;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22472, ASSERT_TYPE_ASSERT, "(unsigned)( outCurListPos ) < (unsigned)( ( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) + 3 ) )", "outCurListPos doesn't index MAX_NUM_WEAPON_STREAMED_XMODELS\n\t%i not in [0, %i)", v8, 32) )
          __debugbreak();
      }
      (*outList)[(*outCurListPos)++] = addModel;
    }
  }
}

/*
==============
BG_AddWeaponAttachmentModels
==============
*/
void BG_AddWeaponAttachmentModels(const Weapon *r_weapon, const PlayerHandIndex hand, bool isDualWield, bool useViewModel, bool ignoreCollision, bool stowedWeapon, DObjModel *dobjModels, unsigned __int16 maxModels, unsigned __int16 *numModels, XAnimWeaponIKModelsContainer *outWeaponIKModels, const DObjCamoParams *camoParams)
{
  AttachmentSlot v13; 
  __int64 v14; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  unsigned int v16; 
  int v17; 
  const WeaponAttachment *v18; 
  unsigned __int8 v19; 
  __int64 useViewModela; 
  __int64 isDualWielda; 
  DObjModel *dobjModelsa; 

  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1745, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !numModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1746, ASSERT_TYPE_ASSERT, "(numModels)", (const char *)&queryFormat, "numModels") )
    __debugbreak();
  dobjModelsa = (DObjModel *)BG_WeaponCompleteDef(r_weapon, 0);
  v13 = ATT_SLOT_RECEIVER;
  v14 = 0i64;
  do
  {
    WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, v13);
    if ( WeaponPrimaryAttachment )
      BG_AddAttachmentModelToDObjHierarchy(r_weapon, dobjModels, v13, WeaponPrimaryAttachment, hand, useViewModel, isDualWield, camoParams, ignoreCollision, stowedWeapon, maxModels, numModels, outWeaponIKModels);
    ++v13;
    ++v14;
  }
  while ( (unsigned int)v13 < ATT_SLOT_OTHER );
  v16 = 0;
  if ( r_weapon->weaponOthers )
  {
    if ( dobjModelsa[3].boneName > 0x10u )
    {
      LODWORD(isDualWielda) = 16;
      LODWORD(useViewModela) = dobjModelsa[3].boneName;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1763, ASSERT_TYPE_ASSERT, "( attList->attachmentCount ) <= ( 16 )", "attList->attachmentCount not in [0, MAX_ATTACHMENT_OTHERS]\n\t%u not in [0, %u]", useViewModela, isDualWielda) )
        __debugbreak();
    }
    if ( dobjModelsa[3].boneName )
    {
      do
      {
        v17 = 1 << v16;
        if ( (1 << v16 < 0 || (unsigned int)v17 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,int>(int)", "unsigned", (unsigned __int16)v17, "signed", v17) )
          __debugbreak();
        if ( ((unsigned __int16)v17 & r_weapon->weaponOthers) != 0 )
        {
          v18 = *(const WeaponAttachment **)(*(_QWORD *)dobjModelsa[3].offsets.v + 8i64 * v16);
          if ( v16 >= 0x10 )
          {
            LODWORD(isDualWielda) = 16;
            LODWORD(useViewModela) = v16;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", useViewModela, isDualWielda) )
              __debugbreak();
          }
          v19 = truncate_cast<unsigned char,unsigned int>(v16 + 13);
          BG_AddAttachmentModelToDObjHierarchy(r_weapon, dobjModels, v19, v18, hand, useViewModel, isDualWield, camoParams, ignoreCollision, stowedWeapon, maxModels, numModels, outWeaponIKModels);
        }
        ++v16;
      }
      while ( v16 < dobjModelsa[3].boneName );
    }
  }
}

/*
==============
BG_AdvanceTrace
==============
*/

bool __fastcall BG_AdvanceTrace(BulletFireParams *bp, const trace_t *trace, const vec3_t *hitPos, double dist)
{
  int EntityHitId; 
  int ignoreHitEntCount; 
  bool result; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  _RDI = hitPos;
  _RSI = trace;
  _RBX = bp;
  __asm { vmovaps xmm6, xmm3 }
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 617, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 618, ASSERT_TYPE_ASSERT, "(trace)", (const char *)&queryFormat, "trace") )
    __debugbreak();
  if ( _RSI->hitType == TRACE_HITTYPE_BEGIN && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 619, ASSERT_TYPE_ASSERT, "(trace->hitType != TRACE_HITTYPE_NONE)", (const char *)&queryFormat, "trace->hitType != TRACE_HITTYPE_NONE") )
    __debugbreak();
  EntityHitId = Trace_GetEntityHitId(_RSI);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 550, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !BG_IsIgnoreEntInBP(_RBX, EntityHitId) )
  {
    ignoreHitEntCount = _RBX->ignoreHitEntCount;
    if ( ignoreHitEntCount >= 16 )
    {
      Com_PrintWarning(14, "BG_AddIgnoreEntToBP: %d is too many ignore hit entities.  May want to increase limit (BULLET_MAX_IGNORE_HIT_ENTRIES) of %d. \n", (unsigned int)ignoreHitEntCount, 16i64);
      ignoreHitEntCount = _RBX->ignoreHitEntCount;
    }
    _RBX->ignoreHitEntityQueue[ignoreHitEntCount % 16] = EntityHitId;
    ++_RBX->ignoreHitEntCount;
  }
  if ( BG_IsIgnoreEntInBP(_RBX, 2046) )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm6, xmm0
      vmovss  xmm0, dword ptr [rsi+14h]
      vmovss  xmm1, dword ptr [rsi+10h]
      vmulss  xmm2, xmm1, dword ptr [rbx+80h]
      vmulss  xmm3, xmm0, dword ptr [rbx+84h]
      vmovss  xmm0, dword ptr [rsi+18h]
      vmulss  xmm1, xmm0, dword ptr [rbx+88h]
      vaddss  xmm4, xmm3, xmm2
      vaddss  xmm2, xmm4, xmm1
      vcomiss xmm2, cs:__real@be000000
      vmovss  xmm4, dword ptr [rbx+8Ch]
      vmulss  xmm2, xmm6, cs:__real@41000000
      vaddss  xmm0, xmm4, xmm2
      vmovss  dword ptr [rbx+8Ch], xmm0
      vmulss  xmm0, xmm2, dword ptr [rbx+80h]
      vaddss  xmm1, xmm0, dword ptr [rdi]
      vmovss  dword ptr [rbx+68h], xmm1
      vmulss  xmm0, xmm2, dword ptr [rbx+84h]
      vaddss  xmm1, xmm0, dword ptr [rdi+4]
      vmovss  dword ptr [rbx+6Ch], xmm1
      vmulss  xmm0, xmm2, dword ptr [rbx+88h]
      vaddss  xmm1, xmm0, dword ptr [rdi+8]
    }
    result = 0;
  }
  else
  {
    _RBX->start.v[0] = _RDI->v[0];
    _RBX->start.v[1] = _RDI->v[1];
    __asm { vmovss  xmm1, dword ptr [rdi+8] }
    result = 1;
  }
  __asm
  {
    vmovss  dword ptr [rbx+70h], xmm1
    vmovaps xmm6, [rsp+58h+var_28]
  }
  return result;
}

/*
==============
BG_AimAssistLockonStrength
==============
*/
float BG_AimAssistLockonStrength(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v11[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v11, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8361, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v5)->aimAssist )
        break;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    __asm { vmovss  xmm0, dword ptr [rcx+1Ch] }
  }
  else
  {
LABEL_8:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm { vmovss  xmm0, dword ptr [rax+414h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_AimAssistRange
==============
*/
void BG_AimAssistRange(const Weapon *r_weapon, bool isAlternate, float *aimAssistRange, float *aimAssistRangeAds)
{
  const WeaponDef *v8; 
  int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v12; 
  AttAimAssist *aimAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !aimAssistRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8301, ASSERT_TYPE_ASSERT, "(aimAssistRange)", (const char *)&queryFormat, "aimAssistRange") )
    __debugbreak();
  if ( !aimAssistRangeAds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8302, ASSERT_TYPE_ASSERT, "(aimAssistRangeAds)", (const char *)&queryFormat, "aimAssistRangeAds") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v9 = 0;
  *aimAssistRange = v8->aimAssistRange;
  *aimAssistRangeAds = v8->aimAssistRangeAds;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8310, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v12 = *i;
      aimAssist = (*i)->aimAssist;
      if ( aimAssist )
        break;
      if ( ++v9 >= WeaponAttachments_Internal )
        return;
    }
    *aimAssistRange = aimAssist->aimAssistRange;
    *aimAssistRangeAds = v12->aimAssist->aimAssistRangeAds;
  }
}

/*
==============
BG_AimAssistSlowdown
==============
*/
void BG_AimAssistSlowdown(const Weapon *r_weapon, bool isAlternate, float *aimAssistPitchSlowdown, float *aimAssistPitchSlowdownAds, float *aimAssistYawSlowdown, float *aimAssistYawSlowdownAds)
{
  const WeaponDef *v10; 
  int v11; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v14; 
  AttAimAssist *aimAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !aimAssistPitchSlowdown && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8327, ASSERT_TYPE_ASSERT, "(aimAssistPitchSlowdown)", (const char *)&queryFormat, "aimAssistPitchSlowdown") )
    __debugbreak();
  if ( !aimAssistPitchSlowdownAds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8328, ASSERT_TYPE_ASSERT, "(aimAssistPitchSlowdownAds)", (const char *)&queryFormat, "aimAssistPitchSlowdownAds") )
    __debugbreak();
  if ( !aimAssistYawSlowdown && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8329, ASSERT_TYPE_ASSERT, "(aimAssistYawSlowdown)", (const char *)&queryFormat, "aimAssistYawSlowdown") )
    __debugbreak();
  if ( !aimAssistYawSlowdownAds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8330, ASSERT_TYPE_ASSERT, "(aimAssistYawSlowdownAds)", (const char *)&queryFormat, "aimAssistYawSlowdownAds") )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v11 = 0;
  *aimAssistPitchSlowdown = v10->aimAssistPitchSlowdown;
  *aimAssistPitchSlowdownAds = v10->aimAssistPitchSlowdownAds;
  *aimAssistYawSlowdown = v10->aimAssistYawSlowdown;
  *aimAssistYawSlowdownAds = v10->aimAssistYawSlowdownAds;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8340, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v14 = *i;
      aimAssist = (*i)->aimAssist;
      if ( aimAssist )
        break;
      if ( ++v11 >= WeaponAttachments_Internal )
        return;
    }
    *aimAssistPitchSlowdown = aimAssist->aimAssistPitchSlowdown;
    *aimAssistPitchSlowdownAds = v14->aimAssist->aimAssistPitchSlowdownAds;
    *aimAssistYawSlowdown = v14->aimAssist->aimAssistYawSlowdown;
    *aimAssistYawSlowdownAds = v14->aimAssist->aimAssistYawSlowdownAds;
  }
}

/*
==============
BG_AllowWeaponSwitchWhileHoldingGrenade
==============
*/
bool BG_AllowWeaponSwitchWhileHoldingGrenade(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9972, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->allowGrenadeSwitching;
}

/*
==============
BG_AltDropADSTime
==============
*/
__int64 BG_AltDropADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 138i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltDropAkimboTime
==============
*/
__int64 BG_AltDropAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 140i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltDropTime
==============
*/
__int64 BG_AltDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 136i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltOverride3PInTime
==============
*/
__int64 BG_AltOverride3PInTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(NULL, r_weapon, isAlternate, isDualWielding, 92i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltOverride3PIsADS
==============
*/
bool BG_AltOverride3PIsADS(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return (unsigned __int16)(unsigned __int8)BG_GetWeaponFieldTimeWithDependentAnimation(NULL, r_weapon, isAlternate, isDualWielding, 191i64, WEAP_ANIM_3P_ADDITIVE_ALT_OVERRIDE) != 0;
}

/*
==============
BG_AltOverride3POutTime
==============
*/
__int64 BG_AltOverride3POutTime(const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(NULL, r_weapon, isAlternate, isDualWielding, 94i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltRaiseADSTime
==============
*/
__int64 BG_AltRaiseADSTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 6i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltRaiseAkimboTime
==============
*/
__int64 BG_AltRaiseAkimboTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 8i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltRaiseTime
==============
*/
__int64 BG_AltRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_AltSharesAmmo
==============
*/
bool BG_AltSharesAmmo(const Weapon *r_weapon)
{
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned int v2; 
  bool result; 
  WeaponAttachment **v4; 
  WeaponAttachment *v5; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  v2 = 0;
  result = 0;
  if ( AllWeaponAttachmentsWithIds )
  {
    v4 = attachments;
    do
    {
      if ( result )
        break;
      if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5026, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v5 = *v4;
      ++v2;
      ++v4;
      result = v5->shareAmmoWithAlt;
    }
    while ( v2 < AllWeaponAttachmentsWithIds );
  }
  return result;
}

/*
==============
BG_AlwaysFireAtMaxRangeInAds
==============
*/
_BOOL8 BG_AlwaysFireAtMaxRangeInAds(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v7; 
  const AttADSSettings *WeaponAdsSettings; 

  v7 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v7, 0);
  if ( WeaponAdsSettings )
    return WeaponAdsSettings->alwaysFireAtMaxRangeInAds;
  else
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->alwaysFireAtMaxRangeInAds;
}

/*
==============
BG_AmmoCounterClip
==============
*/
__int64 BG_AmmoCounterClip(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  ammoCounterClipType_t ammoCounterClip; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttUI *ui; 
  unsigned int v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  ammoCounterClip = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->ammoCounterClip;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16348, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ui = (*i)->ui;
      if ( ui )
        break;
      if ( ++v4 >= WeaponAttachments_Internal )
        return (unsigned int)ammoCounterClip;
    }
    v9 = ui->ammoCounterClip;
    if ( v9 )
      return v9;
  }
  return (unsigned int)ammoCounterClip;
}

/*
==============
BG_AmmoUsedPerShot
==============
*/
__int64 BG_AmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  __int64 result; 
  int iAmmoUsedPerShot; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8567, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      result = (unsigned int)(*v5)->ammoUsedPerShotOverride;
      if ( (int)result > 0 )
        break;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    iAmmoUsedPerShot = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iAmmoUsedPerShot;
    result = 1i64;
    if ( iAmmoUsedPerShot > 0 )
      return (unsigned int)iAmmoUsedPerShot;
  }
  return result;
}

/*
==============
BG_AnyUnderbarrelWeaponEquipped
==============
*/
__int64 BG_AnyUnderbarrelWeaponEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  unsigned int v4; 
  const Weapon *Weapon; 
  unsigned __int8 v6; 
  const WeaponCompleteDef *v7; 
  const WeaponCompleteDef *v8; 
  WeaponAttachment *v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1092, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1093, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v4 >= 0xF )
    {
      LODWORD(v12) = 15;
      LODWORD(v11) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v11, v12) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v4]);
    if ( !Weapon->weaponIdx )
      goto LABEL_29;
    v6 = Weapon->weaponAttachments[10];
    if ( !v6 )
      goto LABEL_29;
    v7 = BG_WeaponCompleteDef(Weapon, 0);
    v8 = v7;
    if ( v6 > v7->attachments[10].attachmentCount )
    {
      LODWORD(v13) = v7->attachments[10].attachmentCount;
      LODWORD(v12) = 1;
      LODWORD(v11) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 805, ASSERT_TYPE_ASSERT, "( 1 ) <= ( attachmentIndex ) && ( attachmentIndex ) <= ( attList->attachmentCount )", "attachmentIndex not in [1, attList->attachmentCount]\n\t%i not in [%i, %i]", v11, v12, v13) )
        __debugbreak();
    }
    v9 = v8->attachments[10].attachments[v6 - 1];
    if ( v9 )
      break;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 807, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", v8->szInternalName) )
      __debugbreak();
LABEL_29:
    if ( (int)++v4 >= 15 )
      return 0i64;
  }
  if ( (v9->weapClass != WEAPCLASS_GRENADE || v9->weaponType != WEAPTYPE_PROJECTILE) && !BG_IsUnderbarrelShotgun(v9) )
    goto LABEL_29;
  return 1i64;
}

/*
==============
BG_ApplyWeaponAnglesToShootingDirection
==============
*/
void BG_ApplyWeaponAnglesToShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t *angles, const vec3_t (*anglesCategorized)[30], const vec3_t *oldAngles, vec3_t *outNewAngles, vec3_t *outShootingAnglesLocal)
{
  vec3_t outAngles; 
  tmat33_t<vec3_t> in2; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> out; 

  _RBP = outShootingAnglesLocal;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20088, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !anglesCategorized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20089, ASSERT_TYPE_ASSERT, "(anglesCategorized)", (const char *)&queryFormat, "anglesCategorized") )
    __debugbreak();
  *outNewAngles = *oldAngles;
  BG_GetWeaponAnglesForShootingDirection(weaponMap, ps, r_weapon, isAlternate, anglesCategorized, &outAngles);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+108h+var_D8]
    vmovss  xmm1, dword ptr [rsp+108h+var_D8+4]
    vmovss  dword ptr [rbp+0], xmm0
    vmovss  xmm0, dword ptr [rsp+108h+var_D8+8]
    vmovss  dword ptr [rbp+8], xmm0
    vmovss  dword ptr [rbp+4], xmm1
  }
  AnglesToAxis(&outAngles, &axis);
  AnglesToAxis(outNewAngles, &in2);
  MatrixMultiply(&axis, &in2, &out);
  AxisToAngles(&out, outNewAngles);
}

/*
==============
BG_AssertOffhandIndexOrNone
==============
*/
void BG_AssertOffhandIndexOrNone(const Weapon *r_weapon)
{
  unsigned __int16 weaponIdx; 
  const char *WeaponName; 
  char output[1024]; 

  weaponIdx = r_weapon->weaponIdx;
  if ( weaponIdx && BG_WeaponDefAtIndex(weaponIdx)->offhandClass == OFFHAND_CLASS_NONE )
  {
    WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5008, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Weapon (%s) expected to be offhand weapon or no weapon at all, but is not.", WeaponName) )
      __debugbreak();
  }
}

/*
==============
BG_AttachmentUseMainSettings
==============
*/
bool BG_AttachmentUseMainSettings(const WeaponAttachment *attachment, const bool isAlternate, const bool isUsingHybridScope)
{
  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8182, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  return attachment->type == ATTACHMENT_UNDERBARREL && !isAlternate || BG_CanAttachmentHybridToggle(attachment) && !isUsingHybridScope;
}

/*
==============
BG_AutoAimRange
==============
*/
float BG_AutoAimRange(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+3F8h] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8283, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->aimAssist )
        break;
      ++v6;
      ++v9;
      if ( v6 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_9;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_9:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_BlastBackTime
==============
*/
__int64 BG_BlastBackTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 196i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlastFrontTime
==============
*/
__int64 BG_BlastFrontTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 192i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlastLeftTime
==============
*/
__int64 BG_BlastLeftTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 198i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlastRightTime
==============
*/
__int64 BG_BlastRightTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 194i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BlocksNVGADS
==============
*/
bool BG_BlocksNVGADS(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v5; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    v5 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1230, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    sight = v5->sight;
    if ( sight )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return sight->blockNVGADS;
}

/*
==============
BG_BlurSceneAdsInFraction
==============
*/
float BG_BlurSceneAdsInFraction(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  WeaponAttachment *v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v17[32]; 
  char v18; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v17, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    while ( 1 )
    {
      v9 = *v7;
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1186, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( v9->sight )
        break;
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_9;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rax]
      vcomiss xmm0, xmm6
    }
  }
  else
  {
LABEL_9:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm { vmovss  xmm0, dword ptr [rax+1084h] }
  }
  _R11 = &v18;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_BlurSceneAdsOutFraction
==============
*/
float BG_BlurSceneAdsOutFraction(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  WeaponAttachment *v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v17[32]; 
  char v18; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v17, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    while ( 1 )
    {
      v9 = *v7;
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1209, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( v9->sight )
        break;
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_9;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rax+4]
      vcomiss xmm0, xmm6
    }
  }
  else
  {
LABEL_9:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm { vmovss  xmm0, dword ptr [rax+1088h] }
  }
  _R11 = &v18;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_BoltActionReloadIncludesRechamber
==============
*/
__int64 BG_BoltActionReloadIncludesRechamber(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->boltActionReloadIncludesRechamber;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8046, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0x14D7];
}

/*
==============
BG_BreachRaiseTime
==============
*/
__int64 BG_BreachRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 146i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Interpolated
==============
*/

void __fastcall BG_BuildExplosionDamageRangeInfo_Interpolated(double innerDamage, double outerDamage, double damageRadius, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  __asm
  {
    vmovss  dword ptr [r9+8], xmm2
    vmovss  dword ptr [r9+0Ch], xmm2
    vmovss  dword ptr [r9+10h], xmm0
    vmovss  dword ptr [r9+14h], xmm1
    vmovss  dword ptr [r9+18h], xmm1
  }
  outDamageRangeInfo->useSteppedDamage = 0;
  outDamageRangeInfo->innerRadius = 0.0;
}

/*
==============
BG_BuildExplosionDamageRangeInfo_Stepped
==============
*/

void __fastcall BG_BuildExplosionDamageRangeInfo_Stepped(double innerRange, double innerDamage, double midRange, double midDamage, const float outerRange, const float outerDamage, BgExplosionDamageRangeInfo *outDamageRangeInfo)
{
  _RAX = outDamageRangeInfo;
  __asm
  {
    vmovss  dword ptr [rax+4], xmm0
    vmovss  xmm0, [rsp+outerRange]
    vmovss  dword ptr [rax+10h], xmm1
    vmovss  xmm1, [rsp+outerDamage]
    vmovss  dword ptr [rax+0Ch], xmm0
    vmovss  dword ptr [rax+18h], xmm1
    vmovss  dword ptr [rax+8], xmm2
    vmovss  dword ptr [rax+14h], xmm3
  }
  outDamageRangeInfo->useSteppedDamage = 1;
}

/*
==============
BG_BuildWeaponAnimArrays
==============
*/
_BOOL8 BG_BuildWeaponAnimArrays(const playerState_s *ps, const Weapon *r_weapon, bool bIsDualWielding, bool bIsAlternate, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const WeaponDef *v14; 
  const WeaponDef *v15; 
  WeaponAnimPackage *szXAnimsRightHanded; 
  bool v17; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  __int64 v20; 
  unsigned int v21; 
  AnimOverride *v22; 
  int HasUnderbarrelAmmo; 
  bool v26; 
  int v28; 
  AnimOverride *animOverrides[23]; 

  Sys_ProfBeginNamedEvent(0xFF808080, "BG_BuildWeaponAnimArrays");
  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18853, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18854, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18855, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18857, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  if ( outFootsteps && numAnims < 608 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18863, ASSERT_TYPE_ASSERT, "(numAnims >= NUM_WEAP_VIEWMODEL_ANIMS)", (const char *)&queryFormat, "numAnims >= NUM_WEAP_VIEWMODEL_ANIMS") )
    __debugbreak();
  memset_0(animOverrides, 0, 0xA8ui64);
  v14 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v15 = v14;
  if ( !bIsDualWielding )
    goto LABEL_24;
  if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2738, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  szXAnimsRightHanded = v15->szXAnimsRightHanded;
  if ( szXAnimsRightHanded && *((_QWORD *)szXAnimsRightHanded->anims + 236) )
  {
    v17 = BG_BuildWeaponAnimArrays_DualWield(ps, v15, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
  }
  else
  {
LABEL_24:
    IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
    v26 = IsMeleeComboOverride;
    AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
    v28 = AllWeaponAttachmentsCount;
    if ( IsMeleeComboOverride || AllWeaponAttachmentsCount )
    {
      v20 = 0i64;
      v21 = 0;
      if ( v15->numAnimOverrides )
      {
        do
        {
          v22 = &v15->animOverrides[v21];
          if ( BG_WeaponHasOverride(r_weapon, v22->bindings, v22->numBindings) )
          {
            animOverrides[v20] = v22;
            v20 = (unsigned int)(v20 + 1);
          }
          ++v21;
        }
        while ( v21 < v15->numAnimOverrides );
        IsMeleeComboOverride = v26;
      }
      BG_BuildWeaponAnimArrays_BaseAnimations(bIsAlternate, v15, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
      if ( IsMeleeComboOverride )
      {
        BG_BuildWeaponAnimArrays_MeleeComboWeapon(ps, r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
      }
      else
      {
        BG_BuildWeaponAnimArrays_AttachmentOverrides(ps, r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, (const AnimOverride **)animOverrides, v20, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
        BG_BuildWeaponAnimArrays_MeleeOverrides(r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, (const AnimOverride **)animOverrides, v20, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
      }
      if ( startAnim == WEAP_ANIM_ROOT && numAnims == 608 )
        BG_BuildWeaponAnimArrays_BlendSpaceOverrides(r_weapon, bIsAlternate, v15, rawAnimArrays, normalAnimArray, (const AnimOverride **)animOverrides, v20, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, WEAP_ANIM_ROOT, 608);
      BG_BuildWeaponAnimArrays_CarryOverrides(ps, v15, normalAnimArray, altAnimArray, startAnim, numAnims);
      if ( numAnims == 608 )
      {
        HasUnderbarrelAmmo = BG_HasUnderbarrelAmmo(r_weapon);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_ADS_DOWN);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_ADS_UP);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_SCOPE_TOGGLE_ON);
        BG_SetMustHaveAltAnim(HasUnderbarrelAmmo, normalAnimArray, altAnimArray, WEAP_ANIM_SCOPE_TOGGLE_OFF);
      }
      v17 = v28 > 0 || IsMeleeComboOverride;
    }
    else
    {
      v17 = BG_BuildWeaponAnimArrays_NoAttachments(ps, v15, bIsAlternate, rawAnimArrays, normalAnimArray, outBlendSpaces, altAnimArray, outBlendSpacesAlt, outFootsteps, startAnim, numAnims);
    }
  }
  Sys_ProfEndNamedEvent();
  return v17;
}

/*
==============
BG_BuildWeaponAnimArrays_AttachmentOverrides
==============
*/
void BG_BuildWeaponAnimArrays_AttachmentOverrides(const playerState_s *ps, const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const AnimOverride **animOverrides, const unsigned int numAnimOverrides, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const AnimOverride **v15; 
  unsigned int v16; 
  weapAnimFiles_t v17; 
  unsigned __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  const AnimOverride **v21; 
  __int64 v22; 
  __int64 v23; 
  const AnimOverride *v24; 
  unsigned int numBindings; 
  unsigned int v26; 
  unsigned int v27; 
  WeaponAnimPackage *overrides; 
  XAnimParts *v29; 
  __int64 v30; 
  WeaponAnimPackage *overridesAlt; 
  XAnimParts *v42; 
  __int64 v45; 
  __int64 v54; 
  __int64 v55; 
  __int64 v57; 
  XAnimParts **v58; 
  XAnimParts **v59; 
  int v60[616]; 
  int v61[616]; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18625, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18626, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18627, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  v15 = animOverrides;
  if ( !animOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18628, ASSERT_TYPE_ASSERT, "(animOverrides)", (const char *)&queryFormat, "animOverrides") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18629, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18631, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  memset_0(v61, 0, 0x998ui64);
  memset_0(v60, 0, 0x998ui64);
  if ( numAnims > 0 )
  {
    v16 = numAnimOverrides;
    v17 = startAnim;
    v57 = (unsigned int)numAnims;
    v18 = 8i64 * (int)startAnim;
    v58 = &normalAnimArray[v18 / 0xFFFFFFFFFFFFFFF8ui64];
    v19 = 0i64;
    v59 = &altAnimArray[v18 / 0xFFFFFFFFFFFFFFF8ui64];
    do
    {
      if ( (unsigned int)v17 >= NUM_WEAP_ANIMS )
      {
        LODWORD(v55) = 614;
        LODWORD(v54) = v17;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21746, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", v54, v55) )
          __debugbreak();
        v16 = numAnimOverrides;
      }
      v20 = 0i64;
      while ( FootstepToAnimMap[v20] != v17 )
      {
        if ( (unsigned __int64)++v20 >= 9 )
        {
          LODWORD(v20) = -1;
          break;
        }
      }
      if ( (unsigned int)(v17 - 262) > 0x17 && (unsigned int)(v17 - 448) > 0x9F && v16 )
      {
        v21 = v15;
        v22 = v16;
        v23 = (int)v20;
        do
        {
          v24 = *v21;
          if ( !*v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18657, ASSERT_TYPE_ASSERT, "(animOverride != nullptr)", (const char *)&queryFormat, "animOverride != nullptr") )
            __debugbreak();
          numBindings = v24->numBindings;
          v26 = v61[v19];
          if ( v24->numBindings > v26 || numBindings > v60[v19] )
          {
            v27 = v24->numBindings;
            if ( numBindings > v26 )
            {
              overrides = v24->overrides;
              if ( overrides )
              {
                v29 = overrides->anims[v18 / 8];
                v27 = v24->numBindings;
                if ( v29 )
                {
                  v58[v18 / 8] = v29;
                  v27 = v24->numBindings;
                  v61[v19] = v24->numBindings;
                  if ( !bIsAlternate && outFootsteps && v23 != -1 )
                  {
                    v30 = 4i64;
                    _R8 = &overrides->footstep[v23].leftCount;
                    _RDX = &outFootsteps[v23];
                    do
                    {
                      _RDX = (FootstepAnim *)((char *)_RDX + 128);
                      __asm { vmovups xmm0, xmmword ptr [r8] }
                      _R8 += 32;
                      __asm
                      {
                        vmovups xmmword ptr [rdx-80h], xmm0
                        vmovups xmm1, xmmword ptr [r8-70h]
                        vmovups xmmword ptr [rdx-70h], xmm1
                        vmovups xmm0, xmmword ptr [r8-60h]
                        vmovups xmmword ptr [rdx-60h], xmm0
                        vmovups xmm1, xmmword ptr [r8-50h]
                        vmovups xmmword ptr [rdx-50h], xmm1
                        vmovups xmm0, xmmword ptr [r8-40h]
                        vmovups xmmword ptr [rdx-40h], xmm0
                        vmovups xmm1, xmmword ptr [r8-30h]
                        vmovups xmmword ptr [rdx-30h], xmm1
                        vmovups xmm0, xmmword ptr [r8-20h]
                        vmovups xmmword ptr [rdx-20h], xmm0
                        vmovups xmm1, xmmword ptr [r8-10h]
                        vmovups xmmword ptr [rdx-10h], xmm1
                      }
                      --v30;
                    }
                    while ( v30 );
                    _RDX->leftCount = *_R8;
                    v27 = v24->numBindings;
                  }
                }
              }
            }
            if ( v27 > v60[v19] )
            {
              overridesAlt = v24->overridesAlt;
              if ( overridesAlt )
              {
                v42 = overridesAlt->anims[v18 / 8];
                if ( v42 )
                {
                  v59[v18 / 8] = v42;
                  v60[v19] = v24->numBindings;
                  if ( bIsAlternate && outFootsteps && v23 != -1 )
                  {
                    _RAX = &overridesAlt->footstep[v23].leftCount;
                    _RDX = &outFootsteps[v23];
                    v45 = 4i64;
                    do
                    {
                      _RDX = (FootstepAnim *)((char *)_RDX + 128);
                      __asm { vmovups xmm0, xmmword ptr [rax] }
                      _RAX += 32;
                      __asm
                      {
                        vmovups xmmword ptr [rdx-80h], xmm0
                        vmovups xmm1, xmmword ptr [rax-70h]
                        vmovups xmmword ptr [rdx-70h], xmm1
                        vmovups xmm0, xmmword ptr [rax-60h]
                        vmovups xmmword ptr [rdx-60h], xmm0
                        vmovups xmm1, xmmword ptr [rax-50h]
                        vmovups xmmword ptr [rdx-50h], xmm1
                        vmovups xmm0, xmmword ptr [rax-40h]
                        vmovups xmmword ptr [rdx-40h], xmm0
                        vmovups xmm1, xmmword ptr [rax-30h]
                        vmovups xmmword ptr [rdx-30h], xmm1
                        vmovups xmm0, xmmword ptr [rax-20h]
                        vmovups xmmword ptr [rdx-20h], xmm0
                        vmovups xmm1, xmmword ptr [rax-10h]
                        vmovups xmmword ptr [rdx-10h], xmm1
                      }
                      --v45;
                    }
                    while ( v45 );
                    _RDX->leftCount = *_RAX;
                  }
                }
              }
            }
          }
          ++v21;
          --v22;
        }
        while ( v22 );
        v17 = startAnim;
        v15 = animOverrides;
      }
      v16 = numAnimOverrides;
      ++v17;
      ++v19;
      startAnim = v17;
      v18 += 8i64;
      --v57;
    }
    while ( v57 );
  }
}

/*
==============
BG_BuildWeaponAnimArrays_BaseAnimations
==============
*/
void BG_BuildWeaponAnimArrays_BaseAnimations(bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  __int64 v19; 
  weapAnimFiles_t v20; 
  unsigned __int64 v21; 
  XAnimParts **v22; 
  XAnimParts **anims; 
  XAnimParts *v24; 
  char v25; 
  FootstepAnimType FootstepFromAnim; 
  __int64 v27; 
  __int64 v28; 
  __int64 v31; 
  XAnimParts **v42; 

  _RSI = rawAnimArrays;
  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18560, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18561, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18562, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18563, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18565, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  if ( outFootsteps )
    memcpy_0(outFootsteps, _RSI->footsteps, 0x1A34ui64);
  _RAX = outBlendSpaces;
  if ( outBlendSpaces )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+1330h]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rsi+1350h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
  }
  _RAX = outBlendSpacesAlt;
  if ( outBlendSpacesAlt )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+26A0h]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rsi+26C0h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
  }
  v19 = numAnims;
  if ( numAnims > 0 )
  {
    v20 = startAnim;
    v21 = 8i64 * (int)startAnim;
    v22 = &normalAnimArray[v21 / 0xFFFFFFFFFFFFFFF8ui64];
    v42 = v22;
    do
    {
      v22[v21 / 8] = _RSI->xAnims[v21 / 8];
      anims = pDef->szXAnims->anims;
      if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2550, ASSERT_TYPE_ASSERT, "(originalAnims)", (const char *)&queryFormat, "originalAnims") )
        __debugbreak();
      if ( _RSI == (const RawWeaponAnimArrays *)-4976i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2551, ASSERT_TYPE_ASSERT, "(modifiedAnims)", (const char *)&queryFormat, "modifiedAnims") )
        __debugbreak();
      if ( !_RSI->xAnimsAlt[v21 / 8] || anims[v21 / 8] )
      {
        v25 = 0;
        v24 = v42[v21 / 8];
      }
      else
      {
        v24 = _RSI->xAnimsAlt[v21 / 8];
        v25 = 1;
      }
      *(&altAnimArray[v21 / 8] - (int)startAnim) = v24;
      if ( outFootsteps )
      {
        if ( bIsAlternate )
        {
          FootstepFromAnim = BG_GetFootstepFromAnim(v20);
          if ( FootstepFromAnim != FOOTSTEP_ANIM_INVALID )
          {
            v27 = FootstepFromAnim;
            v28 = 26612i64;
            if ( !v25 )
              v28 = 19904i64;
            _RDX = &outFootsteps[v27];
            _RAX = (int *)((char *)_RSI + v27 * 516 + v28);
            v31 = 4i64;
            do
            {
              _RDX = (FootstepAnim *)((char *)_RDX + 128);
              __asm { vmovups xmm0, xmmword ptr [rax] }
              _RAX += 32;
              __asm
              {
                vmovups xmmword ptr [rdx-80h], xmm0
                vmovups xmm1, xmmword ptr [rax-70h]
                vmovups xmmword ptr [rdx-70h], xmm1
                vmovups xmm0, xmmword ptr [rax-60h]
                vmovups xmmword ptr [rdx-60h], xmm0
                vmovups xmm1, xmmword ptr [rax-50h]
                vmovups xmmword ptr [rdx-50h], xmm1
                vmovups xmm0, xmmword ptr [rax-40h]
                vmovups xmmword ptr [rdx-40h], xmm0
                vmovups xmm1, xmmword ptr [rax-30h]
                vmovups xmmword ptr [rdx-30h], xmm1
                vmovups xmm0, xmmword ptr [rax-20h]
                vmovups xmmword ptr [rdx-20h], xmm0
                vmovups xmm1, xmmword ptr [rax-10h]
                vmovups xmmword ptr [rdx-10h], xmm1
              }
              --v31;
            }
            while ( v31 );
            _RDX->leftCount = *_RAX;
          }
        }
      }
      v22 = v42;
      ++v20;
      v21 += 8i64;
      --v19;
    }
    while ( v19 );
  }
}

/*
==============
BG_BuildWeaponAnimArrays_BlendSpaceOverrides
==============
*/
void BG_BuildWeaponAnimArrays_BlendSpaceOverrides(const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const AnimOverride **animOverrides, const unsigned int numAnimOverrides, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const AnimOverride **v14; 
  unsigned int v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  unsigned int v21; 
  __int64 v22; 
  const AnimOverride **v23; 
  const AnimOverride *v24; 
  unsigned int numBindings; 
  WeaponAnimPackage *overrides; 
  __int64 v27; 
  WeaponAnimPackage *overridesAlt; 
  __int64 v29; 
  __int64 v30; 
  __int64 v31; 
  __int64 v32; 
  __int64 v33; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18773, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18774, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18775, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  v14 = animOverrides;
  if ( !animOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18776, ASSERT_TYPE_ASSERT, "(animOverrides)", (const char *)&queryFormat, "animOverrides") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18777, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18779, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v15 = numAnimOverrides;
  v16 = 448i64;
  v17 = 0i64;
  v18 = 8i64;
  v30 = 0i64;
  v33 = 448i64;
  v31 = 8i64;
  v19 = 467i64;
  do
  {
    v20 = 0;
    v21 = 0;
    if ( !v15 )
      goto LABEL_55;
    v22 = v15;
    v23 = v14;
    v32 = v15;
    do
    {
      if ( !*v23 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18792, ASSERT_TYPE_ASSERT, "(animOverrides[overrideIndex] != nullptr)", (const char *)&queryFormat, "animOverrides[overrideIndex] != nullptr") )
          __debugbreak();
        v22 = v32;
      }
      v24 = *v23;
      numBindings = (*v23)->numBindings;
      if ( numBindings > v20 )
      {
        overrides = v24->overrides;
        if ( overrides && *(BlendSpace2DDef **)((char *)overrides->blendSpaces + v17) )
        {
          v27 = v16;
          if ( v16 <= v19 )
          {
            do
            {
              if ( (unsigned __int64)(v27 - 448) > 0x9F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18804, ASSERT_TYPE_ASSERT, "(( (WEAP_ANIM_BLEND_SPACE_FIRST <= index) && (index <= WEAP_ANIM_BLEND_SPACE_LAST) ))", (const char *)&queryFormat, "WEAPONANIM_ISBLENDSPACEANIM( index )") )
                __debugbreak();
              normalAnimArray[v27] = v24->overrides->anims[v27];
              ++v27;
            }
            while ( v27 <= v19 );
            v16 = v33;
          }
          if ( outBlendSpaces )
            *(const BlendSpace2DDef **)((char *)outBlendSpaces + v17) = *(BlendSpace2DDef **)((char *)v24->overrides->blendSpaces + v17);
          v20 = v24->numBindings;
          numBindings = v24->numBindings;
        }
      }
      else if ( numBindings <= v21 )
      {
        goto LABEL_53;
      }
      if ( numBindings > v21 )
      {
        overridesAlt = v24->overridesAlt;
        if ( overridesAlt )
        {
          if ( *(BlendSpace2DDef **)((char *)overridesAlt->blendSpaces + v17) )
          {
            v29 = v16;
            if ( v16 <= v19 )
            {
              do
              {
                if ( (unsigned __int64)(v29 - 448) > 0x9F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18825, ASSERT_TYPE_ASSERT, "(( (WEAP_ANIM_BLEND_SPACE_FIRST <= index) && (index <= WEAP_ANIM_BLEND_SPACE_LAST) ))", (const char *)&queryFormat, "WEAPONANIM_ISBLENDSPACEANIM( index )") )
                  __debugbreak();
                altAnimArray[v29] = v24->overridesAlt->anims[v29];
                ++v29;
              }
              while ( v29 <= v19 );
              v17 = v30;
              v16 = v33;
            }
            if ( outBlendSpacesAlt )
              *(const BlendSpace2DDef **)((char *)outBlendSpacesAlt + v17) = *(BlendSpace2DDef **)((char *)v24->overridesAlt->blendSpaces + v17);
            v21 = v24->numBindings;
          }
        }
      }
      v22 = v32;
LABEL_53:
      ++v23;
      v32 = --v22;
    }
    while ( v22 );
    v18 = v31;
    v15 = numAnimOverrides;
    v14 = animOverrides;
LABEL_55:
    v16 += 20i64;
    v17 += 8i64;
    v33 = v16;
    v19 += 20i64;
    v30 = v17;
    v31 = --v18;
  }
  while ( v18 );
}

/*
==============
BG_BuildWeaponAnimArrays_CarryOverrides
==============
*/
void BG_BuildWeaponAnimArrays_CarryOverrides(const playerState_s *ps, const WeaponDef *pDef, XAnimParts **normalAnimArray, XAnimParts **altAnimArray, weapAnimFiles_t startAnim, int numAnims)
{
  const CarryObjectDef *PlayerCarryObjectDef; 
  CarryAnimOverride *carryAnimOverrides; 
  __int64 v12; 
  WeaponAnimPackage *animPackage; 
  WeaponAnimPackage *animPackageAlt; 
  __int64 v15; 
  unsigned __int64 v16; 
  unsigned __int64 v17; 
  unsigned __int64 v18; 
  XAnimParts **v19; 
  XAnimParts **v20; 
  XAnimParts **anims; 
  XAnimParts **v22; 
  XAnimParts *v23; 

  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18328, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18329, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18330, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18332, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  if ( ps && BG_CarryObject_IsActive(ps) )
  {
    PlayerCarryObjectDef = BG_GetPlayerCarryObjectDef(ps);
    if ( !PlayerCarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18347, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
      __debugbreak();
    carryAnimOverrides = pDef->carryAnimOverrides;
    v12 = 0i64;
    while ( carryAnimOverrides->carryObjectType != PlayerCarryObjectDef->type )
    {
      ++v12;
      ++carryAnimOverrides;
      if ( v12 >= 5 )
        return;
    }
    animPackage = carryAnimOverrides->animPackage;
    animPackageAlt = carryAnimOverrides->animPackageAlt;
    if ( animPackage || animPackageAlt )
    {
      v15 = numAnims;
      if ( numAnims > 0 )
      {
        v16 = 8i64 * (int)startAnim;
        v17 = (int)startAnim - 262i64;
        v18 = v16 - (_QWORD)normalAnimArray;
        v19 = &normalAnimArray[v16 / 0xFFFFFFFFFFFFFFF8ui64];
        v20 = &altAnimArray[v16 / 0xFFFFFFFFFFFFFFF8ui64];
        while ( 1 )
        {
          if ( animPackage )
          {
            anims = carryAnimOverrides->animPackage->anims;
            if ( v17 > 0x17 )
            {
              if ( anims[v16 / 8] )
                v19[v16 / 8] = *(XAnimParts **)((char *)anims + (_QWORD)&v19[v16 / 8] + v18);
            }
            else
            {
              v19[v16 / 8] = anims[v16 / 8];
            }
          }
          if ( !animPackageAlt )
            goto LABEL_37;
          v22 = carryAnimOverrides->animPackageAlt->anims;
          if ( v17 <= 0x17 )
            break;
          if ( v22[v16 / 8] )
          {
            v23 = *(XAnimParts **)((char *)v22 + (_QWORD)v19 + v18 + v16);
            goto LABEL_36;
          }
LABEL_37:
          ++v17;
          v16 += 8i64;
          if ( !--v15 )
            return;
        }
        v23 = v22[v16 / 8];
LABEL_36:
        v20[v16 / 8] = v23;
        goto LABEL_37;
      }
    }
  }
}

/*
==============
BG_BuildWeaponAnimArrays_DualWield
==============
*/
bool BG_BuildWeaponAnimArrays_DualWield(const playerState_s *ps, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  __int64 v14; 
  XAnimParts **v15; 
  char *v16; 
  XAnimParts *v17; 
  XAnimParts *v18; 

  _RBX = rawAnimArrays;
  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18408, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18409, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18410, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18412, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v14 = numAnims;
  if ( numAnims > 0 )
  {
    v15 = normalAnimArray;
    v16 = (char *)_RBX + 8i64 * (int)startAnim + 14928 - (_QWORD)normalAnimArray;
    do
    {
      v17 = *(XAnimParts **)((char *)v15++ + (_QWORD)v16 - 4976);
      v18 = NULL;
      if ( v17 )
        v18 = v17;
      *(v15 - 1) = v18;
      *(XAnimParts **)((char *)v15 + (char *)altAnimArray - (char *)normalAnimArray - 8) = *(XAnimParts **)((char *)v15 + (_QWORD)v16 - 8);
      --v14;
    }
    while ( v14 );
  }
  if ( outFootsteps )
    memcpy_0(outFootsteps, _RBX->footstepsLeftHanded, 0x1A34ui64);
  _RAX = outBlendSpaces;
  if ( outBlendSpaces )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3A10h]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rbx+3A30h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
  }
  _RAX = outBlendSpacesAlt;
  if ( outBlendSpacesAlt )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+4D80h]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rbx+4DA0h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
  }
  BG_BuildWeaponAnimArrays_CarryOverrides(ps, pDef, normalAnimArray, altAnimArray, startAnim, numAnims);
  return 0;
}

/*
==============
BG_BuildWeaponAnimArrays_MeleeComboWeapon
==============
*/
void BG_BuildWeaponAnimArrays_MeleeComboWeapon(const playerState_s *ps, const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  int meleeComboSeqIdx; 
  signed int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v17; 
  __int64 v18; 
  AnimOverride *v19; 
  WeaponAnimPackage *overrides; 
  WeaponAnimPackage *overridesAlt; 
  weapAnimFiles_t v22; 
  unsigned __int64 v23; 
  XAnimParts **v24; 
  XAnimParts **v25; 
  __int64 v26; 
  XAnimParts *v27; 
  bool v28; 
  XAnimParts *v29; 
  __int64 v30; 
  __int64 v31; 
  XAnimParts *v42; 
  __int64 v43; 
  __int64 v44; 
  __int64 v55; 
  __int64 v56; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18496, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18497, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18498, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18499, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18501, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  meleeComboSeqIdx = 0;
  if ( ps )
    meleeComboSeqIdx = ps->weapCommon.meleeComboSeqIdx;
  AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
  v17 = AnimOverrideIdxForMeleeComboSeq;
  if ( AnimOverrideIdxForMeleeComboSeq >= 0 )
  {
    if ( AnimOverrideIdxForMeleeComboSeq >= pDef->numAnimOverrides )
    {
      LODWORD(v55) = AnimOverrideIdxForMeleeComboSeq;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18513, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( pDef->numAnimOverrides )", "animOverrideIdx doesn't index pDef->numAnimOverrides\n\t%i not in [0, %i)", v55, pDef->numAnimOverrides) )
        __debugbreak();
    }
    v18 = numAnims;
    v19 = &pDef->animOverrides[v17];
    overrides = v19->overrides;
    overridesAlt = v19->overridesAlt;
    if ( numAnims > 0 )
    {
      v22 = startAnim;
      v23 = 8i64 * (int)startAnim;
      v24 = &normalAnimArray[v23 / 0xFFFFFFFFFFFFFFF8ui64];
      v25 = &altAnimArray[v23 / 0xFFFFFFFFFFFFFFF8ui64];
      while ( 1 )
      {
        if ( (unsigned int)v22 >= NUM_WEAP_ANIMS )
        {
          LODWORD(v56) = 614;
          LODWORD(v55) = v22;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21746, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", v55, v56) )
            __debugbreak();
        }
        v26 = 0i64;
        while ( FootstepToAnimMap[v26] != v22 )
        {
          if ( (unsigned __int64)++v26 >= 9 )
          {
            LODWORD(v26) = -1;
            break;
          }
        }
        if ( (unsigned int)(v22 - 262) > 0x17 )
          break;
        if ( overrides )
          v27 = overrides->anims[v23 / 8];
        else
          v27 = NULL;
        v24[v23 / 8] = v27;
        if ( overridesAlt )
          v25[v23 / 8] = overridesAlt->anims[v23 / 8];
        else
          v25[v23 / 8] = NULL;
LABEL_55:
        ++v22;
        v23 += 8i64;
        if ( !--v18 )
          return;
      }
      if ( overrides )
      {
        v28 = bIsAlternate;
        v29 = overrides->anims[v23 / 8];
        if ( !v29 || (v24[v23 / 8] = v29, bIsAlternate) || !outFootsteps || (_DWORD)v26 == -1 )
        {
LABEL_47:
          if ( overridesAlt )
          {
            v42 = overridesAlt->anims[v23 / 8];
            if ( v42 )
            {
              v25[v23 / 8] = v42;
              if ( v28 && outFootsteps && (_DWORD)v26 != -1 )
              {
                v43 = (int)v26;
                v44 = 4i64;
                _R8 = &overridesAlt->footstep[v43].leftCount;
                _RCX = &outFootsteps[v43];
                do
                {
                  __asm
                  {
                    vmovups xmm0, xmmword ptr [r8]
                    vmovups xmmword ptr [rcx], xmm0
                    vmovups xmm1, xmmword ptr [r8+10h]
                    vmovups xmmword ptr [rcx+10h], xmm1
                    vmovups xmm0, xmmword ptr [r8+20h]
                    vmovups xmmword ptr [rcx+20h], xmm0
                    vmovups xmm1, xmmword ptr [r8+30h]
                    vmovups xmmword ptr [rcx+30h], xmm1
                    vmovups xmm0, xmmword ptr [r8+40h]
                    vmovups xmmword ptr [rcx+40h], xmm0
                    vmovups xmm1, xmmword ptr [r8+50h]
                    vmovups xmmword ptr [rcx+50h], xmm1
                    vmovups xmm0, xmmword ptr [r8+60h]
                    vmovups xmmword ptr [rcx+60h], xmm0
                    vmovups xmm1, xmmword ptr [r8+70h]
                  }
                  _R8 += 32;
                  _RCX = (FootstepAnim *)((char *)_RCX + 128);
                  __asm { vmovups xmmword ptr [rcx-10h], xmm1 }
                  --v44;
                }
                while ( v44 );
                _RCX->leftCount = *_R8;
              }
            }
          }
          goto LABEL_55;
        }
        v30 = (int)v26;
        v31 = 4i64;
        _R9 = &overrides->footstep[v30].leftCount;
        _R8 = &outFootsteps[v30];
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [r9]
            vmovups xmmword ptr [r8], xmm0
            vmovups xmm1, xmmword ptr [r9+10h]
            vmovups xmmword ptr [r8+10h], xmm1
            vmovups xmm0, xmmword ptr [r9+20h]
            vmovups xmmword ptr [r8+20h], xmm0
            vmovups xmm1, xmmword ptr [r9+30h]
            vmovups xmmword ptr [r8+30h], xmm1
            vmovups xmm0, xmmword ptr [r9+40h]
            vmovups xmmword ptr [r8+40h], xmm0
            vmovups xmm1, xmmword ptr [r9+50h]
            vmovups xmmword ptr [r8+50h], xmm1
            vmovups xmm0, xmmword ptr [r9+60h]
            vmovups xmmword ptr [r8+60h], xmm0
            vmovups xmm1, xmmword ptr [r9+70h]
          }
          _R8 = (FootstepAnim *)((char *)_R8 + 128);
          _R9 += 32;
          __asm { vmovups xmmword ptr [r8-10h], xmm1 }
          --v31;
        }
        while ( v31 );
        _R8->leftCount = *_R9;
      }
      v28 = bIsAlternate;
      goto LABEL_47;
    }
  }
}

/*
==============
BG_BuildWeaponAnimArrays_MeleeOverrides
==============
*/
void BG_BuildWeaponAnimArrays_MeleeOverrides(const Weapon *r_weapon, bool bIsAlternate, const WeaponDef *pDef, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const AnimOverride **animOverrides, const unsigned int numAnimOverrides, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  const AnimOverride **v14; 
  unsigned int v15; 
  unsigned int v16; 
  __int64 v17; 
  const AnimOverride *v18; 
  unsigned int numBindings; 
  __int64 v20; 
  XAnimParts **v21; 
  __int64 v22; 
  XAnimParts **v23; 

  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18711, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18712, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18713, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  v14 = animOverrides;
  if ( !animOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18714, ASSERT_TYPE_ASSERT, "(animOverrides)", (const char *)&queryFormat, "animOverrides") )
    __debugbreak();
  if ( !pDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18715, ASSERT_TYPE_ASSERT, "(pDef)", (const char *)&queryFormat, "pDef") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18717, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v15 = 0;
  v16 = 0;
  if ( numAnimOverrides )
  {
    v17 = numAnimOverrides;
    while ( 1 )
    {
      v18 = *v14;
      if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18724, ASSERT_TYPE_ASSERT, "(animOverride != nullptr)", (const char *)&queryFormat, "animOverride != nullptr") )
        __debugbreak();
      numBindings = v18->numBindings;
      if ( v18->numBindings > v15 )
        break;
      if ( numBindings > v16 )
        goto LABEL_33;
LABEL_40:
      ++v14;
      if ( !--v17 )
        return;
    }
    if ( v18->overrides )
    {
      v20 = 0i64;
      if ( numAnims > 0i64 )
      {
        v21 = normalAnimArray;
        do
        {
          if ( (unsigned __int64)((int)startAnim + v20 - 262) <= 0x17 )
          {
            *v21 = *(XAnimParts **)((char *)v18->overrides->anims + 8i64 * (int)startAnim - (_QWORD)normalAnimArray + (unsigned __int64)v21);
            v15 = v18->numBindings;
            numBindings = v18->numBindings;
          }
          ++v20;
          ++v21;
        }
        while ( v20 < numAnims );
      }
    }
LABEL_33:
    if ( numBindings > v16 )
    {
      if ( v18->overridesAlt )
      {
        v22 = 0i64;
        if ( numAnims > 0i64 )
        {
          v23 = altAnimArray;
          do
          {
            if ( (unsigned __int64)((int)startAnim + v22 - 262) <= 0x17 )
            {
              *v23 = *(XAnimParts **)((char *)v18->overridesAlt->anims + 8i64 * (int)startAnim - (_QWORD)altAnimArray + (unsigned __int64)v23);
              v16 = v18->numBindings;
            }
            ++v22;
            ++v23;
          }
          while ( v22 < numAnims );
        }
      }
    }
    goto LABEL_40;
  }
}

/*
==============
BG_BuildWeaponAnimArrays_NoAttachments
==============
*/
bool BG_BuildWeaponAnimArrays_NoAttachments(const playerState_s *ps, const WeaponDef *pDef, bool bIsAlternate, const RawWeaponAnimArrays *const rawAnimArrays, XAnimParts **normalAnimArray, const BlendSpace2DDef **outBlendSpaces, XAnimParts **altAnimArray, const BlendSpace2DDef **outBlendSpacesAlt, FootstepAnim *outFootsteps, weapAnimFiles_t startAnim, int numAnims)
{
  __int64 v15; 
  XAnimParts **v16; 
  char *v17; 
  XAnimParts *v18; 
  XAnimParts *v19; 
  __int64 v20; 

  _RBX = rawAnimArrays;
  if ( !rawAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18452, ASSERT_TYPE_ASSERT, "(rawAnimArrays)", (const char *)&queryFormat, "rawAnimArrays") )
    __debugbreak();
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18453, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18454, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( (unsigned int)(numAnims - 1) > 0x265 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18456, ASSERT_TYPE_ASSERT, "((numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS))", (const char *)&queryFormat, "(numAnims > 0) && (numAnims <= NUM_WEAP_ANIMS)") )
    __debugbreak();
  v15 = numAnims;
  if ( numAnims > 0 )
  {
    v16 = normalAnimArray;
    v17 = (char *)_RBX + 8i64 * (int)startAnim - (_QWORD)normalAnimArray;
    do
    {
      v18 = *(XAnimParts **)((char *)v16++ + (_QWORD)v17);
      v19 = NULL;
      if ( v18 )
        v19 = v18;
      *(v16 - 1) = v19;
      *(XAnimParts **)((char *)v16 + (char *)altAnimArray - (char *)normalAnimArray - 8) = *(XAnimParts **)((char *)v16 + (_QWORD)v17 + 4968);
      --v15;
    }
    while ( v15 );
  }
  if ( outFootsteps )
  {
    v20 = 26612i64;
    if ( !bIsAlternate )
      v20 = 19904i64;
    memcpy_0(outFootsteps, (char *)_RBX + v20, 0x1A34ui64);
  }
  _RAX = outBlendSpaces;
  if ( outBlendSpaces )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+1330h]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rbx+1350h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
  }
  _RAX = outBlendSpacesAlt;
  if ( outBlendSpacesAlt )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+26A0h]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rbx+26C0h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
  }
  BG_BuildWeaponAnimArrays_CarryOverrides(ps, pDef, normalAnimArray, altAnimArray, startAnim, numAnims);
  return 0;
}

/*
==============
BG_BurstFireIsAuto
==============
*/
bool BG_BurstFireIsAuto(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  WeaponAttachment *v7; 
  AttBurst *burst; 
  const WeaponDef *v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( BG_GetWeaponFireType(r_weapon, isAlternate) != WEAPON_FIRETYPE_BURST || !r_weapon->weaponIdx )
    return 0;
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      v7 = *v6;
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7050, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      burst = v7->burst;
      if ( burst )
        return burst->burstFireAuto;
      ++v4;
      ++v6;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7059, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v9->burstFireAuto;
  }
}

/*
==============
BG_CalculateEaseMotionFactor
==============
*/

float __fastcall BG_CalculateEaseMotionFactor(double weaponPosFrac, AdsOffsetInterpolationType lerpType)
{
  int v48; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm7
    vmovaps xmm7, xmm0
  }
  if ( (unsigned int)lerpType >= ADS_OFFSET_INTERP_TYPE_COUNT )
  {
    v48 = 9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22417, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>(lerpType) ) < (unsigned)( ADS_OFFSET_INTERP_TYPE_COUNT )", "static_cast<int>(lerpType) doesn't index ADS_OFFSET_INTERP_TYPE_COUNT\n\t%i not in [0, %i)", lerpType, v48) )
      __debugbreak();
  }
  switch ( lerpType )
  {
    case ADS_OFFSET_INTERP_TYPE_EASEINOUTSINE:
      __asm
      {
        vsubss  xmm0, xmm7, cs:__real@3f000000; jumptable 00000001410D755E case 1
        vmulss  xmm0, xmm0, cs:__real@40490fdb; X
      }
      *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
      __asm
      {
        vaddss  xmm1, xmm0, cs:__real@3f800000
        vmulss  xmm7, xmm1, cs:__real@3f000000
        vmovaps xmm0, xmm7
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINOUTSMOOTHERSTEP:
      __asm
      {
        vmulss  xmm0, xmm7, cs:__real@40c00000; jumptable 00000001410D755E case 2
        vsubss  xmm1, xmm0, cs:__real@41700000
        vmulss  xmm2, xmm1, xmm7
        vaddss  xmm3, xmm2, cs:__real@41200000
        vmulss  xmm0, xmm7, xmm7
        vmulss  xmm1, xmm0, xmm7
        vmulss  xmm7, xmm3, xmm1
        vmovaps xmm0, xmm7
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINCUBIC:
      __asm
      {
        vmulss  xmm0, xmm7, xmm7; jumptable 00000001410D755E case 3
        vmulss  xmm7, xmm0, xmm7
        vmovaps xmm0, xmm7
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEOUTCUBIC:
      __asm
      {
        vsubss  xmm1, xmm7, cs:__real@3f800000; jumptable 00000001410D755E case 4
        vmulss  xmm0, xmm1, xmm1
        vmulss  xmm1, xmm0, xmm1
        vaddss  xmm7, xmm1, cs:__real@3f800000
        vmovaps xmm0, xmm7
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINQUARTIC:
      __asm
      {
        vmulss  xmm0, xmm7, xmm7; jumptable 00000001410D755E case 5
        vmulss  xmm1, xmm0, xmm7
        vmulss  xmm7, xmm1, xmm7
        vmovaps xmm0, xmm7
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEOUTQUARTIC:
      __asm
      {
        vmovss  xmm3, cs:__real@3f800000; jumptable 00000001410D755E case 6
        vsubss  xmm2, xmm7, xmm3
        vmulss  xmm0, xmm2, xmm2
        vmulss  xmm1, xmm0, xmm2
        vmulss  xmm2, xmm1, xmm2
        vsubss  xmm7, xmm3, xmm2
        vmovaps xmm0, xmm7
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEINEXPO:
      __asm
      {
        vsubss  xmm0, xmm7, cs:__real@3f800000; jumptable 00000001410D755E case 7
        vmulss  xmm1, xmm0, cs:__real@41200000; Y
        vmovss  xmm0, cs:__real@40000000; X
      }
      *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
      __asm
      {
        vmovaps xmm7, xmm0
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
    case ADS_OFFSET_INTERP_TYPE_EASEOUTEXPO:
      __asm
      {
        vmulss  xmm1, xmm7, cs:__real@c1200000; jumptable 00000001410D755E case 8
        vmovss  xmm0, cs:__real@40000000; X
      }
      powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
      __asm
      {
        vmovss  xmm1, cs:__real@3f800000
        vsubss  xmm7, xmm1, xmm0
      }
      goto LABEL_13;
    default:
LABEL_13:
      __asm
      {
        vmovaps xmm0, xmm7; jumptable 00000001410D755E default case
        vmovaps xmm7, [rsp+58h+var_18]
      }
      break;
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/

float __fastcall BG_CalculateFinalSpreadForWeapon(double weaponPosFrac, double minSpread, double maxSpread, double adsSpread)
{
  __asm
  {
    vsubss  xmm2, xmm2, xmm1
    vmulss  xmm4, xmm2, [rsp+28h+aimSpreadScale]
    vmovaps [rsp+28h+var_18], xmm6
    vaddss  xmm5, xmm4, xmm1
    vxorps  xmm1, xmm1, xmm1
    vucomiss xmm0, xmm1
    vmovaps [rsp+28h+var_28], xmm7
    vmovaps xmm7, xmm3
    vmovaps xmm6, xmm0
    vmovss  xmm0, cs:__real@3f800000
    vsubss  xmm1, xmm0, xmm6
    vmulss  xmm2, xmm6, xmm7
    vmovaps xmm6, [rsp+28h+var_18]
    vmovaps xmm7, [rsp+28h+var_28]
    vmulss  xmm3, xmm1, xmm5
    vaddss  xmm0, xmm3, xmm2
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_CalculateFinalSpreadForWeapon
==============
*/

float __fastcall BG_CalculateFinalSpreadForWeapon(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, double aimSpreadScale)
{
  bool v16; 
  const BgWeaponMap *v17; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v19; 
  bool v20; 
  bool doNotAllowAttachmentsToOverrideSpread; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment **v31; 
  __int64 v32; 
  bool v49; 
  float minSpread; 
  float maxSpread; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-58h], xmm7
    vmovaps xmmword ptr [r11-88h], xmm11
  }
  _R14 = ps;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm6
    vmovaps xmmword ptr [r11-68h], xmm8
    vmovaps xmmword ptr [r11-78h], xmm9
    vmovaps xmmword ptr [r11-98h], xmm12
    vmovaps xmm12, xmm3
  }
  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4686, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4687, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rsp+208h+maxSpread], xmm6
    vmovss  [rsp+208h+minSpread], xmm6
  }
  BG_GetSpreadForWeapon(_R14, r_weapon, &minSpread, &maxSpread);
  v16 = BG_UsingAlternate(_R14);
  v17 = handler->GetWeaponMap(handler);
  v19 = _R14 && v17 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v17, _R14, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  v20 = BG_PlayerUsesNVGHalfADS(_R14, handler);
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v20 )
    __asm { vmovss  xmm9, dword ptr [rax+834h] }
  else
    __asm { vmovss  xmm9, dword ptr [rax+830h] }
  doNotAllowAttachmentsToOverrideSpread = _RAX->doNotAllowAttachmentsToOverrideSpread;
  if ( BG_GetWeaponAdsSettings(r_weapon, v16, v19, doNotAllowAttachmentsToOverrideSpread) )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rax]
      vcmpless xmm0, xmm6, xmm1
      vblendvps xmm9, xmm9, xmm1, xmm0
    }
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v16, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)3, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm8, xmm7
  }
  if ( WeaponAttachments_Internal )
  {
    v31 = (const WeaponAttachment **)attachments;
    v32 = WeaponAttachments_Internal;
    do
    {
      _RBX = *v31;
      if ( *v31 && (!doNotAllowAttachmentsToOverrideSpread || _RBX->type) )
      {
        if ( BG_AttachmentUseMainSettings(*v31, v16, v19) )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+2E4h]
            vcomiss xmm0, xmm6
          }
        }
        else
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+2E0h]
            vcomiss xmm0, xmm6
            vmovaps xmm0, xmm7
          }
        }
        __asm
        {
          vaddss  xmm0, xmm8, xmm0
          vsubss  xmm8, xmm0, xmm7
        }
      }
      ++v31;
      --v32;
    }
    while ( v32 );
  }
  __asm
  {
    vmaxss  xmm2, xmm8, xmm6
    vsubss  xmm0, xmm7, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm2, xmm7, xmm0
    vmulss  xmm11, xmm1, xmm9
  }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm
  {
    vmovss  xmm8, dword ptr [rax+838h]
    vmovss  xmm9, dword ptr [rax+83Ch]
  }
  _RAX = BG_GetWeaponAdsSettings(r_weapon, v16, v19, _RAX->doNotAllowAttachmentsToOverrideSpread);
  v49 = _RAX == NULL;
  if ( _RAX )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rax+4]
      vmovss  xmm2, dword ptr [rax+8]
      vcmpless xmm0, xmm6, xmm1
      vblendvps xmm8, xmm8, xmm1, xmm0
      vcmpless xmm0, xmm6, xmm2
      vblendvps xmm9, xmm9, xmm2, xmm0
    }
  }
  __asm
  {
    vmovss  xmm1, dword ptr [r14+730h]
    vmaxss  xmm0, xmm9, xmm8
    vmovaps xmm9, [rsp+208h+var_78]
    vsubss  xmm2, xmm0, xmm8
    vcvtss2sd xmm0, xmm2, xmm2
    vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vsubss  xmm3, xmm1, xmm8
    vmovaps xmm8, [rsp+208h+var_68]
  }
  if ( _RAX )
  {
    __asm
    {
      vdivss  xmm0, xmm3, xmm2; val
      vmovaps xmm2, xmm7; max
      vmovaps xmm1, xmm6; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm4, xmm0 }
  }
  else
  {
    __asm
    {
      vcmpltss xmm0, xmm6, xmm3
      vblendvps xmm4, xmm6, xmm7, xmm0
    }
  }
  __asm
  {
    vmovss  xmm0, [rsp+208h+maxSpread]
    vsubss  xmm1, xmm0, [rsp+208h+minSpread]
    vmulss  xmm2, xmm1, xmm12
    vaddss  xmm5, xmm2, [rsp+208h+minSpread]
    vmovaps xmm12, [rsp+208h+var_98]
    vucomiss xmm4, xmm6
    vmovaps xmm6, [rsp+208h+var_48]
  }
  if ( v49 )
  {
    __asm { vmovaps xmm0, xmm5 }
  }
  else
  {
    __asm
    {
      vsubss  xmm0, xmm7, xmm4
      vmulss  xmm2, xmm0, xmm5
      vmulss  xmm1, xmm4, xmm11
      vaddss  xmm0, xmm2, xmm1
    }
  }
  __asm
  {
    vmovaps xmm7, [rsp+208h+var_58]
    vmovaps xmm11, [rsp+208h+var_88]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_CalculateKickBox
==============
*/
void BG_CalculateKickBox(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel, float *outMinMagnitude)
{
  unsigned int *v16; 
  char v21; 
  char v22; 
  int v42; 
  int v43; 
  int v44; 
  float hipGunKickPitchMin; 
  float hipGunKickPitchMax; 
  float hipGunKickYawMin; 
  int v48; 
  int v49[9]; 
  char vars0; 
  void *retaddr; 
  int v52; 
  int v53; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-18h], xmm6
    vmovaps xmmword ptr [r11-28h], xmm7
  }
  _RBX = ps;
  if ( isViewKick )
    BG_GetViewKickYawAndPitch(weaponMap, ps, r_weapon, isAlternate, &hipGunKickPitchMin, &hipGunKickPitchMax, &hipGunKickYawMin, (float *)&v48, (float *)v49, (float *)&v52, (float *)&v53, (float *)&v42, (float *)&v43, (float *)&v44);
  else
    BG_GetGunKickYawAndPitch(weaponMap, ps, r_weapon, isAlternate, &hipGunKickPitchMin, &hipGunKickPitchMax, &hipGunKickYawMin, (float *)&v48, (float *)v49, (float *)&v52, (float *)&v53, (float *)&v42, (float *)&v43, (float *)&v44);
  __asm { vmovss  xmm6, dword ptr [rbx+730h] }
  v16 = holdrand;
  *(double *)&_XMM0 = BG_random(holdrand);
  __asm { vmovss  xmm7, cs:__real@3f800000 }
  _RAX = outPitchAVel;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm6, xmm1
    vsubss  xmm2, xmm7, xmm0
  }
  if ( v21 | v22 )
  {
    __asm
    {
      vmulss  xmm1, xmm2, [rbp+2Fh+hipGunKickPitchMin]
      vmulss  xmm0, xmm0, [rbp+2Fh+hipGunKickPitchMax]
      vaddss  xmm2, xmm1, xmm0
      vmovss  dword ptr [rax], xmm2
    }
    *(double *)&_XMM0 = BG_random(v16);
    __asm
    {
      vsubss  xmm1, xmm7, xmm0
      vmulss  xmm0, xmm0, [rbp+2Fh+var_28]
      vmulss  xmm2, xmm1, [rbp+2Fh+hipGunKickYawMin]
      vaddss  xmm3, xmm2, xmm0
      vmovss  xmm0, [rbp+2Fh+var_24]
    }
  }
  else
  {
    __asm
    {
      vmulss  xmm1, xmm2, [rbp+2Fh+arg_8]
      vmulss  xmm0, xmm0, [rbp+2Fh+arg_10]
      vaddss  xmm2, xmm1, xmm0
      vmovss  dword ptr [rax], xmm2
    }
    *(double *)&_XMM0 = BG_random(v16);
    __asm
    {
      vsubss  xmm1, xmm7, xmm0
      vmulss  xmm0, xmm0, [rbp+2Fh+var_3C]
      vmulss  xmm2, xmm1, [rbp+2Fh+var_40]
      vaddss  xmm3, xmm2, xmm0
      vmovss  xmm0, [rbp+2Fh+var_38]
    }
  }
  _RAX = outYawAVel;
  _R11 = &vars0;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovss  dword ptr [rax], xmm3
  }
  _RAX = outMinMagnitude;
  __asm { vmovss  dword ptr [rax], xmm0 }
}

/*
==============
BG_CalculateKickMovement
==============
*/

bool __fastcall BG_CalculateKickMovement(double fTimeStep, const vec2_t *maxAngles, double kickPitchScale, double kickYawScale, float recenterAngAcceleration, float fReturnAccelScale, float fReturnSpeedCurveScale, vec2_t *inOutAngles, vec2_t *inOutAngularVel)
{
  unsigned int v22; 
  bool v27; 
  bool v28; 
  bool v32; 
  bool v33; 
  bool v34; 
  const dvar_t *v75; 
  char v106; 
  char v107; 
  char v114; 
  bool v118; 
  bool v142; 
  const dvar_t *v143; 
  unsigned int v176; 
  bool v187; 
  bool v188; 
  bool v191; 
  bool v192; 
  bool v193; 
  bool v194; 
  bool v199; 
  bool v200; 
  bool result; 
  __int64 v227; 
  double v228; 
  double v229; 
  __int64 v230; 
  __int64 v231; 
  __int64 v232; 
  double v233; 
  double v234; 
  __int64 v235; 
  __int64 v236; 
  double v237; 
  double v238; 
  char v252; 
  void *retaddr; 

  _RAX = &retaddr;
  _R14 = inOutAngles;
  _R15 = inOutAngularVel;
  v22 = 0;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovss  xmm6, cs:__real@c3340000
    vmovaps xmmword ptr [rax-48h], xmm7
  }
  _RDI = inOutAngles;
  __asm
  {
    vmovss  xmm7, cs:__real@43340000
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  v27 = 1;
  v28 = 1;
  __asm
  {
    vmovsd  xmm8, cs:__real@4066800000000000
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovsd  xmm9, cs:__real@c066800000000000
    vmovaps xmmword ptr [rax-0A8h], xmm13
    vmovaps xmm13, xmm0
    vmovss  [rsp+128h+var_D4], xmm3
    vmovss  [rsp+128h+var_D8], xmm2
    vmovss  [rsp+128h+var_D0], xmm0
  }
  do
  {
    if ( !v27 )
    {
      LODWORD(v232) = 2;
      LODWORD(v227) = v22;
      v32 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232);
      v28 = !v32;
      if ( v32 )
        __debugbreak();
    }
    __asm { vcomiss xmm6, dword ptr [rdi] }
    if ( !v28 )
      goto LABEL_92;
    v33 = v22 < 2;
    if ( v22 >= 2 )
    {
      LODWORD(v232) = 2;
      LODWORD(v227) = v22;
      v34 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232);
      v33 = 0;
      if ( v34 )
        __debugbreak();
    }
    __asm { vcomiss xmm7, dword ptr [rdi] }
    if ( v33 )
    {
LABEL_92:
      if ( v22 >= 2 )
      {
        LODWORD(v232) = 2;
        LODWORD(v227) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi]
        vmovsd  [rsp+128h+var_F0], xmm8
        vcvtss2sd xmm0, xmm0, xmm0
        vmovsd  [rsp+128h+var_F8], xmm9
        vmovsd  [rsp+128h+var_100], xmm0
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4077, ASSERT_TYPE_ASSERT, "( (-180.0f + 1.192092896e-07F) ) <= ( inOutAngles[i] ) && ( inOutAngles[i] ) <= ( 180.0f )", "inOutAngles[i] not in [(-180.0f + FLT_EPSILON), 180.0f]\n\t%g not in [%g, %g]", v228, v233, v237) )
        __debugbreak();
    }
    ++v22;
    _RDI = (vec2_t *)((char *)_RDI + 4);
    v27 = v22 < 2;
    v28 = v22 <= 2;
  }
  while ( (int)v22 < 2 );
  __asm
  {
    vmovss  xmm3, dword ptr [r14+4]
    vmovss  xmm4, dword ptr [r14]
    vmulss  xmm1, xmm4, xmm4
    vmulss  xmm0, xmm3, xmm3
    vaddss  xmm1, xmm1, xmm0
    vmovss  xmm0, dword ptr [r15]
    vsqrtss xmm5, xmm1, xmm1
    vcomiss xmm5, cs:STOP_THRESHOLD_OFFSET
    vmovss  xmm1, dword ptr [r15+4]
    vmulss  xmm2, xmm0, xmm0
    vmulss  xmm1, xmm1, xmm1
    vaddss  xmm2, xmm2, xmm1
    vmovaps [rsp+128h+var_78], xmm10
    vsqrtss xmm7, xmm2, xmm2
    vmovss  [rsp+128h+var_DC], xmm5
    vmovaps [rsp+128h+var_98], xmm12
    vmovsd  xmm2, cs:__real@3eb0c6f7a0b5ed8d
    vmovss  xmm6, cs:__real@3f800000
    vmovaps [rsp+128h+var_88], xmm11
    vmovaps [rsp+128h+var_B8], xmm14
    vmovss  xmm14, cs:__real@80000000
    vcvtss2sd xmm0, xmm5, xmm5
    vcomisd xmm0, xmm2
    vmovaps [rsp+128h+var_C8], xmm15
    vmovss  xmm15, dword ptr cs:__xmm@80000000800000008000000080000000
    vxorps  xmm10, xmm10, xmm10
  }
  if ( v22 <= 2 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  [rsp+128h+var_E8], xmm0
      vmovss  [rsp+128h+var_E4], xmm6
      vmovaps xmm8, xmm6
    }
  }
  else
  {
    __asm
    {
      vcmpless xmm0, xmm5, xmm14
      vblendvps xmm0, xmm5, xmm6, xmm0
      vdivss  xmm1, xmm6, xmm0
      vmulss  xmm0, xmm4, xmm1
      vmulss  xmm1, xmm3, xmm1
      vxorps  xmm1, xmm1, xmm15
      vxorps  xmm8, xmm0, xmm15
      vmovss  [rsp+128h+var_E8], xmm1
      vmovss  [rsp+128h+var_E4], xmm8
    }
  }
  __asm
  {
    vcvtss2sd xmm0, xmm7, xmm7
    vcomisd xmm0, xmm2
  }
  if ( v22 <= 2 )
  {
    __asm
    {
      vmovaps xmm11, xmm6
      vxorps  xmm12, xmm12, xmm12
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm4, dword ptr [r15+4]
      vmovss  xmm3, dword ptr [r15]
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm1, xmm1, xmm0
      vsqrtss xmm2, xmm1, xmm1
      vcmpless xmm0, xmm2, xmm14
      vblendvps xmm0, xmm2, xmm6, xmm0
      vdivss  xmm1, xmm6, xmm0
      vmulss  xmm11, xmm3, xmm1
      vmulss  xmm12, xmm4, xmm1
    }
  }
  v75 = DCONST_DVARFLT_bg_kickIntegrationFudgeFactor;
  if ( !DCONST_DVARFLT_bg_kickIntegrationFudgeFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_kickIntegrationFudgeFactor") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v75);
  __asm
  {
    vmulss  xmm0, xmm13, [rsp+128h+recenterAngAcceleration]
    vmovss  xmm4, [rsp+128h+var_E8]
    vmulss  xmm9, xmm0, dword ptr [rbx+28h]
    vxorps  xmm8, xmm8, xmm15
    vmulss  xmm0, xmm8, xmm8
    vmulss  xmm1, xmm4, xmm4
    vaddss  xmm3, xmm1, xmm0
    vsubss  xmm2, xmm3, xmm6
    vandps  xmm2, xmm2, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm2, cs:__real@3b03126f
  }
  if ( !v27 )
  {
    __asm
    {
      vsqrtss xmm0, xmm3, xmm3
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+128h+var_F0], xmm1
      vcvtss2sd xmm2, xmm8, xmm8
      vmovsd  [rsp+128h+var_F8], xmm2
      vcvtss2sd xmm3, xmm4, xmm4
      vmovsd  [rsp+128h+var_100], xmm3
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4140, ASSERT_TYPE_ASSERT, "( Vec2IsNormalized( rightAngDirection ) )", "(%g, %g) len %g", v229, v234, v238) )
      __debugbreak();
  }
  __asm
  {
    vmovd   xmm1, cs:KICK_ANGLES_TIME_STEP
    vmovss  xmm0, cs:__real@447a0000
    vcvtdq2ps xmm1, xmm1
    vdivss  xmm1, xmm0, xmm1
    vmovss  xmm0, [rsp+128h+var_DC]
    vcmpless xmm0, xmm0, cs:STOP_SIDE_MOVEMENT_OFFSET
    vmulss  xmm2, xmm1, xmm13
    vmulss  xmm3, xmm2, cs:COUNTER_SIDE_MOVEMENT_SPEED_MULT
    vmulss  xmm1, xmm11, [rsp+128h+var_E8]
    vblendvps xmm4, xmm3, xmm6, xmm0
    vmulss  xmm0, xmm12, xmm8
    vaddss  xmm1, xmm1, xmm0
    vmulss  xmm2, xmm1, xmm7
    vmulss  xmm0, xmm2, xmm4; val
    vxorps  xmm13, xmm9, xmm15
    vmovaps xmm2, xmm9; max
    vmovaps xmm1, xmm13; min
    vmovss  [rsp+128h+var_E0], xmm4
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@bf800000
    vmovss  xmm3, [rsp+128h+var_DC]
    vcomiss xmm3, xmm10
    vmovss  xmm0, [rsp+128h+var_E8]
    vmulss  xmm2, xmm1, xmm8
    vmovss  [rsp+128h+var_E0], xmm2
    vmulss  xmm15, xmm1, xmm0
  }
  if ( v106 | v107 )
    goto LABEL_31;
  __asm { vcomiss xmm7, xmm10 }
  if ( v106 | v107 )
  {
LABEL_31:
    v114 = 0;
    v106 = 0;
    v107 = 1;
  }
  else
  {
    v114 = 1;
  }
  __asm
  {
    vmulss  xmm1, xmm11, [rsp+128h+var_E4]
    vmulss  xmm0, xmm12, xmm0
    vaddss  xmm2, xmm1, xmm0
    vcomiss xmm2, xmm10
  }
  v118 = !(v106 | v107);
  if ( !v114 || v106 | v107 )
  {
    __asm { vmovss  xmm12, [rsp+128h+var_E4] }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, cs:RECENTER_CURVE_FAR_DIST
      vmulss  xmm1, xmm0, [rsp+128h+fReturnSpeedCurveScale]
      vcomiss xmm1, xmm10
      vsubss  xmm0, xmm1, xmm3
      vdivss  xmm0, xmm0, xmm1; val
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm2, xmm6; max
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovss  xmm12, [rsp+128h+var_E4]
      vmulss  xmm2, xmm12, dword ptr [r15]
      vmulss  xmm4, xmm0, xmm0
      vmovss  xmm0, [rsp+128h+var_E8]
      vmulss  xmm0, xmm0, dword ptr [r15+4]
      vaddss  xmm5, xmm2, xmm0
      vmulss  xmm0, xmm4, cs:CENTER_MULT
      vsubss  xmm2, xmm6, xmm4
      vmulss  xmm3, xmm2, cs:EDGE_MULT
      vaddss  xmm3, xmm3, xmm0
      vmulss  xmm2, xmm3, xmm9
      vsubss  xmm0, xmm2, xmm5; val
      vmovaps xmm2, xmm9; max
      vmovaps xmm1, xmm13; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm9, xmm0 }
  }
  __asm
  {
    vmovss  xmm13, [rsp+128h+var_E8]
    vmulss  xmm8, xmm13, xmm9
    vmulss  xmm7, xmm12, xmm9
  }
  v142 = !v118;
  if ( v118 )
  {
    __asm { vmovss  xmm11, [rsp+128h+var_E0] }
  }
  else
  {
    v143 = DVARBOOL_bg_kickScalesReturn;
    if ( !DVARBOOL_bg_kickScalesReturn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_kickScalesReturn") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v143);
    v142 = !v143->current.enabled;
    __asm { vmovss  xmm11, [rsp+128h+var_E0] }
    if ( v143->current.enabled )
    {
      __asm
      {
        vmulss  xmm7, xmm7, [rsp+128h+var_D8]
        vmulss  xmm8, xmm8, [rsp+128h+var_D4]
        vmulss  xmm15, xmm15, [rsp+128h+var_D8]
        vmulss  xmm11, xmm11, [rsp+128h+var_D4]
        vmulss  xmm1, xmm7, xmm7
        vmulss  xmm0, xmm8, xmm8
        vaddss  xmm1, xmm1, xmm0
        vsqrtss xmm9, xmm1, xmm1
      }
    }
  }
  __asm
  {
    vaddss  xmm3, xmm7, dword ptr [r15]
    vaddss  xmm4, xmm8, dword ptr [r15+4]
    vmulss  xmm1, xmm4, xmm4
    vmulss  xmm0, xmm3, xmm3
    vaddss  xmm1, xmm1, xmm0
    vsqrtss xmm2, xmm1, xmm1
    vcvtss2sd xmm0, xmm2, xmm2
    vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
  }
  if ( v142 )
  {
    __asm { vxorps  xmm5, xmm5, xmm5 }
  }
  else
  {
    __asm
    {
      vcmpless xmm0, xmm2, xmm14
      vblendvps xmm0, xmm2, xmm6, xmm0
      vdivss  xmm1, xmm6, xmm0
      vmulss  xmm6, xmm1, xmm3
      vmulss  xmm5, xmm4, xmm1
    }
  }
  __asm
  {
    vmovss  xmm14, [rsp+128h+var_DC]
    vcomiss xmm14, xmm10
  }
  if ( !v142 )
  {
    __asm
    {
      vcomiss xmm2, xmm10
      vmulss  xmm1, xmm13, xmm5
      vmulss  xmm0, xmm6, xmm12
      vaddss  xmm2, xmm1, xmm0
      vcomiss xmm2, xmm10
      vmulss  xmm1, xmm12, xmm3
      vmulss  xmm0, xmm4, xmm13
      vaddss  xmm1, xmm1, xmm0
      vmulss  xmm2, xmm1, xmm9
      vcomiss xmm2, xmm10
      vmulss  xmm0, xmm9, [rsp+128h+fReturnAccelScale]
      vmulss  xmm7, xmm12, xmm0
      vmulss  xmm8, xmm13, xmm0
    }
  }
  __asm
  {
    vaddss  xmm0, xmm15, dword ptr [r15]
    vaddss  xmm1, xmm11, dword ptr [r15+4]
    vmovss  xmm3, [rsp+128h+var_D0]
    vmovaps xmm15, [rsp+128h+var_C8]
    vmovaps xmm11, [rsp+128h+var_88]
  }
  v176 = 0;
  __asm
  {
    vaddss  xmm2, xmm0, xmm7
    vmovss  xmm7, dword ptr cs:__xmm@80000000800000008000000080000000
    vmovss  dword ptr [r15], xmm2
    vaddss  xmm0, xmm1, xmm8
    vmovss  dword ptr [r15+4], xmm0
    vmulss  xmm2, xmm2, xmm3
    vaddss  xmm1, xmm2, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
    vmulss  xmm0, xmm3, dword ptr [r15+4]
    vaddss  xmm2, xmm0, dword ptr [r14+4]
  }
  _RBP = (char *)maxAngles - (char *)inOutAngles;
  _RSI = (char *)inOutAngularVel - (char *)inOutAngles;
  __asm { vmovss  dword ptr [r14+4], xmm2 }
  _RDI = inOutAngles;
  v187 = 1;
  do
  {
    if ( !v187 )
    {
      LODWORD(v232) = 2;
      LODWORD(v227) = v176;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
        __debugbreak();
      LODWORD(v235) = 2;
      LODWORD(v230) = v176;
      v188 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v230, v235);
      v187 = 0;
      if ( v188 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+rbp]
      vcomiss xmm0, dword ptr [rdi]
    }
    if ( v187 )
    {
      if ( v176 >= 2 )
      {
        LODWORD(v232) = 2;
        LODWORD(v227) = v176;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
          __debugbreak();
      }
      __asm { vmovss  xmm6, dword ptr [rdi+rbp] }
      if ( v176 >= 2 )
      {
        LODWORD(v232) = 2;
        LODWORD(v227) = v176;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
          __debugbreak();
      }
      __asm { vmovss  dword ptr [rdi], xmm6 }
      v191 = v176 < 2;
      if ( v176 >= 2 )
      {
        LODWORD(v232) = 2;
        LODWORD(v227) = v176;
        v192 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232);
        v191 = 0;
        if ( v192 )
          __debugbreak();
      }
      __asm { vcomiss xmm10, dword ptr [rsi+rdi] }
      if ( v191 )
        goto LABEL_82;
    }
    else
    {
      v193 = v176 <= 2;
      if ( v176 >= 2 )
      {
        LODWORD(v232) = 2;
        LODWORD(v227) = v176;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
          __debugbreak();
        LODWORD(v236) = 2;
        LODWORD(v231) = v176;
        v194 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v231, v236);
        v193 = !v194;
        if ( v194 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+rbp]
        vxorps  xmm1, xmm0, xmm7
        vcomiss xmm1, dword ptr [rdi]
      }
      if ( !v193 )
      {
        if ( v176 >= 2 )
        {
          LODWORD(v232) = 2;
          LODWORD(v227) = v176;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rdi+rbp]
          vxorps  xmm6, xmm0, xmm7
        }
        if ( v176 >= 2 )
        {
          LODWORD(v232) = 2;
          LODWORD(v227) = v176;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
            __debugbreak();
        }
        __asm { vmovss  dword ptr [rdi], xmm6 }
        v199 = v176 <= 2;
        if ( v176 >= 2 )
        {
          LODWORD(v232) = 2;
          LODWORD(v227) = v176;
          v200 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232);
          v199 = !v200;
          if ( v200 )
            __debugbreak();
        }
        __asm { vcomiss xmm10, dword ptr [rsi+rdi] }
        if ( !v199 )
        {
LABEL_82:
          if ( v176 >= 2 )
          {
            LODWORD(v232) = 2;
            LODWORD(v227) = v176;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v227, v232) )
              __debugbreak();
          }
          *(float *)((char *)_RDI->v + _RSI) = 0.0;
        }
      }
    }
    ++v176;
    _RDI = (vec2_t *)((char *)_RDI + 4);
    v187 = v176 < 2;
  }
  while ( (int)v176 < 2 );
  __asm
  {
    vmovss  xmm2, dword ptr [r14+4]
    vmovss  xmm4, dword ptr [r14]
    vmulss  xmm1, xmm2, xmm2
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm1, xmm1, xmm0
    vcvtss2sd xmm0, xmm14, xmm14
    vmovaps xmm14, [rsp+128h+var_B8]
    vsqrtss xmm3, xmm1, xmm1
    vmovsd  xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vcomisd xmm0, xmm1
  }
  if ( v176 > 2 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm3, xmm3
      vcomisd xmm0, xmm1
      vmovss  xmm0, cs:__real@bf800000
      vdivss  xmm1, xmm0, xmm3
      vmulss  xmm0, xmm2, xmm1
      vmulss  xmm1, xmm4, xmm1
      vmulss  xmm2, xmm1, xmm12
      vmulss  xmm3, xmm0, xmm13
      vaddss  xmm0, xmm3, xmm2
      vcomiss xmm0, xmm10
    }
  }
  result = 0;
  __asm { vmovaps xmm12, [rsp+128h+var_98] }
  _R11 = &v252;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm10, [rsp+128h+var_78]
  }
  return result;
}

/*
==============
BG_CalculateKickMovement_Legacy
==============
*/

void __fastcall BG_CalculateKickMovement_Legacy(double ft, const vec3_t *maxAngles, double recenterAccel, const Weapon *r_weapon, const bool fastSnipe, vec3_t *inOutKickAVel, vec3_t *inOutKickAngles)
{
  unsigned int v19; 
  bool v26; 
  bool v27; 
  bool v35; 
  bool v36; 
  bool v37; 
  bool v38; 
  bool v39; 
  bool v40; 
  bool v41; 
  const dvar_t *v51; 
  bool v55; 
  bool v56; 
  bool v58; 
  bool v59; 
  bool v63; 
  bool v64; 
  bool v67; 
  bool v68; 
  __int64 v87; 
  __int64 v88; 
  __int64 v89; 
  __int64 v90; 
  char v97; 
  void *retaddr; 

  _RAX = &retaddr;
  _RDI = inOutKickAngles;
  v19 = 0;
  __asm { vmovaps xmmword ptr [rax-48h], xmm7 }
  _RBP = (char *)maxAngles - (char *)inOutKickAngles;
  __asm { vmovaps xmmword ptr [rax-58h], xmm8 }
  _R14 = (char *)inOutKickAVel - (char *)inOutKickAngles;
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovss  xmm9, cs:__real@3d75c28f
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovss  xmm10, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovaps xmmword ptr [rax-88h], xmm11
  }
  v26 = 1;
  v27 = 0;
  __asm
  {
    vmovss  xmm11, cs:__real@bf800000
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovss  xmm12, cs:__real@3f800000
    vmovaps [rsp+118h+var_A8], xmm13
    vmovaps [rsp+118h+var_B8], xmm14
    vmovss  xmm14, dword ptr cs:__xmm@80000000800000008000000080000000
    vmovaps [rsp+118h+var_C8], xmm15
    vmovss  xmm15, cs:__real@45160000
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmm13, xmm2
    vmovaps xmm8, xmm0
    vxorps  xmm7, xmm7, xmm7
  }
  do
  {
    if ( !v26 )
    {
      LODWORD(v89) = 3;
      LODWORD(v87) = v19;
      v35 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89);
      v27 = !v35;
      if ( v35 )
        __debugbreak();
    }
    __asm { vucomiss xmm7, dword ptr [r14+rdi] }
    if ( !v27 )
      goto LABEL_10;
    v36 = v19 == 3;
    if ( v19 >= 3 )
    {
      LODWORD(v89) = 3;
      LODWORD(v87) = v19;
      v37 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89);
      v36 = !v37;
      if ( v37 )
        __debugbreak();
    }
    __asm { vucomiss xmm7, dword ptr [rdi] }
    if ( !v36 )
    {
LABEL_10:
      v38 = v19 == 3;
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        v39 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89);
        v38 = !v39;
        if ( v39 )
          __debugbreak();
      }
      __asm { vucomiss xmm7, dword ptr [rdi] }
      if ( !v38 )
      {
        v40 = v19 == 3;
        if ( v19 >= 3 )
        {
          LODWORD(v89) = 3;
          LODWORD(v87) = v19;
          v41 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89);
          v40 = !v41;
          if ( v41 )
            __debugbreak();
        }
        __asm
        {
          vcmpltss xmm0, xmm7, dword ptr [rdi]
          vblendvps xmm3, xmm12, xmm11, xmm0
          vucomiss xmm3, xmm7
          vmovss  [rsp+118h+var_D8], xmm3
        }
        if ( !v40 )
        {
          _EAX = 0;
          __asm { vmovd   xmm1, eax }
          _EAX = r_weapon->weaponIdx;
          __asm
          {
            vmovd   xmm0, eax
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm0, xmm13, xmm15, xmm2
            vmulss  xmm6, xmm0, xmm3
          }
          if ( fastSnipe )
          {
            v51 = DVARFLT_perk_fastSnipeScale;
            if ( !DVARFLT_perk_fastSnipeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_fastSnipeScale") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v51);
            __asm { vmulss  xmm6, xmm6, dword ptr [rsi+28h] }
          }
          if ( v19 >= 3 )
          {
            LODWORD(v89) = 3;
            LODWORD(v87) = v19;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
              __debugbreak();
          }
          __asm
          {
            vmulss  xmm0, xmm6, xmm8
            vaddss  xmm1, xmm0, dword ptr [r14+rdi]
            vmovss  dword ptr [r14+rdi], xmm1
          }
        }
      }
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
          __debugbreak();
      }
      __asm { vmulss  xmm6, xmm8, dword ptr [r14+rdi] }
      v55 = v19 < 3;
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        v56 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89);
        v55 = 0;
        if ( v56 )
          __debugbreak();
      }
      __asm
      {
        vmulss  xmm0, xmm6, dword ptr [rdi]
        vcomiss xmm0, xmm7
      }
      if ( v55 )
        __asm { vmulss  xmm6, xmm6, xmm9 }
      v58 = v19 < 3;
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
          __debugbreak();
        LODWORD(v90) = 3;
        LODWORD(v88) = v19;
        v59 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v88, v90);
        v58 = 0;
        if ( v59 )
          __debugbreak();
      }
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmulss  xmm2, xmm0, dword ptr [rdi]
        vcomiss xmm2, xmm7
      }
      if ( v58 )
      {
        if ( v19 >= 3 )
        {
          LODWORD(v89) = 3;
          LODWORD(v87) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
            __debugbreak();
        }
        _RDI->v[0] = 0.0;
        if ( v19 >= 3 )
          goto LABEL_68;
        goto LABEL_70;
      }
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
          __debugbreak();
      }
      __asm
      {
        vaddss  xmm0, xmm6, dword ptr [rdi]
        vmovss  dword ptr [rdi], xmm0
      }
      v63 = v19 == 3;
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        v64 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89);
        v63 = !v64;
        if ( v64 )
          __debugbreak();
      }
      __asm { vucomiss xmm7, dword ptr [rdi] }
      if ( v63 )
        goto LABEL_62;
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm6, dword ptr [rdi]
        vandps  xmm6, xmm6, xmm10
      }
      v67 = v19 <= 3;
      if ( v19 >= 3 )
      {
        LODWORD(v89) = 3;
        LODWORD(v87) = v19;
        v68 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 48, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89);
        v67 = !v68;
        if ( v68 )
          __debugbreak();
      }
      __asm { vcomiss xmm6, dword ptr [rdi+rbp] }
      if ( !v67 )
      {
        if ( v19 >= 3 )
        {
          LODWORD(v89) = 3;
          LODWORD(v87) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
            __debugbreak();
        }
        __asm { vmovss  xmm6, dword ptr [rdi] }
        _RAX = vec3_t::operator[]((vec3_t *)maxAngles, v19);
        __asm
        {
          vcmpltss xmm0, xmm7, xmm6
          vmovss  xmm2, dword ptr [rax]
          vxorps  xmm1, xmm2, xmm14
          vblendvps xmm0, xmm1, xmm2, xmm0
          vmovss  [rsp+118h+var_D8], xmm0
        }
        if ( v19 >= 3 )
        {
          LODWORD(v89) = 3;
          LODWORD(v87) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm0, [rsp+118h+var_D8]
          vmovss  dword ptr [rdi], xmm0
        }
LABEL_62:
        if ( v19 >= 3 )
        {
LABEL_68:
          LODWORD(v89) = 3;
          LODWORD(v87) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v87, v89) )
            __debugbreak();
        }
LABEL_70:
        *(float *)((char *)_RDI->v + _R14) = 0.0;
      }
    }
    ++v19;
    _RDI = (vec3_t *)((char *)_RDI + 4);
    v26 = v19 < 3;
    v27 = v19 == 3;
  }
  while ( (int)v19 < 3 );
  __asm { vmovaps xmm6, [rsp+118h+var_38] }
  _R11 = &v97;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, [rsp+118h+var_B8]
    vmovaps xmm15, [rsp+118h+var_C8]
  }
}

/*
==============
BG_CalculateKickPolar
==============
*/
void BG_CalculateKickPolar(const BgWeaponMap *weaponMap, const bool isViewKick, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, unsigned int *holdrand, float *outPitchAVel, float *outYawAVel)
{
  int bulletNum; 
  char v20; 
  __int64 v45; 
  __int64 v46; 
  __int64 v47; 
  __int64 v48; 
  float adsAngularGunKickStrengthMin; 
  float adsAngularGunKickStrengthMax; 
  float hipAngularGunKickDir; 
  float hipAngularGunKickDev; 
  float hipAngularGunKickStrengthMin; 
  float hipAngularGunKickStrengthMax; 
  float adsAngularGunKickPitchScale; 
  float hipAngularGunKickPitchScale[17]; 
  char v69; 
  void *retaddr; 
  float adsAngularGunKickDir; 
  float adsAngularGunKickDev; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
  }
  _RDI = ps;
  bulletNum = BG_GetShotCountForRecoil(ps);
  if ( isViewKick )
    BG_GetAngularViewKickSettings(weaponMap, _RDI, r_weapon, isAlternate, bulletNum, &hipAngularGunKickDir, &hipAngularGunKickDev, &hipAngularGunKickStrengthMin, &hipAngularGunKickStrengthMax, hipAngularGunKickPitchScale, &adsAngularGunKickDir, &adsAngularGunKickDev, &adsAngularGunKickStrengthMin, &adsAngularGunKickStrengthMax, &adsAngularGunKickPitchScale);
  else
    BG_GetAngularGunKickSettings(weaponMap, _RDI, r_weapon, isAlternate, bulletNum, &hipAngularGunKickDir, &hipAngularGunKickDev, &hipAngularGunKickStrengthMin, &hipAngularGunKickStrengthMax, hipAngularGunKickPitchScale, &adsAngularGunKickDir, &adsAngularGunKickDev, &adsAngularGunKickStrengthMin, &adsAngularGunKickStrengthMax, &adsAngularGunKickPitchScale);
  _RBX = DCONST_DVARFLT_bg_viewAndGunKickAdsFrac;
  __asm { vmovss  xmm6, dword ptr [rdi+730h] }
  if ( !DCONST_DVARFLT_bg_viewAndGunKickAdsFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewAndGunKickAdsFrac") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vcomiss xmm6, dword ptr [rbx+28h] }
  if ( v20 )
  {
    __asm
    {
      vmovss  xmm7, [rbp+37h+hipAngularGunKickDir]
      vmovss  xmm6, [rbp+37h+hipAngularGunKickDev]
      vmovss  xmm9, [rbp+37h+hipAngularGunKickStrengthMin]
      vmovss  xmm10, [rbp+37h+hipAngularGunKickStrengthMax]
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm7, [rbp+37h+adsAngularGunKickDir]
      vmovss  xmm6, [rbp+37h+adsAngularGunKickDev]
      vmovss  xmm9, [rbp+37h+adsAngularGunKickStrengthMin]
      vmovss  xmm10, [rbp+37h+adsAngularGunKickStrengthMax]
    }
  }
  BG_random(holdrand);
  __asm
  {
    vmulss  xmm4, xmm6, cs:__real@3f000000
    vmovss  xmm6, cs:__real@3f800000
    vsubss  xmm1, xmm6, xmm0
    vsubss  xmm2, xmm7, xmm4
    vmulss  xmm3, xmm2, xmm1
    vaddss  xmm2, xmm4, xmm7
    vmulss  xmm0, xmm2, xmm0
    vaddss  xmm1, xmm3, xmm0
    vmulss  xmm7, xmm1, cs:__real@3b360b61
  }
  *(double *)&_XMM0 = BG_random(holdrand);
  __asm
  {
    vaddss  xmm3, xmm7, cs:__real@3f000000
    vsubss  xmm1, xmm6, xmm0
    vmulss  xmm0, xmm0, xmm10
    vmulss  xmm2, xmm1, xmm9
    vaddss  xmm6, xmm2, xmm0
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm3, 1
    vsubss  xmm1, xmm7, xmm4
    vmulss  xmm0, xmm1, cs:__real@40c90fdb
  }
  *(double *)&_XMM0 = j___libm_sse2_sincosf_(v46, v45, v47, v48);
  _RAX = outPitchAVel;
  _R11 = &v69;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm9, xmmword ptr [r11-30h]
    vmovaps xmm10, xmmword ptr [r11-40h]
    vshufps xmm1, xmm0, xmm0, 1
    vmulss  xmm2, xmm1, xmm6
    vxorps  xmm3, xmm2, cs:__xmm@80000000800000008000000080000000
    vmovss  dword ptr [rax], xmm3
  }
  _RAX = outYawAVel;
  __asm
  {
    vmulss  xmm0, xmm0, xmm6
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovss  dword ptr [rax], xmm1
  }
}

/*
==============
BG_CalculateRecoilInputScalar
==============
*/

float __fastcall BG_CalculateRecoilInputScalar(double kick, double move, double fkickAlignedInputScalar, double fkickOpposedInputScalar)
{
  char v4; 
  char v5; 

  __asm
  {
    vxorps  xmm4, xmm4, xmm4
    vucomiss xmm0, xmm4
  }
  if ( v5 )
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
    return *(float *)&_XMM0;
  }
  __asm
  {
    vucomiss xmm1, xmm4
    vcomiss xmm0, xmm4
  }
  if ( !(v4 | v5) )
  {
    __asm { vcomiss xmm1, xmm4 }
    if ( v4 )
      goto LABEL_8;
    __asm { vcomiss xmm0, xmm4 }
  }
  if ( !v4 )
    goto LABEL_9;
  __asm { vcomiss xmm1, xmm4 }
  if ( v4 | v5 )
  {
LABEL_9:
    __asm { vmovaps xmm0, xmm2 }
    return *(float *)&_XMM0;
  }
LABEL_8:
  __asm { vmovaps xmm0, xmm3 }
  return *(float *)&_XMM0;
}

/*
==============
BG_CalculateRecoilInputScalars
==============
*/
void BG_CalculateRecoilInputScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, float pitchKick, float yawKick, float pitchMove, float yawMove, float *outPitchInputScalar, float *outYawInputScalar)
{
  unsigned int v16; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v19; 
  unsigned int v20; 
  const WeaponAttachment **v21; 
  unsigned int v25; 
  const PlayerEquippedWeaponState *v26; 
  bool v27; 
  const WeaponAttachment **v28; 
  char v30; 
  bool v31; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outPitchInputScalar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3770, ASSERT_TYPE_ASSERT, "(outPitchInputScalar)", (const char *)&queryFormat, "outPitchInputScalar") )
    __debugbreak();
  if ( !outYawInputScalar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3771, ASSERT_TYPE_ASSERT, "(outYawInputScalar)", (const char *)&queryFormat, "outYawInputScalar") )
    __debugbreak();
  v16 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v19 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovaps [rsp+1C8h+var_48], xmm6 }
  v20 = 0;
  if ( WeaponAttachments_Internal )
  {
    v21 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20735, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( BG_GetAttachmentViewKick(weaponMap, ps, weapon, isAlternate, *v21, v19) )
        break;
      ++v20;
      ++v21;
      if ( v20 >= WeaponAttachments_Internal )
        goto LABEL_19;
    }
    __asm { vmovss  xmm6, dword ptr [rax+154h] }
  }
  else
  {
LABEL_19:
    _RAX = BG_WeaponDefAtIndex(weapon->weaponIdx);
    __asm { vmovss  xmm6, dword ptr [rax+8B4h] }
  }
  v25 = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v27 = ps && weaponMap && (v26 = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon)) != NULL && v26->hybridScope;
  if ( v25 )
  {
    v28 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20757, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RAX = BG_GetAttachmentViewKick(weaponMap, ps, weapon, isAlternate, *v28, v27);
      v30 = 0;
      v31 = _RAX == NULL;
      if ( _RAX )
        break;
      ++v16;
      ++v28;
      if ( v16 >= v25 )
        goto LABEL_33;
    }
    __asm { vmovss  xmm2, dword ptr [rax+158h] }
  }
  else
  {
LABEL_33:
    _RAX = BG_WeaponDefAtIndex(weapon->weaponIdx);
    __asm { vmovss  xmm2, dword ptr [rax+8B8h] }
  }
  __asm
  {
    vmovss  xmm0, [rsp+1C8h+pitchMove]
    vxorps  xmm3, xmm0, cs:__xmm@80000000800000008000000080000000
    vmovss  xmm0, [rsp+1C8h+pitchKick]
    vmovss  xmm4, cs:__real@3f800000
    vxorps  xmm1, xmm1, xmm1
    vucomiss xmm0, xmm1
  }
  if ( v31 )
  {
    __asm { vmovaps xmm0, xmm4 }
  }
  else
  {
    __asm
    {
      vucomiss xmm3, xmm1
      vcomiss xmm0, xmm1
    }
    if ( !(v30 | v31) )
    {
      __asm { vcomiss xmm3, xmm1 }
      if ( v30 )
      {
        __asm { vmovaps xmm0, xmm2 }
        goto LABEL_46;
      }
      __asm { vcomiss xmm0, xmm1 }
    }
    if ( !v30 )
      goto LABEL_44;
    __asm { vcomiss xmm3, xmm1 }
    if ( v30 | v31 )
LABEL_44:
      __asm { vmovaps xmm0, xmm6 }
    else
      __asm { vmovaps xmm0, xmm2 }
  }
LABEL_46:
  _RAX = outPitchInputScalar;
  __asm
  {
    vmovss  xmm3, [rsp+1C8h+yawKick]
    vucomiss xmm3, xmm1
    vmovss  dword ptr [rax], xmm0
  }
  if ( v31 )
  {
    _RAX = outYawInputScalar;
    __asm { vmovss  dword ptr [rax], xmm4 }
    goto LABEL_56;
  }
  __asm
  {
    vmovss  xmm0, [rsp+1C8h+yawMove]
    vucomiss xmm0, xmm1
    vcomiss xmm3, xmm1
  }
  if ( !(v30 | v31) )
  {
    __asm { vcomiss xmm0, xmm1 }
    if ( v30 )
      goto LABEL_50;
    __asm { vcomiss xmm3, xmm1 }
  }
  if ( !v30 )
    goto LABEL_54;
  __asm { vcomiss xmm0, xmm1 }
  if ( v30 | v31 )
  {
LABEL_54:
    _RAX = outYawInputScalar;
    __asm { vmovss  dword ptr [rax], xmm6 }
    goto LABEL_56;
  }
LABEL_50:
  _RAX = outYawInputScalar;
  __asm { vmovss  dword ptr [rax], xmm2 }
LABEL_56:
  __asm { vmovaps xmm6, [rsp+1C8h+var_48] }
}

/*
==============
BG_CalculateScopeFadeFraction
==============
*/

void __fastcall BG_CalculateScopeFadeFraction(AttSight *sight, double fractionFadeIn, double fractionFadeOut, GfxScopeFadeInfo *outScopeFadeInfo)
{
  const dvar_t *v22; 
  const dvar_t *v30; 
  char v44; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  _RSI = outScopeFadeInfo;
  __asm { vmovaps xmmword ptr [rax-28h], xmm7 }
  _RBX = sight;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
    vmovaps xmmword ptr [rax-78h], xmm12
    vmovaps xmm10, xmm2
    vmovaps xmm8, xmm1
  }
  if ( !sight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15683, ASSERT_TYPE_ASSERT, "(sight)", (const char *)&queryFormat, "sight") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vminss  xmm7, xmm0, cs:__real@3f7d70a4
    vaddss  xmm0, xmm7, cs:__real@3c23d70a
    vmovss  xmm1, dword ptr [rbx+14h]
    vminss  xmm11, xmm1, cs:__real@3f7d70a4
    vmaxss  xmm9, xmm0, dword ptr [rbx+10h]
  }
  v22 = DCONST_DVARBOOL_bg_scopeFadeIn;
  __asm
  {
    vaddss  xmm0, xmm11, cs:__real@3c23d70a
    vmaxss  xmm12, xmm0, dword ptr [rbx+18h]
  }
  if ( !DCONST_DVARBOOL_bg_scopeFadeIn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeIn") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v22);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  if ( v22->current.enabled && _RBX->adsSmoothFade )
  {
    __asm
    {
      vsubss  xmm1, xmm8, xmm7
      vsubss  xmm0, xmm9, xmm7
      vdivss  xmm0, xmm1, xmm0; val
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm2, xmm6; max
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  }
  else
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+4], xmm0 }
  v30 = DCONST_DVARBOOL_bg_scopeFadeOut;
  if ( !DCONST_DVARBOOL_bg_scopeFadeOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeOut") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v30);
  if ( v30->current.enabled && _RBX->adsSmoothFade )
  {
    __asm
    {
      vsubss  xmm3, xmm9, xmm10
      vsubss  xmm0, xmm12, xmm11
      vdivss  xmm0, xmm3, xmm0; val
      vmovaps xmm2, xmm6; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovss  dword ptr [rsi], xmm0 }
  }
  else
  {
    __asm { vmovss  dword ptr [rsi], xmm6 }
  }
  _R11 = &v44;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
}

/*
==============
BG_CalculateScopeFadeFractions
==============
*/
void BG_CalculateScopeFadeFractions(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const float adsFrac, const bool playerUsesNVGHalfADS, const WeaponAttachment *scopeAttachment, const BgHybridScopeFraction *hybridScopeFraction, GfxScopeInfo *settingOut)
{
  GfxScopeInfo *v12; 
  AttSight *sight; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  GfxScopeInfo *v19; 
  AttSight *v20; 
  BgHybridScopeInfo outHybridScopeInfo; 

  v12 = settingOut;
  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15714, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15715, ASSERT_TYPE_ASSERT, "(settingOut)", (const char *)&queryFormat, "settingOut") )
    __debugbreak();
  if ( !scopeAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15716, ASSERT_TYPE_ASSERT, "(scopeAttachment)", (const char *)&queryFormat, "scopeAttachment") )
    __debugbreak();
  if ( !scopeAttachment->sight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15717, ASSERT_TYPE_ASSERT, "(scopeAttachment->sight)", (const char *)&queryFormat, "scopeAttachment->sight") )
    __debugbreak();
  sight = scopeAttachment->sight;
  memset(&outHybridScopeInfo, 0, sizeof(outHybridScopeInfo));
  v12->adsSmoothFade = sight->adsSmoothFade;
  if ( playerUsesNVGHalfADS )
  {
    v12->scopeFadeInfo[0] = (GfxScopeFadeInfo)1065353216i64;
    v12->scopeFadeInfo[1] = (GfxScopeFadeInfo)1065353216i64;
  }
  else
  {
    __asm { vmovaps [rsp+0B8h+var_38], xmm6 }
    if ( !BG_CanHybridToggle(ps, r_weapon, isAlternate) )
      goto LABEL_33;
    if ( BG_GetWeaponClass(r_weapon, isAlternate) == WEAPCLASS_ROCKETLAUNCHER )
      goto LABEL_33;
    _EDI = 0;
    settingOut = NULL;
    HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(r_weapon, isAlternate, (const WeaponAttachment **)&settingOut);
    if ( HybridScopeEnablerAttachment != scopeAttachment )
      goto LABEL_33;
    v19 = settingOut;
    if ( !settingOut )
      goto LABEL_33;
    BG_GetHybridScopeInfo(r_weapon, isAlternate, &outHybridScopeInfo);
    v20 = *(AttSight **)&v19[1].scopeLensAxis.row1.z;
    if ( !outHybridScopeInfo.hasHybridScope && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15764, ASSERT_TYPE_ASSERT, "(hybridScopeInfo.hasHybridScope)", (const char *)&queryFormat, "hybridScopeInfo.hasHybridScope", outHybridScopeInfo.hybridScopeAttachment, *(_QWORD *)&outHybridScopeInfo.hybridScope1To2FovTransBegin, *(_QWORD *)&outHybridScopeInfo.hybridScope2To1FovTransBegin, *(_QWORD *)&outHybridScopeInfo.hybridScope1To2ScopeFadeTransBegin, *(_QWORD *)&outHybridScopeInfo.hybridScope2To1ScopeFadeTransBegin) )
      __debugbreak();
    if ( v20 )
    {
      __asm
      {
        vmovaps [rsp+0B8h+var_48], xmm7
        vmovaps [rsp+0B8h+var_58], xmm8
      }
      if ( !HybridScopeEnablerAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15770, ASSERT_TYPE_ASSERT, "(hybridEnablerAttachment)", (const char *)&queryFormat, "hybridEnablerAttachment") )
        __debugbreak();
      if ( !HybridScopeEnablerAttachment->adsOverlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15771, ASSERT_TYPE_ASSERT, "(hybridEnablerAttachment->adsOverlay)", (const char *)&queryFormat, "hybridEnablerAttachment->adsOverlay") )
        __debugbreak();
      _RAX = hybridScopeFraction;
      __asm
      {
        vmovss  xmm7, cs:__real@3f800000
        vmovss  xmm0, dword ptr [rax]
      }
      if ( hybridScopeFraction->increasing )
      {
        __asm
        {
          vsubss  xmm2, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope1To2ScopeFadeTransBegin]
          vmovss  xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope1To2ScopeFadeTransEnd]
          vsubss  xmm1, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope1To2ScopeFadeTransBegin]
          vdivss  xmm0, xmm2, xmm1; val
          vmovaps xmm2, xmm7; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vsubss  xmm0, xmm0, cs:__real@3f000000
          vmulss  xmm0, xmm0, cs:__real@40490fdb; X
        }
        *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
        __asm
        {
          vaddss  xmm1, xmm0, xmm7
          vmulss  xmm8, xmm1, cs:__real@3f000000
        }
      }
      else
      {
        __asm
        {
          vsubss  xmm0, xmm7, xmm0
          vsubss  xmm2, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope2To1ScopeFadeTransBegin]
          vmovss  xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope2To1ScopeFadeTransEnd]
          vsubss  xmm1, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope2To1ScopeFadeTransBegin]
          vdivss  xmm0, xmm2, xmm1; val
          vmovaps xmm2, xmm7; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovss  xmm6, cs:__real@3f000000
          vsubss  xmm0, xmm0, xmm6
          vmulss  xmm0, xmm0, cs:__real@40490fdb; X
        }
        *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
        __asm
        {
          vmulss  xmm1, xmm0, xmm6
          vsubss  xmm8, xmm6, xmm1
        }
      }
      __asm
      {
        vmovss  xmm6, [rsp+0B8h+adsFrac]
        vsubss  xmm0, xmm7, xmm8
        vmulss  xmm1, xmm0, xmm6; fractionFadeIn
      }
      _EAX = HybridScopeEnablerAttachment->adsOverlay->hybridScope1ShowHipGlassWhenInactive;
      __asm
      {
        vmovd   xmm2, edi
        vmovd   xmm0, eax
        vpcmpeqd xmm3, xmm0, xmm2
        vblendvps xmm2, xmm1, xmm6, xmm3; fractionFadeOut
      }
      BG_CalculateScopeFadeFraction(sight, *(double *)&_XMM1, *(double *)&_XMM2, v12->scopeFadeInfo);
      __asm
      {
        vmovd   xmm2, edi
        vmulss  xmm1, xmm8, xmm6; fractionFadeIn
      }
      _EAX = HybridScopeEnablerAttachment->adsOverlay->hybridScope2ShowHipGlassWhenInactive;
      __asm
      {
        vmovd   xmm0, eax
        vpcmpeqd xmm3, xmm0, xmm2
        vblendvps xmm2, xmm1, xmm6, xmm3; fractionFadeOut
      }
      BG_CalculateScopeFadeFraction(v20, *(double *)&_XMM1, *(double *)&_XMM2, &v12->scopeFadeInfo[1]);
      __asm
      {
        vmovaps xmm8, [rsp+0B8h+var_58]
        vmovaps xmm7, [rsp+0B8h+var_48]
      }
    }
    else
    {
LABEL_33:
      __asm
      {
        vmovss  xmm6, [rsp+0B8h+adsFrac]
        vmovaps xmm2, xmm6; fractionFadeOut
        vmovaps xmm1, xmm6; fractionFadeIn
      }
      BG_CalculateScopeFadeFraction(sight, *(double *)&_XMM1, *(double *)&_XMM2, v12->scopeFadeInfo);
      __asm
      {
        vmovaps xmm2, xmm6; fractionFadeOut
        vmovaps xmm1, xmm6; fractionFadeIn
      }
      BG_CalculateScopeFadeFraction(sight, *(double *)&_XMM1, *(double *)&_XMM2, &v12->scopeFadeInfo[1]);
    }
    __asm { vmovaps xmm6, [rsp+0B8h+var_38] }
  }
}

/*
==============
BG_CanAttachmentHybridToggle
==============
*/
AttADSOverlay *BG_CanAttachmentHybridToggle(const WeaponAttachment *attachment)
{
  AttADSOverlay *result; 

  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  result = attachment->adsOverlay;
  if ( result )
    return (AttADSOverlay *)result->hybridToggle;
  return result;
}

/*
==============
BG_CanEquipWeapon
==============
*/
bool BG_CanEquipWeapon(const BgWeaponMap *const weaponMap, const playerState_s *const ps, const Weapon *r_weapon)
{
  return BG_GetFreeEquipSlot(weaponMap, ps) >= 0;
}

/*
==============
BG_CanHybridToggle
==============
*/
bool BG_CanHybridToggle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  bool v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v8; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  v4 = isAlternate;
  if ( ps && isAlternate && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v4, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7556, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    v8 = *i;
    if ( (*i)->type == ATTACHMENT_SCOPE )
      break;
    if ( ++v3 >= WeaponAttachments_Internal )
      return 0;
  }
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  adsOverlay = v8->adsOverlay;
  if ( !adsOverlay )
    return 0;
  return adsOverlay->hybridToggle;
}

/*
==============
BG_CanPlayerHaveWeapon
==============
*/
bool BG_CanPlayerHaveWeapon(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->gunXModel != NULL;
}

/*
==============
BG_CanThermalToggle
==============
*/
bool BG_CanThermalToggle(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = v4->thermalToggle && v4->thermalScope;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v5;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7599, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    if ( (*i)->type == ATTACHMENT_SCOPE )
    {
      adsOverlay = (*i)->adsOverlay;
      if ( adsOverlay )
        break;
    }
    if ( ++v6 >= WeaponAttachments_Internal )
      return v5;
  }
  return adsOverlay->thermalToggle && adsOverlay->thermalScope;
}

/*
==============
BG_ChargeWeaponInTime
==============
*/
__int64 BG_ChargeWeaponInTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 220i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, animIndex, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_ChargeWeaponLoopTime
==============
*/
__int64 BG_ChargeWeaponLoopTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 222i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, animIndex, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_ChargeWeaponOutTime
==============
*/
__int64 BG_ChargeWeaponOutTime(const playerState_s *ps, weapAnimFiles_t animIndex, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 224i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, animIndex, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_CheckTorsoAnimForModelVisibility
==============
*/
__int64 BG_CheckTorsoAnimForModelVisibility(const BgAnimStatic *const bgameAnim, const entityState_t *es, characterInfo_t *ci, scr_string_t notetrack_on, scr_string_t notetrack_off, float rangeExpand)
{
  unsigned int Animset; 
  PlayerASM_AnimSlot v15; 
  unsigned int v16; 
  unsigned int Anim; 
  unsigned int XAnimIndex; 
  XAnimTree *pXAnimTree; 
  char v20; 
  int XAnimIndexForCharacter; 
  char v25; 
  __int64 result; 
  unsigned int outAnimPartsIndex; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
    vmovaps [rsp+58h+var_38], xmm8
  }
  if ( PlayerASM_IsEnabled() )
  {
    Animset = BG_PlayerASM_GetAnimset(ci);
    LOBYTE(v15) = 1;
    v16 = Animset;
    Anim = BG_PlayerASM_GetAnim(es, v15);
    XAnimIndex = BG_PlayerASM_GetXAnimIndex(v16, Anim);
    pXAnimTree = ci->pXAnimTree;
    outAnimPartsIndex = 0;
    BG_PlayerASM_GetXAnimParts(pXAnimTree->anims, XAnimIndex, &outAnimPartsIndex);
    XAnimIndexForCharacter = outAnimPartsIndex;
  }
  else
  {
    XAnimIndexForCharacter = BG_AnimationMP_GetXAnimIndexForCharacter(bgameAnim, ci, ci->torso.animationNumber & 0xFFFFEFFF);
  }
  __asm
  {
    vmovss  xmm8, [rsp+58h+rangeExpand]
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm8, xmm6
    vxorps  xmm7, xmm7, xmm7
  }
  if ( !v20 )
  {
    *(double *)&_XMM0 = XAnimGetLength(ci->pXAnimTree->anims, XAnimIndexForCharacter);
    __asm { vcomiss xmm0, xmm6 }
    if ( !(v25 | v20) )
      __asm { vdivss  xmm7, xmm8, xmm0 }
  }
  *(double *)&_XMM0 = XAnimGetNotetrackTime(ci->pXAnimTree->anims, XAnimIndexForCharacter, notetrack_on);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovaps xmm8, xmm0
  }
  if ( !v25 )
  {
    *(double *)&_XMM0 = XAnimGetTime(ci->pXAnimTree, 0, XANIM_SUBTREE_DEFAULT, XAnimIndexForCharacter);
    __asm
    {
      vsubss  xmm1, xmm8, xmm7
      vcomiss xmm0, xmm1
    }
    if ( v25 )
      goto LABEL_11;
  }
  *(double *)&_XMM0 = XAnimGetNotetrackTime(ci->pXAnimTree->anims, XAnimIndexForCharacter, notetrack_off);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovaps xmm8, xmm0
  }
  if ( v25 )
    goto LABEL_12;
  *(double *)&_XMM0 = XAnimGetTime(ci->pXAnimTree, 0, XANIM_SUBTREE_DEFAULT, XAnimIndexForCharacter);
  __asm
  {
    vaddss  xmm1, xmm8, xmm7
    vcomiss xmm0, xmm1
  }
  if ( v25 )
LABEL_12:
    result = 1i64;
  else
LABEL_11:
    result = 0i64;
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
    vmovaps xmm8, [rsp+58h+var_38]
  }
  return result;
}

/*
==============
BG_ClearAgentWeapons
==============
*/
void BG_ClearAgentWeapons(BgWeaponMap *weaponMap, agentState_s *as)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20448, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !as && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20449, ASSERT_TYPE_ASSERT, "(as)", (const char *)&queryFormat, "as") )
    __debugbreak();
  weaponMap->ClearWeapon(weaponMap, &as->serverDobjHeldWeapon);
  weaponMap->ClearWeapon(weaponMap, &as->serverDobjTurretWeapon);
}

/*
==============
BG_ClearClientWeapons
==============
*/
void BG_ClearClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20438, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !cs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20439, ASSERT_TYPE_ASSERT, "(cs)", (const char *)&queryFormat, "cs") )
    __debugbreak();
  weaponMap->ClearWeapon(weaponMap, &cs->serverDobjHeldWeapon);
  weaponMap->ClearWeapon(weaponMap, &cs->serverDobjTurretWeapon);
}

/*
==============
BG_ClearMLGSpectatorClientWeapons
==============
*/
void BG_ClearMLGSpectatorClientWeapons(BgWeaponMap *weaponMap, MLGSpectatorClientInfo *mlgSpectatorClientInfo)
{
  BgWeaponHandle *weaponHandles; 
  __int64 v5; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20459, ASSERT_TYPE_ASSERT, "( weaponMap )", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !mlgSpectatorClientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20460, ASSERT_TYPE_ASSERT, "( mlgSpectatorClientInfo )", (const char *)&queryFormat, "mlgSpectatorClientInfo") )
    __debugbreak();
  weaponHandles = mlgSpectatorClientInfo->weaponHandles;
  v5 = 2i64;
  do
  {
    weaponMap->ClearWeapon(weaponMap, weaponHandles++);
    --v5;
  }
  while ( v5 );
}

/*
==============
BG_ClearPlayerWeapons
==============
*/
void BG_ClearPlayerWeapons(BgWeaponMap *weaponMap, playerState_s *ps)
{
  BgWeaponHandle *weaponsEquipped; 
  __int64 v5; 
  int i; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20395, ASSERT_TYPE_ASSERT, "( weaponMap )", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20396, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.weaponHandle);
  weaponMap->ClearWeapon(weaponMap, (BgWeaponHandle *)&ps->weapCommon);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.lastWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.lastStowedWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.weaponSpawnHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.weaponAnimArrayHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.forcedViewAnimWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->weapCommon.forcedViewAnimOriginalWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->throwbackWeaponHandle);
  weaponMap->ClearWeapon(weaponMap, &ps->serverDobjHeldWeapon);
  weaponMap->ClearWeapon(weaponMap, &ps->serverDobjTurretWeapon);
  weaponMap->ClearWeapon(weaponMap, &ps->executionWeapon);
  weaponMap->ClearWeapon(weaponMap, (BgWeaponHandle *)&ps->highPriorityWeapInfo);
  weaponsEquipped = ps->weaponsEquipped;
  v5 = 15i64;
  do
  {
    weaponMap->ClearWeapon(weaponMap, weaponsEquipped++);
    --v5;
  }
  while ( v5 );
  for ( i = 0; i < 7; ++i )
    BG_ClearActionSlotParameter(weaponMap, ps, i);
  BG_ClearPlayerEvents(weaponMap, ps);
}

/*
==============
BG_ConvertWeaponFromHexString
==============
*/
Weapon *BG_ConvertWeaponFromHexString(Weapon *result, const char *hexString)
{
  Weapon *v5; 

  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups ymmword ptr [rcx], ymm0
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
    vmovups xmmword ptr [rcx+20h], xmm1
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
    vmovsd  qword ptr [rcx+30h], xmm0
  }
  *(_DWORD *)&result->weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  v5 = result;
  Com_ConvertHexToBytes(hexString, 0x3Cui64, (unsigned __int8 *)result);
  return v5;
}

/*
==============
BG_ConvertWeaponToHexString
==============
*/
void BG_ConvertWeaponToHexString(const Weapon *r_weapon, char *outHexString, int outStringLength)
{
  if ( !outHexString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20622, ASSERT_TYPE_ASSERT, "(outHexString)", (const char *)&queryFormat, "outHexString") )
    __debugbreak();
  Com_ConvertBytesToHex((const unsigned __int8 *)r_weapon, 60, outStringLength, outHexString);
}

/*
==============
BG_CopyPlayerWeapons
==============
*/
void BG_CopyPlayerWeapons(BgWeaponMap *dstWeaponMap, playerState_s *dstPs, const BgWeaponMap *srcWeaponMap, const playerState_s *srcPs)
{
  const Weapon *CurrentWeaponForPlayer; 
  const Weapon *Weapon; 
  const Weapon *OffHandWeaponForPlayer; 
  const Weapon *v11; 
  const Weapon *v12; 
  const Weapon *v13; 
  const Weapon *v14; 
  const Weapon *v15; 
  const Weapon *ThrowbackWeaponForPlayer; 
  const Weapon *v17; 
  const Weapon *v18; 
  const Weapon *v19; 
  const Weapon *v20; 
  BgWeaponHandle *weaponsEquipped; 
  int v22; 
  const Weapon *v23; 
  int v24; 
  ActionSlotType *actionSlotType; 
  ActionSlotParam *actionSlotParam; 
  __int64 v31; 
  __int64 v32; 
  signed __int64 v34; 
  __m256i v35; 
  int v38; 

  if ( !dstWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20474, ASSERT_TYPE_ASSERT, "( dstWeaponMap )", (const char *)&queryFormat, "dstWeaponMap") )
    __debugbreak();
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20475, ASSERT_TYPE_ASSERT, "( dstPs )", (const char *)&queryFormat, "dstPs") )
    __debugbreak();
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20476, ASSERT_TYPE_ASSERT, "( srcWeaponMap )", (const char *)&queryFormat, "srcWeaponMap") )
    __debugbreak();
  if ( !srcPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20477, ASSERT_TYPE_ASSERT, "( srcPs )", (const char *)&queryFormat, "srcPs") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(srcWeaponMap, srcPs);
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.weaponHandle, CurrentWeaponForPlayer);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 863, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !srcPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 864, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.lastWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 875, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.lastWeaponHandle, Weapon);
  OffHandWeaponForPlayer = BG_GetOffHandWeaponForPlayer(srcWeaponMap, srcPs);
  BG_SetOffHandWeaponForPlayer(dstWeaponMap, dstPs, OffHandWeaponForPlayer);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 972, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v11 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.lastStowedWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 982, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.lastStowedWeaponHandle, v11);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 936, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v12 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.weaponSpawnHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 946, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.weaponSpawnHandle, v12);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 954, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v13 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.weaponAnimArrayHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 964, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.weaponAnimArrayHandle, v13);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 990, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v14 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.forcedViewAnimWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1000, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.forcedViewAnimWeaponHandle, v14);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1008, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v15 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->weapCommon.forcedViewAnimOriginalWeaponHandle);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1018, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->weapCommon.forcedViewAnimOriginalWeaponHandle, v15);
  ThrowbackWeaponForPlayer = BG_GetThrowbackWeaponForPlayer(srcWeaponMap, srcPs);
  BG_SetThrowbackWeaponForPlayer(dstWeaponMap, dstPs, ThrowbackWeaponForPlayer);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 785, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v17 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->serverDobjHeldWeapon);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 795, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->serverDobjHeldWeapon, v17);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 803, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v18 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->serverDobjTurretWeapon);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 813, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->serverDobjTurretWeapon, v18);
  if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 821, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v19 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, srcPs->executionWeapon);
  if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 831, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  dstWeaponMap->SetWeapon(dstWeaponMap, &dstPs->executionWeapon, v19);
  v20 = BG_HighPriorityWeapon_Get(srcWeaponMap, srcPs);
  BG_HighPriorityWeapon_SetDirectly(dstWeaponMap, dstPs, v20);
  weaponsEquipped = dstPs->weaponsEquipped;
  v22 = 0;
  v34 = (char *)srcPs - (char *)dstPs;
  do
  {
    if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( (unsigned int)v22 >= 0xF )
    {
      LODWORD(v32) = 15;
      LODWORD(v31) = v22;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v31, v32) )
        __debugbreak();
    }
    v23 = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, *(BgWeaponHandle *)((char *)weaponsEquipped + (char *)srcPs - (char *)dstPs));
    if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 852, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( (unsigned int)v22 >= 0xF )
    {
      LODWORD(v32) = 15;
      LODWORD(v31) = v22;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 853, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v31, v32) )
        __debugbreak();
    }
    dstWeaponMap->SetWeapon(dstWeaponMap, weaponsEquipped, v23);
    ++v22;
    ++weaponsEquipped;
  }
  while ( v22 < 15 );
  v24 = 0;
  actionSlotType = dstPs->actionSlotType;
  actionSlotParam = dstPs->actionSlotParam;
  do
  {
    if ( dstPs != srcPs )
      BG_ClearActionSlotParameter(dstWeaponMap, dstPs, v24);
    *actionSlotType = *(ActionSlotType *)((char *)actionSlotType + v34);
    if ( BG_ActionSlotIsWeaponType(srcPs, v24) )
    {
      if ( !srcWeaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1026, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( (unsigned int)v24 >= 7 )
      {
        LODWORD(v32) = 7;
        LODWORD(v31) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1028, ASSERT_TYPE_ASSERT, "(unsigned)( actionSlotIndex ) < (unsigned)( 7 )", "actionSlotIndex doesn't index ACTIONSLOTS_COUNT_STATIC\n\t%i not in [0, %i)", v31, v32) )
          __debugbreak();
      }
      if ( !BG_ActionSlotIsWeaponType(srcPs, v24) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1029, ASSERT_TYPE_ASSERT, "(BG_ActionSlotIsWeaponType( ps, actionSlotIndex ))", (const char *)&queryFormat, "BG_ActionSlotIsWeaponType( ps, actionSlotIndex )") )
        __debugbreak();
      _RAX = BgWeaponMap::GetWeapon((BgWeaponMap *)srcWeaponMap, *(BgWeaponHandle *)((char *)&actionSlotParam->specifyWeapon.weaponHandle + v34));
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups [rsp+0E8h+var_90], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups [rsp+0E8h+var_70], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  [rsp+0E8h+var_60], xmm0
      }
      v38 = *(_DWORD *)&_RAX->weaponCamo;
      if ( !dstPs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1038, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (unsigned int)v24 >= 7 )
      {
        LODWORD(v32) = 7;
        LODWORD(v31) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1039, ASSERT_TYPE_ASSERT, "(unsigned)( actionSlotIndex ) < (unsigned)( 7 )", "actionSlotIndex doesn't index ACTIONSLOTS_COUNT_STATIC\n\t%i not in [0, %i)", v31, v32) )
          __debugbreak();
      }
      if ( !BG_ActionSlotIsWeaponType(dstPs, v24) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1040, ASSERT_TYPE_ASSERT, "(BG_ActionSlotIsWeaponType( ps, actionSlotIndex ))", (const char *)&queryFormat, "BG_ActionSlotIsWeaponType( ps, actionSlotIndex )") )
        __debugbreak();
      dstWeaponMap->SetWeapon(dstWeaponMap, (BgWeaponHandle *)actionSlotParam, (const Weapon *)&v35);
    }
    else
    {
      actionSlotType[7] = *(ActionSlotType *)((char *)actionSlotType + v34 + 28);
    }
    ++v24;
    ++actionSlotParam;
    ++actionSlotType;
  }
  while ( v24 < 7 );
  BG_CopyPlayerEvents(dstWeaponMap, dstPs, srcWeaponMap, srcPs);
}

/*
==============
BG_CrawlLoopTime
==============
*/
__int64 BG_CrawlLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 180i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_CRAWL_LOOP, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_CreateWeaponFireParam
==============
*/
__int64 BG_CreateWeaponFireParam(int boneIndex, const Weapon *r_weaponID)
{
  __int64 v5; 

  if ( r_weaponID->weaponIdx == 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4719, ASSERT_TYPE_ASSERT, "(r_weaponID.weaponIdx < 0xffff)", (const char *)&queryFormat, "r_weaponID.weaponIdx < USHRT_MAX") )
    __debugbreak();
  if ( boneIndex + 1 >= 0xFFFF )
  {
    LODWORD(v5) = boneIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4720, ASSERT_TYPE_ASSERT, "( ( boneIndex + 1 < 0xffff ) )", "( boneIndex ) = %i", v5) )
      __debugbreak();
  }
  if ( boneIndex < 0 )
  {
    LODWORD(v5) = boneIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4721, ASSERT_TYPE_ASSERT, "( ( boneIndex >= 0 ) )", "( boneIndex ) = %i", v5) )
      __debugbreak();
  }
  return (boneIndex + 1) | (r_weaponID->weaponIdx << 16);
}

/*
==============
BG_CurrentWeaponSupportsDualFOV
==============
*/
bool BG_CurrentWeaponSupportsDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelWeapon; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3036, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3037, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  return BG_HasDualFOV(weaponMap, ps, ViewmodelWeapon, 0) || BG_HasUnderbarrelAmmo(ViewmodelWeapon) && BG_HasDualFOV(weaponMap, ps, ViewmodelWeapon, 1);
}

/*
==============
BG_DPadIcon
==============
*/
Material *BG_DPadIcon(const Weapon *r_weapon, bool isAlternate, bool isActive)
{
  const WeaponCompleteDef *v5; 
  Material *dpadIconMat; 
  int v7; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v5 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( isActive || (dpadIconMat = v5->dpadIconInactiveMat) == NULL )
    dpadIconMat = v5->dpadIconMat;
  v7 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
    return dpadIconMat;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16315, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v7 >= AllWeaponAttachmentsWithIds )
      return dpadIconMat;
  }
  if ( isActive || !ui->dpadIconInactiveMat )
    return ui->dpadIconMat;
  else
    return ui->dpadIconInactiveMat;
}

/*
==============
BG_DamageConeAngle
==============
*/
float BG_DamageConeAngle(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+6FCh] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17020, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->projectile )
        break;
      ++v6;
      ++v9;
      if ( v6 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_9;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx+10h] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_9:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_DangerIcon
==============
*/
Material *BG_DangerIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->dangerIconMat;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16218, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->dangerIconMat;
  }
  return ui->dangerIconMat;
}

/*
==============
BG_DeathAnimDamageType
==============
*/
__int64 BG_DeathAnimDamageType(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttDamage *damage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->damageInfo.deathAnimDamageType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8381, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    damage = (*i)->damage;
    if ( damage )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->damageInfo.deathAnimDamageType;
  }
  return (unsigned int)damage->deathAnimDamageType;
}

/*
==============
BG_DebugSniperScene
==============
*/
void BG_DebugSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, float frac)
{
  bool v7; 
  const dvar_t *v8; 
  bool v9; 
  bool enabled; 
  const dvar_t *v11; 
  bool v12; 
  DObjPartBits *p_hidePartBits; 
  DObjPartBits *v14; 
  DObjPartBits *v15; 
  unsigned __int8 v16; 
  unsigned int v17; 
  const scr_string_t **v18; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5408, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v7 = BG_ShowViewModelInDualFOV(r_weapon, isAlternate);
  v8 = DCONST_DVARBOOL_bg_showSniperScene;
  v9 = v7;
  if ( !DCONST_DVARBOOL_bg_showSniperScene && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showSniperScene") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  enabled = v8->current.enabled;
  v11 = DCONST_DVARBOOL_bg_showHipScene;
  if ( !DCONST_DVARBOOL_bg_showHipScene && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showHipScene") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  v12 = v11->current.enabled;
  p_hidePartBits = &obj->hidePartBits;
  if ( enabled )
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  else
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  v14 = &obj->hidePartBits;
  if ( v12 )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, v14, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, v14, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  }
  if ( !v9 )
  {
    v15 = &obj->hidePartBits;
    if ( enabled )
      v16 = BG_ShowBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, v15, 0, -1);
    else
      v16 = BG_HideBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, v15, 0, -1);
    if ( v16 <= 0xFDu )
    {
      v17 = 0;
      v18 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
      do
      {
        BG_ToggleBoneVisibilityInAllModels(**v18, obj, &obj->hidePartBits, v12);
        ++v17;
        ++v18;
      }
      while ( v17 < 0xD );
    }
  }
}

/*
==============
BG_DestabilizationCurvatureMax
==============
*/
float BG_DestabilizationCurvatureMax(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+0D08h] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17498, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->projectile )
        break;
      ++v6;
      ++v9;
      if ( v6 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_9;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx+98h] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_9:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_DestabilizationRateTime
==============
*/
float BG_DestabilizationRateTime(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+0D04h] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17473, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->projectile )
        break;
      ++v6;
      ++v9;
      if ( v6 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_9;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx+94h] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_9:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_DestabilizeDistance
==============
*/
__int64 BG_DestabilizeDistance(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int destabilizeDistance; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  destabilizeDistance = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->destabilizeDistance;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return destabilizeDistance;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17523, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return destabilizeDistance;
  }
  return (unsigned int)projectile->destabilizeDistance;
}

/*
==============
BG_DisableInputDrivenViewReturnDampening
==============
*/
bool BG_DisableInputDrivenViewReturnDampening(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  bool v4; 
  __int64 v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  WeaponAttachment **i; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = isAlternate;
  v8 = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableInputDrivenViewReturnDampening;
  for ( i = attachments; ; ++i )
  {
    OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, v4, *i, v11);
    if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20780, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( OverrideAttachmentWhenApplicable->disableInputDrivenViewReturnDampening )
      break;
    v4 = isAlternate;
    v8 = (unsigned int)(v8 + 1);
    if ( (unsigned int)v8 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableInputDrivenViewReturnDampening;
  }
  return attachments[v8]->disableInputDrivenViewReturnDampening == WEAPON_FLAG_OVERRIDE_TRUE;
}

/*
==============
BG_DisableProjectileCrumpleCheck
==============
*/
_BOOL8 BG_DisableProjectileCrumpleCheck(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->disableProjectileCrumpleCheck;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17421, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->disableProjectileCrumpleCheck;
  }
  return projectile->disableProjectileCrumpleCheck;
}

/*
==============
BG_DoubleRiotShieldCheck
==============
*/
char BG_DoubleRiotShieldCheck(const BgWeaponMap *weaponMap, const Weapon *weaponToPickUp, const playerState_s *ps)
{
  unsigned int v7; 
  __int64 v13; 
  __int64 v14; 
  Weapon r_weapon; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8104, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8105, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponToPickUp->weaponIdx || !BG_IsRiotShield(weaponToPickUp, 0) )
    return 0;
  v7 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v7 >= 0xF )
    {
      LODWORD(v14) = 15;
      LODWORD(v13) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    _RAX = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v7]);
    __asm
    {
      vmovups ymm2, ymmword ptr [rax]
      vmovups xmm0, xmmword ptr [rax+20h]
      vmovsd  xmm1, qword ptr [rax+30h]
    }
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
    __asm
    {
      vmovd   eax, xmm2
      vmovups ymmword ptr [rsp+0C8h+r_weapon.weaponIdx], ymm2
      vmovups xmmword ptr [rsp+0C8h+r_weapon.attachmentVariationIndices+5], xmm0
      vmovsd  qword ptr [rsp+0C8h+r_weapon.attachmentVariationIndices+15h], xmm1
    }
    if ( (_WORD)_RAX )
    {
      if ( BG_IsRiotShield(&r_weapon, 0) )
        break;
    }
    if ( (int)++v7 >= 15 )
      return 0;
  }
  return 1;
}

/*
==============
BG_DropTime
==============
*/
__int64 BG_DropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 132i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_EmptyDropTime
==============
*/
__int64 BG_EmptyDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 150i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_EmptyFireSound
==============
*/
const SndAliasList *BG_EmptyFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  _BOOL8 v3; 
  const WeaponSFXPackage *SfxPackage; 

  v3 = isPlayer;
  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 8 * v3 + 336);
}

/*
==============
BG_EmptyRaiseTime
==============
*/
__int64 BG_EmptyRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 148i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_EndingGunKickPercent
==============
*/
float BG_EndingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    __asm { vmovss  xmm6, dword ptr [rax+8ACh] }
  else
    __asm { vmovss  xmm6, dword ptr [rax+8A0h] }
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14299, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v11)->kickScaling )
        break;
      ++v9;
      ++v11;
      if ( v9 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_12;
      }
    }
    if ( ads )
      __asm { vmovss  xmm0, dword ptr [rcx+20h] }
    else
      __asm { vmovss  xmm0, dword ptr [rcx+14h] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_12:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_EndingKickBullets
==============
*/
__int64 BG_EndingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int adsEndingKickBullets; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttKickScaling *kickScaling; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  adsEndingKickBullets = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsEndingKickBullets;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsEndingKickBullets;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14266, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    kickScaling = (*i)->kickScaling;
    if ( kickScaling )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return adsEndingKickBullets;
  }
  return (unsigned int)kickScaling->adsEndingKickBullets;
}

/*
==============
BG_EndingViewKickPercent
==============
*/
float BG_EndingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    __asm { vmovss  xmm6, dword ptr [rax+8B0h] }
  else
    __asm { vmovss  xmm6, dword ptr [rax+8A4h] }
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14338, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v11)->kickScaling )
        break;
      ++v9;
      ++v11;
      if ( v9 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_12;
      }
    }
    if ( ads )
      __asm { vmovss  xmm0, dword ptr [rcx+24h] }
    else
      __asm { vmovss  xmm0, dword ptr [rcx+18h] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_12:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_EquipWeapon
==============
*/
char BG_EquipWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *r_weapon)
{
  int FreeEquipSlot; 
  __int64 v7; 
  const char *WeaponName; 
  int v9; 
  __int64 v10; 
  const Weapon *Weapon; 
  const char *v12; 
  __int64 v14; 
  int AmmoNotInClip; 
  int v16; 
  ComGameModeApplication *ActiveApplication; 
  __int64 v18; 
  __int64 v19; 
  char output[1024]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6905, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6906, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  FreeEquipSlot = BG_GetFreeEquipSlot(weaponMap, ps);
  v7 = FreeEquipSlot;
  if ( FreeEquipSlot >= 0 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6872, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6873, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( (unsigned int)v7 >= 0xF )
    {
      LODWORD(v18) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6846, ASSERT_TYPE_ASSERT, "(unsigned)( equipIndex ) < (unsigned)( 15 )", "equipIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v18, 15) )
        __debugbreak();
    }
    v14 = v7;
    *(_QWORD *)&ps->weapEquippedData[v14].usedBefore = 0i64;
    *(_QWORD *)&ps->weapEquippedData[v14].thermalEnabled = 0i64;
    BG_SetEquippedWeaponForPlayer(weaponMap, ps, v7, r_weapon);
    AmmoNotInClip = BG_GetAmmoNotInClip(ps, r_weapon, 0);
    BG_SetGlobalAmmo(ps, r_weapon, 0, AmmoNotInClip);
    if ( BG_HasUnderbarrelAmmo(r_weapon) )
    {
      v16 = BG_GetAmmoNotInClip(ps, r_weapon, 1);
      BG_SetGlobalAmmo(ps, r_weapon, 1, v16);
    }
    if ( BG_IsRiotShield(r_weapon, 0) )
    {
      ActiveApplication = ComGameModeApplication::GetActiveApplication();
      ActiveApplication->EquipWeaponRiotShield(ActiveApplication, r_weapon, ps->clientNum);
    }
    return 1;
  }
  else
  {
    WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
    Com_PrintError(16, "No free weapon slots to add weapon (%s)\n", WeaponName);
    v9 = 0;
    v10 = 0i64;
    do
    {
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (unsigned int)v9 >= 0xF )
      {
        LODWORD(v19) = 15;
        LODWORD(v18) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v18, v19) )
          __debugbreak();
      }
      Weapon = BgWeaponMap::GetWeapon(weaponMap, ps->weaponsEquipped[v10]);
      ++v9;
      v12 = BG_GetWeaponName(Weapon, output, 0x400u);
      Com_PrintError(16, "Weapon %i: %s\n", (unsigned int)v9, v12);
      ++v10;
    }
    while ( v9 < 15 );
    return 0;
  }
}

/*
==============
BG_ExplosionForceRadius
==============
*/
__int64 BG_ExplosionForceRadius(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iExplosionForceRadius; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iExplosionForceRadius = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iExplosionForceRadius;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iExplosionForceRadius;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16774, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iExplosionForceRadius;
  }
  return (unsigned int)projectile->explosionForceRadius;
}

/*
==============
BG_ExplosionForceScalar
==============
*/
float BG_ExplosionForceScalar(const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm { vmovss  xmm0, dword ptr [rax+6F8h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_ExplosionRadius
==============
*/
__int64 BG_ExplosionRadius(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  unsigned int v5; 
  unsigned int WeaponAttachments_Internal; 
  bool v7; 
  WeaponAttachment *v8; 
  unsigned int iExplosionSteppedRadiusOuter; 
  AttProjectile *projectile; 
  AttProjectile *v12; 
  WeaponAttachment *attachments; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v7 = BG_ExplosionUsesSteppedDamage(r_weapon, isAlternate);
  v8 = attachments;
  if ( v7 )
  {
    iExplosionSteppedRadiusOuter = v4->iExplosionSteppedRadiusOuter;
    if ( WeaponAttachments_Internal )
    {
      while ( 1 )
      {
        if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16732, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        projectile = v8->projectile;
        if ( projectile )
          break;
        ++v5;
        ++v8;
        if ( v5 >= WeaponAttachments_Internal )
          return iExplosionSteppedRadiusOuter;
      }
      return (unsigned int)projectile->iExplosionSteppedRadiusOuter;
    }
    return iExplosionSteppedRadiusOuter;
  }
  iExplosionSteppedRadiusOuter = v4->iExplosionRadius;
  if ( !WeaponAttachments_Internal )
    return iExplosionSteppedRadiusOuter;
  while ( 1 )
  {
    if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16748, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    v12 = v8->projectile;
    if ( v12 )
      break;
    ++v5;
    ++v8;
    if ( v5 >= WeaponAttachments_Internal )
      return iExplosionSteppedRadiusOuter;
  }
  return (unsigned int)v12->explosionRadius;
}

/*
==============
BG_ExplosionReactiveEmitterDelay
==============
*/
float BG_ExplosionReactiveEmitterDelay(const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm { vmovss  xmm0, dword ptr [rax+12E8h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_ExplosionUsesSteppedDamage
==============
*/
_BOOL8 BG_ExplosionUsesSteppedDamage(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  unsigned int v5; 
  unsigned int WeaponAttachments_Internal; 
  bool useSteppedExplosionDamage; 
  unsigned int v8; 
  WeaponAttachment *v9; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  useSteppedExplosionDamage = v4->useSteppedExplosionDamage;
  v8 = WeaponAttachments_Internal;
  v9 = attachments;
  if ( !WeaponAttachments_Internal )
    return useSteppedExplosionDamage;
  while ( 1 )
  {
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16818, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    projectile = v9->projectile;
    if ( projectile )
      break;
    ++v5;
    ++v9;
    if ( v5 >= v8 )
      return useSteppedExplosionDamage;
  }
  return projectile->useSteppedExplosionDamage;
}

/*
==============
BG_FindGlobalAmmoSlot
==============
*/
GlobalAmmo *BG_FindGlobalAmmoSlot(playerState_s *ps)
{
  int i; 

  for ( i = 0; i < 15; ++i )
  {
    if ( !BG_IsValidAmmo(&ps->weapCommon.ammoNotInClip[i].ammoType) )
      return &ps->weapCommon.ammoNotInClip[i];
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6790, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "All global ammo slots filled!\n") )
    __debugbreak();
  return ps->weapCommon.ammoNotInClip;
}

/*
==============
BG_FireRumble
==============
*/
RumbleInfo *BG_FireRumble(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  RumbleInfo *fireRumble; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttRumbles *rumbles; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  fireRumble = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fireRumble;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return fireRumble;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16375, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    rumbles = (*i)->rumbles;
    if ( rumbles )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return fireRumble;
  }
  return rumbles->fireRumble;
}

/*
==============
BG_FireSound
==============
*/
const SndAliasList *BG_FireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  _BOOL8 v3; 
  const WeaponSFXPackage *SfxPackage; 

  v3 = isPlayer;
  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 8 * v3 + 96);
}

/*
==============
BG_FirstRaiseTime
==============
*/
__int64 BG_FirstRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 2i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetADSAccel
==============
*/
void BG_GetADSAccel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsOutToInAccelSec, float *outAdsInToOutAccelSec)
{
  const WeaponDef *v13; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v15; 
  char v17; 
  char v18; 

  _R14 = outAdsOutToInAccelSec;
  if ( !outAdsOutToInAccelSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12672, ASSERT_TYPE_ASSERT, "(outAdsOutToInAccelSec)", (const char *)&queryFormat, "outAdsOutToInAccelSec") )
    __debugbreak();
  _RDI = outAdsInToOutAccelSec;
  if ( !outAdsInToOutAccelSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12673, ASSERT_TYPE_ASSERT, "(outAdsInToOutAccelSec)", (const char *)&queryFormat, "outAdsInToOutAccelSec") )
    __debugbreak();
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12677, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v13 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *_R14 = v13->adsAccelSec[0];
  *_RDI = v13->adsAccelSec[1];
  v15 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v15, 0) )
  {
    BG_GetADSTransTimes(weaponMap, ps, r_weapon, isAlternate, (float *)&outAdsOutToInAccelSec, (float *)&outAdsInToOutAccelSec);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+58h+outAdsOutToInAccelSec]
      vmovss  xmm3, dword ptr [r12+1Ch]
      vaddss  xmm1, xmm0, dword ptr [rsp+58h+outAdsInToOutAccelSec]
      vmulss  xmm2, xmm1, cs:__real@447a0000
      vxorps  xmm4, xmm4, xmm4
      vcomiss xmm3, xmm4
    }
    if ( !(v17 | v18) )
    {
      __asm
      {
        vdivss  xmm0, xmm2, xmm3
        vmovss  dword ptr [r14], xmm0
      }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [r12+18h]
      vcomiss xmm0, xmm4
    }
    if ( !(v17 | v18) )
    {
      __asm
      {
        vdivss  xmm0, xmm2, xmm0
        vmovss  dword ptr [rdi], xmm0
      }
    }
  }
  *(float *)&_XMM0 = BG_GetAdsSettingsScale(r_weapon, isAlternate, v15, 0);
  __asm
  {
    vmulss  xmm2, xmm0, xmm0
    vmulss  xmm1, xmm2, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm1
    vmulss  xmm0, xmm2, dword ptr [r14]
    vmovss  dword ptr [r14], xmm0
  }
}

/*
==============
BG_GetADSCrosshairBlendFracs
==============
*/
void BG_GetADSCrosshairBlendFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool adsIn, float *outBlendStart, float *outBlendEnd)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v18; 

  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12748, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12750, ASSERT_TYPE_ASSERT, "(!BG_IsNullWeapon( r_weapon ))", (const char *)&queryFormat, "!BG_IsNullWeapon( r_weapon )") )
    __debugbreak();
  _RBX = outBlendStart;
  if ( !outBlendStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12751, ASSERT_TYPE_ASSERT, "(outBlendStart)", (const char *)&queryFormat, "outBlendStart") )
    __debugbreak();
  _RDI = outBlendEnd;
  if ( !outBlendEnd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12752, ASSERT_TYPE_ASSERT, "(outBlendEnd)", (const char *)&queryFormat, "outBlendEnd") )
    __debugbreak();
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RDX = _RAX;
  if ( adsIn )
  {
    *outBlendStart = _RAX->adsInCrosshairAlphaStart;
    __asm { vmovss  xmm0, dword ptr [rax+7E0h] }
  }
  else
  {
    *outBlendStart = _RAX->adsOutCrosshairAlphaStart;
    __asm { vmovss  xmm0, dword ptr [rdx+7E8h] }
  }
  __asm { vmovss  dword ptr [rdi], xmm0 }
  v18 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v18, 0) )
  {
    __asm { vxorps  xmm1, xmm1, xmm1 }
    if ( adsIn )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rax+24h]
        vcomiss xmm0, xmm1
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm0, dword ptr [rax+28h]
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2Ch]
        vcomiss xmm0, xmm1
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm0, dword ptr [rax+30h]
      }
    }
    __asm
    {
      vcomiss xmm0, xmm1
      vmovss  dword ptr [rdi], xmm0
    }
  }
}

/*
==============
BG_GetADSDamageRangeScale
==============
*/
float BG_GetADSDamageRangeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13660, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovss  xmm6, dword ptr [rbp+674h] }
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v12, 0) )
    __asm { vmovss  xmm6, dword ptr [rax+0B4h] }
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vxorps  xmm0, xmm0, xmm0
    vcmpeqss xmm2, xmm6, xmm0
    vblendvps xmm0, xmm6, xmm1, xmm2
    vmovaps xmm6, [rsp+58h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSFireRateScale
==============
*/
float BG_GetADSFireRateScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13633, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovss  xmm6, dword ptr [rbp+670h] }
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v12, 0) )
    __asm { vmovss  xmm6, dword ptr [rax+0B0h] }
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vxorps  xmm0, xmm0, xmm0
    vcmpeqss xmm2, xmm6, xmm0
    vblendvps xmm0, xmm6, xmm1, xmm2
    vmovaps xmm6, [rsp+58h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSGunBobBulletDirScale
==============
*/
float BG_GetADSGunBobBulletDirScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v16; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v22; 
  __int64 i; 
  bool v25; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v43; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13582, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm { vmovss  xmm9, dword ptr [rax+4C0h] }
  v16 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( BG_GetWeaponAdsGunBobSettings(r_weapon, isAlternate, v16, 0) )
    __asm { vmovss  xmm9, dword ptr [rax+14h] }
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)6, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vxorps  xmm8, xmm8, xmm8 }
  if ( WeaponAttachments_Internal )
  {
    v22 = attachments;
    for ( i = WeaponAttachments_Internal; i; --i )
    {
      _RBX = *v22;
      if ( !*v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13601, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( BG_AttachmentUseMainSettings(_RBX, isAlternate, v16) )
      {
        v25 = _RBX->adsGunBobSettingsMain == NULL;
        if ( !_RBX->adsGunBobSettingsMain )
        {
          __asm { vmovss  xmm0, dword ptr [rbx+36Ch] }
          goto LABEL_22;
        }
      }
      else
      {
        v25 = _RBX->adsGunBobSettings == NULL;
        if ( !_RBX->adsGunBobSettings )
        {
          __asm { vmovss  xmm0, dword ptr [rbx+368h] }
LABEL_22:
          __asm { vucomiss xmm0, xmm8 }
          if ( !v25 )
          {
            __asm
            {
              vaddss  xmm0, xmm6, xmm0
              vsubss  xmm6, xmm0, xmm7
            }
          }
        }
      }
      ++v22;
    }
  }
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm9, xmm0
  }
  _R11 = &v43;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSGunBobSettings
==============
*/
void BG_GetADSGunBobSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *adsGunBobPitchScale, float *adsGunBobYawScale, float *adsGunBobTiltPitchScale, float *adsGunBobTiltYawScale, float *adsGunBobTiltRollScale, float *adsGunBobTiltOffset)
{
  bool v18; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v23; 
  const AttADSGunBobSettings *WeaponAdsGunBobSettings; 
  EffectiveStance EffectiveStance; 
  bool v28; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v33; 
  __int64 v34; 
  WeaponAttachment *v35; 
  unsigned int v37; 
  WeaponAttachment **v39; 
  __int64 v40; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v106; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  v18 = isAlternate;
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13498, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v23 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *adsGunBobPitchScale = _RBX->fAdsGunBobPitchScale;
  *adsGunBobYawScale = _RBX->fAdsGunBobYawScale;
  *adsGunBobTiltPitchScale = _RBX->fAdsGunBobTiltPitchScale;
  *adsGunBobTiltYawScale = _RBX->fAdsGunBobTiltYawScale;
  *adsGunBobTiltRollScale = _RBX->fAdsGunBobTiltRollScale;
  *adsGunBobTiltOffset = _RBX->fAdsGunBobTiltOffset;
  WeaponAdsGunBobSettings = BG_GetWeaponAdsGunBobSettings(r_weapon, v18, v23, 0);
  if ( WeaponAdsGunBobSettings )
  {
    *adsGunBobPitchScale = WeaponAdsGunBobSettings->fAdsGunBobPitchScale;
    *adsGunBobYawScale = WeaponAdsGunBobSettings->fAdsGunBobYawScale;
    *adsGunBobTiltPitchScale = WeaponAdsGunBobSettings->fAdsGunBobTiltPitchScale;
    *adsGunBobTiltYawScale = WeaponAdsGunBobSettings->fAdsGunBobTiltYawScale;
    *adsGunBobTiltRollScale = WeaponAdsGunBobSettings->fAdsGunBobTiltRollScale;
    *adsGunBobTiltOffset = WeaponAdsGunBobSettings->fAdsGunBobTiltOffset;
  }
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vmovaps xmm7, xmm8
  }
  EffectiveStance = PM_GetEffectiveStance(ps);
  v28 = EffectiveStance == PM_EFF_STANCE_DUCKED;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
    __asm { vmovss  xmm7, dword ptr [rbx+4C8h] }
  __asm
  {
    vmovaps xmm10, xmm8
    vmovaps xmm11, xmm8
    vmovaps xmm6, xmm8
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v18, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v33 = attachments;
    v34 = WeaponAttachments_Internal;
    do
    {
      v35 = *v33;
      if ( !*v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13545, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( v28 && v35->adsStanceScales )
      {
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rax+10h]
          vsubss  xmm6, xmm0, xmm8
        }
      }
      ++v33;
      --v34;
    }
    while ( v34 );
    v18 = isAlternate;
  }
  v37 = BG_GetWeaponAttachments_Internal(r_weapon, v18, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)5, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vxorps  xmm9, xmm9, xmm9 }
  if ( v37 )
  {
    v39 = attachments;
    v40 = v37;
    do
    {
      _RBX = *v39;
      if ( !*v39 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13556, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm
      {
        vmovss  [rsp+248h+var_1F0], xmm8
        vmovss  [rsp+248h+var_1F8], xmm8
      }
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13447, ASSERT_TYPE_ASSERT, "( attachment ) != ( nullptr )", "%s != %s\n\t%p, %p", "attachment", "nullptr", NULL, NULL) )
        __debugbreak();
      __asm
      {
        vmovss  [rsp+248h+var_1F0], xmm8
        vmovss  [rsp+248h+var_1F8], xmm8
      }
      if ( BG_AttachmentUseMainSettings(_RBX, v18, v23) )
      {
        if ( !_RBX->adsGunBobSettingsMain )
        {
          __asm
          {
            vmovss  xmm2, dword ptr [rbx+35Ch]
            vmovss  xmm0, [rsp+248h+var_1F0]
            vcmpltss xmm1, xmm9, xmm2
            vblendvps xmm1, xmm0, xmm2, xmm1
            vmovss  [rsp+248h+var_1F0], xmm1
            vmovss  xmm3, dword ptr [rbx+364h]
            vcomiss xmm3, xmm9
          }
          if ( _RBX->adsGunBobSettingsMain )
            __asm { vmovss  [rsp+248h+var_1F8], xmm3 }
        }
      }
      else if ( !_RBX->adsGunBobSettings )
      {
        __asm
        {
          vmovss  xmm2, dword ptr [rbx+358h]
          vmovss  xmm0, [rsp+248h+var_1F0]
          vcmpltss xmm1, xmm9, xmm2
          vblendvps xmm1, xmm0, xmm2, xmm1
          vmovss  xmm0, [rsp+248h+var_1F8]
          vmovss  [rsp+248h+var_1F0], xmm1
          vmovss  xmm3, dword ptr [rbx+360h]
          vcmpltss xmm1, xmm9, xmm3
          vblendvps xmm1, xmm0, xmm3, xmm1
          vmovss  [rsp+248h+var_1F8], xmm1
        }
      }
      __asm
      {
        vmovss  xmm0, [rsp+248h+var_1F0]
        vmovss  xmm2, [rsp+248h+var_1F8]
        vsubss  xmm1, xmm0, xmm8
      }
      ++v39;
      __asm
      {
        vsubss  xmm0, xmm2, xmm8
        vaddss  xmm11, xmm11, xmm0
        vaddss  xmm10, xmm10, xmm1
      }
      --v40;
    }
    while ( v40 );
  }
  __asm { vmovss  xmm4, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff }
  _RAX = adsGunBobPitchScale;
  __asm
  {
    vmaxss  xmm2, xmm6, xmm9
    vmovsd  xmm6, cs:__real@3eb0c6f7a0b5ed8d
    vsubss  xmm0, xmm8, xmm2
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm1, xmm2, xmm8, xmm0
    vmulss  xmm7, xmm7, xmm1
    vmaxss  xmm3, xmm10, xmm9
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm5, xmm3, xmm8, xmm2
    vmaxss  xmm3, xmm11, xmm9
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vmulss  xmm1, xmm5, xmm7
    vmulss  xmm0, xmm1, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = adsGunBobYawScale;
  __asm
  {
    vblendvps xmm4, xmm3, xmm8, xmm2
    vmulss  xmm2, xmm4, xmm7
    vmulss  xmm1, xmm1, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = adsGunBobTiltPitchScale;
  __asm
  {
    vmulss  xmm0, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = adsGunBobTiltYawScale;
  __asm
  {
    vmulss  xmm1, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = adsGunBobTiltRollScale;
  __asm
  {
    vmulss  xmm0, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _R11 = &v106;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
BG_GetADSHandheldCamScale
==============
*/
void BG_GetADSHandheldCamScale(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, bool isAlternate, float *outAdsRotationScale, float *outAdsTranslationScale)
{
  const WeaponDef *v18; 
  __int64 WeaponAttachments_Internal; 
  char v22; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  unsigned int v26; 
  WeaponAttachment **v27; 
  AttPost *post; 
  WeaponAttachment **v35; 
  __int64 v36; 
  bool v41; 
  bool v47; 
  bool v49; 
  bool v58; 
  const WeaponAttachment *v77; 
  WeaponAttachment *outDataAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v83; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
  }
  _R13 = NULL;
  if ( !outAdsRotationScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19951, ASSERT_TYPE_ASSERT, "( outAdsRotationScale ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAdsRotationScale", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAdsTranslationScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19952, ASSERT_TYPE_ASSERT, "( outAdsTranslationScale ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAdsTranslationScale", "nullptr", NULL, NULL) )
    __debugbreak();
  v18 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19955, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  *outAdsRotationScale = v18->adsCameraShakeRotationScale;
  *outAdsTranslationScale = v18->adsCameraShakeTranslationScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  _RAX = hybridScopeFraction;
  __asm { vxorps  xmm8, xmm8, xmm8 }
  outDataAttachment = NULL;
  v77 = NULL;
  __asm { vcomiss xmm8, dword ptr [rax] }
  if ( v22 && BG_CanHybridToggle(ps, weapon, isAlternate) )
  {
    HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(weapon, isAlternate, (const WeaponAttachment **)&outDataAttachment);
    _R13 = outDataAttachment;
    v77 = HybridScopeEnablerAttachment;
  }
  __asm
  {
    vmovss  xmm11, cs:__real@3f000000
    vmovss  xmm12, cs:__real@40490fdb
  }
  v26 = 0;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v27 = attachments;
    while ( 1 )
    {
      if ( !*v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19972, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      post = (*v27)->post;
      if ( post )
        break;
      ++v26;
      ++v27;
      if ( v26 >= (unsigned int)WeaponAttachments_Internal )
      {
        _R15 = outAdsRotationScale;
        goto LABEL_23;
      }
    }
    _RAX = hybridScopeFraction;
    __asm { vcomiss xmm8, dword ptr [rax] }
    _R15 = outAdsRotationScale;
    _R14 = outAdsTranslationScale;
    *outAdsRotationScale = post->adsCameraShakeRotationScale;
    *outAdsTranslationScale = post->adsCameraShakeTranslationScale;
  }
  else
  {
    _R15 = outAdsRotationScale;
LABEL_23:
    _R14 = outAdsTranslationScale;
  }
  _R12 = hybridScopeFraction;
  __asm
  {
    vmovss  xmm9, cs:__real@3f800000
    vmovaps xmm10, xmm9
  }
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    __asm { vmovaps [rsp+248h+var_48], xmm6 }
    v35 = attachments;
    v36 = WeaponAttachments_Internal;
    __asm { vmovaps [rsp+248h+var_58], xmm7 }
    _ER14 = 0;
    do
    {
      _RBX = *v35;
      if ( !*v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20006, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm
      {
        vmovss  xmm7, dword ptr [rbx+350h]
        vmovss  xmm6, dword ptr [rbx+354h]
      }
      v41 = v77 == NULL;
      if ( v77 )
      {
        v41 = v77 <= _RBX;
        if ( v77 == _RBX )
        {
          v41 = _R13 == NULL;
          if ( _R13 )
          {
            __asm
            {
              vmovss  xmm0, dword ptr [r12]
              vsubss  xmm1, xmm0, xmm11
              vmulss  xmm0, xmm1, xmm12; X
            }
            *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
            __asm
            {
              vmovss  xmm3, dword ptr [r13+350h]
              vcomiss xmm7, xmm8
              vmulss  xmm4, xmm0, xmm11
            }
            v47 = !(v22 | v49);
            __asm
            {
              vcomiss xmm3, xmm8
              vaddss  xmm5, xmm4, xmm11
            }
            v49 = !v47;
            if ( v47 )
            {
              v49 = !v47;
              __asm
              {
                vsubss  xmm0, xmm11, xmm4
                vmulss  xmm2, xmm0, xmm7
                vmulss  xmm1, xmm3, xmm5
                vaddss  xmm7, xmm2, xmm1
              }
            }
            else
            {
              _EAX = 0;
              __asm
              {
                vmovd   xmm0, eax
                vmovd   xmm1, r14d
                vpcmpeqd xmm2, xmm0, xmm1
                vblendvps xmm7, xmm3, xmm8, xmm2
              }
            }
            __asm
            {
              vmovss  xmm3, dword ptr [r13+354h]
              vcomiss xmm6, xmm8
              vcomiss xmm3, xmm8
            }
            v58 = !v49;
            v41 = v49;
            if ( v49 )
            {
              _EAX = v58;
              __asm
              {
                vmovd   xmm0, eax
                vmovd   xmm1, r14d
                vpcmpeqd xmm2, xmm0, xmm1
                vblendvps xmm6, xmm3, xmm8, xmm2
              }
            }
            else
            {
              v41 = !v58;
              __asm
              {
                vsubss  xmm0, xmm11, xmm4
                vmulss  xmm2, xmm0, xmm6
                vmulss  xmm1, xmm3, xmm5
                vaddss  xmm6, xmm2, xmm1
              }
            }
          }
        }
      }
      __asm { vcomiss xmm7, xmm8 }
      if ( !v41 )
        __asm { vmulss  xmm9, xmm9, xmm7 }
      __asm { vcomiss xmm6, xmm8 }
      if ( !v41 )
        __asm { vmulss  xmm10, xmm10, xmm6 }
      ++v35;
      --v36;
    }
    while ( v36 );
    _R14 = outAdsTranslationScale;
    _R15 = outAdsRotationScale;
    __asm
    {
      vmovaps xmm7, [rsp+248h+var_58]
      vmovaps xmm6, [rsp+248h+var_48]
    }
  }
  __asm
  {
    vmulss  xmm0, xmm9, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vmulss  xmm1, xmm10, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
  }
  _R11 = &v83;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
}

/*
==============
BG_GetADSIdleLerpTime
==============
*/
void BG_GetADSIdleLerpTime(const Weapon *r_weapon, bool isAlternate, float *adsIdleLerpStartTime, float *adsIdleLerpTime)
{
  const WeaponDef *v12; 
  unsigned int v14; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v18; 
  __int64 v19; 
  WeaponAttachment **v29; 
  WeaponAttachment *v30; 
  AttIdleSettings *idleSettings; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v40; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _R14 = adsIdleLerpTime;
  _R15 = adsIdleLerpStartTime;
  if ( !adsIdleLerpStartTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12247, ASSERT_TYPE_ASSERT, "(adsIdleLerpStartTime)", (const char *)&queryFormat, "adsIdleLerpStartTime") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12248, ASSERT_TYPE_ASSERT, "(adsIdleLerpTime)", (const char *)&queryFormat, "adsIdleLerpTime") )
    __debugbreak();
  v12 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm { vmovss  xmm7, cs:__real@3f800000 }
  v14 = 0;
  *_R15 = v12->adsIdleLerpStartTime;
  *_R14 = v12->adsIdleLerpTime;
  __asm { vmovaps xmm6, xmm7 }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vxorps  xmm8, xmm8, xmm8 }
  if ( WeaponAttachments_Internal )
  {
    v18 = attachments;
    v19 = WeaponAttachments_Internal;
    do
    {
      if ( !*v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12258, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RAX = *v18;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2D4h]
        vcomiss xmm0, xmm8
        vaddss  xmm0, xmm6, xmm0
        vsubss  xmm6, xmm0, xmm7
      }
      ++v18;
      --v19;
    }
    while ( v19 );
  }
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm3, xmm7, xmm2
  }
  if ( WeaponAttachments_Internal )
  {
    v29 = attachments;
    while ( 1 )
    {
      if ( !*v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12268, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v30 = *v29;
      idleSettings = (*v29)->idleSettings;
      if ( idleSettings )
        break;
      ++v14;
      ++v29;
      if ( v14 >= WeaponAttachments_Internal )
        goto LABEL_24;
    }
    *_R15 = idleSettings->adsIdleLerpStartTime;
    *_R14 = v30->idleSettings->adsIdleLerpTime;
  }
LABEL_24:
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vmulss  xmm1, xmm6, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
  }
  _R11 = &v40;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
BG_GetADSNVGFOV
==============
*/
float BG_GetADSNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  _RAX = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( getWeaponValues )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax+194h]
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rax+174h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSNVGFOVXOffset
==============
*/
float BG_GetADSNVGFOVXOffset(const Weapon *r_weapon, const bool isAlternate)
{
  _RAX = BG_WeaponCompleteDef(r_weapon, isAlternate);
  __asm { vmovss  xmm0, dword ptr [rax+198h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSReloadNVGFOV
==============
*/
float BG_GetADSReloadNVGFOV(const Weapon *r_weapon, const bool isAlternate, const bool getWeaponValues)
{
  _RAX = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( getWeaponValues )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax+19Ch]
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rax+178h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSSwayScalars
==============
*/
void BG_GetADSSwayScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsSwayMaxAngleScale, float *outAdsSwayLerpSpeedScale, float *outAdsSwayScaleScale)
{
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v23; 
  __int64 v24; 
  WeaponAttachment **v25; 
  bool v28; 
  bool v29; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v62; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovss  xmm10, cs:__real@3f800000
    vmovaps xmm8, xmm10
    vmovaps xmm9, xmm10
    vmovaps xmm7, xmm10
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v23 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v24 = WeaponAttachments_Internal;
    v25 = attachments;
    __asm
    {
      vmovaps [rsp+208h+var_48], xmm6
      vxorps  xmm6, xmm6, xmm6
    }
    do
    {
      _RBX = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v25, v23);
      v28 = _RBX == NULL;
      if ( !_RBX )
      {
        v29 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19925, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v28 = !v29;
        if ( v29 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+320h]
        vcomiss xmm0, xmm6
      }
      if ( !v28 )
        __asm { vmulss  xmm8, xmm8, xmm0 }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+324h]
        vcomiss xmm0, xmm6
      }
      if ( !v28 )
        __asm { vmulss  xmm9, xmm9, xmm0 }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+328h]
        vcomiss xmm0, xmm6
      }
      if ( !v28 )
        __asm { vmulss  xmm7, xmm7, xmm0 }
      ++v25;
      --v24;
    }
    while ( v24 );
    __asm { vmovaps xmm6, [rsp+208h+var_48] }
  }
  __asm
  {
    vmovss  xmm3, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovsd  xmm4, cs:__real@3eb0c6f7a0b5ed8d
  }
  _RAX = outAdsSwayMaxAngleScale;
  __asm
  {
    vsubss  xmm0, xmm10, xmm8
    vandps  xmm0, xmm0, xmm3
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, xmm4
    vblendvps xmm1, xmm8, xmm10, xmm0
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = outAdsSwayLerpSpeedScale;
  __asm
  {
    vsubss  xmm0, xmm10, xmm9
    vandps  xmm0, xmm0, xmm3
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm4
    vblendvps xmm0, xmm9, xmm10, xmm2
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = outAdsSwayScaleScale;
  __asm
  {
    vsubss  xmm0, xmm10, xmm7
    vandps  xmm0, xmm0, xmm3
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm4
    vblendvps xmm0, xmm7, xmm10, xmm2
    vmovss  dword ptr [rax], xmm0
  }
  _R11 = &v62;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
  }
}

/*
==============
BG_GetADSTransTimes
==============
*/
void BG_GetADSTransTimes(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outAdsTransInSpeedMs, float *outAdsTransOutSpeedMs)
{
  const WeaponDef *v15; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v17; 

  _RBX = outAdsTransInSpeedMs;
  __asm { vmovaps [rsp+68h+var_28], xmm6 }
  if ( !outAdsTransInSpeedMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12632, ASSERT_TYPE_ASSERT, "(outAdsTransInSpeedMs)", (const char *)&queryFormat, "outAdsTransInSpeedMs") )
    __debugbreak();
  _RSI = outAdsTransOutSpeedMs;
  if ( !outAdsTransOutSpeedMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12633, ASSERT_TYPE_ASSERT, "(outAdsTransOutSpeedMs)", (const char *)&queryFormat, "outAdsTransOutSpeedMs") )
    __debugbreak();
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12637, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  v15 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outAdsTransInSpeedMs = v15->adsSpeedMs[0];
  *outAdsTransOutSpeedMs = v15->adsSpeedMs[1];
  v17 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *(float *)&_XMM0 = BG_GetAdsSettingsScale(r_weapon, isAlternate, v17, 0);
  __asm { vmovaps xmm6, xmm0 }
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v17, 0) )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rax+10h]
      vmovss  xmm2, cs:__real@3a83126f
      vxorps  xmm3, xmm3, xmm3
      vcomiss xmm1, xmm3
      vdivss  xmm0, xmm2, xmm1
      vmovss  dword ptr [rbx], xmm0
      vmovss  xmm0, dword ptr [rax+14h]
      vcomiss xmm0, xmm3
      vdivss  xmm0, xmm2, xmm0
      vmovss  dword ptr [rsi], xmm0
    }
  }
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vmulss  xmm1, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm1
  }
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x2Du) )
  {
    _RDI = DCONST_DVARFLT_sprintAdsSpeedScale;
    if ( !DCONST_DVARFLT_sprintAdsSpeedScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sprintAdsSpeedScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm1, xmm0, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm1
    }
  }
  __asm { vmovaps xmm6, [rsp+68h+var_28] }
}

/*
==============
BG_GetADSViewBobSettingsScale
==============
*/
float BG_GetADSViewBobSettingsScale(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  __int64 v9; 
  bool v11; 
  bool v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v19[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-28h], xmm6
    vmovss  xmm6, cs:__real@3f800000
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v19, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    __asm
    {
      vmovaps [rsp+198h+var_38], xmm7
      vxorps  xmm7, xmm7, xmm7
    }
    v9 = WeaponAttachments_Internal;
    do
    {
      _RDI = *v7;
      v11 = *v7 == NULL;
      if ( !*v7 )
      {
        v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13406, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v11 = !v12;
        if ( v12 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm1, dword ptr [rdi+370h]
        vcomiss xmm1, xmm7
      }
      if ( !v11 )
        __asm { vmulss  xmm6, xmm6, xmm1 }
      ++v7;
      --v9;
    }
    while ( v9 );
    __asm { vmovaps xmm7, [rsp+198h+var_38] }
  }
  __asm
  {
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+198h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSZoomInFracs
==============
*/
void BG_GetADSZoomInFracs(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const bool getWeaponValues, float *adsZoomInFrac, float *adsZoomOutFrac)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v16; 

  _RBX = adsZoomInFrac;
  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  if ( !adsZoomInFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13298, ASSERT_TYPE_ASSERT, "(adsZoomInFrac)", (const char *)&queryFormat, "adsZoomInFrac") )
    __debugbreak();
  _RDI = adsZoomOutFrac;
  if ( !adsZoomOutFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13299, ASSERT_TYPE_ASSERT, "(adsZoomOutFrac)", (const char *)&queryFormat, "adsZoomOutFrac") )
    __debugbreak();
  if ( ps && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13303, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _R14 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  v16 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *adsZoomInFrac = _R14->zoomSettings.scene.adsZoomInFrac;
  *adsZoomOutFrac = _R14->zoomSettings.scene.adsZoomOutFrac;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( getWeaponValues )
  {
    __asm
    {
      vmovss  xmm2, dword ptr [r14+1A4h]
      vmovss  xmm0, dword ptr [rbx]
      vcmpless xmm1, xmm6, xmm2
      vblendvps xmm1, xmm0, xmm2, xmm1
      vmovss  dword ptr [rbx], xmm1
      vmovss  xmm3, dword ptr [r14+1A8h]
      vmovss  xmm0, dword ptr [rbx]
      vcmpless xmm1, xmm6, xmm3
      vblendvps xmm1, xmm0, xmm3, xmm1
      vmovss  dword ptr [rbx], xmm1
    }
  }
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v16, 0) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax+60h]
      vcomiss xmm0, xmm6
      vmovss  dword ptr [rbx], xmm0
      vmovss  xmm0, dword ptr [rax+64h]
      vcomiss xmm0, xmm6
      vmovss  dword ptr [rdi], xmm0
    }
    if ( getWeaponValues )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rax+98h]
        vcomiss xmm0, xmm6
        vmovss  dword ptr [rbx], xmm0
        vmovss  xmm0, dword ptr [rax+9Ch]
        vcomiss xmm0, xmm6
        vmovss  dword ptr [rdi], xmm0
      }
    }
  }
  __asm { vmovaps xmm6, [rsp+58h+var_28] }
}

/*
==============
BG_GetADSZoomInfo
==============
*/
void BG_GetADSZoomInfo(const BgWeaponMap *weaponMap, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, BgAdsZoomInfo *outZoomInfo)
{
  bool v14; 

  _R14 = outZoomInfo;
  _R11 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  outZoomInfo->zoomCount = _R11->zoomSettings.scene.adsZoomCount;
  __asm
  {
    vmovsd  xmm0, qword ptr [rax+144h]
    vmovsd  qword ptr [r14+10h], xmm0
  }
  outZoomInfo->zoomFov[2] = _R11->zoomSettings.scene.adsZoomFov[2];
  __asm
  {
    vmovsd  xmm0, qword ptr [rax+15Ch]
    vmovsd  qword ptr [r14+1Ch], xmm0
  }
  outZoomInfo->zoomFovTransitionTime[2] = _R11->zoomSettings.scene.adsZoomFovTransitionTime[2];
  outZoomInfo->zoomFovXOffset = _R11->zoomSettings.weapon.adsZoomFovXOffset;
  __asm
  {
    vmovsd  xmm0, qword ptr [r11+150h]
    vmovsd  qword ptr [r14+2Ch], xmm0
  }
  outZoomInfo->zoomReloadFov[2] = _R11->zoomSettings.scene.adsReloadFov[2];
  outZoomInfo->depthHackZoomFov = _R11->zoomSettings.weapon.adsZoomFov;
  outZoomInfo->depthHackReloadFov = _R11->zoomSettings.weapon.adsReloadZoomFov;
  outZoomInfo->zoomLerpType = _R11->zoomSettings.scene.adsZoomFovLerpType;
  outZoomInfo->depthHackZoomLerpType = _R11->zoomSettings.weapon.adsZoomFovLerpType;
  BG_GetADSZoomInfo_ApplyAttachmentOverrides(weaponMap, r_weapon, isAlternate, hybridScopeFractionInfo, outZoomInfo);
  v14 = outZoomInfo->zoomCount == 0;
  __asm { vxorps  xmm0, xmm0, xmm0 }
  if ( outZoomInfo->zoomCount <= 1 )
  {
LABEL_4:
    __asm { vcomiss xmm0, dword ptr [r14+4] }
    if ( !v14 )
      return;
    goto LABEL_5;
  }
  __asm { vcomiss xmm0, dword ptr [r14+4] }
  if ( outZoomInfo->zoomCount )
  {
    outZoomInfo->depthHackZoomFov = outZoomInfo->zoomFov[0];
    goto LABEL_4;
  }
LABEL_5:
  __asm { vcomiss xmm0, dword ptr [r14+8] }
  if ( !v14 )
    outZoomInfo->depthHackReloadFov = outZoomInfo->zoomReloadFov[0];
}

/*
==============
BG_GetADSZoomInfo_ApplyAttachmentOverrides
==============
*/
void BG_GetADSZoomInfo_ApplyAttachmentOverrides(const BgWeaponMap *weaponMap, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, BgAdsZoomInfo *outZoomInfo)
{
  const AttADSSettings *WeaponAdsSettings; 
  bool v16; 
  bool v79; 
  int adsZoomCount; 
  int v89; 
  bool v91; 
  BgHybridScopeInfo outHybridScopeInfo; 

  _R14 = hybridScopeFractionInfo;
  _RBX = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 0, 0);
  if ( _RBX )
  {
    WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 1, 0);
    _RDI = WeaponAdsSettings;
    v16 = WeaponAdsSettings == NULL;
    if ( !WeaponAdsSettings || (v16 = WeaponAdsSettings <= _RBX, WeaponAdsSettings == _RBX) )
    {
      __asm { vmovss  xmm0, dword ptr [rbx+74h] }
      _R9 = outZoomInfo;
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcomiss xmm0, xmm1
      }
      if ( !v16 )
        __asm { vmovss  dword ptr [r9+4], xmm0 }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+80h]
        vcomiss xmm0, xmm1
      }
      if ( !v16 )
        __asm { vmovss  dword ptr [r9+8], xmm0 }
      adsZoomCount = _RBX->zoomSettings.scene.adsZoomCount;
      v89 = 0;
      if ( adsZoomCount > 0 )
      {
        _RCX = outZoomInfo->zoomFov;
        v91 = _RBX < (const AttADSSettings *)outZoomInfo;
        _RDX = (char *)_RBX - (char *)outZoomInfo;
        do
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rdx+rcx+28h]
            vcomiss xmm0, xmm1
          }
          if ( !v91 )
            __asm { vmovss  dword ptr [rcx], xmm0 }
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
            vcomiss xmm0, xmm1
          }
          if ( !v91 )
            _RCX[3] = *(float *)((char *)_RCX + _RDX + 64);
          if ( _RBX->zoomSettings.weapon.adsZoomFovXOffsetOverride )
            outZoomInfo->zoomFovXOffset = _RBX->zoomSettings.weapon.adsZoomFovXOffset;
          __asm
          {
            vmovss  xmm0, dword ptr [rdx+rcx+34h]
            vcomiss xmm0, xmm1
            vmovss  dword ptr [rcx+1Ch], xmm0
          }
          adsZoomCount = _RBX->zoomSettings.scene.adsZoomCount;
          ++v89;
          ++_RCX;
          v91 = v89 < (unsigned int)adsZoomCount;
        }
        while ( v89 < adsZoomCount );
      }
      outZoomInfo->zoomCount = adsZoomCount;
      outZoomInfo->zoomLerpType = _RBX->zoomSettings.scene.adsZoomFovLerpType;
      outZoomInfo->depthHackZoomLerpType = _RBX->zoomSettings.weapon.adsZoomFovLerpType;
    }
    else
    {
      __asm
      {
        vmovaps [rsp+0B8h+var_18], xmm6
        vmovaps [rsp+0B8h+var_28], xmm7
        vmovaps [rsp+0B8h+var_38], xmm8
        vmovaps [rsp+0B8h+var_48], xmm9
      }
      BG_GetHybridScopeInfo(r_weapon, isAlternate, &outHybridScopeInfo);
      if ( !outHybridScopeInfo.hasHybridScope && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13108, ASSERT_TYPE_ASSERT, "(hybridScopeInfo.hasHybridScope)", (const char *)&queryFormat, "hybridScopeInfo.hasHybridScope") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, dword ptr [r14]
        vmovss  xmm8, cs:__real@3f800000
        vxorps  xmm7, xmm7, xmm7
      }
      if ( _R14->increasing )
      {
        __asm
        {
          vsubss  xmm2, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope1To2FovTransBegin]
          vmovss  xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope1To2FovTransEnd]
          vsubss  xmm1, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope1To2FovTransBegin]
          vdivss  xmm0, xmm2, xmm1; val
          vmovaps xmm2, xmm8; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vsubss  xmm0, xmm0, cs:__real@3f000000
          vmulss  xmm0, xmm0, cs:__real@40490fdb; X
        }
        *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
        __asm
        {
          vaddss  xmm1, xmm0, xmm8
          vmulss  xmm4, xmm1, cs:__real@3f000000
        }
      }
      else
      {
        __asm
        {
          vsubss  xmm0, xmm8, xmm0
          vsubss  xmm2, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope2To1FovTransBegin]
          vmovss  xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope2To1FovTransEnd]
          vsubss  xmm1, xmm0, [rsp+0B8h+outHybridScopeInfo.hybridScope2To1FovTransBegin]
          vdivss  xmm0, xmm2, xmm1; val
          vmovaps xmm2, xmm8; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovss  xmm6, cs:__real@3f000000
          vsubss  xmm0, xmm0, xmm6
          vmulss  xmm0, xmm0, cs:__real@40490fdb; X
        }
        *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
        __asm
        {
          vmulss  xmm1, xmm0, xmm6
          vsubss  xmm4, xmm6, xmm1
        }
      }
      _RCX = outZoomInfo;
      __asm { vsubss  xmm8, xmm8, xmm4 }
      outZoomInfo->zoomCount = 1;
      __asm { vmovss  xmm6, dword ptr [rcx+10h] }
      outZoomInfo->zoomFovTransitionTime[0] = 0;
      __asm
      {
        vmovss  xmm1, dword ptr [rdi+38h]
        vmovss  xmm2, dword ptr [rbx+38h]
        vmovss  xmm9, dword ptr [rcx+4]
        vmovss  xmm5, dword ptr [rcx+28h]
        vcmpltss xmm0, xmm7, xmm1
        vblendvps xmm3, xmm6, xmm1, xmm0
        vcmpltss xmm0, xmm7, xmm2
        vblendvps xmm1, xmm6, xmm2, xmm0
        vmulss  xmm0, xmm3, xmm4
        vmulss  xmm1, xmm8, xmm1
        vaddss  xmm1, xmm1, xmm0
        vmovss  dword ptr [rcx+10h], xmm1
        vmovss  xmm2, dword ptr [rbx+74h]
        vcmpltss xmm0, xmm7, xmm2
        vblendvps xmm3, xmm9, xmm2, xmm0
        vcomiss xmm3, xmm7
        vmovss  xmm1, dword ptr [rbx+38h]
        vcmpltss xmm0, xmm7, xmm1
        vblendvps xmm3, xmm6, xmm1, xmm0
        vmovss  xmm1, dword ptr [rdi+74h]
        vcmpltss xmm0, xmm7, xmm1
        vblendvps xmm2, xmm9, xmm1, xmm0
        vcomiss xmm2, xmm7
        vmovaps xmm9, [rsp+0B8h+var_48]
        vmovss  xmm1, dword ptr [rdi+38h]
        vcmpltss xmm0, xmm7, xmm1
        vblendvps xmm2, xmm6, xmm1, xmm0
        vmovaps xmm6, [rsp+0B8h+var_18]
        vmulss  xmm1, xmm8, xmm3
        vmulss  xmm0, xmm2, xmm4
        vaddss  xmm1, xmm1, xmm0
        vmovss  dword ptr [rcx+4], xmm1
      }
      if ( _RBX->zoomSettings.weapon.adsZoomFovXOffsetOverride )
        __asm { vmovss  xmm0, dword ptr [rbx+7Ch] }
      else
        __asm { vmovaps xmm0, xmm5 }
      if ( _RDI->zoomSettings.weapon.adsZoomFovXOffsetOverride )
        __asm { vmovss  xmm5, dword ptr [rdi+7Ch] }
      __asm
      {
        vmulss  xmm1, xmm8, xmm0
        vmovaps xmm8, [rsp+0B8h+var_38]
        vmulss  xmm0, xmm5, xmm4
        vaddss  xmm1, xmm1, xmm0
        vmovss  dword ptr [rcx+28h], xmm1
      }
      v79 = !_R14->increasing;
      if ( _R14->increasing )
      {
        outZoomInfo->zoomLerpType = _RDI->zoomSettings.scene.adsZoomFovLerpType;
        outZoomInfo->depthHackZoomLerpType = _RDI->zoomSettings.weapon.adsZoomFovLerpType;
        __asm
        {
          vmovss  xmm0, dword ptr [rdi+80h]
          vcomiss xmm0, xmm7
        }
        if ( !v79 )
          __asm { vmovss  dword ptr [rcx+8], xmm0 }
        __asm { vmovss  xmm0, dword ptr [rdi+44h] }
      }
      else
      {
        outZoomInfo->zoomLerpType = _RBX->zoomSettings.scene.adsZoomFovLerpType;
        outZoomInfo->depthHackZoomLerpType = _RBX->zoomSettings.weapon.adsZoomFovLerpType;
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+80h]
          vcomiss xmm0, xmm7
        }
        if ( !v79 )
          __asm { vmovss  dword ptr [rcx+8], xmm0 }
        __asm { vmovss  xmm0, dword ptr [rbx+44h] }
      }
      __asm { vcomiss xmm0, xmm7 }
      if ( !v79 )
        __asm { vmovss  dword ptr [rcx+2Ch], xmm0 }
      __asm { vmovaps xmm7, [rsp+0B8h+var_28] }
    }
  }
}

/*
==============
BG_GetADSZoomLevel
==============
*/
__int64 BG_GetADSZoomLevel(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const int zoomCount)
{
  bool v8; 
  bool CanHybridToggle; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  __int64 result; 
  int zoomLevelIndex; 

  v8 = BG_UsingAlternate(ps);
  CanHybridToggle = BG_CanHybridToggle(ps, r_weapon, v8);
  if ( !ps || CanHybridToggle || zoomCount <= 0 )
    return 0i64;
  EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
  if ( !EquippedWeaponStateConst )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12856, ASSERT_TYPE_ASSERT, "(equippedData != nullptr)", (const char *)&queryFormat, "equippedData != nullptr") )
      __debugbreak();
    return 0i64;
  }
  zoomLevelIndex = EquippedWeaponStateConst->zoomLevelIndex;
  result = 0i64;
  if ( zoomLevelIndex < zoomCount )
    return (unsigned int)zoomLevelIndex;
  return result;
}

/*
==============
BG_GetADSZoomLevelFraction
==============
*/
float BG_GetADSZoomLevelFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  char v30; 
  char v31; 
  __int64 v44; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12880, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_ADSZoomCount(weaponMap, ps, weapon, isAlternate) > 1 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon)) != NULL )
  {
    __asm { vmovaps [rsp+108h+var_58], xmm7 }
    memset(&outZoomInfo, 0, sizeof(outZoomInfo));
    hybridScopeFractionInfo = 0i64;
    BG_GetADSZoomInfo(weaponMap, weapon, isAlternate, &hybridScopeFractionInfo, &outZoomInfo);
    if ( EquippedWeaponStateConst->zoomLevelIndex >= 3u )
    {
      LODWORD(v44) = EquippedWeaponStateConst->zoomLevelIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12900, ASSERT_TYPE_ASSERT, "(unsigned)( equippedWeaponState->zoomLevelIndex ) < (unsigned)( 3 )", "equippedWeaponState->zoomLevelIndex doesn't index WEAPON_VZSCOPE_MAXFOVS\n\t%i not in [0, %i)", v44, 3) )
        __debugbreak();
    }
    __asm
    {
      vxorps  xmm7, xmm7, xmm7
      vcvtsi2ss xmm7, xmm7, eax
    }
    if ( outZoomInfo.zoomFovTransitionTime[EquippedWeaponStateConst->zoomLevelIndex] > 0 )
    {
      __asm
      {
        vmovaps [rsp+108h+var_48], xmm6
        vmovaps [rsp+108h+var_68], xmm8
        vmovaps [rsp+108h+var_78], xmm9
      }
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1184, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      __asm
      {
        vmovss  xmm6, cs:__real@40400000
        vmovaps xmm1, xmm6; maxAbsValueSize
      }
      *(double *)&_XMM0 = MSG_UnpackUnsignedFloat(ps->weapCommon.adsZoomLevelFractionOnStateChange, *(float *)&_XMM1, 8u);
      __asm
      {
        vxorps  xmm2, xmm2, xmm2
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm2, xmm2, eax
        vcvtsi2ss xmm1, xmm1, edi
        vmovaps xmm8, xmm0
        vdivss  xmm0, xmm2, xmm1; val
        vmovss  xmm2, cs:__real@3f800000; max
        vxorps  xmm1, xmm1, xmm1; min
        vxorps  xmm9, xmm9, xmm9
      }
      I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vcomiss xmm7, xmm8 }
      if ( v30 | v31 )
      {
        __asm
        {
          vsubss  xmm2, xmm8, xmm7
          vsubss  xmm1, xmm6, xmm2
        }
      }
      else
      {
        __asm
        {
          vsubss  xmm1, xmm7, xmm8
          vsubss  xmm2, xmm6, xmm1
        }
      }
      __asm { vcomiss xmm2, xmm1 }
      if ( v30 )
      {
        __asm
        {
          vmulss  xmm0, xmm2, xmm0
          vsubss  xmm2, xmm8, xmm0
          vaddss  xmm1, xmm2, xmm6
          vcmpltss xmm0, xmm2, xmm9
          vblendvps xmm0, xmm2, xmm1, xmm0
        }
      }
      else
      {
        __asm
        {
          vmulss  xmm0, xmm1, xmm0
          vaddss  xmm0, xmm0, xmm8
          vcomiss xmm0, xmm6
        }
        if ( !(v30 | v31) )
          __asm { vaddss  xmm0, xmm0, cs:__real@c0400000; val }
      }
      __asm
      {
        vmovaps xmm2, xmm6; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovaps xmm9, [rsp+108h+var_78]
        vmovaps xmm8, [rsp+108h+var_68]
        vmovaps xmm6, [rsp+108h+var_48]
      }
    }
    else
    {
      __asm { vmovaps xmm0, xmm7 }
    }
    __asm { vmovaps xmm7, [rsp+108h+var_58] }
  }
  else
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetADSZoomLevelWeights
==============
*/

void __fastcall BG_GetADSZoomLevelWeights(double adsZoomLevelFraction, float *outZoomLevelWeights)
{
  bool v5; 
  int v7; 
  double v19; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  _RBX = outZoomLevelWeights;
  __asm { vmovaps xmm6, xmm0 }
  if ( !outZoomLevelWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12964, ASSERT_TYPE_ASSERT, "(outZoomLevelWeights)", (const char *)&queryFormat, "outZoomLevelWeights") )
    __debugbreak();
  v5 = 1;
  LODWORD(_RAX) = 0;
  *(_QWORD *)_RBX = 0i64;
  _RBX[2] = 0.0;
  do
  {
    v7 = _RAX + 1;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, edx
      vcomiss xmm6, xmm0
    }
    if ( v5 )
    {
      if ( (_DWORD)_RAX == 2 )
      {
        __asm
        {
          vsubss  xmm1, xmm0, xmm6
          vmovss  xmm0, cs:__real@3f800000
          vsubss  xmm2, xmm0, xmm1
        }
        v7 = 0;
      }
      else
      {
        __asm
        {
          vmovss  xmm1, cs:__real@3f800000
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vsubss  xmm2, xmm6, xmm0
          vsubss  xmm1, xmm1, xmm2
        }
      }
      _RAX = (int)_RAX;
      __asm { vmovss  dword ptr [rbx+rax*4], xmm1 }
      _RAX = v7;
      __asm { vmovss  dword ptr [rbx+rax*4], xmm2 }
      goto LABEL_13;
    }
    LODWORD(_RAX) = _RAX + 1;
    v5 = (unsigned int)v7 <= 3;
  }
  while ( v7 < 3 );
  __asm
  {
    vcvtss2sd xmm0, xmm6, xmm6
    vmovsd  [rsp+48h+var_20], xmm0
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13000, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_GetADSZoomLevelWeights should have never reached here. adsZoomLevelFraction: %f", v19) )
  {
    __debugbreak();
    __asm { vmovaps xmm6, [rsp+48h+var_18] }
    return;
  }
LABEL_13:
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
BG_GetAdsAlign
==============
*/
_BOOL8 BG_GetAdsAlign(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const BgHybridScopeFraction *hybridScopeFractionInfo, vec3_t *outAdsAlignOffset, AdsOffsetInterpolationType *outOffsetLerpType, AdsOffsetInterpolationType *outAlignmentLerpType, bool *outDisableTagAlignX)
{
  const AttADSSettings *WeaponAdsSettings; 
  bool adsAlignEnabled; 
  AdsOffsetInterpolationType adsAlignLerpType; 
  const WeaponDef *v19; 
  _BOOL8 result; 

  _RSI = outAdsAlignOffset;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19500, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19501, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !outOffsetLerpType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19502, ASSERT_TYPE_ASSERT, "( outOffsetLerpType ) != ( nullptr )", "%s != %s\n\t%p, %p", "outOffsetLerpType", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAlignmentLerpType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19503, ASSERT_TYPE_ASSERT, "( outAlignmentLerpType ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAlignmentLerpType", "nullptr", NULL, NULL) )
    __debugbreak();
  WeaponAdsSettings = BG_GetWeaponAdsSettings(r_weapon, isAlternate, 0, 0);
  if ( WeaponAdsSettings )
  {
    _R13 = hybridScopeFractionInfo;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm0, dword ptr [r13+0]
    }
    *outAdsAlignOffset = WeaponAdsSettings->adsAlignOffset;
    adsAlignEnabled = WeaponAdsSettings->adsAlignEnabled;
    *outDisableTagAlignX = WeaponAdsSettings->disableTagAlignX;
    *outOffsetLerpType = WeaponAdsSettings->adsAlignOffsetLerpType;
    adsAlignLerpType = WeaponAdsSettings->adsAlignLerpType;
  }
  else
  {
    v19 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19555, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
      __debugbreak();
    *outAdsAlignOffset = v19->adsAlignOffset;
    adsAlignEnabled = v19->adsAlignEnabled;
    *outDisableTagAlignX = v19->disableTagAlignX;
    *outOffsetLerpType = v19->adsAlignOffsetLerpType;
    adsAlignLerpType = v19->adsAlignLerpType;
  }
  *outAlignmentLerpType = adsAlignLerpType;
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4]
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
  }
  result = adsAlignEnabled;
  __asm { vmovss  dword ptr [rsi+4], xmm1 }
  return result;
}

/*
==============
BG_GetAdsDownAnim
==============
*/
__int64 BG_GetAdsDownAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17839, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17840, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_DOWN_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 407i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 408i64;
  if ( v4 )
    return 407i64;
  return result;
}

/*
==============
BG_GetAdsFireAnim
==============
*/
__int64 BG_GetAdsFireAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17908, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17909, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_FIRE_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 346i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 347i64;
  if ( v4 )
    return 346i64;
  return result;
}

/*
==============
BG_GetAdsLastShotAnim
==============
*/
__int64 BG_GetAdsLastShotAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17926, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17927, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_LASTSHOT_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 348i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 349i64;
  if ( v4 )
    return 348i64;
  return result;
}

/*
==============
BG_GetAdsSettingsScale
==============
*/
float BG_GetAdsSettingsScale(const Weapon *r_weapon, bool isAlternate, const bool isUsingHybridScope, bool ignoreSpreadFromScopes)
{
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment **v15; 
  __int64 v16; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v34[32]; 
  char v35; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-28h], xmm6
    vmovaps xmmword ptr [r11-38h], xmm7
    vmovaps xmmword ptr [r11-48h], xmm8
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v34, (const UnderbarrelMainModeFieldType)2, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmm8, xmm6
    vxorps  xmm7, xmm7, xmm7
  }
  if ( WeaponAttachments_Internal )
  {
    v15 = (const WeaponAttachment **)attachments;
    v16 = WeaponAttachments_Internal;
    do
    {
      _RBX = *v15;
      if ( *v15 && (!ignoreSpreadFromScopes || _RBX->type) )
      {
        if ( BG_AttachmentUseMainSettings(*v15, isAlternate, isUsingHybridScope) )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+2DCh]
            vcomiss xmm0, xmm7
          }
        }
        else
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+2D8h]
            vcomiss xmm0, xmm7
            vmovaps xmm0, xmm6
          }
        }
        __asm
        {
          vaddss  xmm0, xmm8, xmm0
          vsubss  xmm8, xmm0, xmm6
        }
      }
      ++v15;
      --v16;
    }
    while ( v16 );
  }
  __asm
  {
    vmaxss  xmm3, xmm8, xmm7
    vsubss  xmm0, xmm6, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm6, xmm2
  }
  _R11 = &v35;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetAdsSettleAnim
==============
*/
__int64 BG_GetAdsSettleAnim(const playerState_s *ps, const PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  bool v6; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17871, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17872, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  v6 = BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SETTLE_ADS, hand, pmoveHandler) != 0;
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG, hand, pmoveHandler) && BG_PlayerUsesNVGHalfADS(ps, pmoveHandler) )
    return 165i64;
  else
    return v6 ? 0xA4 : 0;
}

/*
==============
BG_GetAdsUpAnim
==============
*/
__int64 BG_GetAdsUpAnim(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  bool v4; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17807, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17808, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_UP_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
    return 405i64;
  v4 = !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler);
  result = 406i64;
  if ( v4 )
    return 405i64;
  return result;
}

/*
==============
BG_GetAdsVisionSetInfo
==============
*/
BgAdsVisionSetInfo *BG_GetAdsVisionSetInfo(BgAdsVisionSetInfo *result, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, bool isAlternate)
{
  bool v10; 
  const WeaponDef *v11; 
  const char *visionSetName; 
  int visionSetBlendInTimeMs; 
  bool v14; 
  unsigned int v15; 
  unsigned int WeaponAttachments_Internal; 
  const playerState_s *v17; 
  unsigned int v18; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v20; 
  unsigned int v21; 
  WeaponAttachment **v23; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  AttADSOverlay *adsOverlay; 
  const char *v26; 
  bool v27; 
  bool v28; 
  const dvar_t *v29; 
  char v31; 
  const dvar_t *v32; 
  const dvar_t *v33; 
  WeaponAttachment **v34; 
  const WeaponAttachment *v35; 
  AttADSOverlay *v36; 
  bool v37; 
  bool v38; 
  const char *v39; 
  bool v40; 
  const dvar_t *v41; 
  const dvar_t *v43; 
  BgAdsVisionSetInfo *v44; 
  bool v46; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+1C8h+var_48], xmm6 }
  result->visionSetName = NULL;
  *(_QWORD *)&result->visionSetADSFraction = 0i64;
  *(_QWORD *)&result->visionSetBlendOutTimeMs = 0i64;
  v10 = isAlternate && BG_HasUnderbarrelAmmo(weapon);
  v46 = v10;
  v11 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( v11->overlay.applyVisionSet )
  {
    visionSetName = v11->overlay.visionSetName;
    result->visionSetADSFraction = v11->overlay.visionSetADSFraction;
    visionSetBlendInTimeMs = v11->overlay.visionSetBlendInTimeMs;
    result->visionSetBlendOutTimeMs = v11->overlay.visionSetBlendOutTimeMs;
    result->visionSetName = visionSetName;
    result->visionSetBlendInTimeMs = visionSetBlendInTimeMs;
    v14 = visionSetName && *visionSetName;
    result->applyVisionSet = v14;
  }
  v15 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, v10, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v17 = ps;
  v18 = WeaponAttachments_Internal;
  v20 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon), v17 = ps, EquippedWeaponStateConst) && EquippedWeaponStateConst->hybridScope;
  v21 = 0;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( v18 )
  {
    v23 = attachments;
    while ( 1 )
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, v17, weapon, v10, *v23, v20);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15411, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      adsOverlay = OverrideAttachmentWhenApplicable->adsOverlay;
      if ( adsOverlay )
        break;
      v10 = v46;
      ++v21;
      v17 = ps;
      ++v23;
      if ( v21 >= v18 )
        goto LABEL_47;
    }
    v26 = adsOverlay->overlay.visionSetName;
    result->visionSetADSFraction = adsOverlay->overlay.visionSetADSFraction;
    result->visionSetBlendInTimeMs = adsOverlay->overlay.visionSetBlendInTimeMs;
    result->visionSetBlendOutTimeMs = adsOverlay->overlay.visionSetBlendOutTimeMs;
    result->visionSetName = v26;
    v27 = adsOverlay->overlay.applyVisionSet && v26 && *v26;
    result->applyVisionSet = v27;
    v28 = adsOverlay->thermalScope && OverrideAttachmentWhenApplicable->sight;
    v29 = DVARBOOL_bg_scopedNVGSyncAdsFraction;
    if ( !DVARBOOL_bg_scopedNVGSyncAdsFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopedNVGSyncAdsFraction") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v29);
    if ( v29->current.enabled && v28 )
      result->visionSetADSFraction = OverrideAttachmentWhenApplicable->sight->adsSmoothFadeInBegin;
    _RDI = DCONST_DVARFLT_bg_visionsetADSFraction;
    if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vcomiss xmm6, dword ptr [rdi+28h] }
    if ( v31 )
    {
      v32 = DCONST_DVARFLT_bg_visionsetADSFraction;
      if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v32);
      LODWORD(result->visionSetADSFraction) = v32->current.integer;
    }
LABEL_47:
    v10 = v46;
  }
  if ( v20 )
  {
    v33 = DVARBOOL_bg_hybridScopeCheckAllAttachmentsForVisionSet;
    if ( !DVARBOOL_bg_hybridScopeCheckAllAttachmentsForVisionSet && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_hybridScopeCheckAllAttachmentsForVisionSet") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v33);
    if ( v33->current.enabled && !result->visionSetName && v18 )
    {
      v34 = attachments;
      while ( 1 )
      {
        v35 = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, weapon, v10, *v34, 0);
        if ( !v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15449, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        v36 = v35->adsOverlay;
        v37 = v36 && v36->thermalScope && v35->sight;
        if ( v36 && v37 )
          break;
        ++v15;
        ++v34;
        if ( v15 >= v18 )
          goto LABEL_86;
      }
      v38 = !v36->overlay.applyVisionSet;
      v39 = v36->overlay.visionSetName;
      result->visionSetADSFraction = v36->overlay.visionSetADSFraction;
      result->visionSetBlendInTimeMs = v36->overlay.visionSetBlendInTimeMs;
      result->visionSetBlendOutTimeMs = v36->overlay.visionSetBlendOutTimeMs;
      result->visionSetName = v39;
      v40 = !v38 && v39 && *v39;
      v41 = DVARBOOL_bg_scopedNVGSyncAdsFraction;
      result->applyVisionSet = v40;
      if ( !v41 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopedNVGSyncAdsFraction") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v41);
      if ( v41->current.enabled )
        result->visionSetADSFraction = v35->sight->adsSmoothFadeInBegin;
      _RDI = DCONST_DVARFLT_bg_visionsetADSFraction;
      if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm { vcomiss xmm6, dword ptr [rdi+28h] }
      if ( v31 )
      {
        v43 = DCONST_DVARFLT_bg_visionsetADSFraction;
        if ( !DCONST_DVARFLT_bg_visionsetADSFraction && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_visionsetADSFraction") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v43);
        LODWORD(result->visionSetADSFraction) = v43->current.integer;
      }
    }
  }
LABEL_86:
  v44 = result;
  __asm { vmovaps xmm6, [rsp+1C8h+var_48] }
  return v44;
}

/*
==============
BG_GetAdvancedIdleSettings
==============
*/
void BG_GetAdvancedIdleSettings(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, AdvancedIdleSettings *outAdvancedIdleSettings)
{
  unsigned int WeaponAttachments_Internal; 
  char v24; 
  WeaponAttachment **v30; 
  __int64 v31; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v47; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v111; 
  void *retaddr; 
  bitarray<64> v113; 

  _R11 = &retaddr;
  v113 = perks;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm6
    vmovaps xmmword ptr [r11-58h], xmm7
    vmovaps xmmword ptr [r11-68h], xmm8
    vmovaps xmmword ptr [r11-78h], xmm9
    vmovaps xmmword ptr [r11-88h], xmm10
    vmovaps xmmword ptr [r11-98h], xmm11
    vmovaps xmmword ptr [r11-0A8h], xmm12
  }
  _RBX = outAdvancedIdleSettings;
  if ( !outAdvancedIdleSettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12022, ASSERT_TYPE_ASSERT, "(outAdvancedIdleSettings)", (const char *)&queryFormat, "outAdvancedIdleSettings") )
    __debugbreak();
  memset_0(_RBX, 0, sizeof(AdvancedIdleSettings));
  _RDI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12029, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+13B8h]
    vmovups ymmword ptr [rbx], ymm0
    vmovups ymm1, ymmword ptr [rdi+13D8h]
    vmovups ymmword ptr [rbx+20h], ymm1
    vmovups ymm0, ymmword ptr [rdi+13F8h]
    vmovups ymmword ptr [rbx+40h], ymm0
    vmovups ymm1, ymmword ptr [rdi+1418h]
    vmovups ymmword ptr [rbx+60h], ymm1
    vmovups xmm0, xmmword ptr [rdi+1438h]
    vmovups xmmword ptr [rbx+80h], xmm0
    vmovsd  xmm1, qword ptr [rdi+1448h]
    vmovsd  qword ptr [rbx+90h], xmm1
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_ORDER_STOCK_PRIORITIZED);
  __asm { vmovss  xmm8, cs:__real@3f800000 }
  v24 = 0;
  __asm
  {
    vmovaps xmm6, xmm8
    vmovaps xmm11, xmm8
    vmovaps xmm12, xmm8
    vmovaps xmm10, xmm8
    vxorps  xmm9, xmm9, xmm9
  }
  if ( WeaponAttachments_Internal )
  {
    v30 = attachments;
    v31 = WeaponAttachments_Internal;
    do
    {
      _RDI = *v30;
      if ( !*v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12046, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+2CCh]
        vcomiss xmm0, xmm9
        vaddss  xmm0, xmm6, xmm0
        vsubss  xmm6, xmm0, xmm8
        vmovss  xmm0, dword ptr [rdi+2D0h]
        vcomiss xmm0, xmm9
        vaddss  xmm0, xmm0, xmm11
        vsubss  xmm11, xmm0, xmm8
        vmovss  xmm0, dword ptr [rdi+2D4h]
        vcomiss xmm0, xmm9
        vaddss  xmm0, xmm10, xmm0
        vsubss  xmm10, xmm0, xmm8
      }
      if ( !v24 )
      {
        if ( _RDI->idleSettings )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rax+1Ch]
            vmovups ymmword ptr [rbx], ymm0
            vmovups ymm1, ymmword ptr [rax+3Ch]
            vmovups ymmword ptr [rbx+20h], ymm1
            vmovups ymm0, ymmword ptr [rax+5Ch]
            vmovups ymmword ptr [rbx+40h], ymm0
            vmovups ymm1, ymmword ptr [rax+7Ch]
            vmovups ymmword ptr [rbx+60h], ymm1
            vmovups xmm0, xmmword ptr [rax+9Ch]
            vmovups xmmword ptr [rbx+80h], xmm0
            vmovsd  xmm1, qword ptr [rax+0ACh]
            vmovsd  qword ptr [rbx+90h], xmm1
          }
          v24 = 1;
        }
      }
      ++v30;
      --v31;
    }
    while ( v31 );
  }
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x1Au);
  v47 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex >= 0 )
  {
    if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 )
    {
      LODWORD(attachmentSlots) = 64;
      LODWORD(numAttachmentSlots) = PerkNetworkPriorityIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", numAttachmentSlots, attachmentSlots) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v47 & 0x1F)) & v113.array[v47 >> 5]) != 0 )
    {
      _RDI = DCONST_DVARFLT_perk_reducedSwayScale;
      if ( !DCONST_DVARFLT_perk_reducedSwayScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_reducedSwayScale") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm { vmovss  xmm12, dword ptr [rdi+28h] }
    }
  }
  __asm
  {
    vmovss  xmm5, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmaxss  xmm2, xmm6, xmm9
    vmovsd  xmm6, cs:__real@3eb0c6f7a0b5ed8d
    vsubss  xmm0, xmm8, xmm2
    vandps  xmm0, xmm0, xmm5
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm7, xmm2, xmm8, xmm0
    vmaxss  xmm3, xmm11, xmm9
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, xmm5
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm4, xmm3, xmm8, xmm2
    vsubss  xmm0, xmm8, xmm12
    vandps  xmm0, xmm0, xmm5
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm12, xmm8, xmm2
    vmulss  xmm4, xmm0, xmm4
    vmaxss  xmm3, xmm10, xmm9
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, xmm5
    vcvtss2sd xmm1, xmm0, xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+0Ch]
    vmovss  dword ptr [rbx+0Ch], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+24h]
    vmovss  dword ptr [rbx+24h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+28h]
    vmovss  dword ptr [rbx+28h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+10h]
    vmovss  dword ptr [rbx+10h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+14h]
    vmovss  dword ptr [rbx+14h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+18h]
    vmovss  dword ptr [rbx+18h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+54h]
    vmovss  dword ptr [rbx+54h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+6Ch]
    vmovss  dword ptr [rbx+6Ch], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+70h]
    vmovss  dword ptr [rbx+70h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+58h]
    vmovss  dword ptr [rbx+58h], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+5Ch]
    vmovss  dword ptr [rbx+5Ch], xmm0
    vmulss  xmm0, xmm7, dword ptr [rbx+60h]
    vmovss  dword ptr [rbx+60h], xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm1, xmm3, xmm8, xmm2
    vmulss  xmm0, xmm1, dword ptr [rbx+30h]
    vmovss  dword ptr [rbx+30h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+48h]
    vmovss  dword ptr [rbx+48h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+4Ch]
    vmovss  dword ptr [rbx+4Ch], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+34h]
    vmovss  dword ptr [rbx+34h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+38h]
    vmovss  dword ptr [rbx+38h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+3Ch]
    vmovss  dword ptr [rbx+3Ch], xmm0
    vmulss  xmm0, xmm1, dword ptr [rbx+78h]
    vmovss  dword ptr [rbx+78h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+90h]
    vmovss  dword ptr [rbx+90h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+94h]
    vmovss  dword ptr [rbx+94h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+7Ch]
    vmovss  dword ptr [rbx+7Ch], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+80h]
    vmovss  dword ptr [rbx+80h], xmm0
    vmulss  xmm0, xmm4, dword ptr [rbx+84h]
    vmovss  dword ptr [rbx+84h], xmm0
  }
  _R11 = &v111;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-38h]
    vmovaps xmm7, xmmword ptr [r11-48h]
    vmovaps xmm8, xmmword ptr [r11-58h]
    vmovaps xmm9, xmmword ptr [r11-68h]
    vmovaps xmm10, xmmword ptr [r11-78h]
    vmovaps xmm11, xmmword ptr [r11-88h]
    vmovaps xmm12, xmmword ptr [r11-98h]
  }
}

/*
==============
BG_GetAllWeaponAttachments
==============
*/
unsigned int BG_GetAllWeaponAttachments(const Weapon *r_weapon, const WeaponAttachment **attachments)
{
  unsigned __int8 attachmentIds[32]; 

  return BG_GetAllWeaponAttachmentsWithIds(r_weapon, attachments, attachmentIds);
}

/*
==============
BG_GetAllWeaponAttachmentsCount
==============
*/
__int64 BG_GetAllWeaponAttachmentsCount(const Weapon *r_weapon)
{
  int v1; 
  int v4; 
  bool v5; 
  __int16 v6; 
  int v7; 

  v1 = 0;
  if ( !r_weapon->weaponIdx )
    return 0i64;
  v4 = 0;
  v5 = 1;
  do
  {
    if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
      __debugbreak();
    if ( v4 == 12 )
      v6 = r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8);
    else
      v6 = r_weapon->weaponAttachments[v4];
    v7 = v1 + 1;
    if ( !v6 )
      v7 = v1;
    ++v4;
    v1 = v7;
    v5 = v4 < 13;
  }
  while ( (unsigned int)v4 < 0xD );
  return v7 + __popcnt(r_weapon->weaponOthers);
}

/*
==============
BG_GetAllWeaponAttachmentsWithIds
==============
*/
__int64 BG_GetAllWeaponAttachmentsWithIds(const Weapon *r_weapon, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  const Weapon *v5; 
  __int64 v6; 
  const WeaponCompleteDef *v8; 
  const AttachmentSlot *v9; 
  __int64 v10; 
  AttachmentSlot v11; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  int v14; 
  __int64 v16; 
  __int64 v17; 
  __int64 v19; 
  const AttachmentSlot *v20; 

  v5 = r_weapon;
  if ( !attachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1519, ASSERT_TYPE_ASSERT, "(attachments)", (const char *)&queryFormat, "attachments") )
    __debugbreak();
  if ( !attachmentIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1520, ASSERT_TYPE_ASSERT, "(attachmentIds)", (const char *)&queryFormat, "attachmentIds") )
    __debugbreak();
  v6 = 0i64;
  DebugWipe(attachments, 0xE8ui64);
  if ( !v5->weaponIdx )
    return 0i64;
  v8 = BG_WeaponCompleteDef(v5, 0);
  v9 = ATTACHMENT_DEFAULT_ORDER;
  v10 = 14i64;
  v20 = ATTACHMENT_DEFAULT_ORDER;
  v19 = 14i64;
  do
  {
    v11 = *v9;
    if ( *(int *)v9 < 13 )
    {
      WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(v5, v11);
      if ( WeaponPrimaryAttachment )
      {
        if ( (unsigned int)v6 >= 0x1D )
        {
          LODWORD(v17) = 29;
          LODWORD(v16) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1541, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        attachments[v6] = WeaponPrimaryAttachment;
        v5 = r_weapon;
        attachmentIds[v6] = truncate_cast<unsigned char,enum AttachmentSlot>(v11);
        v6 = (unsigned int)(v6 + 1);
      }
LABEL_35:
      v10 = v19;
      goto LABEL_36;
    }
    if ( v11 != ATT_SLOT_OTHER )
    {
      SLODWORD(v16) = *v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1569, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid attachment slot %d specified by the attachment ordering\n", v16) )
        __debugbreak();
      goto LABEL_35;
    }
    if ( v8->attachments[13].attachmentCount > 0x10 )
    {
      LODWORD(v17) = 16;
      LODWORD(v16) = v8->attachments[13].attachmentCount;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1551, ASSERT_TYPE_ASSERT, "( attList->attachmentCount ) <= ( 16 )", "attList->attachmentCount not in [0, MAX_ATTACHMENT_OTHERS]\n\t%u not in [0, %u]", v16, v17) )
        __debugbreak();
      v10 = v19;
    }
    _EBP = v5->weaponOthers;
    if ( v5->weaponOthers )
    {
      do
      {
        v14 = _EBP;
        __asm { tzcnt   ebx, ebp }
        if ( _EBX >= v8->attachments[13].attachmentCount )
        {
          LODWORD(v17) = v8->attachments[13].attachmentCount;
          LODWORD(v16) = _EBX;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1556, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( attList->attachmentCount )", "otherIndex doesn't index attList->attachmentCount\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        if ( (unsigned int)v6 >= 0x1D )
        {
          LODWORD(v17) = 29;
          LODWORD(v16) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1557, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        attachments[v6] = v8->attachments[13].attachments[_EBX];
        if ( _EBX >= 0x10 )
        {
          LODWORD(v17) = 16;
          LODWORD(v16) = _EBX;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v16, v17) )
            __debugbreak();
        }
        attachmentIds[v6] = truncate_cast<unsigned char,unsigned int>(_EBX + 13);
        v6 = (unsigned int)(v6 + 1);
        _EBP ^= 1 << _EBX;
      }
      while ( 1 << _EBX != v14 );
      v5 = r_weapon;
      goto LABEL_35;
    }
LABEL_36:
    v9 = v20 + 1;
    --v10;
    ++v20;
    v19 = v10;
  }
  while ( v10 );
  return (unsigned int)v6;
}

/*
==============
BG_GetAltWeapon
==============
*/
const Weapon *BG_GetAltWeapon(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  bool v3; 
  const Weapon *result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( !WeaponPrimaryAttachment )
    return &NULL_WEAPON;
  v3 = WeaponPrimaryAttachment->weapClass == WEAPCLASS_NONE;
  result = r_weapon;
  if ( v3 )
    return &NULL_WEAPON;
  return result;
}

/*
==============
BG_GetAmmoIndex
==============
*/
__int64 BG_GetAmmoIndex(const Weapon *r_weapon, bool isAlternate, const BgHandler *const handler, const char **outAmmoName)
{
  const WeaponDef *v8; 
  unsigned int iAmmoIndex; 
  int v10; 
  int WeaponAttachments_Internal; 
  __int64 v12; 
  __int64 v13; 
  WeaponAttachment *v14; 
  AttAmmoType *ammotype; 
  __int64 result; 
  WeaponAttachment *v17; 
  __int64 v18; 
  int v19; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( outAmmoName )
    *outAmmoName = NULL;
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v8->iAmmoIndex )
  {
    v19 = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6075, ASSERT_TYPE_ASSERT, "( 0 ) != ( weapDef->iAmmoIndex )", "%s != %s\n\t%i, %i", "0", "weapDef->iAmmoIndex", 0i64, v19) )
      __debugbreak();
  }
  iAmmoIndex = v8->iAmmoIndex;
  if ( outAmmoName )
  {
    if ( handler )
      LOBYTE(handler) = BG_IsGameTypeQuick_BR(handler);
    if ( BG_WeaponOverrides_GetSharedAmmo(r_weapon) || (_BYTE)handler )
      *outAmmoName = v8->szAmmoName;
  }
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal <= 0 )
    return iAmmoIndex;
  v13 = 0i64;
  while ( 1 )
  {
    if ( !attachments[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6096, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    v14 = attachments[v13];
    ammotype = v14->ammotype;
    if ( ammotype )
    {
      if ( ammotype->szAmmoName )
        break;
    }
    ++v10;
    if ( ++v13 >= v12 )
      return iAmmoIndex;
  }
  if ( !v14->iAmmoIndex )
  {
    LODWORD(v18) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6099, ASSERT_TYPE_ASSERT, "( 0 ) != ( attachments[attachmentIndex]->iAmmoIndex )", "%s != %s\n\t%i, %i", "0", "attachments[attachmentIndex]->iAmmoIndex", 0i64, v18) )
      __debugbreak();
  }
  v17 = attachments[v10];
  result = (unsigned int)v17->iAmmoIndex;
  if ( outAmmoName )
    *outAmmoName = v17->ammotype->szAmmoName;
  return result;
}

/*
==============
BG_GetAngularGunKickSettings
==============
*/
void BG_GetAngularGunKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularGunKickDir, float *hipAngularGunKickDev, float *hipAngularGunKickStrengthMin, float *hipAngularGunKickStrengthMax, float *hipAngularGunKickPitchScale, float *adsAngularGunKickDir, float *adsAngularGunKickDev, float *adsAngularGunKickStrengthMin, float *adsAngularGunKickStrengthMax, float *adsAngularGunKickPitchScale)
{
  const BgWeaponMap *v21; 
  const Weapon *v24; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool *v27; 
  int v28; 
  int *v29; 
  int v30; 
  int v31; 
  EffectiveStance EffectiveStance; 
  __int64 v34; 
  bool v36; 
  ContextMountType type; 
  unsigned int v51; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v55; 
  WeaponAttachment **v56; 
  __int64 v57; 
  WeaponAttachment *v58; 
  const dvar_t *v60; 
  const WeaponAttachment **v64; 
  AttGunKick *AttachmentGunKick; 
  float *p_hipGunKickPitchMin; 
  bool *v94; 
  int *v95; 
  int v96; 
  bool v97; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v104; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  v21 = weaponMap;
  _R14 = ps;
  v24 = r_weapon;
  if ( !hipAngularGunKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14958, ASSERT_TYPE_ASSERT, "(hipAngularGunKickDir)", (const char *)&queryFormat, "hipAngularGunKickDir") )
    __debugbreak();
  if ( !hipAngularGunKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14959, ASSERT_TYPE_ASSERT, "(hipAngularGunKickDev)", (const char *)&queryFormat, "hipAngularGunKickDev") )
    __debugbreak();
  if ( !hipAngularGunKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14960, ASSERT_TYPE_ASSERT, "(hipAngularGunKickStrengthMin)", (const char *)&queryFormat, "hipAngularGunKickStrengthMin") )
    __debugbreak();
  if ( !hipAngularGunKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14961, ASSERT_TYPE_ASSERT, "(hipAngularGunKickStrengthMax)", (const char *)&queryFormat, "hipAngularGunKickStrengthMax") )
    __debugbreak();
  if ( !hipAngularGunKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14962, ASSERT_TYPE_ASSERT, "(hipAngularGunKickPitchScale)", (const char *)&queryFormat, "hipAngularGunKickPitchScale") )
    __debugbreak();
  if ( !adsAngularGunKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14963, ASSERT_TYPE_ASSERT, "(adsAngularGunKickDir)", (const char *)&queryFormat, "adsAngularGunKickDir") )
    __debugbreak();
  if ( !adsAngularGunKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14964, ASSERT_TYPE_ASSERT, "(adsAngularGunKickDev)", (const char *)&queryFormat, "adsAngularGunKickDev") )
    __debugbreak();
  if ( !adsAngularGunKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14965, ASSERT_TYPE_ASSERT, "(adsAngularGunKickStrengthMin)", (const char *)&queryFormat, "adsAngularGunKickStrengthMin") )
    __debugbreak();
  if ( !adsAngularGunKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14966, ASSERT_TYPE_ASSERT, "(adsAngularGunKickStrengthMax)", (const char *)&queryFormat, "adsAngularGunKickStrengthMax") )
    __debugbreak();
  if ( !adsAngularGunKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14967, ASSERT_TYPE_ASSERT, "(adsAngularGunKickPitchScale)", (const char *)&queryFormat, "adsAngularGunKickPitchScale") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(v24->weaponIdx);
  v97 = _R14 && v21 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v21, _R14, v24)) != NULL && EquippedWeaponStateConst->hybridScope;
  v27 = &_RBX->adsAngularGunKickUseSet[1];
  v28 = 1;
  v29 = &_RBX->adsAngularGunKickBullet[1];
  v30 = 1;
  while ( *v27 && *v29 <= bulletNum )
  {
    v31 = v30;
    ++v29;
    ++v30;
    ++v27;
    if ( v30 >= 6 )
      goto LABEL_42;
  }
  v31 = v30 - 1;
LABEL_42:
  *hipAngularGunKickDir = _RBX->hipAngularGunKickDir[0];
  *hipAngularGunKickDev = _RBX->hipAngularGunKickDev[0];
  *hipAngularGunKickStrengthMin = _RBX->hipAngularGunKickStrengthMin[0];
  *hipAngularGunKickStrengthMax = _RBX->hipAngularGunKickStrengthMax[0];
  *hipAngularGunKickPitchScale = _RBX->hipAngularGunKickPitchScale[0];
  *adsAngularGunKickDir = _RBX->adsAngularGunKickDir[v31];
  *adsAngularGunKickDev = _RBX->adsAngularGunKickDev[v31];
  *adsAngularGunKickStrengthMin = _RBX->adsAngularGunKickStrengthMin[v31];
  *adsAngularGunKickStrengthMax = _RBX->adsAngularGunKickStrengthMax[v31];
  *adsAngularGunKickPitchScale = _RBX->adsAngularGunKickPitchScale[v31];
  EffectiveStance = PM_GetEffectiveStance(_R14);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  v34 = EffectiveStance;
  __asm { vmovaps xmm9, xmm6 }
  v36 = (unsigned int)EffectiveStance < PM_EFF_STANCE_DUCKED;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    __asm { vmovss  xmm9, dword ptr [rbx+4D0h] }
  }
  else
  {
    v36 = EffectiveStance == PM_EFF_STANCE_DEFAULT;
    if ( EffectiveStance == PM_EFF_STANCE_PRONE )
      __asm { vmovss  xmm9, dword ptr [rbx+4D8h] }
  }
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vcomiss xmm10, dword ptr [r14+4C0h]
  }
  if ( !v36 )
    goto LABEL_54;
  type = _R14->mountState.surface.type;
  _RAX = BG_WeaponDefAtIndex(v24->weaponIdx);
  _RCX = _RAX;
  if ( !_RAX )
    goto LABEL_48;
  if ( type == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm3, dword ptr [rax+1318h] }
    goto LABEL_53;
  }
  if ( (unsigned int)(type - 2) <= 1 )
    __asm { vmovss  xmm3, dword ptr [rcx+1350h] }
  else
LABEL_48:
    __asm { vmovaps xmm3, xmm6 }
LABEL_53:
  __asm
  {
    vmovss  xmm1, dword ptr [r14+4C0h]
    vsubss  xmm0, xmm6, xmm1
    vmulss  xmm2, xmm0, xmm9
    vmulss  xmm1, xmm1, xmm3
    vaddss  xmm9, xmm2, xmm1
  }
LABEL_54:
  v51 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v24, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovaps xmm8, xmm6
    vmovaps xmm7, xmm6
  }
  if ( !WeaponAttachments_Internal )
    goto LABEL_75;
  v55 = WeaponAttachments_Internal;
  v56 = attachments;
  v57 = v34;
  do
  {
    v58 = *v56;
    if ( !*v56 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15036, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v58->adsStanceScales )
    {
      if ( v57 == 2 )
      {
        v60 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v60);
        __asm { vmovss  xmm0, dword ptr [rdi+4] }
      }
      else
      {
        if ( v57 != 1 )
          goto LABEL_73;
        v60 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v60);
        __asm { vmovss  xmm0, dword ptr [rdi+0Ch] }
      }
      if ( v60->current.enabled )
      {
        __asm { vmulss  xmm7, xmm7, xmm0 }
      }
      else
      {
        __asm
        {
          vaddss  xmm0, xmm8, xmm0
          vsubss  xmm8, xmm0, xmm6
        }
      }
    }
LABEL_73:
    ++v56;
    --v55;
  }
  while ( v55 );
  v28 = 1;
  _R14 = ps;
  v51 = 0;
  v24 = r_weapon;
  v21 = weaponMap;
LABEL_75:
  if ( WeaponAttachments_Internal )
  {
    v64 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15069, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(v21, _R14, v24, isAlternate, *v64, v97);
      p_hipGunKickPitchMin = &AttachmentGunKick->hipGunKickPitchMin;
      if ( AttachmentGunKick )
        break;
      ++v51;
      ++v64;
      if ( v51 >= WeaponAttachments_Internal )
        goto LABEL_82;
    }
    v94 = &AttachmentGunKick->adsAngularGunKickUseSet[1];
    v95 = (int *)(p_hipGunKickPitchMin + 72);
    while ( *v94 && *v95 <= bulletNum )
    {
      v96 = v28;
      ++v95;
      ++v28;
      ++v94;
      if ( v28 >= 6 )
        goto LABEL_90;
    }
    v96 = v28 - 1;
LABEL_90:
    _R9 = hipAngularGunKickStrengthMin;
    _R10 = hipAngularGunKickStrengthMax;
    *hipAngularGunKickDir = p_hipGunKickPitchMin[11];
    *hipAngularGunKickDev = p_hipGunKickPitchMin[17];
    *hipAngularGunKickStrengthMin = p_hipGunKickPitchMin[23];
    *hipAngularGunKickStrengthMax = p_hipGunKickPitchMin[29];
    *hipAngularGunKickPitchScale = p_hipGunKickPitchMin[35];
    *adsAngularGunKickDir = p_hipGunKickPitchMin[v96 + 41];
    *adsAngularGunKickDev = p_hipGunKickPitchMin[v96 + 47];
    *adsAngularGunKickStrengthMin = p_hipGunKickPitchMin[v96 + 53];
    *adsAngularGunKickStrengthMax = p_hipGunKickPitchMin[v96 + 59];
    *adsAngularGunKickPitchScale = p_hipGunKickPitchMin[v96 + 65];
  }
  else
  {
LABEL_82:
    _R10 = hipAngularGunKickStrengthMax;
    _R9 = hipAngularGunKickStrengthMin;
  }
  _RAX = adsAngularGunKickStrengthMin;
  __asm
  {
    vmaxss  xmm2, xmm8, xmm10
    vsubss  xmm0, xmm6, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm6, xmm0
    vsubss  xmm0, xmm6, xmm7
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm6, xmm2
    vmulss  xmm2, xmm0, xmm5
    vmulss  xmm0, xmm2, dword ptr [r9]
    vmovss  dword ptr [r9], xmm0
    vmulss  xmm1, xmm2, dword ptr [r10]
    vmovss  dword ptr [r10], xmm1
    vmulss  xmm2, xmm2, xmm9
    vmulss  xmm0, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = adsAngularGunKickStrengthMax;
  __asm
  {
    vmulss  xmm1, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _R11 = &v104;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
BG_GetAngularViewKickSettings
==============
*/
void BG_GetAngularViewKickSettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int bulletNum, float *hipAngularViewKickDir, float *hipAngularViewKickDev, float *hipAngularViewKickStrengthMin, float *hipAngularViewKickStrengthMax, float *hipAngularViewKickPitchScale, float *adsAngularViewKickDir, float *adsAngularViewKickDev, float *adsAngularViewKickStrengthMin, float *adsAngularViewKickStrengthMax, float *adsAngularViewKickPitchScale)
{
  int v26; 
  bool *v27; 
  int *v28; 
  int v29; 
  EffectiveStance EffectiveStance; 
  __int64 v32; 
  bool v34; 
  ContextMountType type; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v50; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  __int64 v54; 
  WeaponAttachment **v55; 
  __int64 v56; 
  WeaponAttachment *v57; 
  const dvar_t *v59; 
  unsigned int v63; 
  int v64; 
  const WeaponAttachment **v65; 
  AttViewKick *AttachmentViewKick; 
  float *p_hipViewKickPitchMin; 
  int *v95; 
  bool *v96; 
  int v97; 
  bool v98; 
  unsigned int v100; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v106; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  _R14 = ps;
  if ( !hipAngularViewKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14784, ASSERT_TYPE_ASSERT, "(hipAngularViewKickDir)", (const char *)&queryFormat, "hipAngularViewKickDir") )
    __debugbreak();
  if ( !hipAngularViewKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14785, ASSERT_TYPE_ASSERT, "(hipAngularViewKickDev)", (const char *)&queryFormat, "hipAngularViewKickDev") )
    __debugbreak();
  if ( !hipAngularViewKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14786, ASSERT_TYPE_ASSERT, "(hipAngularViewKickStrengthMin)", (const char *)&queryFormat, "hipAngularViewKickStrengthMin") )
    __debugbreak();
  if ( !hipAngularViewKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14787, ASSERT_TYPE_ASSERT, "(hipAngularViewKickStrengthMax)", (const char *)&queryFormat, "hipAngularViewKickStrengthMax") )
    __debugbreak();
  if ( !hipAngularViewKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14788, ASSERT_TYPE_ASSERT, "(hipAngularViewKickPitchScale)", (const char *)&queryFormat, "hipAngularViewKickPitchScale") )
    __debugbreak();
  if ( !adsAngularViewKickDir && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14789, ASSERT_TYPE_ASSERT, "(adsAngularViewKickDir)", (const char *)&queryFormat, "adsAngularViewKickDir") )
    __debugbreak();
  if ( !adsAngularViewKickDev && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14790, ASSERT_TYPE_ASSERT, "(adsAngularViewKickDev)", (const char *)&queryFormat, "adsAngularViewKickDev") )
    __debugbreak();
  if ( !adsAngularViewKickStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14791, ASSERT_TYPE_ASSERT, "(adsAngularViewKickStrengthMin)", (const char *)&queryFormat, "adsAngularViewKickStrengthMin") )
    __debugbreak();
  if ( !adsAngularViewKickStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14792, ASSERT_TYPE_ASSERT, "(adsAngularViewKickStrengthMax)", (const char *)&queryFormat, "adsAngularViewKickStrengthMax") )
    __debugbreak();
  if ( !adsAngularViewKickPitchScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14793, ASSERT_TYPE_ASSERT, "(adsAngularViewKickPitchScale)", (const char *)&queryFormat, "adsAngularViewKickPitchScale") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v26 = 1;
  v27 = &_RBX->adsAngularViewKickUseSet[1];
  v28 = &_RBX->adsAngularViewKickBullet[1];
  while ( *v27 && *v28 <= bulletNum )
  {
    v29 = v26;
    ++v28;
    ++v26;
    ++v27;
    if ( v26 >= 6 )
      goto LABEL_37;
  }
  v29 = v26 - 1;
LABEL_37:
  *hipAngularViewKickDir = _RBX->hipAngularViewKickDir[0];
  *hipAngularViewKickDev = _RBX->hipAngularViewKickDev[0];
  *hipAngularViewKickStrengthMin = _RBX->hipAngularViewKickStrengthMin[0];
  *hipAngularViewKickStrengthMax = _RBX->hipAngularViewKickStrengthMax[0];
  *hipAngularViewKickPitchScale = _RBX->hipAngularViewKickPitchScale[0];
  *adsAngularViewKickDir = _RBX->adsAngularViewKickDir[v29];
  *adsAngularViewKickDev = _RBX->adsAngularViewKickDev[v29];
  *adsAngularViewKickStrengthMin = _RBX->adsAngularViewKickStrengthMin[v29];
  *adsAngularViewKickStrengthMax = _RBX->adsAngularViewKickStrengthMax[v29];
  *adsAngularViewKickPitchScale = _RBX->adsAngularViewKickPitchScale[v29];
  EffectiveStance = PM_GetEffectiveStance(_R14);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  v32 = EffectiveStance;
  __asm { vmovaps xmm9, xmm6 }
  v34 = (unsigned int)EffectiveStance < PM_EFF_STANCE_DUCKED;
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    __asm { vmovss  xmm9, dword ptr [rbx+4CCh] }
  }
  else
  {
    v34 = EffectiveStance == PM_EFF_STANCE_DEFAULT;
    if ( EffectiveStance == PM_EFF_STANCE_PRONE )
      __asm { vmovss  xmm9, dword ptr [rbx+4D4h] }
  }
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vcomiss xmm10, dword ptr [r14+4C0h]
  }
  if ( !v34 )
    goto LABEL_49;
  type = _R14->mountState.surface.type;
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RCX = _RAX;
  if ( !_RAX )
    goto LABEL_43;
  if ( type == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm3, dword ptr [rax+1320h] }
    goto LABEL_48;
  }
  if ( (unsigned int)(type - 2) <= 1 )
    __asm { vmovss  xmm3, dword ptr [rcx+1358h] }
  else
LABEL_43:
    __asm { vmovaps xmm3, xmm6 }
LABEL_48:
  __asm
  {
    vmovss  xmm1, dword ptr [r14+4C0h]
    vsubss  xmm0, xmm6, xmm1
    vmulss  xmm2, xmm0, xmm9
    vmulss  xmm1, xmm1, xmm3
    vaddss  xmm9, xmm2, xmm1
  }
LABEL_49:
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v50 = WeaponAttachments_Internal;
  v100 = WeaponAttachments_Internal;
  __asm
  {
    vmovaps xmm8, xmm6
    vmovaps xmm7, xmm6
  }
  v98 = weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, _R14, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !(_DWORD)v50 )
    goto LABEL_80;
  v54 = v50;
  v55 = attachments;
  v56 = v32;
  do
  {
    v57 = *v55;
    if ( !*v55 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14863, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v57->adsStanceScales )
    {
      if ( v56 == 2 )
      {
        v59 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v59);
        __asm { vmovss  xmm0, dword ptr [rdi] }
      }
      else
      {
        if ( v56 != 1 )
          goto LABEL_72;
        v59 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v59);
        __asm { vmovss  xmm0, dword ptr [rdi+8] }
      }
      if ( v59->current.enabled )
      {
        __asm { vmulss  xmm7, xmm7, xmm0 }
      }
      else
      {
        __asm
        {
          vaddss  xmm0, xmm8, xmm0
          vsubss  xmm8, xmm0, xmm6
        }
      }
    }
LABEL_72:
    ++v55;
    --v54;
  }
  while ( v54 );
  v63 = 0;
  v64 = 1;
  if ( !v100 )
  {
LABEL_80:
    _R10 = hipAngularViewKickStrengthMax;
    _R9 = hipAngularViewKickStrengthMin;
    goto LABEL_81;
  }
  v65 = (const WeaponAttachment **)attachments;
  while ( 1 )
  {
    if ( !*v65 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14896, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *v65, v98);
    p_hipViewKickPitchMin = &AttachmentViewKick->hipViewKickPitchMin;
    if ( AttachmentViewKick )
      break;
    ++v63;
    ++v65;
    if ( v63 >= v100 )
      goto LABEL_80;
  }
  v95 = &AttachmentViewKick->adsAngularViewKickBullet[1];
  v96 = &AttachmentViewKick->adsAngularViewKickUseSet[1];
  while ( *v96 && *v95 <= bulletNum )
  {
    v97 = v64;
    ++v95;
    ++v64;
    ++v96;
    if ( v64 >= 6 )
      goto LABEL_88;
  }
  v97 = v64 - 1;
LABEL_88:
  _R9 = hipAngularViewKickStrengthMin;
  _R10 = hipAngularViewKickStrengthMax;
  *hipAngularViewKickDir = p_hipViewKickPitchMin[11];
  *hipAngularViewKickDev = p_hipViewKickPitchMin[17];
  *hipAngularViewKickStrengthMin = p_hipViewKickPitchMin[23];
  *hipAngularViewKickStrengthMax = p_hipViewKickPitchMin[29];
  *hipAngularViewKickPitchScale = p_hipViewKickPitchMin[35];
  *adsAngularViewKickDir = p_hipViewKickPitchMin[v97 + 41];
  *adsAngularViewKickDev = p_hipViewKickPitchMin[v97 + 47];
  *adsAngularViewKickStrengthMin = p_hipViewKickPitchMin[v97 + 53];
  *adsAngularViewKickStrengthMax = p_hipViewKickPitchMin[v97 + 59];
  *adsAngularViewKickPitchScale = p_hipViewKickPitchMin[v97 + 65];
LABEL_81:
  _RAX = adsAngularViewKickStrengthMin;
  __asm
  {
    vmaxss  xmm2, xmm8, xmm10
    vsubss  xmm0, xmm6, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm6, xmm0
    vsubss  xmm0, xmm6, xmm7
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm6, xmm2
    vmulss  xmm2, xmm0, xmm5
    vmulss  xmm0, xmm2, dword ptr [r9]
    vmovss  dword ptr [r9], xmm0
    vmulss  xmm1, xmm2, dword ptr [r10]
    vmovss  dword ptr [r10], xmm1
    vmulss  xmm2, xmm2, xmm9
    vmulss  xmm0, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = adsAngularViewKickStrengthMax;
  __asm
  {
    vmulss  xmm1, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _R11 = &v106;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
BG_GetAnimForFootsteps
==============
*/
__int64 BG_GetAnimForFootsteps(FootstepAnimType footstepAnim)
{
  __int64 v1; 
  int v4; 

  v1 = footstepAnim;
  if ( (unsigned int)footstepAnim >= FOOTSTEP_ANIM_COUNT )
  {
    v4 = 13;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21739, ASSERT_TYPE_ASSERT, "(unsigned)( footstepAnim ) < (unsigned)( ( sizeof( *array_counter( FootstepToAnimMap ) ) + 0 ) )", "footstepAnim doesn't index ARRAY_COUNT( FootstepToAnimMap )\n\t%i not in [0, %i)", footstepAnim, v4) )
      __debugbreak();
  }
  return (unsigned int)FootstepToAnimMap[v1];
}

/*
==============
BG_GetAnimOverrideIdxForMeleeComboSeq
==============
*/
__int64 BG_GetAnimOverrideIdxForMeleeComboSeq(const Weapon *r_weapon, const int meleeComboSeqIdx)
{
  int v4; 
  unsigned int v5; 
  const WeaponDef *v6; 
  __int64 result; 

  if ( !BG_IsMeleeComboOverride(r_weapon, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19810, ASSERT_TYPE_ASSERT, "(BG_IsMeleeComboWeapon( r_weapon ))", (const char *)&queryFormat, "BG_IsMeleeComboWeapon( r_weapon )") )
    __debugbreak();
  if ( meleeComboSeqIdx < 0 )
    goto LABEL_21;
  if ( !BG_IsMeleeComboOverride(r_weapon, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19780, ASSERT_TYPE_ASSERT, "(BG_IsMeleeComboWeapon( r_weapon ))", (const char *)&queryFormat, "BG_IsMeleeComboWeapon( r_weapon )") )
    __debugbreak();
  v4 = 1;
  v5 = 0;
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6->numAnimOverrides )
    goto LABEL_22;
  do
  {
    if ( !BG_IsMeleeComboOverride(r_weapon, v5) )
      break;
    ++v4;
    ++v5;
  }
  while ( v5 < v6->numAnimOverrides );
  if ( v4 <= 1 )
  {
LABEL_22:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19802, ASSERT_TYPE_ASSERT, "(comboCount > 1)", (const char *)&queryFormat, "comboCount > 1") )
      __debugbreak();
  }
  if ( meleeComboSeqIdx >= v4 )
  {
LABEL_21:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19811, ASSERT_TYPE_ASSERT, "((meleeComboSeqIdx >= 0) && (meleeComboSeqIdx < BG_GetMeleeComboSeqCount( r_weapon )))", (const char *)&queryFormat, "(meleeComboSeqIdx >= 0) && (meleeComboSeqIdx < BG_GetMeleeComboSeqCount( r_weapon ))") )
      __debugbreak();
  }
  result = 0xFFFFFFFFi64;
  if ( meleeComboSeqIdx )
    return (unsigned int)(meleeComboSeqIdx - 1);
  return result;
}

/*
==============
BG_GetAttachmentGunKick
==============
*/
AttGunKick *BG_GetAttachmentGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 516, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !attachment )
    return 0i64;
  OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, weapon, isAlternate, attachment, usingHybridScope);
  if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 524, ASSERT_TYPE_ASSERT, "(overrideAttachment)", (const char *)&queryFormat, "overrideAttachment") )
    __debugbreak();
  return OverrideAttachmentWhenApplicable->gunKick;
}

/*
==============
BG_GetAttachmentModel
==============
*/
XModel *BG_GetAttachmentModel(const WeaponAttachment *weaponAttachment, const int attachmentVariationIndex, bool isViewModel)
{
  __int64 v3; 
  XModel **viewModelVariations; 

  v3 = attachmentVariationIndex;
  if ( !weaponAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1670, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
    __debugbreak();
  if ( (int)v3 >= (signed int)weaponAttachment->numModelVariations )
    return 0i64;
  if ( isViewModel )
    viewModelVariations = weaponAttachment->viewModelVariations;
  else
    viewModelVariations = weaponAttachment->worldModelVariations;
  return viewModelVariations[v3];
}

/*
==============
BG_GetAttachmentViewKick
==============
*/
AttViewKick *BG_GetAttachmentViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 500, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !attachment )
    return 0i64;
  OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, weapon, isAlternate, attachment, usingHybridScope);
  if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 508, ASSERT_TYPE_ASSERT, "(overrideAttachment)", (const char *)&queryFormat, "overrideAttachment") )
    __debugbreak();
  return OverrideAttachmentWhenApplicable->viewKick;
}

/*
==============
BG_GetBallisticInfo
==============
*/
const BallisticInfo *BG_GetBallisticInfo(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  const BallisticInfo *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v8[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v8, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->ballisticInfo;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22302, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->ballisticInfo;
    if ( result )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->ballisticInfo;
  }
  return result;
}

/*
==============
BG_GetBallisticMuzzleVelocityScale
==============
*/
float BG_GetBallisticMuzzleVelocityScale(const Weapon *r_weapon, bool isAlternate)
{
  __int64 v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  char *v13; 
  unsigned int v14; 
  __int64 v15; 
  bool v24; 
  bool v25; 
  WeaponAttachment **v26; 
  __int64 v27; 
  bool v30; 
  const dvar_t *v34; 
  WeaponAttachment *attachments; 
  char v44; 
  unsigned __int8 v45[32]; 
  char v46; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-18h], xmm6
    vmovaps xmmword ptr [r11-28h], xmm8
    vmovaps xmmword ptr [r11-38h], xmm9
  }
  v7 = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, v45, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = WeaponAttachments_Internal;
  __asm
  {
    vmovss  xmm9, cs:__real@3f800000
    vmovaps xmm6, xmm9
    vxorps  xmm1, xmm1, xmm1
  }
  if ( WeaponAttachments_Internal >= 4 )
  {
    v13 = &v44;
    v14 = ((WeaponAttachments_Internal - 4) >> 2) + 1;
    v15 = v14;
    v7 = 4 * v14;
    do
    {
      if ( *((_QWORD *)v13 - 1) )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rax+264h]
          vcomiss xmm0, xmm1
          vmulss  xmm6, xmm6, xmm0
        }
      }
      _RAX = *(_QWORD *)v13;
      if ( *(_QWORD *)v13 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rax+264h]
          vcomiss xmm0, xmm1
        }
        if ( *(_QWORD *)v13 )
          __asm { vmulss  xmm6, xmm6, xmm0 }
      }
      if ( *((_QWORD *)v13 + 1) )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rax+264h]
          vcomiss xmm0, xmm1
          vmulss  xmm6, xmm6, xmm0
        }
      }
      if ( *((_QWORD *)v13 + 2) )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rax+264h]
          vcomiss xmm0, xmm1
          vmulss  xmm6, xmm6, xmm0
        }
      }
      v13 += 32;
      --v15;
    }
    while ( v15 );
  }
  v24 = (_DWORD)v7 == v9;
  v25 = (unsigned int)v7 <= v9;
  if ( (unsigned int)v7 < v9 )
  {
    v26 = &attachments + v7;
    v27 = v9 - (unsigned int)v7;
    do
    {
      _RAX = *v26;
      if ( *v26 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rax+264h]
          vcomiss xmm0, xmm1
        }
        if ( *v26 )
          __asm { vmulss  xmm6, xmm6, xmm0 }
      }
      ++v26;
      v30 = v27-- == 0;
      v24 = v27 == 0;
      v25 = v30 || v27 == 0;
    }
    while ( v27 );
  }
  __asm
  {
    vsubss  xmm0, xmm9, xmm6
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm8, xmm0, xmm0
    vcomisd xmm8, cs:__real@3eb0c6f7a0b5ed8d
  }
  if ( !v25 )
  {
    __asm { vucomiss xmm6, xmm1 }
    if ( v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22355, ASSERT_TYPE_ASSERT, "(weapScaleAccum.GetFinalValue( 1.0f ))", (const char *)&queryFormat, "weapScaleAccum.GetFinalValue( 1.0f )") )
      __debugbreak();
  }
  v34 = DCONST_DVARFLT_bg_ballisticsVelocityScalar;
  __asm
  {
    vcmplesd xmm0, xmm8, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm6, xmm9, xmm0
  }
  if ( !DCONST_DVARFLT_bg_ballisticsVelocityScalar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsVelocityScalar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v34);
  __asm { vmulss  xmm0, xmm6, dword ptr [rbx+28h] }
  _R11 = &v46;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-20h]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetBulletDamageForProjectile
==============
*/

int __fastcall BG_GetBulletDamageForProjectile(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, double rangeScale, const vec3_t *startPos, vec3_t *hitPos)
{
  int v13; 
  char v15; 
  bool v16; 
  int result; 
  bool v36; 
  float *maxDamageRangea; 
  int v51; 
  int outMaxDamage; 
  int outMinDamage; 
  float minDamageRange; 

  __asm
  {
    vmovaps [rsp+0A8h+var_38], xmm6
    vmovaps xmm6, xmm3
  }
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v51 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16627, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v51) )
      __debugbreak();
  }
  BG_GetMinMaxDamage(damageCalcType, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  v13 = outMaxDamage;
  if ( outMaxDamage == outMinDamage )
  {
    result = outMaxDamage;
  }
  else
  {
    __asm
    {
      vmovaps [rsp+0A8h+var_48], xmm7
      vmovaps xmm3, xmm6; rangeScale
    }
    BG_GetDamageRange(damageCalcType, r_weapon, isAlternate, *(float *)&_XMM3, &minDamageRange, (float *)&outMaxDamage);
    _RDX = hitPos;
    __asm
    {
      vmovss  xmm0, dword ptr [rdx]
      vsubss  xmm3, xmm0, dword ptr [rcx]
      vmovss  xmm0, dword ptr [rdx+4]
      vsubss  xmm2, xmm0, dword ptr [rcx+4]
      vmovss  xmm1, dword ptr [rdx+8]
      vsubss  xmm4, xmm1, dword ptr [rcx+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm0, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm0
      vmulss  xmm1, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm1
      vsqrtss xmm7, xmm2, xmm2
      vcomiss xmm7, [rsp+0A8h+outMaxDamage]
    }
    if ( v15 )
    {
      result = v13;
    }
    else
    {
      __asm
      {
        vmovss  xmm0, [rsp+0A8h+minDamageRange]
        vcomiss xmm7, xmm0
      }
      if ( v15 )
      {
        __asm
        {
          vsubss  xmm6, xmm0, [rsp+0A8h+outMaxDamage]
          vmovaps [rsp+0A8h+var_58], xmm8
          vxorps  xmm8, xmm8, xmm8
          vucomiss xmm6, xmm8
        }
        if ( v16 )
        {
          v36 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16657, ASSERT_TYPE_ASSERT, "(range != 0.0f)", (const char *)&queryFormat, "range != 0.0f");
          v15 = 0;
          v16 = !v36;
          if ( v36 )
            __debugbreak();
        }
        __asm
        {
          vsubss  xmm0, xmm7, [rsp+0A8h+outMaxDamage]
          vmovss  xmm7, cs:__real@3f800000
          vdivss  xmm6, xmm0, xmm6
          vcomiss xmm6, xmm8
          vmovaps xmm8, [rsp+0A8h+var_58]
        }
        if ( v15 )
          goto LABEL_15;
        __asm { vcomiss xmm6, xmm7 }
        if ( !(v15 | v16) )
        {
LABEL_15:
          __asm
          {
            vcvtss2sd xmm0, xmm6, xmm6
            vmovsd  [rsp+0A8h+maxDamageRange], xmm0
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16659, ASSERT_TYPE_ASSERT, "( ( (lerpAmount >= 0.0) && (lerpAmount <= 1.0) ) )", "( lerpAmount ) = %g", *(double *)&maxDamageRangea) )
            __debugbreak();
        }
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, ebx
          vsubss  xmm1, xmm7, xmm6
          vmulss  xmm3, xmm1, xmm0
          vxorps  xmm1, xmm1, xmm1
          vcvtsi2ss xmm1, xmm1, [rsp+0A8h+outMinDamage]
          vmulss  xmm2, xmm1, xmm6
          vaddss  xmm0, xmm3, xmm2
          vcvttss2si eax, xmm0
        }
      }
      else
      {
        result = outMinDamage;
      }
    }
    __asm { vmovaps xmm7, [rsp+0A8h+var_48] }
  }
  __asm { vmovaps xmm6, [rsp+0A8h+var_38] }
  return result;
}

/*
==============
BG_GetBulletTerminationRange
==============
*/
float BG_GetBulletTerminationRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  char v14; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v16; 
  __int64 v17; 
  bool v18; 
  bool v19; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v31; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  *(double *)&_XMM0 = BG_GetADSDamageRangeScale(weaponMap, ps, r_weapon, isAlternate);
  __asm
  {
    vmovaps xmm6, xmm0
    vxorps  xmm8, xmm8, xmm8
    vxorps  xmm7, xmm7, xmm7
  }
  v14 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    goto LABEL_14;
  v16 = attachments;
  v17 = WeaponAttachments_Internal;
  do
  {
    v18 = *v16 == NULL;
    if ( !*v16 )
    {
      v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8405, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
      v18 = !v19;
      if ( v19 )
        __debugbreak();
    }
    _RAX = *v16;
    __asm
    {
      vmovss  xmm0, dword ptr [rax+268h]
      vucomiss xmm0, xmm8
    }
    if ( !v18 )
      __asm { vmulss  xmm6, xmm6, xmm0 }
    if ( !v14 )
    {
      if ( _RAX->damage )
      {
        __asm { vmovss  xmm7, dword ptr [rax+84h] }
        v14 = 1;
      }
    }
    ++v16;
    --v17;
  }
  while ( v17 );
  if ( v14 )
  {
    __asm { vmulss  xmm0, xmm7, xmm6 }
  }
  else
  {
LABEL_14:
    BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm { vmulss  xmm0, xmm6, dword ptr [rax+13Ch] }
  }
  _R11 = &v31;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-20h]
    vmovaps xmm7, xmmword ptr [r11-30h]
    vmovaps xmm8, xmmword ptr [r11-40h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetBurstFireCooldown
==============
*/
float BG_GetBurstFireCooldown(const Weapon *r_weapon, bool isAlternate)
{
  char v10; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment **v16; 
  __int64 v17; 
  WeaponAttachment *v18; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v35; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = 0;
  __asm { vmovss  xmm8, dword ptr [rax+1D4h] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
  }
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    v17 = WeaponAttachments_Internal;
    do
    {
      v18 = *v16;
      if ( !*v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7010, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
        __debugbreak();
      if ( v10 || !v18->burst || v18->type == ATTACHMENT_UNDERBARREL && WeaponPrimaryAttachment != v18 )
      {
        __asm
        {
          vaddss  xmm0, xmm6, dword ptr [rbx+2C8h]
          vsubss  xmm6, xmm0, xmm7
        }
      }
      else
      {
        __asm
        {
          vxorps  xmm8, xmm8, xmm8
          vcvtsi2ss xmm8, xmm8, dword ptr [rax]
        }
        v10 = 1;
      }
      ++v16;
      --v17;
    }
    while ( v17 );
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm3, xmm6, xmm0
    vsubss  xmm1, xmm7, xmm3
    vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm0, xmm1, xmm1
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm8, xmm0
  }
  _R11 = &v35;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetCenterReticle
==============
*/
void BG_GetCenterReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleCenter, int *reticleCenterSize, bool *shouldPulse)
{
  const WeaponDef *v9; 
  int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v13; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !reticleCenter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16541, ASSERT_TYPE_ASSERT, "(reticleCenter)", (const char *)&queryFormat, "reticleCenter") )
    __debugbreak();
  if ( !reticleCenterSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16542, ASSERT_TYPE_ASSERT, "(reticleCenterSize)", (const char *)&queryFormat, "reticleCenterSize") )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *reticleCenter = v9->reticleCenter;
  *reticleCenterSize = v9->iReticleCenterSize;
  if ( shouldPulse )
    *shouldPulse = v9->reticleCenterPulse;
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16557, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v13 = *i;
      general = (*i)->general;
      if ( general )
        break;
      if ( ++v10 >= WeaponAttachments_Internal )
        return;
    }
    *reticleCenter = general->reticleCenter;
    *reticleCenterSize = v13->general->reticleCenterSize;
  }
}

/*
==============
BG_GetCharacterModelRangeByType
==============
*/
char BG_GetCharacterModelRangeByType(DObj *obj, const CharacterModelType (*dobjModelTypes)[32], const CharacterModelType modelTypeSearched, const int startModelIndex, const int finishModelIndex, int *outFirst, int *outLast)
{
  __int64 v7; 
  const CharacterModelType *v11; 
  CharacterModelType v12; 
  int v13; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  int v18; 

  v7 = startModelIndex;
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5895, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !dobjModelTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5896, ASSERT_TYPE_ASSERT, "(dobjModelTypes)", (const char *)&queryFormat, "dobjModelTypes") )
    __debugbreak();
  if ( !outFirst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5897, ASSERT_TYPE_ASSERT, "(outFirst)", (const char *)&queryFormat, "outFirst") )
    __debugbreak();
  if ( !outLast && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5898, ASSERT_TYPE_ASSERT, "(outLast)", (const char *)&queryFormat, "outLast") )
    __debugbreak();
  if ( (int)v7 < 0 || (int)v7 > DObjGetNumModels(obj) - 1 )
  {
    v18 = DObjGetNumModels(obj) - 1;
    LODWORD(v15) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5899, ASSERT_TYPE_ASSERT, "( 0 ) <= ( startModelIndex ) && ( startModelIndex ) <= ( (DObjGetNumModels( obj ) - 1) )", "startModelIndex not in [0, (DObjGetNumModels( obj ) - 1)]\n\t%i not in [%i, %i]", v15, 0i64, v18) )
      __debugbreak();
  }
  if ( finishModelIndex < 0 || finishModelIndex > DObjGetNumModels(obj) - 1 )
  {
    LODWORD(v17) = DObjGetNumModels(obj) - 1;
    LODWORD(v15) = finishModelIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5900, ASSERT_TYPE_ASSERT, "( 0 ) <= ( finishModelIndex ) && ( finishModelIndex ) <= ( (DObjGetNumModels( obj ) - 1) )", "finishModelIndex not in [0, (DObjGetNumModels( obj ) - 1)]\n\t%i not in [%i, %i]", v15, 0i64, v17) )
      __debugbreak();
  }
  *outFirst = -1;
  *outLast = -1;
  if ( (int)v7 <= finishModelIndex )
  {
    v11 = &(*dobjModelTypes)[v7];
    do
    {
      if ( (unsigned int)v7 >= 0x20 )
      {
        LODWORD(v16) = 32;
        LODWORD(v15) = v7;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5909, ASSERT_TYPE_ASSERT, "(unsigned)( modelIndex ) < (unsigned)( ( 32 ) )", "modelIndex doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      v12 = *v11;
      if ( *outFirst >= 0 )
      {
        if ( v12 != modelTypeSearched )
        {
          v13 = v7 - 1;
          *outLast = v13;
          if ( v13 < *outFirst )
          {
            LODWORD(v17) = v13;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5925, ASSERT_TYPE_ASSERT, "( *outLast ) >= ( *outFirst )", "%s >= %s\n\t%i, %i", "*outLast", "*outFirst", v17, *outFirst) )
              __debugbreak();
          }
          break;
        }
      }
      else if ( v12 == modelTypeSearched )
      {
        *outFirst = v7;
      }
      LODWORD(v7) = v7 + 1;
      ++v11;
    }
    while ( (int)v7 <= finishModelIndex );
  }
  if ( *outFirst < 0 )
    return 0;
  if ( *outLast < 0 )
    *outLast = finishModelIndex;
  return 1;
}

/*
==============
BG_GetClipLowAmmo
==============
*/
int BG_GetClipLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v7; 
  const dvar_t *v8; 
  int lowAmmoWarningCount; 
  unsigned int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v12; 
  AttAmmunition *ammunition; 
  int result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6027, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6030, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT|0x100) )
  {
    v8 = DVARBOOL_killswitch_weapon_low_ammo_count_enabled;
    if ( !DVARBOOL_killswitch_weapon_low_ammo_count_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_low_ammo_count_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    if ( v8->current.enabled )
    {
      lowAmmoWarningCount = v7->lowAmmoWarningCount;
      v10 = 0;
      WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      if ( WeaponAttachments_Internal )
      {
        v12 = attachments;
        while ( 1 )
        {
          if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6044, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
            __debugbreak();
          ammunition = (*v12)->ammunition;
          if ( ammunition )
            break;
          ++v10;
          ++v12;
          if ( v10 >= WeaponAttachments_Internal )
            goto LABEL_21;
        }
        lowAmmoWarningCount = ammunition->lowAmmoWarningCount;
      }
LABEL_21:
      if ( lowAmmoWarningCount > 0 )
        return lowAmmoWarningCount;
    }
  }
  BG_GetClipSize(ps, r_weapon, isAlternate);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vmulss  xmm0, xmm0, dword ptr [r14+3E0h]
    vcvttss2si eax, xmm0
  }
  return result;
}

/*
==============
BG_GetClipSize
==============
*/
__int64 BG_GetClipSize(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const playerState_s *v8; 
  int integer; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v16; 
  __int64 v17; 
  bool v18; 
  bool v19; 
  unsigned int v23; 
  WeaponAttachment **v24; 
  AttAmmunition *ammunition; 
  const dvar_t *v39; 
  const char *v40; 
  __int64 numAttachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  v8 = ps;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm6
    vmovaps xmmword ptr [r11-58h], xmm7
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
    vmovaps xmmword ptr [r11-68h], xmm8
  }
  integer = 0;
  _ER15 = BG_WeaponCompleteDef(r_weapon, isAlternate)->iClipSize;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vxorps  xmm8, xmm8, xmm8 }
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    v17 = WeaponAttachments_Internal;
    do
    {
      v18 = *v16 == NULL;
      if ( !*v16 )
      {
        v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5996, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v18 = !v19;
        if ( v19 )
          __debugbreak();
      }
      _RAX = *v16;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+260h]
        vucomiss xmm0, xmm8
      }
      if ( !v18 )
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm6
          vsubss  xmm6, xmm0, xmm7
        }
      }
      ++v16;
      --v17;
    }
    while ( v17 );
    v8 = ps;
  }
  v23 = 0;
  if ( WeaponAttachments_Internal )
  {
    v24 = attachments;
    while ( 1 )
    {
      ammunition = (*v24)->ammunition;
      if ( ammunition )
        break;
      ++v23;
      ++v24;
      if ( v23 >= WeaponAttachments_Internal )
        goto LABEL_16;
    }
    _ER15 = ammunition->clipSize;
  }
LABEL_16:
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vmovaps xmm8, [rsp+1D8h+var_68]
    vmovaps xmm6, [rsp+1D8h+var_48]
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vmovd   xmm0, r15d
    vblendvps xmm1, xmm3, xmm7, xmm2
    vmovaps xmm7, [rsp+1D8h+var_58]
    vcvtdq2ps xmm0, xmm0
    vmulss  xmm0, xmm0, xmm1
    vcvttss2si ebx, xmm0
  }
  if ( _EBX > 1 )
  {
    if ( v8 && BG_HasPerk(&v8->perks, 0xEu) )
    {
      switch ( BG_GetWeaponClass(r_weapon, 0) )
      {
        case WEAPCLASS_RIFLE:
          v39 = DVARINT_perk_extendedMagsRifleAmmo;
          if ( DVARINT_perk_extendedMagsRifleAmmo )
            goto LABEL_36;
          v40 = "perk_extendedMagsRifleAmmo";
          break;
        case WEAPCLASS_SNIPER:
          v39 = DVARINT_perk_extendedMagsSniperAmmo;
          if ( DVARINT_perk_extendedMagsSniperAmmo )
            goto LABEL_36;
          v40 = "perk_extendedMagsSniperAmmo";
          break;
        case WEAPCLASS_MG:
          v39 = DVARINT_perk_extendedMagsMGAmmo;
          if ( DVARINT_perk_extendedMagsMGAmmo )
            goto LABEL_36;
          v40 = "perk_extendedMagsMGAmmo";
          break;
        case WEAPCLASS_SMG:
          v39 = DVARINT_perk_extendedMagsSMGAmmo;
          if ( DVARINT_perk_extendedMagsSMGAmmo )
            goto LABEL_36;
          v40 = "perk_extendedMagsSMGAmmo";
          break;
        case WEAPCLASS_SPREAD:
          v39 = DVARINT_perk_extendedMagsSpreadAmmo;
          if ( DVARINT_perk_extendedMagsSpreadAmmo )
            goto LABEL_36;
          v40 = "perk_extendedMagsSpreadAmmo";
          break;
        case WEAPCLASS_PISTOL:
          v39 = DVARINT_perk_extendedMagsPistolAmmo;
          if ( DVARINT_perk_extendedMagsPistolAmmo )
            goto LABEL_36;
          v40 = "perk_extendedMagsPistolAmmo";
          break;
        case WEAPCLASS_BEAM:
          v39 = DVARINT_perk_extendedMagsBeamAmmo;
          if ( DVARINT_perk_extendedMagsBeamAmmo )
            goto LABEL_36;
          v40 = "perk_extendedMagsBeamAmmo";
          break;
        default:
          goto LABEL_37;
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v40) )
        __debugbreak();
LABEL_36:
      Dvar_CheckFrontendServerThread(v39);
      integer = v39->current.integer;
LABEL_37:
      _EBX += integer;
    }
    if ( _EBX <= 1 )
    {
      LODWORD(numAttachmentSlots) = _EBX;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6018, ASSERT_TYPE_SANITY, "( ( clipSize > 1 ) )", "( clipSize ) = %i", numAttachmentSlots) )
        __debugbreak();
    }
  }
  return (unsigned int)_EBX;
}

/*
==============
BG_GetDamage
==============
*/
__int64 BG_GetDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  int outMaxDamage; 
  int outMinDamage; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v8 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8665, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v8) )
      __debugbreak();
  }
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(damageCalcType, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  return (unsigned int)outMaxDamage;
}

/*
==============
BG_GetDamageRange
==============
*/

void __fastcall BG_GetDamageRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, double rangeScale, float *minDamageRange, float *maxDamageRange)
{
  int ShelvedDamageRanges; 
  __int64 size; 
  __int64 v19; 
  int v20; 
  float rangeArray[4]; 

  __asm { vmovaps [rsp+0A8h+var_48], xmm6 }
  _RBP = maxDamageRange;
  __asm { vmovaps xmm6, xmm3 }
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v20 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9478, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v20) )
      __debugbreak();
  }
  if ( BG_UsesShelvedDamageFalloff(damageCalcType, r_weapon, isAlternate) )
  {
    if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
    {
      LODWORD(v19) = 3;
      LODWORD(size) = damageCalcType;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9408, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", size, v19) )
        __debugbreak();
    }
    __asm { vmovaps xmm3, xmm6; rangeScale }
    ShelvedDamageRanges = BG_GetShelvedDamageRanges(damageCalcType, r_weapon, isAlternate, *(float *)&_XMM3, rangeArray, 4);
    if ( (unsigned int)(ShelvedDamageRanges - 1) > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9414, ASSERT_TYPE_ASSERT, "(( rangeCount > 0 ) && ( rangeCount <= 4 ))", (const char *)&queryFormat, "( rangeCount > 0 ) && ( rangeCount <= MAX_WEAPON_SHELF_RANGES )") )
      __debugbreak();
    __asm
    {
      vmovss  xmm0, [rsp+0A8h+rangeArray]
      vmovss  dword ptr [rbp+0], xmm0
    }
    *minDamageRange = rangeArray[ShelvedDamageRanges - 1];
  }
  else
  {
    __asm { vmovaps xmm3, xmm6; rangeScale }
    BG_GetLinearDamageRange(damageCalcType, r_weapon, isAlternate, *(float *)&_XMM3, minDamageRange, maxDamageRange);
  }
  __asm { vmovaps xmm6, [rsp+0A8h+var_48] }
}

/*
==============
BG_GetDamageViewKickScaleValues
==============
*/
void BG_GetDamageViewKickScaleValues(const playerState_s *ps, const usercmd_s *cmd, float *viewKickScale, float *viewKickMin, float *viewKickMax)
{
  const dvar_t *v10; 
  const dvar_t *v11; 
  const char *v13; 
  const dvar_t *v14; 
  const dvar_t *v15; 

  _R14 = viewKickMin;
  _R15 = viewKickScale;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21797, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !_R15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21798, ASSERT_TYPE_ASSERT, "(viewKickScale)", (const char *)&queryFormat, "viewKickScale") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21799, ASSERT_TYPE_ASSERT, "(viewKickMin)", (const char *)&queryFormat, "viewKickMin") )
    __debugbreak();
  _RBP = viewKickMax;
  if ( !viewKickMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21800, ASSERT_TYPE_ASSERT, "(viewKickMax)", (const char *)&queryFormat, "viewKickMax") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|WEAPON_LADDER_AIM|0x80) || BG_InADS(ps) || (cmd->buttons & 0x200) != 0 )
  {
    v14 = DCONST_DVARMPFLT_bg_viewKickScale;
    if ( !DCONST_DVARMPFLT_bg_viewKickScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    *_R15 = v14->current.value;
    v15 = DCONST_DVARMPFLT_bg_viewKickMin;
    if ( !DCONST_DVARMPFLT_bg_viewKickMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickMin") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v15);
    *_R14 = v15->current.value;
    _RBX = DCONST_DVARMPFLT_bg_viewKickMax;
    if ( !DCONST_DVARMPFLT_bg_viewKickMax )
    {
      v13 = "bg_viewKickMax";
LABEL_35:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v13) )
        __debugbreak();
    }
  }
  else
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|WEAPON_LADDER_AIM|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21811, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::NON_ADS_VIEW_KICK_VALUES ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::NON_ADS_VIEW_KICK_VALUES )") )
      __debugbreak();
    v10 = DCONST_DVARMPFLT_bg_viewKickScaleNonADS;
    if ( !DCONST_DVARMPFLT_bg_viewKickScaleNonADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickScaleNonADS") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    *_R15 = v10->current.value;
    v11 = DCONST_DVARMPFLT_bg_viewKickMinNonADS;
    if ( !DCONST_DVARMPFLT_bg_viewKickMinNonADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewKickMinNonADS") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    *_R14 = v11->current.value;
    _RBX = DCONST_DVARMPFLT_bg_viewKickMaxNonADS;
    if ( !DCONST_DVARMPFLT_bg_viewKickMaxNonADS )
    {
      v13 = "bg_viewKickMaxNonADS";
      goto LABEL_35;
    }
  }
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmovss  dword ptr [rbp+0], xmm0
  }
  if ( ps->damageModFlags == 0x80000 )
  {
    _RBX = DCONST_DVARFLT_bg_viewkickModFireScale;
    if ( !DCONST_DVARFLT_bg_viewkickModFireScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewkickModFireScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm2, dword ptr [rbx+28h]
      vmulss  xmm0, xmm2, dword ptr [r15]
      vmovss  dword ptr [r15], xmm0
      vmovss  xmm1, dword ptr [r14]
      vminss  xmm2, xmm1, xmm2
      vmovss  dword ptr [r14], xmm2
      vmovss  xmm0, dword ptr [rbp+0]
      vmaxss  xmm1, xmm0, xmm2
    }
  }
  else
  {
    __asm { vmaxss  xmm1, xmm0, dword ptr [r14] }
  }
  __asm { vmovss  dword ptr [rbp+0], xmm1 }
}

/*
==============
BG_GetDynamicAttachmentSlot
==============
*/
__int64 BG_GetDynamicAttachmentSlot(const DynamicAttachmentType dynamicAttachmentType)
{
  __int64 result; 

  switch ( dynamicAttachmentType )
  {
    case DYNAMIC_ATTACHMENT_TYPE_MUZZLE:
      result = 5i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_UNDERBARREL:
      result = 10i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_LASER:
      result = 8i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_MAGAZINE:
      result = 3i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_RECEIVER:
      result = 0i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_SCOPE:
      result = 9i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_STOCK:
      result = 2i64;
      break;
    case DYNAMIC_ATTACHMENT_TYPE_BARREL:
      result = 1i64;
      break;
    default:
      result = 13i64;
      break;
  }
  return result;
}

/*
==============
BG_GetEnemyCrossHairRange
==============
*/
float BG_GetEnemyCrossHairRange(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+41Ch] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8168, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->general )
        break;
      ++v6;
      ++v9;
      if ( v6 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_9;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx+4] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_9:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetEnemyLaserType
==============
*/
const LaserDef *BG_GetEnemyLaserType(const Weapon *r_weapon, bool isBeamDraw)
{
  const WeaponDef *v4; 
  const LaserDef *result; 
  LaserDef *viewModelLaser; 
  LaserDef *friendlyLaser; 
  LaserDef *enemyLaser; 
  LaserDef *viewModelLaserAlt; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !isBeamDraw && v4->tracerStyle == TRACERSTYLE_BEAM )
    return 0i64;
  viewModelLaser = NULL;
  viewModelLaserAlt = NULL;
  friendlyLaser = NULL;
  enemyLaser = NULL;
  BG_GetLasers(r_weapon, (const LaserDef **)&viewModelLaser, (const LaserDef **)&viewModelLaserAlt, (const LaserDef **)&friendlyLaser, (const LaserDef **)&enemyLaser);
  result = friendlyLaser;
  if ( enemyLaser )
    return enemyLaser;
  return result;
}

/*
==============
BG_GetExplosionDamageFromRangeInfo
==============
*/

float __fastcall BG_GetExplosionDamageFromRangeInfo(const BgExplosionDamageRangeInfo *damageRangeInfo, double distance)
{
  if ( damageRangeInfo->useSteppedDamage )
  {
    __asm { vcomiss xmm1, dword ptr [rcx+4] }
    if ( damageRangeInfo->useSteppedDamage )
    {
      __asm { vcomiss xmm1, dword ptr [rcx+8] }
      if ( damageRangeInfo->useSteppedDamage )
      {
        __asm { vcomiss xmm1, dword ptr [rcx+0Ch] }
        if ( damageRangeInfo->useSteppedDamage )
          __asm { vxorps  xmm0, xmm0, xmm0 }
        else
          __asm { vmovss  xmm0, dword ptr [rcx+18h] }
      }
      else
      {
        __asm { vmovss  xmm0, dword ptr [rcx+14h] }
      }
    }
    else
    {
      __asm { vmovss  xmm0, dword ptr [rcx+10h] }
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+0Ch]
      vmovss  xmm2, cs:__real@3f800000
      vmaxss  xmm0, xmm0, xmm2
      vdivss  xmm1, xmm1, xmm0
      vmovss  xmm0, dword ptr [rcx+10h]
      vsubss  xmm2, xmm2, xmm1
      vsubss  xmm1, xmm0, dword ptr [rcx+18h]
      vmulss  xmm2, xmm2, xmm1
      vaddss  xmm0, xmm2, dword ptr [rcx+18h]
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetExplosionDamageRangeInfo
==============
*/

void __fastcall BG_GetExplosionDamageRangeInfo(const Weapon *r_weapon, bool isAlternate, BgExplosionDamageRangeInfo *outDamageRangeInfo, double _XMM3_8)
{
  unsigned int v10; 
  unsigned int WeaponAttachments_Internal; 
  bool v12; 
  WeaponAttachment *v15; 
  WeaponAttachment *attachments; 
  unsigned __int8 attachmentIds[32]; 

  _R13 = outDamageRangeInfo;
  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = BG_ExplosionUsesSteppedDamage(r_weapon, isAlternate);
  v15 = attachments;
  _R13->useSteppedDamage = v12;
  if ( v12 )
  {
    if ( WeaponAttachments_Internal )
    {
      while ( 1 )
      {
        if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16854, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        if ( v15->projectile )
          break;
        ++v10;
        ++v15;
        if ( v10 >= WeaponAttachments_Internal )
        {
          _R13 = outDamageRangeInfo;
          __asm
          {
            vxorps  xmm5, xmm5, xmm5
            vcvtsi2ss xmm5, xmm5, ecx
          }
          goto LABEL_20;
        }
      }
      _R13 = outDamageRangeInfo;
      __asm
      {
        vxorps  xmm5, xmm5, xmm5
        vcvtsi2ss xmm5, xmm5, ecx
      }
    }
    else
    {
      __asm
      {
        vxorps  xmm5, xmm5, xmm5
        vcvtsi2ss xmm5, xmm5, ecx
      }
    }
  }
  else
  {
    if ( WeaponAttachments_Internal )
    {
      while ( 1 )
      {
        if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16885, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        if ( v15->projectile )
          break;
        ++v10;
        ++v15;
        if ( v10 >= WeaponAttachments_Internal )
        {
          _R13 = outDamageRangeInfo;
          goto LABEL_19;
        }
      }
      _R13 = outDamageRangeInfo;
    }
LABEL_19:
    __asm { vxorps  xmm5, xmm5, xmm5 }
  }
LABEL_20:
  __asm
  {
    vmovss  dword ptr [r13+4], xmm5
    vxorps  xmm0, xmm0, xmm0
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm0, xmm0, edi
    vmovss  dword ptr [r13+8], xmm0
    vxorps  xmm3, xmm3, xmm3
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm1, xmm1, r12d
    vmovss  dword ptr [r13+0Ch], xmm1
    vcvtsi2ss xmm3, xmm3, edx
    vmovss  dword ptr [r13+10h], xmm3
    vxorps  xmm4, xmm4, xmm4
    vcvtsi2ss xmm2, xmm2, r15d
    vcvtsi2ss xmm4, xmm4, ebp
    vmovss  dword ptr [r13+14h], xmm2
    vmovss  dword ptr [r13+18h], xmm4
  }
}

/*
==============
BG_GetExplosionReactiveMotionParams
==============
*/
void BG_GetExplosionReactiveMotionParams(const Weapon *r_weapon, bool isAlternate, float *radiusScale, float *frequencyScale, float *amplitudeScale, float *falloff, float *lifetime)
{
  const WeaponDef *v11; 
  int v12; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v15; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !radiusScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16974, ASSERT_TYPE_ASSERT, "(radiusScale)", (const char *)&queryFormat, "radiusScale") )
    __debugbreak();
  if ( !frequencyScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16975, ASSERT_TYPE_ASSERT, "(frequencyScale)", (const char *)&queryFormat, "frequencyScale") )
    __debugbreak();
  if ( !amplitudeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16976, ASSERT_TYPE_ASSERT, "(amplitudeScale)", (const char *)&queryFormat, "amplitudeScale") )
    __debugbreak();
  if ( !falloff && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16977, ASSERT_TYPE_ASSERT, "(falloff)", (const char *)&queryFormat, "falloff") )
    __debugbreak();
  if ( !lifetime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16978, ASSERT_TYPE_ASSERT, "(lifetime)", (const char *)&queryFormat, "lifetime") )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = 0;
  *radiusScale = v11->reactiveMotionRadiusScale;
  *frequencyScale = v11->reactiveMotionFrequencyScale;
  *amplitudeScale = v11->reactiveMotionAmplitudeScale;
  *falloff = v11->reactiveMotionFalloff;
  *lifetime = v11->reactiveMotionLifetime;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16991, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v15 = *i;
      projectile = (*i)->projectile;
      if ( projectile )
        break;
      if ( ++v12 >= WeaponAttachments_Internal )
        return;
    }
    *radiusScale = projectile->reactiveMotionRadiusScale;
    *frequencyScale = v15->projectile->reactiveMotionFrequencyScale;
    *amplitudeScale = v15->projectile->reactiveMotionAmplitudeScale;
    *falloff = v15->projectile->reactiveMotionFalloff;
    *lifetime = v15->projectile->reactiveMotionLifetime;
  }
}

/*
==============
BG_GetFireAnimTime
==============
*/
int BG_GetFireAnimTime(const Weapon *r_weapon, const bool isAlternate, __int64 isDualWielding, const playerState_s *const ps, const BgHandler *pmoveHandler, const weapAnimFiles_t anim)
{
  weapAnimFiles_t v7; 
  __int64 v11; 
  __int64 v12; 
  int result; 
  const char *v20; 
  char v21[512]; 
  char output[512]; 

  v7 = anim;
  if ( anim != WEAP_ANIM_LASTSHOT && anim != WEAP_ANIM_FIRE && (unsigned int)(anim - 346) > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9711, ASSERT_TYPE_ASSERT, "((anim == WEAP_ANIM_LASTSHOT) || (anim == WEAP_ANIM_FIRE) || (anim == WEAP_ANIM_ADS_FIRE) || (anim == WEAP_ANIM_ADS_LASTSHOT) || (anim == WEAP_ANIM_ADS_FIRE_NVG) || (anim == WEAP_ANIM_ADS_LASTSHOT_NVG))", (const char *)&queryFormat, "(anim == WEAP_ANIM_LASTSHOT) || (anim == WEAP_ANIM_FIRE) || (anim == WEAP_ANIM_ADS_FIRE) || (anim == WEAP_ANIM_ADS_LASTSHOT) || (anim == WEAP_ANIM_ADS_FIRE_NVG) || (anim == WEAP_ANIM_ADS_LASTSHOT_NVG)") )
    __debugbreak();
  v11 = ((__int64 (__fastcall *)(const BgHandler *, const playerState_s *const, __int64))pmoveHandler->PlayerWeaponAnimsConst)(pmoveHandler, ps, isDualWielding);
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9714, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( memcmp_0((const void *)(v11 + 16660), r_weapon, 0x3Cui64) )
  {
    BG_GetWeaponName((const Weapon *)(v11 + 16660), output, 0x200u);
    BG_GetWeaponName(r_weapon, v21, 0x200u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9724, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "GetFireAnimTime(): Unexpected weapon anim array.  Have '%s', expected '%s'.", output, v21) )
      __debugbreak();
  }
  if ( isAlternate )
  {
    if ( (unsigned int)anim >= NUM_WEAP_ANIMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9730, ASSERT_TYPE_ASSERT, "(anim < ( sizeof( *array_counter( weaponAnimArrays->altAnimArray ) ) + 0 ))", (const char *)&queryFormat, "anim < ARRAY_COUNT( weaponAnimArrays->altAnimArray )") )
      __debugbreak();
    v11 += 4976i64;
  }
  else if ( (unsigned int)anim >= NUM_WEAP_ANIMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9735, ASSERT_TYPE_ASSERT, "(anim < ( sizeof( *array_counter( weaponAnimArrays->normalAnimArray ) ) + 0 ))", (const char *)&queryFormat, "anim < ARRAY_COUNT( weaponAnimArrays->normalAnimArray )") )
  {
    __debugbreak();
  }
  v12 = *(_QWORD *)(v11 + 8i64 * (int)anim);
  _RBX = v12;
  if ( !v12 )
    _RBX = *(_QWORD *)(v11 + 1912);
  if ( _RBX )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm0, dword ptr [rbx+64h]
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9749, ASSERT_TYPE_ASSERT, "(animParts->framerate > 0.0f)", (const char *)&queryFormat, "animParts->framerate > 0.0f") )
      __debugbreak();
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vdivss  xmm2, xmm1, dword ptr [rbx+64h]
      vcvttss2si eax, xmm2
    }
  }
  else
  {
    BG_GetWeaponName(r_weapon, v21, 0x200u);
    v20 = "normal";
    if ( isAlternate )
      v20 = "alt";
    if ( !v12 )
      v7 = WEAP_ANIM_FIRE;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F5A1D0, 547i64, (unsigned int)v7, v20, v21);
    return 0;
  }
  return result;
}

/*
==============
BG_GetFireTime
==============
*/
void BG_GetFireTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  BG_GetFireTimeWithHand(weaponMap, ps, WEAPON_HAND_DEFAULT, 0, r_weapon, isAlternate, isDualWielding, shotCount, fireTime, fireDelay);
}

/*
==============
BG_GetFireTimeWithHand
==============
*/
void BG_GetFireTimeWithHand(const BgWeaponMap *weaponMap, const playerState_s *ps, const PlayerHandIndex hand, const bool adjustForHyperBurst, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int shotCount, int *fireTime, int *fireDelay)
{
  int v22; 
  int v23; 
  bool v24; 
  bool v25; 
  int v44; 
  int iFireDelayAkimbo; 
  BOOL v46; 
  bool v47; 
  bool v48; 
  int v66; 
  int fireTimeOverride; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v70; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  char *v72; 
  unsigned int v73; 
  __int64 v74; 
  const WeaponAttachment *v75; 
  AttachmentType type; 
  int fireTimeAkimboOverride; 
  const WeaponAttachment *v79; 
  AttachmentType v80; 
  int v81; 
  const WeaponAttachment *v83; 
  AttachmentType v84; 
  int v85; 
  const WeaponAttachment *v87; 
  AttachmentType v88; 
  int v89; 
  WeaponAttachment **v91; 
  __int64 i; 
  WeaponAttachment *v93; 
  AttachmentType v94; 
  int v95; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v99; 
  const PlayerEquippedWeaponState *v108; 
  bool v109; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned int v140; 
  unsigned int v141; 
  WeaponAttachment **v142; 
  HyperBurstInfo *hyperBurstInfo; 
  const WeaponDef *v144; 
  int v145; 
  int v152; 
  __int64 numAttachmentSlots; 
  float rateofFire; 
  PlayerHandIndex handa; 
  int *v165; 
  WeaponAttachment *attachments; 
  char v167; 
  WeaponAttachment *v168[30]; 
  unsigned __int8 attachmentIds[32]; 
  unsigned __int8 v170[32]; 
  char v171; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  _R14 = ps;
  handa = hand;
  v165 = fireTime;
  if ( !fireTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9544, ASSERT_TYPE_ASSERT, "(fireTime)", (const char *)&queryFormat, "fireTime") )
    __debugbreak();
  if ( !fireDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9545, ASSERT_TYPE_ASSERT, "(fireDelay)", (const char *)&queryFormat, "fireDelay") )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(numAttachmentSlots) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9546, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", numAttachmentSlots, 2) )
      __debugbreak();
  }
  if ( _R14 && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9551, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RBX = _RAX;
  __asm { vxorps  xmm10, xmm10, xmm10 }
  if ( isDualWielding )
  {
    *fireTime = _RAX->iFireTimeAkimbo;
    __asm { vucomiss xmm10, dword ptr [rax+1118h] }
    v22 = !isDualWielding;
    v23 = _RAX->changedFireTimeNumBullets == 0;
    v24 = v22 == v23;
    if ( v22 != v23 )
    {
      v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9560, ASSERT_TYPE_ASSERT, "((weapDef->changedFireTimeAkimbo == 0) == (weapDef->changedFireTimeNumBullets == 0))", (const char *)&queryFormat, "(weapDef->changedFireTimeAkimbo == 0) == (weapDef->changedFireTimeNumBullets == 0)");
      v24 = !v25;
      if ( v25 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm2, dword ptr [rbx+1118h]
      vucomiss xmm2, xmm10
    }
    _EDX = shotCount;
    __asm { vmovss  xmm9, cs:__real@3f800000 }
    if ( !v24 )
    {
      if ( _RBX->changedFireTimeNumBullets )
      {
        _ECX = _RBX->iFireTimeAkimbo;
        __asm
        {
          vmulss  xmm2, xmm2, cs:__real@447a0000
          vmovd   xmm0, eax
          vcvtdq2ps xmm0, xmm0
          vmovd   xmm1, edx
          vcvtdq2ps xmm1, xmm1
          vdivss  xmm1, xmm1, xmm0
          vminss  xmm3, xmm1, xmm9
          vmovd   xmm0, ecx
          vcvtdq2ps xmm0, xmm0
          vsubss  xmm1, xmm2, xmm0
          vmulss  xmm2, xmm3, xmm1
          vaddss  xmm3, xmm2, cs:__real@3f000000
          vcvttss2si eax, xmm3
        }
        v44 = _ECX + _EAX;
        if ( v44 < 50 )
          v44 = 50;
        *fireTime = v44;
      }
    }
    iFireDelayAkimbo = _RBX->iFireDelayAkimbo;
  }
  else
  {
    *fireTime = _RAX->iFireTime;
    __asm { vucomiss xmm10, dword ptr [rbx+1114h] }
    v46 = _RAX->changedFireTimeNumBullets == 0;
    v47 = v46;
    if ( !v46 )
    {
      v48 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9574, ASSERT_TYPE_ASSERT, "((weapDef->changedFireTime == 0) == (weapDef->changedFireTimeNumBullets == 0))", (const char *)&queryFormat, "(weapDef->changedFireTime == 0) == (weapDef->changedFireTimeNumBullets == 0)");
      v47 = !v48;
      if ( v48 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm2, dword ptr [rbx+1114h]
      vucomiss xmm2, xmm10
    }
    _EDX = shotCount;
    __asm { vmovss  xmm9, cs:__real@3f800000 }
    if ( !v47 )
    {
      if ( _RBX->changedFireTimeNumBullets )
      {
        _ECX = _RBX->iFireTime;
        __asm
        {
          vmulss  xmm2, xmm2, cs:__real@447a0000
          vmovd   xmm0, eax
          vcvtdq2ps xmm0, xmm0
          vmovd   xmm1, edx
          vcvtdq2ps xmm1, xmm1
          vdivss  xmm1, xmm1, xmm0
          vminss  xmm3, xmm1, xmm9
          vmovd   xmm0, ecx
          vcvtdq2ps xmm0, xmm0
          vsubss  xmm1, xmm2, xmm0
          vmulss  xmm2, xmm3, xmm1
          vaddss  xmm3, xmm2, cs:__real@3f000000
          vcvttss2si eax, xmm3
        }
        v66 = _ECX + _EAX;
        if ( v66 < 50 )
          v66 = 50;
        *fireTime = v66;
      }
    }
    iFireDelayAkimbo = _RBX->iFireDelay;
  }
  *fireDelay = iFireDelayAkimbo;
  fireTimeOverride = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vmovaps xmm8, xmm9 }
  v70 = 0i64;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponAttachments_Internal >= 4 )
  {
    v72 = &v167;
    v73 = ((WeaponAttachments_Internal - 4) >> 2) + 1;
    v74 = v73;
    v70 = 4 * v73;
    do
    {
      v75 = (const WeaponAttachment *)*((_QWORD *)v72 - 1);
      if ( !v75 )
        goto LABEL_47;
      if ( !fireTimeOverride )
      {
        type = v75->type;
        if ( isDualWielding )
        {
          fireTimeAkimboOverride = v75->fireTimeAkimboOverride;
          if ( fireTimeAkimboOverride && (type != ATTACHMENT_UNDERBARREL || WeaponPrimaryAttachment == v75) )
          {
LABEL_41:
            fireTimeOverride = fireTimeAkimboOverride;
            goto LABEL_47;
          }
        }
        else
        {
          fireTimeAkimboOverride = v75->fireTimeOverride;
          if ( fireTimeAkimboOverride )
          {
            if ( type != ATTACHMENT_UNDERBARREL )
              goto LABEL_41;
            if ( WeaponPrimaryAttachment == v75 )
            {
              fireTimeOverride = v75->fireTimeOverride;
              goto LABEL_47;
            }
          }
        }
      }
      __asm
      {
        vaddss  xmm0, xmm8, dword ptr [rax+2C4h]
        vsubss  xmm8, xmm0, xmm9
      }
LABEL_47:
      v79 = *(const WeaponAttachment **)v72;
      if ( !*(_QWORD *)v72 )
        goto LABEL_59;
      if ( !fireTimeOverride )
      {
        v80 = v79->type;
        if ( isDualWielding )
        {
          v81 = v79->fireTimeAkimboOverride;
          if ( v81 && (v80 != ATTACHMENT_UNDERBARREL || WeaponPrimaryAttachment == v79) )
          {
LABEL_53:
            fireTimeOverride = v81;
            goto LABEL_59;
          }
        }
        else
        {
          v81 = v79->fireTimeOverride;
          if ( v81 )
          {
            if ( v80 != ATTACHMENT_UNDERBARREL )
              goto LABEL_53;
            if ( WeaponPrimaryAttachment == v79 )
            {
              fireTimeOverride = v79->fireTimeOverride;
              goto LABEL_59;
            }
          }
        }
      }
      __asm
      {
        vaddss  xmm0, xmm8, dword ptr [rax+2C4h]
        vsubss  xmm8, xmm0, xmm9
      }
LABEL_59:
      v83 = (const WeaponAttachment *)*((_QWORD *)v72 + 1);
      if ( !v83 )
        goto LABEL_71;
      if ( !fireTimeOverride )
      {
        v84 = v83->type;
        if ( isDualWielding )
        {
          v85 = v83->fireTimeAkimboOverride;
          if ( v85 && (v84 != ATTACHMENT_UNDERBARREL || WeaponPrimaryAttachment == v83) )
          {
LABEL_65:
            fireTimeOverride = v85;
            goto LABEL_71;
          }
        }
        else
        {
          v85 = v83->fireTimeOverride;
          if ( v85 )
          {
            if ( v84 != ATTACHMENT_UNDERBARREL )
              goto LABEL_65;
            if ( WeaponPrimaryAttachment == v83 )
            {
              fireTimeOverride = v83->fireTimeOverride;
              goto LABEL_71;
            }
          }
        }
      }
      __asm
      {
        vaddss  xmm0, xmm8, dword ptr [rax+2C4h]
        vsubss  xmm8, xmm0, xmm9
      }
LABEL_71:
      v87 = (const WeaponAttachment *)*((_QWORD *)v72 + 2);
      if ( v87 )
      {
        if ( fireTimeOverride )
          goto LABEL_82;
        v88 = v87->type;
        if ( isDualWielding )
        {
          v89 = v87->fireTimeAkimboOverride;
          if ( !v89 || v88 == ATTACHMENT_UNDERBARREL && WeaponPrimaryAttachment != v87 )
          {
LABEL_82:
            __asm
            {
              vaddss  xmm0, xmm8, dword ptr [rax+2C4h]
              vsubss  xmm8, xmm0, xmm9
            }
            goto LABEL_83;
          }
LABEL_77:
          fireTimeOverride = v89;
          goto LABEL_83;
        }
        v89 = v87->fireTimeOverride;
        if ( !v89 )
          goto LABEL_82;
        if ( v88 != ATTACHMENT_UNDERBARREL )
          goto LABEL_77;
        if ( WeaponPrimaryAttachment != v87 )
          goto LABEL_82;
        fireTimeOverride = v87->fireTimeOverride;
      }
LABEL_83:
      v72 += 32;
      --v74;
    }
    while ( v74 );
  }
  if ( (unsigned int)v70 < WeaponAttachments_Internal )
  {
    v91 = &attachments + v70;
    for ( i = WeaponAttachments_Internal - (unsigned int)v70; i; --i )
    {
      v93 = *v91;
      if ( *v91 )
      {
        if ( fireTimeOverride )
          goto LABEL_97;
        v94 = v93->type;
        if ( isDualWielding )
        {
          v95 = v93->fireTimeAkimboOverride;
          if ( !v95 || v94 == ATTACHMENT_UNDERBARREL && WeaponPrimaryAttachment != v93 )
          {
LABEL_97:
            __asm
            {
              vaddss  xmm0, xmm8, dword ptr [rax+2C4h]
              vsubss  xmm8, xmm0, xmm9
            }
            goto LABEL_98;
          }
LABEL_92:
          fireTimeOverride = v95;
          goto LABEL_98;
        }
        v95 = v93->fireTimeOverride;
        if ( !v95 )
          goto LABEL_97;
        if ( v94 != ATTACHMENT_UNDERBARREL )
          goto LABEL_92;
        if ( WeaponPrimaryAttachment != v93 )
          goto LABEL_97;
        fireTimeOverride = v93->fireTimeOverride;
      }
LABEL_98:
      ++v91;
    }
  }
  if ( fireTimeOverride )
    *v165 = fireTimeOverride;
  if ( _R14 && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13633, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v99 = _R14 && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, _R14, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovss  xmm6, dword ptr [rbx+670h] }
  if ( BG_GetWeaponAdsSettings(r_weapon, isAlternate, v99, 0) )
    __asm { vmovss  xmm6, dword ptr [rax+0B0h] }
  __asm
  {
    vcmpeqss xmm0, xmm6, xmm10
    vblendvps xmm1, xmm6, xmm9, xmm0
    vmovss  [rsp+328h+rateofFire], xmm1
    vmovss  [rsp+328h+var_2D4], xmm1
  }
  BG_GameInterface_ModifyRateOfFireForWeapon(_R14, r_weapon, &rateofFire);
  __asm
  {
    vmovss  xmm1, [rsp+328h+rateofFire]
    vcmpneqss xmm0, xmm1, xmm10
    vblendvps xmm0, xmm9, xmm1, xmm0
    vmovss  [rsp+328h+var_2D4], xmm0
  }
  if ( !_R14 )
  {
    __asm { vmovaps xmm2, xmm9 }
    goto LABEL_126;
  }
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13687, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v109 = weaponMap && (v108 = BG_GetEquippedWeaponStateConst(weaponMap, _R14, r_weapon)) != NULL && v108->hybridScope;
  __asm { vmovss  xmm6, dword ptr [rbx+67Ch] }
  _RAX = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v109, 0);
  if ( _RAX )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rax+0BCh]
      vcmpneqss xmm0, xmm1, xmm10
      vblendvps xmm6, xmm6, xmm1, xmm0
    }
  }
  __asm { vucomiss xmm6, xmm10 }
  if ( _RAX )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [r14+730h]
      vmulss  xmm1, xmm0, xmm6
      vsubss  xmm0, xmm9, xmm0
      vaddss  xmm2, xmm1, xmm0
      vucomiss xmm2, xmm10
    }
LABEL_126:
    __asm
    {
      vmovss  xmm0, [rsp+328h+var_2D4]
      vmulss  xmm7, xmm0, xmm2
    }
    goto LABEL_127;
  }
  __asm { vmovss  xmm7, [rsp+328h+var_2D4] }
LABEL_127:
  if ( _R14 )
  {
    if ( _R14->fireTimeScale )
    {
      CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, _R14);
      if ( !memcmp_0(CurrentWeaponForPlayer, r_weapon, 0x3Cui64) )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmulss  xmm1, xmm0, cs:__real@3c23d70a
          vmulss  xmm7, xmm7, xmm1
        }
      }
    }
  }
  _R12 = v165;
  __asm
  {
    vmaxss  xmm2, xmm8, xmm10
    vsubss  xmm0, xmm9, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovd   xmm6, dword ptr [r12]
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm9, xmm0
    vsubss  xmm0, xmm9, xmm7
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm9, xmm2
    vcvtdq2ps xmm6, xmm6
    vmulss  xmm1, xmm0, xmm6
    vmulss  xmm0, xmm1, xmm5
    vcvttss2si eax, xmm0
  }
  *v165 = _EAX;
  if ( _R14 && adjustForHyperBurst )
  {
    v140 = 0;
    v141 = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)v168, v170, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( v141 )
    {
      v142 = v168;
      while ( 1 )
      {
        if ( !*v142 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22322, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        hyperBurstInfo = (*v142)->hyperBurstInfo;
        if ( hyperBurstInfo )
          break;
        ++v140;
        ++v142;
        if ( v140 >= v141 )
          goto LABEL_140;
      }
    }
    else
    {
LABEL_140:
      v144 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
      hyperBurstInfo = &v144->hyperBurstInfo;
      if ( v144 == (const WeaponDef *)-5272i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9660, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
        __debugbreak();
    }
    if ( hyperBurstInfo->enabled && (shotCount == 1 || !shotCount && BG_GetAmmoInClipForWeapon(_R14, r_weapon, isAlternate, handa) >= 2) )
    {
      v145 = *_R12;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, ebx
        vmulss  xmm2, xmm0, dword ptr [rdi]
        vxorps  xmm0, xmm0, xmm0
        vroundss xmm4, xmm0, xmm2, 1
        vcvttss2si edi, xmm4
      }
      if ( _EDI <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9684, ASSERT_TYPE_ASSERT, "( firstHyperRoundFireTime ) > ( 0 )", "%s > %s\n\t%i, %i", "firstHyperRoundFireTime", "0", _EDI, 0i64) )
        __debugbreak();
      v152 = v145 - _EDI;
      if ( shotCount )
        *_R12 = v152;
      else
        *_R12 = _EDI;
    }
  }
  _R11 = &v171;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
BG_GetFireTimerLerpToADSScale
==============
*/
float BG_GetFireTimerLerpToADSScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 

  _RDI = ps;
  if ( ps )
  {
    __asm { vmovaps [rsp+58h+var_28], xmm6 }
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13687, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
      __debugbreak();
    _RBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    v12 = weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, _RDI, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
    __asm { vmovss  xmm6, dword ptr [rbp+67Ch] }
    _RAX = BG_GetWeaponAdsSettings(r_weapon, isAlternate, v12, 0);
    __asm { vxorps  xmm0, xmm0, xmm0 }
    if ( _RAX )
    {
      __asm
      {
        vmovss  xmm2, dword ptr [rax+0BCh]
        vcmpneqss xmm1, xmm2, xmm0
        vblendvps xmm6, xmm6, xmm2, xmm1
      }
    }
    __asm { vucomiss xmm6, xmm0 }
    if ( _RAX )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rdi+730h]
        vmovss  xmm0, cs:__real@3f800000
        vmulss  xmm2, xmm1, xmm6
        vsubss  xmm1, xmm0, xmm1
        vaddss  xmm0, xmm2, xmm1
      }
    }
    __asm { vmovaps xmm6, [rsp+58h+var_28] }
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetFirstAvailableOffhandByClass
==============
*/
const Weapon *BG_GetFirstAvailableOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return BG_GetFirstEquippedOffhand(weaponMap, ps, OFFHAND_SLOT_NONE, offhandClass, 1);
}

/*
==============
BG_GetFirstAvailableOffhandBySlot
==============
*/
Weapon *BG_GetFirstAvailableOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  int OffhandClass; 

  OffhandClass = BG_GetOffhandClass(ps, slot, weaponMap);
  if ( slot == OFFHAND_SLOT_TAUNT || OffhandClass )
    return (Weapon *)BG_GetFirstEquippedOffhand(weaponMap, ps, slot, OffhandClass, 1);
  else
    return &NULL_WEAPON;
}

/*
==============
BG_GetFirstEquippedOffhand
==============
*/
Weapon *BG_GetFirstEquippedOffhand(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot, const int offhandClass, const int requiringAmmo)
{
  char v9; 
  unsigned int v11; 
  const Weapon *Weapon; 
  const WeaponDef *v13; 
  int EquippedWeaponIndex; 
  OffhandSlot *v15; 
  const char *WeaponName; 
  __int64 v17; 
  __int64 v18; 
  char output[1024]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2597, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2598, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned __int8)(slot - 4) <= 1u )
  {
    v9 = 1;
  }
  else
  {
    v9 = 0;
    if ( !offhandClass )
      return &NULL_WEAPON;
  }
  v11 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v11 >= 0xF )
    {
      LODWORD(v18) = 15;
      LODWORD(v17) = v11;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v17, v18) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v11]);
    if ( Weapon->weaponIdx )
    {
      v13 = BG_WeaponDefAtIndex(Weapon->weaponIdx);
      if ( v9 || v13->offhandClass == offhandClass )
      {
        if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1063, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
          __debugbreak();
        if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1064, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        EquippedWeaponIndex = BG_GetEquippedWeaponIndex(weaponMap, ps, Weapon);
        v15 = EquippedWeaponIndex < 0 ? (OffhandSlot *)10 : &ps->weapEquippedData[EquippedWeaponIndex].offhandSlot;
        if ( (slot == OFFHAND_SLOT_NONE || *v15 == slot) && (!requiringAmmo || slot == OFFHAND_SLOT_TAUNT || BG_GetAmmoInClipForWeapon(ps, Weapon, 0, WEAPON_HAND_DEFAULT) > 0 || offhandClass == 1 && ps->throwbackGrenadeTimeLeft > 0) )
          break;
      }
    }
    if ( (int)++v11 >= 15 )
      return &NULL_WEAPON;
  }
  if ( Weapon->weaponIdx && BG_WeaponDefAtIndex(Weapon->weaponIdx)->offhandClass == OFFHAND_CLASS_NONE )
  {
    WeaponName = BG_GetWeaponName(Weapon, output, 0x400u);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5008, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Weapon (%s) expected to be offhand weapon or no weapon at all, but is not.", WeaponName) )
      __debugbreak();
  }
  return (Weapon *)Weapon;
}

/*
==============
BG_GetFirstEquippedOffhandByClass
==============
*/
Weapon *BG_GetFirstEquippedOffhandByClass(const BgWeaponMap *weaponMap, const playerState_s *ps, int offhandClass)
{
  return BG_GetFirstEquippedOffhand(weaponMap, ps, OFFHAND_SLOT_NONE, offhandClass, 0);
}

/*
==============
BG_GetFirstEquippedOffhandBySlot
==============
*/
Weapon *BG_GetFirstEquippedOffhandBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const OffhandSlot slot)
{
  int OffhandClass; 

  OffhandClass = BG_GetOffhandClass(ps, slot, weaponMap);
  if ( slot == OFFHAND_SLOT_TAUNT || OffhandClass )
    return BG_GetFirstEquippedOffhand(weaponMap, ps, slot, OffhandClass, 0);
  else
    return &NULL_WEAPON;
}

/*
==============
BG_GetFirstEquippedWeaponBySlot
==============
*/
Weapon *BG_GetFirstEquippedWeaponBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  unsigned int i; 
  const Weapon *Weapon; 
  const WeaponDef *v8; 
  int EquippedWeaponIndex; 
  __int64 p_slot; 
  weapInventoryType_t inventoryType; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4824, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4825, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  for ( i = 0; i < 0xF; ++i )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[i]);
    if ( Weapon->weaponIdx )
    {
      v8 = BG_WeaponDefAtIndex(Weapon->weaponIdx);
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1089, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1090, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( Weapon->weaponIdx && (EquippedWeaponIndex = BG_GetEquippedWeaponIndex(weaponMap, ps, Weapon), EquippedWeaponIndex >= 0) )
        p_slot = (__int64)&ps->weapEquippedData[EquippedWeaponIndex].slot;
      else
        p_slot = 12i64;
      inventoryType = v8->inventoryType;
      if ( (inventoryType == WEAPINVENTORY_PRIMARY || inventoryType == WEAPINVENTORY_MODEL_ONLY) && *(_DWORD *)p_slot == slot )
        return (Weapon *)Weapon;
    }
  }
  return &NULL_WEAPON;
}

/*
==============
BG_GetFootstepFromAnim
==============
*/
__int64 BG_GetFootstepFromAnim(weapAnimFiles_t animIndex)
{
  __int64 result; 
  int v4; 

  if ( (unsigned int)animIndex >= NUM_WEAP_ANIMS )
  {
    v4 = 614;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21746, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", animIndex, v4) )
      __debugbreak();
  }
  result = 0i64;
  while ( FootstepToAnimMap[result] != animIndex )
  {
    if ( (unsigned __int64)++result >= 9 )
      return 0xFFFFFFFFi64;
  }
  return result;
}

/*
==============
BG_GetFootstepFromGesture
==============
*/
__int64 BG_GetFootstepFromGesture(gestureAnimType_t gestureIndex)
{
  __int64 result; 
  int v4; 

  if ( (unsigned int)gestureIndex >= GESTUREANIMTYPE_NUM )
  {
    v4 = 54;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21762, ASSERT_TYPE_ASSERT, "(unsigned)( gestureIndex ) < (unsigned)( GESTUREANIMTYPE_NUM )", "gestureIndex doesn't index GESTUREANIMTYPE_NUM\n\t%i not in [0, %i)", gestureIndex, v4) )
      __debugbreak();
  }
  result = 9i64;
  while ( FootstepToAnimMap[result] != gestureIndex )
  {
    if ( (unsigned __int64)++result >= 0xD )
      return 0xFFFFFFFFi64;
  }
  return result;
}

/*
==============
BG_GetFreeEquipSlot
==============
*/
__int64 BG_GetFreeEquipSlot(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  unsigned int v4; 
  __int64 v6; 
  __int64 v7; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6857, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6858, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = 0;
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v4 >= 0xF )
    {
      LODWORD(v7) = 15;
      LODWORD(v6) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( !BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v4])->weaponIdx )
      break;
    if ( (int)++v4 >= 15 )
      return 0xFFFFFFFFi64;
  }
  return v4;
}

/*
==============
BG_GetFriendlyLaserType
==============
*/
const LaserDef *BG_GetFriendlyLaserType(const Weapon *r_weapon, const bool isPlayerView, const bool isBeamDraw)
{
  const WeaponDef *v6; 
  const LaserDef *result; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  LaserDef *enemyLaser; 
  LaserDef *friendlyLaser; 
  LaserDef *viewModelLaserAlt; 
  LaserDef *viewModelLaser; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !isBeamDraw && v6->tracerStyle == TRACERSTYLE_BEAM )
    return 0i64;
  viewModelLaser = NULL;
  viewModelLaserAlt = NULL;
  friendlyLaser = NULL;
  enemyLaser = NULL;
  BG_GetLasers(r_weapon, (const LaserDef **)&viewModelLaser, (const LaserDef **)&viewModelLaserAlt, (const LaserDef **)&friendlyLaser, (const LaserDef **)&enemyLaser);
  if ( !isPlayerView )
    goto LABEL_9;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( WeaponPrimaryAttachment && WeaponPrimaryAttachment->useAlternateViewModelLaser )
    return viewModelLaserAlt;
  result = viewModelLaser;
  if ( !viewModelLaser )
  {
LABEL_9:
    result = enemyLaser;
    if ( friendlyLaser )
      return friendlyLaser;
  }
  return result;
}

/*
==============
BG_GetGameDefaultWeaponAnim
==============
*/
XAnimParts *BG_GetGameDefaultWeaponAnim(int animIndex)
{
  return 0i64;
}

/*
==============
BG_GetGrenadeDangerIconDistance
==============
*/

float __fastcall BG_GetGrenadeDangerIconDistance(const Weapon *r_weapon, bool isAlternate, double defaultValue)
{
  unsigned __int16 weaponIdx; 
  unsigned int v12; 
  unsigned int WeaponAttachments_Internal; 
  bool v15; 
  WeaponAttachment **v16; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-28h], xmm6 }
  weaponIdx = r_weapon->weaponIdx;
  __asm
  {
    vmovaps xmmword ptr [r11-38h], xmm7
    vmovaps xmm7, xmm2
  }
  _RAX = BG_WeaponDefAtIndex(weaponIdx);
  v12 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+12ECh] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v15 = 0;
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    while ( 1 )
    {
      if ( !*v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20048, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (*v16)->ui;
      v15 = 0;
      if ( _RCX )
        break;
      ++v12;
      ++v16;
      v15 = v12 < WeaponAttachments_Internal;
      if ( v12 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
    __asm { vmovss  xmm6, dword ptr [rcx+5Ch] }
  }
LABEL_10:
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcmpltss xmm0, xmm6, xmm1
    vblendvps xmm6, xmm6, xmm7, xmm0
    vcomiss xmm6, xmm1
    vmovaps xmm7, [rsp+1A8h+var_38]
  }
  if ( v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20062, ASSERT_TYPE_ASSERT, "(distance >= 0.f)", (const char *)&queryFormat, "distance >= 0.f") )
    __debugbreak();
  __asm
  {
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+1A8h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetGrenadePrimeReadyToThrowTime
==============
*/
void BG_GetGrenadePrimeReadyToThrowTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  int v8; 

  v8 = BG_PlayerDualWielding(ps);
  *time = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, v8 != 0, 18i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetGrenadePrimeTime
==============
*/
void BG_GetGrenadePrimeTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int *time)
{
  int v10; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10154, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10155, ASSERT_TYPE_ASSERT, "(time)", (const char *)&queryFormat, "time") )
    __debugbreak();
  v10 = BG_PlayerDualWielding(ps);
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, v10 != 0, 188i64, NUM_WEAP_ANIMS);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, ecx
  }
  *(double *)&_XMM0 = BG_GetCookingGrenadeScaleTime(ps);
  __asm
  {
    vdivss  xmm1, xmm6, xmm0
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vmovaps xmm6, [rsp+48h+var_18]
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm1, xmm0, xmm3, 1
    vcvttss2si eax, xmm1
  }
  *time = _EAX;
}

/*
==============
BG_GetGunKickMaxAngles
==============
*/
void BG_GetGunKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **i; 
  AttGunKick *AttachmentGunKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *outMaxAngles = *(vec2_t *)&BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fGunMaxPitch;
  if ( WeaponAttachments_Internal )
  {
    for ( i = (const WeaponAttachment **)attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20835, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *i, v11);
      if ( AttachmentGunKick )
        break;
      if ( ++v8 >= WeaponAttachments_Internal )
        return;
    }
    *outMaxAngles = *(vec2_t *)&AttachmentGunKick->gunMaxPitch;
  }
}

/*
==============
BG_GetGunKickSpeed
==============
*/
void BG_GetGunKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickAccel, float *hipGunKickSpeedMax, float *hipGunKickSpeedDecay, float *hipGunKickStaticDecay, float *hipGunKickReturnAccelScale, float *hipGunKickReturnSpeedCurveScale, float *adsGunKickAccel, float *adsGunKickSpeedMax, float *adsGunKickSpeedDecay, float *adsGunKickStaticDecay, float *adsGunKickReturnAccelScale, float *adsGunKickReturnSpeedCurveScale)
{
  const BgWeaponMap *v21; 
  bool v23; 
  const Weapon *v24; 
  const WeaponDef *v25; 
  unsigned int v26; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v28; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v33; 
  __int64 v35; 
  WeaponAttachment **v36; 
  const Weapon *v37; 
  bool v39; 
  bool v40; 
  const dvar_t *v41; 
  ContextMountType type; 
  const WeaponAttachment **v55; 
  AttGunKick *AttachmentGunKick; 
  unsigned int v91; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v96; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  v21 = weaponMap;
  _R13 = ps;
  v23 = isAlternate;
  v24 = r_weapon;
  if ( !hipGunKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14685, ASSERT_TYPE_ASSERT, "(hipGunKickAccel)", (const char *)&queryFormat, "hipGunKickAccel") )
    __debugbreak();
  if ( !hipGunKickSpeedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14686, ASSERT_TYPE_ASSERT, "(hipGunKickSpeedMax)", (const char *)&queryFormat, "hipGunKickSpeedMax") )
    __debugbreak();
  if ( !hipGunKickSpeedDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14687, ASSERT_TYPE_ASSERT, "(hipGunKickSpeedDecay)", (const char *)&queryFormat, "hipGunKickSpeedDecay") )
    __debugbreak();
  if ( !hipGunKickStaticDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14688, ASSERT_TYPE_ASSERT, "(hipGunKickStaticDecay)", (const char *)&queryFormat, "hipGunKickStaticDecay") )
    __debugbreak();
  if ( !adsGunKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14689, ASSERT_TYPE_ASSERT, "(adsGunKickAccel)", (const char *)&queryFormat, "adsGunKickAccel") )
    __debugbreak();
  if ( !adsGunKickSpeedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14690, ASSERT_TYPE_ASSERT, "(adsGunKickSpeedMax)", (const char *)&queryFormat, "adsGunKickSpeedMax") )
    __debugbreak();
  if ( !adsGunKickSpeedDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14691, ASSERT_TYPE_ASSERT, "(adsGunKickSpeedDecay)", (const char *)&queryFormat, "adsGunKickSpeedDecay") )
    __debugbreak();
  if ( !adsGunKickStaticDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14692, ASSERT_TYPE_ASSERT, "(adsGunKickStaticDecay)", (const char *)&queryFormat, "adsGunKickStaticDecay") )
    __debugbreak();
  if ( !hipGunKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14693, ASSERT_TYPE_ASSERT, "(hipGunKickReturnAccelScale)", (const char *)&queryFormat, "hipGunKickReturnAccelScale") )
    __debugbreak();
  if ( !hipGunKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14694, ASSERT_TYPE_ASSERT, "(hipGunKickReturnSpeedCurveScale)", (const char *)&queryFormat, "hipGunKickReturnSpeedCurveScale") )
    __debugbreak();
  if ( !adsGunKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14695, ASSERT_TYPE_ASSERT, "(adsGunKickReturnAccelScale)", (const char *)&queryFormat, "adsGunKickReturnAccelScale") )
    __debugbreak();
  if ( !adsGunKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14696, ASSERT_TYPE_ASSERT, "(adsGunKickReturnSpeedCurveScale)", (const char *)&queryFormat, "adsGunKickReturnSpeedCurveScale") )
    __debugbreak();
  v25 = BG_WeaponDefAtIndex(v24->weaponIdx);
  *hipGunKickAccel = v25->fHipGunKickAccel;
  *hipGunKickSpeedMax = v25->fHipGunKickSpeedMax;
  *hipGunKickSpeedDecay = v25->fHipGunKickSpeedDecay;
  *hipGunKickStaticDecay = v25->fHipGunKickStaticDecay;
  v26 = 0;
  *adsGunKickAccel = v25->fAdsGunKickAccel;
  *adsGunKickSpeedMax = v25->fAdsGunKickSpeedMax;
  *adsGunKickSpeedDecay = v25->fAdsGunKickSpeedDecay;
  *adsGunKickStaticDecay = v25->fAdsGunKickStaticDecay;
  *hipGunKickReturnAccelScale = v25->hipGunKickReturnAccelScale;
  *hipGunKickReturnSpeedCurveScale = v25->hipGunKickReturnSpeedCurveScale;
  *adsGunKickReturnAccelScale = v25->adsGunKickReturnAccelScale;
  *adsGunKickReturnSpeedCurveScale = v25->adsGunKickReturnSpeedCurveScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v24, v23, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v28 = WeaponAttachments_Internal;
  v91 = WeaponAttachments_Internal;
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm8, xmm7
    vmovaps xmm6, xmm7
  }
  v33 = _R13 && v21 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v21, _R13, v24)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vxorps  xmm9, xmm9, xmm9 }
  if ( (_DWORD)v28 )
  {
    v35 = v28;
    v36 = attachments;
    v37 = v24;
    do
    {
      _RDI = BG_GetOverrideAttachmentWhenApplicable(v21, _R13, v37, isAlternate, *v36, v33);
      v39 = _RDI == NULL;
      if ( !_RDI )
      {
        v40 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14720, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v39 = !v40;
        if ( v40 )
          __debugbreak();
      }
      __asm { vucomiss xmm9, dword ptr [rdi+2F8h] }
      if ( !v39 )
      {
        v41 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v41);
        v39 = !v41->current.enabled;
        v21 = weaponMap;
        __asm { vmovss  xmm0, dword ptr [rdi+2F8h] }
        if ( v39 )
        {
          __asm
          {
            vaddss  xmm0, xmm8, xmm0
            vsubss  xmm8, xmm0, xmm7
          }
        }
        else
        {
          __asm { vmulss  xmm6, xmm6, xmm0 }
        }
      }
      ++v36;
      --v35;
    }
    while ( v35 );
    LODWORD(v28) = v91;
    v26 = 0;
    v24 = r_weapon;
    v23 = isAlternate;
  }
  type = _R13->mountState.surface.type;
  _RAX = BG_WeaponDefAtIndex(v24->weaponIdx);
  _RCX = _RAX;
  if ( !_RAX )
    goto LABEL_57;
  if ( type == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm1, dword ptr [rax+131Ch] }
  }
  else
  {
    if ( (unsigned int)(type - 2) > 1 )
    {
LABEL_57:
      __asm { vmovaps xmm1, xmm7 }
      goto LABEL_62;
    }
    __asm { vmovss  xmm1, dword ptr [rcx+1354h] }
  }
LABEL_62:
  __asm
  {
    vmovss  xmm0, dword ptr [r13+4C0h]
    vmulss  xmm1, xmm0, xmm1
    vsubss  xmm0, xmm7, xmm0
    vaddss  xmm1, xmm1, xmm0
    vmulss  xmm6, xmm6, xmm1
  }
  if ( (_DWORD)v28 )
  {
    v55 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v55 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14740, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, _R13, v24, v23, *v55, v33);
      if ( AttachmentGunKick )
        break;
      ++v26;
      ++v55;
      if ( v26 >= (unsigned int)v28 )
        goto LABEL_69;
    }
    _R8 = hipGunKickSpeedDecay;
    _R9 = hipGunKickStaticDecay;
    _R10 = adsGunKickAccel;
    *hipGunKickAccel = AttachmentGunKick->hipGunKickAccel;
    _RDX = hipGunKickSpeedMax;
    *hipGunKickSpeedMax = AttachmentGunKick->hipGunKickSpeedMax;
    *hipGunKickSpeedDecay = AttachmentGunKick->hipGunKickSpeedDecay;
    *hipGunKickStaticDecay = AttachmentGunKick->hipGunKickStaticDecay;
    *adsGunKickAccel = AttachmentGunKick->adsGunKickAccel;
    *adsGunKickSpeedMax = AttachmentGunKick->adsGunKickSpeedMax;
    *adsGunKickSpeedDecay = AttachmentGunKick->adsGunKickSpeedDecay;
    *adsGunKickStaticDecay = AttachmentGunKick->adsGunKickStaticDecay;
    *hipGunKickReturnAccelScale = AttachmentGunKick->hipGunKickReturnAccelScale;
    *hipGunKickReturnSpeedCurveScale = AttachmentGunKick->hipGunKickReturnSpeedCurveScale;
    *adsGunKickReturnAccelScale = AttachmentGunKick->adsGunKickReturnAccelScale;
    *adsGunKickReturnSpeedCurveScale = AttachmentGunKick->adsGunKickReturnSpeedCurveScale;
  }
  else
  {
LABEL_69:
    _R10 = adsGunKickAccel;
    _R9 = hipGunKickStaticDecay;
    _R8 = hipGunKickSpeedDecay;
    _RDX = hipGunKickSpeedMax;
  }
  _RAX = hipGunKickAccel;
  __asm
  {
    vmaxss  xmm2, xmm8, xmm9
    vsubss  xmm0, xmm7, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm7, xmm0
    vsubss  xmm0, xmm7, xmm6
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm6, xmm7, xmm2
    vmulss  xmm2, xmm0, xmm5
    vmulss  xmm0, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
    vmulss  xmm1, xmm2, dword ptr [rdx]
  }
  _RAX = adsGunKickSpeedMax;
  __asm
  {
    vmovss  dword ptr [rdx], xmm1
    vmulss  xmm0, xmm2, dword ptr [r8]
    vmovss  dword ptr [r8], xmm0
    vmulss  xmm1, xmm2, dword ptr [r9]
    vmovss  dword ptr [r9], xmm1
    vmulss  xmm0, xmm2, dword ptr [r10]
    vmovss  dword ptr [r10], xmm0
    vmulss  xmm1, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = adsGunKickSpeedDecay;
  __asm
  {
    vmulss  xmm0, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = adsGunKickStaticDecay;
  __asm
  {
    vmulss  xmm1, xmm2, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _R11 = &v96;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
BG_GetGunKickYawAndPitch
==============
*/
void BG_GetGunKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunKickPitchMin, float *hipGunKickPitchMax, float *hipGunKickYawMin, float *hipGunKickYawMax, float *hipGunKickMagMin, float *adsGunKickPitchMin, float *adsGunKickPitchMax, float *adsGunKickYawMin, float *adsGunKickYawMax, float *adsGunKickMagMin)
{
  EffectiveStance EffectiveStance; 
  __int64 v25; 
  unsigned int v29; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v33; 
  __int64 v34; 
  WeaponAttachment **v35; 
  WeaponAttachment *v36; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v47; 
  const WeaponAttachment **v48; 
  AttGunKick *AttachmentGunKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v66; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _R13 = ps;
  _RSI = adsGunKickPitchMin;
  _RBP = adsGunKickPitchMax;
  if ( !hipGunKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14575, ASSERT_TYPE_ASSERT, "(hipGunKickPitchMin)", (const char *)&queryFormat, "hipGunKickPitchMin") )
    __debugbreak();
  if ( !hipGunKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14576, ASSERT_TYPE_ASSERT, "(hipGunKickPitchMax)", (const char *)&queryFormat, "hipGunKickPitchMax") )
    __debugbreak();
  if ( !hipGunKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14577, ASSERT_TYPE_ASSERT, "(hipGunKickYawMin)", (const char *)&queryFormat, "hipGunKickYawMin") )
    __debugbreak();
  if ( !hipGunKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14578, ASSERT_TYPE_ASSERT, "(hipGunKickYawMax)", (const char *)&queryFormat, "hipGunKickYawMax") )
    __debugbreak();
  if ( !hipGunKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14579, ASSERT_TYPE_ASSERT, "(hipGunKickMagMin)", (const char *)&queryFormat, "hipGunKickMagMin") )
    __debugbreak();
  if ( !adsGunKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14580, ASSERT_TYPE_ASSERT, "(adsGunKickPitchMin)", (const char *)&queryFormat, "adsGunKickPitchMin") )
    __debugbreak();
  if ( !adsGunKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14581, ASSERT_TYPE_ASSERT, "(adsGunKickPitchMax)", (const char *)&queryFormat, "adsGunKickPitchMax") )
    __debugbreak();
  if ( !adsGunKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14582, ASSERT_TYPE_ASSERT, "(adsGunKickYawMin)", (const char *)&queryFormat, "adsGunKickYawMin") )
    __debugbreak();
  if ( !adsGunKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14583, ASSERT_TYPE_ASSERT, "(adsGunKickYawMax)", (const char *)&queryFormat, "adsGunKickYawMax") )
    __debugbreak();
  if ( !adsGunKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14584, ASSERT_TYPE_ASSERT, "(adsGunKickMagMin)", (const char *)&queryFormat, "adsGunKickMagMin") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipGunKickPitchMin = _RBX->fHipGunKickPitchMin;
  *hipGunKickPitchMax = _RBX->fHipGunKickPitchMax;
  *hipGunKickYawMin = _RBX->fHipGunKickYawMin;
  *hipGunKickYawMax = _RBX->fHipGunKickYawMax;
  *hipGunKickMagMin = _RBX->fHipGunKickMagMin;
  *adsGunKickPitchMin = _RBX->fAdsGunKickPitchMin;
  *adsGunKickPitchMax = _RBX->fAdsGunKickPitchMax;
  *adsGunKickYawMin = _RBX->fAdsGunKickYawMin;
  *adsGunKickYawMax = _RBX->fAdsGunKickYawMax;
  *adsGunKickMagMin = _RBX->fAdsGunKickMagMin;
  EffectiveStance = PM_GetEffectiveStance(_R13);
  __asm { vmovss  xmm7, cs:__real@3f800000 }
  v25 = EffectiveStance;
  __asm { vmovaps xmm8, xmm7 }
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    __asm { vmovss  xmm8, dword ptr [rbx+4D0h] }
  }
  else if ( EffectiveStance == PM_EFF_STANCE_PRONE )
  {
    __asm { vmovss  xmm8, dword ptr [rbx+4D8h] }
  }
  v29 = 0;
  __asm { vmovaps xmm6, xmm7 }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v33 = v25;
    v34 = WeaponAttachments_Internal;
    v35 = attachments;
    while ( 1 )
    {
      v36 = *v35;
      if ( !*v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14617, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !v36->adsStanceScales )
        goto LABEL_46;
      if ( v33 == 2 )
        break;
      if ( v33 == 1 )
      {
        __asm { vaddss  xmm0, xmm6, dword ptr [rax+0Ch] }
        goto LABEL_45;
      }
LABEL_46:
      ++v35;
      if ( !--v34 )
      {
        v29 = 0;
        _RSI = adsGunKickPitchMin;
        _RBP = adsGunKickPitchMax;
        goto LABEL_48;
      }
    }
    __asm { vaddss  xmm0, xmm6, dword ptr [rax+4] }
LABEL_45:
    __asm { vsubss  xmm6, xmm0, xmm7 }
    goto LABEL_46;
  }
LABEL_48:
  __asm
  {
    vxorps  xmm4, xmm4, xmm4
    vcomiss xmm4, dword ptr [r13+4C0h]
    vmaxss  xmm3, xmm6, xmm4
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmulss  xmm6, xmm0, xmm8
  }
  v47 = weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, _R13, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( WeaponAttachments_Internal )
  {
    v48 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v48 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14648, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, _R13, r_weapon, isAlternate, *v48, v47);
      if ( AttachmentGunKick )
        break;
      ++v29;
      ++v48;
      if ( v29 >= WeaponAttachments_Internal )
        goto LABEL_59;
    }
    _R8 = adsGunKickYawMax;
    *hipGunKickPitchMin = AttachmentGunKick->hipGunKickPitchMin;
    *hipGunKickPitchMax = AttachmentGunKick->hipGunKickPitchMax;
    *hipGunKickYawMin = AttachmentGunKick->hipGunKickYawMin;
    *hipGunKickYawMax = AttachmentGunKick->hipGunKickYawMax;
    *hipGunKickMagMin = AttachmentGunKick->hipGunKickMagMin;
    _RDX = adsGunKickYawMin;
    *_RSI = AttachmentGunKick->adsGunKickPitchMin;
    *_RBP = AttachmentGunKick->adsGunKickPitchMax;
    *adsGunKickYawMin = AttachmentGunKick->adsGunKickYawMin;
    *adsGunKickYawMax = AttachmentGunKick->adsGunKickYawMax;
    _RCX = adsGunKickMagMin;
    *adsGunKickMagMin = AttachmentGunKick->adsGunKickMagMin;
  }
  else
  {
LABEL_59:
    _RCX = adsGunKickMagMin;
    _R8 = adsGunKickYawMax;
    _RDX = adsGunKickYawMin;
  }
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm0
    vmulss  xmm1, xmm6, dword ptr [rbp+0]
    vmovss  dword ptr [rbp+0], xmm1
    vmulss  xmm0, xmm6, dword ptr [rdx]
    vmovss  dword ptr [rdx], xmm0
    vmulss  xmm1, xmm6, dword ptr [r8]
    vmovss  dword ptr [r8], xmm1
    vmulss  xmm0, xmm6, dword ptr [rcx]
    vmovss  dword ptr [rcx], xmm0
  }
  _R11 = &v66;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
BG_GetGunTiltYawPitchAndRoll
==============
*/
void BG_GetGunTiltYawPitchAndRoll(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipGunTiltPitchFactor, float *hipGunTiltYawFactor, float *hipGunTiltRollFactor, float *hipGunTiltOffset, float *adsGunTiltPitchFactor, float *adsGunTiltYawFactor, float *adsGunTiltRollFactor, float *adsGunTiltOffset)
{
  const WeaponDef *v20; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v22; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v26; 
  WeaponAttachment **v28; 
  __int64 v29; 
  bool v31; 
  bool v32; 
  unsigned int v35; 
  const playerState_s *v36; 
  WeaponAttachment **v37; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  AttGunTilt *gunTilt; 
  unsigned int v63; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v67; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14364, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !hipGunTiltPitchFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14365, ASSERT_TYPE_ASSERT, "(hipGunTiltPitchFactor)", (const char *)&queryFormat, "hipGunTiltPitchFactor") )
    __debugbreak();
  if ( !hipGunTiltYawFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14366, ASSERT_TYPE_ASSERT, "(hipGunTiltYawFactor)", (const char *)&queryFormat, "hipGunTiltYawFactor") )
    __debugbreak();
  if ( !hipGunTiltRollFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14367, ASSERT_TYPE_ASSERT, "(hipGunTiltRollFactor)", (const char *)&queryFormat, "hipGunTiltRollFactor") )
    __debugbreak();
  if ( !hipGunTiltOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14368, ASSERT_TYPE_ASSERT, "(hipGunTiltOffset)", (const char *)&queryFormat, "hipGunTiltOffset") )
    __debugbreak();
  if ( !adsGunTiltPitchFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14369, ASSERT_TYPE_ASSERT, "(adsGunTiltPitchFactor)", (const char *)&queryFormat, "adsGunTiltPitchFactor") )
    __debugbreak();
  if ( !adsGunTiltYawFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14370, ASSERT_TYPE_ASSERT, "(adsGunTiltYawFactor)", (const char *)&queryFormat, "adsGunTiltYawFactor") )
    __debugbreak();
  if ( !adsGunTiltRollFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14371, ASSERT_TYPE_ASSERT, "(adsGunTiltRollFactor)", (const char *)&queryFormat, "adsGunTiltRollFactor") )
    __debugbreak();
  if ( !adsGunTiltOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14372, ASSERT_TYPE_ASSERT, "(adsGunTiltOffset)", (const char *)&queryFormat, "adsGunTiltOffset") )
    __debugbreak();
  v20 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipGunTiltPitchFactor = v20->hipGunTiltPitchFactor;
  *hipGunTiltYawFactor = v20->hipGunTiltYawFactor;
  *hipGunTiltRollFactor = v20->hipGunTiltRollFactor;
  *hipGunTiltOffset = v20->hipGunTiltOffset;
  *adsGunTiltPitchFactor = v20->adsGunTiltPitchFactor;
  *adsGunTiltYawFactor = v20->adsGunTiltYawFactor;
  *adsGunTiltRollFactor = v20->adsGunTiltRollFactor;
  *adsGunTiltOffset = v20->adsGunTiltOffset;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v22 = WeaponAttachments_Internal;
  v63 = WeaponAttachments_Internal;
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vmovaps xmm6, xmm8
  }
  v26 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( !(_DWORD)v22 )
    goto LABEL_48;
  v28 = attachments;
  v29 = v22;
  do
  {
    _RDI = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v28, v26);
    v31 = _RDI == NULL;
    if ( !_RDI )
    {
      v32 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14392, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
      v31 = !v32;
      if ( v32 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+2FCh]
      vucomiss xmm0, xmm7
    }
    if ( !v31 )
    {
      __asm
      {
        vaddss  xmm0, xmm0, xmm6
        vsubss  xmm6, xmm0, xmm8
      }
    }
    ++v28;
    --v29;
  }
  while ( v29 );
  v35 = 0;
  v36 = ps;
  if ( v63 )
  {
    v37 = attachments;
    while ( 1 )
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, v36, r_weapon, isAlternate, *v37, v26);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14403, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      gunTilt = OverrideAttachmentWhenApplicable->gunTilt;
      if ( gunTilt )
        break;
      v36 = ps;
      ++v35;
      ++v37;
      if ( v35 >= v63 )
        goto LABEL_48;
    }
    _RDX = hipGunTiltPitchFactor;
    _R8 = hipGunTiltYawFactor;
    _R9 = hipGunTiltRollFactor;
    _R10 = adsGunTiltPitchFactor;
    *hipGunTiltPitchFactor = gunTilt->hipGunTiltPitchFactor;
    *hipGunTiltYawFactor = OverrideAttachmentWhenApplicable->gunTilt->hipGunTiltYawFactor;
    *hipGunTiltRollFactor = OverrideAttachmentWhenApplicable->gunTilt->hipGunTiltRollFactor;
    *hipGunTiltOffset = OverrideAttachmentWhenApplicable->gunTilt->hipGunTiltOffset;
    *adsGunTiltPitchFactor = OverrideAttachmentWhenApplicable->gunTilt->adsGunTiltPitchFactor;
    *adsGunTiltYawFactor = OverrideAttachmentWhenApplicable->gunTilt->adsGunTiltYawFactor;
    *adsGunTiltRollFactor = OverrideAttachmentWhenApplicable->gunTilt->adsGunTiltRollFactor;
    *adsGunTiltOffset = OverrideAttachmentWhenApplicable->gunTilt->adsGunTiltOffset;
  }
  else
  {
LABEL_48:
    _R10 = adsGunTiltPitchFactor;
    _R9 = hipGunTiltRollFactor;
    _R8 = hipGunTiltYawFactor;
    _RDX = hipGunTiltPitchFactor;
  }
  _RAX = adsGunTiltYawFactor;
  __asm
  {
    vmaxss  xmm3, xmm6, xmm7
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm4, xmm3, xmm8, xmm2
    vmulss  xmm0, xmm4, dword ptr [rdx]
    vmovss  dword ptr [rdx], xmm0
    vmulss  xmm1, xmm4, dword ptr [r8]
    vmovss  dword ptr [r8], xmm1
    vmulss  xmm0, xmm4, dword ptr [r9]
    vmovss  dword ptr [r9], xmm0
    vmulss  xmm1, xmm4, dword ptr [r10]
    vmovss  dword ptr [r10], xmm1
    vmulss  xmm0, xmm4, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = adsGunTiltRollFactor;
  __asm
  {
    vmulss  xmm1, xmm4, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _R11 = &v67;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
BG_GetHandFromWeaponEvent
==============
*/
__int64 BG_GetHandFromWeaponEvent(int event)
{
  __int64 result; 

  switch ( event )
  {
    case 17:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 55:
    case 66:
    case 67:
    case 70:
    case 71:
      result = 1i64;
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

/*
==============
BG_GetHeatProperties
==============
*/
void BG_GetHeatProperties(const Weapon *weapon, const bool isAlternate, float *outAccumulationPerShot, float *outDissipationPerSecond)
{
  const WeaponDef *v13; 
  unsigned int v14; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v16; 
  WeaponAttachment **v17; 
  float *p_heatAccumulationPerShot; 
  WeaponAttachment **v23; 
  bool v25; 
  bool v26; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v52; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _R15 = outDissipationPerSecond;
  _R14 = outAccumulationPerShot;
  v13 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19270, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  v14 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  *_R14 = v13->heatAccumulationPerShot;
  *_R15 = v13->heatDissipationPerSecond;
  v16 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v17 = attachments;
    while ( 1 )
    {
      if ( !*v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19281, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      p_heatAccumulationPerShot = &(*v17)->heat->heatAccumulationPerShot;
      if ( p_heatAccumulationPerShot )
        break;
      ++v14;
      ++v17;
      if ( v14 >= (unsigned int)v16 )
        goto LABEL_13;
    }
    *_R14 = *p_heatAccumulationPerShot;
    *_R15 = p_heatAccumulationPerShot[1];
  }
LABEL_13:
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
    vmovaps xmm8, xmm7
    vxorps  xmm9, xmm9, xmm9
  }
  if ( (_DWORD)v16 )
  {
    v23 = attachments;
    do
    {
      _RBX = *v23;
      v25 = *v23 == NULL;
      if ( !*v23 )
      {
        v26 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19298, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v25 = !v26;
        if ( v26 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+334h]
        vcomiss xmm0, xmm9
      }
      if ( !v25 )
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm6
          vsubss  xmm6, xmm0, xmm7
        }
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+338h]
        vcomiss xmm0, xmm9
      }
      if ( !v25 )
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm8
          vsubss  xmm8, xmm0, xmm7
        }
      }
      ++v23;
      --v16;
    }
    while ( v16 );
  }
  __asm
  {
    vmaxss  xmm2, xmm6, xmm9
    vsubss  xmm0, xmm7, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm2, xmm7, xmm0
    vmulss  xmm0, xmm1, dword ptr [r14]
    vmovss  dword ptr [r14], xmm0
    vmaxss  xmm3, xmm8, xmm9
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm0, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
  }
  _R11 = &v52;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
BG_GetHeatSmokeProperties
==============
*/
void BG_GetHeatSmokeProperties(const Weapon *weapon, const bool isAlternate, float *outSmokeStartThreshold, float *outSmokeStopThreshold)
{
  const WeaponDef *v12; 
  unsigned int v13; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v15; 
  WeaponAttachment **v16; 
  AttHeat *heat; 
  WeaponAttachment **v21; 
  bool v23; 
  bool v24; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v41; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _R15 = outSmokeStopThreshold;
  _R14 = outSmokeStartThreshold;
  v12 = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19321, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  v13 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  *_R14 = v12->heatSmokeStartThreshold;
  *_R15 = v12->heatSmokeStopThreshold;
  v15 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    while ( 1 )
    {
      if ( !*v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19332, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      heat = (*v16)->heat;
      if ( heat )
        break;
      ++v13;
      ++v16;
      if ( v13 >= (unsigned int)v15 )
        goto LABEL_13;
    }
    *_R14 = heat->heatSmokeStartThreshold;
    *_R15 = heat->heatSmokeStopThreshold;
  }
LABEL_13:
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
    vxorps  xmm8, xmm8, xmm8
  }
  if ( (_DWORD)v15 )
  {
    v21 = attachments;
    do
    {
      _RDI = *v21;
      v23 = *v21 == NULL;
      if ( !*v21 )
      {
        v24 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19348, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v23 = !v24;
        if ( v24 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+33Ch]
        vcomiss xmm0, xmm8
      }
      if ( !v23 )
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm6
          vsubss  xmm6, xmm0, xmm7
        }
      }
      ++v21;
      --v15;
    }
    while ( v15 );
  }
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm1, dword ptr [r14]
    vmovss  dword ptr [r14], xmm0
    vmulss  xmm1, xmm1, dword ptr [r15]
    vmovss  dword ptr [r15], xmm1
  }
  _R11 = &v41;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
BG_GetHipIdleValues
==============
*/
void BG_GetHipIdleValues(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, float *hipIdleAmount, float *adsIdleAmount, float *hipIdleSpeed, float *adsIdleSpeed)
{
  const WeaponDef *v19; 
  unsigned int v20; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v27; 
  __int64 v28; 
  WeaponAttachment **v56; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v62; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  float *v75; 
  float *v76; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v79; 
  void *retaddr; 
  bitarray<64> v81; 

  _RAX = &retaddr;
  v81 = perks;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  _R14 = adsIdleAmount;
  _R13 = hipIdleAmount;
  _R15 = adsIdleSpeed;
  _R12 = hipIdleSpeed;
  v75 = adsIdleAmount;
  v76 = adsIdleSpeed;
  if ( !hipIdleAmount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12112, ASSERT_TYPE_ASSERT, "(hipIdleAmount)", (const char *)&queryFormat, "hipIdleAmount") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12113, ASSERT_TYPE_ASSERT, "(adsIdleAmount)", (const char *)&queryFormat, "adsIdleAmount") )
    __debugbreak();
  if ( !_R12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12114, ASSERT_TYPE_ASSERT, "(hipIdleSpeed)", (const char *)&queryFormat, "hipIdleSpeed") )
    __debugbreak();
  if ( !_R15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12115, ASSERT_TYPE_ASSERT, "(adsIdleSpeed)", (const char *)&queryFormat, "adsIdleSpeed") )
    __debugbreak();
  v19 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v20 = 0;
  *_R13 = v19->fHipIdleAmount;
  *_R14 = v19->fAdsIdleAmount;
  *_R12 = v19->hipIdleSpeed;
  *_R15 = v19->adsIdleSpeed;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmm10, xmm6
    vmovaps xmm9, xmm6
    vmovaps xmm8, xmm6
    vxorps  xmm7, xmm7, xmm7
  }
  if ( WeaponAttachments_Internal )
  {
    v27 = attachments;
    v28 = WeaponAttachments_Internal;
    do
    {
      if ( !*v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12129, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RAX = *v27;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2CCh]
        vcomiss xmm0, xmm7
        vaddss  xmm0, xmm0, xmm10
        vsubss  xmm10, xmm0, xmm6
        vmovss  xmm0, dword ptr [rax+2D0h]
        vcomiss xmm0, xmm7
        vaddss  xmm0, xmm9, xmm0
        vsubss  xmm9, xmm0, xmm6
        vmovss  xmm0, dword ptr [rax+2D4h]
        vcomiss xmm0, xmm7
        vaddss  xmm0, xmm0, xmm8
        vsubss  xmm8, xmm0, xmm6
      }
      ++v27;
      --v28;
    }
    while ( v28 );
    _R14 = v75;
    _R15 = v76;
  }
  __asm
  {
    vmovss  xmm4, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovsd  xmm5, cs:__real@3eb0c6f7a0b5ed8d
    vmaxss  xmm2, xmm10, xmm7
    vsubss  xmm0, xmm6, xmm2
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, xmm5
    vblendvps xmm10, xmm2, xmm6, xmm0
    vmaxss  xmm3, xmm9, xmm7
    vsubss  xmm0, xmm6, xmm3
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm5
    vblendvps xmm9, xmm3, xmm6, xmm2
    vmaxss  xmm3, xmm8, xmm7
    vsubss  xmm0, xmm6, xmm3
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm5
    vblendvps xmm6, xmm3, xmm6, xmm2
  }
  if ( WeaponAttachments_Internal )
  {
    v56 = attachments;
    while ( 1 )
    {
      if ( !*v56 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12149, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v56)->idleSettings )
        break;
      ++v20;
      ++v56;
      if ( v20 >= WeaponAttachments_Internal )
        goto LABEL_35;
    }
    __asm
    {
      vmulss  xmm0, xmm10, dword ptr [rcx]
      vmovss  dword ptr [r13+0], xmm0
      vmulss  xmm0, xmm10, dword ptr [rax+4]
      vmovss  dword ptr [r12], xmm0
    }
  }
LABEL_35:
  __asm
  {
    vmulss  xmm0, xmm9, dword ptr [r14]
    vmovss  dword ptr [r14], xmm0
    vmulss  xmm1, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm1
  }
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x1Au);
  v62 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex >= 0 )
  {
    if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 )
    {
      LODWORD(attachmentSlots) = 64;
      LODWORD(numAttachmentSlots) = PerkNetworkPriorityIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", numAttachmentSlots, attachmentSlots) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v62 & 0x1F)) & v81.array[v62 >> 5]) != 0 )
    {
      _RBX = DCONST_DVARFLT_perk_reducedSwayScale;
      if ( !DCONST_DVARFLT_perk_reducedSwayScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_reducedSwayScale") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm1, dword ptr [rbx+28h]
        vmulss  xmm0, xmm1, dword ptr [r14]
        vmovss  dword ptr [r14], xmm0
        vmulss  xmm1, xmm1, dword ptr [r15]
        vmovss  dword ptr [r15], xmm1
      }
    }
  }
  _R11 = &v79;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
BG_GetHipOffsetLerpType
==============
*/
void BG_GetHipOffsetLerpType(const Weapon *r_weapon, bool isAlternate, AdsOffsetInterpolationType *outHipOffsetLerpType)
{
  __int64 WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outHipOffsetLerpType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22397, ASSERT_TYPE_ASSERT, "(outHipOffsetLerpType)", (const char *)&queryFormat, "outHipOffsetLerpType") )
    __debugbreak();
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  *outHipOffsetLerpType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hipOffsetLerpType;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v7 = attachments;
    do
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22407, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v7)->overridehipOffsetLerpType )
        *outHipOffsetLerpType = (*v7)->hipOffsetLerpType;
      ++v7;
      --WeaponAttachments_Internal;
    }
    while ( WeaponAttachments_Internal );
  }
}

/*
==============
BG_GetHipSpread
==============
*/
void BG_GetHipSpread(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMax)
{
  const WeaponDef *v23; 
  unsigned int v24; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v29; 
  __int64 v30; 
  bool v31; 
  bool v32; 
  WeaponAttachment **v36; 
  WeaponAttachment *v37; 
  float *p_hipSpreadStandMin; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v68; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _R12 = hipSpreadDuckedMax;
  _R14 = hipSpreadStandMax;
  _R13 = hipSpreadProneMin;
  _R15 = hipSpreadDuckedMin;
  if ( !hipSpreadStandMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13799, ASSERT_TYPE_ASSERT, "(hipSpreadStandMin)", (const char *)&queryFormat, "hipSpreadStandMin") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13800, ASSERT_TYPE_ASSERT, "(hipSpreadStandMax)", (const char *)&queryFormat, "hipSpreadStandMax") )
    __debugbreak();
  if ( !hipSpreadDuckedMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13801, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMin)", (const char *)&queryFormat, "hipSpreadDuckedMin") )
    __debugbreak();
  if ( !hipSpreadDuckedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13802, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMax)", (const char *)&queryFormat, "hipSpreadDuckedMax") )
    __debugbreak();
  if ( !hipSpreadProneMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13803, ASSERT_TYPE_ASSERT, "(hipSpreadProneMin)", (const char *)&queryFormat, "hipSpreadProneMin") )
    __debugbreak();
  if ( !hipSpreadProneMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13804, ASSERT_TYPE_ASSERT, "(hipSpreadProneMax)", (const char *)&queryFormat, "hipSpreadProneMax") )
    __debugbreak();
  v23 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipSpreadStandMin = v23->fHipSpreadStandMin;
  *_R14 = v23->hipSpreadStandMax;
  *hipSpreadDuckedMin = v23->fHipSpreadDuckedMin;
  *hipSpreadDuckedMax = v23->hipSpreadDuckedMax;
  *hipSpreadProneMin = v23->fHipSpreadProneMin;
  *hipSpreadProneMax = v23->hipSpreadProneMax;
  v24 = 0;
  *hipSpreadSprintMin = v23->hipSpreadSprintMin;
  *hipSpreadSprintMax = v23->hipSpreadSprintMax;
  *hipSpreadInAirMin = v23->hipSpreadInAirMin;
  *hipSpreadInAirMax = v23->hipSpreadInAirMax;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
    vxorps  xmm8, xmm8, xmm8
  }
  if ( WeaponAttachments_Internal )
  {
    v29 = attachments;
    v30 = WeaponAttachments_Internal;
    do
    {
      v31 = *v29 == NULL;
      if ( !*v29 )
      {
        v32 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13823, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v31 = !v32;
        if ( v32 )
          __debugbreak();
      }
      _RAX = *v29;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2E8h]
        vucomiss xmm0, xmm8
      }
      if ( !v31 )
      {
        __asm
        {
          vaddss  xmm0, xmm6, xmm0
          vsubss  xmm6, xmm0, xmm7
        }
      }
      ++v29;
      --v30;
    }
    while ( v30 );
    _R12 = hipSpreadDuckedMax;
    _R13 = hipSpreadProneMin;
  }
  if ( WeaponAttachments_Internal )
  {
    v36 = attachments;
    while ( 1 )
    {
      if ( !*v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13832, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v37 = *v36;
      p_hipSpreadStandMin = &(*v36)->hipSpread->hipSpreadStandMin;
      if ( p_hipSpreadStandMin )
        break;
      ++v24;
      ++v36;
      if ( v24 >= WeaponAttachments_Internal )
        goto LABEL_35;
    }
    _R9 = hipSpreadStandMin;
    _R8 = hipSpreadProneMax;
    *hipSpreadStandMin = *p_hipSpreadStandMin;
    *_R14 = v37->hipSpread->hipSpreadMax;
    *hipSpreadDuckedMin = v37->hipSpread->hipSpreadDuckedMin;
    *_R12 = v37->hipSpread->hipSpreadDuckedMax;
    *_R13 = v37->hipSpread->hipSpreadProneMin;
    *hipSpreadProneMax = v37->hipSpread->hipSpreadProneMax;
    *hipSpreadSprintMin = v37->hipSpread->hipSpreadSprintMin;
    *hipSpreadSprintMax = v37->hipSpread->hipSpreadSprintMax;
    *hipSpreadInAirMin = v37->hipSpread->hipSpreadSprintMin;
    *hipSpreadInAirMax = v37->hipSpread->hipSpreadSprintMax;
  }
  else
  {
LABEL_35:
    _R9 = hipSpreadStandMin;
    _R8 = hipSpreadProneMax;
  }
  _RAX = hipSpreadSprintMin;
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm4, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm4, dword ptr [r9]
    vmovss  dword ptr [r9], xmm0
    vmulss  xmm1, xmm4, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
    vmulss  xmm0, xmm4, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vmulss  xmm1, xmm4, dword ptr [r12]
    vmovss  dword ptr [r12], xmm1
    vmulss  xmm0, xmm4, dword ptr [r13+0]
    vmovss  dword ptr [r13+0], xmm0
    vmulss  xmm1, xmm4, dword ptr [r8]
    vmovss  dword ptr [r8], xmm1
    vmulss  xmm0, xmm4, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadSprintMax;
  __asm
  {
    vmulss  xmm1, xmm4, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadInAirMin;
  __asm
  {
    vmulss  xmm0, xmm4, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadInAirMax;
  __asm
  {
    vmulss  xmm1, xmm4, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _R11 = &v68;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
BG_GetHipSpreadWithDecay
==============
*/
void BG_GetHipSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *hipSpreadStandMin, float *hipSpreadStandMoveMax, float *hipSpreadStandMax, float *hipSpreadDuckedMin, float *hipSpreadDuckedMoveMax, float *hipSpreadDuckedMax, float *hipSpreadProneMin, float *hipSpreadProneMoveMax, float *hipSpreadProneMax, float *hipSpreadSprintMin, float *hipSpreadSprintMoveMax, float *hipSpreadSprintMax, float *hipSpreadInAirMin, float *hipSpreadInAirMoveMax, float *hipSpreadInAirMax, float *hipSpreadDecayRate, float *hipSpreadProneDecay, float *hipSpreadDuckedDecay, float *hipSpreadSprintDecay, float *hipSpreadInAirDecay, float *hipSpreadTurnAdd, float *hipSpreadMoveAdd)
{
  const WeaponDef *v32; 
  unsigned int v33; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v36; 
  __int64 v38; 
  bool v39; 
  bool v40; 
  WeaponAttachment **v44; 
  WeaponAttachment *v45; 
  float *p_hipSpreadStandMin; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+258h+var_48], xmm6 }
  _R13 = hipSpreadDuckedMoveMax;
  _R14 = hipSpreadStandMoveMax;
  _R15 = hipSpreadStandMax;
  _R12 = hipSpreadDuckedMin;
  if ( !hipSpreadStandMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13921, ASSERT_TYPE_ASSERT, "(hipSpreadStandMin)", (const char *)&queryFormat, "hipSpreadStandMin") )
    __debugbreak();
  if ( !hipSpreadStandMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13922, ASSERT_TYPE_ASSERT, "(hipSpreadStandMax)", (const char *)&queryFormat, "hipSpreadStandMax") )
    __debugbreak();
  if ( !hipSpreadDuckedMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13923, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMin)", (const char *)&queryFormat, "hipSpreadDuckedMin") )
    __debugbreak();
  if ( !hipSpreadDuckedMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13924, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMax)", (const char *)&queryFormat, "hipSpreadDuckedMax") )
    __debugbreak();
  if ( !hipSpreadProneMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13925, ASSERT_TYPE_ASSERT, "(hipSpreadProneMin)", (const char *)&queryFormat, "hipSpreadProneMin") )
    __debugbreak();
  if ( !hipSpreadProneMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13926, ASSERT_TYPE_ASSERT, "(hipSpreadProneMax)", (const char *)&queryFormat, "hipSpreadProneMax") )
    __debugbreak();
  if ( !hipSpreadDecayRate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13928, ASSERT_TYPE_ASSERT, "(hipSpreadDecayRate)", (const char *)&queryFormat, "hipSpreadDecayRate") )
    __debugbreak();
  if ( !hipSpreadProneDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13929, ASSERT_TYPE_ASSERT, "(hipSpreadProneDecay)", (const char *)&queryFormat, "hipSpreadProneDecay") )
    __debugbreak();
  if ( !hipSpreadDuckedDecay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13930, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedDecay)", (const char *)&queryFormat, "hipSpreadDuckedDecay") )
    __debugbreak();
  if ( !hipSpreadTurnAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13931, ASSERT_TYPE_ASSERT, "(hipSpreadTurnAdd)", (const char *)&queryFormat, "hipSpreadTurnAdd") )
    __debugbreak();
  if ( !hipSpreadMoveAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13932, ASSERT_TYPE_ASSERT, "(hipSpreadMoveAdd)", (const char *)&queryFormat, "hipSpreadMoveAdd") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13934, ASSERT_TYPE_ASSERT, "(hipSpreadStandMoveMax)", (const char *)&queryFormat, "hipSpreadStandMoveMax") )
    __debugbreak();
  if ( !hipSpreadDuckedMoveMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13935, ASSERT_TYPE_ASSERT, "(hipSpreadDuckedMoveMax)", (const char *)&queryFormat, "hipSpreadDuckedMoveMax") )
    __debugbreak();
  if ( !hipSpreadProneMoveMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13936, ASSERT_TYPE_ASSERT, "(hipSpreadProneMoveMax)", (const char *)&queryFormat, "hipSpreadProneMoveMax") )
    __debugbreak();
  v32 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *hipSpreadStandMin = v32->fHipSpreadStandMin;
  *hipSpreadStandMax = v32->hipSpreadStandMax;
  *hipSpreadDuckedMin = v32->fHipSpreadDuckedMin;
  *hipSpreadDuckedMax = v32->hipSpreadDuckedMax;
  v33 = 0;
  *hipSpreadProneMin = v32->fHipSpreadProneMin;
  *hipSpreadProneMax = v32->hipSpreadProneMax;
  *hipSpreadSprintMin = v32->hipSpreadSprintMin;
  *hipSpreadSprintMax = v32->hipSpreadSprintMax;
  *hipSpreadInAirMin = v32->hipSpreadInAirMin;
  *hipSpreadInAirMax = v32->hipSpreadInAirMax;
  *_R14 = v32->hipSpreadStandMoveMax;
  *hipSpreadDuckedMoveMax = v32->hipSpreadDuckedMoveMax;
  *hipSpreadProneMoveMax = v32->hipSpreadProneMoveMax;
  *hipSpreadSprintMoveMax = v32->hipSpreadSprintMoveMax;
  *hipSpreadInAirMoveMax = v32->hipSpreadInAirMoveMax;
  *hipSpreadDecayRate = v32->fHipSpreadDecayRate;
  *hipSpreadProneDecay = v32->fHipSpreadProneDecay;
  *hipSpreadDuckedDecay = v32->fHipSpreadDuckedDecay;
  *hipSpreadSprintDecay = v32->hipSpreadSprintDecay;
  *hipSpreadInAirDecay = v32->hipSpreadInAirDecay;
  *hipSpreadTurnAdd = v32->fHipSpreadTurnAdd;
  *hipSpreadMoveAdd = v32->fHipSpreadMoveAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  if ( WeaponAttachments_Internal )
  {
    __asm { vmovaps [rsp+258h+var_58], xmm7 }
    v36 = attachments;
    __asm { vxorps  xmm7, xmm7, xmm7 }
    v38 = WeaponAttachments_Internal;
    do
    {
      v39 = *v36 == NULL;
      if ( !*v36 )
      {
        v40 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13969, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v39 = !v40;
        if ( v40 )
          __debugbreak();
      }
      _RAX = *v36;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2E8h]
        vucomiss xmm0, xmm7
      }
      if ( !v39 )
        __asm { vmulss  xmm6, xmm6, xmm0 }
      ++v36;
      --v38;
    }
    while ( v38 );
    _R14 = hipSpreadStandMoveMax;
    _R13 = hipSpreadDuckedMoveMax;
    __asm { vmovaps xmm7, [rsp+258h+var_58] }
  }
  if ( WeaponAttachments_Internal )
  {
    v44 = attachments;
    while ( 1 )
    {
      if ( !*v44 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13976, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v45 = *v44;
      p_hipSpreadStandMin = &(*v44)->hipSpread->hipSpreadStandMin;
      if ( p_hipSpreadStandMin )
        break;
      ++v33;
      ++v44;
      if ( v33 >= WeaponAttachments_Internal )
        goto LABEL_59;
    }
    _R8 = hipSpreadDuckedMax;
    _R9 = hipSpreadProneMin;
    *hipSpreadStandMin = *p_hipSpreadStandMin;
    *hipSpreadStandMax = v45->hipSpread->hipSpreadMax;
    *hipSpreadDuckedMin = v45->hipSpread->hipSpreadDuckedMin;
    *hipSpreadDuckedMax = v45->hipSpread->hipSpreadDuckedMax;
    *hipSpreadProneMin = v45->hipSpread->hipSpreadProneMin;
    *hipSpreadProneMax = v45->hipSpread->hipSpreadProneMax;
    *hipSpreadSprintMin = v45->hipSpread->hipSpreadSprintMin;
    *hipSpreadSprintMax = v45->hipSpread->hipSpreadSprintMax;
    *hipSpreadInAirMin = v45->hipSpread->hipSpreadInAirMin;
    *hipSpreadInAirMax = v45->hipSpread->hipSpreadInAirMax;
    *_R14 = v45->hipSpread->hipSpreadStandMoveMax;
    *_R13 = v45->hipSpread->hipSpreadDuckedMoveMax;
    *hipSpreadProneMoveMax = v45->hipSpread->hipSpreadProneMoveMax;
    *hipSpreadSprintMoveMax = v45->hipSpread->hipSpreadSprintMoveMax;
    *hipSpreadInAirMoveMax = v45->hipSpread->hipSpreadInAirMoveMax;
    *hipSpreadDecayRate = v45->hipSpread->hipSpreadDecayRate;
    *hipSpreadProneDecay = v45->hipSpread->hipSpreadProneDecay;
    *hipSpreadDuckedDecay = v45->hipSpread->hipSpreadDuckedDecay;
    *hipSpreadSprintDecay = v45->hipSpread->hipSpreadSprintDecay;
    *hipSpreadInAirDecay = v45->hipSpread->hipSpreadInAirDecay;
    *hipSpreadTurnAdd = v45->hipSpread->hipSpreadTurnAdd;
    *hipSpreadMoveAdd = v45->hipSpread->hipSpreadMoveAdd;
  }
  else
  {
LABEL_59:
    _R9 = hipSpreadProneMin;
    _R8 = hipSpreadDuckedMax;
  }
  _RAX = hipSpreadStandMin;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
    vmulss  xmm1, xmm6, dword ptr [r15]
    vmovss  dword ptr [r15], xmm1
    vmulss  xmm0, xmm6, dword ptr [r12]
    vmovss  dword ptr [r12], xmm0
    vmulss  xmm1, xmm6, dword ptr [r8]
    vmovss  dword ptr [r8], xmm1
    vmulss  xmm0, xmm6, dword ptr [r9]
  }
  _RAX = hipSpreadProneMax;
  __asm
  {
    vmovss  dword ptr [r9], xmm0
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadSprintMin;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadSprintMax;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadInAirMin;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadInAirMax;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadDecayRate;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadProneDecay;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadDuckedDecay;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadSprintDecay;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadInAirDecay;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadTurnAdd;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadMoveAdd;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
    vmulss  xmm1, xmm6, dword ptr [r14]
  }
  _RAX = hipSpreadProneMoveMax;
  __asm
  {
    vmovss  dword ptr [r14], xmm1
    vmulss  xmm0, xmm6, dword ptr [r13+0]
    vmovss  dword ptr [r13+0], xmm0
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
  }
  _RAX = hipSpreadSprintMoveMax;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = hipSpreadInAirMoveMax;
  __asm
  {
    vmulss  xmm1, xmm6, dword ptr [rax]
    vmovss  dword ptr [rax], xmm1
    vmovaps xmm6, [rsp+258h+var_48]
  }
}

/*
==============
BG_GetHitmarkerType
==============
*/
__int64 BG_GetHitmarkerType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  HitmarkerType hitmarkerType; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttHitmarker *hitmarker; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v10; 
  __int64 v11; 
  AttHitmarker *v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  hitmarkerType = HITMARKER_TYPE_SMALL;
  if ( v4 )
    hitmarkerType = v4->hitmarkerType;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
  {
    hitmarker = WeaponPrimaryAttachment->hitmarker;
    if ( hitmarker )
      return (unsigned int)hitmarker->hitmarkerType;
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    v11 = WeaponAttachments_Internal;
    do
    {
      v12 = (*v10)->hitmarker;
      if ( v12 )
      {
        if ( v12->hitmarkerType > hitmarkerType )
          hitmarkerType = v12->hitmarkerType;
      }
      ++v10;
      --v11;
    }
    while ( v11 );
  }
  return (unsigned int)hitmarkerType;
}

/*
==============
BG_GetHudOutlineAltInScopeColor
==============
*/
void BG_GetHudOutlineAltInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outColor;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3174, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3175, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = 0;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3186, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (_DWORD *)(*v11)->outline->outlineColor.v;
      if ( _RCX )
        break;
      ++v10;
      ++v11;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    _RSI->v[0] = (float)_RCX[4];
    _RSI->v[1] = (float)_RCX[5];
    _RSI->v[2] = (float)_RCX[6];
    __asm { vmovss  xmm0, dword ptr [rcx+1Ch] }
  }
  else
  {
LABEL_14:
    *(_QWORD *)_RSI->v = 0i64;
    _RSI->v[2] = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+0Ch], xmm0 }
}

/*
==============
BG_GetHudOutlineDepthTest
==============
*/
bool BG_GetHudOutlineDepthTest(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3361, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3362, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3373, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineDepthTest;
}

/*
==============
BG_GetHudOutlineFill
==============
*/
bool BG_GetHudOutlineFill(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3386, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3387, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3398, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineFill;
}

/*
==============
BG_GetHudOutlineFillColor0
==============
*/
void BG_GetHudOutlineFillColor0(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outColor;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3201, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3202, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = 0;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3213, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (_DWORD *)(*v11)->outline->outlineColor.v;
      if ( _RCX )
        break;
      ++v10;
      ++v11;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    _RSI->v[0] = (float)_RCX[8];
    _RSI->v[1] = (float)_RCX[9];
    _RSI->v[2] = (float)_RCX[10];
    __asm { vmovss  xmm0, dword ptr [rcx+2Ch] }
  }
  else
  {
LABEL_14:
    *(_QWORD *)_RSI->v = 0i64;
    _RSI->v[2] = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+0Ch], xmm0 }
}

/*
==============
BG_GetHudOutlineFillColor1
==============
*/
void BG_GetHudOutlineFillColor1(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outColor;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3228, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3229, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = 0;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3240, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (_DWORD *)(*v11)->outline->outlineColor.v;
      if ( _RCX )
        break;
      ++v10;
      ++v11;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    _RSI->v[0] = (float)_RCX[12];
    _RSI->v[1] = (float)_RCX[13];
    _RSI->v[2] = (float)_RCX[14];
    __asm { vmovss  xmm0, dword ptr [rcx+3Ch] }
  }
  else
  {
LABEL_14:
    *(_QWORD *)_RSI->v = 0i64;
    _RSI->v[2] = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+0Ch], xmm0 }
}

/*
==============
BG_GetHudOutlineInScopeColor
==============
*/
void BG_GetHudOutlineInScopeColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outColor;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3147, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3148, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = 0;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3159, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (*v11)->outline->outlineColor.v;
      if ( _RCX )
        break;
      ++v10;
      ++v11;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    _RSI->v[0] = *_RCX;
    _RSI->v[1] = _RCX[1];
    _RSI->v[2] = _RCX[2];
    __asm { vmovss  xmm0, dword ptr [rcx+0Ch] }
  }
  else
  {
LABEL_14:
    *(_QWORD *)_RSI->v = 0i64;
    _RSI->v[2] = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+0Ch], xmm0 }
}

/*
==============
BG_GetHudOutlineOccludedInlineColor
==============
*/
void BG_GetHudOutlineOccludedInlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outColor;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3282, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3283, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = 0;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3294, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (_DWORD *)(*v11)->outline->outlineColor.v;
      if ( _RCX )
        break;
      ++v10;
      ++v11;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    _RSI->v[0] = (float)_RCX[20];
    _RSI->v[1] = (float)_RCX[21];
    _RSI->v[2] = (float)_RCX[22];
    __asm { vmovss  xmm0, dword ptr [rcx+5Ch] }
  }
  else
  {
LABEL_14:
    *(_QWORD *)_RSI->v = 0i64;
    _RSI->v[2] = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+0Ch], xmm0 }
}

/*
==============
BG_GetHudOutlineOccludedInteriorColor
==============
*/
void BG_GetHudOutlineOccludedInteriorColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outColor;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3309, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3310, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = 0;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3321, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (_DWORD *)(*v11)->outline->outlineColor.v;
      if ( _RCX )
        break;
      ++v10;
      ++v11;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    _RSI->v[0] = (float)_RCX[24];
    _RSI->v[1] = (float)_RCX[25];
    _RSI->v[2] = (float)_RCX[26];
    __asm { vmovss  xmm0, dword ptr [rcx+6Ch] }
  }
  else
  {
LABEL_14:
    *(_QWORD *)_RSI->v = 0i64;
    _RSI->v[2] = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+0Ch], xmm0 }
}

/*
==============
BG_GetHudOutlineOccludedOutlineColor
==============
*/
void BG_GetHudOutlineOccludedOutlineColor(const BgWeaponMap *weaponMap, const playerState_s *ps, vec4_t *outColor)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outColor;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3255, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3256, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = 0;
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3267, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (_DWORD *)(*v11)->outline->outlineColor.v;
      if ( _RCX )
        break;
      ++v10;
      ++v11;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    _RSI->v[0] = (float)_RCX[16];
    _RSI->v[1] = (float)_RCX[17];
    _RSI->v[2] = (float)_RCX[18];
    __asm { vmovss  xmm0, dword ptr [rcx+4Ch] }
  }
  else
  {
LABEL_14:
    *(_QWORD *)_RSI->v = 0i64;
    _RSI->v[2] = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  __asm { vmovss  dword ptr [rsi+0Ch], xmm0 }
}

/*
==============
BG_GetHudOutlineScriptControlled
==============
*/
bool BG_GetHudOutlineScriptControlled(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3411, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3412, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3423, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineScriptControlled;
}

/*
==============
BG_GetHudOutlineWeapon
==============
*/
_BOOL8 BG_GetHudOutlineWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  int v6; 
  bool outlineEnemies; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3134, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3135, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  outlineEnemies = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx)->outlineEnemies;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return outlineEnemies;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7685, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return outlineEnemies;
  }
  return outline->outlineEnemies;
}

/*
==============
BG_GetHudOutlineWidth
==============
*/
float BG_GetHudOutlineWidth(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v5; 
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v8; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3336, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3337, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v5 = BG_UsingAlternate(ps);
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v8 = attachments;
    while ( 1 )
    {
      if ( !*v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3348, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v8)->outline )
        break;
      ++v6;
      ++v8;
      if ( v6 >= WeaponAttachments_Internal )
        goto LABEL_14;
    }
    __asm { vmovss  xmm0, dword ptr [rcx+70h] }
  }
  else
  {
LABEL_14:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetHybridScopeEnablerAttachment
==============
*/
WeaponAttachment *BG_GetHybridScopeEnablerAttachment(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **outDataAttachment)
{
  int v3; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v7; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  if ( outDataAttachment )
    *outDataAttachment = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0i64;
  for ( i = attachments; ; ++i )
  {
    v7 = *i;
    if ( !*i )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12406, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
    }
    adsOverlay = v7->adsOverlay;
    if ( adsOverlay )
    {
      if ( adsOverlay->hybridToggle )
        break;
    }
    if ( ++v3 >= WeaponAttachments_Internal )
      return 0i64;
  }
  if ( outDataAttachment )
    *outDataAttachment = adsOverlay->hybridScopeAttachment;
  return v7;
}

/*
==============
BG_GetHybridScopeInfo
==============
*/
void BG_GetHybridScopeInfo(const Weapon *r_weapon, bool isAlternate, BgHybridScopeInfo *outHybridScopeInfo)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v7; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  outHybridScopeInfo->hybridScopeAttachment = NULL;
  *(_QWORD *)&outHybridScopeInfo->hybridScope1To2FovTransBegin = 0i64;
  v4 = 0;
  *(_QWORD *)&outHybridScopeInfo->hybridScope2To1FovTransBegin = 0i64;
  *(_QWORD *)&outHybridScopeInfo->hybridScope1To2ScopeFadeTransBegin = 0i64;
  *(_QWORD *)&outHybridScopeInfo->hybridScope2To1ScopeFadeTransBegin = 0i64;
  *(_QWORD *)&outHybridScopeInfo->hasHybridScope = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      v7 = *i;
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7523, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( v7->type == ATTACHMENT_SCOPE )
      {
        adsOverlay = v7->adsOverlay;
        if ( adsOverlay )
        {
          if ( adsOverlay->hybridToggle )
            break;
        }
      }
      if ( ++v4 >= WeaponAttachments_Internal )
        return;
    }
    outHybridScopeInfo->hasHybridScope = 1;
    outHybridScopeInfo->hybridScopeAttachment = v7->adsOverlay->hybridScopeAttachment;
    outHybridScopeInfo->hybridScope1To2FovTransBegin = v7->adsOverlay->hybridScope1To2FovTransBegin;
    outHybridScopeInfo->hybridScope1To2FovTransEnd = v7->adsOverlay->hybridScope1To2FovTransEnd;
    outHybridScopeInfo->hybridScope2To1FovTransBegin = v7->adsOverlay->hybridScope2To1FovTransBegin;
    outHybridScopeInfo->hybridScope2To1FovTransEnd = v7->adsOverlay->hybridScope2To1FovTransEnd;
    outHybridScopeInfo->hybridScope1To2ScopeFadeTransBegin = v7->adsOverlay->hybridScope1To2ScopeFadeTransBegin;
    outHybridScopeInfo->hybridScope1To2ScopeFadeTransEnd = v7->adsOverlay->hybridScope1To2ScopeFadeTransEnd;
    outHybridScopeInfo->hybridScope2To1ScopeFadeTransBegin = v7->adsOverlay->hybridScope2To1ScopeFadeTransBegin;
    outHybridScopeInfo->hybridScope2To1ScopeFadeTransEnd = v7->adsOverlay->hybridScope2To1ScopeFadeTransEnd;
  }
}

/*
==============
BG_GetHyperBurstInfo
==============
*/
const HyperBurstInfo *BG_GetHyperBurstInfo(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  const HyperBurstInfo *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v8[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v8, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hyperBurstInfo;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22322, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->hyperBurstInfo;
    if ( result )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hyperBurstInfo;
  }
  return result;
}

/*
==============
BG_GetIgnoreHitEntityCount
==============
*/
__int64 BG_GetIgnoreHitEntityCount(const BulletFireParams *bp)
{
  __int64 result; 

  result = (unsigned int)bp->ignoreHitEntCount;
  if ( (int)result >= 16 )
    return 16i64;
  return result;
}

/*
==============
BG_GetImpactDamageAndModForProjectile
==============
*/

__int64 __fastcall BG_GetImpactDamageAndModForProjectile(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, double rangeScale, const vec3_t *origStart, vec3_t *hitPos, meansOfDeath_t *outMOD)
{
  weapClass_t weapClass; 
  int BulletDamageForProjectile; 
  unsigned int v14; 
  bool v15; 
  __int64 result; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm3
  }
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16674, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  if ( !outMOD && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16679, ASSERT_TYPE_ASSERT, "(outMOD)", (const char *)&queryFormat, "outMOD") )
    __debugbreak();
  weapClass = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapClass;
  if ( weapClass < WEAPCLASS_RIFLE )
    goto LABEL_11;
  if ( weapClass > WEAPCLASS_SPREAD )
  {
    if ( weapClass == WEAPCLASS_PISTOL )
    {
      __asm { vmovaps xmm3, xmm6; rangeScale }
      BulletDamageForProjectile = BG_GetBulletDamageForProjectile(damageCalcType, r_weapon, isAlternate, *(double *)&_XMM3, origStart, hitPos);
      *outMOD = MOD_PISTOL_BULLET;
      goto LABEL_12;
    }
    if ( weapClass != WEAPCLASS_BEAM )
    {
LABEL_11:
      BulletDamageForProjectile = BG_GetDamage(damageCalcType, r_weapon, isAlternate);
      *outMOD = MOD_IMPACT;
      goto LABEL_12;
    }
  }
  __asm { vmovaps xmm3, xmm6; rangeScale }
  BulletDamageForProjectile = BG_GetBulletDamageForProjectile(damageCalcType, r_weapon, isAlternate, *(double *)&_XMM3, origStart, hitPos);
  *outMOD = MOD_RIFLE_BULLET;
LABEL_12:
  v14 = BulletDamageForProjectile;
  v15 = !BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bIncendiaryBullet;
  result = v14;
  if ( !v15 )
    *outMOD = MOD_FIRE_BULLET;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  return result;
}

/*
==============
BG_GetKickAlignedInputScalar
==============
*/
float BG_GetKickAlignedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( WeaponAttachments_Internal )
  {
    v12 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20735, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *v12, v11) )
        break;
      ++v8;
      ++v12;
      if ( v8 >= WeaponAttachments_Internal )
        goto LABEL_13;
    }
    __asm { vmovss  xmm0, dword ptr [rax+154h] }
  }
  else
  {
LABEL_13:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm { vmovss  xmm0, dword ptr [rax+8B4h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetKickOpposedInputScalar
==============
*/
float BG_GetKickOpposedInputScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **v12; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( WeaponAttachments_Internal )
  {
    v12 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20757, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *v12, v11) )
        break;
      ++v8;
      ++v12;
      if ( v8 >= WeaponAttachments_Internal )
        goto LABEL_13;
    }
    __asm { vmovss  xmm0, dword ptr [rax+158h] }
  }
  else
  {
LABEL_13:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm { vmovss  xmm0, dword ptr [rax+8B8h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetLUICrosshairWidget
==============
*/
const char *BG_GetLUICrosshairWidget(const Weapon *r_weapon, const bool isAlternate)
{
  int v4; 
  const char *szLUICrosshairWidget; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  szLUICrosshairWidget = BG_WeaponCompleteDef(r_weapon, isAlternate)->szLUICrosshairWidget;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return szLUICrosshairWidget;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16522, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return szLUICrosshairWidget;
  }
  return general->szLUICrosshairWidget;
}

/*
==============
BG_GetLasers
==============
*/
void BG_GetLasers(const Weapon *r_weapon, const LaserDef **viewModelLaser, const LaserDef **viewModelLaserAlt, const LaserDef **friendlyLaser, const LaserDef **enemyLaser)
{
  const WeaponDef *v9; 
  unsigned int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v12; 
  WeaponAttachment *v13; 
  const LaserDef **p_laserTypeViewModel; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !friendlyLaser && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7165, ASSERT_TYPE_ASSERT, "(friendlyLaser)", (const char *)&queryFormat, "friendlyLaser") )
    __debugbreak();
  if ( !enemyLaser && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7166, ASSERT_TYPE_ASSERT, "(enemyLaser)", (const char *)&queryFormat, "enemyLaser") )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7169, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  *viewModelLaser = v9->laserTypeViewModel;
  v10 = 0;
  *viewModelLaserAlt = v9->laserTypeViewModelAlt;
  *friendlyLaser = v9->laserTypeFriendly;
  *enemyLaser = v9->laserTypeEnemy;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, 0, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    do
    {
      v13 = *v12;
      if ( *v12 )
      {
        p_laserTypeViewModel = (const LaserDef **)&v13->laser->laserTypeViewModel;
        if ( p_laserTypeViewModel )
        {
          *viewModelLaser = *p_laserTypeViewModel;
          *viewModelLaserAlt = v13->laser->laserTypeViewModelAlt;
          *friendlyLaser = v13->laser->laserTypeFriendly;
          *enemyLaser = v13->laser->laserTypeEnemy;
          return;
        }
      }
      else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7183, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      {
        __debugbreak();
      }
      ++v10;
      ++v12;
    }
    while ( v10 < WeaponAttachments_Internal );
  }
}

/*
==============
BG_GetLinearDamageRange
==============
*/

void __fastcall BG_GetLinearDamageRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, double rangeScale, float *minDamageRange, float *maxDamageRange)
{
  __int64 v15; 
  bool v18; 
  bool v19; 
  unsigned int v24; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v28; 
  __int64 v29; 
  bool v30; 
  bool v31; 
  WeaponAttachment **v43; 
  bool v45; 
  bool v46; 
  __int64 numAttachmentSlots; 
  __int64 numAttachmentSlotsa; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v64; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _R14 = maxDamageRange;
  _RBP = minDamageRange;
  v15 = damageCalcType;
  __asm { vmovaps xmm9, xmm3 }
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9423, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  if ( !minDamageRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9431, ASSERT_TYPE_ASSERT, "(minDamageRange)", (const char *)&queryFormat, "minDamageRange") )
    __debugbreak();
  if ( !maxDamageRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9432, ASSERT_TYPE_ASSERT, "(maxDamageRange)", (const char *)&queryFormat, "maxDamageRange") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v18 = (unsigned int)v15 < 3;
  if ( (unsigned int)v15 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v15;
    v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots);
    v18 = 0;
    if ( v19 )
      __debugbreak();
  }
  _R13 = 5 * v15;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+r13*8+0E4h]
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
  }
  if ( v18 )
    __asm { vmovss  xmm0, dword ptr [rbx+0E4h] }
  __asm
  {
    vmovss  dword ptr [rbp+0], xmm0
    vmovss  xmm1, dword ptr [rbx+r13*8+0D4h]
    vcomiss xmm1, xmm7
  }
  if ( v18 )
    __asm { vmovss  xmm1, dword ptr [rbx+0D4h] }
  v24 = 0;
  __asm
  {
    vmovss  dword ptr [r14], xmm1
    vmovss  xmm8, cs:__real@3f800000
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vmovaps xmm6, xmm8 }
  if ( WeaponAttachments_Internal )
  {
    v28 = attachments;
    v29 = WeaponAttachments_Internal;
    do
    {
      v30 = *v28 == NULL;
      if ( !*v28 )
      {
        v31 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9449, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v30 = !v31;
        if ( v31 )
          __debugbreak();
      }
      _RAX = *v28;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+268h]
        vucomiss xmm0, xmm7
      }
      if ( !v30 )
      {
        __asm
        {
          vaddss  xmm0, xmm6, xmm0
          vsubss  xmm6, xmm0, xmm8
        }
      }
      ++v28;
      --v29;
    }
    while ( v29 );
    _R14 = maxDamageRange;
    _RBP = minDamageRange;
  }
  __asm
  {
    vmaxss  xmm3, xmm6, xmm7
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm2, xmm0, xmm0
    vcmplesd xmm0, xmm2, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm3, xmm8, xmm0
    vcmplesd xmm0, xmm2, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm8, xmm3, xmm8, xmm0
  }
  if ( WeaponAttachments_Internal )
  {
    v43 = attachments;
    while ( 1 )
    {
      if ( !*v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9461, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RDI = (*v43)->damage;
      if ( _RDI )
        break;
      ++v24;
      ++v43;
      if ( v24 >= WeaponAttachments_Internal )
        goto LABEL_42;
    }
    v45 = (unsigned int)v15 < 3;
    if ( (unsigned int)v15 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(numAttachmentSlotsa) = v15;
      v46 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlotsa, attachmentSlotsa);
      v45 = 0;
      if ( v46 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+r13*8+24h]
      vcomiss xmm0, xmm7
    }
    if ( v45 )
      __asm { vmovss  xmm0, dword ptr [rdi+24h] }
    __asm
    {
      vmovss  dword ptr [rbp+0], xmm0
      vmovss  xmm1, dword ptr [rdi+r13*8+14h]
      vcomiss xmm1, xmm7
    }
    if ( v45 )
      *_R14 = _RDI->damageInfo.damageData[0].maxDamageRange;
    else
      __asm { vmovss  dword ptr [r14], xmm1 }
  }
LABEL_42:
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rbp+0]
    vmovss  dword ptr [rbp+0], xmm0
    vmulss  xmm1, xmm8, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
    vmulss  xmm0, xmm9, dword ptr [rbp+0]
    vmovss  dword ptr [rbp+0], xmm0
    vmulss  xmm1, xmm9, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
  }
  _R11 = &v64;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
BG_GetLocationDamageMultipliers
==============
*/
const float *BG_GetLocationDamageMultipliers(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  float *locationDamageMultipliers; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  const float *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  locationDamageMultipliers = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->locationDamageMultipliers;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return locationDamageMultipliers;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9518, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->locationDamage;
    if ( result )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return locationDamageMultipliers;
  }
  return result;
}

/*
==============
BG_GetMeleeAutoAimHeight
==============
*/
float BG_GetMeleeAutoAimHeight(const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9076, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( _RBX->meleeOverrideValues )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0E8Ch] }
  }
  else
  {
    _RBX = DCONST_DVARMPSPFLT_aim_automelee_region_height;
    if ( !DCONST_DVARMPSPFLT_aim_automelee_region_height && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_region_height") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeAutoAimLerp
==============
*/
float BG_GetMeleeAutoAimLerp(const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9012, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( _RBX->meleeOverrideValues )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0E88h] }
  }
  else
  {
    _RBX = DCONST_DVARFLT_aim_automelee_lerp;
    if ( !DCONST_DVARFLT_aim_automelee_lerp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_lerp") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeAutoAimMaxPitchMovement
==============
*/
float BG_GetMeleeAutoAimMaxPitchMovement(const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9028, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( _RBX->meleeOverrideValues )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0E94h] }
  }
  else
  {
    _RBX = DCONST_DVARFLT_aim_automelee_maxPitchMovement;
    if ( !DCONST_DVARFLT_aim_automelee_maxPitchMovement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_maxPitchMovement") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeAutoAimMaxYawMovement
==============
*/
float BG_GetMeleeAutoAimMaxYawMovement(const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9044, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( _RBX->meleeOverrideValues )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0E98h] }
  }
  else
  {
    _RBX = DCONST_DVARFLT_aim_automelee_maxYawMovement;
    if ( !DCONST_DVARFLT_aim_automelee_maxYawMovement && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_maxYawMovement") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeAutoAimWidth
==============
*/
float BG_GetMeleeAutoAimWidth(const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9060, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( _RBX->meleeOverrideValues )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0E90h] }
  }
  else
  {
    _RBX = DCONST_DVARMPSPFLT_aim_automelee_region_width;
    if ( !DCONST_DVARMPSPFLT_aim_automelee_region_width && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_automelee_region_width") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeComboSeqCount
==============
*/
__int64 BG_GetMeleeComboSeqCount(const Weapon *r_weapon)
{
  int v2; 
  unsigned int v3; 
  const WeaponDef *v4; 
  const WeaponDef *v5; 
  unsigned int numAnimOverrides; 
  __int64 v7; 
  const WeaponCompleteDef *v8; 
  OverrideBinding *bindings; 
  __int64 slot; 
  __int64 v13; 
  __int64 v15; 
  __int64 v16; 

  if ( !BG_IsMeleeComboOverride(r_weapon, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19780, ASSERT_TYPE_ASSERT, "(BG_IsMeleeComboWeapon( r_weapon ))", (const char *)&queryFormat, "BG_IsMeleeComboWeapon( r_weapon )") )
    __debugbreak();
  v2 = 1;
  v3 = 0;
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4->numAnimOverrides )
    goto LABEL_27;
  do
  {
    v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    numAnimOverrides = v5->numAnimOverrides;
    if ( !numAnimOverrides )
      break;
    if ( v3 >= numAnimOverrides )
    {
      LODWORD(v16) = v5->numAnimOverrides;
      LODWORD(v15) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19733, ASSERT_TYPE_ASSERT, "(unsigned)( overrideIndex ) < (unsigned)( weapDef->numAnimOverrides )", "overrideIndex doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    v7 = v3;
    if ( !v5->animOverrides[v7].numBindings )
      break;
    v8 = BG_WeaponCompleteDef(r_weapon, 0);
    bindings = v5->animOverrides[v7].bindings;
    if ( !bindings->numBindingLists && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19741, ASSERT_TYPE_ASSERT, "(overrideBinding->numBindingLists != 0)", (const char *)&queryFormat, "overrideBinding->numBindingLists != 0") )
      __debugbreak();
    _RBX = bindings->bindingLists;
    if ( _RBX->slot >= (unsigned int)ATT_SLOT_COUNT )
    {
      LODWORD(v16) = 14;
      LODWORD(v15) = _RBX->slot;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19744, ASSERT_TYPE_ASSERT, "(unsigned)( overrideList->slot ) < (unsigned)( ATT_SLOT_COUNT )", "overrideList->slot doesn't index ATT_SLOT_COUNT\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    slot = _RBX->slot;
    __asm { tzcnt   ebx, [rbx+4] }
    v13 = (__int64)&v8->attachments[slot];
    if ( _EBX >= *(_DWORD *)v13 )
    {
      LODWORD(v16) = *(_DWORD *)v13;
      LODWORD(v15) = _EBX;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19748, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentIndex ) < (unsigned)( attachmentList->attachmentCount )", "attachmentIndex doesn't index attachmentList->attachmentCount\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 8i64 * _EBX) + 16i64) != scr_const.combosequence )
      break;
    ++v2;
    ++v3;
  }
  while ( v3 < v4->numAnimOverrides );
  if ( v2 <= 1 )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19802, ASSERT_TYPE_ASSERT, "(comboCount > 1)", (const char *)&queryFormat, "comboCount > 1") )
      __debugbreak();
  }
  return (unsigned int)v2;
}

/*
==============
BG_GetMeleeCountToFinisher
==============
*/
bool BG_GetMeleeCountToFinisher(const Weapon *r_weapon, bool isAlternate, int *outCountToFinisher)
{
  unsigned int v3; 
  const dvar_t *v7; 
  bool result; 
  const WeaponDef *v9; 
  bool hasMeleeFinisher; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v12; 
  WeaponAttachment **v13; 
  AttMelee *melee; 
  WeaponAttachment **v15; 
  __int64 v16; 
  __int64 v17; 
  int v18; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  if ( !outCountToFinisher && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8846, ASSERT_TYPE_ASSERT, "( outCountToFinisher ) != ( nullptr )", "%s != %s\n\t%p, %p", "outCountToFinisher", "nullptr", NULL, NULL) )
    __debugbreak();
  v7 = DCONST_DVARMPBOOL_player_meleeFinisherEnabled;
  if ( !DCONST_DVARMPBOOL_player_meleeFinisherEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeFinisherEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
    return 0;
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  hasMeleeFinisher = v9->hasMeleeFinisher;
  *outCountToFinisher = v9->iMeleeCountToFinisher;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v13 = attachments;
    while ( 1 )
    {
      if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8863, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      melee = (*v13)->melee;
      if ( melee )
        break;
      ++v3;
      ++v13;
      if ( v3 >= (unsigned int)v12 )
        goto LABEL_18;
    }
    hasMeleeFinisher = melee->hasMeleeFinisher;
    *outCountToFinisher = melee->meleeCountToFinisher;
LABEL_18:
    v15 = attachments;
    v16 = v12;
    do
    {
      if ( !*v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8875, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v17 = (__int64)*v15++;
      v18 = *outCountToFinisher + *(_DWORD *)(v17 + 892);
      *outCountToFinisher = v18;
      --v16;
    }
    while ( v16 );
  }
  else
  {
    v18 = *outCountToFinisher;
  }
  if ( v18 > 7 )
    v18 = 7;
  if ( v18 < 1 )
    v18 = 1;
  result = hasMeleeFinisher;
  *outCountToFinisher = v18;
  return result;
}

/*
==============
BG_GetMeleeDamage
==============
*/
__int64 BG_GetMeleeDamage(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v9; 
  WeaponAttachment **v10; 
  AttMelee *melee; 
  WeaponAttachment **v12; 
  bool v14; 
  bool v15; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = 0;
  _EBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iMeleeDamage;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v10 = attachments;
    __asm { vmovaps [rsp+188h+var_28], xmm6 }
    while ( 1 )
    {
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8821, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      melee = (*v10)->melee;
      if ( melee )
        break;
      ++v6;
      ++v10;
      if ( v6 >= (unsigned int)v9 )
        goto LABEL_10;
    }
    _EBP = melee->meleeDamage;
LABEL_10:
    v12 = attachments;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    do
    {
      v14 = *v12 == NULL;
      if ( !*v12 )
      {
        v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8832, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v14 = !v15;
        if ( v15 )
          __debugbreak();
      }
      _RAX = *v12;
      __asm
      {
        vmovss  xmm1, dword ptr [rax+378h]
        vcomiss xmm1, xmm6
      }
      if ( !v14 )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, ebp
          vmulss  xmm1, xmm0, xmm1
          vcvttss2si ebp, xmm1
        }
      }
      ++v12;
      --v9;
    }
    while ( v9 );
    __asm { vmovaps xmm6, [rsp+188h+var_28] }
  }
  return _EBP;
}

/*
==============
BG_GetMeleeHeight
==============
*/
float BG_GetMeleeHeight(const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8996, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( _RBX->meleeOverrideValues )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0E9Ch] }
  }
  else
  {
    _RBX = DCONST_DVARFLT_player_meleeHeight;
    if ( !DCONST_DVARFLT_player_meleeHeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeHeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeInterruptTime
==============
*/
void BG_GetMeleeInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outToMeleeInterruptTime, int *outInterruptTime, int *outToFireInterruptTime)
{
  int *v12; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v17; 
  bool v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v27; 
  WeaponAttachment **v29; 
  __int64 v30; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v61; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  v12 = outToMeleeInterruptTime;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10059, ASSERT_TYPE_ASSERT, "( weaponMap ) != ( nullptr )", "%s != %s\n\t%p, %p", "weaponMap", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10060, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outToMeleeInterruptTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10061, ASSERT_TYPE_ASSERT, "( outToMeleeInterruptTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outToMeleeInterruptTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outInterruptTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10062, ASSERT_TYPE_ASSERT, "( outInterruptTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outInterruptTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outToFireInterruptTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10063, ASSERT_TYPE_ASSERT, "( outToFireInterruptTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outToFireInterruptTime", "nullptr", NULL, NULL) )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v17 = BG_UsingAlternateMelee(ps);
  if ( isFatal )
  {
    v18 = !v17;
    v19 = 42i64;
    v20 = 44i64;
    if ( v17 )
      v19 = 66i64;
    if ( v17 )
      v20 = 68i64;
    v21 = 40i64;
    v22 = 64i64;
  }
  else
  {
    v18 = !v17;
    v19 = 34i64;
    v20 = 36i64;
    if ( v17 )
      v19 = 58i64;
    v21 = 30i64;
    if ( v17 )
      v20 = 60i64;
    v22 = 54i64;
  }
  if ( !v18 )
    v21 = v22;
  *outToMeleeInterruptTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v19, NUM_WEAP_ANIMS);
  *outInterruptTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v20, NUM_WEAP_ANIMS);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  *outToFireInterruptTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v21, NUM_WEAP_ANIMS);
  __asm { vmovaps xmm7, xmm6 }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v27 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, CurrentWeaponForPlayer)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovaps xmm1, xmm6 }
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v29 = attachments;
    v30 = WeaponAttachments_Internal;
    do
    {
      if ( !BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, CurrentWeaponForPlayer, isAlternate, *v29, v27) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10097, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm { vaddss  xmm0, xmm7, dword ptr [rdi+2B4h] }
      ++v29;
      __asm
      {
        vsubss  xmm7, xmm0, xmm6
        vmovaps xmm1, xmm7
      }
      --v30;
    }
    while ( v30 );
    v12 = outToMeleeInterruptTime;
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm3, xmm1, xmm0
    vsubss  xmm1, xmm6, xmm3
    vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm0, xmm1, xmm1
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm7, xmm3, xmm6, xmm2
  }
  if ( BG_HasPerk(&ps->perks, 0x19u) )
  {
    _RBX = DCONST_DVARFLT_perk_fasterMeleeScale;
    if ( !DCONST_DVARFLT_perk_fasterMeleeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_fasterMeleeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rbp+0]
    vmulss  xmm1, xmm0, xmm7
    vmulss  xmm2, xmm1, xmm6
    vcvttss2si eax, xmm2
  }
  *v12 = _EAX;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rcx]
    vmulss  xmm1, xmm0, xmm7
    vmulss  xmm2, xmm1, xmm6
    vcvttss2si eax, xmm2
  }
  *outInterruptTime = _EAX;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rcx]
    vmulss  xmm1, xmm0, xmm7
    vmulss  xmm2, xmm1, xmm6
    vcvttss2si eax, xmm2
  }
  *outToFireInterruptTime = _EAX;
  _R11 = &v61;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
BG_GetMeleeRange
==============
*/
float BG_GetMeleeRange(const BgWeaponMap *weaponMap, const playerState_s *ps, const bool getChargeRange)
{
  const Weapon *CurrentWeaponForPlayer; 
  const WeaponDef *v9; 
  bool v10; 
  unsigned __int16 weaponIdx; 
  bool HasPerk; 
  bool v13; 
  EffectiveStance EffectiveStance; 

  __asm { vmovaps [rsp+58h+var_28], xmm6 }
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8939, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8940, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  BG_UsingAlternate(ps);
  v9 = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8945, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  v10 = BG_UsingAlternate(ps);
  if ( !BG_IsMeleeOnlyWeapon(CurrentWeaponForPlayer, v10) )
  {
    weaponIdx = BG_GetFirstEquippedWeaponBySlot(weaponMap, ps, WEAPON_SLOT_MELEE)->weaponIdx;
    if ( weaponIdx )
    {
      v9 = BG_WeaponDefAtIndex(weaponIdx);
      if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8953, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
    }
  }
  HasPerk = BG_HasPerk(&ps->perks, 0x14u);
  v13 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x1Du);
  EffectiveStance = PM_GetEffectiveStance(ps);
  *(float *)&_XMM0 = BG_GetMeleeRangeInternal(v9, getChargeRange, HasPerk, EffectiveStance);
  __asm { vmovaps xmm6, xmm0 }
  BG_GetMeleeRangeSlideScale(v13);
  __asm
  {
    vmulss  xmm0, xmm6, xmm0
    vmovaps xmm6, [rsp+58h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeRangeByWeapon
==============
*/
float BG_GetMeleeRangeByWeapon(const Weapon *r_weapon, const bool isAlternate, const bool getChargeRange, const bool hasExtendedMelee, const EffectiveStance stance, const bool isSliding)
{
  const WeaponDef *v11; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8965, ASSERT_TYPE_ASSERT, "(r_weapon.weaponIdx != 0)", (const char *)&queryFormat, "r_weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8969, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  *(float *)&_XMM0 = BG_GetMeleeRangeInternal(v11, getChargeRange, hasExtendedMelee, stance);
  __asm { vmovaps xmm6, xmm0 }
  BG_GetMeleeRangeSlideScale(isSliding);
  __asm
  {
    vmulss  xmm0, xmm6, xmm0
    vmovaps xmm6, [rsp+48h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeRangeInternal
==============
*/
float BG_GetMeleeRangeInternal(const WeaponDef *weapDef, const bool getChargeRange, const bool hasExtendedMelee, const EffectiveStance stance)
{
  __int32 v11; 
  __int32 v12; 
  __int32 v13; 
  __int32 v14; 
  const dvar_t *v15; 
  const char *v16; 

  _RDI = weapDef;
  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8888, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( getChargeRange && hasExtendedMelee )
  {
    _RBX = DCONST_DVARFLT_perk_extendedMeleeRange;
    if ( !DCONST_DVARFLT_perk_extendedMeleeRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_extendedMeleeRange") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
    return *(float *)&_XMM0;
  }
  if ( _RDI->meleeOverrideValues )
  {
    if ( stance == PM_EFF_STANCE_DEFAULT )
      goto LABEL_15;
    v11 = stance - 1;
    if ( !v11 )
    {
      __asm { vmovss  xmm0, dword ptr [rdi+0EACh] }
      return *(float *)&_XMM0;
    }
    v12 = v11 - 1;
    if ( !v12 )
    {
      if ( getChargeRange )
        __asm { vmovss  xmm0, dword ptr [rdi+0EB4h] }
      else
        __asm { vmovss  xmm0, dword ptr [rdi+0EA8h] }
      return *(float *)&_XMM0;
    }
    if ( v12 == 1 )
    {
LABEL_15:
      if ( getChargeRange )
        __asm { vmovss  xmm0, dword ptr [rdi+0EB0h] }
      else
        __asm { vmovss  xmm0, dword ptr [rdi+0EA4h] }
      return *(float *)&_XMM0;
    }
    goto LABEL_26;
  }
  if ( stance == PM_EFF_STANCE_DEFAULT )
    goto LABEL_33;
  v13 = stance - 1;
  if ( !v13 )
  {
    v15 = DCONST_DVARFLT_player_meleeRangeProne;
    v16 = "player_meleeRangeProne";
LABEL_36:
    *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(v15, v16);
    return *(float *)&_XMM0;
  }
  v14 = v13 - 1;
  if ( !v14 )
  {
    if ( getChargeRange )
    {
      v15 = DCONST_DVARFLT_player_meleeRangeChargeCrouched;
      v16 = "player_meleeRangeChargeCrouched";
    }
    else
    {
      v15 = DCONST_DVARFLT_player_meleeRangeCrouched;
      v16 = "player_meleeRangeCrouched";
    }
    goto LABEL_36;
  }
  if ( v14 == 1 )
  {
LABEL_33:
    if ( getChargeRange )
    {
      v15 = DCONST_DVARFLT_player_meleeRangeChargeStanding;
      v16 = "player_meleeRangeChargeStanding";
    }
    else
    {
      v15 = DCONST_DVARFLT_player_meleeRangeStanding;
      v16 = "player_meleeRangeStanding";
    }
    goto LABEL_36;
  }
LABEL_26:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8926, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "unreachable code") )
    __debugbreak();
  __asm { vxorps  xmm0, xmm0, xmm0 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeRangeSlideScale
==============
*/
float BG_GetMeleeRangeSlideScale(const bool isSliding)
{
  if ( isSliding )
  {
    _RBX = DCONST_DVARMPSPFLT_player_meleeRangeSlideScale;
    if ( !DCONST_DVARMPSPFLT_player_meleeRangeSlideScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeRangeSlideScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMeleeTime
==============
*/
void BG_GetMeleeTime(const BgWeaponMap *weaponMap, const playerState_s *ps, bool isAlternate, bool isDualWielding, bool isFatal, int *outMeleeTime, int *outMeleeDamageTime, int *outMeleeViewLockTime)
{
  int *v12; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v25; 
  WeaponAttachment **v27; 
  __int64 v28; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v59; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  v12 = outMeleeTime;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9980, ASSERT_TYPE_ASSERT, "( weaponMap ) != ( nullptr )", "%s != %s\n\t%p, %p", "weaponMap", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9981, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outMeleeTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9982, ASSERT_TYPE_ASSERT, "( outMeleeTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outMeleeTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outMeleeDamageTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9983, ASSERT_TYPE_ASSERT, "( outMeleeDamageTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outMeleeDamageTime", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outMeleeViewLockTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9984, ASSERT_TYPE_ASSERT, "( outMeleeViewLockTime ) != ( nullptr )", "%s != %s\n\t%p, %p", "outMeleeViewLockTime", "nullptr", NULL, NULL) )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v17 = BG_UsingAlternateMelee(ps);
  if ( isFatal )
  {
    if ( v17 )
    {
      v18 = 48i64;
      v19 = 62i64;
      v20 = 50i64;
    }
    else
    {
      v18 = 24i64;
      v19 = 38i64;
      v20 = 26i64;
    }
  }
  else if ( v17 )
  {
    v18 = 46i64;
    v19 = 52i64;
    v20 = 56i64;
  }
  else
  {
    v18 = 22i64;
    v19 = 28i64;
    v20 = 32i64;
  }
  *outMeleeTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v18, NUM_WEAP_ANIMS);
  *outMeleeDamageTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v19, NUM_WEAP_ANIMS);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  *outMeleeViewLockTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, CurrentWeaponForPlayer, isAlternate, isDualWielding, v20, NUM_WEAP_ANIMS);
  __asm { vmovaps xmm7, xmm6 }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v25 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, CurrentWeaponForPlayer)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovaps xmm1, xmm6 }
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v27 = attachments;
    v28 = WeaponAttachments_Internal;
    do
    {
      if ( !BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, CurrentWeaponForPlayer, isAlternate, *v27, v25) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10037, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm { vaddss  xmm0, xmm7, dword ptr [rdi+2B4h] }
      ++v27;
      __asm
      {
        vsubss  xmm7, xmm0, xmm6
        vmovaps xmm1, xmm7
      }
      --v28;
    }
    while ( v28 );
    v12 = outMeleeTime;
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm3, xmm1, xmm0
    vsubss  xmm1, xmm6, xmm3
    vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm0, xmm1, xmm1
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm7, xmm3, xmm6, xmm2
  }
  if ( BG_HasPerk(&ps->perks, 0x19u) )
  {
    _RBX = DCONST_DVARFLT_perk_fasterMeleeScale;
    if ( !DCONST_DVARFLT_perk_fasterMeleeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_fasterMeleeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rbp+0]
    vmulss  xmm1, xmm0, xmm7
    vmulss  xmm2, xmm1, xmm6
    vcvttss2si eax, xmm2
  }
  *v12 = _EAX;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rcx]
    vmulss  xmm1, xmm0, xmm7
    vmulss  xmm2, xmm1, xmm6
    vcvttss2si eax, xmm2
  }
  *outMeleeDamageTime = _EAX;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rcx]
    vmulss  xmm1, xmm0, xmm7
    vmulss  xmm2, xmm1, xmm6
    vcvttss2si eax, xmm2
  }
  *outMeleeViewLockTime = _EAX;
  _R11 = &v59;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
BG_GetMeleeWidth
==============
*/
float BG_GetMeleeWidth(const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8980, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( _RBX->meleeOverrideValues )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0EA0h] }
  }
  else
  {
    _RBX = DCONST_DVARFLT_player_meleeWidth;
    if ( !DCONST_DVARFLT_player_meleeWidth && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_meleeWidth") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMidDamage
==============
*/
void BG_GetMidDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMid1Damage, int *outMid2Damage, int *outMid3Damage)
{
  __int64 v8; 
  const WeaponDef *v10; 
  int v11; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttDamage *damage; 
  __int64 numAttachmentSlots; 
  __int64 numAttachmentSlotsa; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  __int64 v19; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = damageCalcType;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8786, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( (unsigned int)v8 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
      __debugbreak();
  }
  v11 = 0;
  *outMid1Damage = v10->damageInfo.damageData[v8].mid1Damage;
  *outMid2Damage = v10->damageInfo.damageData[v8].mid2Damage;
  *outMid3Damage = v10->damageInfo.damageData[v8].mid3Damage;
  v19 = v8;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8800, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      damage = (*i)->damage;
      if ( damage )
        break;
      if ( ++v11 >= WeaponAttachments_Internal )
        return;
    }
    if ( (unsigned int)v8 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(numAttachmentSlotsa) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlotsa, attachmentSlotsa) )
        __debugbreak();
    }
    *outMid1Damage = damage->damageInfo.damageData[v19].mid1Damage;
    *outMid2Damage = damage->damageInfo.damageData[v19].mid2Damage;
    *outMid3Damage = damage->damageInfo.damageData[v19].mid3Damage;
  }
}

/*
==============
BG_GetMinDamage
==============
*/
__int64 BG_GetMinDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  __int64 v8; 
  int v9; 
  __int64 v10; 
  int outMinDamage; 
  int outMaxDamage; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v9 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8678, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v9) )
      __debugbreak();
    LODWORD(v10) = 3;
    LODWORD(v8) = damageCalcType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8680, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", v8, v10) )
      __debugbreak();
  }
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(damageCalcType, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  return (unsigned int)outMinDamage;
}

/*
==============
BG_GetMinMaxDamage
==============
*/
void BG_GetMinMaxDamage(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, int *outMinDamage, int *outMaxDamage)
{
  __int64 v6; 
  const WeaponDef *v9; 
  __int64 v10; 
  int minDamage; 
  int damage; 
  int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  int *v16; 
  int v17; 
  int v18; 
  __int64 numAttachmentSlots; 
  __int64 numAttachmentSlotsa; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = damageCalcType;
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8759, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( (unsigned int)v6 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots) )
      __debugbreak();
  }
  v10 = 10 * v6;
  minDamage = v9->damageInfo.damageData[v6].minDamage;
  if ( minDamage < 0 )
    minDamage = v9->damageInfo.damageData[0].minDamage;
  *outMinDamage = minDamage;
  damage = v9->damageInfo.damageData[(unsigned __int64)v10 / 0xA].damage;
  if ( damage < 0 )
    damage = v9->damageInfo.damageData[0].damage;
  *outMaxDamage = damage;
  v13 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8774, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v16 = (int *)(*i)->damage;
      if ( v16 )
        break;
      if ( ++v13 >= WeaponAttachments_Internal )
        return;
    }
    if ( (unsigned int)v6 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(numAttachmentSlotsa) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlotsa, attachmentSlotsa) )
        __debugbreak();
    }
    v17 = v16[v10];
    if ( v17 < 0 )
      v17 = *v16;
    *outMinDamage = v17;
    v18 = v16[v10 + 4];
    if ( v18 < 0 )
      v18 = v16[4];
    *outMaxDamage = v18;
  }
}

/*
==============
BG_GetMotionBlurProperties
==============
*/
void BG_GetMotionBlurProperties(const playerState_s *ps, const BgHybridScopeFraction *hybridScopeFraction, const Weapon *weapon, const bool isAlternate, const float adsLerp, float *outBlur, int *outBlurDurationMs, float *outBlurDecayExponent)
{
  unsigned int WeaponAttachments_Internal; 
  __int64 v31; 
  unsigned int v35; 
  WeaponAttachment **v36; 
  __int64 v51; 
  WeaponAttachment **v52; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v128; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  _R13 = hybridScopeFraction;
  _RBX = BG_WeaponDefAtIndex(weapon->weaponIdx);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19366, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+1398h]
    vmovss  [rsp+278h+var_22C], xmm6
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, dword ptr [rbx+139Ch]
    vmovss  [rsp+278h+var_228], xmm6
    vmovss  xmm6, dword ptr [rbx+13A0h]
    vmovss  [rsp+278h+var_218], xmm6
    vmovss  xmm6, dword ptr [rbx+13A4h]
    vmovss  [rsp+278h+var_224], xmm6
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, dword ptr [rbx+13A8h]
  }
  v31 = WeaponAttachments_Internal;
  __asm
  {
    vmovss  [rsp+278h+var_220], xmm6
    vmovss  xmm6, dword ptr [rbx+13ACh]
    vxorps  xmm9, xmm9, xmm9
    vcomiss xmm9, dword ptr [r13+0]
    vmovss  [rsp+278h+var_21C], xmm6
    vmovss  xmm11, cs:__real@3f000000
  }
  v35 = 0;
  if ( WeaponAttachments_Internal )
  {
    v36 = attachments;
    while ( 1 )
    {
      if ( !*v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19388, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v36)->post )
        break;
      ++v35;
      ++v36;
      if ( v35 >= (unsigned int)v31 )
        goto LABEL_13;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vmovss  [rsp+278h+var_22C], xmm0
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [rbx+4]
      vmovss  [rsp+278h+var_228], xmm0
      vmovss  xmm0, dword ptr [rbx+8]
      vmovss  [rsp+278h+var_218], xmm0
      vmovss  xmm0, dword ptr [rbx+0Ch]
      vmovss  [rsp+278h+var_224], xmm0
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [rbx+10h]
      vmovss  [rsp+278h+var_220], xmm0
      vmovss  xmm0, dword ptr [rbx+14h]
      vmovss  [rsp+278h+var_21C], xmm0
    }
  }
LABEL_13:
  __asm
  {
    vmovss  xmm12, cs:__real@3f800000
    vmovaps xmm1, xmm12
    vmovss  [rsp+278h+var_230], xmm1
    vmovaps xmm15, xmm12
    vmovaps xmm14, xmm12
    vmovaps xmm13, xmm12
  }
  if ( (_DWORD)v31 )
  {
    v51 = v31;
    __asm { vmovaps [rsp+278h+var_88], xmm10 }
    v52 = attachments;
    do
    {
      _RBX = *v52;
      if ( !*v52 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19433, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm
      {
        vmovss  xmm7, dword ptr [rbx+340h]
        vmovss  xmm6, dword ptr [rbx+344h]
        vmovss  xmm8, dword ptr [rbx+348h]
        vmovss  xmm10, dword ptr [rbx+34Ch]
        vcomiss xmm7, xmm9
        vmovss  xmm1, [rsp+278h+var_230]
        vcomiss xmm6, xmm9
        vcomiss xmm8, xmm9
        vcomiss xmm10, xmm9
      }
      ++v52;
      --v51;
    }
    while ( v51 );
    __asm { vmovaps xmm10, [rsp+278h+var_88] }
  }
  __asm
  {
    vmovss  xmm4, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovsd  xmm6, cs:__real@3eb0c6f7a0b5ed8d
  }
  _RAX = outBlur;
  __asm
  {
    vmaxss  xmm2, xmm1, xmm9
    vsubss  xmm0, xmm12, xmm2
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm1, xmm2, xmm12, xmm0
    vmulss  xmm8, xmm1, [rsp+278h+var_22C]
    vmaxss  xmm3, xmm15, xmm9
    vsubss  xmm0, xmm12, xmm3
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm3, xmm12, xmm2
    vmulss  xmm7, xmm0, [rsp+278h+var_228]
    vmaxss  xmm3, xmm14, xmm9
    vsubss  xmm0, xmm12, xmm3
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm3, xmm12, xmm2
    vmulss  xmm5, xmm0, [rsp+278h+var_224]
    vmaxss  xmm3, xmm13, xmm9
    vsubss  xmm0, xmm12, xmm3
    vandps  xmm0, xmm0, xmm4
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vmovss  xmm6, [rsp+278h+adsLerp]
    vblendvps xmm4, xmm3, xmm12, xmm2
    vsubss  xmm3, xmm12, xmm6
    vmulss  xmm1, xmm3, xmm5
    vmulss  xmm0, xmm8, xmm6
    vaddss  xmm1, xmm1, xmm0
    vmulss  xmm0, xmm4, [rsp+278h+var_220]
    vmovss  dword ptr [rax], xmm1
    vmulss  xmm2, xmm0, xmm3
    vmulss  xmm0, xmm6, [rsp+278h+var_218]
    vmulss  xmm1, xmm7, xmm6
    vaddss  xmm2, xmm2, xmm1
    vmulss  xmm1, xmm3, [rsp+278h+var_21C]
    vcvttss2si eax, xmm2
  }
  *outBlurDurationMs = (int)_RAX;
  _RAX = outBlurDecayExponent;
  __asm
  {
    vaddss  xmm1, xmm1, xmm0
    vmovss  dword ptr [rax], xmm1
  }
  _R11 = &v128;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
BG_GetMountEdgeToEyeDistance
==============
*/
void BG_GetMountEdgeToEyeDistance(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, float *outForward, float *outAbove)
{
  const WeaponDef *v10; 

  if ( !outForward && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21869, ASSERT_TYPE_ASSERT, "(outForward)", (const char *)&queryFormat, "outForward") )
    __debugbreak();
  _RBX = outAbove;
  if ( !outAbove && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21870, ASSERT_TYPE_ASSERT, "(outAbove)", (const char *)&queryFormat, "outAbove") )
    __debugbreak();
  v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RCX = v10;
  if ( !v10 )
    goto LABEL_8;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    *outForward = v10->mountTopEdgeToEyeDistanceForward;
    __asm { vmovss  xmm0, dword ptr [rcx+133Ch] }
    goto LABEL_13;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
  {
    *outForward = v10->mountSideEdgeToEyeDistanceForward;
    __asm { vmovss  xmm0, dword ptr [rcx+1374h] }
  }
  else
  {
LABEL_8:
    *outForward = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
LABEL_13:
  __asm { vmovss  dword ptr [rbx], xmm0 }
}

/*
==============
BG_GetMountEnterExitDuration
==============
*/
void BG_GetMountEnterExitDuration(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate, int *outEnterDurationMs, int *outExitDurationMs)
{
  const WeaponDef *v8; 
  int mountTopExitDurationMs; 

  if ( !outEnterDurationMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21943, ASSERT_TYPE_ASSERT, "(outEnterDurationMs)", (const char *)&queryFormat, "outEnterDurationMs") )
    __debugbreak();
  if ( !outExitDurationMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21944, ASSERT_TYPE_ASSERT, "(outExitDurationMs)", (const char *)&queryFormat, "outExitDurationMs") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v8 )
  {
    *outEnterDurationMs = 1;
LABEL_17:
    *outExitDurationMs = 1;
    goto LABEL_18;
  }
  if ( mountType == MOUNT_TYPE_TOP )
  {
    *outEnterDurationMs = v8->mountTopEnterDurationMs;
    mountTopExitDurationMs = v8->mountTopExitDurationMs;
  }
  else if ( (unsigned int)(mountType - 2) > 1 )
  {
    *outEnterDurationMs = 1;
    mountTopExitDurationMs = 1;
  }
  else
  {
    *outEnterDurationMs = v8->mountSideEnterDurationMs;
    mountTopExitDurationMs = v8->mountSideExitDurationMs;
  }
  *outExitDurationMs = mountTopExitDurationMs;
  if ( *outEnterDurationMs <= 0 )
  {
    *outEnterDurationMs = 1;
    mountTopExitDurationMs = *outExitDurationMs;
  }
  if ( mountTopExitDurationMs <= 0 )
    goto LABEL_17;
LABEL_18:
  if ( *outEnterDurationMs <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21981, ASSERT_TYPE_ASSERT, "(0 < *outEnterDurationMs)", (const char *)&queryFormat, "0 < *outEnterDurationMs") )
    __debugbreak();
  if ( *outExitDurationMs <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21982, ASSERT_TYPE_ASSERT, "(0 < *outExitDurationMs)", (const char *)&queryFormat, "0 < *outExitDurationMs") )
    __debugbreak();
}

/*
==============
BG_GetMountFOVScale
==============
*/
float BG_GetMountFOVScale(const Weapon *r_weapon, bool isAlternate)
{
  if ( BG_WeaponDefAtIndex(r_weapon->weaponIdx) )
    __asm { vmovss  xmm0, dword ptr [rax+137Ch] }
  else
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMountGunCenterScale
==============
*/
float BG_GetMountGunCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RDX = _RAX;
  if ( !_RAX )
    goto LABEL_2;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm0, dword ptr [rax+131Ch] }
    return *(float *)&_XMM0;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
    __asm { vmovss  xmm0, dword ptr [rdx+1354h] }
  else
LABEL_2:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMountGunIdleScale
==============
*/
float BG_GetMountGunIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RDX = _RAX;
  if ( !_RAX )
    goto LABEL_2;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm0, dword ptr [rax+1328h] }
    return *(float *)&_XMM0;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
    __asm { vmovss  xmm0, dword ptr [rdx+1360h] }
  else
LABEL_2:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMountGunKickScale
==============
*/
float BG_GetMountGunKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RDX = _RAX;
  if ( !_RAX )
    goto LABEL_2;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm0, dword ptr [rax+1318h] }
    return *(float *)&_XMM0;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
    __asm { vmovss  xmm0, dword ptr [rdx+1350h] }
  else
LABEL_2:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMountRumble
==============
*/
const WeaponDef *BG_GetMountRumble(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *result; 

  result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( result )
    return (const WeaponDef *)result->mountRumble;
  return result;
}

/*
==============
BG_GetMountSideRoll
==============
*/
void BG_GetMountSideRoll(const Weapon *r_weapon, bool isAlternate, float *outRollDeg, float *outStartFrac, float *outEndFrac)
{
  const WeaponDef *v7; 

  *outRollDeg = 0.0;
  *outStartFrac = 0.0;
  *outEndFrac = 1.0;
  v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v7 )
  {
    *outRollDeg = v7->mountSideRoll;
    *outStartFrac = v7->mountSideRollStartFrac;
    *outEndFrac = v7->mountSideRollEndFrac;
  }
}

/*
==============
BG_GetMountTransitionEnabled
==============
*/
const WeaponDef *BG_GetMountTransitionEnabled(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *result; 

  result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( result )
    return (const WeaponDef *)result->mountSideTransitionEnable;
  return result;
}

/*
==============
BG_GetMountViewCenterScale
==============
*/
float BG_GetMountViewCenterScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RDX = _RAX;
  if ( !_RAX )
    goto LABEL_2;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm0, dword ptr [rax+1324h] }
    return *(float *)&_XMM0;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
    __asm { vmovss  xmm0, dword ptr [rdx+135Ch] }
  else
LABEL_2:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMountViewIdleScale
==============
*/
float BG_GetMountViewIdleScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RDX = _RAX;
  if ( !_RAX )
    goto LABEL_2;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm0, dword ptr [rax+132Ch] }
    return *(float *)&_XMM0;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
    __asm { vmovss  xmm0, dword ptr [rdx+1364h] }
  else
LABEL_2:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMountViewKickScale
==============
*/
float BG_GetMountViewKickScale(const ContextMountType mountType, const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RDX = _RAX;
  if ( !_RAX )
    goto LABEL_2;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm0, dword ptr [rax+1320h] }
    return *(float *)&_XMM0;
  }
  if ( (unsigned int)(mountType - 2) <= 1 )
    __asm { vmovss  xmm0, dword ptr [rdx+1358h] }
  else
LABEL_2:
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMountViewmodelOffset
==============
*/
float BG_GetMountViewmodelOffset(const Weapon *r_weapon, bool isAlternate)
{
  if ( BG_WeaponDefAtIndex(r_weapon->weaponIdx) )
    __asm { vmovss  xmm0, dword ptr [rax+1378h] }
  else
    __asm { vxorps  xmm0, xmm0, xmm0 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetMoveSpeedScale
==============
*/
void BG_GetMoveSpeedScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *moveSpeedScaleOut, float *adsMoveSpeedScaleOut)
{
  const WeaponDef *v16; 
  unsigned int v17; 
  __int64 WeaponAttachments_Internal; 
  WeaponAttachment **v19; 
  WeaponAttachment *v20; 
  float *p_moveSpeedScale; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v23; 
  __int64 v27; 
  const WeaponAttachment **v28; 
  bool v29; 
  const WeaponAttachment *v30; 
  AttMovement *movementScaleMain; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v57; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _R13 = adsMoveSpeedScaleOut;
  if ( !moveSpeedScaleOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8194, ASSERT_TYPE_ASSERT, "(moveSpeedScaleOut)", (const char *)&queryFormat, "moveSpeedScaleOut") )
    __debugbreak();
  if ( !adsMoveSpeedScaleOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8195, ASSERT_TYPE_ASSERT, "(adsMoveSpeedScaleOut)", (const char *)&queryFormat, "adsMoveSpeedScaleOut") )
    __debugbreak();
  v16 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v17 = 0;
  *moveSpeedScaleOut = v16->moveSpeedScale;
  *adsMoveSpeedScaleOut = v16->adsMoveSpeedScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v19 = attachments;
    while ( 1 )
    {
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8203, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v20 = *v19;
      p_moveSpeedScale = &(*v19)->movement->moveSpeedScale;
      if ( p_moveSpeedScale )
        break;
      ++v17;
      ++v19;
      if ( v17 >= (unsigned int)WeaponAttachments_Internal )
        goto LABEL_16;
    }
    *moveSpeedScaleOut = *p_moveSpeedScale;
    *adsMoveSpeedScaleOut = v20->movement->adsMoveSpeedScale;
  }
LABEL_16:
  v23 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vmovaps xmm6, xmm8
    vmovaps xmm9, xmm8
  }
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v27 = WeaponAttachments_Internal;
    v28 = (const WeaponAttachment **)attachments;
    do
    {
      if ( !*v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8218, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v29 = BG_AttachmentUseMainSettings(*v28, isAlternate, v23);
      v30 = *v28;
      if ( v29 )
        movementScaleMain = v30->movementScaleMain;
      else
        movementScaleMain = v30->movementScale;
      if ( movementScaleMain )
      {
        __asm
        {
          vaddss  xmm1, xmm9, dword ptr [rax+4]
          vaddss  xmm0, xmm6, dword ptr [rax]
          vsubss  xmm9, xmm1, xmm8
          vsubss  xmm6, xmm0, xmm8
        }
      }
      ++v28;
      --v27;
    }
    while ( v27 );
    _R13 = adsMoveSpeedScaleOut;
  }
  _RAX = moveSpeedScaleOut;
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vmaxss  xmm2, xmm6, xmm7
    vsubss  xmm0, xmm8, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm2, xmm8, xmm0
    vmulss  xmm0, xmm1, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
    vmaxss  xmm3, xmm9, xmm7
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm8, xmm2
    vmulss  xmm0, xmm0, dword ptr [r13+0]
    vmovss  dword ptr [r13+0], xmm0
  }
  _R11 = &v57;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
BG_GetMultipleReloadClipPercentage
==============
*/
float BG_GetMultipleReloadClipPercentage(const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm { vmovss  xmm0, dword ptr [rax+888h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetNextSpectateViewWeapons
==============
*/
char BG_GetNextSpectateViewWeapons(const BgWeaponMap *const weaponMap, const characterInfo_t *const ci, Weapon (*outViewWeapons)[24], unsigned int *inOutWeaponCount)
{
  const characterInfo_t *v5; 
  unsigned int v6; 
  const Weapon *__ptr32 const *v7; 
  const WeaponDef *v9; 
  unsigned int v10; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int8 *v12; 
  WeaponAttachment **v13; 
  WeaponAttachment *v14; 
  unsigned __int8 v15; 
  unsigned __int8 v16; 
  int numModelVariations; 
  int v18; 
  __int64 v19; 
  __int64 v25; 
  __int64 v26; 
  unsigned int v27; 
  const Weapon *__ptr32 const *i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RSI = outViewWeapons;
  v5 = ci;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22635, ASSERT_TYPE_ASSERT, "( ( weaponMap != nullptr ) )", "( weaponMap ) = %p", NULL) )
    __debugbreak();
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22636, ASSERT_TYPE_ASSERT, "( ( ci != nullptr ) )", "( ci ) = %p", NULL) )
    __debugbreak();
  v6 = 0;
  v7 = NEXT_SPECTATE_WEAPON_MEMBERS;
  v27 = 0;
  for ( i = NEXT_SPECTATE_WEAPON_MEMBERS; ; ++i )
  {
    _R12 = (const Weapon *)((char *)v5 + *(int *)v7);
    if ( _R12->weaponIdx )
      break;
LABEL_36:
    ++v6;
    v7 = i + 1;
    v27 = v6;
    if ( v6 >= 2 )
      return 1;
  }
  v9 = BG_WeaponDefAtIndex(_R12->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22562, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
    __debugbreak();
  if ( !v9->hasAnyTransientModels )
    goto LABEL_35;
  if ( *(_WORD *)&v9->transientBaseViewFlags )
    goto LABEL_33;
  v10 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(_R12, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
  {
LABEL_35:
    v5 = ci;
    goto LABEL_36;
  }
  v12 = attachmentIds;
  v13 = attachments;
  while ( 1 )
  {
    v14 = *v13;
    if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22581, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    v15 = *v12;
    if ( *v12 >= 0x1Du )
    {
      LODWORD(v26) = 29;
      LODWORD(v25) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22584, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentId ) < (unsigned)( ( sizeof( *array_counter( weapon.attachmentVariationIndices ) ) + 0 ) )", "attachmentId doesn't index ARRAY_COUNT( weapon.attachmentVariationIndices )\n\t%i not in [0, %i)", v25, v26) )
        __debugbreak();
    }
    v16 = _R12->attachmentVariationIndices[v15];
    if ( v16 >= 0x10u )
    {
      LODWORD(v26) = 16;
      LODWORD(v25) = v16;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22587, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( 16 )", "variationIndex doesn't index MAX_ATT_XMODEL_VARIATION\n\t%i not in [0, %i)", v25, v26) )
        __debugbreak();
    }
    numModelVariations = v14->numModelVariations;
    if ( v16 < numModelVariations )
    {
      if ( v16 >= (unsigned int)numModelVariations )
      {
        LODWORD(v26) = v14->numModelVariations;
        LODWORD(v25) = v16;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22594, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( attachment->numModelVariations )", "variationIndex doesn't index attachment->numModelVariations\n\t%i not in [0, %i)", v25, v26) )
          __debugbreak();
      }
      v18 = v14->transientViewFlags | v14->transientWorldFlags;
      if ( _bittest(&v18, v16) )
        break;
    }
    ++v10;
    ++v13;
    ++v12;
    if ( v10 >= AllWeaponAttachmentsWithIds )
    {
      v6 = v27;
      _RSI = outViewWeapons;
      goto LABEL_35;
    }
  }
  v6 = v27;
  _RSI = outViewWeapons;
LABEL_33:
  v19 = *inOutWeaponCount;
  if ( (unsigned int)v19 < 0x18 )
  {
    __asm { vmovups ymm0, ymmword ptr [r12] }
    _RCX = v19;
    __asm
    {
      vmovups ymmword ptr [rcx+rsi], ymm0
      vmovups xmm1, xmmword ptr [r12+20h]
      vmovups xmmword ptr [rcx+rsi+20h], xmm1
      vmovsd  xmm0, qword ptr [r12+30h]
      vmovsd  qword ptr [rcx+rsi+30h], xmm0
    }
    *(_DWORD *)&(*_RSI)[_RCX].weaponCamo = *(_DWORD *)&_R12->weaponCamo;
    ++*inOutWeaponCount;
    goto LABEL_35;
  }
  return 0;
}

/*
==============
BG_GetNotetrackOverrides
==============
*/
char BG_GetNotetrackOverrides(const Weapon *r_weapon, bool isAlternate, unsigned int *numMappings, const scr_string_t **keys, const scr_string_t **values)
{
  unsigned int AllWeaponAttachmentsWithIds; 
  __int64 v9; 
  const WeaponCompleteDef *v10; 
  scr_string_t attachment; 
  unsigned int v12; 
  WeaponAttachment **v13; 
  WeaponAttachment *v14; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !numMappings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2563, ASSERT_TYPE_ASSERT, "(numMappings)", (const char *)&queryFormat, "numMappings") )
    __debugbreak();
  if ( !keys && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2564, ASSERT_TYPE_ASSERT, "(keys)", (const char *)&queryFormat, "keys") )
    __debugbreak();
  if ( !values && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2565, ASSERT_TYPE_ASSERT, "(values)", (const char *)&queryFormat, "values") )
    __debugbreak();
  if ( !isAlternate )
    return 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
    return 0;
  v9 = 0i64;
  v10 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !v10->numNotetrackOverrides )
    return 0;
  while ( 1 )
  {
    attachment = v10->notetrackOverrides[v9].attachment;
    if ( attachment )
      break;
LABEL_21:
    v9 = (unsigned int)(v9 + 1);
    if ( (unsigned int)v9 >= v10->numNotetrackOverrides )
      return 0;
  }
  v12 = 0;
  v13 = attachments;
  while ( 1 )
  {
    v14 = *v13;
    if ( !*v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1789, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v14->internalName == attachment )
      break;
    ++v12;
    ++v13;
    if ( v12 >= AllWeaponAttachmentsWithIds )
      goto LABEL_21;
  }
  *keys = v10->notetrackOverrides[v9].notetrackSoundMapKeys;
  *values = v10->notetrackOverrides[v9].notetrackSoundMapValues;
  *numMappings = v10->notetrackOverrides[v9].numSoundMappings;
  return 1;
}

/*
==============
BG_GetOffhandAllowsSprint
==============
*/
bool BG_GetOffhandAllowsSprint(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9774, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->offhandAllowsSprint;
}

/*
==============
BG_GetOffhandClass
==============
*/
__int64 BG_GetOffhandClass(const playerState_s *ps, const OffhandSlot slot, const BgWeaponMap *weaponMap)
{
  OffhandClass outOffhandClass; 

  outOffhandClass = OFFHAND_CLASS_NONE;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2645, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_GameInterface_GetOffhandClass(ps, slot, weaponMap, &outOffhandClass) )
    return (unsigned int)outOffhandClass;
  switch ( slot )
  {
    case OFFHAND_SLOT_PRIMARY:
      return (unsigned int)ps->weapCommon.offhandPrimary;
    case OFFHAND_SLOT_SECONDARY:
      return (unsigned int)ps->weapCommon.offhandSecondary;
    case OFFHAND_SLOT_SPECIAL:
      return (unsigned int)ps->weapCommon.offhandSpecial;
  }
  if ( slot != OFFHAND_SLOT_SCRIPTED )
    return (unsigned int)outOffhandClass;
  else
    return (unsigned int)ps->weapCommon.offhandScripted;
}

/*
==============
BG_GetOffhandMaxHoldTime
==============
*/
__int64 BG_GetOffhandMaxHoldTime(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9788, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (unsigned int)v4->maxHoldTime;
}

/*
==============
BG_GetOffhandOverCookIsNotLethal
==============
*/
bool BG_GetOffhandOverCookIsNotLethal(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9802, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->overCookIsNotLethal;
}

/*
==============
BG_GetOnePieceReticle
==============
*/
Material *BG_GetOnePieceReticle(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  Material *reticleOnePiece; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  reticleOnePiece = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reticleOnePiece;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return reticleOnePiece;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16612, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return reticleOnePiece;
  }
  return general->reticleOnePiece;
}

/*
==============
BG_GetOtherAdsDownAnim
==============
*/
__int64 BG_GetOtherAdsDownAnim(const weapAnimFiles_t adsAnim)
{
  if ( adsAnim == WEAP_ANIM_ADS_DOWN )
    return 408i64;
  if ( adsAnim != WEAP_ANIM_ADS_DOWN_NVG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17863, ASSERT_TYPE_ASSERT, "(adsAnim == WEAP_ANIM_ADS_DOWN_NVG)", (const char *)&queryFormat, "adsAnim == WEAP_ANIM_ADS_DOWN_NVG") )
    __debugbreak();
  return 407i64;
}

/*
==============
BG_GetOtherAdsSettleAnim
==============
*/
__int64 BG_GetOtherAdsSettleAnim(const weapAnimFiles_t adsSettleAnim)
{
  if ( adsSettleAnim == WEAP_ANIM_ADDITIVE_SETTLE_ADS )
    return 165i64;
  if ( adsSettleAnim != WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17900, ASSERT_TYPE_ASSERT, "(adsSettleAnim == WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG)", (const char *)&queryFormat, "adsSettleAnim == WEAP_ANIM_ADDITIVE_SETTLE_ADS_NVG") )
    __debugbreak();
  return 164i64;
}

/*
==============
BG_GetOtherAdsUpAnim
==============
*/
__int64 BG_GetOtherAdsUpAnim(const weapAnimFiles_t adsAnim)
{
  if ( adsAnim == WEAP_ANIM_ADS_UP )
    return 406i64;
  if ( adsAnim != WEAP_ANIM_ADS_UP_NVG && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17831, ASSERT_TYPE_ASSERT, "(adsAnim == WEAP_ANIM_ADS_UP_NVG)", (const char *)&queryFormat, "adsAnim == WEAP_ANIM_ADS_UP_NVG") )
    __debugbreak();
  return 405i64;
}

/*
==============
BG_GetOverlay
==============
*/
AttADSOverlay *BG_GetOverlay(const Weapon *r_weapon, bool isAlternate)
{
  bool v3; 
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttADSOverlay *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = isAlternate && BG_HasUnderbarrelAmmo(r_weapon);
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v3, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (AttADSOverlay *)&v4->overlay;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15369, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (*i)->adsOverlay;
    if ( result )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (AttADSOverlay *)&v4->overlay;
  }
  return result;
}

/*
==============
BG_GetOverlayReticle
==============
*/
__int64 BG_GetOverlayReticle(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const ADSOverlay *Overlay; 

  if ( ps && BG_PWF_UseAlternateAsOffhand(ps) && r_weapon->weaponAttachments[9] )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15517, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
      __debugbreak();
    isAlternate = 0;
  }
  Overlay = BG_GetOverlay(r_weapon, isAlternate);
  if ( Overlay )
    return (unsigned int)Overlay->reticle;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15523, ASSERT_TYPE_ASSERT, "(overlay)", (const char *)&queryFormat, "overlay") )
    __debugbreak();
  return MEMORY[0x44];
}

/*
==============
BG_GetOverrideAttachmentWhenApplicable
==============
*/
WeaponAttachment *BG_GetOverrideAttachmentWhenApplicable(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const WeaponAttachment *attachment, const bool usingHybridScope)
{
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  WeaponAttachment *result; 
  WeaponAttachment *outDataAttachment; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 477, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 478, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  if ( !usingHybridScope )
    return (WeaponAttachment *)attachment;
  outDataAttachment = NULL;
  HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(weapon, isAlternate, (const WeaponAttachment **)&outDataAttachment);
  result = outDataAttachment;
  if ( !outDataAttachment || HybridScopeEnablerAttachment != attachment )
    return (WeaponAttachment *)attachment;
  return result;
}

/*
==============
BG_GetPenetrateMultiplier
==============
*/
float BG_GetPenetrateMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v7; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RDI = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7884, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
    __debugbreak();
  __asm { vmovss  xmm6, dword ptr [rdi+1C8h] }
  v7 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7892, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->penetration )
        break;
      ++v7;
      ++v9;
      if ( v7 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_12;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx+4] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_12:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetPenetrateType
==============
*/
__int64 BG_GetPenetrateType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  PenetrateType penetrateType; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7859, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7860, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  penetrateType = v4->penetrateType;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)penetrateType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7869, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return (unsigned int)penetrateType;
  }
  return (unsigned int)penetration->penetrateType;
}

/*
==============
BG_GetPlayerDamageRange
==============
*/
void BG_GetPlayerDamageRange(const WeaponDamageCalcType damageCalcType, const BgWeaponMap *weaponMap, const playerState_s *ps, const bitarray<64> *r_perks, const Weapon *r_weapon, bool isAlternate, float *minDamageRange, float *maxDamageRange)
{
  int v21; 

  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
  {
    v21 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9493, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, v21) )
      __debugbreak();
  }
  *(double *)&_XMM0 = BG_GetADSDamageRangeScale(weaponMap, ps, r_weapon, isAlternate);
  _RBP = maxDamageRange;
  _R14 = minDamageRange;
  __asm { vmovaps xmm3, xmm0; rangeScale }
  BG_GetDamageRange(damageCalcType, r_weapon, isAlternate, *(float *)&_XMM3, minDamageRange, maxDamageRange);
  if ( BG_HasPerk(r_perks, 0x18u) )
  {
    _RBX = DCONST_DVARFLT_perk_longerRangeScale;
    if ( !DCONST_DVARFLT_perk_longerRangeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_longerRangeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm1, dword ptr [rbx+28h]
      vmulss  xmm0, xmm1, dword ptr [r14]
      vmovss  dword ptr [r14], xmm0
      vmulss  xmm1, xmm1, dword ptr [rbp+0]
      vmovss  dword ptr [rbp+0], xmm1
    }
  }
}

/*
==============
BG_GetProjectileSpeed
==============
*/
void BG_GetProjectileSpeed(const Weapon *r_weapon, bool isAlternate, int *projectileSpeed, int *projectileSpeedUp)
{
  const WeaponDef *v8; 
  int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v12; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !projectileSpeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17038, ASSERT_TYPE_ASSERT, "(projectileSpeed)", (const char *)&queryFormat, "projectileSpeed") )
    __debugbreak();
  if ( !projectileSpeedUp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17039, ASSERT_TYPE_ASSERT, "(projectileSpeedUp)", (const char *)&queryFormat, "projectileSpeedUp") )
    __debugbreak();
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v9 = 0;
  *projectileSpeed = v8->iProjectileSpeed;
  *projectileSpeedUp = v8->iProjectileSpeedUp;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17048, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v12 = *i;
      projectile = (*i)->projectile;
      if ( projectile )
        break;
      if ( ++v9 >= WeaponAttachments_Internal )
        return;
    }
    *projectileSpeed = projectile->projectileSpeed;
    *projectileSpeedUp = v12->projectile->projectileSpeedUp;
  }
}

/*
==============
BG_GetRegularWeaponFieldTime
==============
*/
__int64 BG_GetRegularWeaponFieldTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const WeaponDef *weapDef, __int64 offset, unsigned __int16 timer, const weapAnimFiles_t dependentAnimType)
{
  __int64 v8; 
  bool v10; 
  const Weapon *v11; 
  const playerState_s *v12; 
  unsigned int v13; 
  unsigned int v14; 
  AnimOverride *animOverrides; 
  __int64 v16; 
  unsigned int numBindings; 
  AnimOverride *v18; 
  WeaponAnimPackage *overridesAlt; 
  const CarryObjectDef *PlayerCarryObjectDef; 
  CarryAnimOverride *i; 
  WeaponAnimPackage *animPackage; 
  WeaponAnimPackage *animPackageAlt; 
  unsigned __int16 v25; 
  WeaponAnimPackageStateTimers *timers; 

  v8 = 0i64;
  v10 = isAlternate;
  v11 = r_weapon;
  v12 = ps;
  v13 = 0;
  v14 = 0;
  if ( weapDef->numAnimOverrides )
  {
    do
    {
      animOverrides = weapDef->animOverrides;
      v16 = v14;
      numBindings = animOverrides[v16].numBindings;
      v18 = &animOverrides[v16];
      if ( numBindings > v13 )
      {
        if ( BG_WeaponHasOverride(v11, v18->bindings, numBindings) && (isAlternate && (overridesAlt = weapDef->animOverrides[v16].overridesAlt) != NULL || (overridesAlt = weapDef->animOverrides[v16].overrides) != NULL) && *(unsigned __int16 *)((char *)&overridesAlt->timers->iDetonateDelay + offset) != 0xFFFF && (dependentAnimType == NUM_WEAP_ANIMS || overridesAlt->anims[dependentAnimType]) )
        {
          v13 = v18->numBindings;
          timer = *(unsigned __int16 *)((char *)&overridesAlt->timers->iDetonateDelay + offset);
        }
        v11 = r_weapon;
      }
      ++v14;
    }
    while ( v14 < weapDef->numAnimOverrides );
    v10 = isAlternate;
    v8 = 0i64;
    v12 = ps;
  }
  if ( !v12 || !BG_CarryObject_IsActive(v12) )
    return timer;
  PlayerCarryObjectDef = BG_GetPlayerCarryObjectDef(v12);
  if ( !PlayerCarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1903, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
    __debugbreak();
  for ( i = weapDef->carryAnimOverrides; i->carryObjectType != PlayerCarryObjectDef->type; ++i )
  {
    if ( ++v8 >= 5 )
      return timer;
  }
  animPackage = i->animPackage;
  animPackageAlt = i->animPackageAlt;
  if ( !animPackage && !animPackageAlt )
    return timer;
  if ( !v10 || !animPackageAlt )
  {
    if ( animPackage )
    {
      timers = animPackage->timers;
      if ( *(unsigned __int16 *)((char *)&timers->iDetonateDelay + offset) != 0xFFFF )
        return *(unsigned __int16 *)((char *)&timers->iDetonateDelay + offset);
    }
    return timer;
  }
  v25 = *(unsigned __int16 *)((char *)&animPackageAlt->timers->iDetonateDelay + offset);
  if ( v25 == 0xFFFF )
    return timer;
  return v25;
}

/*
==============
BG_GetReloadAnimFileType
==============
*/
__int64 BG_GetReloadAnimFileType(weapAnimFiles_t animFile)
{
  __int64 result; 

  if ( (unsigned int)(animFile - 381) <= 7 )
    return 3i64;
  if ( (unsigned int)(animFile - 389) <= 7 )
    return 4i64;
  if ( (unsigned int)(animFile - 286) <= 0x11 )
    return 1i64;
  result = 0i64;
  if ( (unsigned int)(animFile - 304) <= 0x11 )
    return 2i64;
  return result;
}

/*
==============
BG_GetReloadTimeScale
==============
*/
float BG_GetReloadTimeScale(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip, bool isUsingFastReloadStateTimer)
{
  bool v17; 
  bool v18; 
  bool v19; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v25; 
  bool v27; 
  WeaponAttachment **v28; 
  __int64 v29; 
  bool v31; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-58h], xmm6
    vmovaps xmmword ptr [r11-68h], xmm7
    vmovaps xmmword ptr [r11-78h], xmm8
  }
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10855, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10856, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm8, xmm7
  }
  v17 = BG_UseFastReload(ps, r_weapon, isAlternate);
  v18 = BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  v19 = v18;
  if ( v17 || v18 )
  {
    if ( BG_GameInterface_HasFastReloadPerkVariant(&ps->perks) )
    {
      __asm { vmovaps xmm1, xmm7; reloadTimeScale }
      *(double *)&_XMM0 = BG_GameInterface_ApplyFastReloadPerkVariantScaling(ps, *(float *)&_XMM1);
LABEL_19:
      __asm { vmovaps xmm8, xmm0 }
      goto LABEL_20;
    }
    if ( isUsingFastReloadStateTimer )
    {
      if ( v17 && v19 )
      {
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_weapReloadMultiplierEmpty, "perk_weapReloadMultiplierEmpty");
        goto LABEL_19;
      }
    }
    else
    {
      if ( v17 )
      {
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_weapReloadMultiplier, "perk_weapReloadMultiplier");
        __asm { vmovaps xmm8, xmm0 }
      }
      if ( v19 )
      {
        Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_weapReloadMultiplierEmpty, "perk_weapReloadMultiplierEmpty");
        __asm { vmulss  xmm8, xmm8, xmm0 }
      }
    }
  }
LABEL_20:
  __asm { vmovaps xmm6, xmm7 }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v25 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovaps xmm0, xmm7 }
  v27 = (_DWORD)WeaponAttachments_Internal == 0;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v28 = attachments;
    v29 = WeaponAttachments_Internal;
    do
    {
      if ( !BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v28, v25) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10903, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm { vaddss  xmm0, xmm6, dword ptr [rsi+2B8h] }
      ++v28;
      __asm
      {
        vsubss  xmm6, xmm0, xmm7
        vmovaps xmm0, xmm6
      }
      v31 = v29-- == 0;
      v27 = v31 || v29 == 0;
    }
    while ( v29 );
  }
  __asm
  {
    vxorps  xmm4, xmm4, xmm4
    vmaxss  xmm3, xmm0, xmm4
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmovaps xmm7, [rsp+1E8h+var_68]
    vmulss  xmm6, xmm8, xmm0
    vcomiss xmm6, xmm4
    vmovaps xmm8, [rsp+1E8h+var_78]
  }
  if ( v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10910, ASSERT_TYPE_ASSERT, "(reloadTimeScale > 0.0f)", (const char *)&queryFormat, "reloadTimeScale > 0.0f") )
    __debugbreak();
  __asm
  {
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+1E8h+var_58]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetReloadType
==============
*/
__int64 BG_GetReloadType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  ReloadType reloadType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  reloadType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reloadType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)reloadType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7841, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    reload = (*i)->reload;
    if ( reload )
    {
      if ( reload->segmentedReload )
        break;
    }
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)reloadType;
  }
  return 1i64;
}

/*
==============
BG_GetReticleType
==============
*/
__int64 BG_GetReticleType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  ReticleType reticleType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  reticleType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->reticleType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)reticleType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16498, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)reticleType;
  }
  return (unsigned int)general->reticleType;
}

/*
==============
BG_GetScopeAttachment
==============
*/
const WeaponAttachment *BG_GetScopeAttachment(const Weapon *r_weapon)
{
  return BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
}

/*
==============
BG_GetScopeDriftDelay
==============
*/
float BG_GetScopeDriftDelay(const Weapon *r_weapon, bool isAlternate)
{
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetScopeDriftSettings(r_weapon, isAlternate) )
    __asm { vmovss  xmm0, dword ptr [rax] }
  else
    __asm { vmovss  xmm0, dword ptr [rsi+6A4h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetScopeDriftLerpInTime
==============
*/
float BG_GetScopeDriftLerpInTime(const Weapon *r_weapon, bool isAlternate)
{
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetScopeDriftSettings(r_weapon, isAlternate) )
    __asm { vmovss  xmm0, dword ptr [rax+4] }
  else
    __asm { vmovss  xmm0, dword ptr [rsi+6A8h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetScopeDriftLerpOutTime
==============
*/
float BG_GetScopeDriftLerpOutTime(const Weapon *r_weapon, bool isAlternate)
{
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetScopeDriftSettings(r_weapon, isAlternate) )
    __asm { vmovss  xmm0, dword ptr [rax+0Ch] }
  else
    __asm { vmovss  xmm0, dword ptr [rsi+6B0h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetScopeDriftSettings
==============
*/
WeaponAttachment *BG_GetScopeDriftSettings(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *v2; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v5; 
  unsigned int v6; 
  WeaponAttachment **v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v5 = 0;
  v6 = WeaponAttachments_Internal;
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    do
    {
      if ( v2 )
        break;
      v2 = *v7;
      if ( *v7 )
      {
        if ( v2->shareAmmoWithAlt )
        {
          if ( isAlternate )
            v2 = (WeaponAttachment *)v2->scopeDriftSettings;
          else
            v2 = (WeaponAttachment *)v2->scopeDriftSettingsMain;
        }
        else
        {
          v2 = (WeaponAttachment *)v2->scopeDriftSettings;
        }
      }
      ++v5;
      ++v7;
    }
    while ( v5 < v6 );
  }
  return v2;
}

/*
==============
BG_GetScopeDriftSteadyFactor
==============
*/
float BG_GetScopeDriftSteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetScopeDriftSettings(r_weapon, isAlternate) )
    __asm { vmovss  xmm0, dword ptr [rax+10h] }
  else
    __asm { vmovss  xmm0, dword ptr [rsi+6B4h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetScopeDriftSteadyTime
==============
*/
float BG_GetScopeDriftSteadyTime(const Weapon *r_weapon, bool isAlternate)
{
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetScopeDriftSettings(r_weapon, isAlternate) )
    __asm { vmovss  xmm0, dword ptr [rax+8] }
  else
    __asm { vmovss  xmm0, dword ptr [rsi+6ACh] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetScopeDriftUnsteadyFactor
==============
*/
float BG_GetScopeDriftUnsteadyFactor(const Weapon *r_weapon, bool isAlternate)
{
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetScopeDriftSettings(r_weapon, isAlternate) )
    __asm { vmovss  xmm0, dword ptr [rax+14h] }
  else
    __asm { vmovss  xmm0, dword ptr [rsi+6B8h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetScopeLensSettings
==============
*/
void BG_GetScopeLensSettings(const BgHandler *handler, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const float adsFrac, const BgHybridScopeFraction *hybridScopeFraction, GfxScopeInfo *settingOut)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *scopeAttachment; 
  const dvar_t *v20; 
  bool v21; 
  const dvar_t *v22; 
  const WeaponCompleteDef *v23; 
  const char *v24; 
  const char *szInternalName; 
  AttSight *sight; 
  AttPost *post; 
  __int64 v54; 
  const dvar_t *v55; 
  const dvar_t *v57; 
  float fmt; 
  void *retaddr; 
  bool playerUsesNVGHalfADS; 

  _RAX = &retaddr;
  _RBX = settingOut;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  if ( !settingOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15821, ASSERT_TYPE_ASSERT, "(settingOut)", (const char *)&queryFormat, "settingOut") )
    __debugbreak();
  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15822, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  settingOut->foundSight = 0;
  *(_WORD *)&settingOut->dofOverride = 0;
  __asm
  {
    vmovss  xmm8, [rsp+0A8h+adsFrac]
    vmovss  xmm7, cs:__real@3f800000
  }
  if ( isAlternate && (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL), (scopeAttachment = WeaponPrimaryAttachment) != NULL) && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE && !WeaponPrimaryAttachment->shareAmmoWithAlt || (scopeAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE)) != NULL )
  {
    v20 = DVARBOOL_cg_drawGun;
    if ( !DVARBOOL_cg_drawGun && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_drawGun") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v20);
    if ( v20->current.enabled )
    {
      v21 = BG_PlayerUsesNVGHalfADS(ps, handler);
      v22 = DVARBOOL_bg_showWeaponAndAttachment;
      playerUsesNVGHalfADS = v21;
      if ( !DVARBOOL_bg_showWeaponAndAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponAndAttachment") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v22);
      if ( v22->current.enabled )
      {
        v23 = BG_WeaponCompleteDef(r_weapon, isAlternate);
        v24 = "null";
        szInternalName = "null";
        if ( v23->szInternalName )
          szInternalName = v23->szInternalName;
        Com_Printf(17, "weaponDef=%s", szInternalName);
        if ( scopeAttachment )
        {
          if ( scopeAttachment->szInternalName )
            v24 = scopeAttachment->szInternalName;
          Com_Printf(17, " attachment=%s", v24);
        }
        Com_Printf(17, "\n");
        Dvar_SetBool_Internal(DVARBOOL_bg_showWeaponAndAttachment, 0);
      }
      _R15 = hybridScopeFraction;
      if ( scopeAttachment )
      {
        sight = scopeAttachment->sight;
        if ( sight )
        {
          __asm { vmovss  dword ptr [rsp+0A8h+fmt], xmm8 }
          settingOut->foundSight = 1;
          BG_CalculateScopeFadeFractions(handler, ps, r_weapon, isAlternate, fmt, playerUsesNVGHalfADS, scopeAttachment, hybridScopeFraction, settingOut);
          settingOut->scopeUseDualFov = sight->useDualFOV;
          settingOut->scopeUseHybridSetup = BG_CanHybridToggle(ps, r_weapon, isAlternate);
          settingOut->scopeLensInnerDisk = sight->scopeLensInnerDisk;
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+68h]
            vmulss  xmm1, xmm0, dword ptr [rsi+2Ch]
            vsubss  xmm0, xmm7, xmm0
            vaddss  xmm1, xmm1, xmm0
            vmovss  dword ptr [rbx+3Ch], xmm1
          }
          settingOut->scopeLensOuterRing = sight->scopeLensOuterRing;
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+68h]
            vmulss  xmm1, xmm0, dword ptr [rsi+34h]
            vsubss  xmm0, xmm7, xmm0
            vaddss  xmm1, xmm1, xmm0
            vmovss  dword ptr [rbx+44h], xmm1
          }
          settingOut->scopeLensRadius = sight->scopeLensRadius;
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+68h]
            vmulss  xmm1, xmm0, dword ptr [rsi+3Ch]
            vsubss  xmm0, xmm7, xmm0
            vaddss  xmm1, xmm1, xmm0
            vmovss  dword ptr [rbx+54h], xmm1
            vmovss  xmm2, dword ptr [rbx+68h]
            vmulss  xmm1, xmm2, dword ptr [rsi+40h]
            vsubss  xmm0, xmm7, xmm2
            vaddss  xmm1, xmm1, xmm0
            vmovss  dword ptr [rbx+58h], xmm1
            vmovss  xmm2, dword ptr [rbx+68h]
            vmulss  xmm1, xmm2, dword ptr [rsi+44h]
            vsubss  xmm0, xmm7, xmm2
            vaddss  xmm1, xmm1, xmm0
            vmovss  dword ptr [rbx+5Ch], xmm1
            vmovss  xmm2, dword ptr [rbx+68h]
            vmulss  xmm1, xmm2, dword ptr [rsi+48h]
            vsubss  xmm0, xmm7, xmm2
            vaddss  xmm1, xmm1, xmm0
            vmovss  dword ptr [rbx+60h], xmm1
          }
          settingOut->scopeLensFadeStart = sight->scopeLensFadeStart;
          settingOut->scopeLensFadeEnd = sight->scopeLensFadeEnd;
          settingOut->scopeEyeRelief_focusDistance = sight->scopeEyeRelief_focusDistance;
          settingOut->scopeEyeRelief_focuseUVScale = sight->scopeEyeRelief_focuseUVScale;
          settingOut->scopeEyeRelief_outOfFocusDistance = sight->scopeEyeRelief_outOfFocusDistance;
          settingOut->scopeEyeRelief_outOfFocuseUVScale = sight->scopeEyeRelief_outOfFocuseUVScale;
          settingOut->scopeEyeRelief_idleMovementScale = sight->scopeEyeRelief_idleMovementScale;
          settingOut->scopeEyeRelief_fullSpeedMovementScale = sight->scopeEyeRelief_fullSpeedMovementScale;
          settingOut->scopeEyeRelief_maxMovement = sight->scopeEyeRelief_maxMovement;
          settingOut->scopeEyeRelief_hipMovementScale = sight->scopeEyeRelief_hipMovementScale;
          settingOut->scopeEyeRelief_hipMaxMovement = sight->scopeEyeRelief_hipMaxMovement;
          settingOut->scopeEyeRelief_idleSway_freq = sight->scopeEyeRelief_idleSway_freq;
          settingOut->scopeEyeRelief_idleSway_movement = sight->scopeEyeRelief_idleSway_movement;
          settingOut->scopeEyeRelief_fullSpeedSway_freq = sight->scopeEyeRelief_fullSpeedSway_freq;
          settingOut->scopeEyeRelief_fullSpeedSway_movement = sight->scopeEyeRelief_fullSpeedSway_movement;
        }
      }
      if ( !playerUsesNVGHalfADS )
      {
        if ( scopeAttachment )
        {
          post = scopeAttachment->post;
          if ( post )
          {
            __asm
            {
              vxorps  xmm0, xmm0, xmm0
              vcomiss xmm0, dword ptr [r15]
            }
            settingOut->dofOverride = 1;
            settingOut->dofViewModelPhysicalFstop = post->dofViewModelPhysicalFstop;
            settingOut->dofViewModelPhysicalFocusDistance = post->dofViewModelPhysicalFocusDistance;
            settingOut->dofViewModelPhysicalFocalTag = post->dofViewModelPhysicalFocalTag;
            settingOut->dofPhysicalFstop = post->dofPhysicalFstop;
            settingOut->dofPhysicalFocusDistance = post->dofPhysicalFocusDistance;
            settingOut->dofSceneIsOverridden = post->dofSceneIsOverridden;
          }
        }
      }
    }
  }
  if ( !settingOut->foundSight )
  {
    settingOut->adsSmoothFade = 0;
    _RSI = settingOut->scopeFadeInfo;
    v54 = 2i64;
    do
    {
      v55 = DCONST_DVARBOOL_bg_scopeFadeIn;
      if ( !DCONST_DVARBOOL_bg_scopeFadeIn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeIn") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v55);
      if ( v55->current.enabled && settingOut->adsSmoothFade )
        __asm { vmovaps xmm0, xmm8 }
      else
        __asm { vmovaps xmm0, xmm7 }
      __asm { vmovss  dword ptr [rsi+4], xmm0 }
      v57 = DCONST_DVARBOOL_bg_scopeFadeOut;
      if ( !DCONST_DVARBOOL_bg_scopeFadeOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_scopeFadeOut") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v57);
      if ( v57->current.enabled && settingOut->adsSmoothFade )
        __asm { vsubss  xmm0, xmm7, xmm8 }
      else
        __asm { vmovaps xmm0, xmm7 }
      __asm { vmovss  dword ptr [rsi], xmm0 }
      ++_RSI;
      --v54;
    }
    while ( v54 );
    *(_WORD *)&settingOut->scopeUseDualFov = 0;
    settingOut->scopeLensInnerDisk = 0.30000001;
    settingOut->scopeLensInnerDiskMag = 1.0;
    settingOut->scopeLensOuterRing = 0.5;
    settingOut->scopeLensOuterRingMag = 1.0;
    settingOut->scopeLensRadius = 1.64;
    settingOut->scopeLensColorRed = 1.0;
    settingOut->scopeLensColorGreen = 1.0;
    settingOut->scopeLensColorBlue = 1.0;
    settingOut->scopeLensBrightness = 1.0;
    settingOut->scopeLensFadeStart = 1.0;
    settingOut->scopeLensFadeEnd = 1.0;
    settingOut->scopeEyeRelief_focusDistance = 2.0;
    settingOut->scopeEyeRelief_focuseUVScale = 0.80000001;
    settingOut->scopeEyeRelief_outOfFocusDistance = 10.0;
    settingOut->scopeEyeRelief_outOfFocuseUVScale = 5.0;
    settingOut->scopeEyeRelief_idleMovementScale = 0.5;
    settingOut->scopeEyeRelief_fullSpeedMovementScale = 1.0;
    settingOut->scopeEyeRelief_maxMovement = 0.30000001;
    settingOut->scopeEyeRelief_idleSway_freq = 0.5;
    settingOut->scopeEyeRelief_idleSway_movement = 0.0099999998;
    settingOut->scopeEyeRelief_fullSpeedSway_freq = 3.0;
    settingOut->scopeEyeRelief_fullSpeedSway_movement = 0.02;
  }
  __asm
  {
    vmovaps xmm8, [rsp+0A8h+var_58]
    vmovaps xmm7, [rsp+0A8h+var_48]
  }
  if ( !settingOut->dofOverride )
  {
    settingOut->dofViewModelPhysicalFstop = 22.0;
    strcpy((char *)&settingOut->dofViewModelPhysicalFocusDistance, "shA");
    settingOut->dofPhysicalFstop = 22.0;
    settingOut->dofPhysicalFocusDistance = 29.301001;
  }
}

/*
==============
BG_GetSfxPackage
==============
*/
WeaponSFXPackage *BG_GetSfxPackage(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  unsigned int AllWeaponAttachmentsCount; 
  WeaponSFXPackage *sfxPackage; 
  unsigned int numBindings; 
  unsigned int i; 
  __int64 v9; 
  SFXOverride *v10; 
  WeaponSFXPackage *overridesAlt; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2244, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
  sfxPackage = v4->sfxPackage;
  if ( AllWeaponAttachmentsCount )
  {
    numBindings = 0;
    for ( i = 0; i < v4->numSfxOverrides; ++i )
    {
      v9 = i;
      v10 = &v4->sfxOverrides[v9];
      if ( v10->numBindings > numBindings && BG_WeaponHasOverride(r_weapon, v10->bindings, v10->numBindings) && (isAlternate && (overridesAlt = v4->sfxOverrides[v9].overridesAlt) != NULL || (overridesAlt = v4->sfxOverrides[v9].overrides) != NULL) )
      {
        numBindings = v10->numBindings;
        sfxPackage = overridesAlt;
      }
    }
  }
  return sfxPackage;
}

/*
==============
BG_GetShelvedDamageForRange
==============
*/

__int64 __fastcall BG_GetShelvedDamageForRange(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, double rangeScale, float range)
{
  __int64 v7; 
  const Weapon *v9; 
  const WeaponDef *v11; 
  __int64 v13; 
  int minDamage; 
  int damage; 
  unsigned int v16; 
  unsigned int WeaponAttachments_Internal; 
  bool v18; 
  WeaponAttachment **v19; 
  AttDamage *v20; 
  unsigned int v21; 
  unsigned int v22; 
  unsigned int v23; 
  const dvar_t *v25; 
  bool v26; 
  bool v27; 
  weapClass_t WeaponClass; 
  __int64 result; 
  __int64 size; 
  __int64 sizea; 
  AttachmentSlot *attachmentSlots; 
  AttachmentSlot *attachmentSlotsa; 
  int mid1Damage; 
  int mid2Damage; 
  int mid3Damage; 
  float rangeArray[6]; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+1E8h+var_58], xmm6 }
  v7 = damageCalcType;
  v9 = r_weapon;
  __asm { vmovaps xmm6, xmm3 }
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9349, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(v9->weaponIdx);
  __asm { vmovaps xmm3, xmm6; rangeScale }
  BG_GetShelvedDamageRanges((const WeaponDamageCalcType)v7, v9, isAlternate, *(float *)&_XMM3, rangeArray, 4);
  if ( (unsigned int)v7 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(size) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", size, attachmentSlots) )
      __debugbreak();
  }
  v13 = v7;
  minDamage = v11->damageInfo.damageData[v7].minDamage;
  mid1Damage = v11->damageInfo.damageData[v7].mid1Damage;
  mid3Damage = v11->damageInfo.damageData[v7].mid3Damage;
  mid2Damage = v11->damageInfo.damageData[v7].mid2Damage;
  if ( minDamage < 0 )
    minDamage = v11->damageInfo.damageData[0].minDamage;
  damage = v11->damageInfo.damageData[v7].damage;
  if ( damage < 0 )
    damage = v11->damageInfo.damageData[0].damage;
  v16 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v9, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v18 = 0;
  if ( WeaponAttachments_Internal )
  {
    v19 = attachments;
    while ( 1 )
    {
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9371, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v20 = (*v19)->damage;
      if ( v20 )
        break;
      ++v16;
      ++v19;
      v18 = v16 < WeaponAttachments_Internal;
      if ( v16 >= WeaponAttachments_Internal )
      {
        v9 = r_weapon;
        goto LABEL_19;
      }
    }
    if ( (unsigned int)v7 >= 3 )
    {
      LODWORD(attachmentSlotsa) = 3;
      LODWORD(sizea) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8698, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", sizea, attachmentSlotsa) )
        __debugbreak();
    }
    minDamage = v20->damageInfo.damageData[v7].minDamage;
    v23 = v20->damageInfo.damageData[v7].mid1Damage;
    v22 = v20->damageInfo.damageData[v7].mid2Damage;
    v21 = v20->damageInfo.damageData[v13].mid3Damage;
    if ( minDamage < 0 )
      minDamage = v20->damageInfo.damageData[0].minDamage;
    damage = v20->damageInfo.damageData[v13].damage;
    v9 = r_weapon;
    v18 = 0;
    if ( damage < 0 )
      damage = v20->damageInfo.damageData[0].damage;
  }
  else
  {
LABEL_19:
    v21 = mid3Damage;
    v22 = mid2Damage;
    v23 = mid1Damage;
  }
  __asm
  {
    vmovss  xmm6, [rsp+1E8h+range]
    vcomiss xmm6, [rsp+1E8h+rangeArray]
  }
  if ( v18 )
    goto LABEL_43;
  v25 = DVARBOOL_bg_bulletsUseMaxDamageMinRange;
  if ( !DVARBOOL_bg_bulletsUseMaxDamageMinRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletsUseMaxDamageMinRange") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v25);
  v26 = 0;
  v27 = !v25->current.enabled;
  if ( v25->current.enabled && (WeaponClass = BG_GetWeaponClass(v9, isAlternate), v26 = (unsigned int)WeaponClass < WEAPCLASS_SPREAD, v27 = (unsigned int)WeaponClass <= WEAPCLASS_SPREAD, WeaponClass != WEAPCLASS_SPREAD) )
  {
LABEL_43:
    result = (unsigned int)damage;
  }
  else
  {
    __asm
    {
      vmovss  xmm1, [rsp+1E8h+var_18C]
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm1, xmm0
    }
    if ( v27 )
      goto LABEL_36;
    __asm { vcomiss xmm6, xmm1 }
    if ( !v26 )
    {
LABEL_36:
      __asm
      {
        vmovss  xmm1, [rsp+1E8h+var_188]
        vcomiss xmm1, xmm0
      }
      if ( v27 )
        goto LABEL_39;
      __asm { vcomiss xmm6, xmm1 }
      if ( !v26 )
      {
LABEL_39:
        __asm
        {
          vmovss  xmm1, [rsp+1E8h+var_184]
          vcomiss xmm1, xmm0
        }
        if ( v27 )
          goto LABEL_42;
        __asm { vcomiss xmm6, xmm1 }
        if ( !v26 )
LABEL_42:
          result = (unsigned int)minDamage;
        else
          result = v21;
      }
      else
      {
        result = v22;
      }
    }
    else
    {
      result = v23;
    }
  }
  __asm { vmovaps xmm6, [rsp+1E8h+var_58] }
  return result;
}

/*
==============
BG_GetShelvedDamageRanges
==============
*/

__int64 __fastcall BG_GetShelvedDamageRanges(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate, double rangeScale, float *rangeArray, int size)
{
  WeaponDamageCalcType v14; 
  unsigned int v18; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v22; 
  __int64 v23; 
  bool v24; 
  bool v25; 
  bool v38; 
  bool v39; 
  unsigned int v42; 
  WeaponAttachment **v43; 
  bool v45; 
  bool v46; 
  bool v50; 
  bool i; 
  __int64 result; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v63; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _R14 = rangeArray;
  v14 = damageCalcType;
  __asm { vmovaps xmm9, xmm3 }
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9287, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  if ( size != 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9288, ASSERT_TYPE_ASSERT, "(size == 4)", (const char *)&queryFormat, "size == MAX_WEAPON_SHELF_RANGES") )
    __debugbreak();
  __asm { vmovss  xmm8, cs:__real@3f800000 }
  _RBP = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v18 = 0;
  __asm { vmovaps xmm7, xmm8 }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( WeaponAttachments_Internal )
  {
    v22 = attachments;
    v23 = WeaponAttachments_Internal;
    do
    {
      v24 = *v22 == NULL;
      if ( !*v22 )
      {
        v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9301, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v24 = !v25;
        if ( v25 )
          __debugbreak();
      }
      _RAX = *v22;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+268h]
        vucomiss xmm0, xmm6
      }
      if ( !v24 )
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm7
          vsubss  xmm7, xmm0, xmm8
        }
      }
      ++v22;
      --v23;
    }
    while ( v23 );
    v14 = damageCalcType;
  }
  rangeArray[3] = 0.0;
  _RDI = rangeArray + 2;
  rangeArray[2] = 0.0;
  *(_QWORD *)rangeArray = 0i64;
  __asm
  {
    vmaxss  xmm3, xmm7, xmm6
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm8, xmm2
    vmulss  xmm7, xmm9, xmm0
    vshufps xmm7, xmm7, xmm7, 0
  }
  v38 = (unsigned int)v14 < WEAP_DMG_CALC_TYPE_NUM;
  if ( (unsigned int)v14 >= WEAP_DMG_CALC_TYPE_NUM )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v14;
    v39 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots);
    v38 = 0;
    if ( v39 )
      __debugbreak();
  }
  _R12 = v14;
  rangeArray[1] = _RBP->damageInfo.damageData[v14].mid1DamageRange;
  *_RDI = _RBP->damageInfo.damageData[v14].mid2DamageRange;
  rangeArray[3] = _RBP->damageInfo.damageData[v14].mid3DamageRange;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+r12*8+0D4h]
    vcomiss xmm0, xmm6
  }
  if ( v38 )
    __asm { vmovss  xmm0, dword ptr [rbp+0D4h] }
  v42 = 0;
  __asm { vmovss  dword ptr [r14], xmm0 }
  if ( WeaponAttachments_Internal )
  {
    v43 = attachments;
    while ( 1 )
    {
      if ( !*v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9316, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RBP = (*v43)->damage;
      if ( _RBP )
        break;
      ++v42;
      ++v43;
      if ( v42 >= WeaponAttachments_Internal )
        goto LABEL_35;
    }
    v45 = (unsigned int)damageCalcType < WEAP_DMG_CALC_TYPE_NUM;
    if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM )
    {
      LODWORD(attachmentSlots) = 3;
      LODWORD(numAttachmentSlots) = damageCalcType;
      v46 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots);
      v45 = 0;
      if ( v46 )
        __debugbreak();
    }
    rangeArray[1] = _RBP->damageInfo.damageData[_R12].mid1DamageRange;
    *_RDI = _RBP->damageInfo.damageData[_R12].mid2DamageRange;
    rangeArray[3] = _RBP->damageInfo.damageData[_R12].mid3DamageRange;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+r12*8+14h]
      vcomiss xmm0, xmm6
    }
    if ( v45 )
      *rangeArray = _RBP->damageInfo.damageData[0].maxDamageRange;
    else
      __asm { vmovss  dword ptr [r14], xmm0 }
  }
LABEL_35:
  _RCX = 0i64;
  __asm
  {
    vmulps  xmm1, xmm7, xmmword ptr [r14]
    vmovups xmmword ptr [r14], xmm1
  }
  v50 = (unsigned __int64)size < 4;
  if ( size < 4i64 )
  {
LABEL_41:
    for ( i = _RCX < (unsigned __int64)size; _RCX < size; i = ++_RCX < (unsigned __int64)size )
    {
      __asm { vcomiss xmm6, dword ptr [r14+rcx*4] }
      if ( !i )
        break;
      ++v18;
    }
  }
  else
  {
    while ( 1 )
    {
      __asm { vcomiss xmm6, dword ptr [rdi-8] }
      if ( !v50 )
        break;
      __asm { vcomiss xmm6, dword ptr [rdi-4] }
      if ( !v50 )
      {
        result = v18 + 1;
        goto LABEL_45;
      }
      __asm { vcomiss xmm6, dword ptr [rdi] }
      if ( !v50 )
      {
        result = v18 + 2;
        goto LABEL_45;
      }
      __asm { vcomiss xmm6, dword ptr [rdi+4] }
      if ( !v50 )
      {
        result = v18 + 3;
        goto LABEL_45;
      }
      v18 += 4;
      _RCX += 4i64;
      _RDI += 4;
      v50 = _RCX < (unsigned __int64)(size - 3i64);
      if ( _RCX >= size - 3i64 )
        goto LABEL_41;
    }
  }
  result = v18;
LABEL_45:
  _R11 = &v63;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
  return result;
}

/*
==============
BG_GetShootingDirectionScaleForAngleType
==============
*/
float BG_GetShootingDirectionScaleForAngleType(bitarray<64> perks, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const float adsFraction, const WeaponAngleType angleType)
{
  const dvar_t *v12; 
  const char *v13; 
  unsigned int v38; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v40; 
  const WeaponAttachment **p_outAdvancedIdleSettings; 
  double Float_Internal_DebugName; 
  const WeaponDef *v59; 
  unsigned int WeaponAttachments_Internal; 
  SwaySettings outAdvancedIdleSettings; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+1C8h+var_48], xmm6 }
  switch ( angleType )
  {
    case WEAPON_ANGLE_TYPE_BASE:
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleBaseAds, "bg_bulletDirScaleBaseAds");
      v12 = DCONST_DVARFLT_bg_bulletDirScaleBaseHip;
      v13 = "bg_bulletDirScaleBaseHip";
      goto LABEL_3;
    case WEAPON_ANGLE_TYPE_BASE_PIVOT_STAND:
    case WEAPON_ANGLE_TYPE_BASE_PIVOT_CROUCH:
    case WEAPON_ANGLE_TYPE_CLIENT_SPRING:
    case WEAPON_ANGLE_TYPE_CLIENT_MOTION_TORSO:
    case WEAPON_ANGLE_TYPE_CLIENT_MOTION_GUN:
    case WEAPON_ANGLE_TYPE_SKYDIVE:
      goto $LN22_36;
    case WEAPON_ANGLE_TYPE_BOB:
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleBobAds, "bg_bulletDirScaleBobAds");
      v12 = DCONST_DVARFLT_bg_bulletDirScaleBobHip;
      v13 = "bg_bulletDirScaleBobHip";
      goto LABEL_3;
    case WEAPON_ANGLE_TYPE_IDLE:
      if ( !BG_WeaponDefAtIndex(r_weapon->weaponIdx) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20150, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  xmm3, [rsp+1C8h+adsFraction]
        vsubss  xmm1, xmm0, xmm3
        vmulss  xmm2, xmm1, dword ptr [rbx+12F0h]
        vmulss  xmm0, xmm3, dword ptr [rbx+12F4h]
      }
      goto LABEL_28;
    case WEAPON_ANGLE_TYPE_IDLE_ADVANCED_1:
      BG_GetAdvancedIdleSettings(perks, r_weapon, isAlternate, (AdvancedIdleSettings *)&outAdvancedIdleSettings);
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  xmm2, [rsp+1C8h+adsFraction]
        vsubss  xmm0, xmm0, xmm2
        vmulss  xmm3, xmm0, dword ptr [rsp+1C8h+outAdvancedIdleSettings+8]
        vmulss  xmm2, xmm2, dword ptr [rsp+1C8h+outAdvancedIdleSettings+2Ch]
        vaddss  xmm0, xmm3, xmm2
      }
      goto LABEL_29;
    case WEAPON_ANGLE_TYPE_IDLE_ADVANCED_2:
      BG_GetAdvancedIdleSettings(perks, r_weapon, isAlternate, (AdvancedIdleSettings *)&outAdvancedIdleSettings);
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  xmm2, [rsp+1C8h+adsFraction]
        vsubss  xmm0, xmm0, xmm2
        vmulss  xmm3, xmm0, dword ptr [rsp+1C8h+outAdvancedIdleSettings+50h]
        vmulss  xmm2, xmm2, dword ptr [rsp+1C8h+outAdvancedIdleSettings+74h]
        vaddss  xmm0, xmm3, xmm2
      }
      goto LABEL_29;
    case WEAPON_ANGLE_TYPE_SWAY:
      BG_GetSwaySettings(weaponMap, ps, r_weapon, isAlternate, &outAdvancedIdleSettings);
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  xmm2, [rsp+1C8h+adsFraction]
        vsubss  xmm0, xmm0, xmm2
        vmulss  xmm3, xmm0, dword ptr [rsp+1C8h+outAdvancedIdleSettings+18h]
        vmulss  xmm2, xmm2, dword ptr [rsp+1C8h+outAdvancedIdleSettings+38h]
        vaddss  xmm0, xmm3, xmm2
      }
      goto LABEL_29;
    case WEAPON_ANGLE_TYPE_RECOIL:
      if ( !BG_WeaponDefAtIndex(r_weapon->weaponIdx) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20180, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
      v38 = 0;
      WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)&outAdvancedIdleSettings, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      v40 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
      if ( !WeaponAttachments_Internal )
        goto LABEL_27;
      p_outAdvancedIdleSettings = (const WeaponAttachment **)&outAdvancedIdleSettings;
      break;
    case WEAPON_ANGLE_TYPE_TILT:
      if ( !BG_WeaponDefAtIndex(r_weapon->weaponIdx) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20202, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  xmm3, [rsp+1C8h+adsFraction]
        vsubss  xmm1, xmm0, xmm3
        vmulss  xmm2, xmm1, dword ptr [rbx+1300h]
        vmulss  xmm0, xmm3, dword ptr [rbx+1304h]
      }
      goto LABEL_28;
    case WEAPON_ANGLE_TYPE_ADSBOB:
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleBobAds, "bg_bulletDirScaleBobAds");
      __asm { vmulss  xmm0, xmm0, [rsp+1C8h+adsFraction] }
      goto LABEL_29;
    case WEAPON_ANGLE_TYPE_MOVEMENTTILT:
      *(double *)&_XMM0 = BG_GetADSGunBobBulletDirScale(weaponMap, ps, r_weapon, isAlternate);
      __asm { vmulss  xmm0, xmm0, [rsp+1C8h+adsFraction] }
      goto LABEL_29;
    case WEAPON_ANGLE_TYPE_DAMAGEKICK:
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleDamageKickAds, "bg_bulletDirScaleDamageKickAds");
      v12 = DCONST_DVARFLT_bg_bulletDirScaleDamageKickHip;
      v13 = "bg_bulletDirScaleDamageKickHip";
LABEL_3:
      __asm { vmovaps xmm6, xmm0 }
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(v12, v13);
      __asm
      {
        vmovss  xmm1, cs:__real@3f800000
        vsubss  xmm1, xmm1, [rsp+1C8h+adsFraction]
        vmulss  xmm2, xmm0, xmm1
        vmulss  xmm0, xmm6, [rsp+1C8h+adsFraction]
      }
      goto LABEL_28;
    case WEAPON_ANGLE_TYPE_MOUNT:
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleMountAds, "bg_bulletDirScaleMountAds");
      __asm { vmovaps xmm6, xmm0 }
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_bulletDirScaleMountHip, "bg_bulletDirScaleMountHip");
      __asm
      {
        vmovss  xmm2, [rsp+1C8h+adsFraction]; max
        vmovaps xmm1, xmm6; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&Float_Internal_DebugName, *(float *)&_XMM1, *(float *)&_XMM2);
      goto LABEL_29;
    default:
      if ( (unsigned int)(angleType - 18) > 0xB )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20266, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled weapon angle type: %d", angleType) )
          __debugbreak();
      }
      else
      {
        v59 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
        if ( !v59 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20249, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
          __debugbreak();
        if ( angleType - 18 < v59->numWeaponOffsetPatterns )
        {
          _RAX = v59->weaponOffsetPatterns;
          _RCX = 9i64 * (int)angleType - 162;
          if ( *((_DWORD *)&_RAX->transformType + 2 * _RCX) == 3 )
          {
            __asm { vmovss  xmm0, dword ptr [rax+rcx*8+30h] }
            goto LABEL_29;
          }
        }
      }
$LN22_36:
      __asm { vxorps  xmm0, xmm0, xmm0; jumptable 00000001410F8322 cases 1,2,14-17 }
      goto LABEL_29;
  }
  while ( 1 )
  {
    if ( !*p_outAdvancedIdleSettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20188, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    if ( BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *p_outAdvancedIdleSettings, v40) )
      break;
    ++v38;
    ++p_outAdvancedIdleSettings;
    if ( v38 >= WeaponAttachments_Internal )
    {
LABEL_27:
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  xmm3, [rsp+1C8h+adsFraction]
        vsubss  xmm1, xmm0, xmm3
        vmulss  xmm2, xmm1, dword ptr [rax+12F8h]
        vmulss  xmm0, xmm3, dword ptr [rax+12FCh]
      }
      goto LABEL_28;
    }
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  xmm3, [rsp+1C8h+adsFraction]
    vsubss  xmm1, xmm0, xmm3
    vmulss  xmm2, xmm1, dword ptr [rax+174h]
    vmulss  xmm0, xmm3, dword ptr [rax+178h]
  }
LABEL_28:
  __asm { vaddss  xmm0, xmm2, xmm0 }
LABEL_29:
  __asm { vmovaps xmm6, [rsp+1C8h+var_48] }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetSideReticle
==============
*/
void BG_GetSideReticle(const Weapon *r_weapon, bool isAlternate, Material **reticleSide, int *reticleSideSize, bool *spin45)
{
  const WeaponDef *v9; 
  int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v13; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !reticleSide && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16575, ASSERT_TYPE_ASSERT, "(reticleSide)", (const char *)&queryFormat, "reticleSide") )
    __debugbreak();
  if ( !reticleSideSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16576, ASSERT_TYPE_ASSERT, "(reticleSideSize)", (const char *)&queryFormat, "reticleSideSize") )
    __debugbreak();
  if ( !spin45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16577, ASSERT_TYPE_ASSERT, "(spin45)", (const char *)&queryFormat, "spin45") )
    __debugbreak();
  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = 0;
  *reticleSide = v9->reticleSide;
  *reticleSideSize = v9->iReticleSideSize;
  *spin45 = v9->reticleSpin45;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16587, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v13 = *i;
      general = (*i)->general;
      if ( general )
        break;
      if ( ++v10 >= WeaponAttachments_Internal )
        return;
    }
    *reticleSide = general->reticleSide;
    *reticleSideSize = v13->general->reticleSideSize;
    *spin45 = v13->general->reticleSpin45;
  }
}

/*
==============
BG_GetSlideSpread
==============
*/
void BG_GetSlideSpread(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMax)
{
  const WeaponDef *v12; 
  unsigned int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v18; 
  __int64 v19; 
  bool v20; 
  bool v21; 
  WeaponAttachment **v25; 
  WeaponAttachment *v26; 
  float *p_slideSpreadMin; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v42; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _R14 = outSlideSpreadMax;
  _R15 = outSlideSpreadMin;
  if ( !outSlideSpreadMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13871, ASSERT_TYPE_ASSERT, "(outSlideSpreadMin)", (const char *)&queryFormat, "outSlideSpreadMin") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13872, ASSERT_TYPE_ASSERT, "(outSlideSpreadMax)", (const char *)&queryFormat, "outSlideSpreadMax") )
    __debugbreak();
  v12 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v13 = 0;
  *_R15 = v12->slideSpreadMin;
  *_R14 = v12->slideSpreadMax;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
    vxorps  xmm8, xmm8, xmm8
  }
  if ( WeaponAttachments_Internal )
  {
    v18 = attachments;
    v19 = WeaponAttachments_Internal;
    do
    {
      v20 = *v18 == NULL;
      if ( !*v18 )
      {
        v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13882, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v20 = !v21;
        if ( v21 )
          __debugbreak();
      }
      _RAX = *v18;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2ECh]
        vucomiss xmm0, xmm8
      }
      if ( !v20 )
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm6
          vsubss  xmm6, xmm0, xmm7
        }
      }
      ++v18;
      --v19;
    }
    while ( v19 );
  }
  if ( WeaponAttachments_Internal )
  {
    v25 = attachments;
    while ( 1 )
    {
      if ( !*v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13891, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v26 = *v25;
      p_slideSpreadMin = &(*v25)->slideSpread->slideSpreadMin;
      if ( p_slideSpreadMin )
        break;
      ++v13;
      ++v25;
      if ( v13 >= WeaponAttachments_Internal )
        goto LABEL_24;
    }
    *_R15 = *p_slideSpreadMin;
    *_R14 = v26->slideSpread->slideSpreadMax;
  }
LABEL_24:
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm1, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm1, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vmulss  xmm1, xmm1, dword ptr [r14]
    vmovss  dword ptr [r14], xmm1
  }
  _R11 = &v42;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
BG_GetSlideSpreadWithDecay
==============
*/
void BG_GetSlideSpreadWithDecay(const Weapon *r_weapon, bool isAlternate, float *outSlideSpreadMin, float *outSlideSpreadMoveMax, float *outSlideSpreadMax, float *outSlideSpreadDecayRate, float *outSlideSpreadTurnAdd)
{
  const WeaponDef *v18; 
  unsigned int v19; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v24; 
  __int64 v25; 
  bool v26; 
  bool v27; 
  WeaponAttachment **v31; 
  WeaponAttachment *v32; 
  float *p_slideSpreadMin; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v54; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  _R13 = outSlideSpreadTurnAdd;
  _R14 = outSlideSpreadMoveMax;
  _R15 = outSlideSpreadMax;
  _R12 = outSlideSpreadDecayRate;
  if ( !outSlideSpreadMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14039, ASSERT_TYPE_ASSERT, "(outSlideSpreadMin)", (const char *)&queryFormat, "outSlideSpreadMin") )
    __debugbreak();
  if ( !outSlideSpreadMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14040, ASSERT_TYPE_ASSERT, "(outSlideSpreadMax)", (const char *)&queryFormat, "outSlideSpreadMax") )
    __debugbreak();
  if ( !outSlideSpreadDecayRate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14041, ASSERT_TYPE_ASSERT, "(outSlideSpreadDecayRate)", (const char *)&queryFormat, "outSlideSpreadDecayRate") )
    __debugbreak();
  if ( !outSlideSpreadTurnAdd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14042, ASSERT_TYPE_ASSERT, "(outSlideSpreadTurnAdd)", (const char *)&queryFormat, "outSlideSpreadTurnAdd") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14043, ASSERT_TYPE_ASSERT, "(outSlideSpreadMoveMax)", (const char *)&queryFormat, "outSlideSpreadMoveMax") )
    __debugbreak();
  v18 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outSlideSpreadMin = v18->slideSpreadMin;
  v19 = 0;
  *outSlideSpreadMax = v18->slideSpreadMax;
  *outSlideSpreadDecayRate = v18->slideSpreadDecayRate;
  *outSlideSpreadTurnAdd = v18->slideSpreadTurnAdd;
  *_R14 = v18->slideSpreadMoveMax;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
    vxorps  xmm8, xmm8, xmm8
  }
  if ( WeaponAttachments_Internal )
  {
    v24 = attachments;
    v25 = WeaponAttachments_Internal;
    do
    {
      v26 = *v24 == NULL;
      if ( !*v24 )
      {
        v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14057, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v26 = !v27;
        if ( v27 )
          __debugbreak();
      }
      _RAX = *v24;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2ECh]
        vucomiss xmm0, xmm8
      }
      if ( !v26 )
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm6
          vsubss  xmm6, xmm0, xmm7
        }
      }
      ++v24;
      --v25;
    }
    while ( v25 );
    _R14 = outSlideSpreadMoveMax;
    _R13 = outSlideSpreadTurnAdd;
  }
  if ( WeaponAttachments_Internal )
  {
    v31 = attachments;
    while ( 1 )
    {
      if ( !*v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14066, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v32 = *v31;
      p_slideSpreadMin = &(*v31)->slideSpread->slideSpreadMin;
      if ( p_slideSpreadMin )
        break;
      ++v19;
      ++v31;
      if ( v19 >= WeaponAttachments_Internal )
        goto LABEL_32;
    }
    _R8 = outSlideSpreadMin;
    *outSlideSpreadMin = *p_slideSpreadMin;
    *outSlideSpreadMax = v32->slideSpread->slideSpreadMax;
    *outSlideSpreadDecayRate = v32->slideSpread->slideSpreadDecayRate;
    *_R13 = v32->slideSpread->slideSpreadTurnAdd;
    *_R14 = v32->slideSpread->slideSpreadMoveMax;
  }
  else
  {
LABEL_32:
    _R8 = outSlideSpreadMin;
  }
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm4, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm4, dword ptr [r8]
    vmovss  dword ptr [r8], xmm0
    vmulss  xmm1, xmm4, dword ptr [r15]
    vmovss  dword ptr [r15], xmm1
    vmulss  xmm0, xmm4, dword ptr [r12]
    vmovss  dword ptr [r12], xmm0
    vmulss  xmm1, xmm4, dword ptr [r13+0]
    vmovss  dword ptr [r13+0], xmm1
    vmulss  xmm0, xmm4, dword ptr [r14]
    vmovss  dword ptr [r14], xmm0
  }
  _R11 = &v54;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
BG_GetSpreadForWeapon
==============
*/
void BG_GetSpreadForWeapon(const playerState_s *ps, const Weapon *r_weapon, float *minSpread, float *maxSpread)
{
  int aimSpreadStateLast; 
  int aimSpreadStateCurrent; 
  const SuitDef *SuitDef; 
  char v50; 
  bool v58; 
  bool v59; 
  bool v67; 
  char v98; 
  float spreadMinOut; 
  float hipSpreadDuckedMin; 
  float v127; 
  float v128; 
  float hipSpreadDuckedMax; 
  float v130; 
  float v131; 
  float hipSpreadInAirMax; 
  float hipSpreadInAirMin; 
  float hipSpreadSprintMax; 
  float hipSpreadSprintMin; 
  float hipSpreadProneMax; 
  float hipSpreadProneMin; 
  float hipSpreadStandMax; 
  float hipSpreadStandMin; 
  float outSlideSpreadMax; 
  float outSlideSpreadMin; 
  float v142; 
  float v143; 
  float v144; 
  float v145; 
  float v146; 
  float v147; 
  float v148; 
  float v149; 
  float v150; 
  float v151; 
  float spreadMaxOut; 

  _R15 = maxSpread;
  _R12 = minSpread;
  _RDI = ps;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4526, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( _RDI->weapCommon.spreadOverrideState == 2 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [rdi+75Ch]
      vxorps  xmm1, xmm1, xmm1
      vmovss  dword ptr [r12], xmm0
      vcvtsi2ss xmm1, xmm1, dword ptr [rdi+75Ch]
    }
    goto LABEL_42;
  }
  aimSpreadStateLast = _RDI->weapCommon.aimSpreadStateLast;
  __asm
  {
    vmovaps [rsp+130h+var_30], xmm6
    vmovaps [rsp+130h+var_40], xmm7
    vmovaps [rsp+130h+var_50], xmm8
  }
  if ( aimSpreadStateLast >= 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4542, ASSERT_TYPE_ASSERT, "(lastState < AIM_SPREAD_STATE_COUNT)", (const char *)&queryFormat, "lastState < AIM_SPREAD_STATE_COUNT") )
    __debugbreak();
  aimSpreadStateCurrent = _RDI->weapCommon.aimSpreadStateCurrent;
  if ( aimSpreadStateCurrent >= 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4545, ASSERT_TYPE_ASSERT, "(currentState < AIM_SPREAD_STATE_COUNT)", (const char *)&queryFormat, "currentState < AIM_SPREAD_STATE_COUNT") )
    __debugbreak();
  hipSpreadDuckedMin = *(float *)&_RDI->weapCommon.aimSpreadStateChangeTime;
  BG_GetSpreadMinMaxForState(_RDI, r_weapon, (const AimSpreadState)aimSpreadStateLast, &spreadMinOut, &spreadMaxOut);
  BG_GetSpreadMinMaxForState(_RDI, r_weapon, (const AimSpreadState)aimSpreadStateCurrent, &v127, &v128);
  SuitDef = BG_GetSuitDef(_RDI->suitIndex);
  if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4554, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  __asm { vmovaps [rsp+130h+var_60], xmm9 }
  if ( aimSpreadStateLast != 2 )
  {
    if ( aimSpreadStateLast == 1 )
    {
      if ( aimSpreadStateCurrent == 2 )
        goto LABEL_17;
      if ( aimSpreadStateCurrent == 3 )
      {
        __asm
        {
          vmovss  xmm6, dword ptr [rdi+1E8h]
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, ebx
          vcomiss xmm6, xmm0
        }
        v58 = BG_UsingAlternate(_RDI);
        if ( v50 )
        {
          BG_GetHipSpread(r_weapon, v58, &v149, &v148, &v130, &v131, &v147, &v146, &v145, &v144, &v143, &v142);
          v67 = BG_UsingAlternate(_RDI);
          BG_GetSlideSpread(r_weapon, v67, &v151, &v150);
          __asm
          {
            vmovss  xmm0, dword ptr [rdi+1E8h]
            vmovss  xmm8, [rsp+130h+var_BC]
            vmovss  xmm7, [rsp+130h+var_B8]
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, dword ptr [rsi+204h]
            vsubss  xmm6, xmm0, xmm1
          }
          BG_Suit_GetProneViewHeight(SuitDef);
          __asm
          {
            vmovss  xmm9, cs:__real@3f800000
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
            vdivss  xmm0, xmm6, xmm0; val
            vmovaps xmm2, xmm9; max
            vxorps  xmm1, xmm1, xmm1; min
          }
          *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
          __asm { vmovaps xmm6, xmm0 }
          if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_bg_crouchToProneSpreadEnabled, "bg_crouchToProneSpreadEnabled") )
          {
            __asm { vcomiss xmm6, xmm9 }
            *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpreadRecover, "bg_crouchToProneSpreadRecover");
            __asm { vmovaps xmm6, xmm0 }
            Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_bg_directStandToProneSpreadRecoverDelay, "bg_directStandToProneSpreadRecoverDelay");
            __asm
            {
              vxorps  xmm2, xmm2, xmm2
              vcvtsi2ss xmm2, xmm2, ecx
              vdivss  xmm0, xmm2, xmm6; val
              vmovaps xmm2, xmm9; max
              vxorps  xmm1, xmm1, xmm1; min
            }
            *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
            __asm
            {
              vcomiss xmm0, xmm9
              vmovaps xmm6, xmm0
            }
            if ( v50 )
            {
              *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
              __asm { vmulss  xmm8, xmm0, xmm8 }
              *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
              __asm { vmulss  xmm7, xmm0, xmm7 }
            }
          }
          goto LABEL_41;
        }
        BG_GetHipSpread(r_weapon, v58, &hipSpreadStandMin, &hipSpreadStandMax, &hipSpreadDuckedMin, &hipSpreadDuckedMax, &hipSpreadProneMin, &hipSpreadProneMax, &hipSpreadSprintMin, &hipSpreadSprintMax, &hipSpreadInAirMin, &hipSpreadInAirMax);
        v59 = BG_UsingAlternate(_RDI);
        BG_GetSlideSpread(r_weapon, v59, &outSlideSpreadMin, &outSlideSpreadMax);
        __asm
        {
          vmovss  xmm0, [rsp+130h+hipSpreadDuckedMin]
          vmovss  xmm1, [rsp+130h+var_C0]
          vmovss  [rsp+130h+var_C8], xmm0
          vmovss  xmm0, dword ptr [rdi+1E8h]
          vxorps  xmm2, xmm2, xmm2
          vcvtsi2ss xmm2, xmm2, ecx
          vmovss  [rsp+130h+var_C4], xmm1
          vsubss  xmm1, xmm0, xmm2
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vdivss  xmm0, xmm1, xmm0
        }
        goto LABEL_18;
      }
    }
    else if ( aimSpreadStateLast == 3 && aimSpreadStateCurrent == 2 )
    {
      BG_Suit_GetProneViewHeight(SuitDef);
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+1E8h]
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, eax
        vsubss  xmm6, xmm0, xmm1
      }
      BG_Suit_GetProneViewHeight(SuitDef);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, ecx
        vdivss  xmm0, xmm6, xmm0
      }
      goto LABEL_18;
    }
    goto LABEL_34;
  }
  if ( aimSpreadStateCurrent == 1 )
  {
LABEL_17:
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+1E8h]
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, ecx
      vsubss  xmm2, xmm0, xmm1
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vdivss  xmm0, xmm2, xmm0; val
    }
LABEL_18:
    __asm
    {
      vmovss  xmm2, cs:__real@3f800000; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm6, xmm0 }
LABEL_40:
    __asm
    {
      vmovss  xmm7, [rbp+30h+spreadMaxOut]
      vmovss  xmm8, [rsp+130h+spreadMinOut]
    }
    goto LABEL_41;
  }
  if ( aimSpreadStateCurrent != 3 )
  {
LABEL_34:
    _RBX = DCONST_DVARFLT_aim_spread_lerp_time;
    if ( !DCONST_DVARFLT_aim_spread_lerp_time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "aim_spread_lerp_time") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm3, dword ptr [rbx+28h]
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm3, xmm0
    }
    if ( v50 | v98 )
    {
      __asm { vmovss  xmm6, cs:__real@3f800000 }
    }
    else
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm1, xmm0, cs:__real@3a83126f
        vminss  xmm2, xmm1, xmm3
        vdivss  xmm6, xmm2, xmm3
      }
    }
    goto LABEL_40;
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+1E8h]
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, dword ptr [rsi+204h]
    vsubss  xmm6, xmm0, xmm1
  }
  BG_Suit_GetProneViewHeight(SuitDef);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vdivss  xmm0, xmm6, xmm0; val
    vmovaps xmm2, xmm7; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm6, xmm0 }
  if ( !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_bg_crouchToProneSpreadEnabled, "bg_crouchToProneSpreadEnabled") )
    goto LABEL_40;
  __asm { vcomiss xmm6, xmm7 }
  *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpreadRecover, "bg_crouchToProneSpreadRecover");
  __asm { vmovaps xmm6, xmm0 }
  Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_bg_crouchToProneSpreadRecoverDelay, "bg_crouchToProneSpreadRecoverDelay");
  __asm
  {
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, ecx
    vdivss  xmm0, xmm2, xmm6; val
    vmovaps xmm2, xmm7; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vcomiss xmm0, xmm7
    vmovaps xmm6, xmm0
  }
  if ( !v50 )
    goto LABEL_40;
  Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
  __asm
  {
    vmovss  xmm1, [rsp+130h+spreadMinOut]
    vmulss  xmm8, xmm1, xmm0
  }
  Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bg_crouchToProneSpread, "bg_crouchToProneSpread");
  __asm
  {
    vmovss  xmm1, [rbp+30h+spreadMaxOut]
    vmulss  xmm7, xmm1, xmm0
  }
LABEL_41:
  __asm
  {
    vmovss  xmm0, [rsp+130h+var_C8]
    vmovaps xmm9, [rsp+130h+var_60]
    vsubss  xmm1, xmm0, xmm8
    vmovss  xmm0, [rsp+130h+var_C4]
    vmulss  xmm2, xmm1, xmm6
    vsubss  xmm1, xmm0, xmm7
    vaddss  xmm3, xmm2, xmm8
    vmovaps xmm8, [rsp+130h+var_50]
    vmulss  xmm2, xmm1, xmm6
    vmovaps xmm6, [rsp+130h+var_30]
    vaddss  xmm1, xmm2, xmm7
    vmovaps xmm7, [rsp+130h+var_40]
    vmovss  dword ptr [r12], xmm3
  }
LABEL_42:
  __asm { vmovss  dword ptr [r15], xmm1 }
  if ( _RDI->weapCommon.spreadOverrideState == 1 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [rdi+75Ch]
      vmovss  dword ptr [r15], xmm0
    }
  }
  if ( BG_HasPerk(&_RDI->perks, 0) )
  {
    _RBX = DVARFLT_perk_weapSpreadMultiplier;
    if ( !DVARFLT_perk_weapSpreadMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_weapSpreadMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+28h]
      vmulss  xmm1, xmm0, dword ptr [r12]
      vmovss  dword ptr [r12], xmm1
    }
    _RBX = DVARFLT_perk_weapSpreadMultiplier;
    if ( !DVARFLT_perk_weapSpreadMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_weapSpreadMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+28h]
      vmulss  xmm1, xmm0, dword ptr [r15]
      vmovss  dword ptr [r15], xmm1
    }
  }
  BG_GameInterface_ModifySpreadForWeapon(_RDI, r_weapon, _R12, _R15);
}

/*
==============
BG_GetSpreadMinMaxForState
==============
*/
void BG_GetSpreadMinMaxForState(const playerState_s *ps, const Weapon *r_weapon, const AimSpreadState state, float *spreadMinOut, float *spreadMaxOut)
{
  bool v10; 
  bool v11; 
  float hipSpreadProneMin; 
  float hipSpreadProneMax; 
  float hipSpreadSprintMin; 
  float hipSpreadSprintMax; 
  float outSlideSpreadMin; 
  float outSlideSpreadMax; 
  float hipSpreadInAirMin; 
  float hipSpreadInAirMax; 
  float hipSpreadDuckedMin; 
  float hipSpreadStandMin; 
  float hipSpreadDuckedMax; 

  _RDI = spreadMinOut;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4445, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4446, ASSERT_TYPE_ASSERT, "(spreadMinOut)", (const char *)&queryFormat, "spreadMinOut") )
    __debugbreak();
  _RBX = spreadMaxOut;
  if ( !spreadMaxOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4447, ASSERT_TYPE_ASSERT, "(spreadMaxOut)", (const char *)&queryFormat, "spreadMaxOut") )
    __debugbreak();
  *_RDI = 0.0;
  *_RBX = 0.0;
  v10 = BG_UsingAlternate(ps);
  BG_GetHipSpread(r_weapon, v10, &hipSpreadStandMin, (float *)&spreadMaxOut, &hipSpreadDuckedMin, &hipSpreadDuckedMax, &hipSpreadProneMin, &hipSpreadProneMax, &hipSpreadSprintMin, &hipSpreadSprintMax, &hipSpreadInAirMin, &hipSpreadInAirMax);
  v11 = BG_UsingAlternate(ps);
  BG_GetSlideSpread(r_weapon, v11, &outSlideSpreadMin, &outSlideSpreadMax);
  switch ( state )
  {
    case AIM_SPREAD_STATE_INVALID:
    case AIM_SPREAD_STATE_STAND:
      __asm
      {
        vmovss  xmm0, [rbp+hipSpreadStandMin]; jumptable 00000001410F9FDE cases 0,1
        vmovss  xmm1, dword ptr [rbp+spreadMaxOut]
        vmovss  dword ptr [rdi], xmm0
        vmovss  dword ptr [rbx], xmm1
      }
      break;
    case AIM_SPREAD_STATE_CROUCH:
      __asm
      {
        vmovss  xmm0, [rbp+hipSpreadDuckedMin]; jumptable 00000001410F9FDE case 2
        vmovss  xmm1, [rbp+arg_18]
        vmovss  dword ptr [rdi], xmm0
        vmovss  dword ptr [rbx], xmm1
      }
      break;
    case AIM_SPREAD_STATE_PRONE:
      __asm
      {
        vmovss  xmm0, [rbp+var_20]; jumptable 00000001410F9FDE case 3
        vmovss  xmm1, [rbp+var_1C]
        vmovss  dword ptr [rdi], xmm0
        vmovss  dword ptr [rbx], xmm1
      }
      break;
    case AIM_SPREAD_STATE_SLIDE:
      __asm
      {
        vmovss  xmm0, [rbp+outSlideSpreadMin]; jumptable 00000001410F9FDE case 4
        vmovss  xmm1, [rbp+outSlideSpreadMax]
        vmovss  dword ptr [rdi], xmm0
        vmovss  dword ptr [rbx], xmm1
      }
      break;
    case AIM_SPREAD_STATE_SPRINT:
      __asm
      {
        vmovss  xmm0, [rbp+var_18]; jumptable 00000001410F9FDE case 5
        vmovss  xmm1, [rbp+var_14]
        vmovss  dword ptr [rdi], xmm0
        vmovss  dword ptr [rbx], xmm1
      }
      break;
    case AIM_SPREAD_STATE_IN_AIR:
      __asm
      {
        vmovss  xmm0, [rbp+var_8]; jumptable 00000001410F9FDE case 6
        vmovss  xmm1, [rbp+var_4]
        vmovss  dword ptr [rdi], xmm0
        vmovss  dword ptr [rbx], xmm1
      }
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4517, ASSERT_TYPE_ASSERT, "(0)", (const char *)&queryFormat, "0") )
        __debugbreak();
      break;
  }
}

/*
==============
BG_GetSprintAdditiveAnim
==============
*/
__int64 BG_GetSprintAdditiveAnim(weapAnimFiles_t relativeAnim)
{
  switch ( relativeAnim )
  {
    case WEAP_ANIM_SPRINT_IN:
      return 94i64;
    case WEAP_ANIM_SPRINT_LOOP:
      return 95i64;
    case WEAP_ANIM_SPRINT_OUT:
      return 97i64;
  }
  return (unsigned int)relativeAnim;
}

/*
==============
BG_GetSprintAnim
==============
*/
__int64 BG_GetSprintAnim(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t relativeAnim)
{
  weapAnimFiles_t v9; 
  weapAnimFiles_t suitAnim; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v9 = relativeAnim;
  switch ( relativeAnim )
  {
    case WEAP_ANIM_SPRINT_IN:
      suitAnim = WEAP_ANIM_ADDITIVE_SPRINT_IN;
      break;
    case WEAP_ANIM_SPRINT_LOOP:
      suitAnim = WEAP_ANIM_ADDITIVE_SPRINT_LOOP;
      break;
    case WEAP_ANIM_SPRINT_OUT:
      suitAnim = WEAP_ANIM_ADDITIVE_SPRINT_OUT;
      break;
    default:
      suitAnim = relativeAnim;
      break;
  }
  if ( BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, isDualWielding, relativeAnim, suitAnim) )
    return (unsigned int)suitAnim;
  return (unsigned int)v9;
}

/*
==============
BG_GetSprintOutTimeScale
==============
*/
float BG_GetSprintOutTimeScale(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v18; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v21; 
  WeaponAttachment **v22; 
  __int64 v23; 
  const dvar_t *v25; 
  const dvar_t *v26; 
  double numAttachmentSlots; 
  const WeaponDef *v47; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11403, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11404, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weaponIdx = r_weapon->weaponIdx;
  if ( r_weapon->weaponIdx )
  {
    __asm
    {
      vmovaps [rsp+1E8h+var_48], xmm6
      vmovaps [rsp+1E8h+var_58], xmm7
      vmovaps [rsp+1E8h+var_68], xmm8
      vmovss  xmm8, cs:__real@3f800000
      vmovaps xmm6, xmm8
      vmovaps xmm7, xmm8
      vmovaps [rsp+1E8h+var_78], xmm9
    }
    _RAX = BG_WeaponDefAtIndex(weaponIdx);
    v47 = _RAX;
    v18 = _RAX;
    if ( _RAX )
    {
      __asm { vmovss  xmm7, dword ptr [rax+150h] }
      WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      v21 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
      if ( (_DWORD)WeaponAttachments_Internal )
      {
        v22 = attachments;
        v23 = WeaponAttachments_Internal;
        do
        {
          if ( !BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v22, v21) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11424, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
          __asm { vaddss  xmm0, xmm6, dword ptr [rdi+32Ch] }
          ++v22;
          __asm { vsubss  xmm6, xmm0, xmm8 }
          --v23;
        }
        while ( v23 );
      }
      v18 = v47;
    }
    if ( BG_CanSprintFire(ps) )
    {
      v25 = DCONST_DVARFLT_perk_sprintFireSprintOutTimeMultiplier;
      if ( !DCONST_DVARFLT_perk_sprintFireSprintOutTimeMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_sprintFireSprintOutTimeMultiplier") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v25);
      __asm { vmulss  xmm7, xmm7, dword ptr [rbx+28h] }
    }
    if ( BG_HasPerk(&ps->perks, 0x13u) )
    {
      v26 = DVARFLT_perk_sprintRecoveryMultiplierActual;
      if ( !DVARFLT_perk_sprintRecoveryMultiplierActual && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_sprintRecoveryMultiplierActual") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v26);
      __asm { vmulss  xmm7, xmm7, dword ptr [rbx+28h] }
    }
    __asm
    {
      vxorps  xmm9, xmm9, xmm9
      vmaxss  xmm2, xmm6, xmm9
      vsubss  xmm0, xmm8, xmm2
      vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcvtss2sd xmm1, xmm0, xmm0
      vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
      vblendvps xmm5, xmm2, xmm8, xmm0
      vsubss  xmm0, xmm8, xmm7
      vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcvtss2sd xmm1, xmm0, xmm0
      vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
      vblendvps xmm0, xmm7, xmm8, xmm2
      vmovaps xmm8, [rsp+1E8h+var_68]
      vmovaps xmm7, [rsp+1E8h+var_58]
      vmulss  xmm6, xmm0, xmm5
    }
    if ( v18->weapClass != WEAPCLASS_TURRET )
    {
      __asm { vcomiss xmm6, xmm9 }
      if ( v18->weapClass <= (unsigned int)WEAPCLASS_TURRET )
      {
        __asm
        {
          vcvtss2sd xmm0, xmm6, xmm6
          vmovsd  qword ptr [rsp+1E8h+numAttachmentSlots], xmm0
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11450, ASSERT_TYPE_ASSERT, "( ( 0.0f < sprintOutTimeScale ) )", "( sprintOutTimeScale ) = %g", numAttachmentSlots) )
          __debugbreak();
      }
    }
    __asm
    {
      vmovaps xmm9, [rsp+1E8h+var_78]
      vmovaps xmm0, xmm6
      vmovaps xmm6, [rsp+1E8h+var_48]
    }
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetStandWeaponOffset
==============
*/
void BG_GetStandWeaponOffset(const Weapon *r_weapon, bool isAlternate, vec3_t *outStandOffset, vec3_t *outStandOffsetAngles, vec3_t *outStandOffsetPivot)
{
  __int64 WeaponAttachments_Internal; 
  const WeaponDef *v25; 
  WeaponAttachment **v33; 
  WeaponAttachment *v34; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v50; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  _RSI = outStandOffsetAngles;
  _RDI = outStandOffset;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm7, xmm7, xmm7
    vxorps  xmm8, xmm8, xmm8
    vxorps  xmm9, xmm9, xmm9
    vxorps  xmm10, xmm10, xmm10
    vxorps  xmm11, xmm11, xmm11
  }
  v25 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm2, xmm2, xmm2
  }
  *_RDI = v25->vStandOfs;
  *_RSI = v25->vStandOfsRot;
  *outStandOffsetPivot = v25->vStandOfsRotPivot;
  __asm
  {
    vxorps  xmm3, xmm3, xmm3
    vxorps  xmm4, xmm4, xmm4
    vxorps  xmm5, xmm5, xmm5
  }
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v33 = attachments;
    do
    {
      if ( !*v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22376, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v34 = *v33;
      if ( (*v33)->overrideStandOfs )
      {
        _RDI->v[0] = v34->standOfs.v[0];
        _RDI->v[1] = v34->standOfs.v[1];
        _RDI->v[2] = v34->standOfs.v[2];
        _RSI->v[0] = v34->standOfsRot.v[0];
        _RSI->v[1] = v34->standOfsRot.v[1];
        _RSI->v[2] = v34->standOfsRot.v[2];
        *outStandOffsetPivot = v34->standOfsRotPivot;
      }
      __asm
      {
        vaddss  xmm7, xmm7, dword ptr [rcx+298h]
        vaddss  xmm8, xmm8, dword ptr [rcx+29Ch]
        vaddss  xmm9, xmm9, dword ptr [rcx+2A0h]
        vaddss  xmm10, xmm10, dword ptr [rcx+2A4h]
        vaddss  xmm11, xmm11, dword ptr [rcx+2A8h]
        vaddss  xmm6, xmm6, dword ptr [rcx+294h]
      }
      ++v33;
      __asm
      {
        vmovaps xmm1, xmm7
        vmovaps xmm2, xmm8
        vmovaps xmm3, xmm9
        vmovaps xmm4, xmm10
        vmovaps xmm5, xmm11
      }
      --WeaponAttachments_Internal;
    }
    while ( WeaponAttachments_Internal );
  }
  __asm
  {
    vaddss  xmm1, xmm1, dword ptr [rdi+4]
    vaddss  xmm0, xmm6, dword ptr [rdi]
    vmovss  dword ptr [rdi], xmm0
    vaddss  xmm0, xmm2, dword ptr [rdi+8]
    vmovss  dword ptr [rdi+8], xmm0
    vmovss  dword ptr [rdi+4], xmm1
    vaddss  xmm1, xmm3, dword ptr [rsi]
    vaddss  xmm0, xmm4, dword ptr [rsi+4]
    vmovss  dword ptr [rsi], xmm1
    vaddss  xmm1, xmm5, dword ptr [rsi+8]
    vmovss  dword ptr [rsi+8], xmm1
    vmovss  dword ptr [rsi+4], xmm0
  }
  _R11 = &v50;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-20h]
    vmovaps xmm7, xmmword ptr [r11-30h]
    vmovaps xmm8, xmmword ptr [r11-40h]
    vmovaps xmm9, xmmword ptr [r11-50h]
    vmovaps xmm10, xmmword ptr [r11-60h]
    vmovaps xmm11, xmmword ptr [r11-70h]
  }
}

/*
==============
BG_GetSwayScalar
==============
*/
float BG_GetSwayScalar(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const int gameTime)
{
  bool hybridScope; 
  bool v21; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v23; 
  BgHybridScopeFraction WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *v39; 
  WeaponAttachment **v41; 
  bool v53; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 
  SwaySettings outSwaySettings; 
  __int64 v76; 
  int v77; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v83; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-0A8h], xmm11
    vmovaps xmmword ptr [rax-0B8h], xmm12
    vmovaps xmmword ptr [rax-0C8h], xmm13
  }
  if ( !ps )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19863, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_4;
  }
  if ( !weaponMap || (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) == NULL )
  {
LABEL_4:
    hybridScope = 0;
    goto LABEL_5;
  }
  hybridScope = EquippedWeaponStateConst->hybridScope;
LABEL_5:
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  v21 = 0;
  memset(&outZoomInfo, 0, sizeof(outZoomInfo));
  if ( hybridScope )
  {
    __asm { vmovss  [rsp+380h+hybridScopeFractionInfo.fraction], xmm6 }
    hybridScopeFractionInfo.increasing = 1;
  }
  else
  {
    hybridScopeFractionInfo = 0i64;
  }
  v23 = BG_UsingAlternate(ps);
  BG_GetADSZoomInfo(weaponMap, r_weapon, v23, &hybridScopeFractionInfo, &outZoomInfo);
  if ( BG_GetADSZoomLevel(weaponMap, ps, r_weapon, outZoomInfo.zoomCount) >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19872, ASSERT_TYPE_ASSERT, "(adsZoomLevel < 3)", "%s\n\tYou must introduce new ADS sway scalars to support the new zoom levels added. Supported: 3 Needed %d", "adsZoomLevel < 3", 3) )
    __debugbreak();
  BG_GetSwaySettings(weaponMap, ps, r_weapon, isAlternate, &outSwaySettings);
  *(double *)&_XMM0 = BG_GetWeaponOrOffhandAdsFrac(weaponMap, ps);
  __asm
  {
    vmulss  xmm1, xmm0, [rbp+rdi*4+280h+outSwaySettings.ads.adsSwayScale]
    vsubss  xmm12, xmm6, xmm0
    vaddss  xmm13, xmm1, xmm12
    vmovaps xmm11, xmm0
  }
  *(double *)&_XMM0 = BG_GetADSZoomLevelFraction(weaponMap, ps, r_weapon, isAlternate, gameTime);
  v76 = 0i64;
  v77 = 0;
  __asm
  {
    vmovaps xmm2, xmm0
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, ecx
    vcomiss xmm2, xmm1
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vsubss  xmm3, xmm2, xmm0
    vsubss  xmm0, xmm6, xmm3
  }
  _RAX = 0i64;
  __asm { vmovss  dword ptr [rbp+rax*4+280h+var_1F0], xmm0 }
  _RAX = 1i64;
  __asm { vmovss  dword ptr [rbp+rax*4+280h+var_1F0], xmm3 }
  WeaponAttachments_Internal = (BgHybridScopeFraction)BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vmovaps xmm7, xmm6 }
  if ( ps )
  {
    if ( weaponMap )
    {
      v39 = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
      if ( v39 )
        v21 = v39->hybridScope;
    }
  }
  __asm { vmovaps xmm1, xmm6 }
  if ( LODWORD(WeaponAttachments_Internal.fraction) )
  {
    v41 = attachments;
    __asm
    {
      vmovaps xmmword ptr [rsp+380h+var_78+8], xmm8
      vmovss  xmm8, [rbp+280h+var_1E8]
      vmovaps [rsp+380h+var_88+8], xmm9
      vmovss  xmm9, dword ptr [rbp+280h+var_1F0+4]
      vmovaps [rsp+380h+var_98+8], xmm10
      vmovss  xmm10, dword ptr [rbp+280h+var_1F0]
    }
    hybridScopeFractionInfo = WeaponAttachments_Internal;
    do
    {
      if ( !BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v41, v21) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19898, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm
      {
        vmulss  xmm1, xmm10, dword ptr [rdi+314h]
        vmulss  xmm0, xmm9, dword ptr [rdi+318h]
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm8, dword ptr [rdi+31Ch]
        vaddss  xmm0, xmm2, xmm1
        vmulss  xmm1, xmm12, dword ptr [rdi+310h]
        vmulss  xmm3, xmm0, xmm11
        vaddss  xmm0, xmm3, xmm1
        vaddss  xmm2, xmm0, xmm7
      }
      ++v41;
      v53 = (*(_QWORD *)&hybridScopeFractionInfo)-- == 1i64;
      __asm
      {
        vsubss  xmm7, xmm2, xmm6
        vmovaps xmm1, xmm7
      }
    }
    while ( !v53 );
    __asm
    {
      vmovaps xmm10, [rsp+380h+var_98+8]
      vmovaps xmm9, [rsp+380h+var_88+8]
      vmovaps xmm8, xmmword ptr [rsp+380h+var_78+8]
    }
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm3, xmm1, xmm0
    vsubss  xmm1, xmm6, xmm3
    vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm0, xmm1, xmm1
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm6, xmm2
    vmulss  xmm0, xmm13, xmm0
  }
  _R11 = &v83;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-20h]
    vmovaps xmm7, xmmword ptr [r11-30h]
    vmovaps xmm11, xmmword ptr [r11-70h]
    vmovaps xmm12, xmmword ptr [r11-80h]
    vmovaps xmm13, xmmword ptr [r11-90h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetSwaySettings
==============
*/
void BG_GetSwaySettings(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, SwaySettings *outSwaySettings)
{
  const playerState_s *v10; 
  __int64 v13; 
  unsigned int v22; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v25; 
  WeaponAttachment **v26; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  bool v30; 
  bool v43; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RBX = outSwaySettings;
  v10 = ps;
  if ( !outSwaySettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22234, ASSERT_TYPE_ASSERT, "(outSwaySettings)", (const char *)&queryFormat, "outSwaySettings") )
    __debugbreak();
  _RAX = &BG_WeaponDefAtIndex(r_weapon->weaponIdx)->swaySettings;
  _RCX = outSwaySettings;
  v13 = 2i64;
  do
  {
    _RCX = (SwaySettings *)((char *)_RCX + 128);
    __asm { vmovups xmm0, xmmword ptr [rax] }
    _RAX = (SwaySettings *)((char *)_RAX + 128);
    __asm
    {
      vmovups xmmword ptr [rcx-80h], xmm0
      vmovups xmm1, xmmword ptr [rax-70h]
      vmovups xmmword ptr [rcx-70h], xmm1
      vmovups xmm0, xmmword ptr [rax-60h]
      vmovups xmmword ptr [rcx-60h], xmm0
      vmovups xmm1, xmmword ptr [rax-50h]
      vmovups xmmword ptr [rcx-50h], xmm1
      vmovups xmm0, xmmword ptr [rax-40h]
      vmovups xmmword ptr [rcx-40h], xmm0
      vmovups xmm1, xmmword ptr [rax-30h]
      vmovups xmmword ptr [rcx-30h], xmm1
      vmovups xmm0, xmmword ptr [rax-20h]
      vmovups xmmword ptr [rcx-20h], xmm0
      vmovups xmm1, xmmword ptr [rax-10h]
      vmovups xmmword ptr [rcx-10h], xmm1
    }
    --v13;
  }
  while ( v13 );
  *(_WORD *)&outSwaySettings->overrideHip = 0;
  v22 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v25 = v10 && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, v10, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( WeaponAttachments_Internal )
  {
    v26 = attachments;
    __asm
    {
      vmovaps [rsp+1C8h+var_58], xmm6
      vxorps  xmm6, xmm6, xmm6
    }
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, v10, r_weapon, isAlternate, *v26, v25);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22248, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      _RDX = OverrideAttachmentWhenApplicable->swaySettings;
      if ( _RDX )
      {
        if ( !outSwaySettings->overrideHip )
        {
          v30 = !_RDX->overrideHip;
          if ( _RDX->overrideHip )
          {
            __asm
            {
              vmovups ymm0, ymmword ptr [rdx]
              vmovss  xmm2, dword ptr [rbx+4]
              vmovups ymmword ptr [rbx], ymm0
              vmovups xmm0, xmmword ptr [rdx+50h]
              vmovups xmmword ptr [rbx+50h], xmm0
              vmovups xmm1, xmmword ptr [rdx+60h]
              vmovups xmmword ptr [rbx+60h], xmm1
              vmovups xmm0, xmmword ptr [rdx+70h]
              vmovups xmmword ptr [rbx+70h], xmm0
              vmovups xmm1, xmmword ptr [rdx+80h]
              vmovups xmmword ptr [rbx+80h], xmm1
              vmovups xmm0, xmmword ptr [rdx+90h]
              vmovups xmmword ptr [rbx+90h], xmm0
              vmovups xmm1, xmmword ptr [rdx+0A0h]
              vmovups xmmword ptr [rbx+0A0h], xmm1
              vmovups xmm0, xmmword ptr [rdx+0B0h]
              vmovups xmmword ptr [rbx+0B0h], xmm0
              vmovups xmm1, xmmword ptr [rdx+0C0h]
              vmovups xmmword ptr [rbx+0C0h], xmm1
              vmovups xmm0, xmmword ptr [rdx+0D0h]
              vmovups xmmword ptr [rbx+0D0h], xmm0
              vmovups xmm1, xmmword ptr [rdx+0E0h]
              vmovups xmmword ptr [rbx+0E0h], xmm1
            }
            *(_QWORD *)&outSwaySettings->adv.fireTorsoDeadzoneScale = *(_QWORD *)&_RDX->adv.fireTorsoDeadzoneScale;
            __asm { vcomiss xmm6, dword ptr [rdx+4] }
            if ( !v30 )
              __asm { vmovss  dword ptr [rbx+4], xmm2 }
            outSwaySettings->overrideHip = 1;
          }
        }
        if ( !outSwaySettings->overrideAds )
        {
          v43 = !_RDX->overrideAds;
          if ( _RDX->overrideAds )
          {
            __asm
            {
              vmovups ymm0, ymmword ptr [rdx+20h]
              vmovss  xmm2, dword ptr [rbx+24h]
              vmovss  xmm3, dword ptr [rbx+3Ch]
              vmovups ymmword ptr [rbx+20h], ymm0
              vmovsd  xmm1, qword ptr [rdx+40h]
              vmovsd  qword ptr [rbx+40h], xmm1
            }
            outSwaySettings->ads.adsSwayScale[2] = _RDX->ads.adsSwayScale[2];
            __asm { vcomiss xmm6, dword ptr [rdx+24h] }
            if ( !v43 )
              __asm { vmovss  dword ptr [rbx+24h], xmm2 }
            __asm { vcomiss xmm6, dword ptr [rdx+3Ch] }
            if ( !v43 )
              __asm { vmovss  dword ptr [rbx+3Ch], xmm3 }
            outSwaySettings->overrideAds = 1;
          }
        }
      }
      if ( outSwaySettings->overrideHip && outSwaySettings->overrideAds )
        break;
      v10 = ps;
      ++v22;
      ++v26;
    }
    while ( v22 < WeaponAttachments_Internal );
    __asm { vmovaps xmm6, [rsp+1C8h+var_58] }
  }
}

/*
==============
BG_GetTargetAssistAngleRange
==============
*/

void __fastcall BG_GetTargetAssistAngleRange(const Weapon *r_weapon, bool isAlternate, double fallbackAngle, double fallbackRange, float *outAngle, float *outRange)
{
  unsigned int v15; 
  unsigned int WeaponAttachments_Internal; 
  const WeaponDef *v17; 
  bool v18; 
  WeaponAttachment **v19; 
  WeaponAttachment *v20; 
  AttTargetAssist *targetAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  _RSI = outRange;
  _R14 = outAngle;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm7
    vmovaps xmm6, xmm3
    vmovaps xmm7, xmm2
  }
  if ( !outAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9186, ASSERT_TYPE_ASSERT, "(outAngle)", (const char *)&queryFormat, "outAngle") )
    __debugbreak();
  if ( !outRange && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9187, ASSERT_TYPE_ASSERT, "(outRange)", (const char *)&queryFormat, "outRange") )
    __debugbreak();
  v15 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v17 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  *outAngle = v17->targetAssistAngle;
  *outRange = v17->targetAssistRange;
  v18 = WeaponAttachments_Internal == 0;
  if ( WeaponAttachments_Internal )
  {
    v19 = attachments;
    while ( 1 )
    {
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9198, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v20 = *v19;
      targetAssist = (*v19)->targetAssist;
      v18 = targetAssist == NULL;
      if ( targetAssist )
        break;
      ++v15;
      ++v19;
      v18 = v15 <= WeaponAttachments_Internal;
      if ( v15 >= WeaponAttachments_Internal )
        goto LABEL_16;
    }
    *outAngle = targetAssist->targetAssistAngle;
    *outRange = v20->targetAssist->targetAssistRange;
  }
LABEL_16:
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vcomiss xmm0, dword ptr [r14]
  }
  if ( !v18 )
    __asm { vmovss  dword ptr [r14], xmm7 }
  __asm
  {
    vcomiss xmm0, dword ptr [rsi]
    vmovaps xmm7, [rsp+1A8h+var_48]
  }
  if ( !v18 )
    __asm { vmovss  dword ptr [rsi], xmm6 }
  __asm { vmovaps xmm6, [rsp+1A8h+var_38] }
}

/*
==============
BG_GetTargetAssistBehavior
==============
*/
__int64 BG_GetTargetAssistBehavior(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  targetAssistBehavior_t targetAssistBehavior; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttTargetAssist *targetAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  targetAssistBehavior = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->targetAssistBehavior;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)targetAssistBehavior;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9124, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    targetAssist = (*i)->targetAssist;
    if ( targetAssist )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)targetAssistBehavior;
  }
  return (unsigned int)targetAssist->targetAssistBehavior;
}

/*
==============
BG_GetTargetAssistType
==============
*/
__int64 BG_GetTargetAssistType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  targetAssistType_t targetAssistType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttTargetAssist *targetAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  targetAssistType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->targetAssistType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)targetAssistType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9100, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    targetAssist = (*i)->targetAssist;
    if ( targetAssist )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)targetAssistType;
  }
  return (unsigned int)targetAssist->targetAssistType;
}

/*
==============
BG_GetTopMountYawMax
==============
*/
float BG_GetTopMountYawMax(const Weapon *r_weapon, bool isAlternate)
{
  if ( BG_WeaponDefAtIndex(r_weapon->weaponIdx) )
    __asm { vmovss  xmm0, dword ptr [rax+1314h] }
  else
    __asm { vmovss  xmm0, cs:__real@43340000 }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetTurretFireType
==============
*/
__int64 BG_GetTurretFireType(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9871, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (unsigned int)v4->turretFireType;
}

/*
==============
BG_GetUnderbarrelAttachment
==============
*/
const WeaponAttachment *BG_GetUnderbarrelAttachment(const Weapon *r_weapon)
{
  return BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
}

/*
==============
BG_GetViewAndGunKickScalars
==============
*/
void BG_GetViewAndGunKickScalars(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *outViewKickPitchScale, float *outViewKickYawScale, float *outGunKickPitchScale, float *outGunKickYawScale)
{
  bool v20; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v35; 
  __int64 v36; 
  WeaponAttachment **v37; 
  const dvar_t *v39; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v117; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
    vmovss  xmm8, cs:__real@3f800000
  }
  v20 = isAlternate;
  __asm
  {
    vmovaps xmm6, xmm8
    vmovaps xmm9, xmm8
    vmovaps xmm13, xmm8
    vmovaps xmm10, xmm8
    vmovaps xmm14, xmm8
    vmovaps xmm11, xmm8
    vmovaps xmm15, xmm8
    vmovaps xmm12, xmm8
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v35 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v36 = WeaponAttachments_Internal;
    v37 = attachments;
    do
    {
      _RBX = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, v20, *v37, v35);
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14542, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v39 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
      if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v39);
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+300h]
        vmovss  xmm1, dword ptr [rbx+304h]
        vmovss  xmm2, dword ptr [rbx+2F0h]
        vmovss  xmm3, dword ptr [rbx+2F4h]
      }
      if ( v39->current.enabled )
      {
        __asm
        {
          vmulss  xmm9, xmm9, xmm0
          vmulss  xmm10, xmm10, xmm1
          vmulss  xmm11, xmm11, xmm2
          vmulss  xmm12, xmm12, xmm3
        }
      }
      else
      {
        __asm
        {
          vaddss  xmm0, xmm0, xmm6
          vaddss  xmm1, xmm1, xmm13
          vsubss  xmm6, xmm0, xmm8
          vsubss  xmm13, xmm1, xmm8
          vaddss  xmm0, xmm14, xmm2
          vaddss  xmm1, xmm15, xmm3
          vsubss  xmm14, xmm0, xmm8
          vsubss  xmm15, xmm1, xmm8
        }
      }
      v20 = isAlternate;
      ++v37;
      --v36;
    }
    while ( v36 );
  }
  __asm { vmovsd  xmm7, cs:__real@3eb0c6f7a0b5ed8d }
  _RAX = outViewKickPitchScale;
  __asm
  {
    vxorps  xmm5, xmm5, xmm5
    vmaxss  xmm2, xmm6, xmm5
    vmovss  xmm6, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vsubss  xmm0, xmm8, xmm2
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, xmm7
    vblendvps xmm3, xmm2, xmm8, xmm0
    vsubss  xmm0, xmm8, xmm9
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm9, xmm8, xmm2
    vmulss  xmm0, xmm0, xmm3
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = outViewKickYawScale;
  __asm
  {
    vmaxss  xmm3, xmm13, xmm5
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm4, xmm3, xmm8, xmm2
    vsubss  xmm0, xmm8, xmm10
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm10, xmm8, xmm2
    vmulss  xmm0, xmm0, xmm4
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = outGunKickPitchScale;
  __asm
  {
    vmaxss  xmm3, xmm14, xmm5
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm4, xmm3, xmm8, xmm2
    vsubss  xmm0, xmm8, xmm11
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm11, xmm8, xmm2
    vmulss  xmm0, xmm0, xmm4
    vmovss  dword ptr [rax], xmm0
  }
  _RAX = outGunKickYawScale;
  __asm
  {
    vmaxss  xmm3, xmm15, xmm5
    vsubss  xmm0, xmm8, xmm3
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm7
    vsubss  xmm0, xmm8, xmm12
    vandps  xmm0, xmm0, xmm6
    vcvtss2sd xmm1, xmm0, xmm0
    vblendvps xmm4, xmm3, xmm8, xmm2
    vcmplesd xmm2, xmm1, xmm7
    vblendvps xmm0, xmm12, xmm8, xmm2
    vmulss  xmm0, xmm0, xmm4
    vmovss  dword ptr [rax], xmm0
  }
  _R11 = &v117;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm13, xmmword ptr [r11-88h]
    vmovaps xmm14, xmmword ptr [r11-98h]
    vmovaps xmm15, xmmword ptr [r11-0A8h]
  }
}

/*
==============
BG_GetViewKickMaintainFraction
==============
*/
float BG_GetViewKickMaintainFraction(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  char v14; 
  __int64 WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v17; 
  __int64 v18; 
  WeaponAttachment **v19; 
  const WeaponAttachment *OverrideAttachmentWhenApplicable; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  xmm7, dword ptr [rax+8BCh]
  }
  v14 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v17 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v18 = WeaponAttachments_Internal;
    v19 = attachments;
    do
    {
      OverrideAttachmentWhenApplicable = BG_GetOverrideAttachmentWhenApplicable(weaponMap, ps, r_weapon, isAlternate, *v19, v17);
      if ( !OverrideAttachmentWhenApplicable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20809, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !v14 )
      {
        if ( OverrideAttachmentWhenApplicable->viewKick )
        {
          __asm { vmovss  xmm7, dword ptr [rax+15Ch] }
          v14 = 1;
        }
      }
      __asm { vmulss  xmm6, xmm6, dword ptr [rbx+30Ch] }
      ++v19;
      --v18;
    }
    while ( v18 );
  }
  __asm
  {
    vmulss  xmm0, xmm7, xmm6
    vmovaps xmm6, [rsp+1C8h+var_48]
    vmovaps xmm7, [rsp+1C8h+var_58]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_GetViewKickMaxAngles
==============
*/
void BG_GetViewKickMaxAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, vec2_t *outMaxAngles)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v11; 
  const WeaponAttachment **i; 
  vec2_t *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  *outMaxAngles = *(vec2_t *)&BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fViewMaxPitch;
  if ( WeaponAttachments_Internal )
  {
    for ( i = (const WeaponAttachment **)attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20859, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = (vec2_t *)BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v11);
      if ( AttachmentViewKick )
        break;
      if ( ++v8 >= WeaponAttachments_Internal )
        return;
    }
    *outMaxAngles = AttachmentViewKick[44];
  }
}

/*
==============
BG_GetViewKickSpeed
==============
*/
void BG_GetViewKickSpeed(const BgWeaponMap *weaponMap, const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickAccel, float *hipViewKickReturnAccelScale, float *hipViewKickReturnSpeedCurveScale, float *adsViewKickAccel, float *adsViewKickReturnAccelScale, float *adsViewKickReturnSpeedCurveScale)
{
  const Weapon *v18; 
  const WeaponDef *v21; 
  const WeaponCompleteDef *v22; 
  unsigned int v23; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v25; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  WeaponAttachment **v31; 
  __int64 v32; 
  const BgWeaponMap *v33; 
  bool v35; 
  bool v36; 
  const dvar_t *v37; 
  ContextMountType type; 
  const WeaponAttachment **v53; 
  AttViewKick *AttachmentViewKick; 
  bool v86; 
  unsigned int v88; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v93; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  v18 = r_weapon;
  _R13 = ps;
  if ( !hipViewKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15251, ASSERT_TYPE_ASSERT, "(hipViewKickAccel)", (const char *)&queryFormat, "hipViewKickAccel") )
    __debugbreak();
  if ( !adsViewKickAccel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15252, ASSERT_TYPE_ASSERT, "(adsViewKickAccel)", (const char *)&queryFormat, "adsViewKickAccel") )
    __debugbreak();
  if ( !hipViewKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15253, ASSERT_TYPE_ASSERT, "(hipViewKickReturnAccelScale)", (const char *)&queryFormat, "hipViewKickReturnAccelScale") )
    __debugbreak();
  if ( !hipViewKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15254, ASSERT_TYPE_ASSERT, "(hipViewKickReturnSpeedCurveScale)", (const char *)&queryFormat, "hipViewKickReturnSpeedCurveScale") )
    __debugbreak();
  if ( !adsViewKickReturnAccelScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15255, ASSERT_TYPE_ASSERT, "(adsViewKickReturnAccelScale)", (const char *)&queryFormat, "adsViewKickReturnAccelScale") )
    __debugbreak();
  if ( !adsViewKickReturnSpeedCurveScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15256, ASSERT_TYPE_ASSERT, "(adsViewKickReturnSpeedCurveScale)", (const char *)&queryFormat, "adsViewKickReturnSpeedCurveScale") )
    __debugbreak();
  v21 = BG_WeaponDefAtIndex(v18->weaponIdx);
  v22 = BG_WeaponCompleteDef(v18, isAlternate);
  *hipViewKickAccel = v22->fHipViewKickCenterSpeed;
  *adsViewKickAccel = v22->fAdsViewKickCenterSpeed;
  v23 = 0;
  *hipViewKickReturnAccelScale = v21->hipViewKickReturnAccelScale;
  *hipViewKickReturnSpeedCurveScale = v21->hipViewKickReturnSpeedCurveScale;
  *adsViewKickReturnAccelScale = v21->adsViewKickReturnAccelScale;
  *adsViewKickReturnSpeedCurveScale = v21->adsViewKickReturnSpeedCurveScale;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v18, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v25 = WeaponAttachments_Internal;
  v88 = WeaponAttachments_Internal;
  __asm
  {
    vmovss  xmm9, cs:__real@3f800000
    vmovaps xmm10, xmm9
    vmovaps xmm6, xmm9
  }
  v86 = _R13 && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, _R13, v18)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vxorps  xmm11, xmm11, xmm11 }
  if ( (_DWORD)v25 )
  {
    v31 = attachments;
    v32 = v25;
    v33 = weaponMap;
    do
    {
      _RDI = BG_GetOverrideAttachmentWhenApplicable(v33, _R13, v18, isAlternate, *v31, v86);
      v35 = _RDI == NULL;
      if ( !_RDI )
      {
        v36 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15275, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment");
        v35 = !v36;
        if ( v36 )
          __debugbreak();
      }
      __asm { vucomiss xmm11, dword ptr [rdi+308h] }
      if ( !v35 )
      {
        v37 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v37);
        v35 = !v37->current.enabled;
        v18 = r_weapon;
        __asm { vmovss  xmm0, dword ptr [rdi+308h] }
        if ( v35 )
        {
          __asm
          {
            vaddss  xmm0, xmm10, xmm0
            vsubss  xmm10, xmm0, xmm9
          }
        }
        else
        {
          __asm { vmulss  xmm6, xmm6, xmm0 }
        }
      }
      ++v31;
      --v32;
    }
    while ( v32 );
    LODWORD(v25) = v88;
    v23 = 0;
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f000000
    vcomiss xmm0, dword ptr [r13+730h]
    vmovaps xmm7, xmm9
  }
  type = _R13->mountState.surface.type;
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RCX = _RAX;
  if ( !_RAX )
    goto LABEL_39;
  if ( type == MOUNT_TYPE_TOP )
  {
    __asm { vmovss  xmm1, dword ptr [rax+1324h] }
  }
  else
  {
    if ( (unsigned int)(type - 2) > 1 )
    {
LABEL_39:
      __asm { vmovaps xmm1, xmm9 }
      goto LABEL_44;
    }
    __asm { vmovss  xmm1, dword ptr [rcx+135Ch] }
  }
LABEL_44:
  __asm
  {
    vmovss  xmm0, dword ptr [r13+4C0h]
    vmulss  xmm1, xmm0, xmm1
    vsubss  xmm0, xmm9, xmm0
    vaddss  xmm1, xmm1, xmm0
    vmulss  xmm8, xmm6, xmm1
  }
  if ( (_DWORD)v25 )
  {
    v53 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v53 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15332, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, _R13, r_weapon, isAlternate, *v53, v86);
      if ( AttachmentViewKick )
        break;
      ++v23;
      ++v53;
      if ( v23 >= (unsigned int)v25 )
        goto LABEL_51;
    }
    *hipViewKickAccel = AttachmentViewKick->hipViewKickCenterSpeed;
    _RDX = adsViewKickAccel;
    *adsViewKickAccel = AttachmentViewKick->adsViewKickCenterSpeed;
    *hipViewKickReturnAccelScale = AttachmentViewKick->hipViewKickReturnAccelScale;
    *hipViewKickReturnSpeedCurveScale = AttachmentViewKick->hipViewKickReturnSpeedCurveScale;
    *adsViewKickReturnAccelScale = AttachmentViewKick->adsViewKickReturnAccelScale;
    *adsViewKickReturnSpeedCurveScale = AttachmentViewKick->adsViewKickReturnSpeedCurveScale;
  }
  else
  {
LABEL_51:
    _RDX = adsViewKickAccel;
  }
  __asm
  {
    vmovss  xmm5, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovsd  xmm6, cs:__real@3eb0c6f7a0b5ed8d
  }
  _RAX = hipViewKickAccel;
  __asm
  {
    vmaxss  xmm2, xmm10, xmm11
    vsubss  xmm0, xmm9, xmm2
    vandps  xmm0, xmm0, xmm5
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, xmm6
    vblendvps xmm3, xmm2, xmm9, xmm0
    vsubss  xmm0, xmm9, xmm8
    vandps  xmm0, xmm0, xmm5
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm0, xmm8, xmm9, xmm2
    vmulss  xmm4, xmm0, xmm3
    vsubss  xmm0, xmm9, xmm7
    vandps  xmm0, xmm0, xmm5
    vcvtss2sd xmm1, xmm0, xmm0
    vmulss  xmm0, xmm4, dword ptr [rax]
    vmovss  dword ptr [rax], xmm0
    vcmplesd xmm2, xmm1, xmm6
    vblendvps xmm1, xmm7, xmm9, xmm2
    vmulss  xmm0, xmm1, xmm4
    vmulss  xmm1, xmm0, dword ptr [rdx]
    vmovss  dword ptr [rdx], xmm1
  }
  _R11 = &v93;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
BG_GetViewKickYawAndPitch
==============
*/
void BG_GetViewKickYawAndPitch(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, float *hipViewKickPitchMin, float *hipViewKickPitchMax, float *hipViewKickYawMin, float *hipViewKickYawMax, float *hipViewKickMagMin, float *adsViewKickPitchMin, float *adsViewKickPitchMax, float *adsViewKickYawMin, float *adsViewKickYawMax, float *adsViewKickMagMin)
{
  const Weapon *v21; 
  EffectiveStance EffectiveStance; 
  __int64 v26; 
  unsigned int v30; 
  unsigned int WeaponAttachments_Internal; 
  __int64 v34; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v36; 
  __int64 v37; 
  WeaponAttachment **v38; 
  __int64 v39; 
  WeaponAttachment *v40; 
  const dvar_t *v42; 
  const WeaponAttachment **v59; 
  AttViewKick *AttachmentViewKick; 
  unsigned int v77; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v83; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
  }
  _RBP = ps;
  v21 = r_weapon;
  _R15 = adsViewKickPitchMin;
  if ( !hipViewKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15129, ASSERT_TYPE_ASSERT, "(hipViewKickPitchMin)", (const char *)&queryFormat, "hipViewKickPitchMin") )
    __debugbreak();
  if ( !hipViewKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15130, ASSERT_TYPE_ASSERT, "(hipViewKickPitchMax)", (const char *)&queryFormat, "hipViewKickPitchMax") )
    __debugbreak();
  if ( !hipViewKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15131, ASSERT_TYPE_ASSERT, "(hipViewKickYawMin)", (const char *)&queryFormat, "hipViewKickYawMin") )
    __debugbreak();
  if ( !hipViewKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15132, ASSERT_TYPE_ASSERT, "(hipViewKickYawMax)", (const char *)&queryFormat, "hipViewKickYawMax") )
    __debugbreak();
  if ( !hipViewKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15133, ASSERT_TYPE_ASSERT, "(hipViewKickMagMin)", (const char *)&queryFormat, "hipViewKickMagMin") )
    __debugbreak();
  if ( !adsViewKickPitchMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15134, ASSERT_TYPE_ASSERT, "(adsViewKickPitchMin)", (const char *)&queryFormat, "adsViewKickPitchMin") )
    __debugbreak();
  if ( !adsViewKickPitchMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15135, ASSERT_TYPE_ASSERT, "(adsViewKickPitchMax)", (const char *)&queryFormat, "adsViewKickPitchMax") )
    __debugbreak();
  if ( !adsViewKickYawMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15136, ASSERT_TYPE_ASSERT, "(adsViewKickYawMin)", (const char *)&queryFormat, "adsViewKickYawMin") )
    __debugbreak();
  if ( !adsViewKickYawMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15137, ASSERT_TYPE_ASSERT, "(adsViewKickYawMax)", (const char *)&queryFormat, "adsViewKickYawMax") )
    __debugbreak();
  if ( !adsViewKickMagMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15138, ASSERT_TYPE_ASSERT, "(adsViewKickMagMin)", (const char *)&queryFormat, "adsViewKickMagMin") )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(v21->weaponIdx);
  *hipViewKickPitchMin = _RBX->fHipViewKickPitchMin;
  *hipViewKickPitchMax = _RBX->fHipViewKickPitchMax;
  *hipViewKickYawMin = _RBX->fHipViewKickYawMin;
  *hipViewKickYawMax = _RBX->fHipViewKickYawMax;
  *hipViewKickMagMin = _RBX->fHipViewKickMagMin;
  *adsViewKickPitchMin = _RBX->fAdsViewKickPitchMin;
  *adsViewKickPitchMax = _RBX->fAdsViewKickPitchMax;
  *adsViewKickYawMin = _RBX->fAdsViewKickYawMin;
  *adsViewKickYawMax = _RBX->fAdsViewKickYawMax;
  *adsViewKickMagMin = _RBX->fAdsViewKickMagMin;
  EffectiveStance = PM_GetEffectiveStance(_RBP);
  __asm { vmovss  xmm8, cs:__real@3f800000 }
  v26 = EffectiveStance;
  __asm { vmovaps xmm10, xmm8 }
  if ( EffectiveStance == PM_EFF_STANCE_DUCKED )
  {
    __asm { vmovss  xmm10, dword ptr [rbx+4CCh] }
  }
  else if ( EffectiveStance == PM_EFF_STANCE_PRONE )
  {
    __asm { vmovss  xmm10, dword ptr [rbx+4D4h] }
  }
  v30 = 0;
  __asm
  {
    vmovaps xmm9, xmm8
    vmovaps xmm7, xmm8
  }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v21, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v34 = WeaponAttachments_Internal;
  v77 = WeaponAttachments_Internal;
  v36 = _RBP && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, _RBP, v21)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( (_DWORD)v34 )
  {
    v37 = v34;
    v38 = attachments;
    v39 = v26;
    while ( 1 )
    {
      v40 = *v38;
      if ( !*v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15172, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !v40->adsStanceScales )
        goto LABEL_59;
      if ( v39 == 2 )
        break;
      if ( v39 == 1 )
      {
        v42 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
        if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v42);
        __asm { vmovss  xmm0, dword ptr [rdi+8] }
        goto LABEL_56;
      }
LABEL_59:
      ++v38;
      if ( !--v37 )
      {
        LODWORD(v34) = v77;
        v30 = 0;
        _RBP = ps;
        v21 = r_weapon;
        _R15 = adsViewKickPitchMin;
        goto LABEL_61;
      }
    }
    v42 = DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled;
    if ( !DVARBOOL_killswitch_weapon_kick_scale_multiplicative_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_kick_scale_multiplicative_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v42);
    __asm { vmovss  xmm0, dword ptr [rdi] }
LABEL_56:
    if ( v42->current.enabled )
    {
      __asm { vmulss  xmm7, xmm7, xmm0 }
    }
    else
    {
      __asm
      {
        vaddss  xmm0, xmm0, xmm9
        vsubss  xmm9, xmm0, xmm8
      }
    }
    goto LABEL_59;
  }
LABEL_61:
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm6, dword ptr [rbp+4C0h]
    vmaxss  xmm2, xmm9, xmm6
    vsubss  xmm0, xmm8, xmm2
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm0, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm5, xmm2, xmm8, xmm0
    vsubss  xmm0, xmm8, xmm7
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm7, xmm8, xmm2
    vmulss  xmm1, xmm0, xmm10
    vmulss  xmm7, xmm1, xmm5
  }
  if ( (_DWORD)v34 )
  {
    v59 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v59 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15215, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, _RBP, v21, isAlternate, *v59, v36);
      if ( AttachmentViewKick )
        break;
      ++v30;
      ++v59;
      if ( v30 >= (unsigned int)v34 )
        goto LABEL_68;
    }
    _R8 = adsViewKickYawMin;
    _R9 = adsViewKickYawMax;
    *hipViewKickPitchMin = AttachmentViewKick->hipViewKickPitchMin;
    *hipViewKickPitchMax = AttachmentViewKick->hipViewKickPitchMax;
    *hipViewKickYawMin = AttachmentViewKick->hipViewKickYawMin;
    *hipViewKickYawMax = AttachmentViewKick->hipViewKickYawMax;
    *hipViewKickMagMin = AttachmentViewKick->hipViewKickMagMin;
    _RDX = adsViewKickPitchMax;
    *_R15 = AttachmentViewKick->adsViewKickPitchMin;
    *adsViewKickPitchMax = AttachmentViewKick->adsViewKickPitchMax;
    *adsViewKickYawMin = AttachmentViewKick->adsViewKickYawMin;
    *adsViewKickYawMax = AttachmentViewKick->adsViewKickYawMax;
    _RCX = adsViewKickMagMin;
    *adsViewKickMagMin = AttachmentViewKick->adsViewKickMagMin;
  }
  else
  {
LABEL_68:
    _RCX = adsViewKickMagMin;
    _R9 = adsViewKickYawMax;
    _R8 = adsViewKickYawMin;
    _RDX = adsViewKickPitchMax;
  }
  __asm
  {
    vmulss  xmm0, xmm7, dword ptr [r15]
    vmovss  dword ptr [r15], xmm0
    vmulss  xmm1, xmm7, dword ptr [rdx]
    vmovss  dword ptr [rdx], xmm1
    vmulss  xmm0, xmm7, dword ptr [r8]
    vmovss  dword ptr [r8], xmm0
    vmulss  xmm1, xmm7, dword ptr [r9]
    vmovss  dword ptr [r9], xmm1
    vmulss  xmm0, xmm7, dword ptr [rcx]
    vmovss  dword ptr [rcx], xmm0
  }
  _R11 = &v83;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
BG_GetWeaponAdsGunBobSettings
==============
*/
AttADSGunBobSettings *BG_GetWeaponAdsGunBobSettings(const Weapon *r_weapon, bool isAlternate, bool isUsingHybridScope, bool ignoreSpreadFromScopes)
{
  AttADSGunBobSettings *adsGunBobSettingsMain; 
  unsigned int WeaponAttachments_Internal; 
  int v9; 
  WeaponAttachment **i; 
  WeaponAttachment *v11; 
  AttADSOverlay *adsOverlay; 
  bool v13; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  adsGunBobSettingsMain = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, Menu, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( adsGunBobSettingsMain )
        return adsGunBobSettingsMain;
      v11 = *i;
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12456, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !ignoreSpreadFromScopes || v11->type )
      {
        if ( !v11 )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12374, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
        }
        adsOverlay = v11->adsOverlay;
        if ( adsOverlay && adsOverlay->hybridToggle )
        {
          v13 = !isUsingHybridScope;
          goto LABEL_20;
        }
        if ( v11->shareAmmoWithAlt )
        {
          v13 = !isAlternate;
LABEL_20:
          if ( v13 )
            adsGunBobSettingsMain = v11->adsGunBobSettingsMain;
          else
            adsGunBobSettingsMain = v11->adsGunBobSettings;
          goto LABEL_23;
        }
        adsGunBobSettingsMain = v11->adsGunBobSettings;
      }
LABEL_23:
      if ( ++v9 >= WeaponAttachments_Internal )
        return adsGunBobSettingsMain;
    }
  }
  return 0i64;
}

/*
==============
BG_GetWeaponAdsSettings
==============
*/
AttADSSettings *BG_GetWeaponAdsSettings(const Weapon *r_weapon, bool isAlternate, bool isUsingHybridScope, bool ignoreSpreadFromScopes)
{
  AttADSSettings *adsSettings; 
  unsigned int WeaponAttachments_Internal; 
  int v9; 
  WeaponAttachment **i; 
  WeaponAttachment *v11; 
  WeaponAttachment *v12; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *hybridScopeAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  adsSettings = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, (const UnderbarrelMainModeFieldType)1, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v9 = 0;
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( adsSettings )
        return adsSettings;
      v11 = *i;
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12432, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      if ( !ignoreSpreadFromScopes || v11->type )
      {
        v12 = *i;
        if ( !*i )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12346, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
            __debugbreak();
        }
        adsOverlay = v12->adsOverlay;
        if ( !adsOverlay || !adsOverlay->hybridToggle )
        {
          if ( v12->shareAmmoWithAlt )
          {
            if ( isAlternate )
              adsSettings = v12->adsSettings;
            else
              adsSettings = v12->adsSettingsMain;
            goto LABEL_24;
          }
LABEL_20:
          adsSettings = v12->adsSettings;
          goto LABEL_24;
        }
        if ( !isUsingHybridScope )
          goto LABEL_20;
        hybridScopeAttachment = adsOverlay->hybridScopeAttachment;
        if ( !hybridScopeAttachment )
          goto LABEL_20;
        adsSettings = hybridScopeAttachment->adsSettings;
      }
LABEL_24:
      if ( ++v9 >= WeaponAttachments_Internal )
        return adsSettings;
    }
  }
  return 0i64;
}

/*
==============
BG_GetWeaponAltReloadAnimsEnabled
==============
*/
_BOOL8 BG_GetWeaponAltReloadAnimsEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  bool v3; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  __int64 v7; 
  WeaponAttachment *v8; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    __asm
    {
      vmovaps [rsp+188h+var_28], xmm6
      vxorps  xmm6, xmm6, xmm6
    }
    v7 = WeaponAttachments_Internal;
    do
    {
      v8 = *v5;
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23071, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      _RAX = v8->dlcOverrides;
      if ( _RAX && _RAX->useFloatOverride[1] )
      {
        __asm { vucomiss xmm6, dword ptr [rax+0Ch] }
        v3 = _RAX->useFloatOverride[1];
      }
      ++v5;
      --v7;
    }
    while ( v7 );
    __asm { vmovaps xmm6, [rsp+188h+var_28] }
  }
  return v3;
}

/*
==============
BG_GetWeaponAnglesForShootingDirection
==============
*/
void BG_GetWeaponAnglesForShootingDirection(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, const vec3_t (*anglesCategorized)[30], vec3_t *outAngles)
{
  const vec3_t (*v10)[30]; 
  bool v11; 
  const Weapon *v13; 
  int v15; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v18; 
  WeaponAttachment **v19; 
  const BgWeaponMap *v21; 
  unsigned int numAttachmentSlots; 
  vec3_t weaponMapa; 
  vec3_t r_weapona[2]; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
  }
  v10 = anglesCategorized;
  v11 = isAlternate;
  _R14 = outAngles;
  v13 = r_weapon;
  _R15 = ps;
  *(_QWORD *)r_weapona[0].v = r_weapon;
  *(_QWORD *)weaponMapa.v = weaponMap;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20276, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !anglesCategorized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20277, ASSERT_TYPE_ASSERT, "(anglesCategorized)", (const char *)&queryFormat, "anglesCategorized") )
    __debugbreak();
  v15 = 0;
  *(_QWORD *)outAngles->v = 0i64;
  outAngles->v[2] = 0.0;
  if ( !_R15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20110, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( v13->weaponIdx )
  {
    __asm { vcomiss xmm7, dword ptr [r15+730h] }
    BG_WeaponDefAtIndex(v13->weaponIdx);
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v13, v11, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    v18 = 0;
    if ( WeaponAttachments_Internal )
    {
      v19 = attachments;
      do
      {
        if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7410, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        if ( (*v19)->sight )
          break;
        ++v18;
        ++v19;
      }
      while ( v18 < WeaponAttachments_Internal );
    }
    v11 = isAlternate;
    v13 = *(const Weapon **)r_weapona[0].v;
    if ( !BG_GetOverlay(*(const Weapon **)r_weapona[0].v, isAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20120, ASSERT_TYPE_ASSERT, "(adsOverlay)", (const char *)&queryFormat, "adsOverlay") )
      __debugbreak();
  }
  __asm { vmovaps xmm6, xmm7 }
  v21 = *(const BgWeaponMap **)weaponMapa.v;
  do
  {
    __asm { vmovss  [rsp+1F8h+numAttachmentSlots], xmm6 }
    *(float *)&_XMM0 = BG_GetShootingDirectionScaleForAngleType(_R15->perks, v21, _R15, v13, v11, *(const float *)&numAttachmentSlots, (const WeaponAngleType)v15);
    __asm { vmovaps xmm2, xmm0; fraction }
    *(_QWORD *)&r_weapona[0].y = 0i64;
    __asm { vmovss  dword ptr [rsp+1F8h+r_weapon], xmm7 }
    SlerpAngles(r_weapona, (const vec3_t *)v10, *(const float *)&_XMM2, &weaponMapa);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+1F8h+weaponMap]
      vaddss  xmm1, xmm0, dword ptr [r14]
      vmovss  xmm2, dword ptr [rsp+1F8h+weaponMap+4]
      vaddss  xmm0, xmm2, dword ptr [r14+4]
      vmovss  dword ptr [r14], xmm1
      vmovss  xmm1, [rsp+1F8h+var_1A8]
      vaddss  xmm2, xmm1, dword ptr [r14+8]
    }
    ++v15;
    v10 = (const vec3_t (*)[30])((char *)v10 + 12);
    __asm
    {
      vmovss  dword ptr [r14+8], xmm2
      vmovss  dword ptr [r14+4], xmm0
    }
  }
  while ( v15 < 30 );
  __asm
  {
    vmovaps xmm6, [rsp+1F8h+var_58]
    vmovaps xmm7, [rsp+1F8h+var_68]
  }
}

/*
==============
BG_GetWeaponAttachments
==============
*/
unsigned int BG_GetWeaponAttachments(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  unsigned __int8 attachmentIds[32]; 

  return BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
}

/*
==============
BG_GetWeaponAttachmentsUsingHighStockPriority
==============
*/
unsigned int BG_GetWeaponAttachmentsUsingHighStockPriority(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments)
{
  unsigned __int8 attachmentIds[32]; 

  return BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, attachments, attachmentIds, None, 0xEu, ATTACHMENT_ORDER_STOCK_PRIORITIZED);
}

/*
==============
BG_GetWeaponAttachmentsWithIds
==============
*/
unsigned int BG_GetWeaponAttachmentsWithIds(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds)
{
  return BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
}

/*
==============
BG_GetWeaponAttachments_Internal
==============
*/
__int64 BG_GetWeaponAttachments_Internal(const Weapon *r_weapon, bool isAlternate, const WeaponAttachment **attachments, unsigned __int8 *attachmentIds, const UnderbarrelMainModeFieldType underbarrelMainModeFieldType, const unsigned int numAttachmentSlots, const AttachmentSlot *attachmentSlots)
{
  const Weapon *v8; 
  const WeaponAttachment **v10; 
  __int64 v12; 
  unsigned int v13; 
  bool v15; 
  const WeaponCompleteDef *v16; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v19; 
  const WeaponAttachment *v20; 
  AttADSSettings *adsSettingsMain; 
  char v22; 
  bool v23; 
  bool v24; 
  AttADSGunBobSettings *adsGunBobSettingsMain; 
  char v28; 
  const WeaponAttachment *v31; 
  const AttachmentSlot *v32; 
  int v33; 
  const WeaponAttachment *v34; 
  __int64 v35; 
  int v37; 
  __int64 v39; 
  __int64 v40; 
  const WeaponAttachment *v41; 
  const WeaponAttachment *v42; 
  __int64 v43; 
  __int16 v44; 
  char numAttachmentSlotsa; 

  v8 = r_weapon;
  v10 = attachments;
  if ( !attachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1346, ASSERT_TYPE_ASSERT, "(attachments)", (const char *)&queryFormat, "attachments") )
    __debugbreak();
  if ( !attachmentIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1347, ASSERT_TYPE_ASSERT, "(attachmentIds)", (const char *)&queryFormat, "attachmentIds") )
    __debugbreak();
  v12 = numAttachmentSlots;
  if ( numAttachmentSlots > 0xE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1348, ASSERT_TYPE_ASSERT, "( numAttachmentSlots ) <= ( ATT_SLOT_COUNT )", "%s <= %s\n\t%u, %u", "numAttachmentSlots", "ATT_SLOT_COUNT", numAttachmentSlots, 14) )
    __debugbreak();
  v13 = 0;
  DebugWipe(v10, 0xE8ui64);
  if ( !v8->weaponIdx )
    return 0i64;
  v15 = isAlternate && BG_HasUnderbarrelAmmo(v8);
  v16 = BG_WeaponCompleteDef(v8, 0);
  v41 = NULL;
  v42 = NULL;
  v44 = 0;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(v8, ATT_SLOT_UNDERBARREL);
  _RBX = WeaponPrimaryAttachment;
  if ( !WeaponPrimaryAttachment || (v41 = WeaponPrimaryAttachment, v42 = WeaponPrimaryAttachment, v19 = WeaponPrimaryAttachment, (v20 = BG_GetWeaponPrimaryAttachment(v8, ATT_SLOT_UNDERBARREL)) == NULL) || v20->weapClass == WEAPCLASS_NONE )
  {
    v22 = 0;
    numAttachmentSlotsa = 0;
    goto LABEL_58;
  }
  if ( v15 )
  {
    LOBYTE(v44) = 1;
    HIBYTE(v44) = !_RBX->shareAmmoWithAlt;
    goto LABEL_60;
  }
  if ( underbarrelMainModeFieldType != 1 )
  {
    v24 = (unsigned int)underbarrelMainModeFieldType < 2;
    if ( underbarrelMainModeFieldType == 2 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcomiss xmm0, dword ptr [rbx+2DCh]
      }
    }
    else
    {
      v24 = (unsigned int)underbarrelMainModeFieldType < 3;
      if ( underbarrelMainModeFieldType == 3 )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcomiss xmm0, dword ptr [rbx+2E4h]
        }
      }
      else
      {
        if ( underbarrelMainModeFieldType == Menu )
        {
          adsGunBobSettingsMain = _RBX->adsGunBobSettingsMain;
          v28 = 0;
          v23 = adsGunBobSettingsMain == NULL;
          if ( adsGunBobSettingsMain )
            v28 = 1;
          v22 = v28;
          goto LABEL_33;
        }
        v24 = (unsigned int)underbarrelMainModeFieldType < 5;
        if ( underbarrelMainModeFieldType == 5 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcomiss xmm0, dword ptr [rbx+35Ch]
            vcomiss xmm0, dword ptr [rbx+364h]
          }
        }
        else
        {
          v24 = (unsigned int)underbarrelMainModeFieldType < 6;
          if ( underbarrelMainModeFieldType != 6 )
          {
LABEL_56:
            v22 = 0;
            numAttachmentSlotsa = 0;
            v41 = NULL;
            v42 = NULL;
            goto LABEL_58;
          }
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcomiss xmm0, dword ptr [rbx+36Ch]
          }
        }
      }
    }
    if ( v24 )
    {
      v22 = 0;
      numAttachmentSlotsa = 0;
LABEL_42:
      if ( v15 && (v8->weaponAttachments[9] || v8->weaponAttachments[11] || v8->weaponAttachments[12] | (unsigned __int16)(v8->visualAttachmentHighAddr << 8) || v8->weaponOthers) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1394, ASSERT_TYPE_ASSERT, "(!isAlternate || ( !scopeAttachmentIndex && !modifierAttachmentIndex && !visualAttachmentIndex && !r_weapon.weaponOthers ))", (const char *)&queryFormat, "!isAlternate || ( !scopeAttachmentIndex && !modifierAttachmentIndex && !visualAttachmentIndex && !r_weapon.weaponOthers )") )
        __debugbreak();
      v31 = v41;
      goto LABEL_50;
    }
    goto LABEL_56;
  }
  adsSettingsMain = _RBX->adsSettingsMain;
  v22 = 0;
  v23 = adsSettingsMain == NULL;
  if ( adsSettingsMain )
    v22 = 1;
LABEL_33:
  LOBYTE(v44) = v22;
  numAttachmentSlotsa = v22;
  if ( v23 )
  {
    v41 = NULL;
    v42 = NULL;
  }
LABEL_58:
  if ( !v22 )
    goto LABEL_42;
  v19 = v41;
LABEL_60:
  if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1370, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tInvalid weapon specified when trying to get attachments for '%s' ", "weapAttachment", v16->szInternalName) )
    __debugbreak();
  *v10 = v19;
  *attachmentIds = 10;
  if ( HIBYTE(v44) )
  {
    if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1383, ASSERT_TYPE_ASSERT, "(attachments[attachmentCount])", (const char *)&queryFormat, "attachments[attachmentCount]") )
      __debugbreak();
    return 1i64;
  }
  v22 = v44;
  v13 = 1;
  v31 = v42;
  numAttachmentSlotsa = v44;
  v41 = v42;
LABEL_50:
  if ( (_DWORD)v12 )
  {
    v32 = attachmentSlots;
    v43 = v12;
    while ( 1 )
    {
      v33 = *v32;
      if ( *v32 == ATT_SLOT_UNDERBARREL )
        break;
      if ( v33 < 13 )
        goto LABEL_70;
      if ( v33 != 13 )
      {
        SLODWORD(v39) = *v32;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1440, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid attachment slot %d specified by the attachment ordering\n", v39) )
          __debugbreak();
        goto LABEL_77;
      }
      if ( v16->attachments[13].attachmentCount > 0x10 )
      {
        LODWORD(v40) = 16;
        LODWORD(v39) = v16->attachments[13].attachmentCount;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1421, ASSERT_TYPE_ASSERT, "( attList->attachmentCount ) <= ( 16 )", "attList->attachmentCount not in [0, MAX_ATTACHMENT_OTHERS]\n\t%u not in [0, %u]", v39, v40) )
          __debugbreak();
      }
      _ESI = v8->weaponOthers;
      if ( v8->weaponOthers )
      {
        do
        {
          v37 = _ESI;
          __asm { tzcnt   ebx, esi }
          if ( _EBX >= v16->attachments[13].attachmentCount )
          {
            LODWORD(v40) = v16->attachments[13].attachmentCount;
            LODWORD(v39) = _EBX;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1427, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( attList->attachmentCount )", "otherIndex doesn't index attList->attachmentCount\n\t%i not in [0, %i)", v39, v40) )
              __debugbreak();
          }
          if ( v13 >= 0x1D )
          {
            LODWORD(v40) = 29;
            LODWORD(v39) = v13;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1428, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v39, v40) )
              __debugbreak();
          }
          attachments[v13] = v16->attachments[13].attachments[_EBX];
          if ( _EBX >= 0x10 )
          {
            LODWORD(v40) = 16;
            LODWORD(v39) = _EBX;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v39, v40) )
              __debugbreak();
          }
          attachmentIds[v13++] = truncate_cast<unsigned char,unsigned int>(_EBX + 13);
          _ESI ^= 1 << _EBX;
        }
        while ( 1 << _EBX != v37 );
        v22 = numAttachmentSlotsa;
        v8 = r_weapon;
        v10 = attachments;
        goto LABEL_75;
      }
LABEL_76:
      v12 = v43;
LABEL_77:
      v31 = v41;
LABEL_78:
      ++v32;
      --v12;
      attachmentSlots = v32;
      v43 = v12;
      if ( !v12 )
        return v13;
    }
    if ( !v31 || v22 )
      goto LABEL_78;
LABEL_70:
    v34 = BG_GetWeaponPrimaryAttachment(v8, (const AttachmentSlot)v33);
    if ( v34 )
    {
      if ( v13 >= 0x1D )
      {
        LODWORD(v40) = 29;
        LODWORD(v39) = v13;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1411, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentCount ) < (unsigned)( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount doesn't index MAX_NUM_WEAPON_ATTACHMENTS\n\t%i not in [0, %i)", v39, v40) )
          __debugbreak();
      }
      v35 = v13;
      v10[v13++] = v34;
      attachmentIds[v35] = truncate_cast<unsigned char,enum AttachmentSlot>((AttachmentSlot)v33);
LABEL_75:
      v32 = attachmentSlots;
      goto LABEL_76;
    }
    goto LABEL_76;
  }
  return v13;
}

/*
==============
BG_GetWeaponBurstCount
==============
*/
__int64 BG_GetWeaponBurstCount(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  int burstCount; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  AttAmmoGeneral *ammogeneral; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  burstCount = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->burstCount;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6974, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammogeneral = (*v7)->ammogeneral;
      if ( ammogeneral )
        break;
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
    burstCount = ammogeneral->burstCount;
  }
LABEL_10:
  if ( BG_GetWeaponFireType(r_weapon, isAlternate) != WEAPON_FIRETYPE_BURST && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6984, ASSERT_TYPE_ASSERT, "(fireType == WEAPON_FIRETYPE_BURST)", (const char *)&queryFormat, "fireType == WEAPON_FIRETYPE_BURST") )
    __debugbreak();
  if ( burstCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6985, ASSERT_TYPE_ASSERT, "(burstCount > 0)", (const char *)&queryFormat, "burstCount > 0") )
    __debugbreak();
  if ( burstCount > 31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6986, ASSERT_TYPE_ASSERT, "(burstCount <= ( ( 1 << 5 ) - 1 ))", (const char *)&queryFormat, "burstCount <= PLAYER_WEAPONSHOTCOUNT_MAX") )
    __debugbreak();
  return (unsigned int)burstCount;
}

/*
==============
BG_GetWeaponClass
==============
*/
__int64 BG_GetWeaponClass(const Weapon *r_weapon, bool isAlternate)
{
  bool v3; 
  int v4; 
  weapClass_t weapClass; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  __int64 result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = isAlternate && BG_HasUnderbarrelAmmo(r_weapon);
  v4 = 0;
  weapClass = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapClass;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v3, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)weapClass;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16452, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (unsigned int)(*i)->weapClass;
    if ( (_DWORD)result != 14 )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)weapClass;
  }
  return result;
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/
weapClass_t BG_GetWeaponClassForAnimCondition(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2102, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( BG_IsRemoteTurretActiveFlags(&es->lerp.eFlags) )
    return 8;
  else
    return BG_GetWeaponClass(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponClassForAnimCondition
==============
*/
weapClass_t BG_GetWeaponClassForAnimCondition(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2166, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsRemoteTurretActiveFlags(&ps->eFlags) )
    return 8;
  else
    return BG_GetWeaponClass(r_weapon, isAlternate);
}

/*
==============
BG_GetWeaponDismembermentEnabled
==============
*/
_BOOL8 BG_GetWeaponDismembermentEnabled(const Weapon *r_weapon, const bool isAlternate)
{
  bool v6; 
  bool v7; 
  bool v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  __int64 v12; 
  WeaponAttachment *v13; 
  _BOOL8 result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = _RBX == NULL;
  if ( !_RBX )
  {
    v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23033, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef");
    v6 = !v7;
    if ( v7 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm6, dword ptr [rbx+14B8h]
  }
  v9 = !v6;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    v12 = WeaponAttachments_Internal;
    do
    {
      v13 = *v11;
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23045, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      _RAX = v13->dlcOverrides;
      if ( _RAX && _RAX->useFloatOverride[0] )
      {
        __asm { vucomiss xmm6, dword ptr [rax+8] }
        v9 = _RAX->useFloatOverride[0];
      }
      ++v11;
      --v12;
    }
    while ( v12 );
  }
  result = v9;
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return result;
}

/*
==============
BG_GetWeaponEffect
==============
*/
FxCombinedDef BG_GetWeaponEffect(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  unsigned int numBindings; 
  const WeaponDef *v6; 
  WeaponVFXPackage *vfxPackage; 
  __int64 v9; 
  unsigned int i; 
  __int64 v11; 
  VFXOverride *v12; 
  WeaponVFXPackage *overridesAlt; 

  numBindings = 0;
  if ( (offset < 0 || (unsigned __int64)offset > 0xE0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2401, ASSERT_TYPE_ASSERT, "( 0 ) <= ( offset ) && ( offset ) <= ( sizeof(WeaponVFXPackageDefs) )", "offset not in [0, sizeof(WeaponVFXPackageDefs)]\n\t%i not in [%i, %i]", offset, 0i64, 224) )
    __debugbreak();
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  vfxPackage = v6->vfxPackage;
  if ( !vfxPackage )
    return 0i64;
  v9 = *(__int64 *)((char *)&vfxPackage->vfx->viewFlashEffect.particleSystemDef + offset);
  if ( BG_GetAllWeaponAttachmentsCount(r_weapon) )
  {
    for ( i = 0; i < v6->numVfxOverrides; ++i )
    {
      v11 = i;
      v12 = &v6->vfxOverrides[v11];
      if ( v12->numBindings > numBindings && BG_WeaponHasOverride(r_weapon, v12->bindings, v12->numBindings) && (isAlternate && (overridesAlt = v6->vfxOverrides[v11].overridesAlt) != NULL || (overridesAlt = v6->vfxOverrides[v11].overrides) != NULL) )
      {
        numBindings = v12->numBindings;
        v9 = *(__int64 *)((char *)&overridesAlt->vfx->viewFlashEffect.particleSystemDef + offset);
      }
    }
  }
  return (FxCombinedDef)v9;
}

/*
==============
BG_GetWeaponExplicitHideTags
==============
*/
void BG_GetWeaponExplicitHideTags(const Weapon *r_weapon, const bool isAlternate, const bool isViewModel, const unsigned __int64 hideTagBufferSize, scr_string_t *outHideTagBuffer, unsigned __int64 *outHideTagCount)
{
  unsigned __int64 *v7; 
  unsigned __int64 v10; 
  __int64 v11; 
  unsigned __int64 v12; 
  const WeaponCompleteDef *v13; 
  unsigned __int64 i; 
  int v15; 
  int v16; 
  int v17; 
  int v18; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int64 v20; 
  unsigned __int64 v21; 
  WeaponAttachment *v22; 
  unsigned int numHideTagsNonViewModel; 
  scr_string_t *v24; 
  scr_string_t *p_last; 
  int *v26; 
  scr_string_t v27; 
  int v28; 
  char *v29; 
  __int64 v30; 
  unsigned __int64 v31; 
  scr_string_t *v32; 
  unsigned __int64 v33; 
  scr_string_t *p_first; 
  char *v35; 
  scr_string_t v36; 
  scr_string_t v37; 
  char *v38; 
  __int64 v39; 
  unsigned __int64 v40; 
  scr_string_t *v41; 
  __int64 v42; 
  scr_string_t *p_Src; 
  char *v44; 
  scr_string_t v45; 
  scr_string_t v46; 
  char *v47; 
  __int64 v48; 
  unsigned __int64 v49; 
  scr_string_t *v50; 
  __int64 v51; 
  int v52; 
  scr_string_t *v53; 
  __int64 v55; 
  unsigned __int64 v56; 
  scr_string_t last; 
  int v58[31]; 
  scr_string_t first; 
  char v60[588]; 
  scr_string_t Src; 
  char v62[1164]; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v7 = outHideTagCount;
  if ( !outHideTagBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5811, ASSERT_TYPE_ASSERT, "(outHideTagBuffer)", (const char *)&queryFormat, "outHideTagBuffer") )
    __debugbreak();
  if ( hideTagBufferSize < 0x142 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5812, ASSERT_TYPE_ASSERT, "((((1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) * (5) * 2) + 32) <= hideTagBufferSize)", (const char *)&queryFormat, "MAX_WEAP_ATTACHMENT_HIDE_TAGS <= hideTagBufferSize") )
    __debugbreak();
  v10 = 0i64;
  v55 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  for ( i = 0i64; i < 0x20; i += 4i64 )
  {
    v15 = v13->hideTags[v11];
    if ( !v15 )
      break;
    v58[v11 - 1] = v15;
    v16 = v13->hideTags[v11 + 1];
    if ( !v16 )
    {
      ++v11;
      goto LABEL_17;
    }
    v58[v11] = v16;
    v17 = v13->hideTags[v11 + 2];
    if ( !v17 )
    {
      v11 += 2i64;
      goto LABEL_17;
    }
    v58[v11 + 1] = v17;
    v18 = v13->hideTags[v11 + 3];
    if ( !v18 )
    {
      v11 += 3i64;
LABEL_17:
      v55 = v11;
      break;
    }
    v58[v11 + 2] = v18;
    v11 += 4i64;
    v55 = v11;
  }
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  v20 = 0i64;
  v56 = AllWeaponAttachmentsWithIds;
  v21 = 0i64;
  if ( AllWeaponAttachmentsWithIds )
  {
    do
    {
      v22 = attachments[v20];
      if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5840, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      memcpy_0(&v60[4 * v21 - 4], v22->showTags, 4i64 * v22->numShowTags);
      if ( v22->numShowTags > 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5843, ASSERT_TYPE_ASSERT, "(attachment->numShowTags <= (5))", (const char *)&queryFormat, "attachment->numShowTags <= MAX_ATTACH_SHOWHIDE_TAGS") )
        __debugbreak();
      v21 += v22->numShowTags;
      if ( v21 > 0x91 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5845, ASSERT_TYPE_ASSERT, "(attachShowTagCount <= ( sizeof( *array_counter( attachShowTags ) ) + 0 ))", (const char *)&queryFormat, "attachShowTagCount <= ARRAY_COUNT( attachShowTags )") )
        __debugbreak();
      memcpy_0(&v62[4 * v12 - 4], v22->hideTags, 4i64 * v22->numHideTags);
      if ( v22->numHideTags > 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5848, ASSERT_TYPE_ASSERT, "(attachment->numHideTags <= (5))", (const char *)&queryFormat, "attachment->numHideTags <= MAX_ATTACH_SHOWHIDE_TAGS") )
        __debugbreak();
      v12 += v22->numHideTags;
      if ( v12 > 0x122 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5850, ASSERT_TYPE_ASSERT, "(attachHideTagCount <= ( sizeof( *array_counter( attachHideTags ) ) + 0 ))", (const char *)&queryFormat, "attachHideTagCount <= ARRAY_COUNT( attachHideTags )") )
        __debugbreak();
      if ( !isViewModel )
      {
        numHideTagsNonViewModel = v22->numHideTagsNonViewModel;
        if ( numHideTagsNonViewModel )
        {
          memcpy_0(&v62[4 * v12 - 4], v22->hideTagsNonViewModel, 4i64 * numHideTagsNonViewModel);
          v12 += v22->numHideTagsNonViewModel;
        }
      }
      ++v20;
    }
    while ( v20 < v56 );
    v7 = outHideTagCount;
    v11 = v55;
  }
  v24 = (scr_string_t *)&v58[v11 - 1];
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(&last, v24, (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  if ( &last != v24 )
  {
    p_last = &last;
    v26 = v58;
    if ( v58 != (int *)v24 )
    {
      v27 = last;
      while ( 1 )
      {
        v28 = *v26;
        v29 = (char *)(v26 + 1);
        if ( v27 == *v26 )
          break;
        p_last = (scr_string_t *)v26++;
        v27 = v28;
        if ( v29 == (char *)v24 )
          goto LABEL_52;
      }
      v30 = 0i64;
      v31 = (unsigned __int64)((char *)v24 - v29 + 3) >> 2;
      if ( v29 > (char *)v24 )
        v31 = 0i64;
      if ( v31 )
      {
        do
        {
          if ( *p_last != *(_DWORD *)v29 )
            *++p_last = *(scr_string_t *)v29;
          v29 += 4;
          ++v30;
        }
        while ( v30 != v31 );
      }
      v24 = p_last + 1;
    }
  }
LABEL_52:
  v32 = (scr_string_t *)&v60[4 * v21 - 4];
  v33 = v24 - &last;
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(&first, v32, (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  if ( &first != v32 )
  {
    p_first = &first;
    v35 = v60;
    if ( v60 != (char *)v32 )
    {
      v36 = first;
      while ( 1 )
      {
        v37 = *(_DWORD *)v35;
        v38 = v35 + 4;
        if ( v36 == *(_DWORD *)v35 )
          break;
        p_first = (scr_string_t *)v35;
        v35 += 4;
        v36 = v37;
        if ( v38 == (char *)v32 )
          goto LABEL_65;
      }
      v39 = 0i64;
      v40 = (unsigned __int64)((char *)v32 - v38 + 3) >> 2;
      if ( v38 > (char *)v32 )
        v40 = 0i64;
      if ( v40 )
      {
        do
        {
          if ( *p_first != *(_DWORD *)v38 )
            *++p_first = *(scr_string_t *)v38;
          v38 += 4;
          ++v39;
        }
        while ( v39 != v40 );
      }
      v32 = p_first + 1;
    }
  }
LABEL_65:
  v41 = (scr_string_t *)&v62[4 * v12 - 4];
  v42 = v32 - &first;
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(&Src, v41, (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  if ( &Src != v41 )
  {
    p_Src = &Src;
    v44 = v62;
    if ( v62 != (char *)v41 )
    {
      v45 = Src;
      while ( 1 )
      {
        v46 = *(_DWORD *)v44;
        v47 = v44 + 4;
        if ( v45 == *(_DWORD *)v44 )
          break;
        p_Src = (scr_string_t *)v44;
        v44 += 4;
        v45 = v46;
        if ( v47 == (char *)v41 )
          goto LABEL_78;
      }
      v48 = 0i64;
      v49 = (unsigned __int64)((char *)v41 - v47 + 3) >> 2;
      if ( v47 > (char *)v41 )
        v49 = 0i64;
      if ( v49 )
      {
        do
        {
          if ( *p_Src != *(_DWORD *)v47 )
            *++p_Src = *(scr_string_t *)v47;
          v47 += 4;
          ++v48;
        }
        while ( v48 != v49 );
      }
      v41 = p_Src + 1;
    }
  }
LABEL_78:
  *v7 = 0i64;
  v50 = (scr_string_t *)&v60[4 * v42 - 4];
  v51 = v41 - &Src;
  if ( v33 )
  {
    do
    {
      v52 = v58[v10 - 1];
      v53 = &first;
      if ( &first == v50 )
        goto LABEL_84;
      while ( *v53 != v52 )
      {
        if ( ++v53 == v50 )
          goto LABEL_84;
      }
      if ( v53 == v50 )
LABEL_84:
        outHideTagBuffer[(*v7)++] = v52;
      ++v10;
    }
    while ( v10 < v33 );
    v10 = *v7;
  }
  memcpy_0(&outHideTagBuffer[v10], &Src, 4 * v51);
  *v7 += v51;
  ntl::sort<enum scr_string_t *,ntl::less<enum scr_string_t,enum scr_string_t>>(outHideTagBuffer, &outHideTagBuffer[*v7], (ntl::less<enum scr_string_t,enum scr_string_t>)isViewModel, (ntl::random_access_iterator_tag)isViewModel);
  *v7 = std::unique<enum scr_string_t *,std::equal_to<void>>(outHideTagBuffer, &outHideTagBuffer[*v7], (std::equal_to<void>)isViewModel) - outHideTagBuffer;
}

/*
==============
BG_GetWeaponFieldTime
==============
*/
unsigned __int16 BG_GetWeaponFieldTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, offset, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetWeaponFieldTimeWithDependentAnimation
==============
*/
__int64 BG_GetWeaponFieldTimeWithDependentAnimation(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset, const weapAnimFiles_t dependentAnimType)
{
  int meleeComboSeqIdx; 
  const WeaponDef *v11; 
  const WeaponDef *v12; 
  WeaponAnimPackage *szXAnims; 
  WeaponAnimPackage *szXAnimsLeftHanded; 
  unsigned __int16 v16; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 timer; 
  __int64 v25; 

  meleeComboSeqIdx = 0;
  if ( (offset < 0 || (unsigned __int64)offset > 0x172) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2098, ASSERT_TYPE_ASSERT, "( 0 ) <= ( offset ) && ( offset ) <= ( sizeof(WeaponAnimPackageStateTimers) )", "offset not in [0, sizeof(WeaponAnimPackageStateTimers)]\n\t%i not in [%i, %i]", offset, 0i64, 370) )
    __debugbreak();
  v11 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v12 = v11;
  szXAnims = v11->szXAnims;
  if ( !szXAnims )
    return 0i64;
  if ( isDualWielding )
  {
    szXAnimsLeftHanded = v11->szXAnimsLeftHanded;
    if ( szXAnimsLeftHanded )
      return *(unsigned __int16 *)((char *)&szXAnimsLeftHanded->timers->iDetonateDelay + offset);
  }
  v16 = *(unsigned __int16 *)((char *)&szXAnims->timers->iDetonateDelay + offset);
  IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
  AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
  if ( IsMeleeComboOverride )
  {
    if ( ps )
      meleeComboSeqIdx = ps->weapCommon.meleeComboSeqIdx;
    AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
    v20 = AnimOverrideIdxForMeleeComboSeq;
    if ( AnimOverrideIdxForMeleeComboSeq >= 0 )
    {
      if ( AnimOverrideIdxForMeleeComboSeq >= v12->numAnimOverrides )
      {
        LODWORD(v25) = v12->numAnimOverrides;
        LODWORD(timer) = AnimOverrideIdxForMeleeComboSeq;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1852, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( weapDef->numAnimOverrides )", "animOverrideIdx doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", timer, v25) )
          __debugbreak();
      }
      v21 = (__int64)&v12->animOverrides[v20];
      v22 = *(_QWORD *)(v21 + 16);
      if ( isAlternate && (v23 = *(_QWORD *)(v21 + 24)) != 0 )
      {
        if ( *(_WORD *)(offset + *(_QWORD *)(v23 + 16)) != 0xFFFF && (dependentAnimType == NUM_WEAP_ANIMS || *(_QWORD *)(*(_QWORD *)(v23 + 8) + 8i64 * (int)dependentAnimType)) )
          return *(unsigned __int16 *)(offset + *(_QWORD *)(v23 + 16));
      }
      else if ( v22 && *(_WORD *)(offset + *(_QWORD *)(v22 + 16)) != 0xFFFF && (dependentAnimType == NUM_WEAP_ANIMS || *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8i64 * (int)dependentAnimType)) )
      {
        return *(unsigned __int16 *)(offset + *(_QWORD *)(v22 + 16));
      }
    }
  }
  else if ( AllWeaponAttachmentsCount )
  {
    return BG_GetRegularWeaponFieldTime(ps, r_weapon, isAlternate, v12, offset, v16, dependentAnimType);
  }
  return v16;
}

/*
==============
BG_GetWeaponFireEventBoneIndex
==============
*/
__int64 BG_GetWeaponFireEventBoneIndex(unsigned int param)
{
  unsigned int v1; 

  v1 = (unsigned __int16)param - 1;
  if ( v1 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned int>(unsigned int)", "signed", (unsigned __int16)param - 1i64, "unsigned", v1) )
    __debugbreak();
  return v1;
}

/*
==============
BG_GetWeaponFireType
==============
*/
__int64 BG_GetWeaponFireType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  weapFireType_t fireType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoGeneral *ammogeneral; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  fireType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->fireType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)fireType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6949, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammogeneral = (*i)->ammogeneral;
    if ( ammogeneral )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)fireType;
  }
  return (unsigned int)ammogeneral->fireType;
}

/*
==============
BG_GetWeaponFireWeaponID
==============
*/
Weapon *BG_GetWeaponFireWeaponID(Weapon *result, unsigned int param)
{
  Weapon *v4; 

  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
  }
  v4 = result;
  __asm
  {
    vmovups ymmword ptr [rcx], ymm0
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
    vmovups xmmword ptr [rcx+20h], xmm1
    vmovsd  qword ptr [rcx+30h], xmm0
  }
  *(_DWORD *)&result->weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  result->weaponIdx = truncate_cast<unsigned short,unsigned int>(HIWORD(param));
  return v4;
}

/*
==============
BG_GetWeaponFlashTagname
==============
*/
TagPair *BG_GetWeaponFlashTagname(TagPair *result, const Weapon *r_weapon, bool isAlternate, int chamberIndex)
{
  const dvar_t *v8; 
  scr_string_t tag_flash_2; 

  if ( (unsigned int)chamberIndex > 0x1F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6385, ASSERT_TYPE_ASSERT, "(0 <= chamberIndex && chamberIndex <= (( ( 1 << 5 ) - 1 )))", (const char *)&queryFormat, "0 <= chamberIndex && chamberIndex <= PLAYER_WEAPONCHAMBER_MAX") )
    __debugbreak();
  v8 = DVARBOOL_useTagFlashSilenced;
  if ( !DVARBOOL_useTagFlashSilenced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "useTagFlashSilenced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( !v8->current.enabled || !BG_IsSilenced(r_weapon, isAlternate) )
  {
    if ( chamberIndex )
    {
      if ( isAlternate )
      {
        result->m_primaryTagName = scr_const.tag_flash_alt_2;
        result->m_fallbackTagName = scr_const.tag_flash_2;
        return result;
      }
      tag_flash_2 = scr_const.tag_flash_2;
    }
    else
    {
      if ( isAlternate )
      {
        result->m_primaryTagName = scr_const.tag_flash_alt;
        result->m_fallbackTagName = scr_const.tag_flash;
        return result;
      }
      tag_flash_2 = scr_const.tag_flash;
    }
    goto LABEL_23;
  }
  if ( chamberIndex )
  {
    if ( isAlternate )
    {
      result->m_primaryTagName = scr_const.tag_flash_alt_2;
      result->m_fallbackTagName = scr_const.tag_flash_2_silenced;
      return result;
    }
    tag_flash_2 = scr_const.tag_flash_2_silenced;
LABEL_23:
    result->m_fallbackTagName = 0;
    result->m_primaryTagName = tag_flash_2;
    return result;
  }
  if ( !isAlternate )
  {
    tag_flash_2 = scr_const.tag_flash_silenced;
    goto LABEL_23;
  }
  result->m_primaryTagName = scr_const.tag_flash_alt;
  result->m_fallbackTagName = scr_const.tag_flash_silenced;
  return result;
}

/*
==============
BG_GetWeaponInspectEnabled
==============
*/
char BG_GetWeaponInspectEnabled(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v4 && v4->enableWeaponInspect )
  {
    v5 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( !WeaponAttachments_Internal )
      return 1;
    for ( i = attachments; !(*i)->disableWeaponInspect; ++i )
    {
      if ( ++v5 >= WeaponAttachments_Internal )
        return 1;
    }
  }
  return 0;
}

/*
==============
BG_GetWeaponInspectTime
==============
*/
__int64 BG_GetWeaponInspectTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 360i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_GetWeaponLaserSettings
==============
*/
void BG_GetWeaponLaserSettings(const Weapon *r_weapon, const bool isAlternate, LaserSettings *outLaserSettings)
{
  unsigned int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  __int16 v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RBP = outLaserSettings;
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17948, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (*v7)->laser;
      if ( _RCX )
        break;
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    __asm
    {
      vmovsd  xmm0, qword ptr [rcx+20h]
      vmovsd  qword ptr [rbp+0], xmm0
    }
    v11 = *(_WORD *)&_RCX->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  else
  {
LABEL_8:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm
    {
      vmovsd  xmm0, qword ptr [rax+0F7Eh]
      vmovsd  qword ptr [rbp+0], xmm0
    }
    v11 = *(_WORD *)&_RAX->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  *(_WORD *)&_RBP->remotePlayerNVGHipLaserEnabled = v11;
}

/*
==============
BG_GetWeaponMeleeAnimProperties
==============
*/
WeaponAnimPackage *BG_GetWeaponMeleeAnimProperties(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool isUsingAlternateMelee, bool *outIsRandomized, MeleeAnimType *outAnimType, unsigned __int8 *outAnimSets)
{
  unsigned int v8; 
  const WeaponDef *v12; 
  WeaponAnimPackage *result; 
  WeaponAnimPackage *szXAnimsLeftHanded; 
  bool v15; 
  WeaponAnimPackage *v16; 
  MeleeAnimType v17; 
  WeaponAnimPackage *v18; 
  unsigned __int8 v19; 
  WeaponAnimPackage *v20; 
  int meleeAnimAltCount; 
  bool altMeleeRandomizeAnims; 
  WeaponAnimPackage *szXAnims; 
  MeleeAnimType meleeAnimAltType; 
  WeaponAnimPackage *v25; 
  unsigned __int8 meleeAnimAltSet; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  int meleeComboSeqIdx; 
  int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v31; 
  __int64 v32; 
  __int64 v33; 
  char v34; 
  MeleeAnimType v35; 
  unsigned __int8 v36; 
  unsigned __int64 v37; 
  __int64 v38; 
  AnimOverride *animOverrides; 
  unsigned int numBindings; 
  AnimOverride *v41; 
  WeaponAnimPackage *v42; 
  bool meleeRandomizeAnims; 
  MeleeAnimType meleeAnimPrimaryType; 
  unsigned __int8 meleeAnimPrimarySet; 
  __int64 v46; 
  __int64 v47; 
  __int64 v48; 
  __int64 v49; 

  v8 = 0;
  if ( !outIsRandomized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2140, ASSERT_TYPE_ASSERT, "( outIsRandomized ) != ( nullptr )", "%s != %s\n\t%p, %p", "outIsRandomized", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAnimType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2141, ASSERT_TYPE_ASSERT, "( outAnimType ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAnimType", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !outAnimSets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2142, ASSERT_TYPE_ASSERT, "( outAnimSets ) != ( nullptr )", "%s != %s\n\t%p, %p", "outAnimSets", "nullptr", NULL, NULL) )
    __debugbreak();
  v12 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  result = v12->szXAnims;
  if ( !result )
  {
    *outIsRandomized = 0;
    *outAnimType = COUNT|DODGE;
    *outAnimSets = 0;
    return result;
  }
  if ( !isDualWielding || (szXAnimsLeftHanded = v12->szXAnimsLeftHanded) == NULL )
  {
    if ( isUsingAlternateMelee )
    {
      meleeAnimAltCount = result->meleeAnimAltCount;
      altMeleeRandomizeAnims = result->altMeleeRandomizeAnims;
    }
    else
    {
      meleeAnimAltCount = result->meleeAnimPrimaryCount;
      altMeleeRandomizeAnims = result->meleeRandomizeAnims;
    }
    *outIsRandomized = altMeleeRandomizeAnims;
    szXAnims = v12->szXAnims;
    if ( isUsingAlternateMelee )
      meleeAnimAltType = szXAnims->meleeAnimAltType;
    else
      meleeAnimAltType = szXAnims->meleeAnimPrimaryType;
    *outAnimType = meleeAnimAltType;
    v25 = v12->szXAnims;
    if ( isUsingAlternateMelee )
      meleeAnimAltSet = v25->meleeAnimAltSet;
    else
      meleeAnimAltSet = v25->meleeAnimPrimarySet;
    *outAnimSets = meleeAnimAltSet;
    IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
    AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
    if ( IsMeleeComboOverride )
    {
      meleeComboSeqIdx = 0;
      if ( ps )
        meleeComboSeqIdx = ps->weapCommon.meleeComboSeqIdx;
      AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
      v31 = AnimOverrideIdxForMeleeComboSeq;
      if ( AnimOverrideIdxForMeleeComboSeq >= 0 )
      {
        if ( AnimOverrideIdxForMeleeComboSeq >= v12->numAnimOverrides )
        {
          LODWORD(v47) = v12->numAnimOverrides;
          LODWORD(v46) = AnimOverrideIdxForMeleeComboSeq;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2193, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( weapDef->numAnimOverrides )", "animOverrideIdx doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v46, v47) )
            __debugbreak();
        }
        v32 = (__int64)&v12->animOverrides[v31];
        if ( isAlternate )
          v33 = *(_QWORD *)(v32 + 24);
        else
          v33 = *(_QWORD *)(v32 + 16);
        if ( v33 )
        {
          if ( isUsingAlternateMelee )
          {
            meleeAnimAltCount = *(_DWORD *)(v33 + 40);
            v34 = *(_BYTE *)(v33 + 45);
          }
          else
          {
            meleeAnimAltCount = *(_DWORD *)(v33 + 28);
            v34 = *(_BYTE *)(v33 + 33);
          }
          *outIsRandomized = v34;
          if ( isUsingAlternateMelee )
            v35 = *(_DWORD *)(v33 + 36);
          else
            v35 = *(_DWORD *)(v33 + 24);
          *outAnimType = v35;
          if ( isUsingAlternateMelee )
            v36 = *(_BYTE *)(v33 + 44);
          else
            v36 = *(_BYTE *)(v33 + 32);
          *outAnimSets = v36;
        }
      }
    }
    else if ( !AllWeaponAttachmentsCount )
    {
      return (WeaponAnimPackage *)(unsigned int)meleeAnimAltCount;
    }
    v37 = 0i64;
    if ( v12->numAnimOverrides )
    {
      v38 = 0i64;
      do
      {
        animOverrides = v12->animOverrides;
        numBindings = animOverrides[v38].numBindings;
        if ( numBindings > v8 && BG_WeaponHasOverride(r_weapon, animOverrides[v38].bindings, numBindings) )
        {
          v41 = v12->animOverrides;
          v42 = isAlternate ? v41[v38].overridesAlt : v41[v38].overrides;
          if ( v42 )
          {
            if ( isUsingAlternateMelee )
            {
              meleeAnimAltCount = v42->meleeAnimAltCount;
              meleeRandomizeAnims = v42->altMeleeRandomizeAnims;
            }
            else
            {
              meleeAnimAltCount = v42->meleeAnimPrimaryCount;
              meleeRandomizeAnims = v42->meleeRandomizeAnims;
            }
            *outIsRandomized = meleeRandomizeAnims;
            if ( isUsingAlternateMelee )
              meleeAnimPrimaryType = v42->meleeAnimAltType;
            else
              meleeAnimPrimaryType = v42->meleeAnimPrimaryType;
            *outAnimType = meleeAnimPrimaryType;
            if ( isUsingAlternateMelee )
              meleeAnimPrimarySet = v42->meleeAnimAltSet;
            else
              meleeAnimPrimarySet = v42->meleeAnimPrimarySet;
            *outAnimSets = meleeAnimPrimarySet;
            v8 = animOverrides[v38].numBindings;
          }
        }
        ++v37;
        ++v38;
      }
      while ( v37 < v12->numAnimOverrides );
    }
    if ( meleeAnimAltCount > 4 )
    {
      LODWORD(v49) = 4;
      LODWORD(v48) = meleeAnimAltCount;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2230, ASSERT_TYPE_ASSERT, "( meleeAnimCount ) <= ( (4) )", "%s <= %s\n\t%i, %i", "meleeAnimCount", "MAX_RANDOM_MELEE_ANIM_PACKAGES", v48, v49) )
        __debugbreak();
    }
    return (WeaponAnimPackage *)(unsigned int)meleeAnimAltCount;
  }
  if ( isUsingAlternateMelee )
    v15 = szXAnimsLeftHanded->altMeleeRandomizeAnims;
  else
    v15 = szXAnimsLeftHanded->meleeRandomizeAnims;
  *outIsRandomized = v15;
  v16 = v12->szXAnimsLeftHanded;
  if ( isUsingAlternateMelee )
    v17 = v16->meleeAnimAltType;
  else
    v17 = v16->meleeAnimPrimaryType;
  *outAnimType = v17;
  v18 = v12->szXAnimsLeftHanded;
  if ( isUsingAlternateMelee )
    v19 = v18->meleeAnimAltSet;
  else
    v19 = v18->meleeAnimPrimarySet;
  *outAnimSets = v19;
  v20 = v12->szXAnimsLeftHanded;
  if ( isUsingAlternateMelee )
    return (WeaponAnimPackage *)(unsigned int)v20->meleeAnimAltCount;
  else
    return (WeaponAnimPackage *)(unsigned int)v20->meleeAnimPrimaryCount;
}

/*
==============
BG_GetWeaponOffhandClass
==============
*/
__int64 BG_GetWeaponOffhandClass(const Weapon *r_weapon)
{
  unsigned __int16 weaponIdx; 

  weaponIdx = r_weapon->weaponIdx;
  if ( weaponIdx )
    return (unsigned int)BG_WeaponDefAtIndex(weaponIdx)->offhandClass;
  else
    return 0i64;
}

/*
==============
BG_GetWeaponOffhandSlot
==============
*/
OffhandSlot BG_GetWeaponOffhandSlot(const playerState_s *ps, const BgWeaponMap *weaponMap, const Weapon *r_weapon)
{
  const PlayerEquippedWeaponState *EquippedWeaponState; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20318, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20319, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( r_weapon->weaponIdx && (EquippedWeaponState = BG_GetEquippedWeaponState(weaponMap, ps, r_weapon)) != NULL )
    return EquippedWeaponState->offhandSlot;
  else
    return 0;
}

/*
==============
BG_GetWeaponOtherAttachment
==============
*/
WeaponAttachment *BG_GetWeaponOtherAttachment(const Weapon *r_weapon, const unsigned int otherIndex)
{
  __int64 v2; 
  const WeaponCompleteDef *v4; 
  WeaponAttachment *v5; 
  __int64 v7; 
  __int64 v8; 

  v2 = otherIndex;
  if ( otherIndex >= 0x10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 818, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", otherIndex, 16) )
    __debugbreak();
  if ( (truncate_cast<unsigned short,int>(1 << v2) & r_weapon->weaponOthers) == 0 )
    return 0i64;
  v4 = BG_WeaponCompleteDef(r_weapon, 0);
  if ( (unsigned int)v2 >= v4->attachments[13].attachmentCount )
  {
    LODWORD(v8) = v4->attachments[13].attachmentCount;
    LODWORD(v7) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 824, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( attList->attachmentCount )", "otherIndex doesn't index attList->attachmentCount\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  v5 = v4->attachments[13].attachments[v2];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 826, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", v4->szInternalName) )
    __debugbreak();
  return v5;
}

/*
==============
BG_GetWeaponPrimaryAttachment
==============
*/
const WeaponAttachment *BG_GetWeaponPrimaryAttachment(const Weapon *r_weapon, const AttachmentSlot attachment)
{
  __int64 v2; 
  bool v4; 
  __int64 v5; 
  unsigned __int16 v6; 
  const WeaponCompleteDef *v7; 
  __int64 v8; 
  const char **p_szInternalName; 
  __int64 v10; 
  __int64 v12; 
  __int64 v13; 

  v2 = attachment;
  v4 = attachment < ATT_SLOT_OTHER;
  if ( (unsigned int)attachment >= ATT_SLOT_OTHER )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 799, ASSERT_TYPE_ASSERT, "(unsigned)( attachment ) < (unsigned)( ATT_SLOT_PRIMARY_COUNT )", "attachment doesn't index ATT_SLOT_PRIMARY_COUNT\n\t%i not in [0, %i)", attachment, 13) )
      __debugbreak();
    v4 = (int)v2 < 13;
  }
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
    __debugbreak();
  if ( (_DWORD)v2 == 12 )
  {
    v5 = 12i64;
    v6 = r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8);
  }
  else
  {
    v5 = v2;
    v6 = r_weapon->weaponAttachments[v2];
  }
  if ( !v6 )
    return 0i64;
  v7 = BG_WeaponCompleteDef(r_weapon, 0);
  v8 = v5;
  p_szInternalName = &v7->szInternalName;
  if ( v6 > v7->attachments[v8].attachmentCount )
  {
    LODWORD(v13) = 1;
    LODWORD(v12) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 805, ASSERT_TYPE_ASSERT, "( 1 ) <= ( attachmentIndex ) && ( attachmentIndex ) <= ( attList->attachmentCount )", "attachmentIndex not in [1, attList->attachmentCount]\n\t%i not in [%i, %i]", v12, v13, v7->attachments[v8].attachmentCount) )
      __debugbreak();
  }
  v10 = *(_QWORD *)&p_szInternalName[v8 * 2 + 6][8 * v6 - 8];
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 807, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", *p_szInternalName) )
    __debugbreak();
  return (const WeaponAttachment *)v10;
}

/*
==============
BG_GetWeaponSfxPackageSound
==============
*/
SndAliasList *BG_GetWeaponSfxPackageSound(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  SndAliasLookup v2; 

  v2.name = BG_GetWeaponSfxPackageSoundLookup(sfxPackage, offset).name;
  if ( v2.name && *v2.name )
    return SND_TryFindAlias(v2.name);
  else
    return 0i64;
}

/*
==============
BG_GetWeaponSfxPackageSoundLookup
==============
*/
SndAliasLookup BG_GetWeaponSfxPackageSoundLookup(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  if ( (offset < 0 || (unsigned __int64)offset > 0x328) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2286, ASSERT_TYPE_ASSERT, "( 0 ) <= ( offset ) && ( offset ) <= ( sizeof( WeaponSFXPackageSounds ) )", "offset not in [0, sizeof( WeaponSFXPackageSounds )]\n\t%i not in [%i, %i]", offset, 0i64, 808) )
    __debugbreak();
  if ( sfxPackage )
    return *(SndAliasLookup *)((char *)&sfxPackage->sounds->name + offset);
  else
    return 0i64;
}

/*
==============
BG_GetWeaponSfxPackageSoundWithFallback
==============
*/
SndAliasList *BG_GetWeaponSfxPackageSoundWithFallback(const WeaponSFXPackage *sfxPackage, __int64 offset)
{
  __int64 v4; 
  SndAliasLookup v5; 
  const char *name; 
  SndAliasList *result; 
  const dvar_t *v8; 
  SndAliasLookup v9; 

  v4 = 0i64;
  v5.name = BG_GetWeaponSfxPackageSoundLookup(sfxPackage, offset).name;
  name = v5.name;
  if ( !v5.name || !*v5.name )
    return 0i64;
  result = SND_TryFindAlias(v5.name);
  if ( !result )
  {
    v8 = DCONST_DVARBOOL_snd_bankDetailStreamingFallback;
    if ( !DCONST_DVARBOOL_snd_bankDetailStreamingFallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_bankDetailStreamingFallback") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    if ( v8->current.enabled )
    {
      v9.name = BG_GetWeaponSfxPackageSoundLookup(sfxPackage->transientFallbackPackage, offset).name;
      if ( v9.name )
      {
        if ( *v9.name )
          return SND_TryFindAlias(v9.name);
      }
      return (SndAliasList *)v4;
    }
    else
    {
      SND_Missing(name);
      return 0i64;
    }
  }
  return result;
}

/*
==============
BG_GetWeaponSound
==============
*/
SndAliasList *BG_GetWeaponSound(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 
  SndAliasLookup v5; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  v5.name = BG_GetWeaponSfxPackageSoundLookup(SfxPackage, offset).name;
  if ( v5.name && *v5.name )
    return SND_TryFindAlias(v5.name);
  else
    return 0i64;
}

/*
==============
BG_GetWeaponSoundLookup
==============
*/
SndAliasLookup BG_GetWeaponSoundLookup(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundLookup(SfxPackage, offset);
}

/*
==============
BG_GetWeaponSoundWithFallback
==============
*/
const SndAliasList *BG_GetWeaponSoundWithFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, offset);
}

/*
==============
BG_GetWeaponSoundWithWeaponSfxPackageFallback
==============
*/
const SndAliasList *BG_GetWeaponSoundWithWeaponSfxPackageFallback(const Weapon *r_weapon, bool isAlternate, __int64 offset)
{
  const WeaponSFXPackage *SfxPackage; 
  const SndAliasList *result; 
  const WeaponDef *v7; 

  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  result = BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, offset);
  if ( !result )
  {
    v7 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2380, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return BG_GetWeaponSfxPackageSoundWithFallback(v7->sfxPackage, offset);
  }
  return result;
}

/*
==============
BG_GetWeaponStreamedModels
==============
*/
__int64 BG_GetWeaponStreamedModels(const Weapon *weapon, const XModel *(*outList)[32], const bool viewModel)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v7; 
  const XModel *gunXModelRightHand; 
  unsigned int AllWeaponAttachmentsWithIds; 
  const WeaponAttachment **v10; 
  unsigned __int8 *v11; 
  __int64 v12; 
  const WeaponAttachment *v13; 
  unsigned __int8 v14; 
  unsigned __int8 v15; 
  int v16; 
  const XModel *AttachmentModel; 
  __int64 v19; 
  __int64 v20; 
  unsigned int outCurListPos[4]; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !outList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22484, ASSERT_TYPE_ASSERT, "(outList)", (const char *)&queryFormat, "outList") )
    __debugbreak();
  weaponIdx = weapon->weaponIdx;
  outCurListPos[0] = 0;
  if ( !weaponIdx )
    return 0i64;
  v7 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22494, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
    __debugbreak();
  if ( !v7->hasAnyTransientModels )
    return 0i64;
  if ( *(_WORD *)&v7->transientBaseViewFlags )
  {
    if ( viewModel )
    {
      BG_AddStreamedWeaponModelToList(v7->gunXModel, outList, outCurListPos);
      BG_AddStreamedWeaponModelToList(v7->gunXModelLeftHand, outList, outCurListPos);
      gunXModelRightHand = v7->gunXModelRightHand;
    }
    else
    {
      BG_AddStreamedWeaponModelToList(v7->worldModel, outList, outCurListPos);
      BG_AddStreamedWeaponModelToList(v7->worldXModelLeftHand, outList, outCurListPos);
      gunXModelRightHand = v7->worldXModelRightHand;
    }
    BG_AddStreamedWeaponModelToList(gunXModelRightHand, outList, outCurListPos);
  }
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( AllWeaponAttachmentsWithIds )
  {
    v10 = (const WeaponAttachment **)attachments;
    v11 = attachmentIds;
    v12 = AllWeaponAttachmentsWithIds;
    do
    {
      v13 = *v10;
      if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22523, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      v14 = *v11;
      if ( *v11 >= 0x1Du )
      {
        LODWORD(v20) = 29;
        LODWORD(v19) = v14;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22526, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentId ) < (unsigned)( ( sizeof( *array_counter( weapon.attachmentVariationIndices ) ) + 0 ) )", "attachmentId doesn't index ARRAY_COUNT( weapon.attachmentVariationIndices )\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
      }
      v15 = weapon->attachmentVariationIndices[v14];
      if ( v15 >= 0x10u )
      {
        LODWORD(v20) = 16;
        LODWORD(v19) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22529, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( 16 )", "variationIndex doesn't index MAX_ATT_XMODEL_VARIATION\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
      }
      if ( v15 < (int)v13->numModelVariations )
      {
        v16 = v13->transientViewFlags | v13->transientWorldFlags;
        if ( _bittest(&v16, v15) )
        {
          AttachmentModel = BG_GetAttachmentModel(*v10, v15, viewModel);
          BG_AddStreamedWeaponModelToList(AttachmentModel, outList, outCurListPos);
        }
      }
      ++v11;
      ++v10;
      --v12;
    }
    while ( v12 );
  }
  return outCurListPos[0];
}

/*
==============
BG_GetWeaponThermalPlayerFadeDistStartAndEnd
==============
*/
__int64 BG_GetWeaponThermalPlayerFadeDistStartAndEnd(const Weapon *r_weapon, const bool isAlternate, vec2_t *outStartAndEnd)
{
  unsigned __int8 v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  __int64 v7; 
  WeaponAttachment *v8; 
  AttDlcOverrides *dlcOverrides; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  *outStartAndEnd = 0i64;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    v7 = WeaponAttachments_Internal;
    do
    {
      v8 = *v6;
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23101, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      dlcOverrides = v8->dlcOverrides;
      if ( dlcOverrides && dlcOverrides->useFloatOverride[2] )
      {
        v4 = 1;
        outStartAndEnd->v[0] = dlcOverrides->floatOverride[2];
        outStartAndEnd->v[1] = v8->dlcOverrides->floatOverride[3];
      }
      ++v6;
      --v7;
    }
    while ( v7 );
  }
  return v4;
}

/*
==============
BG_GetWeaponType
==============
*/
__int64 BG_GetWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  weapType_t weapType; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  __int64 result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  weapType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)weapType;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16425, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    result = (unsigned int)(*i)->weaponType;
    if ( (_DWORD)result )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)weapType;
  }
  return result;
}

/*
==============
BG_GungHoSprintLoopTime
==============
*/
__int64 BG_GungHoSprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 178i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_GUNGHO_SPRINT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_HasADSAltSwitchAnims
==============
*/
bool BG_HasADSAltSwitchAnims(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  const PlayerWeaponAnimArrays *v4; 
  bool v5; 
  bool result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19150, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19153, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v5 = v4 && v4->normalAnimArray[327] && v4->normalAnimArray[330];
  result = v4 != (const PlayerWeaponAnimArrays *)-4976i64 && v4->altAnimArray[327] && v4->altAnimArray[330];
  if ( v5 )
  {
    if ( result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19161, ASSERT_TYPE_ASSERT, "(!( mainPackageHasAltRaiseDropAnims && altPackageHasAltRaiseDropAnims ))", "%s\n\tYou can only place the ADS alt switch animations on either the main or the alt animation package. Not both at the same time.", "!( mainPackageHasAltRaiseDropAnims && altPackageHasAltRaiseDropAnims )") )
      __debugbreak();
    return 1;
  }
  if ( result )
    return 1;
  return result;
}

/*
==============
BG_HasDefaultViewModel
==============
*/
bool BG_HasDefaultViewModel(const Weapon *r_weapon)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->defaultViewModel != NULL;
}

/*
==============
BG_HasDefaultWorldModel
==============
*/
bool BG_HasDefaultWorldModel(const Weapon *r_weapon)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->defaultWorldModel != NULL;
}

/*
==============
BG_HasDualFOV
==============
*/
_BOOL8 BG_HasDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment *v10; 
  const WeaponAttachment *v11; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  WeaponAttachment **i; 
  WeaponAttachment *v15; 
  AttSight *sight; 
  WeaponAttachment *outDataAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2948, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v8 = 0;
  outDataAttachment = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v10 = NULL;
  v11 = NULL;
  if ( ps )
  {
    if ( weaponMap )
    {
      EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
      if ( EquippedWeaponStateConst )
      {
        if ( EquippedWeaponStateConst->hybridScope )
        {
          HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(r_weapon, isAlternate, (const WeaponAttachment **)&outDataAttachment);
          v10 = outDataAttachment;
          v11 = HybridScopeEnablerAttachment;
        }
      }
    }
  }
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useDualFOV;
  for ( i = attachments; ; ++i )
  {
    v15 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2964, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v11 == v15 )
    {
      if ( v10 )
        v15 = v10;
    }
    sight = v15->sight;
    if ( sight )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useDualFOV;
  }
  return sight->useDualFOV;
}

/*
==============
BG_HasDualFOVEquipped
==============
*/
bool BG_HasDualFOVEquipped(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelOrOffhandADSSupportWeapon; 
  bool v5; 
  int HasUnderbarrelWeapon; 
  bool outIsAlternate; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3019, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3020, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelOrOffhandADSSupportWeapon = BG_GetViewmodelOrOffhandADSSupportWeapon(weaponMap, ps, &outIsAlternate);
  if ( !ps )
    goto LABEL_13;
  v5 = outIsAlternate;
  if ( !outIsAlternate )
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5);
  if ( !BG_PWF_UseAlternateAsOffhand(ps) )
  {
LABEL_13:
    v5 = outIsAlternate;
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5);
  }
  HasUnderbarrelWeapon = BG_HasUnderbarrelWeapon(ViewmodelOrOffhandADSSupportWeapon);
  v5 = outIsAlternate;
  if ( HasUnderbarrelWeapon )
    v5 = 0;
  outIsAlternate = v5;
  return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5);
}

/*
==============
BG_HasForegrip
==============
*/
_BOOL8 BG_HasForegrip(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v2; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v2 = WeaponPrimaryAttachment;
  return WeaponPrimaryAttachment && !BG_IsUnderbarrelGl(WeaponPrimaryAttachment) && !BG_IsUnderbarrelShotgun(v2);
}

/*
==============
BG_HasHoldBreathAbility
==============
*/
__int64 BG_HasHoldBreathAbility(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  bool v4; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned __int8 canHoldBreath; 
  unsigned int v7; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v9; 
  WeaponAttachment **v10; 
  AttHoldBreath *holdBreath; 
  bool v13; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2822, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2823, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActive(ps) || BG_IsUsingOffhandGestureWeapon(ps) )
    return 0i64;
  v13 = BG_UsingAlternate(ps);
  v4 = v13;
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  canHoldBreath = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx)->canHoldBreath;
  v7 = 0;
  if ( BG_HasPerk(&ps->perks, 0x17u) )
  {
    canHoldBreath = 1;
  }
  else
  {
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v13, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    v9 = 0;
    if ( WeaponAttachments_Internal )
    {
      v10 = attachments;
      while ( 1 )
      {
        if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2854, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        holdBreath = (*v10)->holdBreath;
        if ( holdBreath )
          break;
        ++v9;
        ++v10;
        if ( v9 >= WeaponAttachments_Internal )
          goto LABEL_20;
      }
      canHoldBreath = holdBreath->canHoldBreath;
LABEL_20:
      v4 = v13;
    }
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND|WEAPON_LADDER_AIM) )
    return canHoldBreath;
  if ( canHoldBreath && BG_UsingSniperScope(weaponMap, ps) && BG_GetWeaponClass(CurrentWeaponForPlayer, v4) != WEAPCLASS_ITEM )
    return 1;
  return v7;
}

/*
==============
BG_HasLadderHand
==============
*/
bool BG_HasLadderHand(const playerState_s *ps)
{
  const dvar_t *v2; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20943, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v2 = DCONST_DVARMPBOOL_ladderEnableEnhanced;
  if ( !DCONST_DVARMPBOOL_ladderEnableEnhanced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableEnhanced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  return v2->current.enabled && GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x32u);
}

/*
==============
BG_HasPredictedProjectileAttachment
==============
*/
bool BG_HasPredictedProjectileAttachment(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  bool result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  result = 0;
  if ( WeaponPrimaryAttachment )
  {
    projectile = WeaponPrimaryAttachment->projectile;
    if ( projectile )
    {
      if ( projectile->isPredictedProjectile )
        return 1;
    }
  }
  return result;
}

/*
==============
BG_HasThermalScope
==============
*/
_BOOL8 BG_HasThermalScope(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  bool v4; 
  bool thermalScope; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttADSOverlay *adsOverlay; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  v4 = isAlternate;
  if ( ps && isAlternate && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v4 = 0;
  thermalScope = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->thermalScope;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v4, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return thermalScope;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15545, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    adsOverlay = (*i)->adsOverlay;
    if ( adsOverlay )
      break;
    if ( ++v3 >= WeaponAttachments_Internal )
      return thermalScope;
  }
  return adsOverlay->thermalScope;
}

/*
==============
BG_HasUnderbarrelAmmo
==============
*/
bool BG_HasUnderbarrelAmmo(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  bool v3; 
  const Weapon *v4; 
  const WeaponAttachment *v5; 
  bool result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v3 = WeaponPrimaryAttachment && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE;
  v4 = r_weapon;
  if ( !v3 )
    v4 = &NULL_WEAPON;
  result = 0;
  if ( r_weapon->weaponIdx )
  {
    v5 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
    if ( v5 )
    {
      if ( v5->weapClass != WEAPCLASS_NONE )
        return 1;
    }
    if ( v4->weaponIdx )
      return 1;
  }
  return result;
}

/*
==============
BG_HasUnderbarrelAttachment
==============
*/
bool BG_HasUnderbarrelAttachment(const Weapon *r_weapon, bool isAlternate, const scr_string_t attachmentName)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  if ( !attachmentName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1828, ASSERT_TYPE_ASSERT, "(attachmentName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "attachmentName != NULL_SCR_STRING") )
    __debugbreak();
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
    LOBYTE(WeaponPrimaryAttachment) = WeaponPrimaryAttachment->internalName == attachmentName;
  return (char)WeaponPrimaryAttachment;
}

/*
==============
BG_HasUnderbarrelGL
==============
*/
int BG_HasUnderbarrelGL(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
    LODWORD(WeaponPrimaryAttachment) = BG_IsUnderbarrelGl(WeaponPrimaryAttachment);
  return (int)WeaponPrimaryAttachment;
}

/*
==============
BG_HasUnderbarrelShotgun
==============
*/
int BG_HasUnderbarrelShotgun(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( WeaponPrimaryAttachment )
    LODWORD(WeaponPrimaryAttachment) = BG_IsUnderbarrelShotgun(WeaponPrimaryAttachment);
  return (int)WeaponPrimaryAttachment;
}

/*
==============
BG_HasUnderbarrelWeapon
==============
*/
_BOOL8 BG_HasUnderbarrelWeapon(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v2; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v2 = WeaponPrimaryAttachment;
  return WeaponPrimaryAttachment && (BG_IsUnderbarrelGl(WeaponPrimaryAttachment) || BG_IsUnderbarrelShotgun(v2));
}

/*
==============
BG_HasVRLegendaryScope
==============
*/
char BG_HasVRLegendaryScope(const Weapon *r_weapon, const bool isAlternate)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) )
    return 0;
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; (*i)->type || (*i)->internalName != scr_const.vrlscope; ++i )
  {
    if ( ++v4 >= WeaponAttachments_Internal )
      return 0;
  }
  return 1;
}

/*
==============
BG_HasVRScope
==============
*/
char BG_HasVRScope(const Weapon *r_weapon, const bool isAlternate)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  scr_string_t internalName; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) )
    return 0;
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( (*i)->type == ATTACHMENT_SCOPE )
    {
      internalName = (*i)->internalName;
      if ( internalName == scr_const.vrscope || internalName == scr_const.vrlscope )
        break;
    }
    if ( ++v4 >= WeaponAttachments_Internal )
      return 0;
  }
  return 1;
}

/*
==============
BG_HasVariableZoom
==============
*/
bool BG_HasVariableZoom(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  bool v7; 

  v7 = BG_UsingAlternate(ps);
  return BG_ADSZoomCount(weaponMap, ps, r_weapon, v7) > 1;
}

/*
==============
BG_HeatSmokeEffect
==============
*/
void BG_HeatSmokeEffect(const Weapon *r_weapon, bool isAlternate, bool isViewmodel, FxCombinedDef *muzzleSmoke, FxCombinedDef *barrelSmoke, FxCombinedDef *ejectionPortSmoke)
{
  FxCombinedDef *v8; 
  __int64 v9; 

  if ( isViewmodel )
  {
    if ( muzzleSmoke )
      muzzleSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 112i64).particleSystemDef;
    if ( barrelSmoke )
      barrelSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 128i64).particleSystemDef;
    v8 = ejectionPortSmoke;
    if ( ejectionPortSmoke )
    {
      v9 = 144i64;
LABEL_14:
      v8->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, v9).particleSystemDef;
    }
  }
  else
  {
    if ( muzzleSmoke )
      muzzleSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 120i64).particleSystemDef;
    if ( barrelSmoke )
      barrelSmoke->particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 136i64).particleSystemDef;
    v8 = ejectionPortSmoke;
    if ( ejectionPortSmoke )
    {
      v9 = 152i64;
      goto LABEL_14;
    }
  }
}

/*
==============
BG_HideBone
==============
*/
unsigned __int8 BG_HideBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return BG_HideBoneByModelRange(bone, obj, partBits, startModel, -1);
}

/*
==============
BG_HideBoneByModelRange
==============
*/
__int64 BG_HideBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  unsigned __int8 childIndex[24]; 
  unsigned __int8 index; 

  if ( startModel < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5037, ASSERT_TYPE_ASSERT, "( startModel ) >= ( 0 )", "%s >= %s\n\t%i, %i", "startModel", "0", startModel, 0i64) )
    __debugbreak();
  index = -2;
  if ( DObjGetBoneIndexFromModelRange(obj, bone, startModel, lastModelInclusive, &index) )
  {
    bitarray_base<bitarray<256>>::setBit(partBits, index);
    for ( childIndex[0] = -2; DObjGetNextChildBoneIndex(obj, index, childIndex); partBits->array[(unsigned __int64)childIndex[0] >> 5] |= 0x80000000 >> (childIndex[0] & 0x1F) )
      ;
  }
  return index;
}

/*
==============
BG_HideIronSights
==============
*/
void BG_HideIronSights(DObj *obj, int startModel, int lastModelInclusive, bool hideRail)
{
  DObjPartBits *p_hidePartBits; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5134, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight2_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  p_hidePartBits = &obj->hidePartBits;
  if ( hideRail )
    BG_HideBoneByModelRange((const scr_string_t)scr_const.weaponrail_on, obj, p_hidePartBits, startModel, lastModelInclusive);
  else
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.weaponrail_on, obj, p_hidePartBits, startModel, lastModelInclusive);
}

/*
==============
BG_HideSlingBonesForDObj
==============
*/
void BG_HideSlingBonesForDObj(DObj *obj, bool hideBones)
{
  const scr_string_t **v4; 
  __int64 v5; 
  DObjPartBits *p_hidePartBits; 
  scr_string_t v7; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5750, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( DObjHasProceduralBones(obj) )
  {
    v4 = SLING_HIDE_BONES;
    v5 = 6i64;
    do
    {
      p_hidePartBits = &obj->hidePartBits;
      v7 = **v4;
      if ( hideBones )
        BG_HideBoneByModelRange(v7, obj, p_hidePartBits, 0, -1);
      else
        BG_ShowBoneByModelRange(v7, obj, p_hidePartBits, 0, -1);
      ++v4;
      --v5;
    }
    while ( v5 );
  }
}

/*
==============
BG_HideSniperScene
==============
*/
void BG_HideSniperScene(const Weapon *r_weapon, DObj *obj)
{
  const scr_string_t **v4; 
  unsigned int i; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5543, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, &obj->hidePartBits, 0, -1);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, &obj->hidePartBits, 0, -1);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  if ( BG_ShowBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, &obj->hidePartBits, 0, -1) <= 0xFDu )
  {
    v4 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
    for ( i = 0; i < 0xD; ++i )
      BG_ToggleBoneVisibilityInAllModels(**v4++, obj, &obj->hidePartBits, 1);
  }
  BG_UpdateWeaponCosmeticBones(r_weapon, obj, 0, -1);
}

/*
==============
BG_HideWarningIcons
==============
*/
_BOOL8 BG_HideWarningIcons(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hideWarningIcons;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16261, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hideWarningIcons;
  }
  return ui->hideWarningIcons;
}

/*
==============
BG_HipSpreadFireAdd
==============
*/
float BG_HipSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v13; 
  __int64 v15; 
  bool v16; 
  bool v17; 
  WeaponAttachment **v21; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v30; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-28h], xmm6
    vmovaps xmmword ptr [r11-48h], xmm8
  }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v9 = 0;
  __asm { vmovss  xmm8, dword ptr [rax+508h] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  if ( WeaponAttachments_Internal )
  {
    __asm { vmovaps [rsp+1A8h+var_38], xmm7 }
    v13 = attachments;
    __asm { vxorps  xmm7, xmm7, xmm7 }
    v15 = WeaponAttachments_Internal;
    do
    {
      v16 = *v13 == NULL;
      if ( !*v13 )
      {
        v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14103, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v16 = !v17;
        if ( v17 )
          __debugbreak();
      }
      _RAX = *v13;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2E8h]
        vucomiss xmm0, xmm7
      }
      if ( !v16 )
        __asm { vmulss  xmm6, xmm6, xmm0 }
      ++v13;
      --v15;
    }
    while ( v15 );
    __asm { vmovaps xmm7, [rsp+1A8h+var_38] }
  }
  if ( WeaponAttachments_Internal )
  {
    v21 = attachments;
    while ( 1 )
    {
      if ( !*v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14110, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v21)->hipSpread )
        break;
      ++v9;
      ++v21;
      if ( v9 >= WeaponAttachments_Internal )
        goto LABEL_17;
    }
    __asm { vmulss  xmm0, xmm6, dword ptr [rcx+28h] }
  }
  else
  {
LABEL_17:
    __asm { vmulss  xmm0, xmm6, xmm8 }
  }
  _R11 = &v30;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_HoldBreathMaxTime
==============
*/
__int64 BG_HoldBreathMaxTime(const playerState_s *const ps)
{
  bitarray<64> *p_perks; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2881, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_player_breath_hold_time;
  if ( !DCONST_DVARFLT_player_breath_hold_time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_hold_time") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmulss  xmm0, xmm0, cs:__real@447a0000
  }
  p_perks = &ps->perks;
  __asm { vcvttss2si ebx, xmm0 }
  if ( BG_HasPerk(&ps->perks, 4u) )
  {
    _RDI = DVARFLT_perk_extraBreath;
    if ( !DVARFLT_perk_extraBreath && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_extraBreath") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si eax, xmm1
    }
    _EBX += _EAX;
  }
  if ( BG_HasPerk(p_perks, 0x12u) )
  {
    _RDI = DVARFLT_perk_improvedExtraBreath;
    if ( !DVARFLT_perk_improvedExtraBreath && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_improvedExtraBreath") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si eax, xmm1
    }
    _EBX += _EAX;
  }
  result = 0i64;
  if ( _EBX > 0 )
    return (unsigned int)_EBX;
  return result;
}

/*
==============
BG_HoldingBreath
==============
*/
_BOOL8 BG_HoldingBreath(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2872, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return ps->holdBreathTimer > 0;
}

/*
==============
BG_HudIcon
==============
*/
GfxImage *BG_HudIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  GfxImage **p_hudIcon; 
  GfxImage *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hudIcon;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16180, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    p_hudIcon = &(*i)->ui->hudIcon;
    if ( p_hudIcon )
    {
      result = *p_hudIcon;
      if ( *p_hudIcon )
        break;
    }
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->hudIcon;
  }
  return result;
}

/*
==============
BG_HybridToggleIsAllowed
==============
*/
bool BG_HybridToggleIsAllowed(const BgWeaponMap *weaponMap, const playerState_s *ps, const BgHandler *handler)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7570, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7571, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7572, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  return (ps->weapState[0].weaponState & 0xFFFFFFEF) == 0 || PM_Weapon_IsInInterruptibleState(weaponMap, ps, WEAPON_HAND_DEFAULT, handler);
}

/*
==============
BG_IdleCrouchFactor
==============
*/
float BG_IdleCrouchFactor(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+538h] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12183, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->idleSettings )
        break;
      ++v6;
      ++v9;
      if ( v6 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_9;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx+8] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_9:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_IdleProneFactor
==============
*/
float BG_IdleProneFactor(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v9; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v6 = 0;
  __asm { vmovss  xmm6, dword ptr [rax+53Ch] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v9 = attachments;
    while ( 1 )
    {
      if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12208, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v9)->idleSettings )
        break;
      ++v6;
      ++v9;
      if ( v6 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_9;
      }
    }
    __asm { vmovss  xmm0, dword ptr [rcx+0Ch] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_9:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_InADS
==============
*/
bool BG_InADS(const playerState_s *ps)
{
  bool v2; 
  bool v3; 

  _RBX = ps;
  v2 = ps == NULL;
  if ( !ps )
  {
    v3 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3586, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps");
    v2 = !v3;
    if ( v3 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vucomiss xmm0, dword ptr [rbx+730h]
  }
  return v2;
}

/*
==============
BG_InheritsPerks
==============
*/
_BOOL8 BG_InheritsPerks(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool inheritsPerks; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  inheritsPerks = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->inheritsPerks;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return inheritsPerks;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8063, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return inheritsPerks;
  }
  return general->inheritsPerks;
}

/*
==============
BG_InitClientWeapons
==============
*/
void BG_InitClientWeapons(BgWeaponMap *weaponMap, clientState_t *cs)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20428, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !cs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20429, ASSERT_TYPE_ASSERT, "(cs)", (const char *)&queryFormat, "cs") )
    __debugbreak();
  *(_QWORD *)&cs->serverDobjHeldWeapon.m_mapEntryId = 0i64;
}

/*
==============
BG_InitPlayerWeapons
==============
*/
void BG_InitPlayerWeapons(playerState_s *ps)
{
  ActionSlotParam *actionSlotParam; 
  int v3; 
  unsigned int v4; 
  unsigned int *p_eventParm; 
  unsigned int v6; 
  unsigned int *v7; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  actionSlotParam = ps->actionSlotParam;
  *(_QWORD *)&ps->weapCommon.weaponHandle.m_mapEntryId = 0i64;
  v3 = 0;
  ps->weapCommon.offHandHandle.m_mapEntryId = 0;
  *(_QWORD *)&ps->weapCommon.lastWeaponHandle.m_mapEntryId = 0i64;
  ps->weapCommon.weaponAnimArrayHandle.m_mapEntryId = 0;
  ps->weapCommon.forcedViewAnimWeaponHandle.m_mapEntryId = 0;
  ps->weapCommon.forcedViewAnimOriginalWeaponHandle.m_mapEntryId = 0;
  *(_QWORD *)&ps->throwbackWeaponHandle.m_mapEntryId = 0i64;
  *(_QWORD *)&ps->serverDobjTurretWeapon.m_mapEntryId = 0i64;
  ps->highPriorityWeapInfo.weaponHandle.m_mapEntryId = 0;
  *(_QWORD *)&ps->weaponsEquipped[0].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[2].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[4].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[6].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[8].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[10].m_mapEntryId = 0i64;
  *(_QWORD *)&ps->weaponsEquipped[12].m_mapEntryId = 0i64;
  ps->weaponsEquipped[14].m_mapEntryId = 0;
  do
  {
    if ( BG_ActionSlotIsWeaponType(ps, v3) )
      actionSlotParam->specifyWeapon.weaponHandle.m_mapEntryId = 0;
    ++v3;
    ++actionSlotParam;
  }
  while ( v3 < 7 );
  v4 = 0;
  p_eventParm = &ps->unpredictableEvents[0].eventParm;
  do
  {
    if ( BG_IsWeaponEvent(*(p_eventParm - 1)) )
      *p_eventParm = 0;
    ++v4;
    p_eventParm += 2;
  }
  while ( v4 < 4 );
  v6 = 0;
  v7 = &ps->pe.events[0].eventParm;
  do
  {
    if ( BG_IsWeaponEvent(*(v7 - 1)) )
      *v7 = 0;
    ++v6;
    v7 += 2;
  }
  while ( v6 < 4 );
}

/*
==============
BG_InterruptTimeCommon
==============
*/
int BG_InterruptTimeCommon(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, __int64 offset)
{
  __int64 WeaponAttachments_Internal; 
  const BgWeaponMap *v20; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v22; 
  __int64 v24; 
  WeaponAttachment **v25; 
  const WeaponAttachment *v26; 
  const BgWeaponMap *v27; 
  int result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v48; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10267, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, offset, NUM_WEAP_ANIMS);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm8, xmm8, xmm8
    vcvtsi2ss xmm8, xmm8, eax
    vmovaps xmm6, xmm7
  }
  WeaponAttachments_Internal = (unsigned int)BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v20 = pmoveHandler->GetWeaponMap(pmoveHandler);
  v22 = ps && v20 && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v20, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovaps xmm1, xmm7 }
  if ( (_DWORD)WeaponAttachments_Internal )
  {
    v24 = WeaponAttachments_Internal;
    v25 = attachments;
    do
    {
      v26 = *v25;
      v27 = pmoveHandler->GetWeaponMap(pmoveHandler);
      if ( !BG_GetOverrideAttachmentWhenApplicable(v27, ps, r_weapon, isAlternate, v26, v22) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10280, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      __asm { vaddss  xmm0, xmm6, dword ptr [rbx+2B8h] }
      ++v25;
      __asm
      {
        vsubss  xmm6, xmm0, xmm7
        vmovaps xmm1, xmm6
      }
      --v24;
    }
    while ( v24 );
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm3, xmm1, xmm0
    vsubss  xmm1, xmm7, xmm3
    vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm0, xmm1, xmm1
    vcmplesd xmm2, xmm0, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm8, xmm0
    vaddss  xmm2, xmm0, cs:__real@3f000000
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm3, xmm1, xmm2
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm3, 1
    vcvttss2si eax, xmm4
  }
  _R11 = &v48;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-20h]
    vmovaps xmm7, xmmword ptr [r11-30h]
    vmovaps xmm8, xmmword ptr [r11-40h]
  }
  return result;
}

/*
==============
BG_IsADSFireOnly
==============
*/
_BOOL8 BG_IsADSFireOnly(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool adsFireOnly; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  adsFireOnly = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsFireOnly;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsFireOnly;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7434, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return adsFireOnly;
  }
  return sight->adsFire;
}

/*
==============
BG_IsAdsVisionSetActive
==============
*/
bool BG_IsAdsVisionSetActive(const BgHandler *handler, const playerState_s *ps, const Weapon *weapon, bool isAlternate, BgAdsVisionSetInfo *outVisionSetInfo)
{
  const BgWeaponMap *v9; 
  char v14; 
  BgAdsVisionSetInfo result; 

  if ( !handler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15487, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15488, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v9 = handler->GetWeaponMap(handler);
  _RAX = BG_GetAdsVisionSetInfo(&result, v9, ps, weapon, isAlternate);
  _RDI = outVisionSetInfo;
  __asm
  {
    vmovups xmm1, xmmword ptr [rax]
    vmovsd  xmm0, qword ptr [rax+10h]
    vmovups xmmword ptr [rdi], xmm1
    vmovsd  qword ptr [rdi+10h], xmm0
  }
  if ( BG_PlayerUsesNVGHalfADS(ps, handler) || !outVisionSetInfo->applyVisionSet )
    return 0;
  *(double *)&_XMM0 = BG_GetWeaponOrOffhandAdsFrac(v9, ps);
  __asm { vcomiss xmm0, dword ptr [rdi+8] }
  return !v14;
}

/*
==============
BG_IsAimDownSight
==============
*/
_BOOL8 BG_IsAimDownSight(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  bool v5; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = v4->aimDownSight || v4->turretADSEnabled && v4->weapClass == WEAPCLASS_TURRET;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v5;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7410, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return v5;
  }
  return sight->aimDownSight;
}

/*
==============
BG_IsAnimInWeaponPackages
==============
*/
char BG_IsAnimInWeaponPackages(const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const int meleeComboSeqIdx, const weapAnimFiles_t animType)
{
  const WeaponDef *v9; 
  WeaponAnimPackage *szXAnims; 
  WeaponAnimPackage *szXAnimsLeftHanded; 
  __int64 v13; 
  bool IsMeleeComboOverride; 
  unsigned int AllWeaponAttachmentsCount; 
  unsigned int v16; 
  AnimOverride *animOverrides; 
  char v18; 
  __int64 v19; 
  WeaponAnimPackage *overridesAlt; 
  bool v21; 
  WeaponAnimPackage *overrides; 
  unsigned int numBindings; 
  int AnimOverrideIdxForMeleeComboSeq; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  __int64 v28; 
  __int64 v29; 
  __int64 v30; 

  v9 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2456, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  szXAnims = v9->szXAnims;
  if ( !szXAnims )
    return 0;
  if ( isDualWielding )
  {
    szXAnimsLeftHanded = v9->szXAnimsLeftHanded;
    if ( szXAnimsLeftHanded )
      return szXAnimsLeftHanded->anims[animType] != NULL;
  }
  v13 = animType;
  if ( szXAnims->anims[v13] )
    return 1;
  IsMeleeComboOverride = BG_IsMeleeComboOverride(r_weapon, 0);
  AllWeaponAttachmentsCount = BG_GetAllWeaponAttachmentsCount(r_weapon);
  if ( !IsMeleeComboOverride )
  {
    if ( AllWeaponAttachmentsCount )
    {
      v16 = 0;
      if ( v9->numAnimOverrides )
      {
        while ( 1 )
        {
          animOverrides = v9->animOverrides;
          v18 = 0;
          v19 = v16;
          if ( isAlternate )
          {
            overridesAlt = animOverrides[v19].overridesAlt;
            if ( overridesAlt && overridesAlt->anims[v13] )
              v18 = 1;
            v21 = v18 == 0;
          }
          else
          {
            overrides = animOverrides[v19].overrides;
            if ( !overrides )
              goto LABEL_22;
            v21 = overrides->anims[v13] == NULL;
          }
          if ( !v21 )
          {
            numBindings = animOverrides[v19].numBindings;
            if ( numBindings )
            {
              if ( BG_WeaponHasOverride(r_weapon, animOverrides[v19].bindings, numBindings) )
                return 1;
            }
          }
LABEL_22:
          if ( ++v16 >= v9->numAnimOverrides )
            return 0;
        }
      }
    }
    return 0;
  }
  AnimOverrideIdxForMeleeComboSeq = BG_GetAnimOverrideIdxForMeleeComboSeq(r_weapon, meleeComboSeqIdx);
  v25 = AnimOverrideIdxForMeleeComboSeq;
  if ( AnimOverrideIdxForMeleeComboSeq < 0 )
    return 0;
  if ( AnimOverrideIdxForMeleeComboSeq >= v9->numAnimOverrides )
  {
    LODWORD(v30) = AnimOverrideIdxForMeleeComboSeq;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2488, ASSERT_TYPE_ASSERT, "(unsigned)( animOverrideIdx ) < (unsigned)( weapDef->numAnimOverrides )", "animOverrideIdx doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v30, v9->numAnimOverrides) )
      __debugbreak();
  }
  v26 = (__int64)&v9->animOverrides[v25];
  v27 = *(_QWORD *)(v26 + 16);
  if ( isAlternate )
  {
    v28 = *(_QWORD *)(v26 + 24);
    if ( v28 )
    {
      v29 = *(_QWORD *)(v28 + 8);
      return *(_QWORD *)(v13 * 8 + v29) != 0;
    }
    return 0;
  }
  if ( !v27 )
    return 0;
  v29 = *(_QWORD *)(v27 + 8);
  return *(_QWORD *)(v13 * 8 + v29) != 0;
}

/*
==============
BG_IsArmorPiercing
==============
*/
_BOOL8 BG_IsArmorPiercing(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool armorPiercing; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  armorPiercing = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->armorPiercing;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return armorPiercing;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7351, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return armorPiercing;
  }
  return penetration->armorPiercing;
}

/*
==============
BG_IsAttachmentHybridThermal
==============
*/
bool BG_IsAttachmentHybridThermal(const WeaponAttachment *attachment)
{
  AttADSOverlay *adsOverlay; 

  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7638, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  return BG_CanAttachmentHybridToggle(attachment) && (adsOverlay = attachment->adsOverlay->hybridScopeAttachment->adsOverlay) != NULL && adsOverlay->thermalScope;
}

/*
==============
BG_IsBallPassValid
==============
*/
bool BG_IsBallPassValid(const playerState_s *ps, const Weapon *r_weapon)
{
  const WeaponDef *v4; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19585, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19577, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->weapClass == WEAPCLASS_BALL && GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagStrict(&ps->otherFlags, (POtherFlagsMP)48);
}

/*
==============
BG_IsBallWeapon
==============
*/
bool BG_IsBallWeapon(const Weapon *r_weapon)
{
  const WeaponDef *v1; 

  v1 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19577, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v1->weapClass == WEAPCLASS_BALL;
}

/*
==============
BG_IsBeamStyleTracer
==============
*/
bool BG_IsBeamStyleTracer(const Weapon *r_weapon, bool isAlternate)
{
  tracerStyle_t tracerStyle; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *v6; 
  AttAmmoTracer *v7; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoTracer *tracer; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  tracerStyle = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->tracerStyle;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v6 = (WeaponAttachment *)WeaponPrimaryAttachment;
  if ( WeaponPrimaryAttachment && (v7 = WeaponPrimaryAttachment->tracer) != NULL && isAlternate )
  {
    tracerStyle = v7->tracerStyle;
  }
  else
  {
    v8 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7284, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        tracer = (*i)->tracer;
        if ( tracer )
        {
          if ( *i != v6 )
            break;
        }
        if ( ++v8 >= WeaponAttachments_Internal )
          return tracerStyle == TRACERSTYLE_BEAM;
      }
      tracerStyle = tracer->tracerStyle;
    }
  }
  return tracerStyle == TRACERSTYLE_BEAM;
}

/*
==============
BG_IsBeamWeapon
==============
*/
bool BG_IsBeamWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  weapClass_t WeaponClass; 

  WeaponClass = BG_GetWeaponClass(r_weapon, isAlternate);
  return WeaponClass == WEAPCLASS_BEAM || WeaponClass == WEAPCLASS_TURRET && BG_GetWeaponFireType(r_weapon, isAlternate) == WEAPON_FIRETYPE_BEAM;
}

/*
==============
BG_IsBoltAction
==============
*/
_BOOL8 BG_IsBoltAction(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bBoltAction; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttGeneral *general; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bBoltAction = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bBoltAction;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bBoltAction;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8031, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    general = (*i)->general;
    if ( general )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bBoltAction;
  }
  return general->boltAction;
}

/*
==============
BG_IsBoneVisibleOnEitherHand
==============
*/
char BG_IsBoneVisibleOnEitherHand(const LocalClientNum_t localClientNum, const char *bone)
{
  scr_string_t String; 
  cg_t *LocalClientGlobals; 
  int v5; 
  bool v6; 
  WeaponHand *i; 
  DObj *viewModelDObj; 
  __int64 v10; 
  __int64 v11; 
  unsigned __int8 index; 

  String = SL_FindString(bone);
  if ( !String )
    return 0;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v5 = 0;
  v6 = 1;
  for ( i = LocalClientGlobals->m_weaponHand; ; ++i )
  {
    if ( !v6 )
    {
      LODWORD(v11) = 2;
      LODWORD(v10) = v5;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v10, v11) )
        __debugbreak();
    }
    viewModelDObj = i->viewModelDObj;
    if ( i->viewModelDObj )
    {
      index = -2;
      if ( !DObjGetBoneIndexFromStartModel(viewModelDObj, String, 0, &index) || !bitarray_base<bitarray<256>>::testBit(&viewModelDObj->hidePartBits, index) )
        break;
    }
    v6 = (unsigned int)++v5 < 2;
    if ( v5 >= 2 )
      return 0;
  }
  return 1;
}

/*
==============
BG_IsChargeShotWeapon
==============
*/
bool BG_IsChargeShotWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  const WeaponAttachment *Attachment; 
  const WeaponAttachment *v6; 
  WeaponChargeType chargeType; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6487, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6492, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    chargeType = v6->charged->chargeType;
  }
  else
  {
    chargeType = v4->chargeType;
  }
  return (chargeType & 0xFFFFFFF7) != 0;
}

/*
==============
BG_IsEnergyBullet
==============
*/
_BOOL8 BG_IsEnergyBullet(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bEnergyBullet;
}

/*
==============
BG_IsExecutionDog
==============
*/
bool BG_IsExecutionDog(const Weapon *weapon)
{
  const WeaponCompleteDef *v2; 

  if ( !BG_IsMeleeOnlyWeapon(weapon, 0) )
    return 0;
  v2 = BG_WeaponCompleteDef(weapon, 0);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19666, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
    __debugbreak();
  return v2->szInternalName && !I_strncmp("iw8_execution_dog", v2->szInternalName, 0x11ui64);
}

/*
==============
BG_IsFauxFists
==============
*/
bool BG_IsFauxFists(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  bool v5; 
  int v7; 
  AmmoStore result; 
  AmmoStore r_clip2; 

  if ( BG_GetWeaponType(r_weapon, 0) != WEAPTYPE_PROJECTILE || BG_GetWeaponClass(r_weapon, 0) != WEAPCLASS_THROWINGKNIFE )
    return 0;
  v5 = BG_UsingAlternate(ps);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1257, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RAX = BG_AmmoStoreForWeapon(&result, r_weapon, v5);
  v7 = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+0D8h+r_clip2.weapon.weaponIdx], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+0D8h+r_clip2.weapon.attachmentVariationIndices+5], ymm1
  }
  while ( !BG_IsClipCompatible(&ps->weapCommon.ammoInClip[v7].clipIndex, &r_clip2) )
  {
    if ( (unsigned int)++v7 >= 0xF )
      return 1;
  }
  return !(ps->weapCommon.ammoInClip[v7].ammoCount[0] + ps->weapCommon.ammoInClip[v7].ammoCount[1]);
}

/*
==============
BG_IsFistsWeapon
==============
*/
bool BG_IsFistsWeapon(const Weapon *r_weapon)
{
  const WeaponCompleteDef *v1; 
  const char *szInternalName; 
  __int64 v3; 
  int v4; 
  char *v5; 
  char v6; 
  __int64 v7; 
  char v8; 

  v1 = BG_WeaponCompleteDef(r_weapon, 0);
  if ( !v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19625, ASSERT_TYPE_ASSERT, "(weaponCompleteDef)", (const char *)&queryFormat, "weaponCompleteDef") )
    __debugbreak();
  szInternalName = v1->szInternalName;
  v3 = 0x7FFFFFFFi64;
  v4 = 1;
  if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v5 = (char *)("iw7_fists_mp" - szInternalName);
  while ( 1 )
  {
    v6 = szInternalName[(_QWORD)v5];
    v7 = v3;
    v8 = *szInternalName++;
    --v3;
    if ( !v7 )
    {
LABEL_11:
      v4 = 0;
      return v4 == 0;
    }
    if ( v6 != v8 )
      break;
    if ( !v6 )
      goto LABEL_11;
  }
  if ( v6 < v8 )
    v4 = -1;
  return v4 == 0;
}

/*
==============
BG_IsForceForegripIK
==============
*/
char BG_IsForceForegripIK(const Weapon *r_weapon, const bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v5; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v8[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v8, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    v5 = *i;
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 855, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( v5->forceForegripIK )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return 1;
}

/*
==============
BG_IsForceUseWeapon
==============
*/
__int64 BG_IsForceUseWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return v2->forceUse;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20900, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0xF61];
}

/*
==============
BG_IsHighPrecisionClientFireEvent
==============
*/
bool BG_IsHighPrecisionClientFireEvent(const int eventId)
{
  unsigned __int64 v1; 
  __int64 v2; 
  bool result; 

  result = 0;
  if ( (unsigned int)eventId <= 0x33 )
  {
    v1 = eventId;
    v2 = 0xF1D0000000000i64;
    if ( _bittest64(&v2, v1) )
      return 1;
  }
  return result;
}

/*
==============
BG_IsHighPrecisionClientFireEventEnabled
==============
*/
bool BG_IsHighPrecisionClientFireEventEnabled(const int eventId, const entityState_t *es)
{
  unsigned __int64 v2; 
  const dvar_t *v4; 
  __int64 v5; 
  bool result; 

  v2 = eventId;
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20642, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  v4 = DVARBOOL_killswitch_high_precision_player_fire_event_enabled;
  if ( !DVARBOOL_killswitch_high_precision_player_fire_event_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_high_precision_player_fire_event_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  result = 0;
  if ( v4->current.enabled && es->eType == ET_PLAYER && (unsigned int)v2 <= 0x33 )
  {
    v5 = 0xF1D0000000000i64;
    if ( _bittest64(&v5, v2) )
      return 1;
  }
  return result;
}

/*
==============
BG_IsHitSurfaceTransparent
==============
*/
bool BG_IsHitSurfaceTransparent(const trace_t *trace)
{
  int surfaceFlags; 
  int v2; 
  bool result; 

  result = 1;
  if ( (trace->contents & 0x10) == 0 )
  {
    surfaceFlags = trace->surfaceFlags;
    if ( (surfaceFlags & 0x800) == 0 )
    {
      v2 = surfaceFlags & 0x1F80000;
      if ( v2 != 4718592 && v2 != 19922944 && v2 != 20447232 && v2 != 20971520 )
        return 0;
    }
  }
  return result;
}

/*
==============
BG_IsIgnoreEntInBP
==============
*/
char BG_IsIgnoreEntInBP(const BulletFireParams *bp, int entityIndex)
{
  int ignoreHitEntCount; 
  __int64 v5; 
  int *i; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 532, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  ignoreHitEntCount = bp->ignoreHitEntCount;
  if ( ignoreHitEntCount >= 16 )
    ignoreHitEntCount = 16;
  if ( ignoreHitEntCount <= 0 )
    return 0;
  v5 = 0i64;
  for ( i = bp->ignoreHitEntityQueue; *i != entityIndex; ++i )
  {
    if ( ++v5 >= ignoreHitEntCount )
      return 0;
  }
  return 1;
}

/*
==============
BG_IsImpalingBullet
==============
*/
_BOOL8 BG_IsImpalingBullet(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool impaling; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  impaling = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->impaling;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return impaling;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7372, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return impaling;
  }
  return penetration->impaling;
}

/*
==============
BG_IsIncendiaryBullet
==============
*/
_BOOL8 BG_IsIncendiaryBullet(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bIncendiaryBullet;
}

/*
==============
BG_IsLadderAiming
==============
*/
char BG_IsLadderAiming(const Weapon *currentWeapon, const playerState_s *ps, bool isAlternate)
{
  const dvar_t *v6; 
  const dvar_t *v7; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20920, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = DCONST_DVARMPBOOL_ladderEnableEnhanced;
  if ( !DCONST_DVARMPBOOL_ladderEnableEnhanced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableEnhanced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( !v6->current.enabled )
    return 0;
  v7 = DCONST_DVARMPBOOL_ladderEnableWeapon;
  if ( !DCONST_DVARMPBOOL_ladderEnableWeapon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableWeapon") )
    __debugbreak();
  if ( (Dvar_CheckFrontendServerThread(v7), v7->current.enabled) && (BG_IsLadderWeapon(currentWeapon, isAlternate) || BG_GetAmmoInClipForWeapon(ps, currentWeapon, isAlternate, WEAPON_HAND_DEFAULT)) && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 6u) && (unsigned int)(ps->ladderState.mode - 2) <= 1 )
    return 1;
  else
    return 0;
}

/*
==============
BG_IsLadderWeapon
==============
*/
bool BG_IsLadderWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v2; 
  const dvar_t *v4; 
  const WeaponDef *v5; 

  v2 = DCONST_DVARMPBOOL_ladderEnableEnhanced;
  if ( !DCONST_DVARMPBOOL_ladderEnableEnhanced && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableEnhanced") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( !v2->current.enabled )
    return 0;
  v4 = DCONST_DVARMPBOOL_ladderEnableWeapon;
  if ( !DCONST_DVARMPBOOL_ladderEnableWeapon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableWeapon") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( !v4->current.enabled )
    return 0;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20913, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v5->ladderWeapon;
}

/*
==============
BG_IsLastShotWeaponEvent
==============
*/
bool BG_IsLastShotWeaponEvent(int event)
{
  bool result; 

  switch ( event )
  {
    case '*':
    case ',':
    case '1':
    case '3':
    case '=':
    case '?':
    case 'A':
    case 'C':
    case 'E':
    case 'G':
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

/*
==============
BG_IsMeleeAnim
==============
*/
bool BG_IsMeleeAnim(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17;
}

/*
==============
BG_IsMeleeAnimFatal
==============
*/
bool BG_IsMeleeAnimFatal(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17 && BG_MapWeaponAnimIndexToMeleeIndex(animIndex) == MELEE_ANIM_FATAL;
}

/*
==============
BG_IsMeleeAnimHit
==============
*/
bool BG_IsMeleeAnimHit(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17 && BG_MapWeaponAnimIndexToMeleeIndex(animIndex) == MELEE_ANIM_HIT;
}

/*
==============
BG_IsMeleeAnimMiss
==============
*/
bool BG_IsMeleeAnimMiss(weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 262) <= 0x17 && BG_MapWeaponAnimIndexToMeleeIndex(animIndex) == MELEE_ANIM_FIRST;
}

/*
==============
BG_IsMeleeAnimState
==============
*/
bool BG_IsMeleeAnimState(int animState)
{
  return (unsigned int)(animState - 10) <= 2;
}

/*
==============
BG_IsMeleeComboOverride
==============
*/
bool BG_IsMeleeComboOverride(const Weapon *r_weapon, const unsigned int overrideIndex)
{
  __int64 v3; 
  const WeaponDef *v4; 
  unsigned int numAnimOverrides; 
  __int64 v6; 
  const WeaponCompleteDef *v7; 
  OverrideBinding *bindings; 
  __int64 slot; 
  __int64 v12; 
  __int64 v14; 
  int v15; 
  __int64 v16; 
  unsigned int v17; 

  v3 = overrideIndex;
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  numAnimOverrides = v4->numAnimOverrides;
  if ( !numAnimOverrides )
    return 0;
  if ( (unsigned int)v3 >= numAnimOverrides )
  {
    v17 = v4->numAnimOverrides;
    v15 = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19733, ASSERT_TYPE_ASSERT, "(unsigned)( overrideIndex ) < (unsigned)( weapDef->numAnimOverrides )", "overrideIndex doesn't index weapDef->numAnimOverrides\n\t%i not in [0, %i)", v15, v17) )
      __debugbreak();
  }
  v6 = v3;
  if ( !v4->animOverrides[v6].numBindings )
    return 0;
  v7 = BG_WeaponCompleteDef(r_weapon, 0);
  bindings = v4->animOverrides[v6].bindings;
  if ( !bindings->numBindingLists && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19741, ASSERT_TYPE_ASSERT, "(overrideBinding->numBindingLists != 0)", (const char *)&queryFormat, "overrideBinding->numBindingLists != 0") )
    __debugbreak();
  _RBX = bindings->bindingLists;
  if ( _RBX->slot >= (unsigned int)ATT_SLOT_COUNT )
  {
    LODWORD(v16) = 14;
    LODWORD(v14) = _RBX->slot;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19744, ASSERT_TYPE_ASSERT, "(unsigned)( overrideList->slot ) < (unsigned)( ATT_SLOT_COUNT )", "overrideList->slot doesn't index ATT_SLOT_COUNT\n\t%i not in [0, %i)", v14, v16) )
      __debugbreak();
  }
  slot = _RBX->slot;
  __asm { tzcnt   ebx, [rbx+4] }
  v12 = (__int64)&v7->attachments[slot];
  if ( _EBX >= *(_DWORD *)v12 )
  {
    LODWORD(v16) = *(_DWORD *)v12;
    LODWORD(v14) = _EBX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19748, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentIndex ) < (unsigned)( attachmentList->attachmentCount )", "attachmentIndex doesn't index attachmentList->attachmentCount\n\t%i not in [0, %i)", v14, v16) )
      __debugbreak();
  }
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8i64 * _EBX) + 16i64) == scr_const.combosequence;
}

/*
==============
BG_IsMeleeComboWeapon
==============
*/
bool BG_IsMeleeComboWeapon(const Weapon *r_weapon)
{
  return BG_IsMeleeComboOverride(r_weapon, 0);
}

/*
==============
BG_IsMeleeOnlyAxe
==============
*/
char BG_IsMeleeOnlyAxe(const Weapon *r_weapon, const bool isAlternate)
{
  const WeaponCompleteDef *v4; 
  const char *szInternalName; 
  __int64 v6; 
  char *v7; 
  char v8; 
  __int64 v9; 
  char v10; 

  if ( !BG_IsMeleeOnlyWeapon(r_weapon, isAlternate) )
    return 0;
  v4 = BG_WeaponCompleteDef(r_weapon, isAlternate);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19636, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
    __debugbreak();
  szInternalName = v4->szInternalName;
  v6 = 0x7FFFFFFFi64;
  if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v7 = (char *)("iw7_axe_mpr_melee" - szInternalName);
  do
  {
    v8 = szInternalName[(_QWORD)v7];
    v9 = v6;
    v10 = *szInternalName++;
    --v6;
    if ( !v9 )
      break;
    if ( v8 != v10 )
      return 0;
  }
  while ( v8 );
  return 1;
}

/*
==============
BG_IsMeleeOnlyWeapon
==============
*/
bool BG_IsMeleeOnlyWeapon(const Weapon *r_weapon, const bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v6; 
  int v7; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v6 = BG_WeaponDefAtIndex(weaponIdx);
  if ( isAlternate && BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE )
    return 1;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) )
  {
    v7 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; (*i)->internalName != scr_const.meleervn; ++i )
      {
        if ( ++v7 >= WeaponAttachments_Internal )
          return v6->meleeOnly;
      }
      return 1;
    }
  }
  return v6->meleeOnly;
}

/*
==============
BG_IsMountTopStrafeEnabled
==============
*/
bool BG_IsMountTopStrafeEnabled(const Weapon *r_weapon, bool isAlternate)
{
  return 0;
}

/*
==============
BG_IsMountTypeEnabled
==============
*/
bool BG_IsMountTypeEnabled(const playerState_s *const ps, const Weapon *r_weapon, bool isAlternate, const ContextMountType mountType)
{
  const dvar_t *v7; 
  const WeaponDef *v8; 
  bool v9; 
  const dvar_t *v11; 
  bool v12; 
  __int64 v13; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22138, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)mountType >= COUNT_MOUNT_TYPE )
  {
    LODWORD(v13) = mountType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22139, ASSERT_TYPE_ASSERT, "(unsigned)( mountType ) < (unsigned)( COUNT_MOUNT_TYPE )", "mountType doesn't index COUNT_MOUNT_TYPE\n\t%i not in [0, %i)", v13, 4) )
      __debugbreak();
  }
  v7 = DCONST_DVARMPBOOL_mount_enable;
  if ( !DCONST_DVARMPBOOL_mount_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "mount_enable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
    return 0;
  v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v8 )
    return 0;
  if ( mountType == MOUNT_TYPE_TOP )
  {
    v11 = DCONST_DVARMPBOOL_mount_enable_top;
    if ( !DCONST_DVARMPBOOL_mount_enable_top && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "mount_enable_top") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    v12 = v11->current.enabled && v8->mountTopEnable;
    if ( ps && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x27u) )
      return 0;
    return v12;
  }
  else
  {
    if ( (unsigned int)(mountType - 2) > 1 )
      return 0;
    v9 = Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_mount_enable_side, "mount_enable_side") && v8->mountSideEnable;
    if ( ps )
    {
      if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x28u) )
        return 0;
    }
  }
  return v9;
}

/*
==============
BG_IsOffhandWeaponType
==============
*/
_BOOL8 BG_IsOffhandWeaponType(const Weapon *r_weapon, bool isAlternate)
{
  weapType_t WeaponType; 

  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  return BG_WeaponTypeIsOffhand(WeaponType);
}

/*
==============
BG_IsPlayingLadderAnims
==============
*/
bool BG_IsPlayingLadderAnims(const characterInfo_t *ci)
{
  unsigned int Animset; 
  unsigned int Anim; 
  bool v4; 
  const PlayerAnimEntry *animation; 

  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9943, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW) && PlayerASM_IsEnabled() && !ci->usingAnimState )
  {
    Animset = BG_PlayerASM_GetAnimset(ci);
    Anim = BG_PlayerASM_GetAnim(ci, MOVEMENT);
    v4 = BG_PlayerASM_IsLadderAlias(Anim, Animset) == 0;
  }
  else
  {
    animation = ci->legs.animation;
    if ( !animation )
      return 0;
    v4 = (animation->flags & 2) == 0;
  }
  return !v4;
}

/*
==============
BG_IsPlayingVehicleOccupancyAnims
==============
*/
bool BG_IsPlayingVehicleOccupancyAnims(const characterInfo_t *ci)
{
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9936, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->enableVehicleOccupancyAnimations == 1;
}

/*
==============
BG_IsPredictedProjectileWeapon
==============
*/
bool BG_IsPredictedProjectileWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  bool result; 

  result = 1;
  if ( !BG_WeaponDefAtIndex(r_weapon->weaponIdx)->isPredictedProjectile )
  {
    WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
    if ( !WeaponPrimaryAttachment )
      return 0;
    projectile = WeaponPrimaryAttachment->projectile;
    if ( !projectile || !projectile->isPredictedProjectile )
      return 0;
  }
  return result;
}

/*
==============
BG_IsRifleBullet
==============
*/
_BOOL8 BG_IsRifleBullet(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bRifleBullet; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bRifleBullet = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bRifleBullet;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bRifleBullet;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7326, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    penetration = (*i)->penetration;
    if ( penetration )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bRifleBullet;
  }
  return penetration->rifleBullet;
}

/*
==============
BG_IsRiotShield
==============
*/
__int64 BG_IsRiotShield(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int8 v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAddOns *addOns; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->weapType == WEAPTYPE_RIOTSHIELD;
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8087, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      addOns = (*i)->addOns;
      if ( addOns )
        break;
      if ( ++v5 >= WeaponAttachments_Internal )
        return v4;
    }
    v4 |= addOns->riotShield;
  }
  return v4;
}

/*
==============
BG_IsSilenced
==============
*/
_BOOL8 BG_IsSilenced(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v4; 
  bool silenced; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v7; 
  AttAddOns *addOns; 
  unsigned __int8 v9; 
  const WeaponCompleteDef *v10; 
  const WeaponCompleteDef *v11; 
  WeaponAttachment *v12; 
  AttAddOns *v13; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  silenced = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->silenced;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7996, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      addOns = (*v7)->addOns;
      if ( addOns )
      {
        silenced = addOns->silenced;
        if ( addOns->silenced )
          break;
      }
      ++v4;
      ++v7;
      if ( v4 >= WeaponAttachments_Internal )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    if ( !silenced && isAlternate )
    {
      v9 = r_weapon->weaponAttachments[10];
      if ( v9 )
      {
        v10 = BG_WeaponCompleteDef(r_weapon, 0);
        v11 = v10;
        if ( v9 > v10->attachments[10].attachmentCount )
        {
          LODWORD(attachmentSlots) = 1;
          LODWORD(numAttachmentSlots) = v9;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 805, ASSERT_TYPE_ASSERT, "( 1 ) <= ( attachmentIndex ) && ( attachmentIndex ) <= ( attList->attachmentCount )", "attachmentIndex not in [1, attList->attachmentCount]\n\t%i not in [%i, %i]", numAttachmentSlots, attachmentSlots, v10->attachments[10].attachmentCount) )
            __debugbreak();
        }
        v12 = v11->attachments[10].attachments[v9 - 1];
        if ( v12 )
        {
          v13 = v12->addOns;
          if ( v13 )
            return v13->silenced;
        }
        else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 807, ASSERT_TYPE_ASSERT, "(weapAttachment)", "%s\n\tCorrupt weapon attachment (possible memory corruption) on weapon '%s' ", "weapAttachment", v11->szInternalName) )
        {
          __debugbreak();
        }
      }
    }
  }
  return silenced;
}

/*
==============
BG_IsSwimWeapon
==============
*/
bool BG_IsSwimWeapon(const Weapon *r_weapon)
{
  scr_string_t swim; 
  const WeaponAttachment *WeaponPrimaryAttachment; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) )
    return 0;
  swim = scr_const.swim;
  if ( !scr_const.swim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1828, ASSERT_TYPE_ASSERT, "(attachmentName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "attachmentName != NULL_SCR_STRING") )
    __debugbreak();
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  return WeaponPrimaryAttachment && WeaponPrimaryAttachment->internalName == swim;
}

/*
==============
BG_IsTargetAssistActive
==============
*/
bool BG_IsTargetAssistActive(const playerState_s *ps, const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  const Weapon *v4; 
  unsigned int v8; 
  targetAssistType_t targetAssistType; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v11; 
  WeaponAttachment **v12; 
  AttTargetAssist *targetAssist; 
  unsigned int v14; 
  WeaponAttachment **v15; 
  AttTargetAssist *v16; 
  bool targetAssistOnlyAvailableInAds; 
  char v18; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = r_weapon;
  v8 = 0;
  targetAssistType = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->targetAssistType;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v4, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v11 = 0;
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9100, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      targetAssist = (*v12)->targetAssist;
      if ( targetAssist )
        break;
      ++v11;
      ++v12;
      if ( v11 >= WeaponAttachments_Internal )
        goto LABEL_10;
    }
    targetAssistType = targetAssist->targetAssistType;
LABEL_10:
    v4 = r_weapon;
  }
  if ( targetAssistType != TARGET_ASSISTTYPPE_CONE )
    return 0;
  v14 = BG_GetWeaponAttachments_Internal(v4, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( v14 )
  {
    v15 = attachments;
    while ( 1 )
    {
      if ( !*v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9171, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v16 = (*v15)->targetAssist;
      if ( v16 )
        break;
      ++v8;
      ++v15;
      if ( v8 >= v14 )
      {
        v4 = r_weapon;
        goto LABEL_20;
      }
    }
    targetAssistOnlyAvailableInAds = v16->targetAssistOnlyAvailableInAds;
  }
  else
  {
LABEL_20:
    targetAssistOnlyAvailableInAds = BG_WeaponDefAtIndex(v4->weaponIdx)->targetAssistOnlyAvailableInAds;
  }
  if ( !ps )
  {
    if ( !es || !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&es->lerp.eFlags, GameModeFlagValues::ms_mpValue, 0x19u) )
      goto LABEL_23;
LABEL_30:
    v18 = 1;
    return !targetAssistOnlyAvailableInAds || v18;
  }
  if ( BG_InADS(ps) )
    goto LABEL_30;
LABEL_23:
  v18 = 0;
  return !targetAssistOnlyAvailableInAds || v18;
}

/*
==============
BG_IsThermalEnabled
==============
*/
bool BG_IsThermalEnabled(const BgWeaponMap *weaponMap, const Weapon *r_weapon, const playerState_s *ps)
{
  bool v6; 
  unsigned int v7; 
  bool v8; 
  bool thermalScope; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  AttADSOverlay *adsOverlay; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7655, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7656, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = BG_UsingAlternate(ps);
  v7 = 0;
  v8 = v6;
  if ( ps && v6 && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v8 = 0;
  thermalScope = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->thermalScope;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v8, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 15545, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      adsOverlay = (*v11)->adsOverlay;
      if ( adsOverlay )
        break;
      ++v7;
      ++v11;
      if ( v7 >= WeaponAttachments_Internal )
        goto LABEL_21;
    }
    thermalScope = adsOverlay->thermalScope;
  }
LABEL_21:
  result = 0;
  if ( thermalScope && (BG_InADS(ps) || BG_IsUsingOffhandGestureWeaponADSActive(ps)) )
  {
    EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
    if ( EquippedWeaponStateConst )
    {
      if ( EquippedWeaponStateConst->thermalEnabled )
        return 1;
    }
  }
  return result;
}

/*
==============
BG_IsThrowingAxe
==============
*/
bool BG_IsThrowingAxe(const Weapon *r_weapon)
{
  return BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE;
}

/*
==============
BG_IsTopMountYawClamped
==============
*/
const WeaponDef *BG_IsTopMountYawClamped(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *result; 

  result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( result )
    return (const WeaponDef *)result->mountTopYawClamp;
  return result;
}

/*
==============
BG_IsUnderbarrelGl
==============
*/
_BOOL8 BG_IsUnderbarrelGl(const WeaponAttachment *weapAttachment)
{
  if ( !weapAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 756, ASSERT_TYPE_ASSERT, "(weapAttachment)", (const char *)&queryFormat, "weapAttachment") )
    __debugbreak();
  return weapAttachment->weapClass == WEAPCLASS_GRENADE && weapAttachment->weaponType == WEAPTYPE_PROJECTILE;
}

/*
==============
BG_IsUnderbarrelShotgun
==============
*/
_BOOL8 BG_IsUnderbarrelShotgun(const WeaponAttachment *weapAttachment)
{
  if ( !weapAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 764, ASSERT_TYPE_ASSERT, "(weapAttachment)", (const char *)&queryFormat, "weapAttachment") )
    __debugbreak();
  return weapAttachment->weapClass == WEAPCLASS_SPREAD && (weapAttachment->weaponType & 0xFFFFFFFD) == 0;
}

/*
==============
BG_IsUsingDualFOV
==============
*/
bool BG_IsUsingDualFOV(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelOrOffhandADSSupportWeapon; 
  bool v5; 
  int HasUnderbarrelWeapon; 
  bool outIsAlternate; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3057, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3058, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3019, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3020, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelOrOffhandADSSupportWeapon = BG_GetViewmodelOrOffhandADSSupportWeapon(weaponMap, ps, &outIsAlternate);
  if ( !ps )
    goto LABEL_19;
  v5 = outIsAlternate;
  if ( !outIsAlternate )
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5) && !BG_IsTurretActive(ps);
  if ( !BG_PWF_UseAlternateAsOffhand(ps) )
  {
LABEL_19:
    v5 = outIsAlternate;
    return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5) && !BG_IsTurretActive(ps);
  }
  HasUnderbarrelWeapon = BG_HasUnderbarrelWeapon(ViewmodelOrOffhandADSSupportWeapon);
  v5 = outIsAlternate;
  if ( HasUnderbarrelWeapon )
    v5 = 0;
  outIsAlternate = v5;
  return BG_HasDualFOV(weaponMap, ps, ViewmodelOrOffhandADSSupportWeapon, v5) && !BG_IsTurretActive(ps);
}

/*
==============
BG_IsUsingFastReloadStateTimer
==============
*/
char BG_IsUsingFastReloadStateTimer(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 v6; 
  int *v10; 
  __int64 v12; 
  bool v13; 
  unsigned __int64 v14; 
  bool v15; 
  bool v16; 
  __int64 v17; 
  bool v18; 
  char v19; 
  bool v20; 
  int ammoInClip; 
  char v22; 
  bool v23; 
  ReloadType ReloadType; 
  PlayerHandIndex fmt; 
  bool hasFastReloadOverride; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10168, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = &ps->commandTime + 20 * v6;
  if ( (unsigned int)(v10[339] - 18) > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10173, ASSERT_TYPE_ASSERT, "(( (weapState.weaponState == WEAPON_RELOADING) || (weapState.weaponState == WEAPON_RELOAD_START) || ( (weapState.weaponState == WEAPON_RELOAD_END) || (weapState.weaponState == WEAPON_RELOAD_END_RECHAMBER) ) ))", (const char *)&queryFormat, "WEAPONSTATE_RELOADING( weapState.weaponState )") )
    __debugbreak();
  if ( v10[339] == 18 )
  {
    v23 = isAlternate;
    ReloadType = BG_GetReloadType(r_weapon, isAlternate);
    hasFastReloadOverride = 0;
    switch ( ReloadType )
    {
      case RELOAD_TYPE_MULTIPLE_PERCENTAGE:
        BG_ReloadMultipleTimePercentageBased(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, &hasFastReloadOverride);
        break;
      case RELOAD_TYPE_MULTIPLE_BULLET:
        BG_ReloadMultipleTimeBulletBased(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, &hasFastReloadOverride);
        break;
      case RELOAD_TYPE_SEGMENTED:
        goto LABEL_30;
      default:
        if ( ReloadType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10204, ASSERT_TYPE_ASSERT, "(reloadType == RELOAD_TYPE_NORMAL)", (const char *)&queryFormat, "reloadType == RELOAD_TYPE_NORMAL") )
          __debugbreak();
        if ( (v10[331] & 0xFFFFFF7F) != 17 )
LABEL_30:
          BG_ReloadTime(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, isDualWielding, v10[345], &hasFastReloadOverride);
        else
          BG_ReloadEmptyTime(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, v23, isDualWielding, &hasFastReloadOverride);
        break;
    }
    return hasFastReloadOverride;
  }
  if ( v10[339] != 19 )
  {
    if ( v10[339] != 20 )
    {
      if ( v10[339] != 21 )
        return 0;
      v12 = 2 * (5 * v6 + 85);
      fmt = (int)v6;
      v13 = isAlternate;
      v14 = *((unsigned int *)&ps->commandTime + 2 * v12);
      v15 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, fmt, v10[345], WEAP_ANIM_FAST_RELOAD_END_RECHAMBER);
      v16 = isDualWielding;
      v17 = (v14 >> 2) & 1;
      v18 = v15;
      BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, isDualWielding, 4i64 * (unsigned int)v17 + 112, NUM_WEAP_ANIMS);
      BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, v16, 4i64 * (unsigned int)v17 + 114, NUM_WEAP_ANIMS);
      v19 = 0;
      if ( v18 )
      {
        if ( BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, v16, 4i64 * (unsigned int)v17 + 124, NUM_WEAP_ANIMS) )
        {
          BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v13, v16, 4i64 * (unsigned int)v17 + 126, NUM_WEAP_ANIMS);
          return 1;
        }
      }
      return v19;
    }
    hasFastReloadOverride = 0;
    BG_ReloadEndTime(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding, v10[345], &hasFastReloadOverride);
    return hasFastReloadOverride;
  }
  v20 = isAlternate;
  ammoInClip = v10[345];
  v22 = 0;
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 96i64, NUM_WEAP_ANIMS);
  if ( BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, v20, (PlayerHandIndex)v6, ammoInClip, WEAP_ANIM_FAST_RELOAD_START) )
    return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, v20, isDualWielding, 98i64, NUM_WEAP_ANIMS) != 0;
  return v22;
}

/*
==============
BG_IsUsingHybridScope
==============
*/
bool BG_IsUsingHybridScope(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 

  return ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
}

/*
==============
BG_IsUsingWorldIKTargets
==============
*/
bool BG_IsUsingWorldIKTargets(const characterInfo_t *ci)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v2; 

  weaponIdx = ci->dobjTurretWeapon.weaponIdx;
  if ( !weaponIdx )
    return 0;
  v2 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9816, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v2->useTurret3pIK;
}

/*
==============
BG_IsValidWeapon
==============
*/
char BG_IsValidWeapon(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponCompleteDef *v4; 
  unsigned int v5; 
  AttachmentList *v6; 
  int v7; 
  bool v8; 
  unsigned int v9; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned int v11; 
  WeaponAttachment **v12; 
  WeaponAttachment *v13; 
  unsigned int numReticles; 
  unsigned int v15; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( r_weapon->weaponIdx < 0x226u )
  {
    v4 = BG_WeaponCompleteDef(r_weapon, 0);
    if ( v4 )
    {
      if ( r_weapon->weaponCamo < BG_Camo_GetCamoCount() )
      {
        v5 = 0;
        v6 = v4->attachments;
        v7 = 0;
        v8 = 1;
        while ( 1 )
        {
          if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
            __debugbreak();
          v9 = v7 == 12 ? r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8) : r_weapon->weaponAttachments[v7];
          if ( v9 > v6->attachmentCount )
            break;
          ++v7;
          ++v6;
          v8 = v7 < 13;
          if ( (unsigned int)v7 >= 0xD )
          {
            if ( (~(unsigned __int16)((1 << v4->attachments[13].attachmentCount) - 1) & r_weapon->weaponOthers) != 0 )
              return 0;
            if ( r_weapon->scopeVariation )
            {
              AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
              v11 = 0;
              if ( AllWeaponAttachmentsWithIds )
              {
                v12 = attachments;
                while ( 1 )
                {
                  v13 = *v12;
                  if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20592, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
                    __debugbreak();
                  numReticles = v13->numReticles;
                  if ( numReticles )
                  {
                    v15 = v13->numReticles;
                    if ( v5 > numReticles )
                      v15 = v5;
                    v5 = v15;
                    if ( r_weapon->scopeVariation >= numReticles )
                      break;
                  }
                  ++v11;
                  ++v12;
                  if ( v11 >= AllWeaponAttachmentsWithIds )
                  {
                    if ( !v5 )
                      return 0;
                    goto LABEL_26;
                  }
                }
              }
            }
            else
            {
LABEL_26:
              if ( !isAlternate )
                return 1;
              WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
              if ( WeaponPrimaryAttachment )
              {
                if ( WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE )
                  return 1;
              }
            }
            return 0;
          }
        }
      }
    }
  }
  return 0;
}

/*
==============
BG_IsWeaponHybridThermal
==============
*/
bool BG_IsWeaponHybridThermal(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  bool v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  WeaponAttachment *v8; 
  AttADSOverlay *adsOverlay; 
  AttADSOverlay *v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = 0;
  v4 = isAlternate;
  if ( ps && isAlternate && BG_PWF_UseAlternateAsOffhand(ps) && BG_HasUnderbarrelWeapon(r_weapon) )
    v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, v4, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7624, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    v8 = *i;
    if ( (*i)->type == ATTACHMENT_SCOPE )
      break;
    if ( ++v3 >= WeaponAttachments_Internal )
      return 0;
  }
  if ( !v8 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7638, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7505, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
  }
  adsOverlay = v8->adsOverlay;
  if ( !adsOverlay )
    return 0;
  if ( !adsOverlay->hybridToggle )
    return 0;
  v11 = adsOverlay->hybridScopeAttachment->adsOverlay;
  if ( !v11 )
    return 0;
  return v11->thermalScope;
}

/*
==============
BG_IsWeaponLaserEndViewCenterInAds
==============
*/
__int16 BG_IsWeaponLaserEndViewCenterInAds(const Weapon *r_weapon, const bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  AttLaser *laser; 
  unsigned __int16 v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v10[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v10, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17948, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      laser = (*v5)->laser;
      if ( laser )
        break;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    v7 = *(_WORD *)&laser->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  else
  {
LABEL_8:
    v7 = *(_WORD *)&BG_WeaponDefAtIndex(r_weapon->weaponIdx)->laserSettings.remotePlayerNVGHipLaserEnabled;
  }
  return HIBYTE(v7);
}

/*
==============
BG_IsWeaponRecoilDelayed
==============
*/
bool BG_IsWeaponRecoilDelayed(const pmove_t *pm, const playerState_s *ps)
{
  int v4; 

  if ( !pm && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22197, ASSERT_TYPE_ASSERT, "(pm)", (const char *)&queryFormat, "pm") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22198, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = pm->cmd.serverTime - ps->weapState[0].weaponFireTime;
  _RDI = DCONST_DVARFLT_weaponRecoilDecayDelay;
  if ( !DCONST_DVARFLT_weaponRecoilDecayDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "weaponRecoilDecayDelay") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vcvttss2si eax, xmm1
  }
  return v4 < _EAX;
}

/*
==============
BG_IsWeaponUsableInState
==============
*/
bool BG_IsWeaponUsableInState(const playerState_s *ps, const Weapon *r_weapon)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3574, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  BG_UsingAlternate(ps);
  return !BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blocksProne || !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0);
}

/*
==============
BG_IsWeaponValid
==============
*/
bool BG_IsWeaponValid(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  unsigned __int16 v6; 
  unsigned __int16 v7; 
  WeaponMapEntry *m_entries; 
  unsigned __int16 v9; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3547, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3548, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !r_weapon->weaponIdx || r_weapon->weaponIdx >= BG_GetNumWeapons() )
    return 0;
  if ( !weaponMap->m_entries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 186, ASSERT_TYPE_ASSERT, "(m_entries != nullptr)", (const char *)&queryFormat, "m_entries != nullptr") )
    __debugbreak();
  if ( !BgWeaponMap::ms_runtimeSizeInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 228, ASSERT_TYPE_ASSERT, "(ms_runtimeSizeInitialized)", (const char *)&queryFormat, "ms_runtimeSizeInitialized") )
    __debugbreak();
  v6 = BgWeaponMap::ms_runtimeSize;
  v7 = 1;
  if ( BgWeaponMap::ms_runtimeSize <= 1u )
    return 0;
  m_entries = weaponMap->m_entries;
  while ( 1 )
  {
    if ( !m_entries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 161, ASSERT_TYPE_ASSERT, "(m_entries != nullptr)", (const char *)&queryFormat, "m_entries != nullptr") )
      __debugbreak();
    v9 = truncate_cast<unsigned short,unsigned int>(v7);
    if ( !BgWeaponMap::ms_runtimeSizeInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 228, ASSERT_TYPE_ASSERT, "(ms_runtimeSizeInitialized)", (const char *)&queryFormat, "ms_runtimeSizeInitialized") )
      __debugbreak();
    if ( v9 >= BgWeaponMap::ms_runtimeSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapon_map.h", 165, ASSERT_TYPE_ASSERT, "(mapEntryIndex < BgWeaponMap::GetRuntimeSize())", "%s\n\tHandle supplied to BgWeaponMap::GetWeapon does not index the map.", "mapEntryIndex < BgWeaponMap::GetRuntimeSize()") )
      __debugbreak();
    m_entries = weaponMap->m_entries;
    if ( m_entries[v9].index == v9 && !memcmp_0(&m_entries[v7].weapon, r_weapon, 0x3Cui64) )
      break;
    if ( ++v7 >= v6 )
      return 0;
  }
  return BG_PlayerHasWeapon(weaponMap, ps, r_weapon) != 0;
}

/*
==============
BG_KickAngles
==============
*/
void BG_KickAngles(const BgWeaponMap *weaponMap, const playerState_s *ps, int updateFrameTime, int *inOutKickTimeRemaining, vec3_t *inOutKickAVel, vec3_t *inOutRawKickAngles, vec3_t *outKickAngles, bool *inOutKickNeedsToCrossCenter)
{
  Weapon *v18; 
  bool v19; 
  bool v20; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v23; 
  unsigned int v25; 
  const WeaponAttachment **v28; 
  bool v32; 
  Weapon *v33; 
  char v37; 
  __int64 v42; 
  int v45; 
  int v46; 
  BgWeaponMap *v47; 
  unsigned int v48; 
  playerState_s *v49; 
  unsigned int v50; 
  const PlayerEquippedWeaponState *v51; 
  bool v52; 
  unsigned int v53; 
  const WeaponAttachment **v54; 
  AttViewKick *AttachmentViewKick; 
  bool v56; 
  float fmt; 
  float *hipViewKickReturnAccelScale; 
  float hipViewKickReturnAccelScalea; 
  float hipViewKickReturnSpeedCurveScale; 
  float *adsViewKickAccel; 
  float *adsViewKickReturnAccelScale; 
  bool v78; 
  bool useNewViewKick; 
  bool v80; 
  float outViewKickPitchScale; 
  float outViewKickYawScale[2]; 
  float v83[2]; 
  playerState_s *psa; 
  float outGunKickYawScale; 
  float outGunKickPitchScale; 
  float v87; 
  float v88; 
  float adsViewKickReturnSpeedCurveScale; 
  float hipViewKickAccel; 
  float v91; 
  BgWeaponMap *weaponMapa; 
  vec2_t *inOutAngles; 
  Weapon *weapon; 
  vec2_t *inOutAngularVel; 
  bool *v96; 
  vec3_t *v97; 
  vec3_t maxAngles; 
  WeaponAttachment *attachments[30]; 
  WeaponAttachment *v100[30]; 
  unsigned __int8 attachmentIds[32]; 
  unsigned __int8 v102[32]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-78h], xmm8
  }
  inOutAngularVel = (vec2_t *)inOutKickAVel;
  weaponMapa = (BgWeaponMap *)weaponMap;
  inOutAngles = (vec2_t *)inOutRawKickAngles;
  v97 = outKickAngles;
  v96 = inOutKickNeedsToCrossCenter;
  psa = (playerState_s *)ps;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4364, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4365, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weapon = (Weapon *)BG_GetViewmodelWeapon(weaponMap, ps);
  v18 = weapon;
  v78 = BG_UsingAlternate(ps);
  if ( !BG_UsingSniperScope(weaponMap, ps) || (v80 = 1, !BG_HasPerk(&ps->perks, 0x29u)) )
    v80 = 0;
  v19 = BG_UsingAlternate(ps);
  BG_GetViewKickSpeed(weaponMap, ps, weapon, v19, &hipViewKickAccel, &v91, v83, &v87, &v88, &adsViewKickReturnSpeedCurveScale);
  v20 = BG_UsingAlternate(ps);
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(v18, v20, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v23 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, v18)) != NULL && EquippedWeaponStateConst->hybridScope;
  _RAX = BG_WeaponDefAtIndex(v18->weaponIdx);
  v25 = 0;
  __asm
  {
    vmovss  xmm0, dword ptr [rax+548h]
    vmovss  dword ptr [rbp+290h+maxAngles], xmm0
    vmovss  xmm1, dword ptr [rax+54Ch]
    vmovss  dword ptr [rbp+290h+maxAngles+4], xmm1
  }
  if ( WeaponAttachments_Internal )
  {
    v28 = (const WeaponAttachment **)attachments;
    while ( 1 )
    {
      if ( !*v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20859, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( BG_GetAttachmentViewKick(weaponMapa, psa, weapon, v20, *v28, v23) )
        break;
      ++v25;
      ++v28;
      if ( v25 >= WeaponAttachments_Internal )
        goto LABEL_24;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rax+160h]
      vmovss  dword ptr [rbp+290h+maxAngles], xmm0
      vmovss  xmm1, dword ptr [rax+164h]
      vmovss  dword ptr [rbp+290h+maxAngles+4], xmm1
    }
  }
LABEL_24:
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  v32 = v78;
  v33 = weapon;
  _RBX = psa;
  __asm
  {
    vmovaps [rsp+390h+var_68+8], xmm7
    vxorps  xmm0, xmm0, xmm0
    vmovaps [rsp+390h+var_88+8], xmm9
    vmovss  [rbp+290h+var_2C8], xmm0
    vmovss  [rsp+390h+outViewKickPitchScale], xmm6
    vmovss  [rsp+390h+outViewKickYawScale], xmm6
    vmovss  [rsp+390h+outGunKickPitchScale], xmm6
    vmovss  [rsp+390h+outGunKickYawScale], xmm6
    vmovaps [rsp+390h+var_98+8], xmm10
  }
  BG_GetViewAndGunKickScalars(weaponMapa, psa, weapon, v78, &outViewKickPitchScale, outViewKickYawScale, &outGunKickPitchScale, &outGunKickYawScale);
  __asm
  {
    vmovss  xmm0, cs:__real@3f000000
    vcomiss xmm0, dword ptr [rbx+730h]
  }
  if ( v37 )
  {
    __asm
    {
      vmovss  xmm7, [rsp+390h+var_318]
      vmovss  xmm9, [rsp+390h+var_314]
      vmovss  xmm10, [rbp+290h+var_310]
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm7, [rbp+290h+hipViewKickAccel]
      vmovss  xmm9, [rbp+290h+var_308]
      vmovss  xmm10, [rsp+390h+var_330]
    }
  }
  __asm { vxorps  xmm0, xmm0, xmm0 }
  v42 = (unsigned int)((updateFrameTime + *inOutKickTimeRemaining) / KICK_ANGLES_TIME_STEP);
  __asm
  {
    vcvtsi2ss xmm0, xmm0, r8d
    vmulss  xmm8, xmm0, cs:__real@3a83126f
  }
  if ( KICK_ANGLES_MAX_TIME_STEPS >= (int)v42 )
  {
    v45 = (updateFrameTime + *inOutKickTimeRemaining) % KICK_ANGLES_TIME_STEP;
  }
  else
  {
    v42 = (unsigned int)KICK_ANGLES_MAX_TIME_STEPS;
    v45 = 0;
  }
  *inOutKickTimeRemaining = v45;
  v46 = KICK_ANGLES_TIME_STEP;
  if ( KICK_ANGLES_TIME_STEP <= 0 )
  {
    LODWORD(adsViewKickReturnAccelScale) = KICK_ANGLES_TIME_STEP;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4414, ASSERT_TYPE_ASSERT, "( 0 ) < ( KICK_ANGLES_TIME_STEP )", "%s < %s\n\t%i, %i", "0", "KICK_ANGLES_TIME_STEP", 0i64, adsViewKickReturnAccelScale) )
      __debugbreak();
    v46 = KICK_ANGLES_TIME_STEP;
  }
  if ( *inOutKickTimeRemaining < 0 || *inOutKickTimeRemaining > v46 - 1 )
  {
    LODWORD(adsViewKickAccel) = v46 - 1;
    LODWORD(hipViewKickReturnAccelScale) = *inOutKickTimeRemaining;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4415, ASSERT_TYPE_ASSERT, "( 0 ) <= ( inOutKickTimeRemaining ) && ( inOutKickTimeRemaining ) <= ( KICK_ANGLES_TIME_STEP - 1 )", "inOutKickTimeRemaining not in [0, KICK_ANGLES_TIME_STEP - 1]\n\t%i not in [%i, %i]", hipViewKickReturnAccelScale, 0i64, adsViewKickAccel) )
      __debugbreak();
  }
  if ( (int)v42 < 0 )
  {
    LODWORD(adsViewKickReturnAccelScale) = v42;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4416, ASSERT_TYPE_ASSERT, "( 0 ) <= ( frameSteps )", "%s <= %s\n\t%i, %i", "0", "frameSteps", 0i64, adsViewKickReturnAccelScale) )
      __debugbreak();
  }
  if ( (int)v42 > KICK_ANGLES_MAX_TIME_STEPS )
  {
    LODWORD(adsViewKickReturnAccelScale) = KICK_ANGLES_MAX_TIME_STEPS;
    LODWORD(adsViewKickAccel) = v42;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4417, ASSERT_TYPE_ASSERT, "( frameSteps ) <= ( KICK_ANGLES_MAX_TIME_STEPS )", "%s <= %s\n\t%i, %i", "frameSteps", "KICK_ANGLES_MAX_TIME_STEPS", adsViewKickAccel, adsViewKickReturnAccelScale) )
      __debugbreak();
  }
  if ( (int)v42 > 0 )
  {
    v47 = weaponMapa;
    *(_QWORD *)v83 = v42;
    do
    {
      useNewViewKick = BG_WeaponDefAtIndex(v33->weaponIdx)->useNewViewKick;
      v48 = BG_GetWeaponAttachments_Internal(v33, v32, (const WeaponAttachment **)v100, v102, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      v49 = psa;
      v50 = v48;
      v52 = v47 && (v51 = BG_GetEquippedWeaponStateConst(v47, psa, v33)) != NULL && v51->hybridScope;
      v53 = 0;
      if ( v50 )
      {
        v54 = (const WeaponAttachment **)v100;
        while ( 1 )
        {
          if ( !*v54 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14470, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
            __debugbreak();
          AttachmentViewKick = BG_GetAttachmentViewKick(v47, v49, v33, v78, *v54, v52);
          if ( AttachmentViewKick )
            break;
          ++v53;
          ++v54;
          if ( v53 >= v50 )
          {
            v42 = *(_QWORD *)v83;
            goto LABEL_58;
          }
        }
        v56 = AttachmentViewKick->useNewViewKick;
        v42 = *(_QWORD *)v83;
      }
      else
      {
LABEL_58:
        v56 = useNewViewKick;
      }
      __asm { vmovaps xmm0, xmm8; ft }
      if ( v56 )
      {
        __asm
        {
          vmovss  dword ptr [rsp+390h+hipViewKickReturnSpeedCurveScale], xmm10
          vmovss  dword ptr [rsp+390h+hipViewKickReturnAccelScale], xmm9
          vmovaps xmm3, xmm6; kickYawScale
          vmovaps xmm2, xmm6; kickPitchScale
          vmovss  dword ptr [rsp+390h+fmt], xmm7
        }
        BG_CalculateKickMovement(*(float *)&_XMM0, (const vec2_t *)&maxAngles, *(float *)&_XMM2, *(float *)&_XMM3, fmt, hipViewKickReturnAccelScalea, hipViewKickReturnSpeedCurveScale, inOutAngles, inOutAngularVel, v96);
      }
      else
      {
        __asm { vmovaps xmm2, xmm7; recenterAccel }
        BG_CalculateKickMovement_Legacy(*(double *)&_XMM0, &maxAngles, *(double *)&_XMM2, v33, v80, (vec3_t *)inOutAngularVel, (vec3_t *)inOutAngles);
      }
      v32 = v78;
      *(_QWORD *)v83 = --v42;
    }
    while ( v42 );
  }
  _RCX = (__int64)v97;
  _RAX = inOutAngles;
  __asm
  {
    vmovaps xmm10, [rsp+390h+var_98+8]
    vmovaps xmm9, [rsp+390h+var_88+8]
    vmovaps xmm7, [rsp+390h+var_68+8]
    vmovss  xmm0, dword ptr [rax]
    vmovss  dword ptr [rcx], xmm0
    vmovss  xmm1, dword ptr [rax+4]
    vmulss  xmm0, xmm0, [rsp+390h+outViewKickPitchScale]
    vmovss  dword ptr [rcx+4], xmm1
  }
  *(float *)&_RAX = _RAX[1].v[0];
  __asm
  {
    vmulss  xmm1, xmm1, [rsp+390h+outViewKickYawScale]
    vmovss  dword ptr [rcx+4], xmm1
    vmovss  dword ptr [rcx], xmm0
  }
  *(_DWORD *)(_RCX + 8) = (_DWORD)_RAX;
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+390h+var_58+8]
    vmovaps xmm8, [rsp+390h+var_78+8]
  }
}

/*
==============
BG_LadderAimADSRaiseInterruptTime
==============
*/
__int64 BG_LadderAimADSRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 164i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimADSRaiseTime
==============
*/
__int64 BG_LadderAimADSRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 162i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimDropInterruptTime
==============
*/
__int64 BG_LadderAimDropInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 168i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimDropTime
==============
*/
__int64 BG_LadderAimDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 166i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimRaiseInterruptTime
==============
*/
__int64 BG_LadderAimRaiseInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u);
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 164i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderAimRaiseTime
==============
*/
__int64 BG_LadderAimRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 result; 

  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u) )
    LOWORD(result) = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 162i64, NUM_WEAP_ANIMS);
  else
    LOWORD(result) = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 158i64, NUM_WEAP_ANIMS);
  return (unsigned __int16)result;
}

/*
==============
BG_LadderClimbDropTime
==============
*/
__int64 BG_LadderClimbDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 156i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderClimbRaiseTime
==============
*/
__int64 BG_LadderClimbRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 154i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LadderVaultTime
==============
*/
__int64 BG_LadderVaultTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 152i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_LeapCancelTime
==============
*/
__int64 BG_LeapCancelTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 218i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_LEAP_CANCEL, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_LeapInTime
==============
*/
__int64 BG_LeapInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 212i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_LEAP_IN, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_LeapOutTime
==============
*/
__int64 BG_LeapOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 216i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_LEAP_OUT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MapWeaponAnimIndexToMeleeIndex
==============
*/
__int64 BG_MapWeaponAnimIndexToMeleeIndex(weapAnimFiles_t animIndex)
{
  unsigned __int32 v2; 

  if ( (unsigned int)(animIndex - 262) > 0x17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17761, ASSERT_TYPE_ASSERT, "(WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST)", (const char *)&queryFormat, "WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST") )
    __debugbreak();
  v2 = (animIndex - 262) % 3;
  if ( v2 > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17764, ASSERT_TYPE_ASSERT, "(MELEE_ANIM_FIRST <= meleeIndex && meleeIndex < NUM_MELEE_ANIMS)", (const char *)&queryFormat, "MELEE_ANIM_FIRST <= meleeIndex && meleeIndex < NUM_MELEE_ANIMS") )
    __debugbreak();
  return v2;
}

/*
==============
BG_MapWeaponAnimStateToAnimIndex
==============
*/
weapAnimFiles_t BG_MapWeaponAnimStateToAnimIndex(const BgWeaponMap *weaponMap, const playerState_s *ps, int animState, bool previousMelee, const Weapon *r_weapon, bool bIsAlternate, PlayerHandIndex handIndex, const BgHandler *pmoveHandler)
{
  int AmmoInClipForWeapon; 
  int v14; 
  int v15; 
  int v16; 
  bool isMeleeVariationAltPrev; 
  int altMeleeVariation; 
  int v19; 
  int v20; 
  bool v21; 
  int v22; 
  bool v23; 
  int v24; 
  bool v25; 
  int v26; 
  bool v27; 
  int v28; 
  bool v29; 
  bool v30; 
  bool IsSprintAdditive; 
  int v32; 
  bool v33; 
  int v34; 
  bool v35; 
  int v36; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18017, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  AmmoInClipForWeapon = BG_GetAmmoInClipForWeapon(ps, r_weapon, bIsAlternate, handIndex);
  switch ( animState )
  {
    case 0:
    case 1:
      if ( AmmoInClipForWeapon )
        return 236;
      return 237;
    case 2:
      return 238;
    case 3:
      return 239;
    case 4:
      return 241;
    case 5:
      return 242;
    case 6:
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17908, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17909, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
        __debugbreak();
      v14 = 347;
      if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_FIRE_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) || !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler) )
        return 346;
      return v14;
    case 7:
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17926, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17927, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
        __debugbreak();
      v15 = 349;
      if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_LASTSHOT_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) || !BG_PlayerUsesNVGHalfADS(ps, pmoveHandler) )
        return 348;
      return v15;
    case 8:
      return 243;
    case 9:
      return 244;
    case 10:
    case 11:
    case 12:
      v16 = animState - 10;
      if ( (unsigned int)v16 > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17744, ASSERT_TYPE_ASSERT, "(BG_IsMeleeAnimState( animState ))", (const char *)&queryFormat, "BG_IsMeleeAnimState( animState )") )
        __debugbreak();
      isMeleeVariationAltPrev = BG_UsingAlternateMelee(ps);
      if ( isMeleeVariationAltPrev )
        altMeleeVariation = ps->weapCommon.altMeleeVariation;
      else
        altMeleeVariation = ps->weapCommon.meleeVariation;
      if ( previousMelee )
      {
        isMeleeVariationAltPrev = ps->weapCommon.isMeleeVariationAltPrev;
        if ( isMeleeVariationAltPrev )
          altMeleeVariation = ps->weapCommon.altMeleeVariationPrev;
        else
          altMeleeVariation = ps->weapCommon.meleeVariationPrev;
      }
      if ( altMeleeVariation >= 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17753, ASSERT_TYPE_ASSERT, "(meleeAnimPkgIndex < (4))", (const char *)&queryFormat, "meleeAnimPkgIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
        __debugbreak();
      if ( (unsigned int)altMeleeVariation > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1177, ASSERT_TYPE_ASSERT, "(0 <= meleeSetIndex && meleeSetIndex < (4))", (const char *)&queryFormat, "0 <= meleeSetIndex && meleeSetIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
        __debugbreak();
      if ( v16 >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1178, ASSERT_TYPE_ASSERT, "(meleeIndex < NUM_MELEE_ANIMS)", (const char *)&queryFormat, "meleeIndex < NUM_MELEE_ANIMS") )
        __debugbreak();
      v19 = altMeleeVariation + 4 * isMeleeVariationAltPrev;
      v20 = v19 + v16 + 2 * v19 + 262;
      if ( (unsigned int)(v19 + v16 + 2 * v19) > 0x17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1186, ASSERT_TYPE_ASSERT, "(WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST)", (const char *)&queryFormat, "WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST") )
        __debugbreak();
      return v20;
    case 13:
    case 71:
      return 325;
    case 14:
      if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x21u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_BREACH_RAISE, handIndex, pmoveHandler) )
        return 324;
      return 322;
    case 15:
      if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x21u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_BREACH_RAISE, handIndex, pmoveHandler) )
        return 324;
      return 323;
    case 16:
      return BG_ReloadMultipleAnimOverride(weaponMap, ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, 0);
    case 17:
      return BG_ReloadMultipleAnimOverride(weaponMap, ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, 1);
    case 18:
      v21 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_START);
      v22 = 292;
      if ( v21 )
        return 310;
      return v22;
    case 19:
      v23 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_START_TWO);
      v24 = 295;
      if ( v23 )
        return 313;
      return v24;
    case 20:
      v25 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_END);
      v26 = 298;
      if ( v25 )
        return 316;
      return v26;
    case 21:
      v27 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, bIsAlternate, handIndex, AmmoInClipForWeapon, WEAP_ANIM_FAST_RELOAD_END_RECHAMBER);
      v28 = 301;
      if ( v27 )
        return 319;
      return v28;
    case 22:
      return 329;
    case 23:
      return 330;
    case 24:
      return 331;
    case 25:
      return 326;
    case 26:
      return 327;
    case 27:
      return 328;
    case 28:
      return 334;
    case 29:
      return 333;
    case 30:
      return 336;
    case 31:
      if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x21u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_BREACH_RAISE, handIndex, pmoveHandler) )
        return 324;
      else
        return 335;
    case 32:
      IsSprintAdditive = BG_IsSprintAdditive(weaponMap, ps);
      v32 = 337;
      if ( IsSprintAdditive )
        return 94;
      return v32;
    case 33:
      return 338;
    case 34:
      v33 = BG_IsSprintAdditive(weaponMap, ps);
      v34 = 339;
      if ( v33 )
        return 95;
      return v34;
    case 35:
      v35 = BG_IsSprintAdditive(weaponMap, ps);
      v36 = 341;
      if ( v35 )
        return 97;
      return v36;
    case 36:
      return 342;
    case 37:
      return 343;
    case 38:
      return 344;
    case 39:
      return 240;
    case 40:
      return 345;
    case 41:
      return 400;
    case 44:
      return 398;
    case 45:
      if ( handIndex )
        return 398;
      else
        return 399;
    case 46:
      return 403;
    case 47:
      return 402;
    case 48:
      return 352;
    case 49:
      return 355;
    case 50:
      return 354;
    case 51:
      return 353;
    case 53:
      v29 = BG_UsingAlternate(ps);
      if ( BG_IsLadderWeapon(r_weapon, v29) && (v30 = BG_UsingAlternate(ps), BG_GetAmmoInClipForWeapon(ps, r_weapon, v30, WEAPON_HAND_DEFAULT)) )
        return 379;
      else
        return 378;
    case 54:
      return 375;
    case 55:
    case 67:
      return 236;
    case 56:
      return 374;
    case 57:
      return 363;
    case 58:
      return 364;
    case 59:
      return 366;
    case 60:
      return 365;
    case 61:
      return 367;
    case 62:
      return 368;
    case 63:
      return 369;
    case 64:
      return 370;
    case 65:
      return 371;
    case 66:
      return 372;
    case 68:
      return 376;
    case 69:
      return 377;
    case 70:
      return 380;
    case 72:
      return 245;
    case 73:
      return 247;
    case 74:
      return 248;
    case 75:
      return 249;
    case 76:
      return 250;
    case 77:
      return 251;
    case 78:
    case 79:
      return 252;
    case 80:
      return 254;
    case 81:
      return 255;
    case 82:
      return 258;
    case 83:
      return 322;
    case 85:
      return 433;
    default:
      Com_Printf(19, "BG_MapWeaponAnimStateToAnimIndex: Unknown weapon animation %i\n", (unsigned int)animState);
      return 236;
  }
}

/*
==============
BG_MapWeaponAnimStateToMeleeAnimIndex
==============
*/
__int64 BG_MapWeaponAnimStateToMeleeAnimIndex(const playerState_s *ps, bool previous, int animState)
{
  int v3; 
  bool isMeleeVariationAltPrev; 
  int altMeleeVariation; 
  int v8; 
  unsigned int v9; 

  v3 = animState - 10;
  if ( (unsigned int)(animState - 10) > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17744, ASSERT_TYPE_ASSERT, "(BG_IsMeleeAnimState( animState ))", (const char *)&queryFormat, "BG_IsMeleeAnimState( animState )") )
    __debugbreak();
  isMeleeVariationAltPrev = BG_UsingAlternateMelee(ps);
  if ( isMeleeVariationAltPrev )
    altMeleeVariation = ps->weapCommon.altMeleeVariation;
  else
    altMeleeVariation = ps->weapCommon.meleeVariation;
  if ( previous )
  {
    isMeleeVariationAltPrev = ps->weapCommon.isMeleeVariationAltPrev;
    if ( isMeleeVariationAltPrev )
      altMeleeVariation = ps->weapCommon.altMeleeVariationPrev;
    else
      altMeleeVariation = ps->weapCommon.meleeVariationPrev;
  }
  if ( altMeleeVariation >= 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17753, ASSERT_TYPE_ASSERT, "(meleeAnimPkgIndex < (4))", (const char *)&queryFormat, "meleeAnimPkgIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
    __debugbreak();
  if ( (unsigned int)altMeleeVariation > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1177, ASSERT_TYPE_ASSERT, "(0 <= meleeSetIndex && meleeSetIndex < (4))", (const char *)&queryFormat, "0 <= meleeSetIndex && meleeSetIndex < MAX_RANDOM_MELEE_ANIM_PACKAGES") )
    __debugbreak();
  if ( v3 >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1178, ASSERT_TYPE_ASSERT, "(meleeIndex < NUM_MELEE_ANIMS)", (const char *)&queryFormat, "meleeIndex < NUM_MELEE_ANIMS") )
    __debugbreak();
  v8 = altMeleeVariation + 4 * isMeleeVariationAltPrev;
  v9 = v8 + v3 + 2 * v8 + 262;
  if ( (unsigned int)(v8 + v3 + 2 * v8) > 0x17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1186, ASSERT_TYPE_ASSERT, "(WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST)", (const char *)&queryFormat, "WEAP_ANIM_MELEE_FIRST <= animIndex && animIndex < WEAP_ANIM_ALT_MELEE_LAST") )
    __debugbreak();
  return v9;
}

/*
==============
BG_MaxAmmo
==============
*/
int BG_MaxAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  weapType_t WeaponType; 
  const WeaponDef *v10; 
  int result; 
  unsigned int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v18; 
  __int64 v19; 
  bool v20; 
  bool v21; 
  WeaponAttachment **v25; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  if ( BG_WeaponTypeIsOffhand(WeaponType) && hasIncreasedOffhandAmmoPerk )
  {
    v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8432, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v10->iPerkMaxAmmo;
  }
  else
  {
    __asm
    {
      vmovaps [rsp+1C8h+var_38], xmm6
      vmovaps [rsp+1C8h+var_48], xmm7
      vmovaps [rsp+1C8h+var_58], xmm8
    }
    _ER15 = BG_WeaponOverrides_GetMaxAmmo(r_weapon);
    v13 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vmovaps xmm6, xmm7
      vxorps  xmm8, xmm8, xmm8
    }
    if ( WeaponAttachments_Internal )
    {
      v18 = attachments;
      v19 = WeaponAttachments_Internal;
      do
      {
        v20 = *v18 == NULL;
        if ( !*v18 )
        {
          v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8455, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
          v20 = !v21;
          if ( v21 )
            __debugbreak();
        }
        _RAX = *v18;
        __asm
        {
          vmovss  xmm0, dword ptr [rax+260h]
          vucomiss xmm0, xmm8
        }
        if ( !v20 )
        {
          __asm
          {
            vaddss  xmm0, xmm0, xmm6
            vsubss  xmm6, xmm0, xmm7
          }
        }
        ++v18;
        --v19;
      }
      while ( v19 );
    }
    if ( WeaponAttachments_Internal )
    {
      v25 = attachments;
      while ( 1 )
      {
        if ( !*v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8464, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammunition = (*v25)->ammunition;
        if ( ammunition )
          break;
        ++v13;
        ++v25;
        if ( v13 >= WeaponAttachments_Internal )
          goto LABEL_24;
      }
      _ER15 = ammunition->maxAmmo;
    }
LABEL_24:
    __asm
    {
      vmaxss  xmm3, xmm6, xmm8
      vmovaps xmm8, [rsp+1C8h+var_58]
      vmovaps xmm6, [rsp+1C8h+var_38]
      vsubss  xmm0, xmm7, xmm3
      vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcvtss2sd xmm1, xmm0, xmm0
      vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
      vmovd   xmm0, r15d
      vblendvps xmm1, xmm3, xmm7, xmm2
      vmovaps xmm7, [rsp+1C8h+var_48]
      vcvtdq2ps xmm0, xmm0
      vmulss  xmm0, xmm0, xmm1
      vcvttss2si eax, xmm0
    }
  }
  return result;
}

/*
==============
BG_MeleeImpactRumble
==============
*/
RumbleInfo *BG_MeleeImpactRumble(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  RumbleInfo *meleeImpactRumble; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttRumbles *rumbles; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  meleeImpactRumble = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->meleeImpactRumble;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return meleeImpactRumble;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16400, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    rumbles = (*i)->rumbles;
    if ( rumbles )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return meleeImpactRumble;
  }
  return rumbles->meleeImpactRumble;
}

/*
==============
BG_MoveCycleJogTime
==============
*/
__int64 BG_MoveCycleJogTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 234i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_JOG, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11745, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleJogTime(): Additive Jog Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveCycleSprintTime
==============
*/
__int64 BG_MoveCycleSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 236i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_SPRINT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11766, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleSprintTime(): Additive Sprint Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveCycleSuperSprintTime
==============
*/
__int64 BG_MoveCycleSuperSprintTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 238i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_SUPERSPRINT, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11787, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleSuperSprintTime(): Additive SuperSprint Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveCycleWalkTime
==============
*/
__int64 BG_MoveCycleWalkTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  int WeaponFieldTimeWithDependentAnimation; 
  int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 232i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_CYCLE_START, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    WeaponFieldTimeWithDependentAnimation = AnimTime;
  if ( WeaponFieldTimeWithDependentAnimation <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11724, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "BG_MoveCycleWalkTime(): Additive Walk Time must be greater than zero.") )
    __debugbreak();
  return (unsigned int)WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MoveTransitionTime
==============
*/
__int64 BG_MoveTransitionTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, movementTransition_t transitionType)
{
  __int64 v9; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  weapAnimFiles_t v11; 
  int AnimTime; 
  __int64 dependentAnimType; 
  __int64 dependentAnimTypea; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11845, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  switch ( transitionType )
  {
    case MOVE_TRANS_DOWNFROM_SUPERSPRINT:
      v9 = 250i64;
      break;
    case MOVE_TRANS_DOWNFROM_SPRINT:
      v9 = 248i64;
      break;
    case MOVE_TRANS_TO_WALK:
      goto LABEL_12;
    case MOVE_TRANS_TO_JOG:
      v9 = 242i64;
      break;
    case MOVE_TRANS_TO_SPRINT:
      v9 = 244i64;
      break;
    case MOVE_TRANS_TO_SUPERSPRINT:
      v9 = 246i64;
      break;
    default:
      LODWORD(dependentAnimType) = transitionType;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11813, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown movementTransition_t encountered: %i", dependentAnimType) )
        __debugbreak();
LABEL_12:
      v9 = 240i64;
      break;
  }
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, v9, NUM_WEAP_ANIMS);
  switch ( transitionType )
  {
    case MOVE_TRANS_DOWNFROM_SUPERSPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SUPERSPRINT_TO_WALK;
      break;
    case MOVE_TRANS_DOWNFROM_SPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SPRINT_TO_WALK;
      break;
    case MOVE_TRANS_TO_WALK:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_JOG_TO_WALK;
      break;
    case MOVE_TRANS_TO_JOG:
      goto LABEL_21;
    case MOVE_TRANS_TO_SPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_WALK_TO_SPRINT;
      break;
    case MOVE_TRANS_TO_SUPERSPRINT:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_WALK_TO_SUPERSPRINT;
      break;
    default:
      LODWORD(dependentAnimTypea) = transitionType;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11837, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown movementTransition_t encountered: %i", dependentAnimTypea) )
        __debugbreak();
LABEL_21:
      v11 = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_START;
      break;
  }
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, v11, isAlternate, isDualWielding, NULL);
  if ( AnimTime > 0 )
    return (unsigned int)AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_MultipleReloadInterruptTime
==============
*/
int BG_MultipleReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, weapAnimFiles_t animIndex)
{
  int result; 
  char *WeaponName; 
  char output[1024]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10303, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  switch ( animIndex )
  {
    case WEAP_ANIM_ALT_MELEE_LAST:
    case WEAP_ANIM_RELOAD_ADS:
    case WEAP_ANIM_RELOAD_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 258i64);
      break;
    case WEAP_ANIM_RELOAD_EMPTY:
    case WEAP_ANIM_RELOAD_EMPTY_ADS:
    case WEAP_ANIM_RELOAD_EMPTY_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 260i64);
      break;
    case WEAP_ANIM_FAST_RELOAD_FIRST:
    case WEAP_ANIM_FAST_RELOAD_ADS:
    case WEAP_ANIM_FAST_RELOAD_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 288i64);
      break;
    case WEAP_ANIM_FAST_RELOAD_EMPTY:
    case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS:
    case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS_NVG:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 290i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FIRST:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 272i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_2:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 274i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_3:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 276i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_4:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 278i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_5:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 280i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_6:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 282i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_7:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 284i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_8:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 286i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_FIRST:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 302i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_2:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 304i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_3:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 306i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_4:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 308i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_5:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 310i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_6:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 312i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_7:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 314i64);
      break;
    case WEAP_ANIM_RELOAD_MULTIPLE_FAST_8:
      result = BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, 316i64);
      break;
    default:
      WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F5A5C0, 548i64, (unsigned int)animIndex, WeaponName);
      result = 0;
      break;
  }
  return result;
}

/*
==============
BG_NoADSWhenMagIsEmpty
==============
*/
_BOOL8 BG_NoADSWhenMagIsEmpty(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool noAdsWhenMagEmpty; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  noAdsWhenMagEmpty = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->noAdsWhenMagEmpty;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return noAdsWhenMagEmpty;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7491, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return noAdsWhenMagEmpty;
  }
  return sight->noAdsWhenMagEmpty;
}

/*
==============
BG_NoPartialReload
==============
*/
_BOOL8 BG_NoPartialReload(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bNoPartialReload; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bNoPartialReload = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bNoPartialReload;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bNoPartialReload;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7924, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    reload = (*i)->reload;
    if ( reload )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bNoPartialReload;
  }
  return reload->noPartialReload;
}

/*
==============
BG_OffhandIsUnderbarrelWeapon
==============
*/
int BG_OffhandIsUnderbarrelWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, unsigned __int64 whichOffhandButton)
{
  __int16 v3; 
  const dvar_t *v6; 
  const dvar_t *v7; 

  v3 = whichOffhandButton;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1114, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1115, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) )
    return 0;
  v6 = DVARBOOL_bg_underbarrelWeaponEnabled;
  if ( !DVARBOOL_bg_underbarrelWeaponEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_underbarrelWeaponEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( !v6->current.enabled )
    return 0;
  v7 = DCONST_DVARBOOL_bg_offhandUnderbarrelEnabled;
  if ( !DCONST_DVARBOOL_bg_offhandUnderbarrelEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_offhandUnderbarrelEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( v7->current.enabled && (v3 & 0x1000) != 0 )
    return BG_AnyUnderbarrelWeaponEquipped(weaponMap, ps);
  else
    return 0;
}

/*
==============
BG_OffhandUnderbarrelInitAllowed
==============
*/
_BOOL8 BG_OffhandUnderbarrelInitAllowed(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1139, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x10u) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0xFu) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 6u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xAu) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xFu) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xEu) )
    return 0i64;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2296, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagValues::ms_mpValue == ACTIVE && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, ACTIVE, 0x22u) || BG_IsTurretActive(ps) )
    return 0i64;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2184, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&ps->eFlags, ACTIVE, 0xBu) && ps->vehicleState.entity == 2047;
}

/*
==============
BG_OneHandedViewModelAnimsValid
==============
*/
_BOOL8 BG_OneHandedViewModelAnimsValid(const WeaponDef *weapDef)
{
  WeaponAnimPackage *szXAnimsRightHanded; 

  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2738, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  szXAnimsRightHanded = weapDef->szXAnimsRightHanded;
  return szXAnimsRightHanded && *((_QWORD *)szXAnimsRightHanded->anims + 236);
}

/*
==============
BG_PackClientWeaponFireEventParm
==============
*/
__int64 BG_PackClientWeaponFireEventParm(const tmat33_t<vec3_t> *fireAxis)
{
  int v10; 
  __int64 result; 
  vec3_t angles; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  AxisToAngles(fireAxis, &angles);
  __asm
  {
    vmovss  xmm5, cs:__real@43360b61
    vmulss  xmm1, xmm5, dword ptr [rsp+58h+angles]
    vaddss  xmm2, xmm1, cs:__real@3f000000
    vmulss  xmm1, xmm5, dword ptr [rsp+58h+angles+4]
    vxorps  xmm6, xmm6, xmm6
    vroundss xmm3, xmm6, xmm2, 1
    vcvttss2si eax, xmm3
    vaddss  xmm3, xmm1, cs:__real@3f000000
  }
  v10 = (unsigned __int16)_EAX;
  __asm
  {
    vroundss xmm1, xmm6, xmm3, 1
    vcvttss2si eax, xmm1
  }
  result = v10 | ((unsigned __int16)_EAX << 16);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  return result;
}

/*
==============
BG_PickUpIcon
==============
*/
GfxImage *BG_PickUpIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  GfxImage *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->pickupIcon;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16199, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
    {
      result = ui->pickupIcon;
      if ( result )
        break;
    }
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->pickupIcon;
  }
  return result;
}

/*
==============
BG_PlayAltGesturesForOffhandWeapons
==============
*/
__int64 BG_PlayAltGesturesForOffhandWeapons(const Weapon *r_weapon)
{
  const WeaponDef *v1; 

  v1 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v1 )
    return v1->playAltGesturesForOffhandWeapons;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7449, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0x108D];
}

/*
==============
BG_PlayerDualWieldingCompatibleWeapon
==============
*/
char BG_PlayerDualWieldingCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v9; 
  const Weapon *Weapon; 
  const Weapon *v13; 
  __int64 v18; 
  __int64 v19; 
  AmmoStore v20; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4965, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4966, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RAX = BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  v9 = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.weaponIdx], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.attachmentVariationIndices+5], ymm1
  }
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v9 >= 0xF )
    {
      LODWORD(v19) = 15;
      LODWORD(v18) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v9]);
    v13 = Weapon;
    if ( Weapon->weaponIdx )
    {
      if ( !isAlternate || BG_HasUnderbarrelAmmo(Weapon) )
      {
        _RAX = BG_AmmoStoreForWeapon(&v20, v13, isAlternate);
        __asm
        {
          vmovups ymm0, ymmword ptr [rax]
          vmovups ymmword ptr [rsp+158h+result.weapon.weaponIdx], ymm0
          vmovups ymm1, ymmword ptr [rax+20h]
          vmovups ymmword ptr [rsp+158h+result.weapon.attachmentVariationIndices+5], ymm1
        }
        if ( BG_IsAmmoCompatible(&result, &r_ammo2) )
        {
          if ( BG_PlayerDualWieldingWeapon(weaponMap, ps, v13) )
            break;
        }
      }
    }
    if ( (int)++v9 >= 15 )
      return 0;
  }
  return 1;
}

/*
==============
BG_PlayerHasCompatibleWeapon
==============
*/
char BG_PlayerHasCompatibleWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v9; 
  const Weapon *Weapon; 
  const Weapon *v13; 
  __int64 v18; 
  __int64 v19; 
  AmmoStore v20; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4937, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4938, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RAX = BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  v9 = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.weaponIdx], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+158h+r_ammo2.weapon.attachmentVariationIndices+5], ymm1
  }
  while ( 1 )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( v9 >= 0xF )
    {
      LODWORD(v19) = 15;
      LODWORD(v18) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[v9]);
    v13 = Weapon;
    if ( Weapon->weaponIdx )
    {
      if ( !isAlternate || BG_HasUnderbarrelAmmo(Weapon) )
      {
        _RAX = BG_AmmoStoreForWeapon(&v20, v13, isAlternate);
        __asm
        {
          vmovups ymm0, ymmword ptr [rax]
          vmovups ymmword ptr [rsp+158h+result.weapon.weaponIdx], ymm0
          vmovups ymm1, ymmword ptr [rax+20h]
          vmovups ymmword ptr [rsp+158h+result.weapon.attachmentVariationIndices+5], ymm1
        }
        if ( BG_IsAmmoCompatible(&result, &r_ammo2) )
          break;
      }
    }
    if ( (int)++v9 >= 15 )
      return 0;
  }
  return 1;
}

/*
==============
BG_PlayerLastWeaponHand
==============
*/
PlayerHandIndex BG_PlayerLastWeaponHand(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6125, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6126, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  return BG_PlayerLastWeaponHandForWeapon(weaponMap, ps, CurrentWeaponForPlayer);
}

/*
==============
BG_PlayerLastWeaponHandForViewWeapon
==============
*/
PlayerHandIndex BG_PlayerLastWeaponHandForViewWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelWeapon; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6115, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6116, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  return BG_PlayerLastWeaponHandForWeapon(weaponMap, ps, ViewmodelWeapon);
}

/*
==============
BG_PlayerLastWeaponHandForWeapon
==============
*/
_BOOL8 BG_PlayerLastWeaponHandForWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6136, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6137, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return BG_PlayerDualWieldingWeapon(weaponMap, ps, r_weapon) || BG_HasLadderHand(ps);
}

/*
==============
BG_PlayerOffhandGetSlotName
==============
*/
__int64 BG_PlayerOffhandGetSlotName(const OffhandSlot slot)
{
  int v3; 
  int v4; 
  int v5[6]; 

  v5[0] = scr_const.none;
  v5[1] = scr_const.primaryoffhand;
  v5[2] = scr_const.secondaryoffhand;
  v5[3] = scr_const.specialoffhand;
  v5[4] = scr_const.scriptoffhand;
  v5[5] = scr_const.tauntoffhand;
  if ( (unsigned __int8)slot >= OFFHAND_SLOT_COUNT )
  {
    v4 = 6;
    v3 = (unsigned __int8)slot;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4767, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( OFFHAND_SLOT_COUNT )", "slot doesn't index OFFHAND_SLOT_COUNT\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (unsigned int)v5[(unsigned __int8)slot];
}

/*
==============
BG_PlayerUsesNVGHalfADS
==============
*/
char BG_PlayerUsesNVGHalfADS(const playerState_s *ps, const BgHandler *pmoveHandler)
{
  const BgWeaponMap *v4; 
  const Weapon *ViewmodelWeapon; 
  bool v6; 
  int v7; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17772, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17773, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2222, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 7u) && BG_ViewModelAnimExists(ps, WEAP_ANIM_ADS_UP_NVG, WEAPON_HAND_DEFAULT, pmoveHandler) )
  {
    v4 = pmoveHandler->GetWeaponMap(pmoveHandler);
    ViewmodelWeapon = BG_GetViewmodelWeapon(v4, ps);
    v6 = BG_UsingAlternate(ps);
    v7 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(ViewmodelWeapon, v6, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( !WeaponAttachments_Internal )
      return 1;
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17794, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      sight = (*i)->sight;
      if ( sight )
      {
        if ( sight->blockNVGADS )
          break;
      }
      if ( ++v7 >= WeaponAttachments_Internal )
        return 1;
    }
  }
  return 0;
}

/*
==============
BG_PlayerWeaponCountWeaponsBySlot
==============
*/
__int64 BG_PlayerWeaponCountWeaponsBySlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  unsigned int v6; 
  unsigned int i; 
  const Weapon *Weapon; 
  const WeaponDef *v9; 
  int EquippedWeaponIndex; 
  __int64 p_slot; 
  weapInventoryType_t inventoryType; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4799, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4800, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = 0;
  for ( i = 0; i < 0xF; ++i )
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon((BgWeaponMap *)weaponMap, ps->weaponsEquipped[i]);
    if ( Weapon->weaponIdx )
    {
      v9 = BG_WeaponDefAtIndex(Weapon->weaponIdx);
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1089, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1090, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( Weapon->weaponIdx && (EquippedWeaponIndex = BG_GetEquippedWeaponIndex(weaponMap, ps, Weapon), EquippedWeaponIndex >= 0) )
        p_slot = (__int64)&ps->weapEquippedData[EquippedWeaponIndex].slot;
      else
        p_slot = 12i64;
      inventoryType = v9->inventoryType;
      if ( (inventoryType == WEAPINVENTORY_PRIMARY || inventoryType == WEAPINVENTORY_MODEL_ONLY) && *(_DWORD *)p_slot == slot )
        ++v6;
    }
  }
  return v6;
}

/*
==============
BG_PlayerWeaponGetCycleSlot
==============
*/
__int64 BG_PlayerWeaponGetCycleSlot(WeaponSlot currentSlot, int cycleSlot)
{
  WeaponSlot outNeededSlot; 

  if ( BG_GameInterface_PlayerWeaponGetCycleSlot(currentSlot, cycleSlot, &outNeededSlot) )
    return (unsigned int)outNeededSlot;
  if ( cycleSlot )
    return (unsigned int)(currentSlot == WEAPON_SLOT_PRIMARY) + 1;
  return (unsigned int)currentSlot;
}

/*
==============
BG_PlayerWeaponGetEquippedSlot
==============
*/
const PlayerEquippedWeaponState *BG_PlayerWeaponGetEquippedSlot(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon)
{
  const PlayerEquippedWeaponState *result; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4904, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4905, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  result = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon);
  if ( result )
    return (const PlayerEquippedWeaponState *)(unsigned int)result->slot;
  return result;
}

/*
==============
BG_PlayerWeaponGetSlot
==============
*/
__int64 BG_PlayerWeaponGetSlot(const Weapon *r_weapon)
{
  const WeaponDef *v1; 
  weapInventoryType_t inventoryType; 

  v1 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4885, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  inventoryType = v1->inventoryType;
  if ( inventoryType == WEAPINVENTORY_PRIMARY || inventoryType == WEAPINVENTORY_MODEL_ONLY )
    return (unsigned int)v1->slot;
  else
    return 0i64;
}

/*
==============
BG_PlayerWeaponGetSlotName
==============
*/
const char *BG_PlayerWeaponGetSlotName(const WeaponSlot slot)
{
  __int64 v1; 
  int v4; 

  v1 = slot;
  if ( (unsigned int)slot >= WEAPON_SLOT_NUM )
  {
    v4 = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4748, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( WEAPON_SLOT_NUM )", "slot doesn't index WEAPON_SLOT_NUM\n\t%i not in [0, %i)", slot, v4) )
      __debugbreak();
  }
  return s_weaponSlotNames[v1];
}

/*
==============
BG_PlayerWeaponIsSlotFull
==============
*/
bool BG_PlayerWeaponIsSlotFull(const BgWeaponMap *weaponMap, const playerState_s *ps, const WeaponSlot slot)
{
  int v6; 
  unsigned int v7; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4922, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4923, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v6 = 0;
  if ( slot == WEAPON_SLOT_PRIMARY )
  {
    v7 = 2;
  }
  else if ( slot == WEAPON_SLOT_HEAVY || slot == WEAPON_SLOT_MELEE )
  {
    v7 = 1;
  }
  else
  {
    v7 = 1;
    if ( slot != WEAPON_SLOT_EXECUTION )
    {
      if ( slot == WEAPON_SLOT_ACCESSORY )
        v6 = 1;
      v7 = v6;
    }
  }
  return BG_PlayerWeaponCountWeaponsBySlot(weaponMap, ps, slot) >= v7;
}

/*
==============
BG_PreFireSound
==============
*/
const SndAliasList *BG_PreFireSound(const Weapon *r_weapon, bool isAlternate, bool isPlayer)
{
  _BOOL8 v3; 
  const WeaponSFXPackage *SfxPackage; 

  v3 = isPlayer;
  SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
  return BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 8 * v3 + 80);
}

/*
==============
BG_PreFireTime
==============
*/
__int64 BG_PreFireTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 230i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_PredictionGetClientTrajectoryBlendOutTime
==============
*/
__int64 BG_PredictionGetClientTrajectoryBlendOutTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  __int64 result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( !WeaponPrimaryAttachment )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  projectile = WeaponPrimaryAttachment->projectile;
  if ( !projectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  if ( !projectile->isPredictedProjectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  result = (unsigned int)projectile->clientTrajectoryBlendOutTime;
  if ( !(_DWORD)result )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->clientTrajectoryBlendOutTime;
  return result;
}

/*
==============
BG_PredictionGetServerTrajectoryBlendInTime
==============
*/
__int64 BG_PredictionGetServerTrajectoryBlendInTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttProjectile *projectile; 
  __int64 result; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( !WeaponPrimaryAttachment )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  projectile = WeaponPrimaryAttachment->projectile;
  if ( !projectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  if ( !projectile->isPredictedProjectile )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  result = (unsigned int)projectile->serverTrajectoryBlendInTime;
  if ( !(_DWORD)result )
    return (unsigned int)BG_WeaponDefAtIndex(r_weapon->weaponIdx)->serverTrajectoryBlendInTime;
  return result;
}

/*
==============
BG_ProceduralGunMotionDisabled
==============
*/
bool BG_ProceduralGunMotionDisabled(const playerState_s *ps)
{
  const dvar_t *v1; 
  bool result; 

  v1 = DCONST_DVARBOOL_bg_disableProceduralGunMotion;
  if ( !DCONST_DVARBOOL_bg_disableProceduralGunMotion && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_disableProceduralGunMotion") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
    return 1;
  result = BG_Skydive_IsSkydiving(ps);
  if ( result )
    return 1;
  return result;
}

/*
==============
BG_ProjBeaconEffect
==============
*/
FxCombinedDef BG_ProjBeaconEffect(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)v4->projBeaconEffect.particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17621, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (FxCombinedDef)v4->projBeaconEffect.particleSystemDef;
  }
  return (FxCombinedDef)projectile->projBeaconEffect.particleSystemDef;
}

/*
==============
BG_ProjBodyEffect
==============
*/
FxCombinedDef BG_ProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projBodyEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17574, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projBodyEffect.particleSystemDef;
}

/*
==============
BG_ProjDisabledTimeoutEffect
==============
*/
_BOOL8 BG_ProjDisabledTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableFxOnTimeout;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17352, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->disableFxOnTimeout;
  }
  return projectile->disableFxOnTimeout;
}

/*
==============
BG_ProjDudEffect
==============
*/
FxCombinedDef BG_ProjDudEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projDudEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17263, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projDudEffect.particleSystemDef;
}

/*
==============
BG_ProjDudSound
==============
*/
SndAliasList *BG_ProjDudSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17310, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projDudSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 640i64);
  }
}

/*
==============
BG_ProjExplosionEffect
==============
*/
FxCombinedDef BG_ProjExplosionEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosionEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17149, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projExplosionEffect.particleSystemDef;
}

/*
==============
BG_ProjExplosionEffectForceNormalUp
==============
*/
_BOOL8 BG_ProjExplosionEffectForceNormalUp(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool projExplosionEffectForceNormalUp; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projExplosionEffectForceNormalUp = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosionEffectForceNormalUp;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return projExplosionEffectForceNormalUp;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17175, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return projExplosionEffectForceNormalUp;
  }
  return projectile->projExplosionEffectForceNormalUp;
}

/*
==============
BG_ProjExplosionEffectInheritParentDirection
==============
*/
_BOOL8 BG_ProjExplosionEffectInheritParentDirection(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosionEffectInheritParentDirection;
}

/*
==============
BG_ProjExplosionReflectionClass
==============
*/
WeaponSFXPackage *BG_ProjExplosionReflectionClass(const Weapon *r_weapon, bool isAlternate)
{
  WeaponSFXPackage *result; 
  unsigned int projExplosionReflClass; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  result = BG_GetSfxPackage(r_weapon, isAlternate);
  if ( result )
  {
    projExplosionReflClass = result->projExplosionReflClass;
    v6 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17237, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        projectile = (*i)->projectile;
        if ( projectile )
          break;
        if ( ++v6 >= WeaponAttachments_Internal )
          return (WeaponSFXPackage *)projExplosionReflClass;
      }
      return (WeaponSFXPackage *)projectile->projExplosionReflClass;
    }
    return (WeaponSFXPackage *)projExplosionReflClass;
  }
  return result;
}

/*
==============
BG_ProjExplosionSound
==============
*/
SndAliasList *BG_ProjExplosionSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17205, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projExplosionSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 632i64);
  }
}

/*
==============
BG_ProjExplosionType
==============
*/
__int64 BG_ProjExplosionType(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  weapProjExposion_t projExplosion; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projExplosion = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projExplosion;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)projExplosion;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17123, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (unsigned int)projExplosion;
  }
  return (unsigned int)projectile->projExplosionType;
}

/*
==============
BG_ProjIgnitionDelay
==============
*/
__int64 BG_ProjIgnitionDelay(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int projIgnitionDelay; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projIgnitionDelay = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projIgnitionDelay;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return projIgnitionDelay;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17646, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return projIgnitionDelay;
  }
  return (unsigned int)projectile->projIgnitionDelay;
}

/*
==============
BG_ProjIgnitionEffect
==============
*/
FxCombinedDef BG_ProjIgnitionEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projIgnitionEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17672, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projIgnitionEffect.particleSystemDef;
}

/*
==============
BG_ProjIgnitionSound
==============
*/
SndAliasList *BG_ProjIgnitionSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17694, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projIgnitionSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 656i64);
  }
}

/*
==============
BG_ProjImpactExplode
==============
*/
_BOOL8 BG_ProjImpactExplode(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bProjImpactExplode; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bProjImpactExplode = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bProjImpactExplode;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bProjImpactExplode;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17399, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bProjImpactExplode;
  }
  return projectile->projImpactExplode;
}

/*
==============
BG_ProjTimeoutEffect
==============
*/
FxCombinedDef BG_ProjTimeoutEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projTimeoutEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17288, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projTimeoutEffect.particleSystemDef;
}

/*
==============
BG_ProjTimeoutSound
==============
*/
SndAliasList *BG_ProjTimeoutSound(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v6; 
  AttProjectile *projectile; 
  const WeaponSFXPackage *SfxPackage; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v6 = attachments;
    while ( 1 )
    {
      if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17331, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v6)->projectile;
      if ( projectile )
        return SND_FindAlias(projectile->projTimeoutSound.name);
      ++v2;
      ++v6;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate);
    return (SndAliasList *)BG_GetWeaponSfxPackageSoundWithFallback(SfxPackage, 648i64);
  }
}

/*
==============
BG_ProjTrailEffect
==============
*/
FxCombinedDef BG_ProjTrailEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projTrailEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17599, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->projTrailEffect.particleSystemDef;
}

/*
==============
BG_ProjTrajectoryEvents
==============
*/
bool BG_ProjTrajectoryEvents(const Weapon *r_weapon, bool isAlternate)
{
  bool result; 

  result = Com_GameMode_SupportsFeature(WEAPON_OFFHAND_HOLD_PRIMED);
  if ( result )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bProjTrajectoryEvents;
  return result;
}

/*
==============
BG_ProjWhizByEnabled
==============
*/
bool BG_ProjWhizByEnabled(const Weapon *r_weapon, bool isAlternate)
{
  bool result; 

  result = Com_GameMode_SupportsFeature(WEAPON_OFFHAND_HOLD_PRIMED);
  if ( result )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bProjWhizByEnabled;
  return result;
}

/*
==============
BG_ProjectileActivateDist
==============
*/
__int64 BG_ProjectileActivateDist(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iProjectileActivateDist; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iProjectileActivateDist = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iProjectileActivateDist;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iProjectileActivateDist;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17073, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iProjectileActivateDist;
  }
  return (unsigned int)projectile->projectileActivateDist;
}

/*
==============
BG_ProjectileModel
==============
*/
XModel *BG_ProjectileModel(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  XModel *projectileModel; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  projectileModel = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->projectileModel;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return projectileModel;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17098, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return projectileModel;
  }
  return projectile->projectileModel;
}

/*
==============
BG_QuickDropTime
==============
*/
__int64 BG_QuickDropTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 142i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_QuickRaiseTime
==============
*/
__int64 BG_QuickRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 144i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RaiseTime
==============
*/
__int64 BG_RaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 134i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberBoltTime
==============
*/
__int64 BG_RechamberBoltTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 14i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberTime
==============
*/
__int64 BG_RechamberTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 10i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberTimeOneHanded
==============
*/
__int64 BG_RechamberTimeOneHanded(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 12i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_RechamberWhileADS
==============
*/
_BOOL8 BG_RechamberWhileADS(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool bRechamberWhileAds; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  bRechamberWhileAds = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bRechamberWhileAds;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return bRechamberWhileAds;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7467, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return bRechamberWhileAds;
  }
  return sight->rechamberWhileAds;
}

/*
==============
BG_ReloadAddTime
==============
*/
__int64 BG_ReloadAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  bool v11; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10678, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  *hasFastReloadOverride = 0;
  v11 = BG_UseFastReload(ps, r_weapon, isAlternate) || BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 80, NUM_WEAP_ANIMS);
  if ( !v11 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 82, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadAmmoAdd
==============
*/
__int64 BG_ReloadAmmoAdd(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iReloadAmmoAdd; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iReloadAmmoAdd = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iReloadAmmoAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iReloadAmmoAdd;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8627, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammunition = (*i)->ammunition;
    if ( ammunition )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iReloadAmmoAdd;
  }
  return (unsigned int)ammunition->reloadAmmoAdd;
}

/*
==============
BG_ReloadDisabled
==============
*/
_BOOL8 BG_ReloadDisabled(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  bool reloadDisabled; 
  int v6; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7944, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  reloadDisabled = v4->reloadDisabled;
  v6 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return reloadDisabled;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7949, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    reload = (*i)->reload;
    if ( reload )
      break;
    if ( ++v6 >= WeaponAttachments_Internal )
      return reloadDisabled;
  }
  return reload->reloadDisabled;
}

/*
==============
BG_ReloadEmptyAddTime
==============
*/
__int64 BG_ReloadEmptyAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  bool v10; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10705, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  *hasFastReloadOverride = 0;
  v10 = BG_UseFastReload(ps, r_weapon, isAlternate) || BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 88i64, NUM_WEAP_ANIMS);
  if ( !v10 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 90i64, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadEmptyInterruptTime
==============
*/
int BG_ReloadEmptyInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10494, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
  offset = 260i64;
  if ( IsUsingFastReloadStateTimer )
    offset = 290i64;
  return BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadEmptyTime
==============
*/
__int64 BG_ReloadEmptyTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, bool *hasFastReloadOverride)
{
  bool v9; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  v9 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, 0, WEAP_ANIM_FAST_RELOAD_EMPTY);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 76i64, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = 0;
  if ( !v9 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 78i64, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadEndInterruptTime
==============
*/
int BG_ReloadEndInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 v6; 
  unsigned int v10; 
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 
  __int64 v13; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10618, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = (unsigned int)ps->weapState[v6].weapHandFlags >> 2;
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding);
  if ( (v10 & 1) != 0 )
  {
    offset = 266i64;
    v13 = 296i64;
  }
  else
  {
    offset = 264i64;
    v13 = 294i64;
  }
  if ( IsUsingFastReloadStateTimer )
    offset = v13;
  return BG_InterruptTimeCommon(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadEndRechamberInterruptTime
==============
*/
int BG_ReloadEndRechamberInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 v6; 
  unsigned int v10; 
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 
  __int64 v13; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10638, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = (unsigned int)ps->weapState[v6].weapHandFlags >> 2;
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding);
  if ( (v10 & 1) != 0 )
  {
    offset = 270i64;
    v13 = 300i64;
  }
  else
  {
    offset = 268i64;
    v13 = 298i64;
  }
  if ( IsUsingFastReloadStateTimer )
    offset = v13;
  return BG_InterruptTimeCommon(ps, pmoveHandler, (const PlayerHandIndex)v6, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadEndRechamberTime
==============
*/
__int64 BG_ReloadEndRechamberTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, int *outShellEjectTime, bool *hasFastReloadOverride)
{
  unsigned __int64 v11; 
  bool v12; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned __int16 v14; 
  unsigned int v15; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  v11 = ((unsigned __int64)(unsigned int)ps->weapState[hand].weapHandFlags >> 2) & 1;
  v12 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_END_RECHAMBER);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 112, NUM_WEAP_ANIMS);
  *outShellEjectTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 114, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = 0;
  if ( !v12 )
    return WeaponFieldTimeWithDependentAnimation;
  v14 = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 124, NUM_WEAP_ANIMS);
  v15 = v14;
  if ( !v14 )
    return WeaponFieldTimeWithDependentAnimation;
  *outShellEjectTime = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * (unsigned int)v11 + 126, NUM_WEAP_ANIMS);
  result = v15;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadEndTime
==============
*/
__int64 BG_ReloadEndTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  unsigned __int64 weapHandFlags; 
  bool v11; 
  __int64 v12; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  weapHandFlags = (unsigned int)ps->weapState[hand].weapHandFlags;
  v11 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_END);
  v12 = (weapHandFlags >> 2) & 1;
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 2i64 * (unsigned int)v12 + 108, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = 0;
  if ( !v11 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 2i64 * (unsigned int)v12 + 120, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadInterruptTime
==============
*/
int BG_ReloadInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10291, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
  offset = 258i64;
  if ( IsUsingFastReloadStateTimer )
    offset = 288i64;
  return BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadMultipleAnimOverride
==============
*/
__int64 BG_ReloadMultipleAnimOverride(const BgWeaponMap *weaponMap, const playerState_s *ps, const BgHandler *pmoveHandler, const Weapon *r_weapon, bool isAlternate, PlayerHandIndex handIndex, int empty)
{
  const Weapon *CurrentWeaponForPlayer; 
  int ClipSize; 
  int AmmoNotInClip; 
  __int64 v15; 
  int v16; 
  int v17; 
  ReloadType ReloadType; 
  int ammoInClipBeforeReload; 
  int v27; 
  bool v28; 
  char v29; 
  const PlayerWeaponAnimArrays *v30; 
  bool v32; 
  unsigned int v33; 
  __int64 ammoInClip; 
  __int64 ammoInClipa; 
  __int64 reloadAnimFile; 
  __int64 v37; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11015, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11016, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  ClipSize = BG_GetClipSize(ps, CurrentWeaponForPlayer, isAlternate);
  AmmoNotInClip = BG_GetAmmoNotInClip(ps, CurrentWeaponForPlayer, isAlternate);
  v15 = handIndex;
  v37 = v15 * 80;
  v16 = ClipSize - ps->weapState[v15].ammoInClipBeforeReload;
  if ( v16 > AmmoNotInClip )
    v16 = AmmoNotInClip;
  v17 = v16 - 1;
  ReloadType = BG_GetReloadType(r_weapon, isAlternate);
  if ( ReloadType == RELOAD_TYPE_MULTIPLE_PERCENTAGE )
  {
    if ( empty )
    {
      ammoInClipBeforeReload = ps->weapState[v15].ammoInClipBeforeReload;
      goto LABEL_44;
    }
    BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, [rsp+78h+arg_0]
      vmulss  xmm0, xmm0, dword ptr [rax+888h]
      vaddss  xmm2, xmm0, cs:__real@3f000000
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm4, xmm0, xmm2, 1
      vcvttss2si ecx, xmm4
    }
    v17 = (_ECX + v16 - 1) / _ECX - 1;
    ReloadType = RELOAD_TYPE_MULTIPLE_PERCENTAGE;
  }
  v27 = 0;
  if ( v17 > 0 )
    v27 = v17;
  if ( (unsigned int)(ReloadType - 2) > 1 )
    goto LABEL_43;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10993, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( v27 >= 8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10995, ASSERT_TYPE_ASSERT, "(ammoNeeded < 8)", (const char *)&queryFormat, "ammoNeeded < MAX_RELOAD_MULTIPLE_ANIMS") )
    __debugbreak();
  v28 = BG_PlayerDualWielding(ps) != 0;
  if ( !BG_UsingAlternate(ps) )
  {
    if ( !v28 )
      goto LABEL_28;
    goto LABEL_26;
  }
  if ( v28 )
  {
LABEL_26:
    if ( handIndex == WEAPON_HAND_LEFT )
      goto LABEL_27;
LABEL_28:
    v29 = 0;
    goto LABEL_29;
  }
LABEL_27:
  v29 = 1;
LABEL_29:
  v30 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11002, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( v29 )
    v30 = (const PlayerWeaponAnimArrays *)((char *)v30 + 4976);
  if ( v30->normalAnimArray[g_reloadMultipleAnimMap[v27]] )
  {
    if ( (unsigned int)v27 >= 8 )
    {
      LODWORD(ammoInClip) = v27;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11059, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( ( sizeof( *array_counter( g_reloadMultipleAnimMap ) ) + 0 ) )", "animIndex doesn't index ARRAY_COUNT( g_reloadMultipleAnimMap )\n\t%i not in [0, %i)", ammoInClip, 8) )
        __debugbreak();
      LODWORD(reloadAnimFile) = 8;
      LODWORD(ammoInClipa) = v27;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11060, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( ( sizeof( *array_counter( g_reloadMultipleFastAnimMap ) ) + 0 ) )", "animIndex doesn't index ARRAY_COUNT( g_reloadMultipleFastAnimMap )\n\t%i not in [0, %i)", ammoInClipa, reloadAnimFile) )
        __debugbreak();
    }
    if ( BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, handIndex, *(unsigned int *)((char *)&ps->weapState[0].ammoInClipBeforeReload + v37), g_reloadMultipleFastAnimMap[v27]) )
      return (unsigned int)g_reloadMultipleFastAnimMap[v27];
    else
      return (unsigned int)g_reloadMultipleAnimMap[v27];
  }
LABEL_43:
  ammoInClipBeforeReload = *(unsigned int *)((char *)&ps->weapState[0].ammoInClipBeforeReload + v37);
  if ( empty )
  {
LABEL_44:
    if ( BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, handIndex, ammoInClipBeforeReload, WEAP_ANIM_FAST_RELOAD_EMPTY) )
      return 307i64;
    else
      return 289i64;
  }
  v32 = BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, handIndex, ammoInClipBeforeReload, WEAP_ANIM_FAST_RELOAD_FIRST);
  v33 = 286;
  if ( v32 )
    return 304;
  return v33;
}

/*
==============
BG_ReloadMultipleTimeBulletBased
==============
*/
__int64 BG_ReloadMultipleTimeBulletBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  __int64 v7; 
  bool *v10; 
  bool v11; 
  bool v12; 
  char *v13; 
  int v14; 
  unsigned int v15; 
  int v16; 
  int started; 
  int v18; 
  __int64 isDualWielding; 
  bool v21; 

  v7 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10379, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(isDualWielding) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10380, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( ( sizeof( *array_counter( ps->weapState ) ) + 0 ) )", "hand doesn't index ARRAY_COUNT( ps->weapState )\n\t%i not in [0, %i)", isDualWielding, 2) )
      __debugbreak();
  }
  v10 = hasFastReloadOverride;
  v11 = isAlternate;
  v12 = isAlternate;
  v13 = (char *)ps + 80 * v7;
  *hasFastReloadOverride = 0;
  LODWORD(hasFastReloadOverride) = BG_GetAmmoNotInClip(ps, r_weapon, v12);
  v14 = BG_GetClipSize(ps, r_weapon, v11) - *((_DWORD *)v13 + 345);
  v15 = *((_DWORD *)v13 + 339) - 18;
  v21 = 0;
  if ( v15 > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10391, ASSERT_TYPE_ASSERT, "(( (weapState.weaponState == WEAPON_RELOADING) || (weapState.weaponState == WEAPON_RELOAD_START) || ( (weapState.weaponState == WEAPON_RELOAD_END) || (weapState.weaponState == WEAPON_RELOAD_END_RECHAMBER) ) ))", (const char *)&queryFormat, "WEAPONSTATE_RELOADING( weapState.weaponState )") )
    __debugbreak();
  v16 = BG_ReloadEndTime(ps, pmoveHandler, (const PlayerHandIndex)v7, r_weapon, v11, 0, *((_DWORD *)v13 + 345), &v21);
  *v10 |= v21;
  started = BG_ReloadStartAddTime(ps, r_weapon, v11, 0, *((_DWORD *)v13 + 345), 0, &v21);
  *v10 |= v21;
  v18 = BG_ReloadAddTime(ps, r_weapon, v11, 0, *((_DWORD *)v13 + 345), 0, &v21);
  *v10 |= v21;
  if ( v14 > (int)hasFastReloadOverride )
    v14 = (int)hasFastReloadOverride;
  if ( v14 <= 1 )
    return (unsigned int)(started + v16);
  else
    return (unsigned int)(v16 + started + v18 * (v14 - 1));
}

/*
==============
BG_ReloadMultipleTimePercentageBased
==============
*/
__int64 BG_ReloadMultipleTimePercentageBased(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool *hasFastReloadOverride)
{
  __int64 v9; 
  bool *v11; 
  int AmmoNotInClip; 
  int ClipSize; 
  int v16; 
  int ammoInClipBeforeReload; 
  int v25; 
  int started; 
  int v27; 
  int v28; 
  __int64 result; 
  __int64 isSecondRound; 
  int v33; 
  bool v35; 

  __asm { vmovaps [rsp+88h+var_48], xmm6 }
  v9 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10419, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v9 >= 2 )
  {
    LODWORD(isSecondRound) = v9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10420, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( ( sizeof( *array_counter( ps->weapState ) ) + 0 ) )", "hand doesn't index ARRAY_COUNT( ps->weapState )\n\t%i not in [0, %i)", isSecondRound, 2) )
      __debugbreak();
  }
  v11 = hasFastReloadOverride;
  *hasFastReloadOverride = 0;
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  __asm { vmovss  xmm6, dword ptr [rax+888h] }
  AmmoNotInClip = BG_GetAmmoNotInClip(ps, r_weapon, isAlternate);
  ClipSize = BG_GetClipSize(ps, r_weapon, isAlternate);
  v35 = 0;
  v16 = ClipSize;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vmulss  xmm1, xmm0, xmm6
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm1, xmm0, xmm3, 1
    vcvttss2si ecx, xmm1
  }
  ammoInClipBeforeReload = ps->weapState[v9].ammoInClipBeforeReload;
  v25 = ClipSize - ammoInClipBeforeReload;
  if ( ClipSize - ammoInClipBeforeReload > AmmoNotInClip )
    v25 = AmmoNotInClip;
  LODWORD(hasFastReloadOverride) = (_ECX + v25 - 1) / _ECX;
  started = BG_ReloadStartAddTime(ps, r_weapon, isAlternate, 0, ammoInClipBeforeReload, 0, &v35);
  *v11 |= v35;
  v27 = BG_ReloadAddTime(ps, r_weapon, isAlternate, 0, ps->weapState[v9].ammoInClipBeforeReload, 0, &v35);
  *v11 |= v35;
  v33 = v27;
  v28 = BG_ReloadEndTime(ps, pmoveHandler, (const PlayerHandIndex)v9, r_weapon, isAlternate, 0, ps->weapState[v9].ammoInClipBeforeReload, &v35);
  *v11 |= v35;
  if ( v16 == v25 )
  {
    v28 = BG_ReloadEmptyTime(ps, pmoveHandler, (const PlayerHandIndex)v9, r_weapon, isAlternate, 0, &v35);
    *v11 |= v35;
  }
  if ( (int)hasFastReloadOverride <= 1 )
    result = (unsigned int)(v28 + started);
  else
    result = (unsigned int)(started + v28 + v33 * ((_DWORD)hasFastReloadOverride - 1));
  __asm { vmovaps xmm6, [rsp+88h+var_48] }
  return result;
}

/*
==============
BG_ReloadStartAdd
==============
*/
__int64 BG_ReloadStartAdd(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int iReloadStartAdd; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  iReloadStartAdd = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iReloadStartAdd;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return iReloadStartAdd;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8651, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammunition = (*i)->ammunition;
    if ( ammunition )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return iReloadStartAdd;
  }
  return (unsigned int)ammunition->reloadStartAdd;
}

/*
==============
BG_ReloadStartAddTime
==============
*/
__int64 BG_ReloadStartAddTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool isSecondRound, bool *hasFastReloadOverride)
{
  bool v11; 
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10729, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  *hasFastReloadOverride = 0;
  v11 = BG_UseFastReload(ps, r_weapon, isAlternate) || BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip);
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 100, NUM_WEAP_ANIMS);
  if ( !v11 )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 4i64 * isSecondRound + 102, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadStartInterruptTime
==============
*/
int BG_ReloadStartInterruptTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool IsUsingFastReloadStateTimer; 
  __int64 offset; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10608, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding);
  offset = 262i64;
  if ( IsUsingFastReloadStateTimer )
    offset = 292i64;
  return BG_InterruptTimeCommon(ps, pmoveHandler, hand, r_weapon, isAlternate, isDualWielding, offset);
}

/*
==============
BG_ReloadStartTime
==============
*/
__int64 BG_ReloadStartTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  __int64 result; 

  *hasFastReloadOverride = 0;
  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 96i64, NUM_WEAP_ANIMS);
  if ( !BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_START) )
    return WeaponFieldTimeWithDependentAnimation;
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 98i64, NUM_WEAP_ANIMS);
  if ( !(_WORD)result )
    return WeaponFieldTimeWithDependentAnimation;
  *hasFastReloadOverride = 1;
  return result;
}

/*
==============
BG_ReloadTime
==============
*/
__int64 BG_ReloadTime(const playerState_s *ps, const BgHandler *pmoveHandler, const PlayerHandIndex hand, const Weapon *r_weapon, bool isAlternate, bool isDualWielding, int ammoInClip, bool *hasFastReloadOverride)
{
  __int64 result; 

  *hasFastReloadOverride = 0;
  if ( !BG_UseFastReloadAnims(ps, pmoveHandler, r_weapon, isAlternate, hand, ammoInClip, WEAP_ANIM_FAST_RELOAD_FIRST) )
    return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 70i64, NUM_WEAP_ANIMS);
  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 72i64, NUM_WEAP_ANIMS);
  *hasFastReloadOverride = (unsigned __int16)result != 0;
  if ( !(_WORD)result )
    return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 70i64, NUM_WEAP_ANIMS);
  return result;
}

/*
==============
BG_RemoveIgnoreEntFromBP
==============
*/
void BG_RemoveIgnoreEntFromBP(BulletFireParams *bp, int entityIndex)
{
  int ignoreHitEntCount; 
  int v5; 
  int v6; 
  bool v7; 
  int *ignoreHitEntityQueue; 
  int *v9; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 584, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  ignoreHitEntCount = bp->ignoreHitEntCount;
  if ( ignoreHitEntCount >= 16 || ignoreHitEntCount )
  {
    v5 = bp->ignoreHitEntCount;
    v6 = 0;
    v7 = v5 < 0;
    if ( v5 > 0 )
    {
      ignoreHitEntityQueue = bp->ignoreHitEntityQueue;
      while ( *ignoreHitEntityQueue != entityIndex )
      {
        ++v6;
        ++ignoreHitEntityQueue;
        if ( v6 >= v5 )
          goto LABEL_12;
      }
      v9 = &bp->ignoreHitEntityQueue[(v5 - 1) % 16];
      bp->ignoreHitEntityQueue[v6] = *v9;
      *v9 = -1;
      v5 = --bp->ignoreHitEntCount;
LABEL_12:
      v7 = v5 < 0;
    }
    if ( v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 607, ASSERT_TYPE_ASSERT, "(bp->ignoreHitEntCount >= 0)", (const char *)&queryFormat, "bp->ignoreHitEntCount >= 0") )
      __debugbreak();
  }
}

/*
==============
BG_RemoveWeaponAndGlobalAmmo
==============
*/
void BG_RemoveWeaponAndGlobalAmmo(BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  char v9; 
  unsigned int v10; 
  const Weapon *Weapon; 
  const Weapon *v14; 
  int v21; 
  AmmoStore v23; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3599, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3600, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RAX = BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  v9 = 0;
  v10 = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+168h+r_ammo2.weapon.weaponIdx], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+168h+r_ammo2.weapon.attachmentVariationIndices+5], ymm1
  }
  do
  {
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon(weaponMap, ps->weaponsEquipped[v10]);
    v14 = Weapon;
    if ( isAlternate || memcmp_0(Weapon, r_weapon, 0x3Cui64) )
    {
      _RAX = BG_AmmoStoreForWeapon(&v23, v14, 0);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+168h+result.weapon.weaponIdx], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rsp+168h+result.weapon.attachmentVariationIndices+5], ymm1
      }
      if ( BG_IsAmmoCompatible(&result, &r_ammo2) )
        goto LABEL_26;
      if ( BG_HasUnderbarrelAmmo(v14) )
      {
        _RAX = BG_AmmoStoreForWeapon(&v23, v14, 1);
        __asm
        {
          vmovups ymm0, ymmword ptr [rax]
          vmovups ymmword ptr [rsp+168h+result.weapon.weaponIdx], ymm0
          vmovups ymm1, ymmword ptr [rax+20h]
          vmovups ymmword ptr [rsp+168h+result.weapon.attachmentVariationIndices+5], ymm1
        }
        if ( BG_IsAmmoCompatible(&result, &r_ammo2) )
LABEL_26:
          v9 = 1;
      }
    }
    else
    {
      if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 851, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 852, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      weaponMap->SetWeapon(weaponMap, &ps->weaponsEquipped[v10], &NULL_WEAPON);
    }
    ++v10;
  }
  while ( v10 < 0xF );
  v21 = 0;
  if ( !v9 )
  {
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1288, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    while ( !BG_IsAmmoCompatible(&ps->weapCommon.ammoNotInClip[v21].ammoType, &r_ammo2) )
    {
      if ( (unsigned int)++v21 >= 0xF )
        return;
    }
    if ( (playerState_s *)((char *)ps + 68 * v21) != (playerState_s *)-1912i64 )
    {
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.weaponIdx = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.stickerIndices[3] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.weaponAttachments[2] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.weaponAttachments[10] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.attachmentVariationIndices[5] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.attachmentVariationIndices[13] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.attachmentVariationIndices[21] = 0i64;
      *(_QWORD *)&ps->weapCommon.ammoNotInClip[v21].ammoType.weapon.weaponCamo = 0i64;
      ps->weapCommon.ammoNotInClip[v21].ammoCount = 0;
    }
  }
}

/*
==============
BG_RequireAmmoUsedPerShot
==============
*/
_BOOL8 BG_RequireAmmoUsedPerShot(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->requireAmmoUsedPerShot;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8589, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ammunition = (*i)->ammunition;
    if ( ammunition )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->requireAmmoUsedPerShot;
  }
  return ammunition->requireAmmoUsedPerShot;
}

/*
==============
BG_RequiredAmmoPerShot
==============
*/
__int64 BG_RequiredAmmoPerShot(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v6; 
  WeaponAttachment **v7; 
  AttAmmunition *ammunition; 
  bool requireAmmoUsedPerShot; 
  unsigned int v10; 
  WeaponAttachment **v11; 
  __int64 result; 
  int iAmmoUsedPerShot; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v6 = 0;
  if ( WeaponAttachments_Internal )
  {
    v7 = attachments;
    while ( 1 )
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8589, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammunition = (*v7)->ammunition;
      if ( ammunition )
        break;
      ++v6;
      ++v7;
      if ( v6 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    requireAmmoUsedPerShot = ammunition->requireAmmoUsedPerShot;
  }
  else
  {
LABEL_8:
    requireAmmoUsedPerShot = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->requireAmmoUsedPerShot;
  }
  if ( !requireAmmoUsedPerShot )
    return 1i64;
  v10 = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( v10 )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8567, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      result = (unsigned int)(*v11)->ammoUsedPerShotOverride;
      if ( (int)result > 0 )
        break;
      ++v2;
      ++v11;
      if ( v2 >= v10 )
        goto LABEL_17;
    }
  }
  else
  {
LABEL_17:
    iAmmoUsedPerShot = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->iAmmoUsedPerShot;
    result = 1i64;
    if ( iAmmoUsedPerShot > 0 )
      return (unsigned int)iAmmoUsedPerShot;
  }
  return result;
}

/*
==============
BG_ScaleKickValue
==============
*/

void __fastcall BG_ScaleKickValue(float *kickPitch, float *kickYaw, double kickMagMin)
{
  bool v7; 
  bool v8; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  _RBX = kickYaw;
  _RDI = kickPitch;
  __asm { vmovaps xmm6, xmm2 }
  if ( !kickPitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3724, ASSERT_TYPE_ASSERT, "(kickPitch)", (const char *)&queryFormat, "kickPitch") )
    __debugbreak();
  v7 = _RBX == NULL;
  if ( !_RBX )
  {
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3725, ASSERT_TYPE_ASSERT, "(kickYaw)", (const char *)&queryFormat, "kickYaw");
    v7 = !v8;
    if ( v8 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm3, dword ptr [rdi]
    vmovss  xmm4, dword ptr [rbx]
    vmulss  xmm1, xmm4, xmm4
    vmulss  xmm0, xmm3, xmm3
    vaddss  xmm2, xmm1, xmm0
    vcomiss xmm2, cs:__real@358637be
  }
  if ( !v7 )
  {
    __asm
    {
      vmulss  xmm0, xmm6, xmm6
      vcomiss xmm2, xmm0
    }
  }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
BG_ScopeOutlinesAgents
==============
*/
bool BG_ScopeOutlinesAgents(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7816, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineAgents;
}

/*
==============
BG_ScopeOutlinesCharacters
==============
*/
bool BG_ScopeOutlinesCharacters(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7794, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineCharacters;
}

/*
==============
BG_ScopeOutlinesEnemies
==============
*/
_BOOL8 BG_ScopeOutlinesEnemies(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  bool outlineEnemies; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  outlineEnemies = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->outlineEnemies;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return outlineEnemies;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7685, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return outlineEnemies;
  }
  return outline->outlineEnemies;
}

/*
==============
BG_ScopeOutlinesLockOn
==============
*/
bool BG_ScopeOutlinesLockOn(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7751, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineLockOn;
}

/*
==============
BG_ScopeOutlinesScriptMovers
==============
*/
bool BG_ScopeOutlinesScriptMovers(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7729, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineScriptMovers;
}

/*
==============
BG_ScopeOutlinesTurrets
==============
*/
bool BG_ScopeOutlinesTurrets(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7773, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineTurrets;
}

/*
==============
BG_ScopeOutlinesVehicles
==============
*/
bool BG_ScopeOutlinesVehicles(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttOutline *outline; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7707, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    outline = (*i)->outline;
    if ( outline )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return 0;
  }
  return outline->outlineVehicles;
}

/*
==============
BG_ScopeToggleOffInterruptTime
==============
*/
__int64 BG_ScopeToggleOffInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 358i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_ScopeToggleOffTime
==============
*/
__int64 BG_ScopeToggleOffTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 result; 
  bool v7; 
  const char *WeaponNameComplete; 
  char output[1024]; 

  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 256i64, NUM_WEAP_ANIMS);
  if ( (unsigned __int16)result == 0xFFFF )
  {
    v7 = BG_UsingAlternate(ps);
    WeaponNameComplete = BG_GetWeaponNameComplete(r_weapon, v7, output, 0x400u);
    Com_PrintError(17, "ERROR: Weapon \"%s\" is set up as hybrid scope but it does not have a scope toggle off state timer set. Using default scope toggle time (%d).\n", WeaponNameComplete, 100i64);
    return 100i64;
  }
  return result;
}

/*
==============
BG_ScopeToggleOnInterruptTime
==============
*/
__int64 BG_ScopeToggleOnInterruptTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 356i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_ScopeToggleOnTime
==============
*/
__int64 BG_ScopeToggleOnTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  __int64 result; 
  bool v7; 
  const char *WeaponNameComplete; 
  char output[1024]; 

  result = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 254i64, NUM_WEAP_ANIMS);
  if ( (unsigned __int16)result == 0xFFFF )
  {
    v7 = BG_UsingAlternate(ps);
    WeaponNameComplete = BG_GetWeaponNameComplete(r_weapon, v7, output, 0x400u);
    Com_PrintError(17, "ERROR: Weapon \"%s\" is set up as hybrid scope but it does not have a scope toggle on state timer set. Using default scope toggle time (%d).\n", WeaponNameComplete, 100i64);
    return 100i64;
  }
  return result;
}

/*
==============
BG_SetGlobalAmmo
==============
*/
void BG_SetGlobalAmmo(playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoCount)
{
  int v9; 
  AmmoStore result; 
  AmmoStore r_ammo2; 

  _RAX = BG_AmmoStoreForWeapon(&result, r_weapon, isAlternate);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+0D8h+r_ammo2.weapon.weaponIdx], ymm0
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rsp+0D8h+r_ammo2.weapon.attachmentVariationIndices+5], ymm1
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1288, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v9 = 0;
  while ( !BG_IsAmmoCompatible(&ps->weapCommon.ammoNotInClip[v9].ammoType, &r_ammo2) )
  {
    if ( (unsigned int)++v9 >= 0xF )
      goto LABEL_9;
  }
  if ( (playerState_s *)((char *)ps + 68 * v9) == (playerState_s *)-1912i64 )
  {
LABEL_9:
    _RAX = BG_FindGlobalAmmoSlot(ps);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsp+0D8h+r_ammo2.weapon.weaponIdx]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rsp+0D8h+r_ammo2.weapon.attachmentVariationIndices+5]
      vmovups ymmword ptr [rax+20h], ymm1
    }
    _RAX->ammoCount = ammoCount;
    return;
  }
  ps->weapCommon.ammoNotInClip[v9].ammoCount = ammoCount;
}

/*
==============
BG_SetGlobalAmmoForAmmoType
==============
*/
void BG_SetGlobalAmmoForAmmoType(playerState_s *ps, const AmmoStore *r_ammoType, int ammoCount)
{
  _RDI = r_ammoType;
  _RAX = BG_GlobalAmmoForAmmoType(ps, r_ammoType);
  if ( !_RAX )
  {
    _RAX = BG_FindGlobalAmmoSlot(ps);
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi]
      vmovups ymmword ptr [rax], ymm0
      vmovups ymm1, ymmword ptr [rdi+20h]
      vmovups ymmword ptr [rax+20h], ymm1
    }
  }
  _RAX->ammoCount = ammoCount;
}

/*
==============
BG_SetMustHaveAltAnim
==============
*/
void BG_SetMustHaveAltAnim(int weaponHasUnderbarrelAmmo, XAnimParts **normalAnimArray, XAnimParts **altAnimArray, weapAnimFiles_t weaponAnim)
{
  __int64 v4; 
  XAnimParts *v8; 

  v4 = weaponAnim;
  if ( !normalAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18318, ASSERT_TYPE_ASSERT, "(normalAnimArray)", (const char *)&queryFormat, "normalAnimArray") )
    __debugbreak();
  if ( !altAnimArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18319, ASSERT_TYPE_ASSERT, "(altAnimArray)", (const char *)&queryFormat, "altAnimArray") )
    __debugbreak();
  if ( weaponHasUnderbarrelAmmo && !altAnimArray[v4] )
  {
    v8 = normalAnimArray[v4];
    if ( v8 )
      altAnimArray[v4] = v8;
  }
}

/*
==============
BG_SetWeaponDelay
==============
*/
void BG_SetWeaponDelay(const BgWeaponMap *weaponMap, playerState_s *ps, const PlayerHandIndex hand, int weaponDelay, const char *const reason)
{
  __int64 v6; 
  const Weapon *ViewmodelWeapon; 
  bool v10; 
  const char *v11; 
  int v12; 
  const char *fmt; 
  __int64 v14; 
  const char *v15; 
  char output[1024]; 

  v6 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23118, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v6 >= 2 )
  {
    LODWORD(v14) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23119, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v14, 2) )
      __debugbreak();
  }
  if ( weaponDelay == 0xFFFF || (unsigned int)weaponDelay > 0x7FFF )
  {
    ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
    v10 = BG_UsingAlternate(ps);
    BG_GetWeaponNameComplete(ViewmodelWeapon, v10, output, 0x400u);
    v11 = "Set by Code";
    if ( weaponDelay == 0xFFFF )
    {
      v12 = 23135;
      if ( reason )
        v11 = reason;
      v15 = v11;
      fmt = "Undefined weapon delay timer is used. Weapon Delay: %d Reason: %s Weapon: %s. Please report this to the weapon designers.";
    }
    else
    {
      v12 = 23139;
      if ( reason )
        v11 = reason;
      v15 = v11;
      fmt = "Out of bounds weapon delay timer is used. Weapon Delay: %d Reason: %s Weapon: %s. Please report this to the weapon designers.";
    }
    LODWORD(v14) = weaponDelay;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", v12, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, fmt, v14, v15, output) )
      __debugbreak();
  }
  ps->weapState[v6].weaponDelay = weaponDelay;
}

/*
==============
BG_ShotCount
==============
*/
__int64 BG_ShotCount(const Weapon *r_weapon, bool isAlternate)
{
  int v5; 
  unsigned int shotCount; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( BG_GetWeaponClass(r_weapon, isAlternate) == WEAPCLASS_TURRET && BG_GetWeaponFireType(r_weapon, isAlternate) == WEAPON_FIRETYPE_BEAM )
    return 1i64;
  v5 = 0;
  shotCount = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->shotCount;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8548, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      ammunition = (*i)->ammunition;
      if ( ammunition )
        break;
      if ( ++v5 >= WeaponAttachments_Internal )
        return shotCount;
    }
    return (unsigned int)ammunition->shotCount;
  }
  return shotCount;
}

/*
==============
BG_ShouldApplyWeaponAnglesToShootingDirection
==============
*/
bool BG_ShouldApplyWeaponAnglesToShootingDirection(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v10; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RBX = ps;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20110, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( r_weapon->weaponIdx )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm0, dword ptr [rbx+730h]
    }
    BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    v8 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      v10 = attachments;
      do
      {
        if ( !*v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7410, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        if ( (*v10)->sight )
          break;
        ++v8;
        ++v10;
      }
      while ( v8 < WeaponAttachments_Internal );
    }
    if ( !BG_GetOverlay(r_weapon, isAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20120, ASSERT_TYPE_ASSERT, "(adsOverlay)", (const char *)&queryFormat, "adsOverlay") )
      __debugbreak();
  }
  return 0;
}

/*
==============
BG_ShouldBlendFireAnims
==============
*/
_BOOL8 BG_ShouldBlendFireAnims(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blendFireAnimations;
}

/*
==============
BG_ShowBone
==============
*/
unsigned __int8 BG_ShowBone(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel)
{
  return BG_ShowBoneByModelRange(bone, obj, partBits, startModel, -1);
}

/*
==============
BG_ShowBoneByModelRange
==============
*/
__int64 BG_ShowBoneByModelRange(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, int startModel, int lastModelInclusive)
{
  unsigned __int8 childIndex[24]; 
  unsigned __int8 index; 

  if ( startModel < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5063, ASSERT_TYPE_ASSERT, "( startModel ) >= ( 0 )", "%s >= %s\n\t%i, %i", "startModel", "0", startModel, 0i64) )
    __debugbreak();
  index = -2;
  if ( DObjGetBoneIndexFromModelRange(obj, bone, startModel, lastModelInclusive, &index) )
  {
    bitarray_base<bitarray<256>>::resetBit(partBits, index);
    for ( childIndex[0] = -2; DObjGetNextChildBoneIndex(obj, index, childIndex); partBits->array[(unsigned __int64)childIndex[0] >> 5] &= ~(0x80000000 >> (childIndex[0] & 0x1F)) )
      ;
  }
  return index;
}

/*
==============
BG_ShowHideTagsBasedOnAltMode
==============
*/
void BG_ShowHideTagsBasedOnAltMode(const Weapon *r_weapon, DObj *obj, bool isAlternate, bool raisingToAlt, bool hideReticle, bool overrideHamr, bool hamrOn)
{
  if ( hideReticle )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_hamr, obj, &obj->hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_on, obj, &obj->hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_reflex, obj, &obj->hidePartBits, 0, -1);
    goto LABEL_8;
  }
  if ( isAlternate || overrideHamr && hamrOn )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_hamr, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_reticle_on, obj, &obj->hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_reticle_reflex, obj, &obj->hidePartBits, 0, -1);
LABEL_8:
    if ( isAlternate )
      goto LABEL_11;
    goto LABEL_9;
  }
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_reticle_hamr, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_on, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_reticle_reflex, obj, &obj->hidePartBits, 0, -1);
LABEL_9:
  if ( !raisingToAlt )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_show_alt, obj, &obj->hidePartBits, 0, -1);
    return;
  }
LABEL_11:
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_show_alt, obj, &obj->hidePartBits, 0, -1);
}

/*
==============
BG_ShowIronSights
==============
*/
void BG_ShowIronSights(DObj *obj, int startModel, int lastModelInclusive)
{
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5157, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.ironsight2_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.weaponrail_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
}

/*
==============
BG_ShowSniperScene
==============
*/
void BG_ShowSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj)
{
  bool v6; 
  unsigned int v7; 
  const scr_string_t **v8; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5515, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v6 = BG_ShowViewModelInDualFOV(r_weapon, isAlternate);
  BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  if ( !v6 && BG_HideBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, &obj->hidePartBits, 0, -1) <= 0xFDu )
  {
    v7 = 0;
    v8 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
    do
    {
      BG_ToggleBoneVisibilityInAllModels(**v8, obj, &obj->hidePartBits, 0);
      ++v7;
      ++v8;
    }
    while ( v7 < 0xD );
  }
}

/*
==============
BG_ShowViewModelInDualFOV
==============
*/
_BOOL8 BG_ShowViewModelInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->showViewModelInDualFOV;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2988, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->showViewModelInDualFOV;
  }
  return sight->showViewModelInDualFOV;
}

/*
==============
BG_SkydiveFreefallRaiseTime
==============
*/
int BG_SkydiveFreefallRaiseTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveOpenParachuteTime
==============
*/
int BG_SkydiveOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteDetachTime
==============
*/
__int64 BG_SkydiveParachuteDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v3; 

  v3 = DCONST_DVARINT_skydive_cut_parachute_anim_time;
  if ( !DCONST_DVARINT_skydive_cut_parachute_anim_time && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "skydive_cut_parachute_anim_time") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return v3->current.unsignedInt;
}

/*
==============
BG_SkydiveParachuteFastLandingTime
==============
*/
int BG_SkydiveParachuteFastLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_FAST_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteFastLandingVelocity
==============
*/
float BG_SkydiveParachuteFastLandingVelocity(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11671, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RAX = BG_GetSuitDef(ps->suitIndex)->animPackage->animOverrides;
  __asm { vmovss  xmm0, dword ptr [rax+1A64h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_SkydiveParachuteMidAirDetachTime
==============
*/
int BG_SkydiveParachuteMidAirDetachTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_MID_AIR_DETACH, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteSlowHardLandingTime
==============
*/
int BG_SkydiveParachuteSlowHardLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_HARD_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteSlowHardLandingVelocity
==============
*/
float BG_SkydiveParachuteSlowHardLandingVelocity(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11651, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RAX = BG_GetSuitDef(ps->suitIndex)->animPackage->animOverrides;
  __asm { vmovss  xmm0, dword ptr [rax+1A60h] }
  return *(float *)&_XMM0;
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingTime
==============
*/
int BG_SkydiveParachuteSlowSoftLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_SOFT_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveParachuteSlowSoftLandingVelocity
==============
*/
float BG_SkydiveParachuteSlowSoftLandingVelocity(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11631, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RAX = BG_GetSuitDef(ps->suitIndex)->animPackage->animOverrides;
  __asm { vmovss  xmm0, dword ptr [rax+1A5Ch] }
  return *(float *)&_XMM0;
}

/*
==============
BG_SkydiveParachuteStillLandingTime
==============
*/
int BG_SkydiveParachuteStillLandingTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_PARACHUTE_STILL_LAND, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveQuickOpenParachuteTime
==============
*/
int BG_SkydiveQuickOpenParachuteTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveSuperDiveInTime
==============
*/
int BG_SkydiveSuperDiveInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, isAlternate, 0, NULL);
}

/*
==============
BG_SkydiveSuperDiveOutTime
==============
*/
int BG_SkydiveSuperDiveOutTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  return BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, isAlternate, 0, NULL);
}

/*
==============
BG_SlideSpreadFireAdd
==============
*/
float BG_SlideSpreadFireAdd(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v16; 
  __int64 v17; 
  bool v18; 
  bool v19; 
  WeaponAttachment **v23; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char v41; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v10 = 0;
  __asm { vmovss  xmm9, dword ptr [rax+568h] }
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm7
    vxorps  xmm8, xmm8, xmm8
  }
  if ( WeaponAttachments_Internal )
  {
    v16 = attachments;
    v17 = WeaponAttachments_Internal;
    do
    {
      v18 = *v16 == NULL;
      if ( !*v16 )
      {
        v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14135, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
        v18 = !v19;
        if ( v19 )
          __debugbreak();
      }
      _RAX = *v16;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+2ECh]
        vucomiss xmm0, xmm8
      }
      if ( !v18 )
      {
        __asm
        {
          vaddss  xmm0, xmm6, xmm0
          vsubss  xmm6, xmm0, xmm7
        }
      }
      ++v16;
      --v17;
    }
    while ( v17 );
  }
  if ( WeaponAttachments_Internal )
  {
    v23 = attachments;
    while ( 1 )
    {
      if ( !*v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14144, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v23)->slideSpread )
        break;
      ++v10;
      ++v23;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_18;
    }
    __asm { vmovss  xmm9, dword ptr [rcx+0Ch] }
  }
LABEL_18:
  __asm
  {
    vmaxss  xmm3, xmm6, xmm8
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmulss  xmm0, xmm0, xmm9
  }
  _R11 = &v41;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_SmoothFadeSniperScene
==============
*/

void __fastcall BG_SmoothFadeSniperScene(const Weapon *r_weapon, const bool isAlternate, DObj *obj, double adsFrac)
{
  bool v7; 
  DObjPartBits *p_hidePartBits; 
  unsigned int v11; 
  const scr_string_t **v12; 

  __asm { vcomiss xmm3, cs:__real@3f800000 }
  v7 = __CFADD__(obj, 208i64);
  p_hidePartBits = &obj->hidePartBits;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm3, xmm0
  }
  if ( v7 )
    BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  else
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.scope_center, obj, p_hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_cap, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_top, obj, &obj->hidePartBits, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.scope_ads, obj, &obj->hidePartBits, 0, -1);
  if ( !BG_ShowViewModelInDualFOV(r_weapon, isAlternate) && BG_ShowBoneByModelRange((const scr_string_t)scr_const.gun_ads, obj, &obj->hidePartBits, 0, -1) <= 0xFDu )
  {
    v11 = 0;
    v12 = (const scr_string_t **)SNIPER_SCENE_HIDDEN_TAGS;
    do
    {
      BG_ToggleBoneVisibilityInAllModels(**v12, obj, &obj->hidePartBits, 0);
      ++v11;
      ++v12;
    }
    while ( v11 < 0xD );
  }
}

/*
==============
BG_SprintInTime
==============
*/
__int64 BG_SprintInTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  weapAnimFiles_t SprintAnim; 
  char v14; 
  char v15; 
  __int64 result; 

  __asm { vmovaps [rsp+68h+var_28], xmm6 }
  SprintAnim = BG_GetSprintAnim(ps, r_weapon, isAlternate, isDualWielding, WEAP_ANIM_SPRINT_IN);
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 170i64, NUM_WEAP_ANIMS);
  BG_Suit_GetAnimTime(ps, r_weapon, SprintAnim, isAlternate, isDualWielding, NULL);
  _RBX = DCONST_DVARMPFLT_bg_sprintInTimeScale;
  if ( !DCONST_DVARMPFLT_bg_sprintInTimeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_sprintInTimeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+28h]
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v14 | v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11369, ASSERT_TYPE_ASSERT, "(bgSprintInTimeScale > 0.0f)", (const char *)&queryFormat, "bgSprintInTimeScale > 0.0f") )
    __debugbreak();
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, r15d
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si ebx, xmm1
  }
  if ( _EBX <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11372, ASSERT_TYPE_ASSERT, "(sprintInTime > 0)", (const char *)&queryFormat, "sprintInTime > 0") )
    __debugbreak();
  result = (unsigned int)_EBX;
  __asm { vmovaps xmm6, [rsp+68h+var_28] }
  return result;
}

/*
==============
BG_SprintLoopTime
==============
*/
__int64 BG_SprintLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  weapAnimFiles_t v10; 
  char v14; 
  char v15; 

  __asm { vmovaps [rsp+68h+var_28], xmm6 }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = WEAP_ANIM_SPRINT_LOOP;
  if ( BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, isDualWielding, WEAP_ANIM_SPRINT_LOOP, WEAP_ANIM_ADDITIVE_SPRINT_LOOP) )
    v10 = WEAP_ANIM_ADDITIVE_SPRINT_LOOP;
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 172i64, NUM_WEAP_ANIMS);
  BG_Suit_GetAnimTime(ps, r_weapon, v10, isAlternate, isDualWielding, NULL);
  _RBX = DCONST_DVARMPFLT_bg_sprintLoopTimeScale;
  if ( !DCONST_DVARMPFLT_bg_sprintLoopTimeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_sprintLoopTimeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+28h]
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm6, xmm0
  }
  if ( v14 | v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11392, ASSERT_TYPE_ASSERT, "(bgSprintLoopTimeScale > 0.0f)", (const char *)&queryFormat, "bgSprintLoopTimeScale > 0.0f") )
    __debugbreak();
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, esi
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si ebx, xmm1
  }
  if ( _EBX <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11395, ASSERT_TYPE_ASSERT, "(sprintLoopTime > 0)", (const char *)&queryFormat, "sprintLoopTime > 0") )
    __debugbreak();
  __asm { vmovaps xmm6, [rsp+68h+var_28] }
  return (unsigned int)_EBX;
}

/*
==============
BG_SprintOutInterruptTime
==============
*/
int BG_SprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  const dvar_t *v11; 
  bool v12; 
  bool v13; 
  weapAnimFiles_t v14; 
  bool ShouldUseSuitAnim; 
  int result; 
  int outInterruptTime; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11482, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11483, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v11 = DCONST_DVARMPBOOL_movementAnimProto;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  if ( v11->current.enabled )
  {
    v12 = isDualWielding;
    BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 352i64, NUM_WEAP_ANIMS);
    outInterruptTime = 0;
    BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SPRINT_TO_WALK, isAlternate, v12, &outInterruptTime);
  }
  else
  {
    v13 = isDualWielding;
    BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 340i64, NUM_WEAP_ANIMS);
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v14 = WEAP_ANIM_SPRINT_OUT;
    ShouldUseSuitAnim = BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, v13, WEAP_ANIM_SPRINT_OUT, WEAP_ANIM_ADDITIVE_SPRINT_OUT);
    outInterruptTime = 0;
    if ( ShouldUseSuitAnim )
      v14 = WEAP_ANIM_ADDITIVE_SPRINT_OUT;
    BG_Suit_GetAnimTime(ps, r_weapon, v14, isAlternate, v13, &outInterruptTime);
  }
  *(double *)&_XMM0 = BG_GetSprintOutTimeScale(weaponMap, ps, r_weapon, isAlternate);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, esi
    vmulss  xmm0, xmm0, xmm1
    vcvttss2si eax, xmm0
  }
  return result;
}

/*
==============
BG_SprintOutTime
==============
*/
__int64 BG_SprintOutTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  weapAnimFiles_t v11; 
  __int64 dependentAnimType; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11459, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11460, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 174i64, NUM_WEAP_ANIMS);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11339, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v11 = WEAP_ANIM_SPRINT_OUT;
  if ( BG_Suit_ShouldUseSuitAnim(ps, r_weapon, isAlternate, isDualWielding, WEAP_ANIM_SPRINT_OUT, WEAP_ANIM_ADDITIVE_SPRINT_OUT) )
    v11 = WEAP_ANIM_ADDITIVE_SPRINT_OUT;
  BG_Suit_GetAnimTime(ps, r_weapon, v11, isAlternate, isDualWielding, NULL);
  *(double *)&_XMM0 = BG_GetSprintOutTimeScale(weaponMap, ps, r_weapon, isAlternate);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, r12d
    vmulss  xmm0, xmm0, xmm1
    vcvttss2si ebx, xmm0
  }
  if ( _EBX <= 0 )
  {
    LODWORD(dependentAnimType) = _EBX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11474, ASSERT_TYPE_ASSERT, "( ( 0 < sprintOutTime ) )", "( sprintOutTime ) = %i", dependentAnimType) )
      __debugbreak();
  }
  return (unsigned int)_EBX;
}

/*
==============
BG_StartAmmo
==============
*/
int BG_StartAmmo(const Weapon *r_weapon, bool isAlternate, bool hasIncreasedOffhandAmmoPerk)
{
  weapType_t WeaponType; 
  const WeaponDef *v10; 
  int result; 
  unsigned __int16 weaponIdx; 
  unsigned int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v19; 
  __int64 v20; 
  bool v21; 
  bool v22; 
  WeaponAttachment **v26; 
  AttAmmunition *ammunition; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  if ( BG_WeaponTypeIsOffhand(WeaponType) && hasIncreasedOffhandAmmoPerk )
  {
    v10 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8480, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v10->iPerkStartAmmo;
  }
  else
  {
    weaponIdx = r_weapon->weaponIdx;
    __asm
    {
      vmovaps [rsp+1C8h+var_38], xmm6
      vmovaps [rsp+1C8h+var_48], xmm7
      vmovaps [rsp+1C8h+var_58], xmm8
    }
    v13 = 0;
    _ER15 = BG_WeaponDefAtIndex(weaponIdx)->iStartAmmo;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vmovaps xmm6, xmm7
      vxorps  xmm8, xmm8, xmm8
    }
    if ( WeaponAttachments_Internal )
    {
      v19 = attachments;
      v20 = WeaponAttachments_Internal;
      do
      {
        v21 = *v19 == NULL;
        if ( !*v19 )
        {
          v22 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8504, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]");
          v21 = !v22;
          if ( v22 )
            __debugbreak();
        }
        _RAX = *v19;
        __asm
        {
          vmovss  xmm0, dword ptr [rax+260h]
          vucomiss xmm0, xmm8
        }
        if ( !v21 )
        {
          __asm
          {
            vaddss  xmm0, xmm6, xmm0
            vsubss  xmm6, xmm0, xmm7
          }
        }
        ++v19;
        --v20;
      }
      while ( v20 );
    }
    if ( WeaponAttachments_Internal )
    {
      v26 = attachments;
      while ( 1 )
      {
        if ( !*v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8513, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammunition = (*v26)->ammunition;
        if ( ammunition )
          break;
        ++v13;
        ++v26;
        if ( v13 >= WeaponAttachments_Internal )
          goto LABEL_24;
      }
      _ER15 = ammunition->startAmmo;
    }
LABEL_24:
    __asm
    {
      vmaxss  xmm3, xmm6, xmm8
      vmovaps xmm8, [rsp+1C8h+var_58]
      vmovaps xmm6, [rsp+1C8h+var_38]
      vsubss  xmm0, xmm7, xmm3
      vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcvtss2sd xmm1, xmm0, xmm0
      vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
      vmovd   xmm0, r15d
      vblendvps xmm1, xmm3, xmm7, xmm2
      vmovaps xmm7, [rsp+1C8h+var_48]
      vcvtdq2ps xmm0, xmm0
      vmulss  xmm0, xmm0, xmm1
      vcvttss2si eax, xmm0
    }
  }
  return result;
}

/*
==============
BG_StartingGunKickPercent
==============
*/
float BG_StartingGunKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    __asm { vmovss  xmm6, dword ptr [rax+898h] }
  else
    __asm { vmovss  xmm6, dword ptr [rax+88Ch] }
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14198, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v11)->kickScaling )
        break;
      ++v9;
      ++v11;
      if ( v9 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_12;
      }
    }
    if ( ads )
      __asm { vmovss  xmm0, dword ptr [rcx+0Ch] }
    else
      __asm { vmovss  xmm0, dword ptr [rcx] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_12:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_StartingKickBullets
==============
*/
__int64 BG_StartingKickBullets(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int adsStartingKickBullets; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttKickScaling *kickScaling; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  adsStartingKickBullets = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->adsStartingKickBullets;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return adsStartingKickBullets;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14165, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    kickScaling = (*i)->kickScaling;
    if ( kickScaling )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return adsStartingKickBullets;
  }
  return (unsigned int)kickScaling->adsStartingKickBullets;
}

/*
==============
BG_StartingViewKickPercent
==============
*/
float BG_StartingViewKickPercent(const Weapon *r_weapon, bool isAlternate, bool ads)
{
  unsigned int v9; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  __asm { vmovaps [rsp+188h+var_28], xmm6 }
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( ads )
    __asm { vmovss  xmm6, dword ptr [rax+89Ch] }
  else
    __asm { vmovss  xmm6, dword ptr [rax+890h] }
  v9 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14238, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v11)->kickScaling )
        break;
      ++v9;
      ++v11;
      if ( v9 >= WeaponAttachments_Internal )
      {
        __asm { vmovaps xmm0, xmm6 }
        goto LABEL_12;
      }
    }
    if ( ads )
      __asm { vmovss  xmm0, dword ptr [rcx+10h] }
    else
      __asm { vmovss  xmm0, dword ptr [rcx+4] }
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
LABEL_12:
  __asm { vmovaps xmm6, [rsp+188h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
BG_StowedOcclusionTestEnabled
==============
*/
bool BG_StowedOcclusionTestEnabled(const Weapon *r_weapon)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v3; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v3 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1701, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v3->worldModel && v3->stowedOcclusionTestEnabled && !BG_IsRiotShield(r_weapon, 0);
}

/*
==============
BG_StunnedTimeBegin
==============
*/
__int64 BG_StunnedTimeBegin(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 182i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_StunnedTimeEnd
==============
*/
__int64 BG_StunnedTimeEnd(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 186i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_StunnedTimeLoop
==============
*/
__int64 BG_StunnedTimeLoop(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  return BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 184i64, NUM_WEAP_ANIMS);
}

/*
==============
BG_SuperSprintOutInterruptTime
==============
*/
int BG_SuperSprintOutInterruptTime(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  bool v11; 
  int result; 
  int outInterruptTime; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11522, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 11523, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v11 = isDualWielding;
  BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 354i64, NUM_WEAP_ANIMS);
  outInterruptTime = 0;
  BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_SUPERSPRINT_TO_WALK, isAlternate, v11, &outInterruptTime);
  *(double *)&_XMM0 = BG_GetSprintOutTimeScale(weaponMap, ps, r_weapon, isAlternate);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, edi
    vmulss  xmm0, xmm0, xmm1
    vcvttss2si eax, xmm0
  }
  return result;
}

/*
==============
BG_SyncedFOVInDualFOV
==============
*/
_BOOL8 BG_SyncedFOVInDualFOV(const Weapon *r_weapon, bool isAlternate)
{
  int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->syncedFOVInDualFOV;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3006, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    sight = (*i)->sight;
    if ( sight )
      break;
    if ( ++v2 >= WeaponAttachments_Internal )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->syncedFOVInDualFOV;
  }
  return sight->syncedFOVInDualFOV;
}

/*
==============
BG_TakePlayerWeapon
==============
*/
int BG_TakePlayerWeapon(BgWeaponMap *weaponMap, playerState_s *ps, const BgHandler *const handler, const Weapon *r_weapon, int gameTime)
{
  int result; 
  const Weapon *CurrentWeaponForPlayer; 
  const dvar_t *v11; 
  const Weapon *OffHandWeaponForPlayer; 
  const Weapon *ThrowbackWeaponForPlayer; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3649, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  result = BG_PlayerHasWeapon(weaponMap, ps, r_weapon);
  if ( result )
  {
    if ( BG_WeaponDefAtIndex(r_weapon->weaponIdx)->inventoryType == WEAPINVENTORY_ALTMODE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3655, ASSERT_TYPE_ASSERT, "(BG_WeaponDef( r_weapon, false )->inventoryType != WEAPINVENTORY_ALTMODE)", (const char *)&queryFormat, "BG_WeaponDef( r_weapon, false )->inventoryType != WEAPINVENTORY_ALTMODE") )
      __debugbreak();
    if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3633, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3634, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    BG_RemoveWeaponAndGlobalAmmo(weaponMap, ps, r_weapon, 0);
    if ( BG_HasUnderbarrelAmmo(r_weapon) )
      BG_RemoveWeaponAndGlobalAmmo(weaponMap, ps, r_weapon, 1);
    BG_RemoveClipAmmo(ps, r_weapon, 0);
    if ( BG_HasUnderbarrelAmmo(r_weapon) )
      BG_RemoveClipAmmo(ps, r_weapon, 1);
    CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
    if ( !memcmp_0(r_weapon, CurrentWeaponForPlayer, 0x3Cui64) )
    {
      v11 = DVARBOOL_killswitch_left_hand_throw_gesture_stuck_fix_enabled;
      if ( !DVARBOOL_killswitch_left_hand_throw_gesture_stuck_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_left_hand_throw_gesture_stuck_fix_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      if ( v11->current.enabled )
        BG_Weapon_CancelOffhand(ps, handler, weaponMap, gameTime, 0);
      BG_SetCurrentWeaponForPlayer(weaponMap, ps, &NULL_WEAPON, handler);
    }
    OffHandWeaponForPlayer = BG_GetOffHandWeaponForPlayer(weaponMap, ps);
    if ( !memcmp_0(r_weapon, OffHandWeaponForPlayer, 0x3Cui64) )
    {
      if ( BG_IsUsingOffhandGestureWeapon(ps) )
        BG_OffhandGestureWeaponEnd(weaponMap, ps, handler, gameTime, 0);
      if ( BG_IsUsingScriptedOffhandWeapon(ps) )
        BG_OffhandGestureScriptWeaponEnd(weaponMap, ps, gameTime, 0);
      BG_SetOffHandWeaponForPlayer(weaponMap, ps, &NULL_WEAPON);
    }
    ThrowbackWeaponForPlayer = BG_GetThrowbackWeaponForPlayer(weaponMap, ps);
    if ( !memcmp_0(r_weapon, ThrowbackWeaponForPlayer, 0x3Cui64) )
      BG_SetThrowbackWeaponForPlayer(weaponMap, ps, &NULL_WEAPON);
    if ( Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) && BG_WeaponDefAtIndex(r_weapon->weaponIdx)->isAirburstWeapon )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3712, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST )") )
        __debugbreak();
      ps->airburstMarkDistance = 0;
    }
    return 1;
  }
  return result;
}

/*
==============
BG_TargetAssistLosOffsets
==============
*/
void BG_TargetAssistLosOffsets(const Weapon *r_weapon, bool isAlternate, float *outForwardOffset, float *outRightOffset, float *outUpOffset)
{
  unsigned int v10; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v12; 
  WeaponAttachment *v13; 
  AttTargetAssist *targetAssist; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  _RBP = outUpOffset;
  if ( !outForwardOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9137, ASSERT_TYPE_ASSERT, "(outForwardOffset)", (const char *)&queryFormat, "outForwardOffset") )
    __debugbreak();
  if ( !outRightOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9138, ASSERT_TYPE_ASSERT, "(outRightOffset)", (const char *)&queryFormat, "outRightOffset") )
    __debugbreak();
  if ( !outUpOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9139, ASSERT_TYPE_ASSERT, "(outUpOffset)", (const char *)&queryFormat, "outUpOffset") )
    __debugbreak();
  v10 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9146, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v13 = *v12;
      targetAssist = (*v12)->targetAssist;
      if ( targetAssist )
        break;
      ++v10;
      ++v12;
      if ( v10 >= WeaponAttachments_Internal )
        goto LABEL_17;
    }
    *outForwardOffset = targetAssist->targetAssistLosOffsetForward;
    *outRightOffset = v13->targetAssist->targetAssistLosOffsetRight;
    _RAX = v13->targetAssist;
    __asm { vmovss  xmm0, dword ptr [rax+18h] }
  }
  else
  {
LABEL_17:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    *outForwardOffset = _RAX->targetAssistLosOffsetForward;
    *outRightOffset = _RAX->targetAssistLosOffsetRight;
    __asm { vmovss  xmm0, dword ptr [rax+1C8h] }
  }
  __asm { vmovss  dword ptr [rbp+0], xmm0 }
}

/*
==============
BG_ThrowBackIcon
==============
*/
Material *BG_ThrowBackIcon(const Weapon *r_weapon, bool isAlternate)
{
  int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  AttUI *ui; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v9);
  if ( !AllWeaponAttachmentsWithIds )
    return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->throwBackIconMat;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16239, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    ui = (*i)->ui;
    if ( ui )
      break;
    if ( ++v3 >= AllWeaponAttachmentsWithIds )
      return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->throwBackIconMat;
  }
  return ui->throwBackIconMat;
}

/*
==============
BG_ThrowingBackGrenade
==============
*/
bool BG_ThrowingBackGrenade(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 4990, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return ps->throwbackGrenadeOwner != 2047;
}

/*
==============
BG_TimedDetonation
==============
*/
const WeaponDef *BG_TimedDetonation(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  AttProjectile *projectile; 
  const WeaponDef *result; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v9[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v9, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17369, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      projectile = (*v5)->projectile;
      if ( projectile )
        return (const WeaponDef *)projectile->timedDetonation;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    result = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( result )
      return (const WeaponDef *)result->timedDetonation;
  }
  return result;
}

/*
==============
BG_ToggleBoneVisibilityInAllModels
==============
*/
void BG_ToggleBoneVisibilityInAllModels(const scr_string_t bone, DObj *obj, DObjPartBits *partBits, const bool visible)
{
  int v7; 
  int i; 
  DObjPartBits *p_hidePartBits; 
  unsigned __int8 v10; 
  int ModelIndexForBoneIndex; 
  __int64 v12; 
  __int64 v13; 

  v7 = -1;
  for ( i = 0; ; i = ModelIndexForBoneIndex + 1 )
  {
    p_hidePartBits = &obj->hidePartBits;
    v10 = visible ? BG_ShowBoneByModelRange(bone, obj, p_hidePartBits, i, -1) : BG_HideBoneByModelRange(bone, obj, p_hidePartBits, i, -1);
    if ( v10 > 0xFDu )
      break;
    ModelIndexForBoneIndex = DObjGetModelIndexForBoneIndex(obj, v10);
    if ( ModelIndexForBoneIndex >= (unsigned int)obj->numModels )
    {
      LODWORD(v13) = obj->numModels;
      LODWORD(v12) = ModelIndexForBoneIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5389, ASSERT_TYPE_ASSERT, "(unsigned)( modelIdx ) < (unsigned)( obj->numModels )", "modelIdx doesn't index obj->numModels\n\t%i not in [0, %i)", v12, v13) )
        __debugbreak();
    }
    if ( ModelIndexForBoneIndex >= obj->numModels - 1 )
      break;
    if ( ModelIndexForBoneIndex <= v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5397, ASSERT_TYPE_ASSERT, "(modelIdx > prevmodelIdx)", (const char *)&queryFormat, "modelIdx > prevmodelIdx") )
      __debugbreak();
    v7 = ModelIndexForBoneIndex;
  }
}

/*
==============
BG_TracerType
==============
*/
TracerDef *BG_TracerType(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v5; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v7; 
  TracerDef *tracerType; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *v10; 
  TracerDef **p_tracerType; 
  TracerDef *result; 
  int v13; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoTracer *tracer; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  bitarray<64> v19; 

  v19 = perks;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v7 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_7;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v7 & 0x1F)) & v19.array[v7 >> 5]) == 0 || (tracerType = v5->overchargeTracerType) == NULL )
LABEL_7:
    tracerType = v5->tracerType;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v10 = (WeaponAttachment *)WeaponPrimaryAttachment;
  if ( !WeaponPrimaryAttachment || (p_tracerType = &WeaponPrimaryAttachment->tracer->tracerType) == NULL || (result = *p_tracerType) == NULL || !isAlternate )
  {
    if ( v5->tracerOverrideEnabled )
    {
      v13 = 0;
      WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
      if ( WeaponAttachments_Internal )
      {
        for ( i = attachments; ; ++i )
        {
          if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7135, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
            __debugbreak();
          tracer = (*i)->tracer;
          if ( tracer )
          {
            if ( *i != v10 && tracer->tracerType )
              break;
          }
          if ( ++v13 >= WeaponAttachments_Internal )
            return tracerType;
        }
        return tracer->tracerType;
      }
    }
    return tracerType;
  }
  return result;
}

/*
==============
BG_TurretMaxCorrectionAngle
==============
*/
float BG_TurretMaxCorrectionAngle(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 

  weaponIdx = r_weapon->weaponIdx;
  if ( weaponIdx )
  {
    _RBX = BG_WeaponDefAtIndex(weaponIdx);
    if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9858, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    __asm { vmovss  xmm0, dword ptr [rbx+0FA8h] }
  }
  else
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_TurretSpawnsProjectileAtMuzzle
==============
*/
bool BG_TurretSpawnsProjectileAtMuzzle(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9830, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->spawnProjAtMuzzle;
}

/*
==============
BG_TurretSpinSound
==============
*/
SndAliasLookup BG_TurretSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  WeaponSFXPackage *SfxPackage; 

  if ( r_weapon->weaponIdx && (SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate)) != NULL )
    return (SndAliasLookup)SfxPackage->sounds->turretSpinSnd.name;
  else
    return 0i64;
}

/*
==============
BG_TurretStopSpinSound
==============
*/
SndAliasLookup BG_TurretStopSpinSound(const Weapon *r_weapon, bool isAlternate)
{
  WeaponSFXPackage *SfxPackage; 

  if ( r_weapon->weaponIdx && (SfxPackage = BG_GetSfxPackage(r_weapon, isAlternate)) != NULL )
    return (SndAliasLookup)SfxPackage->sounds->turretStopSnd.name;
  else
    return 0i64;
}

/*
==============
BG_TurretUsesBulletCorrection
==============
*/
bool BG_TurretUsesBulletCorrection(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9844, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->correctBulletTrajectory;
}

/*
==============
BG_TurretWeaponUses3pIK
==============
*/
bool BG_TurretWeaponUses3pIK(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9816, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->useTurret3pIK;
}

/*
==============
BG_UniqueAmmoUnderbarrelAttachment
==============
*/
const WeaponAttachment *BG_UniqueAmmoUnderbarrelAttachment(const Weapon *weapon, const bool isAlternate)
{
  const WeaponAttachment *result; 

  if ( !isAlternate )
    return 0i64;
  result = BG_GetWeaponPrimaryAttachment(weapon, ATT_SLOT_UNDERBARREL);
  if ( !result || result->weapClass == WEAPCLASS_NONE || result->shareAmmoWithAlt )
    return 0i64;
  return result;
}

/*
==============
BG_UnpackClientWeaponFireEventParm
==============
*/

void __fastcall BG_UnpackClientWeaponFireEventParm(const unsigned int eventParm, tmat33_t<vec3_t> *outFireAxis, double _XMM2_8)
{
  vec3_t angles; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rax
    vmulss  xmm0, xmm0, cs:__real@3bb40000
    vmovss  dword ptr [rsp+48h+angles], xmm0
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rax
    vmulss  xmm1, xmm0, cs:__real@3bb40000
    vxorps  xmm2, xmm2, xmm2
    vmovss  dword ptr [rsp+48h+angles+4], xmm1
    vmovss  dword ptr [rsp+48h+angles+8], xmm2
  }
  AnglesToAxis(&angles, outFireAxis);
}

/*
==============
BG_UpdateLastWeaponHand
==============
*/
void BG_UpdateLastWeaponHand(const BgWeaponMap *weaponMap, playerState_s *ps, const Weapon *weapon)
{
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23022, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23023, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ps->weapCommon.lastWeaponHand = BG_PlayerDualWieldingWeapon(weaponMap, ps, weapon) != 0;
}

/*
==============
BG_UpdateSecondaryWeaponVisibilities
==============
*/
void BG_UpdateSecondaryWeaponVisibilities(const BgAnimStatic *bgameAnim, const BgWeaponMap *weaponMap, const entityState_t *es, characterInfo_t *ci)
{
  const BgAnimStatic *v8; 
  unsigned __int16 weaponIdx; 
  int isUsingWeaponAltMode; 
  int playerAnimType; 
  const WeaponDef *v12; 
  int v13; 
  BOOL v14; 
  unsigned int Anim; 
  unsigned int Animset; 
  unsigned int v17; 
  const Weapon *v19; 
  const BgAnimStatic *v20; 
  unsigned __int16 v21; 
  int v22; 
  const WeaponDef *v23; 
  int DoesNotFullyAnimateViewmodelEntityState; 
  scr_string_t hide; 
  scr_string_t show; 
  int v27; 
  int v28; 
  SuitAnimType SuitAnimIndex; 
  SuitAnimType v30; 
  const Weapon *OffHandWeaponForPlayerEntity; 
  unsigned __int16 v33; 
  int v34; 
  int v35; 
  const WeaponDef *v36; 
  bool usingThrownWeapon; 
  bool usingKillstreakTrigger; 
  bool hideLeftHandWeapon; 
  bool hideWeapon; 
  bool stowHeldWeapon; 
  float rangeExpand; 
  float rangeExpanda; 
  float rangeExpandb; 
  float rangeExpandc; 
  float rangeExpandd; 
  float rangeExpande; 
  float rangeExpandf; 
  float rangeExpandg; 
  float rangeExpandh; 
  float rangeExpandi; 
  float rangeExpandj; 
  float rangeExpandk; 
  float rangeExpandl; 
  float rangeExpandm; 
  int v57; 
  int v58; 
  unsigned int packedAnimIndex; 
  int animNum; 
  int animNuma; 
  int bgameAnimb; 
  int v66; 
  int v67; 

  v8 = bgameAnim;
  if ( !bgameAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21420, ASSERT_TYPE_ASSERT, "(bgameAnim)", (const char *)&queryFormat, "bgameAnim") )
    __debugbreak();
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21421, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21422, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21423, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  weaponIdx = ci->dobjHeldWeapon.weaponIdx;
  if ( !weaponIdx )
    return;
  BG_WeaponDefAtIndex(weaponIdx);
  isUsingWeaponAltMode = ci->isUsingWeaponAltMode;
  if ( BG_GetWeaponType(&ci->dobjHeldWeapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(&ci->dobjHeldWeapon, 0) == WEAPCLASS_THROWINGKNIFE && isUsingWeaponAltMode )
  {
    playerAnimType = 8;
  }
  else
  {
    v12 = BG_WeaponDefAtIndex(ci->dobjHeldWeapon.weaponIdx);
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20880, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    playerAnimType = v12->playerAnimType;
  }
  v13 = 0;
  v58 = playerAnimType;
  v14 = 0;
  if ( BG_GetWeaponType(&ci->dobjHeldWeapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(&ci->dobjHeldWeapon, 0) == WEAPCLASS_THROWINGKNIFE && ci->isUsingWeaponAltMode )
    v14 = 1;
  __asm { vmovaps [rsp+98h+var_58], xmm6 }
  v66 = 0;
  animNum = 0;
  v67 = 0;
  v57 = 0;
  if ( !PlayerASM_IsEnabled() )
  {
    animNuma = BG_AnimationMP_GetLegsAnimation(es);
    bgameAnimb = BG_AnimationMP_GetTorsoAnimation(es);
    v28 = bgameAnimb;
    SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(es);
    v30 = SuitAnimIndex;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    if ( ci->usingAnimState )
    {
LABEL_121:
      v13 = 0;
      goto LABEL_122;
    }
    if ( !BG_IsThrowOrPrepareAnim(bgameAnimb, SuitAnimIndex) && !BG_IsGestureAnim(bgameAnimb, v30) )
      goto LABEL_109;
    OffHandWeaponForPlayerEntity = BG_GetOffHandWeaponForPlayerEntity(weaponMap, es);
    if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) == WEAPTYPE_GRENADE )
    {
      __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
      if ( (unsigned int)BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.grenade_on, scr_const.grenade_off, rangeExpandh) )
        v14 = 0;
    }
    else if ( BG_IsGestureAnim(bgameAnimb, v30) && playerAnimType == 32 )
    {
      v33 = OffHandWeaponForPlayerEntity->weaponIdx;
      if ( OffHandWeaponForPlayerEntity->weaponIdx )
      {
LABEL_98:
        if ( ci->dualWielding )
        {
          __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
          v34 = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.akimbo_off, scr_const.akimbo_on, rangeExpandj);
          v33 = OffHandWeaponForPlayerEntity->weaponIdx;
          v35 = v34;
          v66 = v34;
        }
        else
        {
          v35 = 0;
        }
        v36 = BG_WeaponDefAtIndex(v33);
        if ( !v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21594, ASSERT_TYPE_ASSERT, "(offhandWeapDef)", (const char *)&queryFormat, "offhandWeapDef") )
          __debugbreak();
        if ( v36->weapType != WEAPTYPE_SCRIPT )
        {
          if ( BG_GetWeaponType(OffHandWeaponForPlayerEntity, 0) == WEAPTYPE_GRENADE && BG_WeaponDoesNotFullyAnimateViewmodelEntityState(es, OffHandWeaponForPlayerEntity, 0) )
          {
            __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
            v67 = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.grenade_on, scr_const.grenade_off, rangeExpandk);
          }
          goto LABEL_108;
        }
        v28 = bgameAnimb;
        if ( BG_IsGestureAnim(bgameAnimb, v30) && v36->scriptedAnimType )
        {
          if ( ci->dualWielding )
            v35 = 1;
          v66 = v35;
          if ( v36->worldModel )
          {
            __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
            v67 = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.show, scr_const.hide, rangeExpandm);
          }
        }
LABEL_109:
        if ( !ci->usingAnimState )
        {
          if ( BG_IsKillstreakTriggerAnim(v28, v30) )
          {
            __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
            v57 = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.phone_on, scr_const.phone_off, rangeExpandl);
          }
          if ( !ci->usingAnimState )
          {
            v13 = 0;
            if ( BG_IsLadderAnim(animNuma, v30) )
              v14 = 1;
            goto LABEL_122;
          }
        }
        goto LABEL_121;
      }
      if ( BG_IsThrowingAxe(&ci->dobjHeldWeapon) )
      {
        __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
        v14 = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.axe_on, scr_const.axe_off, rangeExpandi) == 0;
      }
    }
    v33 = OffHandWeaponForPlayerEntity->weaponIdx;
    if ( !OffHandWeaponForPlayerEntity->weaponIdx )
    {
LABEL_108:
      v28 = bgameAnimb;
      goto LABEL_109;
    }
    goto LABEL_98;
  }
  packedAnimIndex = BG_PlayerASM_GetAnim(es, MOVEMENT);
  Anim = BG_PlayerASM_GetAnim(es, DODGE);
  Animset = BG_PlayerASM_GetAnimset(es);
  v17 = Animset;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( !ci->usingAnimState )
  {
    if ( BG_PlayerASM_IsRocketHideShowAlias(Anim, Animset) )
    {
      __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
      animNum = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.rocket_on, scr_const.rocket_off, rangeExpand) == 0;
    }
    if ( !ci->usingAnimState && (BG_PlayerASM_IsThrowOrPrepareAlias(Anim, v17) || BG_PlayerASM_IsGestureAlias(Anim, v17)) )
    {
      v19 = BG_GetOffHandWeaponForPlayerEntity(weaponMap, es);
      if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) == WEAPTYPE_GRENADE )
      {
        v20 = bgameAnim;
        __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
        if ( !(unsigned int)BG_CheckTorsoAnimForModelVisibility(bgameAnim, es, ci, scr_const.grenade_on, scr_const.grenade_off, rangeExpanda) )
          v14 = 1;
      }
      else if ( BG_PlayerASM_IsGestureAlias(Anim, v17) && v58 == 32 )
      {
        v21 = v19->weaponIdx;
        if ( v19->weaponIdx )
        {
          v20 = bgameAnim;
          goto LABEL_52;
        }
        v20 = bgameAnim;
        if ( BG_IsThrowingAxe(&ci->dobjHeldWeapon) )
        {
          __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
          v14 = BG_CheckTorsoAnimForModelVisibility(bgameAnim, es, ci, scr_const.axe_on, scr_const.axe_off, rangeExpandb) == 0;
        }
      }
      else
      {
        v20 = bgameAnim;
      }
      v21 = v19->weaponIdx;
      if ( !v19->weaponIdx )
      {
LABEL_43:
        v8 = bgameAnim;
LABEL_44:
        v13 = 0;
        goto LABEL_45;
      }
LABEL_52:
      if ( ci->dualWielding )
      {
        __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
        v22 = BG_CheckTorsoAnimForModelVisibility(v20, es, ci, scr_const.akimbo_off, scr_const.akimbo_on, rangeExpandd);
        v21 = v19->weaponIdx;
        v66 = v22;
      }
      v23 = BG_WeaponDefAtIndex(v21);
      if ( !v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21488, ASSERT_TYPE_ASSERT, "(offhandWeapDef)", (const char *)&queryFormat, "offhandWeapDef") )
        __debugbreak();
      if ( v23->weapType == WEAPTYPE_SCRIPT )
      {
        if ( !BG_PlayerASM_IsGestureAlias(Anim, v17) || !v23->scriptedAnimType )
          goto LABEL_43;
        v27 = v66;
        v8 = bgameAnim;
        if ( ci->dualWielding )
          v27 = 1;
        v66 = v27;
        if ( !v23->worldModel )
          goto LABEL_44;
        hide = scr_const.hide;
        show = scr_const.show;
      }
      else
      {
        if ( BG_GetWeaponType(v19, 0) != WEAPTYPE_GRENADE )
          goto LABEL_43;
        DoesNotFullyAnimateViewmodelEntityState = BG_WeaponDoesNotFullyAnimateViewmodelEntityState(es, v19, 0);
        v8 = bgameAnim;
        if ( !DoesNotFullyAnimateViewmodelEntityState )
          goto LABEL_44;
        hide = scr_const.grenade_off;
        show = scr_const.grenade_on;
      }
      __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
      v67 = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, show, hide, rangeExpande);
      goto LABEL_44;
    }
  }
LABEL_45:
  if ( !ci->usingAnimState )
  {
    if ( BG_PlayerASM_IsKillstreakTriggerAlias(Anim, v17) )
    {
      __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
      v57 = BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.phone_on, scr_const.phone_off, rangeExpandc);
    }
    if ( !ci->usingAnimState )
    {
      if ( BG_PlayerASM_IsLadderAlias(Anim, v17) )
      {
        v14 = 1;
      }
      else if ( BG_PlayerASM_IsLadderAimAlias(Anim, v17) )
      {
        v14 = 0;
      }
      else if ( BG_PlayerASM_IsLadderAlias(packedAnimIndex, v17) )
      {
        v14 = 1;
      }
      else if ( BG_PlayerASM_IsLadderAimAlias(packedAnimIndex, v17) )
      {
        v14 = 0;
      }
      if ( !ci->usingAnimState && (BG_PlayerASM_IsRaiseWeaponAlias(Anim, v17) || BG_PlayerASM_IsDropWeaponAlias(Anim, v17)) )
      {
        if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) == WEAPTYPE_EQUIP_DEPLOY )
        {
          __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
          if ( !(unsigned int)BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.gun_on, scr_const.gun_off, rangeExpandf) )
            v14 = 1;
        }
        else if ( BG_GetWeaponType(&ci->dobjHeldWeapon, ci->isUsingWeaponAltMode != 0) != WEAPTYPE_GRENADE )
        {
          __asm { vmovss  [rsp+98h+rangeExpand], xmm6 }
          if ( !(unsigned int)BG_CheckTorsoAnimForModelVisibility(v8, es, ci, scr_const.gun_on, scr_const.gun_off, rangeExpandg) )
          {
            v14 = 1;
            v13 = 1;
          }
        }
      }
    }
  }
  if ( animNum )
  {
    if ( ci->hideRocket )
      goto LABEL_125;
    ci->hideRocket = 1;
    goto LABEL_124;
  }
LABEL_122:
  if ( !ci->hideRocket )
    goto LABEL_125;
  ci->hideRocket = 0;
LABEL_124:
  ci->dobjDirty = 1;
LABEL_125:
  usingThrownWeapon = ci->usingThrownWeapon;
  __asm { vmovaps xmm6, [rsp+98h+var_58] }
  if ( v67 )
  {
    if ( usingThrownWeapon )
      goto LABEL_131;
    ci->usingThrownWeapon = 1;
  }
  else
  {
    if ( !usingThrownWeapon )
      goto LABEL_131;
    ci->usingThrownWeapon = 0;
  }
  ci->dobjDirty = 1;
LABEL_131:
  usingKillstreakTrigger = ci->usingKillstreakTrigger;
  if ( v57 )
  {
    if ( usingKillstreakTrigger )
      goto LABEL_137;
    ci->usingKillstreakTrigger = 1;
  }
  else
  {
    if ( !usingKillstreakTrigger )
      goto LABEL_137;
    ci->usingKillstreakTrigger = 0;
  }
  ci->dobjDirty = 1;
LABEL_137:
  hideLeftHandWeapon = ci->hideLeftHandWeapon;
  if ( v66 )
  {
    if ( hideLeftHandWeapon )
      goto LABEL_143;
    ci->hideLeftHandWeapon = 1;
  }
  else
  {
    if ( !hideLeftHandWeapon )
      goto LABEL_143;
    ci->hideLeftHandWeapon = 0;
  }
  ci->dobjDirty = 1;
LABEL_143:
  hideWeapon = ci->hideWeapon;
  if ( v14 )
  {
    if ( !hideWeapon )
    {
      ci->hideWeapon = 1;
      goto LABEL_148;
    }
  }
  else if ( hideWeapon )
  {
    ci->hideWeapon = 0;
LABEL_148:
    ci->dobjDirty = 1;
  }
  stowHeldWeapon = ci->stowHeldWeapon;
  if ( v13 )
  {
    if ( stowHeldWeapon )
      return;
    ci->stowHeldWeapon = 1;
  }
  else
  {
    if ( !stowHeldWeapon )
      return;
    ci->stowHeldWeapon = 0;
  }
  ci->dobjDirty = 1;
}

/*
==============
BG_UpdateVisibilitySlingBones
==============
*/
void BG_UpdateVisibilitySlingBones(const entityState_t *es, DObj *obj, bool isClientCorpse, const Weapon *r_heldWeapon, const Weapon *r_stowedWeapon, int heldWeaponIndex, int stowedWeaponIndex, unsigned __int16 clientOnly, bool forceShowBones)
{
  char v11; 
  const WeaponDef *v13; 
  unsigned __int16 weaponIdx; 
  char v15; 
  unsigned __int16 v16; 
  char v17; 
  int v18; 
  scr_string_t tag_sling; 
  entityType_s eType; 
  int v21; 
  const scr_string_t **v22; 
  __int64 v23; 
  scr_string_t stowTag; 
  char v25; 
  const scr_string_t **v26; 
  __int64 v27; 
  int modelIndex; 
  unsigned __int8 inOutIndex; 
  bool v30; 

  v30 = isClientCorpse;
  v11 = isClientCorpse;
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5649, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v13 = NULL;
  if ( (_BYTE)clientOnly && Sys_IsServerThread() )
    return;
  weaponIdx = r_heldWeapon->weaponIdx;
  v15 = 0;
  v16 = r_stowedWeapon->weaponIdx;
  v17 = 0;
  clientOnly = weaponIdx;
  if ( v16 )
  {
    v13 = BG_WeaponDefAtIndex(v16);
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5675, ASSERT_TYPE_ASSERT, "(stowedWeapDef)", (const char *)&queryFormat, "stowedWeapDef") )
      __debugbreak();
  }
  if ( weaponIdx )
  {
    v18 = heldWeaponIndex;
    if ( heldWeaponIndex >= 0 )
    {
      tag_sling = scr_const.tag_sling;
      if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_public_inline.h", 89, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
        __debugbreak();
      if ( !tag_sling && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_public_inline.h", 90, ASSERT_TYPE_ASSERT, "(name != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "name != NULL_SCR_STRING") )
        __debugbreak();
      inOutIndex = -2;
      modelIndex = 0;
      if ( DObjGetBoneIndexInternal_19(obj, tag_sling, &inOutIndex, &modelIndex) )
      {
        if ( stowedWeaponIndex < 0 || modelIndex < stowedWeaponIndex )
        {
          if ( modelIndex < v18 )
            Com_PrintWarning(19, "BG_UpdateVisibilitySlingBones(): 'tag_sling' found on the character. It needs to be on the held/stowed weapon models/attachments.");
          else
            v15 = 1;
        }
        else
        {
          v17 = 1;
        }
      }
      v11 = v30;
    }
    weaponIdx = clientOnly;
  }
  LOBYTE(clientOnly) = 0;
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 595, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  eType = es->eType;
  LOBYTE(clientOnly) = 0;
  if ( (unsigned __int16)eType <= ET_AGENT )
  {
    v21 = 131111;
    if ( _bittest(&v21, eType) )
    {
      if ( (((unsigned __int16)es->lerp.u.player.playerFlags >> 5) & 3) != 1 )
      {
        if ( (((unsigned __int16)es->lerp.u.player.playerFlags >> 5) & 3) != 2 )
        {
          if ( (((unsigned __int16)es->lerp.u.player.playerFlags >> 5) & 3) == 3 )
          {
            LOBYTE(clientOnly) = 1;
            goto LABEL_36;
          }
          goto LABEL_45;
        }
        LOBYTE(clientOnly) = 1;
      }
      LOBYTE(clientOnly) = 1;
    }
  }
LABEL_45:
  if ( !weaponIdx && !v16 || !v17 && !v15 || v11 || (!v16 || (stowTag = v13->stowTag, stowTag != scr_const.tag_stowed_chest) && stowTag != scr_const.tag_stowed_chest2 ? (v25 = 0) : (v25 = 1), !v15 && (!v25 || !v17)) )
  {
LABEL_36:
    if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5750, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( DObjHasProceduralBones(obj) )
    {
      v22 = SLING_HIDE_BONES;
      v23 = 6i64;
      do
      {
        BG_HideBoneByModelRange(**v22++, obj, &obj->hidePartBits, 0, -1);
        --v23;
      }
      while ( v23 );
    }
    return;
  }
  if ( forceShowBones )
  {
    if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5750, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( DObjHasProceduralBones(obj) )
    {
      v26 = SLING_HIDE_BONES;
      v27 = 6i64;
      do
      {
        BG_ShowBoneByModelRange(**v26++, obj, &obj->hidePartBits, 0, -1);
        --v27;
      }
      while ( v27 );
    }
  }
}

/*
==============
BG_UpdateWeaponCosmeticBones
==============
*/
void BG_UpdateWeaponCosmeticBones(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  __int64 v9; 
  XModel **viewModelVariations; 
  XModel *v11; 
  scr_string_t tag_cosmetic; 
  int v13; 
  int v14; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_VISUAL);
  if ( WeaponPrimaryAttachment && (v9 = r_weapon->attachmentVariationIndices[12], (int)v9 < (signed int)WeaponPrimaryAttachment->numModelVariations) && (viewModelVariations = WeaponPrimaryAttachment->viewModelVariations, (v11 = viewModelVariations[v9]) != NULL) && DObjGetModelIndex(obj, viewModelVariations[v9]) != -1 )
  {
    if ( WeaponPrimaryAttachment->attachPoint == scr_const.tag_cosmetic )
      goto LABEL_13;
    if ( !v11->numBones )
    {
      v14 = 0;
      v13 = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 173, ASSERT_TYPE_ASSERT, "(unsigned)( boneIndex ) < (unsigned)( model->numBones )", "boneIndex doesn't index model->numBones\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    if ( !v11->boneNames && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 174, ASSERT_TYPE_ASSERT, "(model->boneNames)", (const char *)&queryFormat, "model->boneNames") )
      __debugbreak();
    tag_cosmetic = scr_const.tag_cosmetic;
    if ( *v11->boneNames == scr_const.tag_cosmetic )
    {
LABEL_13:
      BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_cosmetic, obj, &obj->hidePartBits, startModel, lastModelInclusive);
      return;
    }
  }
  else
  {
    tag_cosmetic = scr_const.tag_cosmetic;
  }
  BG_HideBoneByModelRange(tag_cosmetic, obj, &obj->hidePartBits, startModel, lastModelInclusive);
}

/*
==============
BG_UpdateWeaponGlass
==============
*/

void __fastcall BG_UpdateWeaponGlass(double adsFrac, DObj *const obj, const bool adsSmoothFade)
{
  const dvar_t *v7; 
  const dvar_t *v8; 
  DObjPartBits *v9; 
  const dvar_t *v10; 
  DObjPartBits *v11; 
  scr_string_t tag_glass_hip2; 
  DObjPartBits *p_hidePartBits; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm0
  }
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5595, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v7 = DCONST_DVARBOOL_bg_debugWeaponGlass;
  if ( !DCONST_DVARBOOL_bg_debugWeaponGlass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_debugWeaponGlass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
  {
    p_hidePartBits = &obj->hidePartBits;
    if ( !adsSmoothFade )
    {
      BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, p_hidePartBits, 0, -1);
      BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
      BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, &obj->hidePartBits, 0, -1);
      tag_glass_hip2 = scr_const.tag_glass_hip2;
      goto LABEL_24;
    }
    __asm { vcomiss xmm6, cs:__real@3f800000 }
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, p_hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm6, xmm0
    }
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, &obj->hidePartBits, 0, -1);
LABEL_19:
    tag_glass_hip2 = scr_const.tag_glass_ads2;
LABEL_24:
    BG_ShowBoneByModelRange(tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
    goto LABEL_25;
  }
  v8 = DCONST_DVARBOOL_bg_showWeaponGlassHip;
  if ( !DCONST_DVARBOOL_bg_showWeaponGlassHip && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassHip") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  v9 = &obj->hidePartBits;
  if ( v8->current.enabled )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, v9, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, v9, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  v10 = DCONST_DVARBOOL_bg_showWeaponGlassADS;
  if ( !DCONST_DVARBOOL_bg_showWeaponGlassADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassADS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  v11 = &obj->hidePartBits;
  if ( v10->current.enabled )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, v11, 0, -1);
    goto LABEL_19;
  }
  BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, v11, 0, -1);
  BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
LABEL_25:
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
BG_UpdateWeaponGlassDebug
==============
*/
void BG_UpdateWeaponGlassDebug(const float adsFrac, DObj *const obj)
{
  const dvar_t *v2; 
  DObjPartBits *p_hidePartBits; 
  const dvar_t *v5; 
  DObjPartBits *v6; 

  v2 = DCONST_DVARBOOL_bg_showWeaponGlassHip;
  if ( !DCONST_DVARBOOL_bg_showWeaponGlassHip && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassHip") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  p_hidePartBits = &obj->hidePartBits;
  if ( v2->current.enabled )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, p_hidePartBits, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip, obj, p_hidePartBits, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_hip2, obj, &obj->hidePartBits, 0, -1);
  }
  v5 = DCONST_DVARBOOL_bg_showWeaponGlassADS;
  if ( !DCONST_DVARBOOL_bg_showWeaponGlassADS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_showWeaponGlassADS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v6 = &obj->hidePartBits;
  if ( v5->current.enabled )
  {
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, v6, 0, -1);
    BG_ShowBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
  }
  else
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads, obj, v6, 0, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_glass_ads2, obj, &obj->hidePartBits, 0, -1);
  }
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObj
==============
*/
void BG_UpdateWeaponHidePartBitsForDObj(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel)
{
  const dvar_t *v8; 
  unsigned __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 outHideTagCount; 
  scr_string_t outHideTagBuffer[324]; 

  if ( !obj )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5794, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5774, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
  }
  v8 = DCONST_DVARMPBOOL_player_isInZeroGLevel;
  if ( !DCONST_DVARMPBOOL_player_isInZeroGLevel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_isInZeroGLevel") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off, obj, &obj->hidePartBits, startModel, -1);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off2, obj, &obj->hidePartBits, startModel, -1);
  }
  v9 = 0i64;
  outHideTagCount = 0i64;
  BG_GetWeaponExplicitHideTags(r_weapon, 0, isViewModel, 0x142ui64, outHideTagBuffer, &outHideTagCount);
  v10 = outHideTagCount;
  if ( outHideTagCount )
  {
    do
      BG_HideBoneByModelRange(outHideTagBuffer[v9++], obj, &obj->hidePartBits, startModel, -1);
    while ( v9 < v10 );
  }
}

/*
==============
BG_UpdateWeaponHidePartBitsForDObjByModelRange
==============
*/
void BG_UpdateWeaponHidePartBitsForDObjByModelRange(DObj *obj, const Weapon *r_weapon, const bool isViewModel, int startModel, int lastModelInclusive)
{
  const dvar_t *v9; 
  unsigned __int64 v10; 
  unsigned __int64 v11; 
  unsigned __int64 outHideTagCount; 
  scr_string_t outHideTagBuffer[324]; 

  if ( !obj )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5794, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5774, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
  }
  v9 = DCONST_DVARMPBOOL_player_isInZeroGLevel;
  if ( !DCONST_DVARMPBOOL_player_isInZeroGLevel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_isInZeroGLevel") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
  {
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
    BG_HideBoneByModelRange((const scr_string_t)scr_const.tag_zerog_off2, obj, &obj->hidePartBits, startModel, lastModelInclusive);
  }
  v10 = 0i64;
  outHideTagCount = 0i64;
  BG_GetWeaponExplicitHideTags(r_weapon, 0, isViewModel, 0x142ui64, outHideTagBuffer, &outHideTagCount);
  v11 = outHideTagCount;
  if ( outHideTagCount )
  {
    do
      BG_HideBoneByModelRange(outHideTagBuffer[v10++], obj, &obj->hidePartBits, startModel, lastModelInclusive);
    while ( v10 < v11 );
  }
}

/*
==============
BG_UpdatedWeaponBones
==============
*/
void BG_UpdatedWeaponBones(const Weapon *r_weapon, DObj *obj, int startModel)
{
  BG_UpdateWeaponCosmeticBones(r_weapon, obj, startModel, -1);
  BG_UpdatedWeaponIronSightBones(r_weapon, obj, startModel, -1);
}

/*
==============
BG_UpdatedWeaponBonesByModelRange
==============
*/
void BG_UpdatedWeaponBonesByModelRange(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  BG_UpdateWeaponCosmeticBones(r_weapon, obj, startModel, lastModelInclusive);
  BG_UpdatedWeaponIronSightBones(r_weapon, obj, startModel, lastModelInclusive);
}

/*
==============
BG_UpdatedWeaponIronSightBones
==============
*/
void BG_UpdatedWeaponIronSightBones(const Weapon *r_weapon, DObj *obj, int startModel, int lastModelInclusive)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v9; 
  AttSight *sight; 
  const WeaponAttachment *v11; 
  AttSight *v12; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( (WeaponPrimaryAttachment || (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)) != NULL) && WeaponPrimaryAttachment->ignoreIronSights )
  {
    BG_ShowIronSights(obj, startModel, lastModelInclusive);
    return;
  }
  v9 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( v9 )
  {
    sight = v9->sight;
    if ( sight && sight->hideRailWithThisScope )
    {
      BG_HideIronSights(obj, startModel, lastModelInclusive, 1);
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  if ( BG_HasUnderbarrelAmmo(r_weapon) && BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)->hideIronSightsWithThisAttachment )
  {
LABEL_12:
    BG_HideIronSights(obj, startModel, lastModelInclusive, 0);
    goto LABEL_14;
  }
  BG_ShowIronSights(obj, startModel, lastModelInclusive);
LABEL_14:
  v11 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE);
  if ( v11 || (v11 = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)) != NULL )
  {
    v12 = v11->sight;
    if ( v12 )
    {
      if ( v12->forceIronSightDown )
      {
        if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 5212, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
          __debugbreak();
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_off, obj, &obj->hidePartBits, startModel, lastModelInclusive);
        BG_HideBoneByModelRange((const scr_string_t)scr_const.ironsight2_on, obj, &obj->hidePartBits, startModel, lastModelInclusive);
      }
    }
  }
}

/*
==============
BG_UseADSFireAnim
==============
*/
char BG_UseADSFireAnim(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v6; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v9; 

  _RBX = ps;
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13762, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13763, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, _RBX);
  v6 = BG_UsingAlternate(_RBX);
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RBX->weapCommon.weapFlags, GameModeFlagValues::ms_mpValue, 0x36u) )
    return 1;
  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( _RBX && !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13726, ASSERT_TYPE_ASSERT, "(!ps || weaponMap)", (const char *)&queryFormat, "!ps || weaponMap") )
    __debugbreak();
  _RBP = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx);
  v9 = _RBX && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, _RBX, CurrentWeaponForPlayer)) != NULL && EquippedWeaponStateConst->hybridScope;
  __asm { vmovss  xmm6, dword ptr [rbp+678h] }
  if ( BG_GetWeaponAdsSettings(CurrentWeaponForPlayer, v6, v9, 0) )
    __asm { vmovss  xmm6, dword ptr [rax+0B8h] }
  __asm
  {
    vcomiss xmm6, dword ptr [rbx+730h]
    vmovaps xmm6, [rsp+48h+var_18]
  }
  return 0;
}

/*
==============
BG_UseAngularGunKick
==============
*/
_BOOL8 BG_UseAngularGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useAngularGunKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttGunKick *AttachmentGunKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useAngularGunKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useAngularGunKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useAngularGunKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14493, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentGunKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useAngularGunKick;
  }
  return AttachmentGunKick->useAngularGunKick;
}

/*
==============
BG_UseAngularViewKick
==============
*/
_BOOL8 BG_UseAngularViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useAngularViewKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttViewKick *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useAngularViewKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useAngularViewKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useAngularViewKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14516, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentViewKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useAngularViewKick;
  }
  return AttachmentViewKick->useAngularViewKick;
}

/*
==============
BG_UseFastADSAnims
==============
*/
bool BG_UseFastADSAnims(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttMovement *movement; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v4 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8256, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    movement = (*i)->movement;
    if ( movement )
      break;
    movement = (*i)->movementScale;
    if ( movement )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return 0;
  }
  return movement->fastADS3PAnims;
}

/*
==============
BG_UseFastOffhand
==============
*/
bool BG_UseFastOffhand(const playerState_s *ps, const BgWeaponMap *weaponMap)
{
  const Weapon *OffHandWeaponForPlayer; 
  bool v5; 
  bool result; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10792, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  result = 0;
  if ( BG_HasPerk(&ps->perks, 0x15u) )
  {
    OffHandWeaponForPlayer = BG_GetOffHandWeaponForPlayer(weaponMap, ps);
    v5 = BG_UsingAlternate(ps);
    if ( BG_InheritsPerks(OffHandWeaponForPlayer, v5) )
      return 1;
  }
  return result;
}

/*
==============
BG_UseFastReload
==============
*/
bool BG_UseFastReload(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10811, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return (BG_HasPerk(&ps->perks, 1u) || BG_GameInterface_HasFastReloadPerkVariant(&ps->perks)) && BG_InheritsPerks(r_weapon, isAlternate);
}

/*
==============
BG_UseFastReloadAnims
==============
*/
bool BG_UseFastReloadAnims(const playerState_s *ps, const BgHandler *pmoveHandler, const Weapon *r_weapon, bool isAlternate, PlayerHandIndex hand, int ammoInClip, weapAnimFiles_t reloadAnimFile)
{
  bool result; 
  int v12; 
  char v13; 
  int v14; 
  const PlayerWeaponAnimArrays *v15; 
  XAnimParts *const *altAnimArray; 
  int v17; 
  int v20[282]; 
  int v23; 
  int v24; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10917, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_UseFastReload(ps, r_weapon, isAlternate) || (result = BG_UseFastReloadLowAmmo(ps, r_weapon, isAlternate, ammoInClip)) )
  {
    if ( (unsigned int)(reloadAnimFile - 381) > 7 )
    {
      if ( (unsigned int)(reloadAnimFile - 389) > 7 )
      {
        if ( (unsigned int)(reloadAnimFile - 286) > 0x11 )
        {
          v12 = 0;
          if ( (unsigned int)(reloadAnimFile - 304) <= 0x11 )
            v12 = 2;
        }
        else
        {
          v12 = 1;
        }
        v13 = 0;
      }
      else
      {
        v12 = 4;
        v13 = 1;
      }
    }
    else
    {
      v12 = 3;
      v13 = 1;
    }
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10929, ASSERT_TYPE_ASSERT, "(reloadAnimFileType != RELOAD_ANIM_FILE_TYPE_INVALID)", (const char *)&queryFormat, "reloadAnimFileType != RELOAD_ANIM_FILE_TYPE_INVALID") )
      __debugbreak();
    v14 = BG_PlayerDualWielding(ps);
    v15 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
    altAnimArray = (XAnimParts *const *)v15;
    if ( v14 && hand == WEAPON_HAND_LEFT || isAlternate )
      altAnimArray = v15->altAnimArray;
    if ( v13 )
    {
      if ( v12 == 3 )
      {
        v17 = g_reloadMultipleFastAnimMap[reloadAnimFile - 381];
        return BG_WeaponAnimExists(altAnimArray, v17) != 0;
      }
    }
    else if ( v12 == 1 )
    {
      __asm
      {
        vmovaps ymm0, cs:__ymm@0000013700000136000001350000013400000133000001320000013100000130
        vmovups [rsp+0D8h+var_A8], ymm0
        vmovaps ymm0, cs:__ymm@0000013f0000013e0000013d0000013c0000013b0000013a0000013900000138
        vmovups [rsp+0D8h+var_88], ymm0
      }
      v23 = 320;
      v24 = 321;
      v17 = v20[reloadAnimFile];
      return BG_WeaponAnimExists(altAnimArray, v17) != 0;
    }
    v17 = reloadAnimFile;
    return BG_WeaponAnimExists(altAnimArray, v17) != 0;
  }
  return result;
}

/*
==============
BG_UseFastReloadLowAmmo
==============
*/
bool BG_UseFastReloadLowAmmo(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, int ammoInClip)
{
  const dvar_t *v8; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10829, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !BG_HasPerk(&ps->perks, 2u) || !BG_InheritsPerks(r_weapon, isAlternate) )
    return 0;
  v8 = DVARBOOL_perk_weapReloadMultiplierEmptyOnLowAmmo;
  if ( !DVARBOOL_perk_weapReloadMultiplierEmptyOnLowAmmo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_weapReloadMultiplierEmptyOnLowAmmo") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
    return ammoInClip <= BG_GetClipLowAmmo(ps, r_weapon, isAlternate);
  else
    return ammoInClip == 0;
}

/*
==============
BG_UseLeftTriggerAltFireMode
==============
*/
bool BG_UseLeftTriggerAltFireMode(const Weapon *r_weapon)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 

  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  return WeaponPrimaryAttachment && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE && WeaponPrimaryAttachment->useLeftTriggerAltFire;
}

/*
==============
BG_UseQuickSwitchAnims
==============
*/
bool BG_UseQuickSwitchAnims(const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding, const BgHandler *pmoveHandler, const bool checkRaise)
{
  unsigned __int16 WeaponFieldTimeWithDependentAnimation; 
  const PlayerWeaponAnimArrays *v11; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19169, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( checkRaise )
    WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 144i64, NUM_WEAP_ANIMS);
  else
    WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 142i64, NUM_WEAP_ANIMS);
  if ( WeaponFieldTimeWithDependentAnimation )
  {
    v11 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19179, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
      __debugbreak();
    if ( isAlternate )
      v11 = (const PlayerWeaponAnimArrays *)((char *)v11 + 4976);
    LOBYTE(WeaponFieldTimeWithDependentAnimation) = v11->normalAnimArray[!checkRaise + 333] != NULL;
  }
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_UseScopeDrift
==============
*/
_BOOL8 BG_UseScopeDrift(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  bool v5; 
  const Weapon *CurrentWeaponForPlayer; 
  int v7; 
  bool useScopeDrift; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttSight *sight; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2901, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2902, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActive(ps) )
    return 0i64;
  v5 = BG_UsingAlternate(ps);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_HIGH|WEAPON_LADDER_AIM) )
  {
    v7 = 0;
    useScopeDrift = BG_WeaponDefAtIndex(CurrentWeaponForPlayer->weaponIdx)->useScopeDrift;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(CurrentWeaponForPlayer, v5, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2923, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        sight = (*i)->sight;
        if ( sight )
          break;
        if ( ++v7 >= WeaponAttachments_Internal )
          return useScopeDrift;
      }
      return sight->useScopeDrift;
    }
    return useScopeDrift;
  }
  else
  {
    return BG_UsingSniperScope(weaponMap, ps) && BG_GetWeaponClass(CurrentWeaponForPlayer, v5) != WEAPCLASS_ITEM;
  }
}

/*
==============
BG_UseSmoothGunKick
==============
*/
_BOOL8 BG_UseSmoothGunKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useNewGunKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttGunKick *AttachmentGunKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useNewGunKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useNewGunKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useNewGunKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14447, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentGunKick = BG_GetAttachmentGunKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentGunKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useNewGunKick;
  }
  return AttachmentGunKick->useNewGunKick;
}

/*
==============
BG_UseSmoothViewKick
==============
*/
_BOOL8 BG_UseSmoothViewKick(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  int v8; 
  bool useNewViewKick; 
  unsigned int WeaponAttachments_Internal; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v12; 
  const WeaponAttachment **i; 
  AttViewKick *AttachmentViewKick; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v8 = 0;
  useNewViewKick = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->useNewViewKick;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v12 = ps && weaponMap && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, r_weapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( !WeaponAttachments_Internal )
    return useNewViewKick;
  for ( i = (const WeaponAttachment **)attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14470, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    AttachmentViewKick = BG_GetAttachmentViewKick(weaponMap, ps, r_weapon, isAlternate, *i, v12);
    if ( AttachmentViewKick )
      break;
    if ( ++v8 >= WeaponAttachments_Internal )
      return useNewViewKick;
  }
  return AttachmentViewKick->useNewViewKick;
}

/*
==============
BG_UsesContinousAdsIdleTransiton
==============
*/
_BOOL8 BG_UsesContinousAdsIdleTransiton(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  WeaponAttachment *v6; 
  AttIdleSettings *idleSettings; 
  const WeaponDef *v8; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      v6 = *v5;
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12228, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      idleSettings = v6->idleSettings;
      if ( idleSettings )
        return idleSettings->useUninterruptedAdsIdleMotion;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v8 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 12236, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v8->useUninterruptedAdsIdleMotion;
  }
}

/*
==============
BG_UsesReverseWeaponSpread
==============
*/
char BG_UsesReverseWeaponSpread(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  char v7; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v13[32]; 

  v2 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, v13, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 13780, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      _RCX = (*v5)->hipSpread;
      v7 = 0;
      if ( _RCX )
        break;
      ++v2;
      ++v5;
      if ( v2 >= WeaponAttachments_Internal )
        goto LABEL_8;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+14h]
      vcomiss xmm0, dword ptr [rcx]
    }
  }
  else
  {
LABEL_8:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm
    {
      vmovss  xmm0, dword ptr [rax+4F0h]
      vcomiss xmm0, dword ptr [rax+4DCh]
    }
  }
  return v7;
}

/*
==============
BG_UsesShelvedDamageFalloff
==============
*/
bool BG_UsesShelvedDamageFalloff(const WeaponDamageCalcType damageCalcType, const Weapon *r_weapon, bool isAlternate)
{
  __int64 v9; 
  unsigned int v11; 
  unsigned int WeaponAttachments_Internal; 
  bool v13; 
  bool v14; 
  bool v19; 
  bool v20; 
  WeaponAttachment **v21; 
  bool v23; 
  bool v24; 
  bool result; 
  __int64 numAttachmentSlots; 
  AttachmentSlot *attachmentSlots; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm6
    vmovaps xmmword ptr [r11-68h], xmm8
  }
  v9 = damageCalcType;
  __asm { vmovaps xmmword ptr [r11-58h], xmm7 }
  if ( (unsigned int)damageCalcType >= WEAP_DMG_CALC_TYPE_NUM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9251, ASSERT_TYPE_ASSERT, "(unsigned)( damageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "damageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", damageCalcType, 3) )
    __debugbreak();
  _RBX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v11 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v13 = (unsigned int)v9 < 3;
  if ( (unsigned int)v9 >= 3 )
  {
    LODWORD(attachmentSlots) = 3;
    LODWORD(numAttachmentSlots) = v9;
    v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots);
    v13 = 0;
    if ( v14 )
      __debugbreak();
  }
  _R14 = 5 * v9;
  __asm
  {
    vmovss  xmm7, dword ptr [rbx+r14*8+0E4h]
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm7, xmm8
  }
  if ( v13 )
    __asm { vmovss  xmm7, dword ptr [rbx+0E4h] }
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+r14*8+0D4h]
    vcomiss xmm6, xmm8
  }
  if ( v13 )
    __asm { vmovss  xmm6, dword ptr [rbx+0D4h] }
  v19 = WeaponAttachments_Internal == 0;
  v20 = WeaponAttachments_Internal == 0;
  if ( WeaponAttachments_Internal )
  {
    v21 = attachments;
    while ( 1 )
    {
      if ( !*v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9269, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v21)->damage )
        break;
      ++v11;
      ++v21;
      v19 = v11 == WeaponAttachments_Internal;
      v20 = v11 <= WeaponAttachments_Internal;
      if ( v11 >= WeaponAttachments_Internal )
        goto LABEL_26;
    }
    v23 = (unsigned int)v9 < 3;
    v19 = (_DWORD)v9 == 3;
    v20 = (unsigned int)v9 <= 3;
    if ( (unsigned int)v9 >= 3 )
    {
      LODWORD(attachmentSlots) = 3;
      LODWORD(numAttachmentSlots) = v9;
      v24 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 8731, ASSERT_TYPE_ASSERT, "(unsigned)( preferredDamageCalcType ) < (unsigned)( WEAP_DMG_CALC_TYPE_NUM )", "preferredDamageCalcType doesn't index WEAP_DMG_CALC_TYPE_NUM\n\t%i not in [0, %i)", numAttachmentSlots, attachmentSlots);
      v23 = 0;
      v19 = !v24;
      v20 = !v24;
      if ( v24 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm7, dword ptr [rdi+r14*8+24h]
      vcomiss xmm7, xmm8
    }
    if ( v23 )
      __asm { vmovss  xmm7, dword ptr [rdi+24h] }
    __asm
    {
      vmovss  xmm6, dword ptr [rdi+r14*8+14h]
      vcomiss xmm6, xmm8
    }
    if ( v23 )
      __asm { vmovss  xmm6, dword ptr [rdi+14h] }
  }
LABEL_26:
  __asm
  {
    vucomiss xmm7, xmm8
    vmovaps xmm7, [rsp+1C8h+var_58]
  }
  if ( !v19 )
    goto LABEL_29;
  __asm { vcomiss xmm6, xmm8 }
  if ( v20 )
LABEL_29:
    result = 0;
  else
    result = 1;
  __asm
  {
    vmovaps xmm6, [rsp+1C8h+var_48]
    vmovaps xmm8, [rsp+1C8h+var_68]
  }
  return result;
}

/*
==============
BG_UsingSniperScope
==============
*/
_BOOL8 BG_UsingSniperScope(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v8; 
  char v23; 
  char v24; 
  const Weapon *v25; 
  bool v26; 
  const ADSOverlay *Overlay; 
  _BOOL8 result; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 

  __asm
  {
    vmovaps [rsp+68h+var_28], xmm6
    vmovaps [rsp+68h+var_38], xmm7
  }
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2802, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2803, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v8 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(weaponMap, ps, CurrentWeaponForPlayer, v8, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm1, xmm7; maxAbsValueSize
  }
  *(double *)&_XMM0 = MSG_UnpackUnsignedFloat(ps->weapCommon.lastReloadFraction, *(float *)&_XMM1, 6u);
  __asm
  {
    vmovaps xmm2, xmm0
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
  }
  if ( ps->weapCommon.lastReloadStateChangeWasReloading )
  {
    __asm
    {
      vmulss  xmm1, xmm0, [rsp+68h+arg_0]
      vaddss  xmm0, xmm1, xmm2
    }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm0, [rsp+68h+outAdsTransInSpeedMs]
      vsubss  xmm0, xmm2, xmm0; val
    }
  }
  __asm
  {
    vmovaps xmm2, xmm7; max
    vxorps  xmm1, xmm1, xmm1; min
    vxorps  xmm6, xmm6, xmm6
  }
  I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vsubss  xmm1, xmm7, xmm0
    vmulss  xmm0, xmm1, dword ptr [rdi+730h]; val
    vxorps  xmm1, xmm1, xmm1; min
    vmovaps xmm2, xmm7; max
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vcomiss xmm0, xmm6 }
  if ( v23 | v24 )
  {
    result = 0i64;
  }
  else
  {
    v25 = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
    v26 = BG_UsingAlternate(ps);
    Overlay = BG_GetOverlay(v25, v26);
    if ( !Overlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2809, ASSERT_TYPE_ASSERT, "(overlay)", (const char *)&queryFormat, "overlay") )
      __debugbreak();
    result = Overlay->reticle != WEAPOVERLAYRETICLE_NONE;
  }
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_28]
    vmovaps xmm7, [rsp+68h+var_38]
  }
  return result;
}

/*
==============
BG_VMProjBodyEffect
==============
*/
FxCombinedDef BG_VMProjBodyEffect(const Weapon *r_weapon, bool isAlternate)
{
  int v4; 
  const ParticleSystemDef *particleSystemDef; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = 0;
  particleSystemDef = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->vmProjBodyEffect.particleSystemDef;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (FxCombinedDef)particleSystemDef;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17549, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v4 >= WeaponAttachments_Internal )
      return (FxCombinedDef)particleSystemDef;
  }
  return (FxCombinedDef)projectile->vmProjBodyEffect.particleSystemDef;
}

/*
==============
BG_ValidateWeapon
==============
*/
char BG_ValidateWeapon(const Weapon *r_weapon)
{
  AttachmentSlot v2; 
  const WeaponCompleteDef *v3; 
  bool v4; 
  unsigned __int16 v5; 

  if ( !BG_WeaponSetup_Initialized() )
    return 1;
  if ( r_weapon->weaponIdx >= BG_GetNumWeapons() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3480, ASSERT_TYPE_ASSERT, "(BG_ValidateWeaponNumber( r_weapon ))", (const char *)&queryFormat, "BG_ValidateWeaponNumber( r_weapon )") )
    __debugbreak();
  if ( !r_weapon->weaponIdx )
    return 1;
  v2 = ATT_SLOT_RECEIVER;
  v3 = BG_WeaponCompleteDef(r_weapon, 0);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3488, ASSERT_TYPE_ASSERT, "( ( weapCompleteDef != nullptr ) )", "( weapCompleteDef ) = %p", NULL) )
    __debugbreak();
  v4 = 1;
  while ( 1 )
  {
    if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
      __debugbreak();
    v5 = v2 == ATT_SLOT_VISUAL ? r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8) : r_weapon->weaponAttachments[v2];
    if ( !BG_ValidateWeaponAttachment(v3, v2, v5) )
      break;
    v4 = ++v2 < ATT_SLOT_OTHER;
    if ( (unsigned int)v2 >= ATT_SLOT_OTHER )
    {
      LOWORD(_EBX) = r_weapon->weaponOthers;
      if ( !(_WORD)_EBX )
        return 1;
      while ( 1 )
      {
        _EBX = (unsigned __int16)_EBX;
        __asm { tzcnt   edi, ebx }
        if ( _EDI > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)_EDI, "unsigned", _EDI) )
          __debugbreak();
        if ( !BG_ValidateWeaponAttachment(v3, ATT_SLOT_OTHER, (unsigned __int8)_EDI) )
          break;
        _EBX = (unsigned __int16)_EBX ^ (1 << _EDI);
        if ( !(_WORD)_EBX )
          return 1;
      }
      return 0;
    }
  }
  return 0;
}

/*
==============
BG_ValidateWeaponAttachment
==============
*/
char BG_ValidateWeaponAttachment(const WeaponCompleteDef *const weapCompleteDef, const AttachmentSlot slot, const unsigned __int16 weaponAttachmentIndex)
{
  __int64 v3; 
  AttachmentList *v5; 
  const char *v6; 
  const dvar_t *v7; 
  char *fmt; 
  __int64 v10; 
  int v11; 
  unsigned int attachmentCount; 

  v3 = slot;
  if ( !weaponAttachmentIndex )
    return 1;
  v5 = &weapCompleteDef->attachments[slot];
  if ( (const WeaponCompleteDef *const)((char *)weapCompleteDef + 16 * slot) == (const WeaponCompleteDef *const)-40i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3453, ASSERT_TYPE_ASSERT, "( ( attachmentList != nullptr ) )", "( attachmentList ) = %p", &weapCompleteDef->attachments[slot]) )
    __debugbreak();
  if ( weaponAttachmentIndex <= v5->attachmentCount )
    return 1;
  if ( (unsigned int)v3 >= 0xE )
  {
    v11 = 14;
    LODWORD(v10) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 155, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( ( sizeof( *array_counter( ATTACHMENT_SLOT_NAMES ) ) + 0 ) )", "slot doesn't index ARRAY_COUNT( ATTACHMENT_SLOT_NAMES )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  v6 = off_147EBF7B0[v3];
  v7 = DCONST_DVARBOOL_bg_weapons_pedantic;
  if ( !DCONST_DVARBOOL_bg_weapons_pedantic && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_weapons_pedantic") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( v7->current.enabled )
  {
    attachmentCount = v5->attachmentCount;
    LODWORD(v10) = weaponAttachmentIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 167, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "WARNING: Attachment index %u in slot %s is out of bounds (%u)!\n", v10, v6, attachmentCount) )
      __debugbreak();
  }
  LODWORD(fmt) = v5->attachmentCount;
  Com_PrintWarning(17, "WARNING: Attachment index %u in slot %s is out of bounds (%u)!\n", weaponAttachmentIndex, v6, fmt);
  return 0;
}

/*
==============
BG_ValidateWeaponNumber
==============
*/
bool BG_ValidateWeaponNumber(const Weapon *r_weapon)
{
  return r_weapon->weaponIdx < BG_GetNumWeapons();
}

/*
==============
BG_ValidateWeaponNumberOffhand
==============
*/
bool BG_ValidateWeaponNumberOffhand(const Weapon *r_weapon)
{
  unsigned int weaponIdx; 
  OffhandClass offhandClass; 
  bool result; 

  weaponIdx = r_weapon->weaponIdx;
  result = 0;
  if ( weaponIdx < BG_GetNumWeapons() )
  {
    if ( !(_WORD)weaponIdx )
      return 1;
    offhandClass = BG_WeaponDefAtIndex(weaponIdx)->offhandClass;
    if ( offhandClass )
    {
      if ( offhandClass < OFFHAND_CLASS_COUNT )
        return 1;
    }
  }
  return result;
}

/*
==============
BG_ViewFlashADSEffect
==============
*/
FxCombinedDef BG_ViewFlashADSEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v8; 
  FxCombinedDef result; 
  bitarray<64> v10; 

  v10 = perks;
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v8 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_12;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v8 & 0x1F)) & v10.array[v8 >> 5]) == 0 || (result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 56i64).particleSystemDef) == NULL )
  {
LABEL_12:
    if ( !isFirstFlash )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 16i64);
    result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 40i64).particleSystemDef;
    if ( !result.particleSystemDef )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 16i64);
  }
  return result;
}

/*
==============
BG_ViewFlashEffect
==============
*/
FxCombinedDef BG_ViewFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v8; 
  FxCombinedDef result; 
  bitarray<64> v10; 

  v10 = perks;
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v8 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_12;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v8 & 0x1F)) & v10.array[v8 >> 5]) == 0 || (result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 48i64).particleSystemDef) == NULL )
  {
LABEL_12:
    if ( !isFirstFlash )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 0i64);
    result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 24i64).particleSystemDef;
    if ( !result.particleSystemDef )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 0i64);
  }
  return result;
}

/*
==============
BG_ViewLastShotEjectEffect
==============
*/
FxCombinedDef BG_ViewLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 88i64);
}

/*
==============
BG_ViewMagEjectEffect
==============
*/
FxCombinedDef BG_ViewMagEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 104i64);
}

/*
==============
BG_ViewModelAnimExists
==============
*/
_BOOL8 BG_ViewModelAnimExists(const playerState_s *ps, weapAnimFiles_t anim, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  __int64 v4; 
  const PlayerWeaponAnimArrays *v8; 
  bool v9; 
  __int64 v11; 

  v4 = anim;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2761, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v4 >= 0x260 )
  {
    LODWORD(v11) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2762, ASSERT_TYPE_ASSERT, "(unsigned)( anim ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "anim doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v11, 608) )
      __debugbreak();
  }
  v8 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2765, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v9 = BG_PlayerDualWielding(ps) != 0;
  if ( BG_UsingAlternate(ps) )
  {
    if ( !v9 )
    {
LABEL_15:
      v8 = (const PlayerWeaponAnimArrays *)((char *)v8 + 4976);
      return v8->normalAnimArray[v4] != NULL;
    }
  }
  else if ( !v9 )
  {
    return v8->normalAnimArray[v4] != NULL;
  }
  if ( hand == WEAPON_HAND_LEFT )
    goto LABEL_15;
  return v8->normalAnimArray[v4] != NULL;
}

/*
==============
BG_ViewModelBlendSpaceExists
==============
*/
_BOOL8 BG_ViewModelBlendSpaceExists(const playerState_s *ps, WeaponBlendSpaceType blendSpaceType, const BgHandler *pmoveHandler)
{
  __int64 v3; 
  const PlayerWeaponAnimArrays *v6; 
  __int64 v8; 

  v3 = blendSpaceType;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2784, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2785, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  if ( (unsigned int)v3 >= 8 )
  {
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2786, ASSERT_TYPE_ASSERT, "(unsigned)( blendSpaceType ) < (unsigned)( WEAPON_BLEND_SPACE_COUNT )", "blendSpaceType doesn't index WEAPON_BLEND_SPACE_COUNT\n\t%i not in [0, %i)", v8, 8) )
      __debugbreak();
  }
  v6 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2789, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  return v6->blendSpaces[v3] != NULL;
}

/*
==============
BG_ViewShellEjectEffect
==============
*/
FxCombinedDef BG_ViewShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 72i64);
}

/*
==============
BG_WalkLoopTime
==============
*/
__int64 BG_WalkLoopTime(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate, bool isDualWielding)
{
  unsigned int WeaponFieldTimeWithDependentAnimation; 
  unsigned int AnimTime; 

  WeaponFieldTimeWithDependentAnimation = BG_GetWeaponFieldTimeWithDependentAnimation(ps, r_weapon, isAlternate, isDualWielding, 176i64, NUM_WEAP_ANIMS);
  AnimTime = BG_Suit_GetAnimTime(ps, r_weapon, WEAP_ANIM_ADDITIVE_WALK_START, isAlternate, isDualWielding, NULL);
  if ( AnimTime )
    return AnimTime;
  return WeaponFieldTimeWithDependentAnimation;
}

/*
==============
BG_WarningIconsDelay
==============
*/
float BG_WarningIconsDelay(const Weapon *r_weapon, bool isAlternate)
{
  unsigned int v3; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **v5; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 v11[32]; 

  v3 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, v11);
  if ( AllWeaponAttachmentsWithIds )
  {
    v5 = attachments;
    while ( 1 )
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 16280, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v5)->ui )
        break;
      ++v3;
      ++v5;
      if ( v3 >= AllWeaponAttachmentsWithIds )
        goto LABEL_8;
    }
    __asm { vmovss  xmm0, dword ptr [rcx+34h] }
  }
  else
  {
LABEL_8:
    _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
    __asm { vmovss  xmm0, dword ptr [rax+39Ch] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeapDetonateType
==============
*/
__int64 BG_WeapDetonateType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return (unsigned int)v2->detonateType;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 967, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return MEMORY[0xFC4];
}

/*
==============
BG_WeapHasDetonator
==============
*/
bool BG_WeapHasDetonator(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 967, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v2->detonateType != DETONATE_TYPE_NONE;
}

/*
==============
BG_WeapHasGestureDetonation
==============
*/
bool BG_WeapHasGestureDetonation(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 967, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v2->detonateType == DETONATE_TYPE_GESTURE;
}

/*
==============
BG_WeaponADSFractionAffectedByReload
==============
*/
double BG_WeaponADSFractionAffectedByReload(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v7 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(weaponMap, ps, CurrentWeaponForPlayer, v7, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmm1, xmm6; maxAbsValueSize
  }
  *(double *)&_XMM0 = MSG_UnpackUnsignedFloat(ps->weapCommon.lastReloadFraction, *(float *)&_XMM1, 6u);
  __asm
  {
    vmovaps xmm2, xmm0
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
  }
  if ( ps->weapCommon.lastReloadStateChangeWasReloading )
  {
    __asm
    {
      vmulss  xmm1, xmm0, [rsp+48h+arg_8]
      vaddss  xmm0, xmm1, xmm2
    }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm0, [rsp+48h+arg_10]
      vsubss  xmm0, xmm2, xmm0; val
    }
  }
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vsubss  xmm3, xmm6, xmm0
    vmulss  xmm0, xmm3, dword ptr [rsi+730h]; val
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
    vmovaps xmm6, [rsp+48h+var_18]
  }
  return I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
}

/*
==============
BG_WeaponAIFuseTime
==============
*/
__int64 BG_WeaponAIFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)v4->aiFuseTime;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19137, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (unsigned int)v4->aiFuseTime;
  }
  return (unsigned int)projectile->aiFuseTime;
}

/*
==============
BG_WeaponAnimExists
==============
*/
_BOOL8 BG_WeaponAnimExists(XAnimParts *const *weaponAnims, int animIndex)
{
  __int64 v2; 

  v2 = animIndex;
  if ( !weaponAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10754, ASSERT_TYPE_ASSERT, "(weaponAnims)", (const char *)&queryFormat, "weaponAnims") )
    __debugbreak();
  if ( (int)v2 >= 608 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 10755, ASSERT_TYPE_ASSERT, "(animIndex < NUM_WEAP_VIEWMODEL_ANIMS)", (const char *)&queryFormat, "animIndex < NUM_WEAP_VIEWMODEL_ANIMS") )
    __debugbreak();
  return weaponAnims[v2] != NULL;
}

/*
==============
BG_WeaponAnimNumberExists
==============
*/
int BG_WeaponAnimNumberExists(const BgWeaponMap *weaponMap, const playerState_s *ps, int weaponAnimNumber, PlayerHandIndex hand, const BgHandler *pmoveHandler)
{
  bool v9; 
  const Weapon *ViewmodelWeapon; 
  weapAnimFiles_t v11; 
  PlayerHandIndex handIndex; 

  if ( (unsigned int)weaponAnimNumber >= 0x56 )
  {
    handIndex = 86;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2748, ASSERT_TYPE_ASSERT, "(unsigned)( weaponAnimNumber ) < (unsigned)( MAX_WP_ANIMATIONS )", "weaponAnimNumber doesn't index MAX_WP_ANIMATIONS\n\t%i not in [0, %i)", weaponAnimNumber, handIndex) )
      __debugbreak();
  }
  v9 = BG_UsingAlternate(ps);
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  v11 = BG_MapWeaponAnimStateToAnimIndex(weaponMap, ps, weaponAnimNumber, 0, ViewmodelWeapon, v9, hand, pmoveHandler);
  return BG_ViewModelAnimExists(ps, v11, hand, pmoveHandler);
}

/*
==============
BG_WeaponAttachmentAdsSmoothFade
==============
*/
bool BG_WeaponAttachmentAdsSmoothFade(const Weapon *r_weapon, const bool isAlternate)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  AttSight *sight; 

  return (isAlternate && (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL)) != NULL && WeaponPrimaryAttachment->weapClass != WEAPCLASS_NONE && !WeaponPrimaryAttachment->shareAmmoWithAlt || (WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_SCOPE)) != NULL) && (sight = WeaponPrimaryAttachment->sight) != NULL && sight->adsSmoothFade;
}

/*
==============
BG_WeaponBlocksProne
==============
*/
_BOOL8 BG_WeaponBlocksProne(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponDefAtIndex(r_weapon->weaponIdx)->blocksProne;
}

/*
==============
BG_WeaponBulletFire_ExplodeOnImpact
==============
*/
bool BG_WeaponBulletFire_ExplodeOnImpact(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v5; 
  const dvar_t *v6; 
  bool result; 
  bitarray<64> r_perks; 

  r_perks = perks;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6261, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  if ( v5->bBulletExplosiveDamage )
    return 1;
  v6 = DVARBOOL_bg_forceExplosiveBullets;
  if ( !DVARBOOL_bg_forceExplosiveBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_forceExplosiveBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.enabled )
    return 1;
  result = BG_HasPerk(&r_perks, 0x22u);
  if ( result )
    return 1;
  return result;
}

/*
==============
BG_WeaponBulletFire_GetClientHitEvent
==============
*/
__int64 BG_WeaponBulletFire_GetClientHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  __int64 result; 
  __int64 v5; 

  if ( meansOfDeath >= 0x19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6238, ASSERT_TYPE_ASSERT, "(unsigned)( meansOfDeath ) < (unsigned)( MOD_NUM )", "meansOfDeath doesn't index MOD_NUM\n\t%i not in [0, %i)", meansOfDeath, 25) )
    __debugbreak();
  if ( !meansOfDeath )
    goto LABEL_8;
  if ( meansOfDeath <= 2 )
    goto LABEL_14;
  if ( meansOfDeath != 3 )
  {
    if ( meansOfDeath != 9 )
    {
LABEL_8:
      LODWORD(v5) = meansOfDeath;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6250, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unsupported Bullet meansOfDeath '%i' for GetClientHitEvent", v5) )
        __debugbreak();
      return 0i64;
    }
LABEL_14:
    result = 96i64;
    if ( serverPlayerHitEvent )
      return 213i64;
    return result;
  }
  result = 97i64;
  if ( serverPlayerHitEvent )
    return 214i64;
  return result;
}

/*
==============
BG_WeaponBulletFire_GetExplDmg
==============
*/
float BG_WeaponBulletFire_GetExplDmg(const Weapon *r_weapon, bool isAlternate)
{
  weapType_t WeaponType; 
  bool v8; 
  bool v9; 
  double v20; 
  int outMaxDamage; 
  int outMinDamage; 

  __asm { vmovaps [rsp+68h+var_28], xmm6 }
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  v8 = (unsigned int)WeaponType <= WEAPTYPE_BULLET;
  if ( WeaponType != WEAPTYPE_BULLET )
  {
    v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6358, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET");
    v8 = !v9;
    if ( v9 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+704h]
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm1, xmm0
  }
  if ( v8 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm1, xmm1
      vmovsd  [rsp+68h+var_40], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6359, ASSERT_TYPE_ASSERT, "( ( weapDef->bulletExplDmgMult > 0.0f ) )", "( weapDef->bulletExplDmgMult ) = %g", v20) )
      __debugbreak();
  }
  _RBX = DVARFLT_bg_bulletExplDmgFactor;
  if ( !DVARFLT_bg_bulletExplDmgFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletExplDmgFactor") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(WEAP_DMG_CALC_TYPE_DEFAULT, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, [rsp+68h+outMaxDamage]
    vmulss  xmm1, xmm0, xmm6
    vmulss  xmm0, xmm1, dword ptr [rsi+704h]
    vmovaps xmm6, [rsp+68h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponBulletFire_GetExplDmgMin
==============
*/
float BG_WeaponBulletFire_GetExplDmgMin(const Weapon *r_weapon, bool isAlternate)
{
  weapType_t WeaponType; 
  bool v8; 
  bool v9; 
  double v20; 
  int outMaxDamage; 
  int outMinDamage; 

  __asm { vmovaps [rsp+68h+var_28], xmm6 }
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  v8 = (unsigned int)WeaponType < WEAPTYPE_BULLET;
  if ( WeaponType != WEAPTYPE_BULLET )
  {
    v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6347, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET");
    v8 = 0;
    if ( v9 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+700h]
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm1, xmm0
  }
  if ( v8 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm1, xmm1
      vmovsd  [rsp+68h+var_40], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6348, ASSERT_TYPE_ASSERT, "( ( weapDef->bulletExplDmgMultMin >= 0.0f ) )", "( weapDef->bulletExplDmgMultMin ) = %g", v20) )
      __debugbreak();
  }
  _RBX = DVARFLT_bg_bulletExplDmgFactor;
  if ( !DVARFLT_bg_bulletExplDmgFactor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletExplDmgFactor") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  outMinDamage = 0;
  outMaxDamage = 0;
  BG_GetMinMaxDamage(WEAP_DMG_CALC_TYPE_DEFAULT, r_weapon, isAlternate, &outMinDamage, &outMaxDamage);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, [rsp+68h+outMaxDamage]
    vmulss  xmm1, xmm0, xmm6
    vmulss  xmm0, xmm1, dword ptr [rsi+700h]
    vmovaps xmm6, [rsp+68h+var_28]
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponBulletFire_GetExplRadius
==============
*/
float BG_WeaponBulletFire_GetExplRadius(const Weapon *r_weapon, bool isAlternate)
{
  weapType_t WeaponType; 
  bool v8; 
  bool v9; 
  double v20; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  _RSI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  WeaponType = BG_GetWeaponType(r_weapon, isAlternate);
  v8 = (unsigned int)WeaponType <= WEAPTYPE_BULLET;
  if ( WeaponType != WEAPTYPE_BULLET )
  {
    v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6371, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET");
    v8 = !v9;
    if ( v9 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+708h]
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm1, xmm0
  }
  if ( v8 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm1, xmm1
      vmovsd  [rsp+58h+var_30], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6372, ASSERT_TYPE_ASSERT, "( ( weapDef->bulletExplRadiusMult > 0.0f ) )", "( weapDef->bulletExplRadiusMult ) = %g", v20) )
      __debugbreak();
  }
  _RBX = DVARFLT_bg_bulletExplRadius;
  if ( !DVARFLT_bg_bulletExplRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletExplRadius") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() == LONG )
  {
    _RBX = DVARFLT_bg_alienBulletExplRadius;
    if ( !DVARFLT_bg_alienBulletExplRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_alienBulletExplRadius") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+28h]
      vmulss  xmm0, xmm0, dword ptr [rsi+708h]
    }
  }
  else
  {
    __asm { vmulss  xmm0, xmm6, dword ptr [rsi+708h] }
  }
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponBulletFire_GetHitEvent
==============
*/
__int64 BG_WeaponBulletFire_GetHitEvent(unsigned int meansOfDeath, const bool serverPlayerHitEvent)
{
  __int64 result; 
  __int64 v5; 

  if ( meansOfDeath >= 0x19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6217, ASSERT_TYPE_ASSERT, "(unsigned)( meansOfDeath ) < (unsigned)( MOD_NUM )", "meansOfDeath doesn't index MOD_NUM\n\t%i not in [0, %i)", meansOfDeath, 25) )
    __debugbreak();
  if ( !meansOfDeath )
    goto LABEL_9;
  if ( meansOfDeath <= 2 )
    goto LABEL_15;
  if ( meansOfDeath != 3 )
  {
    if ( meansOfDeath != 9 && meansOfDeath != 20 )
    {
LABEL_9:
      LODWORD(v5) = meansOfDeath;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6230, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unsupported Bullet meansOfDeath '%i' for GetHitEvent", v5) )
        __debugbreak();
      return 0i64;
    }
LABEL_15:
    result = 93i64;
    if ( serverPlayerHitEvent )
      return 211i64;
    return result;
  }
  result = 94i64;
  if ( serverPlayerHitEvent )
    return 212i64;
  return result;
}

/*
==============
BG_WeaponBulletFire_GetMethodOfDeath
==============
*/
__int64 BG_WeaponBulletFire_GetMethodOfDeath(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  weapClass_t WeaponClass; 
  __int64 result; 
  unsigned int v8; 
  bool bRifleBullet; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v11; 
  AttPenetration *penetration; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  WeaponClass = BG_GetWeaponClass(r_weapon, isAlternate);
  if ( WeaponClass == WEAPCLASS_BEAM || WeaponClass == WEAPCLASS_TURRET && BG_GetWeaponFireType(r_weapon, isAlternate) == WEAPON_FIRETYPE_BEAM )
    return 2i64;
  if ( BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate) )
    return 3i64;
  if ( BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bIncendiaryBullet )
    return 20i64;
  v8 = 0;
  bRifleBullet = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bRifleBullet;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v11 = attachments;
    while ( 1 )
    {
      if ( !*v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7326, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      penetration = (*v11)->penetration;
      if ( penetration )
        break;
      ++v8;
      ++v11;
      if ( v8 >= WeaponAttachments_Internal )
        goto LABEL_17;
    }
    bRifleBullet = penetration->rifleBullet;
  }
LABEL_17:
  result = 1i64;
  if ( bRifleBullet )
    return 2i64;
  return result;
}

/*
==============
BG_WeaponBulletFire_ShouldPenetrate
==============
*/
bool BG_WeaponBulletFire_ShouldPenetrate(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v3; 

  v3 = DCONST_DVARMPBOOL_bullet_penetration_enabled;
  if ( !DCONST_DVARMPBOOL_bullet_penetration_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bullet_penetration_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return v3->current.enabled && (unsigned int)(BG_GetPenetrateType(r_weapon, isAlternate) - 1) <= 3 && !BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate);
}

/*
==============
BG_WeaponBulletFire_ShouldRicochet
==============
*/
bool BG_WeaponBulletFire_ShouldRicochet(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  const dvar_t *v3; 
  tracerStyle_t tracerStyle; 
  const WeaponAttachment *WeaponPrimaryAttachment; 
  WeaponAttachment *v9; 
  AttAmmoTracer *v10; 
  int v11; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttAmmoTracer *tracer; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v3 = DCONST_DVARBOOL_bullet_ricochet_enabled;
  if ( !DCONST_DVARBOOL_bullet_ricochet_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bullet_ricochet_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( !v3->current.enabled || BG_GetPenetrateType(r_weapon, isAlternate) != PENETRATE_TYPE_RICOCHET || BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate) || BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET || BG_WeaponDefAtIndex(r_weapon->weaponIdx)->bEnergyBullet && Dvar_GetBool_Internal_DebugName(DVARBOOL_disable_energy_bullet_ricochet, "disable_energy_bullet_ricochet") )
    return 0;
  BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  tracerStyle = BG_WeaponDefAtIndex(r_weapon->weaponIdx)->tracerStyle;
  WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  v9 = (WeaponAttachment *)WeaponPrimaryAttachment;
  if ( WeaponPrimaryAttachment && (v10 = WeaponPrimaryAttachment->tracer) != NULL && isAlternate )
  {
    tracerStyle = v10->tracerStyle;
  }
  else
  {
    v11 = 0;
    WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
    if ( WeaponAttachments_Internal )
    {
      for ( i = attachments; ; ++i )
      {
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7284, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        tracer = (*i)->tracer;
        if ( tracer )
        {
          if ( *i != v9 )
            break;
        }
        if ( ++v11 >= WeaponAttachments_Internal )
          return tracerStyle != TRACERSTYLE_BEAM;
      }
      tracerStyle = tracer->tracerStyle;
    }
  }
  return tracerStyle != TRACERSTYLE_BEAM;
}

/*
==============
BG_WeaponBulletFire_ShouldSpread
==============
*/
bool BG_WeaponBulletFire_ShouldSpread(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6280, ASSERT_TYPE_ASSERT, "(BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET)", (const char *)&queryFormat, "BG_GetWeaponType( r_weapon, isAlternate ) == WEAPTYPE_BULLET") )
    __debugbreak();
  return BG_GetWeaponClass(r_weapon, isAlternate) == WEAPCLASS_SPREAD && !BG_WeaponBulletFire_ExplodeOnImpact(perks, r_weapon, isAlternate);
}

/*
==============
BG_WeaponCanAutoReload
==============
*/
bool BG_WeaponCanAutoReload(const playerState_s *ps, const Weapon *currentWeapon, bool isAlternate)
{
  const WeaponDef *v6; 
  bool reloadDisabled; 
  int v8; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttReload *reload; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7963, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 6u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x13u) )
    return 0;
  v6 = BG_WeaponDefAtIndex(currentWeapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7944, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  reloadDisabled = v6->reloadDisabled;
  v8 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(currentWeapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    for ( i = attachments; ; ++i )
    {
      if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 7949, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      reload = (*i)->reload;
      if ( reload )
        break;
      if ( ++v8 >= WeaponAttachments_Internal )
        return !reloadDisabled;
    }
    reloadDisabled = reload->reloadDisabled;
  }
  return !reloadDisabled;
}

/*
==============
BG_WeaponCharge_GetAttachment
==============
*/
WeaponAttachment *BG_WeaponCharge_GetAttachment(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *v2; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **v5; 
  __int64 v6; 
  const char *WeaponName; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 
  char output[1024]; 

  v2 = NULL;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( WeaponAttachments_Internal )
  {
    v5 = attachments;
    v6 = WeaponAttachments_Internal;
    do
    {
      if ( !*v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6456, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      if ( (*v5)->charged )
      {
        if ( v2 )
        {
          WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
          Com_PrintWarning(14, "Weapon '%s' has multiple attachments '%s' with charged overrides. Am using '%s'\n", WeaponName, (*v5)->szDisplayName, v2->szDisplayName);
        }
        else
        {
          v2 = *v5;
        }
      }
      ++v5;
      --v6;
    }
    while ( v6 );
  }
  return v2;
}

/*
==============
BG_WeaponCharge_GetChargeDownSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6606, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6611, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeDownSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeDownSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeDownSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeDownSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeDownToUpSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeDownToUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6622, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6627, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeDownToUpSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeDownToUpSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeDownToUpSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeDownToUpSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeMaxSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeMaxSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6654, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6659, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeMaxSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeMaxSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeMaxSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeMaxSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeUpSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeUpSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6590, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6595, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeUpSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeUpSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeUpSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeUpSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetChargeUpToDownSound
==============
*/
SndAliasLookup BG_WeaponCharge_GetChargeUpToDownSound(const Weapon *r_weapon, bool isAlternate, bool isPlayerView)
{
  const WeaponDef *v6; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v8; 
  AttCharged *charged; 

  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6638, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v8 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6643, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    charged = v8->charged;
    if ( isPlayerView )
      return (SndAliasLookup)charged->chargeUpToDownSoundPlayer.name;
    else
      return (SndAliasLookup)charged->chargeUpToDownSound.name;
  }
  else if ( isPlayerView )
  {
    return (SndAliasLookup)v6->chargeUpToDownSoundPlayer.name;
  }
  else
  {
    return (SndAliasLookup)v6->chargeUpToDownSound.name;
  }
}

/*
==============
BG_WeaponCharge_GetCostPerShot
==============
*/
float BG_WeaponCharge_GetCostPerShot(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  _RDI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6542, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6547, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    _RAX = v6->charged;
    __asm { vmovss  xmm0, dword ptr [rax+8] }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rdi+1128h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponCharge_GetEmptyCooldown
==============
*/
float BG_WeaponCharge_GetEmptyCooldown(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  _RDI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6558, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6563, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    _RAX = v6->charged;
    __asm { vmovss  xmm0, dword ptr [rax+10h] }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rdi+1130h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponCharge_GetFireAtMaxDamageMultiplier
==============
*/
float BG_WeaponCharge_GetFireAtMaxDamageMultiplier(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  _RDI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6574, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6579, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    _RAX = v6->charged;
    __asm { vmovss  xmm0, dword ptr [rax+14h] }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rdi+1134h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponCharge_GetGain
==============
*/
float BG_WeaponCharge_GetGain(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  _RDI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6510, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6515, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    _RAX = v6->charged;
    __asm { vmovss  xmm0, dword ptr [rax+4] }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rdi+1124h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponCharge_GetHudReveal
==============
*/
_BOOL8 BG_WeaponCharge_GetHudReveal(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6670, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return v4->chargeHudReveal;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6675, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeHudReveal;
}

/*
==============
BG_WeaponCharge_GetLossWhenIdle
==============
*/
float BG_WeaponCharge_GetLossWhenIdle(const Weapon *r_weapon, bool isAlternate)
{
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  _RDI = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6526, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6531, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    _RAX = v6->charged;
    __asm { vmovss  xmm0, dword ptr [rax+0Ch] }
  }
  else
  {
    __asm { vmovss  xmm0, dword ptr [rdi+112Ch] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_WeaponCharge_GetMeterBoneCount
==============
*/
__int64 BG_WeaponCharge_GetMeterBoneCount(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 
  __int64 result; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6728, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( Attachment )
  {
    if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6733, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
      __debugbreak();
    result = (unsigned int)v6->charged->chargeMeterEffectBoneCount;
  }
  else
  {
    result = (unsigned int)v4->chargeMeterEffectBoneCount;
  }
  if ( (int)result > 16 )
    return 16i64;
  return result;
}

/*
==============
BG_WeaponCharge_GetMeterBoneMaxCount
==============
*/
__int64 BG_WeaponCharge_GetMeterBoneMaxCount()
{
  return 16i64;
}

/*
==============
BG_WeaponCharge_GetMeterBoneName
==============
*/
__int64 BG_WeaponCharge_GetMeterBoneName(unsigned int chargeIndex)
{
  __int64 result; 

  switch ( chargeIndex )
  {
    case 0u:
      goto $LN7_85;
    case 1u:
      result = (unsigned int)scr_const.tag_charge_fx02;
      break;
    case 2u:
      result = (unsigned int)scr_const.tag_charge_fx03;
      break;
    case 3u:
      result = (unsigned int)scr_const.tag_charge_fx04;
      break;
    case 4u:
      result = (unsigned int)scr_const.tag_charge_fx05;
      break;
    case 5u:
      result = (unsigned int)scr_const.tag_charge_fx06;
      break;
    case 6u:
      result = (unsigned int)scr_const.tag_charge_fx07;
      break;
    case 7u:
      result = (unsigned int)scr_const.tag_charge_fx08;
      break;
    case 8u:
      result = (unsigned int)scr_const.tag_charge_fx09;
      break;
    case 9u:
      result = (unsigned int)scr_const.tag_charge_fx10;
      break;
    case 0xAu:
      result = (unsigned int)scr_const.tag_charge_fx11;
      break;
    case 0xBu:
      result = (unsigned int)scr_const.tag_charge_fx12;
      break;
    case 0xCu:
      result = (unsigned int)scr_const.tag_charge_fx13;
      break;
    case 0xDu:
      result = (unsigned int)scr_const.tag_charge_fx14;
      break;
    case 0xEu:
      result = (unsigned int)scr_const.tag_charge_fx15;
      break;
    case 0xFu:
      result = (unsigned int)scr_const.tag_charge_fx16;
      break;
    default:
      if ( chargeIndex < 0x10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6770, ASSERT_TYPE_ASSERT, "(chargeIndex >= ( 16 ))", (const char *)&queryFormat, "chargeIndex >= PLAYER_WEAPONCHARGE_BONE_TAG_COUNT") )
        __debugbreak();
      Com_PrintWarning(17, "CHARGE_BONE_TAG_NAMES needs to be added to (%d)\n", chargeIndex);
$LN7_85:
      result = (unsigned int)scr_const.tag_charge_fx01;
      break;
  }
  return result;
}

/*
==============
BG_WeaponCharge_GetMeterEffect
==============
*/
FxCombinedDef BG_WeaponCharge_GetMeterEffect(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6711, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return (FxCombinedDef)v4->chargeMeterEffect.particleSystemDef;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6716, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return (FxCombinedDef)v6->charged->chargeMeterEffect.particleSystemDef;
}

/*
==============
BG_WeaponCharge_GetRumble
==============
*/
RumbleInfo *BG_WeaponCharge_GetRumble(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 
  RumbleInfo *result; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6686, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
  {
    result = v4->chargeRumble;
    if ( result )
      return result;
    return 0i64;
  }
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6691, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  result = v6->charged->chargeRumble;
  if ( !result )
    return 0i64;
  return result;
}

/*
==============
BG_WeaponCharge_GetType
==============
*/
__int64 BG_WeaponCharge_GetType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  WeaponAttachment *Attachment; 
  WeaponAttachment *v6; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6487, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  Attachment = BG_WeaponCharge_GetAttachment(r_weapon, isAlternate);
  v6 = Attachment;
  if ( !Attachment )
    return (unsigned int)v4->chargeType;
  if ( !Attachment->charged && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 6492, ASSERT_TYPE_ASSERT, "(attachment->charged)", (const char *)&queryFormat, "attachment->charged") )
    __debugbreak();
  return v6->charged->chargeType;
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelEntityState
==============
*/
_BOOL8 BG_WeaponDoesNotFullyAnimateViewmodelEntityState(const entityState_t *es, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v6; 

  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 941, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( !r_weapon->weaponIdx )
    return 0i64;
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 949, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( !es && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2547, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( (es->lerp.u.player.playerFlags & 0x80) != 0 )
    return BG_WeapHasGestureDetonation(r_weapon, 0);
  else
    return v6->noFullViewmodelAnimations;
}

/*
==============
BG_WeaponDoesNotFullyAnimateViewmodelPlayerState
==============
*/
_BOOL8 BG_WeaponDoesNotFullyAnimateViewmodelPlayerState(const playerState_s *ps, const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v6; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 916, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !r_weapon->weaponIdx )
    return 0i64;
  v6 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 924, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2539, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, ACTIVE, 0x1Eu) )
    return BG_WeapHasGestureDetonation(r_weapon, 0);
  else
    return v6->noFullViewmodelAnimations;
}

/*
==============
BG_WeaponFireRecoil
==============
*/

void __fastcall BG_WeaponFireRecoil(const BgWeaponMap *weaponMap, const playerState_s *ps, PlayerHandIndex hand, double pitchMove, const float yawMove, const vec2_t *gunKickAngles, const vec2_t *viewKickAngles, vec2_t *outGunKickAVel, bool *outGunNeedsToCrossCenter, vec3_t *outViewKickAVel, bool *outViewNeedsToCrossCenter)
{
  __int64 v25; 
  const Weapon *ViewmodelWeapon; 
  bool v30; 
  bool v33; 
  bool v37; 
  unsigned int v38; 
  unsigned int WeaponAttachments_Internal; 
  unsigned int v40; 
  WeaponAttachment **v41; 
  AttKickScaling *kickScaling; 
  float v43; 
  bool v45; 
  unsigned int v48; 
  BgWeaponMap *v49; 
  unsigned int v50; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v52; 
  const WeaponAttachment **v53; 
  AttViewKick *AttachmentViewKick; 
  bool v55; 
  const dvar_t *v96; 
  const dvar_t *v98; 
  BgWeaponMap *v100; 
  bool v106; 
  char v107; 
  bool v108; 
  char v120; 
  float fmt; 
  float fmta; 
  float numAttachmentSlots; 
  float numAttachmentSlotsa; 
  float attachmentSlots; 
  float attachmentSlotsa; 
  float outYawAVel; 
  float outYawAVela; 
  bool useAngularViewKick; 
  float outPitchAVel; 
  float kickYaw; 
  unsigned int pHoldrand; 
  float outPitchInputScalar; 
  float outYawInputScalar; 
  BgWeaponMap *weaponMapa; 
  float adsViewKickYawMin; 
  float adsViewKickYawMax; 
  float adsViewKickPitchMin; 
  float adsViewKickPitchMax; 
  float hipViewKickMagMin; 
  float hipViewKickYawMin; 
  float hipViewKickYawMax; 
  float hipViewKickPitchMin; 
  float hipViewKickPitchMax; 
  float adsGunKickPitchMax; 
  float adsGunKickPitchMin; 
  float adsGunKickYawMin; 
  float adsGunKickYawMax; 
  float adsGunKickMagMin; 
  float hipGunKickPitchMax; 
  float hipGunKickPitchMin; 
  float hipGunKickYawMin; 
  float hipGunKickYawMax[2]; 
  float hipGunKickMagMin[2]; 
  float adsViewKickMagMin; 
  bool *v175; 
  vec2_t *v176; 
  bool *v177; 
  WeaponAttachment *attachments[30]; 
  WeaponAttachment *v179[30]; 
  unsigned __int8 attachmentIds[32]; 
  unsigned __int8 v181[32]; 
  char v182; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  v175 = outGunNeedsToCrossCenter;
  _RDI = ps;
  weaponMapa = (BgWeaponMap *)weaponMap;
  v177 = outViewNeedsToCrossCenter;
  *(_QWORD *)hipGunKickYawMax = outViewKickAVel;
  v176 = outGunKickAVel;
  v25 = hand;
  __asm
  {
    vmovaps xmm15, xmm3
    vxorps  xmm14, xmm14, xmm14
    vxorps  xmm10, xmm10, xmm10
  }
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3805, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 3806, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  pHoldrand = 16811 * _RDI->serverTime + 17891 * _RDI->weapCommon.adsStartTime;
  BG_srand(&pHoldrand);
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, _RDI);
  v30 = BG_UsingAlternate(_RDI);
  __asm
  {
    vmovss  xmm13, cs:__real@3f800000
    vmovss  xmm6, dword ptr [rdi+730h]
  }
  v33 = v30;
  __asm
  {
    vmovaps xmm12, xmm13
    vmovaps xmm9, xmm13
  }
  *(_QWORD *)hipGunKickMagMin = 80 * v25;
  if ( _RDI->weapState[v25].weaponStartingKickTime > 0 )
  {
    _RBX = DCONST_DVARFLT_bg_viewAndGunKickAdsFrac;
    if ( !DCONST_DVARFLT_bg_viewAndGunKickAdsFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewAndGunKickAdsFrac") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vcomiss xmm6, dword ptr [rbx+28h] }
    if ( v107 )
    {
      *(double *)&_XMM0 = BG_StartingGunKickPercent(ViewmodelWeapon, v33, 0);
      v37 = 0;
    }
    else
    {
      *(double *)&_XMM0 = BG_StartingGunKickPercent(ViewmodelWeapon, v33, 1);
      v37 = 1;
    }
    __asm { vmovaps xmm12, xmm0 }
    *(double *)&_XMM0 = BG_StartingViewKickPercent(ViewmodelWeapon, v33, v37);
    __asm { vmovaps xmm9, xmm0 }
  }
  v38 = 0;
  outPitchInputScalar = *(float *)&BG_WeaponDefAtIndex(ViewmodelWeapon->weaponIdx)->adsEndingKickBullets;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(ViewmodelWeapon, v33, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v40 = 0;
  if ( WeaponAttachments_Internal )
  {
    v41 = attachments;
    while ( 1 )
    {
      if ( !*v41 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14266, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      kickScaling = (*v41)->kickScaling;
      if ( kickScaling )
        break;
      ++v40;
      ++v41;
      if ( v40 >= WeaponAttachments_Internal )
        goto LABEL_22;
    }
    v43 = *(float *)&kickScaling->adsEndingKickBullets;
  }
  else
  {
LABEL_22:
    v43 = outPitchInputScalar;
  }
  if ( SLODWORD(v43) > 0 && *(int *)((char *)&_RDI->weapState[0].weaponEndingKickTime + *(_QWORD *)hipGunKickMagMin) <= 0 )
  {
    _RBX = DCONST_DVARFLT_bg_viewAndGunKickAdsFrac;
    if ( !DCONST_DVARFLT_bg_viewAndGunKickAdsFrac && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_viewAndGunKickAdsFrac") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vcomiss xmm6, dword ptr [rbx+28h] }
    if ( v107 )
    {
      *(double *)&_XMM0 = BG_EndingGunKickPercent(ViewmodelWeapon, v33, 0);
      v45 = 0;
    }
    else
    {
      *(double *)&_XMM0 = BG_EndingGunKickPercent(ViewmodelWeapon, v33, 1);
      v45 = 1;
    }
    __asm { vmovaps xmm12, xmm0 }
    *(double *)&_XMM0 = BG_EndingViewKickPercent(ViewmodelWeapon, v33, v45);
    __asm { vmovaps xmm9, xmm0 }
  }
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RDI->weapCommon.weapFlags, ACTIVE, 0xDu) )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm1, xmm0, cs:__real@3c23d70a
      vmulss  xmm12, xmm12, xmm1
      vmulss  xmm9, xmm9, xmm1
    }
  }
  useAngularViewKick = BG_WeaponDefAtIndex(ViewmodelWeapon->weaponIdx)->useAngularViewKick;
  v48 = BG_GetWeaponAttachments_Internal(ViewmodelWeapon, v33, (const WeaponAttachment **)v179, v181, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  v49 = weaponMapa;
  v50 = v48;
  v52 = weaponMapa && (EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMapa, _RDI, ViewmodelWeapon)) != NULL && EquippedWeaponStateConst->hybridScope;
  if ( v50 )
  {
    v53 = (const WeaponAttachment **)v179;
    while ( 1 )
    {
      if ( !*v53 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 14516, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentViewKick = BG_GetAttachmentViewKick(weaponMapa, _RDI, ViewmodelWeapon, v33, *v53, v52);
      if ( AttachmentViewKick )
        break;
      ++v38;
      ++v53;
      if ( v38 >= v50 )
      {
        v49 = weaponMapa;
        goto LABEL_47;
      }
    }
    v55 = AttachmentViewKick->useAngularViewKick;
    v49 = weaponMapa;
  }
  else
  {
LABEL_47:
    v55 = useAngularViewKick;
  }
  if ( v55 )
  {
    BG_CalculateKickPolar(v49, 1, _RDI, ViewmodelWeapon, v33, &pHoldrand, &outPitchAVel, &kickYaw);
    __asm
    {
      vmovss  xmm7, [rsp+410h+kickYaw]
      vmovss  xmm6, [rsp+410h+outPitchAVel]
    }
  }
  else
  {
    BG_GetViewKickYawAndPitch(v49, _RDI, ViewmodelWeapon, v33, &hipViewKickPitchMin, &hipViewKickPitchMax, &hipViewKickYawMin, &hipViewKickYawMax, &hipViewKickMagMin, &adsViewKickPitchMin, &adsViewKickPitchMax, &adsViewKickYawMin, &adsViewKickYawMax, &adsViewKickMagMin);
    __asm { vmovss  xmm6, dword ptr [rdi+730h] }
    *(double *)&_XMM0 = BG_random(&pHoldrand);
    __asm { vmovaps xmm8, xmm0 }
    *(double *)&_XMM0 = BG_random(&pHoldrand);
    __asm
    {
      vcomiss xmm6, xmm14
      vmovaps xmm3, xmm0
      vsubss  xmm0, xmm13, xmm0
      vsubss  xmm4, xmm13, xmm8
    }
    if ( v107 | v108 )
    {
      __asm
      {
        vmulss  xmm1, xmm3, [rbp+310h+hipViewKickYawMax]
        vmulss  xmm2, xmm0, [rbp+310h+hipViewKickYawMin]
        vmulss  xmm3, xmm4, [rbp+310h+hipViewKickPitchMin]
        vmovss  xmm10, [rbp+310h+var_370]
        vaddss  xmm7, xmm2, xmm1
        vmulss  xmm1, xmm8, [rbp+310h+hipViewKickPitchMax]
        vaddss  xmm2, xmm3, xmm1
      }
    }
    else
    {
      __asm
      {
        vmulss  xmm2, xmm0, [rbp+310h+var_380]
        vmulss  xmm0, xmm3, [rbp+310h+var_37C]
        vmulss  xmm3, xmm4, [rbp+310h+var_378]
        vmovss  xmm10, [rbp+310h+var_328]
        vaddss  xmm7, xmm2, xmm0
        vmulss  xmm0, xmm8, [rbp+310h+var_374]
        vaddss  xmm2, xmm3, xmm0
      }
    }
    __asm { vxorps  xmm6, xmm2, cs:__xmm@80000000800000008000000080000000 }
  }
  __asm
  {
    vmovss  xmm11, [rbp+310h+yawMove]
    vmovss  dword ptr [rsp+410h+outYawAVel], xmm11
    vmovss  dword ptr [rsp+410h+attachmentSlots], xmm15
    vmovss  [rsp+410h+numAttachmentSlots], xmm7
    vmovss  dword ptr [rsp+410h+fmt], xmm6
  }
  BG_CalculateRecoilInputScalars(v49, _RDI, ViewmodelWeapon, v33, fmt, numAttachmentSlots, attachmentSlots, outYawAVel, &outPitchInputScalar, &outYawInputScalar);
  __asm
  {
    vmulss  xmm1, xmm9, [rbp+310h+outPitchInputScalar]
    vmulss  xmm6, xmm1, xmm6
    vmulss  xmm1, xmm9, [rbp+310h+outYawInputScalar]
    vmulss  xmm7, xmm7, xmm1
    vmovss  [rsp+410h+kickYaw], xmm7
    vmovss  [rsp+410h+outPitchAVel], xmm6
    vmulss  xmm9, xmm10, xmm9
    vmovss  xmm10, cs:__real@40a00000
  }
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RDI->weapCommon.weapFlags, ACTIVE, 0xCu) )
  {
    __asm
    {
      vmulss  xmm6, xmm6, xmm10
      vmovss  [rsp+410h+outPitchAVel], xmm6
    }
  }
  if ( !BG_UseAngularGunKick(v49, _RDI, ViewmodelWeapon, v33) )
  {
    __asm { vmovaps xmm2, xmm9; kickMagMin }
    BG_ScaleKickValue(&outPitchAVel, &kickYaw, *(const float *)&_XMM2);
    __asm
    {
      vmovss  xmm7, [rsp+410h+kickYaw]
      vmovss  xmm6, [rsp+410h+outPitchAVel]
    }
  }
  _R12 = *(_QWORD *)hipGunKickYawMax;
  __asm
  {
    vmulss  xmm0, xmm7, cs:__real@bf000000
    vmovss  dword ptr [r12], xmm6
    vmovss  dword ptr [r12+4], xmm7
    vmovss  dword ptr [r12+8], xmm0
  }
  if ( BG_UseAngularGunKick(v49, _RDI, ViewmodelWeapon, v33) )
  {
    BG_CalculateKickPolar(v49, 0, _RDI, ViewmodelWeapon, v33, &pHoldrand, &outPitchAVel, &kickYaw);
    __asm
    {
      vmovss  xmm8, [rsp+410h+kickYaw]
      vmovss  xmm6, [rsp+410h+outPitchAVel]
    }
  }
  else
  {
    BG_GetGunKickYawAndPitch(v49, _RDI, ViewmodelWeapon, v33, &hipGunKickPitchMin, &hipGunKickPitchMax, &hipGunKickYawMin, hipGunKickYawMax, hipGunKickMagMin, &adsGunKickPitchMin, &adsGunKickPitchMax, &adsGunKickYawMin, &adsGunKickYawMax, &adsGunKickMagMin);
    __asm { vmovss  xmm6, dword ptr [rdi+730h] }
    *(double *)&_XMM0 = BG_random(&pHoldrand);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = BG_random(&pHoldrand);
    __asm
    {
      vcomiss xmm6, xmm14
      vsubss  xmm4, xmm13, xmm7
      vsubss  xmm8, xmm13, xmm0
    }
    if ( v107 | v108 )
    {
      __asm
      {
        vmulss  xmm1, xmm4, [rbp+310h+hipGunKickPitchMin]
        vmulss  xmm2, xmm7, [rbp+310h+hipGunKickPitchMax]
        vmulss  xmm3, xmm8, [rbp+310h+hipGunKickYawMin]
        vmovss  xmm9, [rbp+310h+hipGunKickMagMin]
        vaddss  xmm6, xmm2, xmm1
        vmulss  xmm1, xmm0, [rbp+310h+hipGunKickYawMax]
        vaddss  xmm8, xmm3, xmm1
      }
    }
    else
    {
      __asm
      {
        vmulss  xmm2, xmm4, [rbp+310h+adsGunKickPitchMin]
        vmulss  xmm4, xmm8, [rbp+310h+adsGunKickYawMin]
        vmulss  xmm3, xmm7, [rbp+310h+adsGunKickPitchMax]
        vmulss  xmm0, xmm0, [rbp+310h+adsGunKickYawMax]
        vmovss  xmm9, [rbp+310h+adsGunKickMagMin]
        vaddss  xmm8, xmm4, xmm0
        vaddss  xmm6, xmm3, xmm2
      }
    }
  }
  if ( BG_HasPerk(&_RDI->perks, 0x34u) )
  {
    v96 = DCONST_DVARFLT_perk_improved_gun_kick_scale;
    if ( !DCONST_DVARFLT_perk_improved_gun_kick_scale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_improved_gun_kick_scale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v96);
    __asm { vmulss  xmm12, xmm12, dword ptr [rbx+28h] }
  }
  v98 = DCONST_DVARBOOL_viewKickInputScalarsAffectGunKick;
  __asm
  {
    vmovaps xmm7, xmm13
    vmovss  [rbp+310h+outPitchInputScalar], xmm13
    vmovss  [rbp+310h+outYawInputScalar], xmm7
  }
  if ( !DCONST_DVARBOOL_viewKickInputScalarsAffectGunKick && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "viewKickInputScalarsAffectGunKick") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v98);
  v108 = !v98->current.enabled;
  v100 = weaponMapa;
  if ( !v108 )
  {
    __asm
    {
      vmovss  dword ptr [rsp+410h+outYawAVel], xmm11
      vmovss  dword ptr [rsp+410h+attachmentSlots], xmm15
      vmovss  [rsp+410h+numAttachmentSlots], xmm8
      vmovss  dword ptr [rsp+410h+fmt], xmm6
    }
    BG_CalculateRecoilInputScalars(weaponMapa, _RDI, ViewmodelWeapon, v33, fmta, numAttachmentSlotsa, attachmentSlotsa, outYawAVela, &outPitchInputScalar, &outYawInputScalar);
    __asm
    {
      vmovss  xmm7, [rbp+310h+outYawInputScalar]
      vmovss  xmm13, [rbp+310h+outPitchInputScalar]
    }
  }
  __asm
  {
    vmulss  xmm0, xmm13, xmm12
    vmulss  xmm6, xmm0, xmm6
    vmulss  xmm0, xmm7, xmm12
    vmulss  xmm7, xmm8, xmm0
    vmovss  [rsp+410h+kickYaw], xmm7
    vmovss  [rsp+410h+outPitchAVel], xmm6
    vmulss  xmm8, xmm9, xmm12
  }
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RDI->weapCommon.weapFlags, ACTIVE, 0xCu) )
  {
    __asm
    {
      vmulss  xmm6, xmm6, xmm10
      vmovss  [rsp+410h+outPitchAVel], xmm6
    }
  }
  v106 = BG_UseAngularGunKick(v100, _RDI, ViewmodelWeapon, v33);
  v107 = 0;
  v108 = !v106;
  if ( !v106 )
  {
    __asm { vmovaps xmm2, xmm8; kickMagMin }
    BG_ScaleKickValue(&outPitchAVel, &kickYaw, *(const float *)&_XMM2);
    __asm
    {
      vmovss  xmm7, [rsp+410h+kickYaw]
      vmovss  xmm6, [rsp+410h+outPitchAVel]
    }
  }
  _RCX = v176;
  _RAX = viewKickAngles;
  __asm
  {
    vmovss  xmm3, cs:__real@358637be
    vmovss  dword ptr [rcx], xmm6
    vmovss  dword ptr [rcx+4], xmm7
    vmovss  xmm2, dword ptr [rax]
    vmovss  xmm1, dword ptr [rax+4]
    vmulss  xmm0, xmm2, xmm2
    vcomiss xmm0, xmm3
  }
  if ( v107 | v108 )
  {
    __asm
    {
      vmulss  xmm0, xmm1, xmm1
      vcomiss xmm0, xmm3
    }
    if ( v107 | v108 )
      goto LABEL_82;
  }
  __asm
  {
    vmulss  xmm1, xmm1, dword ptr [r12+4]
    vmulss  xmm0, xmm2, dword ptr [r12]
    vaddss  xmm2, xmm1, xmm0
    vcomiss xmm2, xmm14
  }
  if ( !v107 )
  {
LABEL_82:
    v120 = 0;
    v107 = 0;
    v108 = 1;
  }
  else
  {
    v120 = 1;
  }
  *v177 = v120;
  _RAX = gunKickAngles;
  __asm
  {
    vmovss  xmm1, dword ptr [rax]
    vmovss  xmm2, dword ptr [rax+4]
    vmulss  xmm0, xmm1, xmm1
    vcomiss xmm0, xmm3
  }
  if ( v107 | v108 )
  {
    __asm
    {
      vmulss  xmm0, xmm2, xmm2
      vcomiss xmm0, xmm3
    }
    if ( v107 | v108 )
      goto LABEL_87;
  }
  __asm
  {
    vmulss  xmm1, xmm1, dword ptr [rcx]
    vmulss  xmm0, xmm2, dword ptr [rcx+4]
    vaddss  xmm2, xmm1, xmm0
    vcomiss xmm2, xmm14
  }
  if ( !v107 )
LABEL_87:
    *v175 = 0;
  else
    *v175 = 1;
  _R11 = &v182;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
BG_WeaponFuseTime
==============
*/
__int64 BG_WeaponFuseTime(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)v4->fuseTime;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19116, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (unsigned int)v4->fuseTime;
  }
  return (unsigned int)projectile->fuseTime;
}

/*
==============
BG_WeaponGetAltModePlayerAnimType
==============
*/
const WeaponAttachment *BG_WeaponGetAltModePlayerAnimType(const Weapon *r_weapon)
{
  const WeaponAttachment *result; 

  result = BG_GetWeaponPrimaryAttachment(r_weapon, ATT_SLOT_UNDERBARREL);
  if ( result )
    return (const WeaponAttachment *)(unsigned int)result->altModePlayerAnimType;
  return result;
}

/*
==============
BG_WeaponGetAnimParts
==============
*/
XAnimParts *BG_WeaponGetAnimParts(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler)
{
  __int64 v5; 
  XAnimParts *result; 
  const PlayerWeaponAnimArrays *v10; 
  bool v11; 
  __int64 v12; 

  v5 = eWeaponAnim;
  if ( eWeaponAnim == WEAP_ANIM_ROOT )
    return 0i64;
  v10 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18240, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v11 = BG_PlayerDualWielding(ps) != 0;
  if ( !bIsAlternate )
  {
    if ( !v11 )
      goto LABEL_12;
LABEL_10:
    if ( hand != WEAPON_HAND_LEFT )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( v11 )
    goto LABEL_10;
LABEL_11:
  v10 = (const PlayerWeaponAnimArrays *)((char *)v10 + 4976);
LABEL_12:
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18254, ASSERT_TYPE_ASSERT, "(animArray)", (const char *)&queryFormat, "animArray") )
    __debugbreak();
  if ( (unsigned int)v5 >= 0x260 )
  {
    LODWORD(v12) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18255, ASSERT_TYPE_ASSERT, "(unsigned)( eWeaponAnim ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "eWeaponAnim doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v12, 608) )
      __debugbreak();
  }
  result = v10->normalAnimArray[v5];
  if ( !result )
    return v10->normalAnimArray[236];
  return result;
}

/*
==============
BG_WeaponGetNotetrackMilliseconds
==============
*/
int BG_WeaponGetNotetrackMilliseconds(const playerState_s *ps, PlayerHandIndex hand, bool bIsAlternate, weapAnimFiles_t eWeaponAnim, const BgHandler *pmoveHandler, const scr_string_t notetrackName, int *outDuration)
{
  __int64 v9; 
  const PlayerWeaponAnimArrays *v13; 
  bool v14; 
  const XAnimParts *v15; 
  char v17; 
  char v18; 
  int result; 
  __int64 v26; 

  v9 = eWeaponAnim;
  if ( eWeaponAnim == WEAP_ANIM_ROOT )
    return -1;
  v13 = pmoveHandler->PlayerWeaponAnimsConst(pmoveHandler, ps);
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18240, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  v14 = BG_PlayerDualWielding(ps) != 0;
  if ( bIsAlternate )
  {
    if ( !v14 )
    {
LABEL_10:
      v13 = (const PlayerWeaponAnimArrays *)((char *)v13 + 4976);
      goto LABEL_11;
    }
  }
  else if ( !v14 )
  {
    goto LABEL_11;
  }
  if ( hand == WEAPON_HAND_LEFT )
    goto LABEL_10;
LABEL_11:
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18254, ASSERT_TYPE_ASSERT, "(animArray)", (const char *)&queryFormat, "animArray") )
    __debugbreak();
  if ( (unsigned int)v9 >= 0x260 )
  {
    LODWORD(v26) = v9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18255, ASSERT_TYPE_ASSERT, "(unsigned)( eWeaponAnim ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "eWeaponAnim doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v26, 608) )
      __debugbreak();
  }
  v15 = v13->normalAnimArray[v9];
  if ( !v15 )
  {
    v15 = v13->normalAnimArray[236];
    if ( !v15 )
      return -1;
  }
  if ( !notetrackName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18276, ASSERT_TYPE_ASSERT, "(notetrackName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "notetrackName != NULL_SCR_STRING") )
    __debugbreak();
  *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(v15, notetrackName);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
  }
  if ( v17 | v18 )
    return -1;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, eax
    vmulss  xmm2, xmm1, cs:__real@447a0000
    vdivss  xmm3, xmm2, dword ptr [rbx+64h]
  }
  if ( outDuration )
  {
    __asm { vcvttss2si eax, xmm3 }
    *outDuration = _EAX;
  }
  __asm
  {
    vmulss  xmm0, xmm3, xmm0
    vcvttss2si eax, xmm0
  }
  return result;
}

/*
==============
BG_WeaponGetPlayerAnimType
==============
*/
__int64 BG_WeaponGetPlayerAnimType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v5; 

  if ( BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE && isAlternate )
    return 8i64;
  v5 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 20880, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (unsigned int)v5->playerAnimType;
}

/*
==============
BG_WeaponHasOverride
==============
*/
char BG_WeaponHasOverride(const Weapon *r_weapon, const OverrideBinding *const bindings, const unsigned int bindingCount)
{
  unsigned int v6; 
  int *p_attachmentVarIndex; 
  int *v8; 
  unsigned int v9; 
  AttachmentSlot *v10; 
  __int64 v11; 
  unsigned int v12; 
  unsigned int v13; 
  int *v14; 
  int v15; 
  int v17; 
  int v18; 
  unsigned __int8 v20; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  AttachmentSlot slot; 

  if ( bindingCount && !bindings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 2016, ASSERT_TYPE_ASSERT, "(bindingCount == 0 || bindings)", (const char *)&queryFormat, "bindingCount == 0 || bindings") )
    __debugbreak();
  v6 = 0;
  if ( bindingCount )
  {
    p_attachmentVarIndex = &bindings->attachmentVarIndex;
LABEL_7:
    v8 = p_attachmentVarIndex - 4;
    if ( p_attachmentVarIndex == (int *)16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1954, ASSERT_TYPE_ASSERT, "(binding)", (const char *)&queryFormat, "binding") )
      __debugbreak();
    v9 = 0;
    if ( !*v8 )
      return 0;
    while ( 1 )
    {
      v10 = (AttachmentSlot *)(*((_QWORD *)p_attachmentVarIndex - 1) + 68i64 * v9);
      v11 = *(int *)v10;
      if ( (int)v11 >= 13 )
      {
        if ( (_DWORD)v11 == 13 )
        {
          _EDI = v10[1] & r_weapon->weaponOthers;
          if ( _EDI )
          {
            v17 = *p_attachmentVarIndex;
            while ( 1 )
            {
              v18 = _EDI;
              if ( v17 < 0 )
                break;
              __asm { tzcnt   ebx, edi }
              if ( _EBX >= 0x10 )
              {
                LODWORD(v24) = 16;
                LODWORD(v22) = _EBX;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1992, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v22, v24) )
                  __debugbreak();
                LODWORD(v25) = 16;
                LODWORD(v23) = _EBX;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 1809, ASSERT_TYPE_ASSERT, "(unsigned)( otherIndex ) < (unsigned)( 16 )", "otherIndex doesn't index MAX_ATTACHMENT_OTHERS\n\t%i not in [0, %i)", v23, v25) )
                  __debugbreak();
              }
              v20 = truncate_cast<unsigned char,unsigned int>(_EBX + 13);
              v17 = *p_attachmentVarIndex;
              if ( r_weapon->attachmentVariationIndices[v20] == *p_attachmentVarIndex )
                break;
              _EDI ^= 1 << _EBX;
              if ( 1 << _EBX == v18 )
                goto LABEL_43;
            }
LABEL_28:
            ++v6;
            p_attachmentVarIndex += 6;
            if ( v6 >= bindingCount )
              return 1;
            goto LABEL_7;
          }
        }
        else
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143F57750, 5964i64);
        }
      }
      else
      {
        slot = *v10;
        if ( (_DWORD)v11 == 12 )
          v12 = r_weapon->weaponAttachments[12] | (r_weapon->visualAttachmentHighAddr << 8);
        else
          v12 = r_weapon->weaponAttachments[v11];
        if ( v12 )
        {
          v13 = v12 - 1;
          if ( v12 - 1 >= Com_GetWeaponAttachmentSlotSize(&slot) )
          {
            LODWORD(v24) = Com_GetWeaponAttachmentSlotSize(&slot);
            LODWORD(v22) = v12 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1969, ASSERT_TYPE_ASSERT, "(unsigned)( bindingAttachmentIndex ) < (unsigned)( Com_GetWeaponAttachmentSlotSize( slot ) )", "bindingAttachmentIndex doesn't index Com_GetWeaponAttachmentSlotSize( slot )\n\t%i not in [0, %i)", v22, v24) )
              __debugbreak();
          }
          v14 = (int *)(v10 + 1);
          if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 12, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
            __debugbreak();
          if ( v13 >= 0x200 )
          {
            LODWORD(v24) = 512;
            LODWORD(v22) = v12 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 14, ASSERT_TYPE_ASSERT, "(unsigned)( bitNum ) < (unsigned)( size * 8 )", "bitNum doesn't index size * 8\n\t%i not in [0, %i)", v22, v24) )
              __debugbreak();
          }
          v15 = v14[(v12 - 1i64) >> 5];
          if ( _bittest(&v15, v13 & 0x1F) )
          {
            if ( *p_attachmentVarIndex < 0 || r_weapon->attachmentVariationIndices[slot] == *p_attachmentVarIndex )
              goto LABEL_28;
          }
        }
      }
LABEL_43:
      if ( ++v9 >= *v8 )
        return 0;
    }
  }
  return 1;
}

/*
==============
BG_WeaponHasStreamedModels
==============
*/
char BG_WeaponHasStreamedModels(const Weapon *weapon)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v3; 
  unsigned int v4; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int8 *v6; 
  WeaponAttachment **i; 
  WeaponAttachment *v8; 
  unsigned __int8 v9; 
  unsigned __int8 v10; 
  int numModelVariations; 
  int v12; 
  __int64 v14; 
  __int64 v15; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  weaponIdx = weapon->weaponIdx;
  if ( !weaponIdx )
    return 0;
  v3 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22562, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
    __debugbreak();
  if ( !v3->hasAnyTransientModels )
    return 0;
  if ( !*(_WORD *)&v3->transientBaseViewFlags )
  {
    v4 = 0;
    AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(weapon, (const WeaponAttachment **)attachments, attachmentIds);
    if ( AllWeaponAttachmentsWithIds )
    {
      v6 = attachmentIds;
      for ( i = attachments; ; ++i )
      {
        v8 = *i;
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22581, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
          __debugbreak();
        v9 = *v6;
        if ( *v6 >= 0x1Du )
        {
          LODWORD(v15) = 29;
          LODWORD(v14) = v9;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22584, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentId ) < (unsigned)( ( sizeof( *array_counter( weapon.attachmentVariationIndices ) ) + 0 ) )", "attachmentId doesn't index ARRAY_COUNT( weapon.attachmentVariationIndices )\n\t%i not in [0, %i)", v14, v15) )
            __debugbreak();
        }
        v10 = weapon->attachmentVariationIndices[v9];
        if ( v10 >= 0x10u )
        {
          LODWORD(v15) = 16;
          LODWORD(v14) = v10;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22587, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( 16 )", "variationIndex doesn't index MAX_ATT_XMODEL_VARIATION\n\t%i not in [0, %i)", v14, v15) )
            __debugbreak();
        }
        numModelVariations = v8->numModelVariations;
        if ( v10 < numModelVariations )
        {
          if ( v10 >= (unsigned int)numModelVariations )
          {
            LODWORD(v15) = v8->numModelVariations;
            LODWORD(v14) = v10;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22594, ASSERT_TYPE_ASSERT, "(unsigned)( variationIndex ) < (unsigned)( attachment->numModelVariations )", "variationIndex doesn't index attachment->numModelVariations\n\t%i not in [0, %i)", v14, v15) )
              __debugbreak();
          }
          v12 = v8->transientViewFlags | v8->transientWorldFlags;
          if ( _bittest(&v12, v10) )
            break;
        }
        ++v4;
        ++v6;
        if ( v4 >= AllWeaponAttachmentsWithIds )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

/*
==============
BG_WeaponHasStreamedModelsErrorCheck
==============
*/
bool BG_WeaponHasStreamedModelsErrorCheck(const Weapon *weapon)
{
  return !g_usedDebugZone && BG_WeaponHasStreamedModels(weapon);
}

/*
==============
BG_WeaponIsDualWield
==============
*/
char BG_WeaponIsDualWield(const Weapon *r_weapon)
{
  int v1; 
  unsigned int AllWeaponAttachmentsWithIds; 
  WeaponAttachment **i; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v1 = 0;
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( !AllWeaponAttachmentsWithIds )
    return 0;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 17725, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    if ( (*i)->isAkimboAttachment )
      break;
    if ( ++v1 >= AllWeaponAttachmentsWithIds )
      return 0;
  }
  return 1;
}

/*
==============
BG_WeaponRadiusDamageDetailTrace
==============
*/
bool BG_WeaponRadiusDamageDetailTrace(const Weapon *r_weapon, bool isAlternate)
{
  return (unsigned int)(BG_GetWeaponType(r_weapon, isAlternate) - 2) <= 2;
}

/*
==============
BG_WeaponReloadingFraction
==============
*/
double BG_WeaponReloadingFraction(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *CurrentWeaponForPlayer; 
  bool v6; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 

  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(weaponMap, ps);
  v6 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(weaponMap, ps, CurrentWeaponForPlayer, v6, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm { vmovss  xmm1, cs:__real@3f800000; maxAbsValueSize }
  *(double *)&_XMM0 = MSG_UnpackUnsignedFloat(ps->weapCommon.lastReloadFraction, *(float *)&_XMM1, 6u);
  __asm
  {
    vmovaps xmm2, xmm0
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
  }
  if ( ps->weapCommon.lastReloadStateChangeWasReloading )
  {
    __asm
    {
      vmulss  xmm1, xmm0, [rsp+38h+arg_8]
      vaddss  xmm0, xmm1, xmm2
    }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm0, [rsp+38h+arg_10]
      vsubss  xmm0, xmm2, xmm0; val
    }
  }
  __asm
  {
    vmovss  xmm2, cs:__real@3f800000; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  return I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
}

/*
==============
BG_WeaponResetADSReloadFraction
==============
*/
void BG_WeaponResetADSReloadFraction(playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1176, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000; maxAbsValueSize
    vxorps  xmm0, xmm0, xmm0; value
  }
  ps->weapCommon.lastReloadFraction = MSG_PackUnsignedFloat(*(float *)&_XMM0, *(float *)&_XMM1, 6u);
  *(_QWORD *)&ps->weapCommon.lastReloadStateChangeTime = 0i64;
}

/*
==============
BG_WeaponStickinessType
==============
*/
__int64 BG_WeaponStickinessType(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return (unsigned int)v4->stickiness;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18974, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return (unsigned int)v4->stickiness;
  }
  return (unsigned int)projectile->stickiness;
}

/*
==============
BG_WeaponSticksToFloors
==============
*/
bool BG_WeaponSticksToFloors(const Weapon *r_weapon, bool isAlternate)
{
  return BG_WeaponStickinessType(r_weapon, isAlternate) != WEAPSTICKINESS_NONE;
}

/*
==============
BG_WeaponSticksToNonStick
==============
*/
_BOOL8 BG_WeaponSticksToNonStick(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToNonStick;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19074, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToNonStick;
  }
  return projectile->stickToNonStick;
}

/*
==============
BG_WeaponSticksToPlayers
==============
*/
_BOOL8 BG_WeaponSticksToPlayers(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToPlayers;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19011, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToPlayers;
  }
  return projectile->stickToPlayers;
}

/*
==============
BG_WeaponSticksToTurrets
==============
*/
_BOOL8 BG_WeaponSticksToTurrets(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToTurrets;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19053, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToTurrets;
  }
  return projectile->stickToTurrets;
}

/*
==============
BG_WeaponSticksToVehicles
==============
*/
_BOOL8 BG_WeaponSticksToVehicles(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v4; 
  int v5; 
  unsigned int WeaponAttachments_Internal; 
  WeaponAttachment **i; 
  AttProjectile *projectile; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  v5 = 0;
  WeaponAttachments_Internal = BG_GetWeaponAttachments_Internal(r_weapon, isAlternate, (const WeaponAttachment **)attachments, attachmentIds, None, 0xEu, ATTACHMENT_DEFAULT_ORDER);
  if ( !WeaponAttachments_Internal )
    return v4->stickToVehicles;
  for ( i = attachments; ; ++i )
  {
    if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19032, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
      __debugbreak();
    projectile = (*i)->projectile;
    if ( projectile )
      break;
    if ( ++v5 >= WeaponAttachments_Internal )
      return v4->stickToVehicles;
  }
  return projectile->stickToVehicles;
}

/*
==============
BG_WeaponSticksToWalls
==============
*/
bool BG_WeaponSticksToWalls(const Weapon *r_weapon, bool isAlternate)
{
  WeapStickinessType v2; 

  v2 = BG_WeaponStickinessType(r_weapon, isAlternate);
  return ((v2 - 1) & 0xFFFFFFFA) == 0 && v2 != WEAPSTICKINESS_GROUND_ORIENT;
}

/*
==============
BG_Weapon_CheckFriendlyFire
==============
*/
bool BG_Weapon_CheckFriendlyFire(const playerState_s *ps)
{
  return !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|0x80) && GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 3u);
}

/*
==============
BG_Weapon_FiresOnWeaponSwitch
==============
*/
_BOOL8 BG_Weapon_FiresOnWeaponSwitch(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1021, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->firesOnWeaponSwitch;
}

/*
==============
BG_Weapon_GetCameraFireEffect
==============
*/
FxCombinedDef BG_Weapon_GetCameraFireEffect(const Weapon *r_weapon, bool isAlternate)
{
  const WeaponDef *v2; 

  v2 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( v2 )
    return (FxCombinedDef)v2->cameraFireEffect.particleSystemDef;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 988, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return (FxCombinedDef)MEMORY[0x1108];
}

/*
==============
BG_Weapon_GetCameraFireEffectDurationSec
==============
*/
float BG_Weapon_GetCameraFireEffectDurationSec(const Weapon *r_weapon, bool isAlternate)
{
  _RAX = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  _RBX = _RAX;
  if ( _RAX )
  {
    __asm { vmovss  xmm0, dword ptr [rax+1110h] }
  }
  else
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 997, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    __asm { vmovss  xmm0, dword ptr [rbx+1110h] }
  }
  return *(float *)&_XMM0;
}

/*
==============
BG_Weapon_GetPrimaryAttachmentIndex
==============
*/
unsigned __int16 BG_Weapon_GetPrimaryAttachmentIndex(const Weapon *weapon, const AttachmentSlot *slot)
{
  __int64 v4; 

  if ( *(int *)slot >= 13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23191, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
    __debugbreak();
  v4 = *(int *)slot;
  if ( (_DWORD)v4 == 12 )
    return weapon->weaponAttachments[12] | (weapon->visualAttachmentHighAddr << 8);
  else
    return weapon->weaponAttachments[v4];
}

/*
==============
BG_Weapon_OffhandDisabled
==============
*/
__int64 BG_Weapon_OffhandDisabled(const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1052, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xAu) )
    return 1i64;
  if ( !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x1Eu) && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xFu) || ps->skydivePlayerState.state[0] == 5) )
    return 2i64;
  return 0i64;
}

/*
==============
BG_Weapon_OffhandDisablesHold
==============
*/
_BOOL8 BG_Weapon_OffhandDisablesHold(const Weapon *r_weapon, bool isAlternate)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v4; 

  weaponIdx = r_weapon->weaponIdx;
  if ( !weaponIdx )
    return 0i64;
  v4 = BG_WeaponDefAtIndex(weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1045, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  return v4->disableHolding;
}

/*
==============
BG_Weapon_SetPrimaryAttachmentIndex
==============
*/
void BG_Weapon_SetPrimaryAttachmentIndex(const AttachmentSlot *slot, const unsigned __int16 attachmentIndex, Weapon *outWeapon)
{
  AttachmentSlot v6; 

  if ( *(int *)slot >= 13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 23176, ASSERT_TYPE_ASSERT, "(slot < ATT_SLOT_PRIMARY_COUNT)", (const char *)&queryFormat, "slot < ATT_SLOT_PRIMARY_COUNT") )
    __debugbreak();
  v6 = *slot;
  if ( *slot == ATT_SLOT_VISUAL )
  {
    outWeapon->weaponAttachments[12] = truncate_cast<unsigned char,int>((unsigned __int8)attachmentIndex);
    outWeapon->visualAttachmentHighAddr = truncate_cast<unsigned char,int>(HIBYTE(attachmentIndex));
  }
  else
  {
    if ( attachmentIndex > 0xFFu )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned short>(unsigned short)", "unsigned", (unsigned __int8)attachmentIndex, "unsigned", attachmentIndex) )
        __debugbreak();
      v6 = *slot;
    }
    outWeapon->weaponAttachments[v6] = attachmentIndex;
  }
}

/*
==============
BG_Weapon_UsingAutoFireOnSwitchWeapon
==============
*/
bool BG_Weapon_UsingAutoFireOnSwitchWeapon(const BgWeaponMap *weaponMap, const playerState_s *ps)
{
  const Weapon *ViewmodelWeapon; 
  const WeaponDef *v6; 

  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1028, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1029, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(weaponMap, ps);
  BG_UsingAlternate(ps);
  if ( ViewmodelWeapon->weaponIdx )
  {
    v6 = BG_WeaponDefAtIndex(ViewmodelWeapon->weaponIdx);
    if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 1021, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    return v6->firesOnWeaponSwitch;
  }
  else
  {
    return 0;
  }
}

/*
==============
BG_WeaponsDifferOnlyInVariantForInstantSwitch
==============
*/
_BOOL8 BG_WeaponsDifferOnlyInVariantForInstantSwitch(const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeapFlags, const Weapon *r_weaponA, const Weapon *r_weaponB)
{
  bool v7; 
  unsigned __int8 weaponCamo; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> v13; 
  __m256i Buf1; 
  int v17; 

  v13 = prevWeapFlags;
  _RDI = r_weaponA;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 18949, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps", v13) )
    __debugbreak();
  v7 = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x14u);
  if ( v7 == GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v13, ACTIVE, 0x14u) || !memcmp_0(_RDI, r_weaponB, 0x3Cui64) )
    return 0i64;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi]
    vmovups xmm1, xmmword ptr [rdi+20h]
  }
  v17 = *(_DWORD *)&_RDI->weaponCamo;
  weaponCamo = r_weaponB->weaponCamo;
  __asm
  {
    vmovups [rsp+88h+Buf1], ymm0
    vmovsd  xmm0, qword ptr [rdi+30h]
    vmovsd  [rsp+88h+var_20], xmm0
    vmovups [rsp+88h+var_30], xmm1
  }
  LOBYTE(v17) = weaponCamo;
  return memcmp_0(&Buf1, r_weaponB, 0x3Cui64) == 0;
}

/*
==============
BG_WeaponsUtil_AdvanceWeapon
==============
*/
bool BG_WeaponsUtil_AdvanceWeapon(Weapon *inOutWeapon)
{
  return BG_WeaponsUtil_IterateWeaponInternal<bool (*)(void *,WeaponAttachment const * const *,unsigned int,unsigned short &,unsigned char &),unsigned short (*)(unsigned int *,unsigned short)>(inOutWeapon, (bool (__fastcall *)(void *, const WeaponAttachment *const *, unsigned int, unsigned __int16 *, unsigned __int8 *))BG_WeaponsUtil_ChooseNextAttachment, (unsigned __int16 (__fastcall *)(unsigned int *, unsigned __int16))BG_WeaponsUtil_ChooseNextWeaponIdx, NULL);
}

/*
==============
BG_WeaponsUtil_ChooseNextAttachment
==============
*/
bool BG_WeaponsUtil_ChooseNextAttachment(void *__formal, const WeaponAttachment *const *const attachments, const unsigned int attachmentCount, unsigned __int16 *outChosenIndex, unsigned __int8 *outVariationIndex)
{
  unsigned __int16 v6; 
  unsigned __int8 v9; 
  __int64 v10; 
  __int64 v11; 
  const WeaponAttachment *const *v12; 
  bool result; 
  int v14; 

  v6 = *outChosenIndex;
  v9 = *outVariationIndex;
  if ( !attachments )
    goto LABEL_14;
  if ( !v6 )
    goto LABEL_7;
  v10 = (unsigned int)v6 - 1;
  if ( (unsigned int)v10 >= attachmentCount )
  {
    v14 = v6 - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22725, ASSERT_TYPE_ASSERT, "(unsigned)( attachIndex ) < (unsigned)( attachmentCount )", "attachIndex doesn't index attachmentCount\n\t%i not in [0, %i)", v14, attachmentCount) )
      __debugbreak();
  }
  ++*outVariationIndex;
  if ( !BG_WeaponsUtil_ChooseNextVariation(attachments[v10], outVariationIndex) )
  {
LABEL_7:
    v11 = *outChosenIndex;
    if ( (unsigned int)v11 < attachmentCount )
    {
      v12 = &attachments[v11];
      while ( 1 )
      {
        if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22736, ASSERT_TYPE_ASSERT, "(attachments[i])", (const char *)&queryFormat, "attachments[i]") )
          __debugbreak();
        *outVariationIndex = 0;
        LODWORD(v11) = v11 + 1;
        if ( BG_WeaponsUtil_ChooseNextVariation(*v12, outVariationIndex) )
          break;
        ++v12;
        if ( (unsigned int)v11 >= attachmentCount )
          goto LABEL_14;
      }
      *outChosenIndex = truncate_cast<unsigned short,unsigned int>(v11);
      return 1;
    }
LABEL_14:
    *outChosenIndex = v6;
    result = 0;
    *outVariationIndex = v9;
    return result;
  }
  return 1;
}

/*
==============
BG_WeaponsUtil_ChooseNextVariation
==============
*/
char BG_WeaponsUtil_ChooseNextVariation(const WeaponAttachment *const attachment, unsigned __int8 *outVariationIndex)
{
  unsigned int v4; 
  unsigned int numModelVariations; 
  int v6; 

  if ( !attachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22698, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
    __debugbreak();
  v4 = *outVariationIndex;
  numModelVariations = attachment->numModelVariations;
  if ( v4 >= numModelVariations )
    return 0;
  while ( 1 )
  {
    v6 = attachment->transientViewFlags | attachment->transientWorldFlags;
    if ( _bittest(&v6, v4) )
      break;
    if ( ++v4 >= numModelVariations )
      return 0;
  }
  if ( v4 > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)v4, "unsigned", v4) )
    __debugbreak();
  *outVariationIndex = v4;
  return 1;
}

/*
==============
BG_WeaponsUtil_ChooseNextWeaponIdx
==============
*/
__int64 BG_WeaponsUtil_ChooseNextWeaponIdx(unsigned int *randSeed, int lastWeaponIdx)
{
  return (unsigned int)(lastWeaponIdx + 1);
}

/*
==============
BG_WeaponsUtil_ChooseRandomAttachment
==============
*/
char BG_WeaponsUtil_ChooseRandomAttachment(unsigned int *randSeed, const WeaponAttachment *const *const attachments, const unsigned int attachmentCount, unsigned __int16 *outChosenIndex, unsigned __int8 *outVariationIndex)
{
  __int64 v9; 
  const WeaponAttachment *v10; 
  unsigned int v11; 

  if ( attachments && attachmentCount )
  {
    if ( !randSeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22761, ASSERT_TYPE_ASSERT, "(randSeed)", (const char *)&queryFormat, "randSeed") )
      __debugbreak();
    v9 = (unsigned int)BG_irand(0, attachmentCount, randSeed);
    v10 = attachments[v9];
    if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22765, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
      __debugbreak();
    v11 = BG_irand(0, v10->numModelVariations, randSeed);
    *outChosenIndex = truncate_cast<unsigned short,unsigned int>(v9 + 1);
    *outVariationIndex = truncate_cast<unsigned char,unsigned int>(v11);
    return 1;
  }
  else
  {
    *outChosenIndex = 0;
    *outVariationIndex = 0;
    return 0;
  }
}

/*
==============
BG_WeaponsUtil_ChooseRandomWeaponIdx
==============
*/
__int64 BG_WeaponsUtil_ChooseRandomWeaponIdx(unsigned int *randSeed, const unsigned __int16 lastWeaponIdx)
{
  int NumWeapons; 
  const WeaponDef *v5; 
  weapClass_t weapClass; 
  int v7; 
  unsigned __int16 v8; 
  WeaponDef *v9; 
  __int64 v11; 
  __int64 v12; 

  NumWeapons = BG_GetNumWeapons();
  v5 = BG_WeaponDefAtIndex(lastWeaponIdx);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22787, ASSERT_TYPE_ASSERT, "(lastWeapDef)", (const char *)&queryFormat, "lastWeapDef") )
    __debugbreak();
  weapClass = v5->weapClass;
  if ( !randSeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22791, ASSERT_TYPE_ASSERT, "(randSeed)", (const char *)&queryFormat, "randSeed") )
    __debugbreak();
  do
  {
    v7 = BG_irand(1, NumWeapons, randSeed);
    v8 = v7;
    if ( (v7 < 0 || (unsigned int)v7 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,int>(int)", "unsigned", (unsigned __int16)v7, "signed", v7) )
      __debugbreak();
    if ( v8 > bg_lastParsedWeaponIndex )
    {
      LODWORD(v12) = bg_lastParsedWeaponIndex;
      LODWORD(v11) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v11, v12) )
        __debugbreak();
    }
    if ( !bg_weaponDefs[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    v9 = bg_weaponDefs[v8];
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 22798, ASSERT_TYPE_ASSERT, "(nextWeapDef)", (const char *)&queryFormat, "nextWeapDef") )
      __debugbreak();
  }
  while ( v9->weapClass != weapClass );
  return v8;
}

/*
==============
BG_WeaponsUtil_RandomizeWeapon
==============
*/
void BG_WeaponsUtil_RandomizeWeapon(Weapon *inOutWeapon, unsigned int *randSeed)
{
  BG_WeaponsUtil_IterateWeaponInternal<bool (*)(unsigned int *,WeaponAttachment const * const *,unsigned int,unsigned short &,unsigned char &),unsigned short (*)(unsigned int *,unsigned short)>(inOutWeapon, (bool (__fastcall *)(unsigned int *, const WeaponAttachment *const *, unsigned int, unsigned __int16 *, unsigned __int8 *))BG_WeaponsUtil_ChooseRandomAttachment, (unsigned __int16 (__fastcall *)(unsigned int *, unsigned __int16))BG_WeaponsUtil_ChooseRandomWeaponIdx, randSeed);
}

/*
==============
BG_Weapons_AttachHeldWeapon
==============
*/
__int64 BG_Weapons_AttachHeldWeapon(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, int *outWeaponModelIndex1, int *outWeaponModelIndex2, bool isServer, XAnimWeaponIKModelsContainer *outWeaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  XAnimWeaponIKModelsContainer *v9; 
  const characterInfo_t *v10; 
  DObjModel *v12; 
  const Weapon *p_dobjHeldWeapon; 
  PlayerHandIndex v14; 
  int *v15; 
  bool v16; 
  XModel *WeaponModels; 
  const char *WeaponName; 
  unsigned __int16 v19; 
  __int64 v20; 
  const XModel *v21; 
  DObjModel *v22; 
  const char *name; 
  const char *v24; 
  __int64 v25; 
  signed __int64 v26; 
  char v27; 
  __int64 v28; 
  char v29; 
  unsigned __int16 v30; 
  unsigned __int64 v31; 
  DObjModel *v32; 
  const WeaponCompleteDef *v33; 
  const char *szInternalName; 
  __int64 v35; 
  char *v36; 
  char v37; 
  __int64 v38; 
  char v39; 
  scr_string_t tag_accessory_right; 
  DObjCamoParams *v41; 
  unsigned __int64 v42; 
  CharacterModelType *v43; 
  __int64 isUsingDetonator; 
  DObjModel *isUsingDetonatora; 
  __int64 isUsingCensorshipWorldModel; 
  DObjCamoParams *v48; 
  bool IsRiotShield; 
  unsigned __int16 v50; 
  DObjModel *dobjModelsa; 
  XAnimWeaponIKModelsContainer *v52; 
  PlayerHandIndex v53; 
  int *v54; 
  const characterInfo_t *v55; 
  weapType_t WeaponType; 
  Weapon *v57; 
  DObjCamoParams *camoParams; 
  XModel *model; 
  CharacterModelType (*v60)[32]; 
  int *v61; 
  DObjCamoParams outLocalParams; 
  char output[1024]; 

  v9 = outWeaponIKModels;
  v10 = ci;
  v54 = outWeaponModelIndex2;
  v12 = dobjModels;
  v52 = outWeaponIKModels;
  v60 = outModelTypes;
  v61 = outWeaponModelIndex1;
  v55 = ci;
  dobjModelsa = dobjModels;
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21096, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21097, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !outWeaponModelIndex1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21098, ASSERT_TYPE_ASSERT, "(outWeaponModelIndex1)", (const char *)&queryFormat, "outWeaponModelIndex1") )
    __debugbreak();
  if ( !outWeaponModelIndex2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21099, ASSERT_TYPE_ASSERT, "(outWeaponModelIndex2)", (const char *)&queryFormat, "outWeaponModelIndex2") )
    __debugbreak();
  if ( !outWeaponIKModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21100, ASSERT_TYPE_ASSERT, "(outWeaponIKModels)", (const char *)&queryFormat, "outWeaponIKModels") )
    __debugbreak();
  p_dobjHeldWeapon = &v10->dobjHeldWeapon;
  v57 = &v10->dobjHeldWeapon;
  WeaponType = BG_GetWeaponType(&v10->dobjHeldWeapon, 0);
  IsRiotShield = BG_IsRiotShield(&v10->dobjHeldWeapon, 0);
  if ( !v10->dualWielding || v10->usingKillstreakTrigger || (v53 = WEAPON_HAND_LEFT, v10->hideLeftHandWeapon) )
    v53 = WEAPON_HAND_DEFAULT;
  v14 = WEAPON_HAND_DEFAULT;
  *outWeaponModelIndex1 = numModels;
  v15 = v54;
  *v54 = -1;
  do
  {
    v16 = isServer || !v10->dobjHeldWeaponLoaded;
    WeaponModels = BG_GetWeaponModels(v14, p_dobjHeldWeapon, 0, v16, v10->dualWielding != 0, 0, 0);
    model = WeaponModels;
    if ( WeaponModels )
    {
      if ( !XAnimWeaponIKModelsContainer::AddXModel(v9, v14, WeaponModels) )
      {
        WeaponName = BG_GetWeaponName(p_dobjHeldWeapon, output, 0x400u);
        LODWORD(isUsingCensorshipWorldModel) = 12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21128, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", isUsingCensorshipWorldModel, WeaponName) )
          __debugbreak();
      }
      camoParams = BG_Camo_GetWeaponDObjCamoParams(p_dobjHeldWeapon, 0, &outLocalParams);
      if ( IsRiotShield )
      {
        v19 = 0;
        if ( !numModels )
        {
LABEL_88:
          v9 = v52;
          goto LABEL_89;
        }
        do
        {
          v20 = v19;
          v21 = v12[v20].model;
          v22 = &v12[v20];
          if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21087, ASSERT_TYPE_ASSERT, "(weapModel)", (const char *)&queryFormat, "weapModel") )
            __debugbreak();
          name = v21->name;
          if ( !v21->name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21069, ASSERT_TYPE_ASSERT, "(modelName)", (const char *)&queryFormat, "modelName") )
            __debugbreak();
          v24 = "weapon_wm_riotshield";
          v25 = 20i64;
          if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
            __debugbreak();
          v26 = name - "weapon_wm_riotshield";
          while ( 1 )
          {
            v27 = v24[v26];
            v28 = v25;
            v29 = *v24++;
            --v25;
            if ( !v28 )
            {
LABEL_43:
              DObjInitModel(model, v22->boneName, v22->ignoreCollision, 0, camoParams, v22);
              v12 = dobjModelsa;
              goto LABEL_87;
            }
            if ( v27 != v29 )
              break;
            if ( !v27 )
              goto LABEL_43;
          }
          v12 = dobjModelsa;
          ++v19;
        }
        while ( v19 < numModels );
      }
      else
      {
        if ( v10->hideWeapon )
          goto LABEL_89;
        if ( numModels >= 0xFEu )
        {
          LODWORD(isUsingCensorshipWorldModel) = 254;
          LODWORD(isUsingDetonator) = numModels;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21151, ASSERT_TYPE_ASSERT, "(unsigned)( numModels ) < (unsigned)( ( DOBJ_MAX_PARTS ) )", "numModels doesn't index DOBJ_MAX_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
            __debugbreak();
        }
        if ( v14 == WEAPON_HAND_LEFT )
          *v15 = numModels;
        v30 = numModels;
        v31 = numModels;
        v32 = &dobjModelsa[numModels];
        if ( BG_GetWeaponType(p_dobjHeldWeapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(p_dobjHeldWeapon, 0) == WEAPCLASS_THROWINGKNIFE )
        {
LABEL_66:
          tag_accessory_right = 0;
        }
        else
        {
          if ( BG_IsMeleeOnlyWeapon(p_dobjHeldWeapon, 0) )
          {
            v33 = BG_WeaponCompleteDef(p_dobjHeldWeapon, 0);
            if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19636, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
              __debugbreak();
            szInternalName = v33->szInternalName;
            v35 = 0x7FFFFFFFi64;
            if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
              __debugbreak();
            v36 = (char *)("iw7_axe_mpr_melee" - szInternalName);
            while ( 1 )
            {
              v37 = szInternalName[(_QWORD)v36];
              v38 = v35;
              v39 = *szInternalName++;
              --v35;
              if ( !v38 )
              {
LABEL_65:
                p_dobjHeldWeapon = v57;
                v10 = v55;
                goto LABEL_66;
              }
              if ( v37 != v39 )
                break;
              if ( !v37 )
                goto LABEL_65;
            }
            v10 = v55;
            p_dobjHeldWeapon = v57;
          }
          if ( WeaponType == WEAPTYPE_GRENADE || (unsigned int)(WeaponType - 6) <= 2 )
          {
            tag_accessory_right = scr_const.tag_accessory_right;
          }
          else if ( v14 )
          {
            tag_accessory_right = scr_const.tag_weapon_left;
          }
          else
          {
            tag_accessory_right = scr_const.tag_weapon_right;
            if ( v10->leftHandGun )
              tag_accessory_right = scr_const.tag_weapon_left;
          }
        }
        isUsingDetonatora = v32;
        v41 = camoParams;
        DObjInitModel(model, tag_accessory_right, isServer, 0, camoParams, isUsingDetonatora);
        v50 = ++numModels;
        if ( isServer || v16 )
        {
          v12 = dobjModelsa;
        }
        else
        {
          v48 = v41;
          v12 = dobjModelsa;
          BG_AddWeaponAttachmentModels(p_dobjHeldWeapon, v14, v10->dualWielding != 0, 0, 0, 0, dobjModelsa, 0xFEu, &v50, v52, v48);
          numModels = v50;
        }
        if ( numModels <= v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21171, ASSERT_TYPE_ASSERT, "(numModels > numModelsBeforeAdd)", (const char *)&queryFormat, "numModels > numModelsBeforeAdd") )
          __debugbreak();
        if ( v31 < numModels )
        {
          v42 = numModels - v31;
          v43 = &(*v60)[v31];
          while ( v42 )
          {
            *v43++ = (v14 == WEAPON_HAND_LEFT) + 12;
            --v42;
          }
        }
      }
LABEL_87:
      v15 = v54;
      goto LABEL_88;
    }
LABEL_89:
    v10 = v55;
    ++v14;
    p_dobjHeldWeapon = &v55->dobjHeldWeapon;
  }
  while ( v14 <= v53 );
  if ( *v61 >= numModels )
    *v61 = -1;
  return numModels;
}

/*
==============
BG_Weapons_AttachHeldWeaponIKTargets
==============
*/
__int64 BG_Weapons_AttachHeldWeaponIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModelLeft, XModel *ikTargetModelRight, bool isServer, unsigned int *inOutFirstWeaponModelIdx, unsigned int *inOutFirstWeaponBoneIdx, int *heldWeaponModelIdx1, int *heldWeaponModelIdx2, int *stowedWeaponModelIdx, const XAnimWeaponIKModelsContainer *weaponIKModels, CharacterModelType (*outModelTypes)[32])
{
  unsigned int v15; 
  Weapon *p_dobjHeldWeapon; 
  bool dobjHeldWeaponLoaded; 
  bool v18; 
  bool isUsingCensorshipWorldModel; 
  const dvar_t *v20; 
  const ExecutionDef *Def; 
  bool v22; 
  int v23; 
  DObjModel *v24; 
  DObjModel *v25; 
  unsigned int v26; 
  unsigned __int16 v27; 
  bool IsRoboticIKEnabled; 
  XModel *v30; 
  CharacterModelType (*v31)[32]; 
  XAnimWeaponIKModelsContainer *v32; 
  signed int v35; 
  int numBones; 
  unsigned int *v37; 
  bool requiresAkimboIK; 
  XModel *v39; 
  signed int v40; 
  __int64 isUsingDetonator; 
  unsigned __int16 numModelsa; 
  unsigned int *v44; 
  DObjModel *dobjModelsa; 
  XAnimWeaponIKModelsContainer *weaponModels; 
  CharacterModelType (*v47)[32]; 
  XModel *tagIKTargetModel; 
  int *v49; 
  XModel *v50; 
  int *v51; 
  XAnimIKTagRequest result; 
  XAnimIKTagRequest tagRequest; 

  dobjModelsa = dobjModels;
  v47 = outModelTypes;
  v50 = ikTargetModelLeft;
  numModelsa = numModels;
  tagIKTargetModel = ikTargetModelRight;
  v44 = inOutFirstWeaponBoneIdx;
  v49 = heldWeaponModelIdx2;
  v51 = stowedWeaponModelIdx;
  weaponModels = (XAnimWeaponIKModelsContainer *)weaponIKModels;
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21191, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21192, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !inOutFirstWeaponModelIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21193, ASSERT_TYPE_ASSERT, "(inOutFirstWeaponModelIdx)", (const char *)&queryFormat, "inOutFirstWeaponModelIdx") )
    __debugbreak();
  if ( !inOutFirstWeaponBoneIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21194, ASSERT_TYPE_ASSERT, "(inOutFirstWeaponBoneIdx)", (const char *)&queryFormat, "inOutFirstWeaponBoneIdx") )
    __debugbreak();
  if ( !heldWeaponModelIdx1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21195, ASSERT_TYPE_ASSERT, "(heldWeaponModelIdx1)", (const char *)&queryFormat, "heldWeaponModelIdx1") )
    __debugbreak();
  if ( !heldWeaponModelIdx2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21196, ASSERT_TYPE_ASSERT, "(heldWeaponModelIdx2)", (const char *)&queryFormat, "heldWeaponModelIdx2") )
    __debugbreak();
  if ( !stowedWeaponModelIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21197, ASSERT_TYPE_ASSERT, "(stowedWeaponModelIdx)", (const char *)&queryFormat, "stowedWeaponModelIdx") )
    __debugbreak();
  v15 = 0;
  if ( numModelsa > 0xFEu )
  {
    LODWORD(isUsingDetonator) = numModelsa;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21198, ASSERT_TYPE_ASSERT, "( 0 ) <= ( numModels ) && ( numModels ) <= ( ( DOBJ_MAX_PARTS ) )", "numModels not in [0, DOBJ_MAX_SUBMODELS]\n\t%i not in [%i, %i]", isUsingDetonator, 0i64, 254) )
      __debugbreak();
  }
  if ( !weaponIKModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21199, ASSERT_TYPE_ASSERT, "(weaponIKModels)", (const char *)&queryFormat, "weaponIKModels") )
    __debugbreak();
  if ( !ikTargetModelLeft && !ikTargetModelRight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21200, ASSERT_TYPE_ASSERT, "(ikTargetModelLeft || ikTargetModelRight)", (const char *)&queryFormat, "ikTargetModelLeft || ikTargetModelRight") )
    __debugbreak();
  if ( !ci->hideWeapon && !BG_SkydiveAnimStateNeedParachuteModel((const animScriptParachuteState_t)ci->skydiveAnimState) )
  {
    p_dobjHeldWeapon = &ci->dobjHeldWeapon;
    dobjHeldWeaponLoaded = ci->dobjHeldWeaponLoaded;
    v18 = ci->isUsingWeaponAltMode == 1;
    isUsingCensorshipWorldModel = 0;
    if ( BG_Execution_IsExecutionWeaponPresent(ci) )
    {
      v20 = DVARBOOL_execution_prop_ik_enabled;
      if ( !DVARBOOL_execution_prop_ik_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "execution_prop_ik_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v20);
      if ( v20->current.enabled )
      {
        Def = BG_Execution_GetDef(ci->execution);
        if ( Def )
        {
          if ( Def->propWeaponEnableIK )
          {
            if ( ci->dualWielding && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21225, ASSERT_TYPE_ASSERT, "(!ci->dualWielding)", (const char *)&queryFormat, "!ci->dualWielding") )
              __debugbreak();
            p_dobjHeldWeapon = &ci->dobjExecutionWeapon;
            dobjHeldWeaponLoaded = ci->dobjExecutionWeaponLoaded && !BG_Execution_ShouldHideExecutionWeapon(&ci->dobjExecutionWeapon);
            v18 = 0;
            isUsingCensorshipWorldModel = BG_Weapons_UseCensorshipWorldModel();
          }
        }
      }
    }
    if ( p_dobjHeldWeapon->weaponIdx && memcmp_0(p_dobjHeldWeapon, &ci->dobjStowedWeapon, 0x3Cui64) )
    {
      v22 = isServer || !dobjHeldWeaponLoaded;
      if ( BG_GetWeaponModels(WEAPON_HAND_DEFAULT, p_dobjHeldWeapon, 0, v22, ci->dualWielding != 0, 0, isUsingCensorshipWorldModel) )
      {
        v23 = 0;
        v24 = dobjModelsa;
        if ( numModelsa )
        {
          v25 = dobjModelsa;
          while ( 1 )
          {
            v26 = XModelNumBones(v25->model) + v15;
            if ( v26 > 0xFE )
              break;
            ++v23;
            ++v25;
            v15 = v26;
            if ( v23 >= numModelsa )
              goto LABEL_59;
          }
        }
        else
        {
LABEL_59:
          if ( v15 + 2 <= 0xFE )
          {
            v27 = numModelsa;
            IsRoboticIKEnabled = BG_Suit_IsRoboticIKEnabled(ci->suitIndex);
            _RAX = XAnimIKSetupTagRequest(&result, p_dobjHeldWeapon, v18, IsRoboticIKEnabled, 0, ci->dualWielding == 1);
            v30 = tagIKTargetModel;
            v31 = v47;
            v32 = weaponModels;
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovups ymmword ptr [rsp+168h+tagRequest.weapon.weaponIdx], ymm0
              vmovups ymm1, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rsp+168h+tagRequest.weapon.attachmentVariationIndices+5], ymm1
            }
            if ( !tagIKTargetModel || (v35 = XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_RIGHT_HAND, tagIKTargetModel, weaponModels, &tagRequest, dobjModelsa, &numModelsa, v47), v35 == -1) || v35 >= (int)*inOutFirstWeaponModelIdx )
            {
              v37 = v44;
            }
            else
            {
              ++*inOutFirstWeaponModelIdx;
              numBones = v30->numBones;
              v37 = v44;
              *v44 += numBones;
            }
            if ( *v49 >= 0 && v27 != numModelsa )
              *v49 += numModelsa - v27;
            requiresAkimboIK = tagRequest.requiresAkimboIK;
            if ( ci->dualWielding )
              requiresAkimboIK = 1;
            v39 = v50;
            tagRequest.requiresAkimboIK = requiresAkimboIK;
            if ( v50 )
            {
              v40 = XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_LEFT_HAND, v50, v32, &tagRequest, v24, &numModelsa, v31);
              if ( v40 != -1 && v40 < (int)*inOutFirstWeaponModelIdx )
              {
                ++*inOutFirstWeaponModelIdx;
                *v37 += v39->numBones;
              }
            }
            if ( *v51 >= 0 && v27 != numModelsa )
              *v51 += numModelsa - v27;
          }
        }
      }
    }
  }
  return numModelsa;
}

/*
==============
BG_Weapons_AttachWorldIKTargets
==============
*/
__int64 BG_Weapons_AttachWorldIKTargets(DObjModel *dobjModels, unsigned __int16 numModels, const characterInfo_t *ci, XModel *ikTargetModel, bool isServer, CharacterModelType (*outModelTypes)[32])
{
  int v9; 
  int v10; 
  DObjModel *v11; 
  const XModel *model; 
  CharacterModelType (*v14)[32]; 
  int attachedModelIdx; 
  unsigned __int16 numModelsa; 

  numModelsa = numModels;
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21319, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21320, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v9 = 0;
  if ( numModelsa > 0xFEu )
  {
    LODWORD(v14) = numModelsa;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21321, ASSERT_TYPE_ASSERT, "( 0 ) <= ( numModels ) && ( numModels ) <= ( ( DOBJ_MAX_PARTS ) )", "numModels not in [0, DOBJ_MAX_SUBMODELS]\n\t%i not in [%i, %i]", v14, 0i64, 254) )
      __debugbreak();
  }
  v10 = 0;
  if ( numModelsa )
  {
    v11 = dobjModels;
    do
    {
      model = v11->model;
      if ( !v11->model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 136, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      ++v10;
      v9 += model->numBones;
      ++v11;
    }
    while ( v10 < numModelsa );
  }
  if ( (unsigned int)(v9 + 2) <= 0xFE )
    XAnimIKAttachTargetToTag(ikTargetModel, scr_const.tag_origin, dobjModels, &numModelsa, &attachedModelIdx, outModelTypes);
  else
    Com_PrintWarning(16, "Failed to attach world ik targets to player dobj - too many bones.\n");
  return numModelsa;
}

/*
==============
BG_Weapons_GetAttachBone
==============
*/
__int64 BG_Weapons_GetAttachBone(const characterInfo_t *ci, weapType_t weapType, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand)
{
  const WeaponCompleteDef *v9; 
  const char *szInternalName; 
  __int64 v11; 
  char *v12; 
  char v13; 
  __int64 v14; 
  char v15; 
  __int64 result; 

  if ( BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_PROJECTILE && BG_GetWeaponClass(r_weapon, 0) == WEAPCLASS_THROWINGKNIFE )
    return 0i64;
  if ( BG_IsMeleeOnlyWeapon(r_weapon, isAlternate) )
  {
    v9 = BG_WeaponCompleteDef(r_weapon, isAlternate);
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 19636, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
      __debugbreak();
    szInternalName = v9->szInternalName;
    v11 = 0x7FFFFFFFi64;
    if ( !szInternalName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v12 = (char *)("iw7_axe_mpr_melee" - szInternalName);
    do
    {
      v13 = szInternalName[(_QWORD)v12];
      v14 = v11;
      v15 = *szInternalName++;
      --v11;
      if ( !v14 )
        break;
      if ( v13 != v15 )
        goto LABEL_15;
    }
    while ( v13 );
    return 0i64;
  }
LABEL_15:
  if ( weapType == WEAPTYPE_GRENADE || (unsigned int)(weapType - 6) <= 2 )
    return (unsigned int)scr_const.tag_accessory_right;
  if ( hand )
    return (unsigned int)scr_const.tag_weapon_left;
  result = (unsigned int)scr_const.tag_weapon_right;
  if ( ci->leftHandGun )
    return (unsigned int)scr_const.tag_weapon_left;
  return result;
}

/*
==============
BG_Weapons_GetScriptedAnimEvent
==============
*/
__int64 BG_Weapons_GetScriptedAnimEvent(const Weapon *offHandWeapon)
{
  unsigned __int16 weaponIdx; 
  const WeaponDef *v2; 

  weaponIdx = offHandWeapon->weaponIdx;
  if ( weaponIdx && (v2 = BG_WeaponDefAtIndex(weaponIdx), v2->weapType == WEAPTYPE_SCRIPT) )
    return (unsigned int)v2->scriptedAnimEvent;
  else
    return 0i64;
}

/*
==============
BG_Weapons_IsRiotShieldModel
==============
*/
__int64 BG_Weapons_IsRiotShieldModel(const XModel *weapModel)
{
  const char *name; 
  const char *v3; 
  __int64 v4; 
  int v5; 
  signed __int64 v6; 
  char v7; 
  __int64 v8; 
  char v9; 
  unsigned int v10; 

  if ( !weapModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21087, ASSERT_TYPE_ASSERT, "(weapModel)", (const char *)&queryFormat, "weapModel") )
    __debugbreak();
  name = weapModel->name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21069, ASSERT_TYPE_ASSERT, "(modelName)", (const char *)&queryFormat, "modelName") )
    __debugbreak();
  v3 = "weapon_wm_riotshield";
  v4 = 20i64;
  v5 = 1;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  v6 = name - "weapon_wm_riotshield";
  while ( 1 )
  {
    v7 = v3[v6];
    v8 = v4;
    v9 = *v3++;
    --v4;
    v10 = 0;
    if ( !v8 )
    {
LABEL_14:
      v5 = 0;
      goto LABEL_15;
    }
    if ( v7 != v9 )
      break;
    if ( !v7 )
      goto LABEL_14;
  }
  if ( v7 < v9 )
    v5 = -1;
LABEL_15:
  LOBYTE(v10) = v5 == 0;
  return v10;
}

/*
==============
BG_Weapons_IsRiotShieldModelName
==============
*/
__int64 BG_Weapons_IsRiotShieldModelName(const char *const modelName)
{
  const char *v2; 
  __int64 v3; 
  signed __int64 v4; 
  char v5; 
  __int64 v6; 
  char v7; 

  if ( !modelName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 21069, ASSERT_TYPE_ASSERT, "(modelName)", (const char *)&queryFormat, "modelName") )
    __debugbreak();
  v2 = "weapon_wm_riotshield";
  v3 = 20i64;
  if ( !modelName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  v4 = modelName - "weapon_wm_riotshield";
  while ( 1 )
  {
    v5 = v2[v4];
    v6 = v3;
    v7 = *v2++;
    --v3;
    if ( !v6 )
      return 1i64;
    if ( v5 != v7 )
      break;
    if ( !v5 )
      return 1i64;
  }
  return 0i64;
}

/*
==============
BG_WorldFlashEffect
==============
*/
FxCombinedDef BG_WorldFlashEffect(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate, bool isFirstFlash)
{
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v8; 
  FxCombinedDef result; 
  bitarray<64> v10; 

  v10 = perks;
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x33u);
  v8 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex < 0 )
    goto LABEL_12;
  if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", PerkNetworkPriorityIndex, 64) )
    __debugbreak();
  if ( ((0x80000000 >> (v8 & 0x1F)) & v10.array[v8 >> 5]) == 0 || (result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 64i64).particleSystemDef) == NULL )
  {
LABEL_12:
    if ( !isFirstFlash )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 8i64);
    result.particleSystemDef = BG_GetWeaponEffect(r_weapon, isAlternate, 32i64).particleSystemDef;
    if ( !result.particleSystemDef )
      return BG_GetWeaponEffect(r_weapon, isAlternate, 8i64);
  }
  return result;
}

/*
==============
BG_WorldLastShotEjectEffect
==============
*/
FxCombinedDef BG_WorldLastShotEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 96i64);
}

/*
==============
BG_WorldShellEjectEffect
==============
*/
FxCombinedDef BG_WorldShellEjectEffect(const Weapon *r_weapon, bool isAlternate)
{
  return BG_GetWeaponEffect(r_weapon, isAlternate, 80i64);
}

/*
==============
BG_turretGetTagForFiringMuzzle
==============
*/
__int64 BG_turretGetTagForFiringMuzzle(const entityState_t *es, const Weapon *r_weapon)
{
  scr_string_t tag_flash; 
  const WeaponDef *v4; 
  int v5; 

  tag_flash = scr_const.tag_flash;
  if ( !r_weapon->weaponIdx )
    return (unsigned int)scr_const.tag_flash;
  v4 = BG_WeaponDefAtIndex(r_weapon->weaponIdx);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9871, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v4->turretFireType == TURRET_ALTERNATE_FIRE )
  {
    v5 = es->lerp.u.anonymous.data[7];
    if ( v5 > 15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 9898, ASSERT_TYPE_ASSERT, "(shotCount <= ((1 << (4)) - 1))", (const char *)&queryFormat, "shotCount <= TURRET_SHOT_COUNT_MAX") )
      __debugbreak();
    if ( (v5 & 1) != 0 )
      return (unsigned int)scr_const.tag_flash_2;
  }
  return (unsigned int)tag_flash;
}

/*
==============
BGSpreadSetting::CalculateSpread
==============
*/
void BGSpreadSetting::CalculateSpread(BGSpreadSetting *this, int shotIndex, float *spreadMinOut, float *spreadMaxOut, float *angleMinOut, float *angleMaxOut)
{
  int m_shotCountInner; 

  _R14 = spreadMaxOut;
  _R15 = spreadMinOut;
  _RBX = this;
  if ( !spreadMinOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 692, ASSERT_TYPE_ASSERT, "(spreadMinOut)", (const char *)&queryFormat, "spreadMinOut") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 693, ASSERT_TYPE_ASSERT, "(spreadMaxOut)", (const char *)&queryFormat, "spreadMaxOut") )
    __debugbreak();
  _RBP = angleMinOut;
  if ( !angleMinOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 694, ASSERT_TYPE_ASSERT, "(angleMinOut)", (const char *)&queryFormat, "angleMinOut") )
    __debugbreak();
  _RSI = angleMaxOut;
  if ( !angleMaxOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 695, ASSERT_TYPE_ASSERT, "(angleMaxOut)", (const char *)&queryFormat, "angleMaxOut") )
    __debugbreak();
  m_shotCountInner = _RBX->m_shotCountInner;
  if ( shotIndex >= m_shotCountInner )
  {
    if ( shotIndex == m_shotCountInner )
    {
      __asm
      {
        vmovss  xmm0, cs:__real@43b40000
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, eax
        vdivss  xmm1, xmm0, xmm1
        vmovss  dword ptr [rbx+8], xmm1
      }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+14h]
      vmulss  xmm1, xmm0, cs:__real@3ea8f5c3
      vmovss  dword ptr [r15], xmm1
    }
    *_R14 = _RBX->m_initSpreadMax;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, edi
      vmulss  xmm1, xmm0, dword ptr [rbx+8]
      vmulss  xmm2, xmm1, cs:__real@40000000
      vaddss  xmm3, xmm2, dword ptr [rbx+0Ch]
      vaddss  xmm2, xmm3, cs:__real@43340000
    }
  }
  else
  {
    *_R15 = 0.0;
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+14h]
      vmulss  xmm1, xmm0, cs:__real@3ea8f5c3
      vmovss  dword ptr [r14], xmm1
      vmovss  xmm2, dword ptr [rbx+8]
      vmulss  xmm3, xmm2, cs:__real@40000000
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, edi
      vmulss  xmm1, xmm3, xmm0
      vaddss  xmm2, xmm1, dword ptr [rbx+0Ch]
    }
  }
  __asm
  {
    vmovss  dword ptr [rbp+0], xmm2
    vaddss  xmm0, xmm2, dword ptr [rbx+8]
    vmovss  dword ptr [rsi], xmm0
  }
}

/*
==============
TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes
==============
*/
unsigned __int8 TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, const scr_string_t tagName)
{
  __int64 v5; 
  int NumModels; 
  scr_string_t v10; 
  int ModelIndexForBoneIndex; 
  __int64 v12; 
  __int64 v13; 
  __int64 v15; 
  __int64 v16; 
  unsigned __int8 index; 

  v5 = modelTypeCount;
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 366, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 367, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !modelTypesToSearch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 368, ASSERT_TYPE_ASSERT, "(modelTypesToSearch)", (const char *)&queryFormat, "modelTypesToSearch") )
    __debugbreak();
  NumModels = DObjGetNumModels(obj);
  if ( NumModels < 1 )
    return -2;
  v10 = tagName;
  index = -2;
  if ( !DObjGetBoneIndexFromStartModel(obj, tagName, 0, &index) )
    return -2;
  while ( 1 )
  {
    ModelIndexForBoneIndex = DObjGetModelIndexForBoneIndex(obj, index);
    v12 = ModelIndexForBoneIndex;
    if ( ModelIndexForBoneIndex >= (unsigned int)NumModels )
    {
      LODWORD(v16) = NumModels;
      LODWORD(v15) = ModelIndexForBoneIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 384, ASSERT_TYPE_ASSERT, "(unsigned)( foundModelIndex ) < (unsigned)( numModels )", "foundModelIndex doesn't index numModels\n\t%i not in [0, %i)", v15, v16) )
        __debugbreak();
    }
    v13 = 0i64;
    if ( v5 > 0 )
      break;
LABEL_18:
    index = -2;
    if ( (int)v12 >= NumModels - 1 || !DObjGetBoneIndexFromStartModel(obj, v10, v12 + 1, &index) )
      return -2;
  }
  while ( ci->dobjModelTypes[v12] != modelTypesToSearch[v13] )
  {
    if ( ++v13 >= v5 )
      goto LABEL_18;
  }
  return index;
}

/*
==============
TagPair::GetFallbackTagName
==============
*/
__int64 TagPair::GetFallbackTagName(TagPair *this)
{
  return (unsigned int)this->m_fallbackTagName;
}

/*
==============
BgWeaponScalarAccumulator::GetFinalValue
==============
*/

float __fastcall BgWeaponScalarAccumulator::GetFinalValue(BgWeaponScalarAccumulator *this, double baseValue)
{
  __asm
  {
    vmovss  xmm2, dword ptr [rcx]
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm3, xmm2, xmm0
    vmovaps [rsp+38h+var_18], xmm6
    vmovaps [rsp+38h+var_28], xmm7
    vmovss  xmm7, cs:__real@3f800000
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcvtss2sd xmm2, xmm0, xmm0
    vcmplesd xmm0, xmm2, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm6, xmm3, xmm7, xmm0
    vmovss  xmm3, dword ptr [rcx+4]
    vsubss  xmm0, xmm7, xmm3
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vmovaps [rsp+38h+var_38], xmm8
    vmovaps xmm8, xmm1
    vcvtss2sd xmm1, xmm0, xmm0
    vcmplesd xmm2, xmm1, cs:__real@3eb0c6f7a0b5ed8d
    vblendvps xmm0, xmm3, xmm7, xmm2
    vmovaps xmm7, [rsp+38h+var_28]
    vmulss  xmm1, xmm0, xmm8
    vmovaps xmm8, [rsp+38h+var_38]
    vmulss  xmm0, xmm1, xmm6
    vmovaps xmm6, [rsp+38h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
TagPair::GetPrimaryTagName
==============
*/
__int64 TagPair::GetPrimaryTagName(TagPair *this)
{
  return (unsigned int)this->m_primaryTagName;
}

/*
==============
TagPair::GetTagNameAndBoneIndex
==============
*/
char TagPair::GetTagNameAndBoneIndex(TagPair *this, const DObj *obj, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  scr_string_t m_fallbackTagName; 
  int modelIndex; 

  if ( !outTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 325, ASSERT_TYPE_ASSERT, "(outTagName)", (const char *)&queryFormat, "outTagName") )
    __debugbreak();
  if ( !outBoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 326, ASSERT_TYPE_ASSERT, "(outBoneIndex)", (const char *)&queryFormat, "outBoneIndex") )
    __debugbreak();
  *outTagName = this->m_primaryTagName;
  *outBoneIndex = -2;
  if ( obj && (this->m_primaryTagName || this->m_fallbackTagName) )
  {
    if ( DObjGetBoneIndexInternal_19(obj, this->m_primaryTagName, outBoneIndex, &modelIndex) )
      return 1;
    *outBoneIndex = -2;
    m_fallbackTagName = this->m_fallbackTagName;
    if ( m_fallbackTagName && DObjGetBoneIndexInternal_19(obj, m_fallbackTagName, outBoneIndex, &modelIndex) )
    {
      *outTagName = this->m_fallbackTagName;
      return 1;
    }
  }
  return 0;
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/
char TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType *modelTypesToSearch, const int modelTypeCount, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  unsigned __int8 v11; 
  unsigned __int8 BoneIndexForTagNameMatchingCharacterModelTypes; 

  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 433, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !outTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 434, ASSERT_TYPE_ASSERT, "(outTagName)", (const char *)&queryFormat, "outTagName") )
    __debugbreak();
  if ( !outBoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 435, ASSERT_TYPE_ASSERT, "(outBoneIndex)", (const char *)&queryFormat, "outBoneIndex") )
    __debugbreak();
  *outTagName = this->m_primaryTagName;
  *outBoneIndex = -2;
  if ( obj )
  {
    if ( this->m_primaryTagName )
    {
      BoneIndexForTagNameMatchingCharacterModelTypes = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, modelTypesToSearch, modelTypeCount, (const scr_string_t)this->m_primaryTagName);
      if ( BoneIndexForTagNameMatchingCharacterModelTypes != 0xFE )
      {
        *outTagName = this->m_primaryTagName;
        *outBoneIndex = BoneIndexForTagNameMatchingCharacterModelTypes;
        return 1;
      }
      goto LABEL_13;
    }
    if ( this->m_fallbackTagName )
    {
LABEL_13:
      if ( this->m_fallbackTagName )
      {
        v11 = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, modelTypesToSearch, modelTypeCount, (const scr_string_t)this->m_fallbackTagName);
        if ( v11 != 0xFE )
        {
          *outTagName = this->m_fallbackTagName;
          *outBoneIndex = v11;
          return 1;
        }
      }
    }
  }
  return 0;
}

/*
==============
TagPair::GetTagNameAndBoneIndexForCharacter
==============
*/
char TagPair::GetTagNameAndBoneIndexForCharacter(TagPair *this, const DObj *obj, const characterInfo_t *ci, const CharacterModelType modelTypeToSearch, scr_string_t *outTagName, unsigned __int8 *outBoneIndex)
{
  scr_string_t *v9; 
  unsigned __int8 *v10; 
  unsigned __int8 v11; 
  unsigned __int8 BoneIndexForTagNameMatchingCharacterModelTypes; 
  CharacterModelType modelTypesToSearch; 

  modelTypesToSearch = modelTypeToSearch;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 433, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v9 = outTagName;
  if ( !outTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 434, ASSERT_TYPE_ASSERT, "(outTagName)", (const char *)&queryFormat, "outTagName") )
    __debugbreak();
  v10 = outBoneIndex;
  if ( !outBoneIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.cpp", 435, ASSERT_TYPE_ASSERT, "(outBoneIndex)", (const char *)&queryFormat, "outBoneIndex") )
    __debugbreak();
  *v9 = this->m_primaryTagName;
  *v10 = -2;
  if ( obj )
  {
    if ( this->m_primaryTagName )
    {
      BoneIndexForTagNameMatchingCharacterModelTypes = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, &modelTypesToSearch, 1, (const scr_string_t)this->m_primaryTagName);
      if ( BoneIndexForTagNameMatchingCharacterModelTypes != 0xFE )
      {
        *v9 = this->m_primaryTagName;
        *v10 = BoneIndexForTagNameMatchingCharacterModelTypes;
        return 1;
      }
      goto LABEL_13;
    }
    if ( this->m_fallbackTagName )
    {
LABEL_13:
      if ( this->m_fallbackTagName )
      {
        v11 = TagPair::GetBoneIndexForTagNameMatchingCharacterModelTypes(obj, ci, &modelTypesToSearch, 1, (const scr_string_t)this->m_fallbackTagName);
        if ( v11 != 0xFE )
        {
          *v9 = this->m_fallbackTagName;
          *v10 = v11;
          return 1;
        }
      }
    }
  }
  return 0;
}

/*
==============
BGSpreadSetting::Init
==============
*/

void __fastcall BGSpreadSetting::Init(BGSpreadSetting *this, double angleStart, int shotCount, double initSpreadMin, float initSpreadMax)
{
  __asm
  {
    vmovss  xmm0, [rsp+initSpreadMax]
    vmovss  dword ptr [rcx+0Ch], xmm1
    vmovss  dword ptr [rcx+14h], xmm0
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, r8d
    vmulss  xmm1, xmm0, cs:__real@3e800000
    vmovss  xmm0, cs:__real@43b40000
    vcvttss2si eax, xmm1
  }
  this->m_shotCount = shotCount;
  __asm { vxorps  xmm1, xmm1, xmm1 }
  if ( _EAX < 1 )
    _EAX = 1;
  this->m_shotCountInner = _EAX;
  __asm
  {
    vcvtsi2ss xmm1, xmm1, eax
    vdivss  xmm1, xmm0, xmm1
    vmovss  dword ptr [rcx+8], xmm1
    vmovss  dword ptr [rcx+10h], xmm3
  }
}

/*
==============
TagPair::IsEmpty
==============
*/
bool TagPair::IsEmpty(TagPair *this)
{
  return !this->m_primaryTagName && !this->m_fallbackTagName;
}

/*
==============
BgWeaponScalarAccumulator::Reset
==============
*/
void BgWeaponScalarAccumulator::Reset(BgWeaponScalarAccumulator *this)
{
  this->m_additiveScale = 1.0;
  this->m_multiplicativeScale = 1.0;
}

/*
==============
TagPair::SetFallbackTagName
==============
*/
void TagPair::SetFallbackTagName(TagPair *this, scr_string_t tagName)
{
  this->m_fallbackTagName = tagName;
}

/*
==============
TagPair::SetPrimaryTagName
==============
*/
void TagPair::SetPrimaryTagName(TagPair *this, scr_string_t tagName)
{
  this->m_primaryTagName = tagName;
}

