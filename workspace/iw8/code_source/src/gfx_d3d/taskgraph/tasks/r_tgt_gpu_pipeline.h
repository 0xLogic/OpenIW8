/*
==============
RBT_GP_ReadBackGPStats
==============
*/

void __fastcall RBT_GP_ReadBackGPStats(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_ReadBackGPStats@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateBatchSubMeshOffsets
==============
*/

void __fastcall RBT_GP_GenerateBatchSubMeshOffsets(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateBatchSubMeshOffsets@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateSModelDataGenIndirectArgs
==============
*/

void __fastcall RBT_GP_GenerateSModelDataGenIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSModelDataGenIndirectArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
R_TGS_GP_ProcessSurfs
==============
*/

void __fastcall R_TGS_GP_ProcessSurfs(R_TG_Script *pScript, const GfxGPConfig *gpConfig, R_TG_Handle beginToken, R_TG_Handle *triIDTexture, R_TG_Handle *occlusionDepthTexture, R_TG_Handle *umbraOcclusionTexture, R_TG_Handle *inoutSceneIndices, R_TG_Handle *inoutSceneIndirectArgs, R_TG_Handle *inoutPerSurfData, TG_GP_PerPassBuffers *perPassBuffers, R_TG_Handle *nullBuffer, R_TG_Handle *nullRwBuffer, R_TG_Handle *indiciesToken)
{
  ?R_TGS_GP_ProcessSurfs@@YAXPEAUR_TG_Script@@AEBUGfxGPConfig@@UR_TG_Handle@@AEAU3@33333AEAUTG_GP_PerPassBuffers@@333@Z(pScript, gpConfig, beginToken, triIDTexture, occlusionDepthTexture, umbraOcclusionTexture, inoutSceneIndices, inoutSceneIndirectArgs, inoutPerSurfData, perPassBuffers, nullBuffer, nullRwBuffer, indiciesToken);
}

/*
==============
RBT_GPV_VisibilityBufferPrepassMSAA
==============
*/

void __fastcall RBT_GPV_VisibilityBufferPrepassMSAA(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GPV_VisibilityBufferPrepassMSAA@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_GP_CreateTemporaryBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_GP_CreateTemporaryBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_GP_CreateTemporaryBuffers@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_GP_GenerateSModelWorkgroups
==============
*/

void __fastcall RBT_GP_GenerateSModelWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSModelWorkgroups@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_ResetClutterFrame
==============
*/

void __fastcall RBT_GP_ResetClutterFrame(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_ResetClutterFrame@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_InitDrawIndirectArgs
==============
*/

void __fastcall RBT_GP_InitDrawIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_InitDrawIndirectArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateSubMeshClusterOffsets
==============
*/

void __fastcall RBT_GP_GenerateSubMeshClusterOffsets(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSubMeshClusterOffsets@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_InitClutterFrame
==============
*/

void __fastcall RBT_GP_InitClutterFrame(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_InitClutterFrame@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateBatchSubMeshIndirectArgs
==============
*/

void __fastcall RBT_GP_GenerateBatchSubMeshIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateBatchSubMeshIndirectArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_GP_CreatePassBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_GP_CreatePassBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>)
{
  return ??$cRBT_GP_CreatePassBuffers@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>);
}

/*
==============
RBT_GP_GenerateSubMeshWorkgroups
==============
*/

void __fastcall RBT_GP_GenerateSubMeshWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSubMeshWorkgroups@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GPV_VisibilityBufferPrepassCommon
==============
*/

void __fastcall RBT_GPV_VisibilityBufferPrepassCommon(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GPV_VisibilityBufferPrepassCommon@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateSubMeshWorkgroupGenIndirectArgs
==============
*/

void __fastcall RBT_GP_GenerateSubMeshWorkgroupGenIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSubMeshWorkgroupGenIndirectArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateClutter
==============
*/

void __fastcall RBT_GP_GenerateClutter(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateClutter@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateClusterWorkgroups
==============
*/

void __fastcall RBT_GP_GenerateClusterWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateClusterWorkgroups@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_GP_ResetClutterFrame<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_GP_ResetClutterFrame<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_GP_ResetClutterFrame@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_GPV_VisibilityBufferPrepass
==============
*/

void __fastcall RBT_GPV_VisibilityBufferPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GPV_VisibilityBufferPrepass@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RT_GP_DObjSurfsSetup
==============
*/

void __fastcall RT_GP_DObjSurfsSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_GP_DObjSurfsSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RT_GP_SModelSurfsSetup
==============
*/

void __fastcall RT_GP_SModelSurfsSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_GP_SModelSurfsSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_GP_CullClusters
==============
*/

void __fastcall RBT_GP_CullClusters(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_CullClusters@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateSModelSurfData
==============
*/

void __fastcall RBT_GP_GenerateSModelSurfData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSModelSurfData@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_ExpandIndexBuffers
==============
*/

void __fastcall RBT_GP_ExpandIndexBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_ExpandIndexBuffers@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateSModelSurfs
==============
*/

void __fastcall RBT_GP_GenerateSModelSurfs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSModelSurfs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_ClearCounterResourcesToZero
==============
*/

void __fastcall RBT_GP_ClearCounterResourcesToZero(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_ClearCounterResourcesToZero@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateClusterWorkgroupsAndVisBits
==============
*/

void __fastcall RBT_GP_GenerateClusterWorkgroupsAndVisBits(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateClusterWorkgroupsAndVisBits@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateClusterTriOffsets
==============
*/

void __fastcall RBT_GP_GenerateClusterTriOffsets(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateClusterTriOffsets@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateDynSurfData
==============
*/

void __fastcall RBT_GP_GenerateDynSurfData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateDynSurfData@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_GenerateSubMeshClusterIndirectArgs
==============
*/

void __fastcall RBT_GP_GenerateSubMeshClusterIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_GenerateSubMeshClusterIndirectArgs@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_GP_CreateClusterTriCountsBuffer<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_GP_CreateClusterTriCountsBuffer<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_GP_CreateClusterTriCountsBuffer@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_GP_CullTriangles
==============
*/

void __fastcall RBT_GP_CullTriangles(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GP_CullTriangles@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_GP_CreateClusterTriCountsBuffer<R_TG_Handle>
==============
*/
unsigned int cRBT_GP_CreateClusterTriCountsBuffer<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_GP_CreateClusterTriCountsBuffer.m_index, &stack);
}

/*
==============
cRBT_GP_CreatePassBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_GP_CreatePassBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_GP_CreatePassBuffers.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>);
}

/*
==============
cRBT_GP_CreateTemporaryBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_GP_CreateTemporaryBuffers<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_GP_CreateTemporaryBuffers.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_GP_ResetClutterFrame<R_TG_Handle>
==============
*/
unsigned int cRBT_GP_ResetClutterFrame<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_GP_ResetClutterFrame.m_index, &stack);
}

/*
==============
RBT_GPV_VisibilityBufferPrepass
==============
*/

void __fastcall RBT_GPV_VisibilityBufferPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_GPV_VisibilityBufferPrepassCommon(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GPV_VisibilityBufferPrepassCommon
==============
*/
void RBT_GPV_VisibilityBufferPrepassCommon(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v10; 
  bool v29; 
  R_RT_Handle v33; 
  R_RT_BufferHandle v34; 
  R_RT_BufferHandle v35; 
  R_RT_ColorHandle v36; 
  R_RT_BufferHandle v37; 

  v10 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_60], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v33);
    if ( (R_RT_Handle::GetSurface(&v33)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v33);
    if ( (R_RT_Handle::GetSurface(&v33)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v33);
    if ( (R_RT_Handle::GetSurface(&v33)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v33);
    if ( (R_RT_Handle::GetSurface(&v33)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v29 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+57h+var_40] }
      if ( v29 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+57h+var_A0]
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymm0, [rbp+57h+var_80]
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymm1, [rbp+57h+var_60]
    vmovups [rbp+57h+var_80], ymm0
    vmovups [rbp+57h+var_60], ymm1
  }
  R_GPV_VisibilityBufferPrepass(computeState, data, viewInfo, v10, &v36, &v35, &v34, &v37);
}

/*
==============
RBT_GPV_VisibilityBufferPrepassMSAA
==============
*/

void __fastcall RBT_GPV_VisibilityBufferPrepassMSAA(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_GPV_VisibilityBufferPrepassCommon(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_GP_ClearCounterResourcesToZero
==============
*/
void RBT_GP_ClearCounterResourcesToZero(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v23; 
  R_RT_Handle v26; 
  R_RT_BufferHandle v27; 
  R_RT_BufferHandle v28; 
  R_RT_BufferHandle v29; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_58], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rsp+0C8h+var_78], ymm1
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_38], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v26);
    if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0C8h+var_38] }
      if ( v23 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+0C8h+var_78]
    vmovups [rsp+0C8h+var_38], ymm0
    vmovups ymm0, [rsp+0C8h+var_58]
    vmovups [rsp+0C8h+var_78], ymm1
    vmovups [rsp+0C8h+var_58], ymm0
  }
  R_GP_ClearCounterResourcesToZero(computeState, data, v9, &v28, &v27, &v29);
}

/*
==============
RBT_GP_CullClusters
==============
*/
void RBT_GP_CullClusters(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  unsigned int v11; 
  bool v12; 
  bool v41; 
  bool v47; 
  bool v63; 
  bool v73; 
  bool v74; 
  R_RT_Handle v75; 
  R_RT_BufferHandle v76; 
  R_RT_BufferHandle v77; 
  R_RT_BufferHandle v78; 
  R_RT_BufferHandle v79; 
  R_RT_BufferHandle v80; 
  R_RT_BufferHandle v81; 
  R_RT_BufferHandle v82; 
  R_RT_BufferHandle v83; 
  R_RT_ColorHandle v84; 
  R_RT_ColorHandle v85; 

  pTaskData = taskInfo->pTaskData;
  v11 = *pTaskData;
  v74 = pTaskData[1] != 0;
  v12 = pTaskData[2] == 0;
  _RAX = taskInfo->attachments;
  v73 = !v12;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+140h+var_D0], ymm0
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_D0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_D0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+140h+var_F0], ymm1
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_F0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_F0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+140h+var_110], ymm0
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_110], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_110], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+140h+var_130], ymm1
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_130], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_130], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rbp+140h+var_150], ymm0
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_150], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_150], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  if ( R_RT_Handle::IsValid(taskInfo->attachments + 5) )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+0A0h]
      vmovd   eax, xmm0
      vmovups [rbp+140h+var_190], ymm0
      vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v75);
      if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID] }
        __debugbreak();
        __asm { vmovups [rbp+140h+var_90], ymm0 }
        goto LABEL_52;
      }
      __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID] }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v41 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rbp+140h+var_190] }
        if ( v41 )
        {
          __debugbreak();
          __asm { vmovups [rbp+140h+var_90], ymm0 }
          goto LABEL_52;
        }
      }
    }
    __asm { vmovups [rbp+140h+var_90], ymm0 }
  }
  else
  {
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr [rbp+140h+var_90+10h], xmm0
    }
    v84.m_surfaceID = 0;
    v84.m_tracking.m_allocCounter = 0;
  }
LABEL_52:
  _RDI = &v84;
  if ( R_RT_Handle::IsValid(taskInfo->attachments + 6) )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+0C0h]
      vmovd   eax, xmm0
      vmovups [rbp+140h+var_190], ymm0
      vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v75);
      if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID] }
        __debugbreak();
        __asm { vmovups [rbp+140h+var_70], ymm0 }
        goto LABEL_63;
      }
      __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID] }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v47 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rbp+140h+var_190] }
        if ( v47 )
        {
          __debugbreak();
          __asm { vmovups [rbp+140h+var_70], ymm0 }
          goto LABEL_63;
        }
      }
    }
    __asm { vmovups [rbp+140h+var_70], ymm0 }
  }
  else
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    v85.m_surfaceID = 0;
    v85.m_tracking.m_allocCounter = 0;
    __asm { vmovdqu xmmword ptr [rbp+140h+var_70+10h], xmm0 }
  }
LABEL_63:
  _RAX = taskInfo->attachments;
  _RBX = &v85;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm0
    vmovups [rbp+140h+var_190], ymm0
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_190], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_190], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+100h]
    vmovd   eax, xmm1
    vmovups [rbp+140h+var_170], ymm1
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_170], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID]
        vmovups [rbp+140h+var_170], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+120h]
    vmovd   eax, xmm0
    vmovups [rbp+140h+var_B0], ymm0
    vmovups ymmword ptr [rbp+140h+var_1B0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v75);
    if ( (R_RT_Handle::GetSurface(&v75)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1B0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v63 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+140h+var_B0] }
      if ( v63 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+140h+var_170]
    vmovups [rbp+140h+var_B0], ymm0
    vmovups ymm0, [rbp+140h+var_190]
    vmovups [rbp+140h+var_190], ymm0
    vmovups ymm0, ymmword ptr [rdi]
    vmovups [rbp+140h+var_170], ymm1
    vmovups ymm1, ymmword ptr [rbx]
    vmovups [rbp+140h+var_90], ymm0
    vmovups ymm0, [rbp+140h+var_150]
    vmovups [rbp+140h+var_70], ymm1
    vmovups ymm1, [rbp+140h+var_130]
    vmovups [rbp+140h+var_150], ymm0
    vmovups ymm0, [rbp+140h+var_110]
    vmovups [rbp+140h+var_130], ymm1
    vmovups ymm1, [rbp+140h+var_F0]
    vmovups [rbp+140h+var_110], ymm0
    vmovups ymm0, [rbp+140h+var_D0]
    vmovups [rbp+140h+var_F0], ymm1
    vmovups [rbp+140h+var_D0], ymm0
  }
  R_GP_CullClusters(computeState, data, viewInfo, v11, v74, v73, &v82, &v81, &v80, &v79, &v78, &v84, &v85, &v76, &v77, &v83);
}

/*
==============
RBT_GP_CullTriangles
==============
*/
void RBT_GP_CullTriangles(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  bool v11; 
  unsigned int v12; 
  bool v14; 
  bool v37; 
  bool v48; 
  R_RT_Handle v55; 
  R_RT_BufferHandle v56; 
  R_RT_ColorHandle v57; 
  R_RT_BufferHandle v58; 
  R_RT_BufferHandle v59; 
  R_RT_BufferHandle v60; 
  R_RT_BufferHandle v61; 
  R_RT_ColorHandle v62; 

  pTaskData = taskInfo->pTaskData;
  v11 = pTaskData[1] == 0;
  v12 = *pTaskData;
  _RAX = taskInfo->attachments;
  v14 = !v11;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+0B0h+var_B0], ymm1
    vmovups ymmword ptr [rsp+1B0h+var_150.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v55);
    if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_B0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_B0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+0B0h+var_D0], ymm0
    vmovups ymmword ptr [rsp+1B0h+var_150.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v55);
    if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_D0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_D0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+0B0h+var_F0], ymm1
    vmovups ymmword ptr [rsp+1B0h+var_150.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v55);
    if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_F0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_F0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+0B0h+var_110], ymm0
    vmovups ymmword ptr [rsp+1B0h+var_150.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v55);
    if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_110], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_110], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  if ( R_RT_Handle::IsValid(taskInfo->attachments + 4) )
  {
    _RAX = taskInfo->attachments;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovd   eax, xmm0
      vmovups [rbp+0B0h+var_130], ymm0
      vmovups ymmword ptr [rsp+1B0h+var_150.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v55);
      if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID] }
        __debugbreak();
        __asm { vmovups [rbp+0B0h+var_70], ymm0 }
        goto LABEL_44;
      }
      __asm { vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID] }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v37 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rbp+0B0h+var_130] }
        if ( v37 )
        {
          __debugbreak();
          __asm { vmovups [rbp+0B0h+var_70], ymm0 }
          goto LABEL_44;
        }
      }
    }
    __asm { vmovups [rbp+0B0h+var_70], ymm0 }
  }
  else
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    v62.m_surfaceID = 0;
    v62.m_tracking.m_allocCounter = 0;
    __asm { vmovdqu xmmword ptr [rbp+0B0h+var_70+10h], xmm0 }
  }
LABEL_44:
  _RAX = taskInfo->attachments;
  _RBX = &v62;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm1
    vmovups [rbp+0B0h+var_130], ymm1
    vmovups ymmword ptr [rsp+1B0h+var_150.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v55);
    if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_130], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID]
        vmovups [rbp+0B0h+var_130], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups [rbp+0B0h+var_90], ymm0
    vmovups ymmword ptr [rsp+1B0h+var_150.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v55);
    if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+1B0h+var_150.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v48 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+0B0h+var_90] }
      if ( v48 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+0B0h+var_130]
    vmovups [rbp+0B0h+var_90], ymm0
    vmovups ymm0, ymmword ptr [rbx]
    vmovups [rbp+0B0h+var_130], ymm1
    vmovups ymm1, [rbp+0B0h+var_F0]
    vmovups [rbp+0B0h+var_70], ymm0
    vmovups ymm0, [rbp+0B0h+var_110]
    vmovups [rbp+0B0h+var_110], ymm0
    vmovups ymm0, [rbp+0B0h+var_D0]
    vmovups [rbp+0B0h+var_F0], ymm1
    vmovups ymm1, [rbp+0B0h+var_B0]
    vmovups [rbp+0B0h+var_D0], ymm0
    vmovups [rbp+0B0h+var_B0], ymm1
  }
  R_GP_CullTriangles(computeState, data, viewInfo, v12, v14, &v60, &v59, &v58, &v57, &v62, &v56, &v61);
}

/*
==============
RBT_GP_ExpandIndexBuffers
==============
*/
void RBT_GP_ExpandIndexBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  bool v10; 
  unsigned int v11; 
  bool v13; 
  bool v41; 
  R_RT_Handle v47; 
  R_RT_BufferHandle v48; 
  R_RT_BufferHandle v49; 
  R_RT_BufferHandle v50; 
  R_RT_BufferHandle v51; 
  R_RT_BufferHandle v52; 
  R_RT_BufferHandle v53; 

  pTaskData = taskInfo->pTaskData;
  v10 = pTaskData[1] == 0;
  v11 = *pTaskData;
  _RAX = taskInfo->attachments;
  v13 = !v10;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_60], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_80], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovd   eax, xmm1
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v41 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+50h+var_40] }
      if ( v41 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+150h+var_E0]
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymm0, [rbp+50h+var_C0]
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymm1, [rbp+50h+var_A0]
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymm0, [rbp+50h+var_80]
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymm1, [rbp+50h+var_60]
    vmovups [rbp+50h+var_80], ymm0
    vmovups [rbp+50h+var_60], ymm1
  }
  R_GP_ExpandIndexBuffers(computeState, data, v11, v13, &v52, &v51, &v50, &v49, &v48, &v53);
}

/*
==============
RBT_GP_GenerateBatchSubMeshIndirectArgs
==============
*/
void RBT_GP_GenerateBatchSubMeshIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  unsigned int PassBatchCount; 
  R_RT_Handle v37; 
  R_RT_BufferHandle v38; 
  R_RT_BufferHandle v39; 
  R_RT_BufferHandle v40; 
  R_RT_BufferHandle v41; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_40], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_40], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_40], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_60], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_80], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_A0], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  PassBatchCount = R_GP_GetPassBatchCount(data, v9);
  __asm { vmovups ymm1, [rbp+57h+var_A0] }
  v37.m_surfaceID = 0;
  v37.m_tracking.m_allocCounter = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+57h+var_C0.m_tracking.m_name], xmm0
    vmovups ymm0, [rbp+57h+var_80]
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymm0, [rbp+57h+var_40]
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymm1, [rbp+57h+var_60]
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
    vmovups [rbp+57h+var_60], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  R_GP_InitIndirectArgsFromPrefixSum(computeState, data, v9, PassBatchCount, 0x100u, 0x4000u, 0x10000u, (R_RT_BufferHandle *)&v37, &v41, &v40, &v39, &v38);
}

/*
==============
RBT_GP_GenerateBatchSubMeshOffsets
==============
*/
void RBT_GP_GenerateBatchSubMeshOffsets(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  unsigned int PassBatchCount; 
  R_RT_Handle v31; 
  R_RT_BufferHandle v32; 
  R_RT_BufferHandle v33; 
  R_RT_BufferHandle v34; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v31);
    if ( (R_RT_Handle::GetSurface(&v31)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
        vmovups [rbp+57h+var_40], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
        vmovups [rbp+57h+var_40], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_60], ymm1
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v31);
    if ( (R_RT_Handle::GetSurface(&v31)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v31);
    if ( (R_RT_Handle::GetSurface(&v31)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  PassBatchCount = R_GP_GetPassBatchCount(data, v9);
  __asm { vmovups ymm1, [rbp+57h+var_80] }
  v31.m_surfaceID = 0;
  v31.m_tracking.m_allocCounter = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+57h+var_A0.m_tracking.m_name], xmm0
    vmovups ymm0, [rbp+57h+var_60]
    vmovups [rbp+57h+var_80], ymm1
    vmovups ymm1, [rbp+57h+var_40]
    vmovups [rbp+57h+var_60], ymm0
    vmovups ymm0, ymmword ptr [rbp+57h+var_A0.m_surfaceID]
    vmovups [rbp+57h+var_40], ymm1
    vmovups ymmword ptr [rbp+57h+var_A0.m_surfaceID], ymm0
  }
  R_GP_PrefixSum256(computeState, data, v9, PassBatchCount, (R_RT_BufferHandle *)&v31, &v34, &v33, &v32);
}

/*
==============
RBT_GP_GenerateClusterTriOffsets
==============
*/
void RBT_GP_GenerateClusterTriOffsets(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v28; 
  R_RT_Handle v32; 
  R_RT_BufferHandle v33; 
  R_RT_BufferHandle v34; 
  R_RT_BufferHandle v35; 
  R_RT_BufferHandle v36; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_60], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+57h+var_40] }
      if ( v28 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+57h+var_A0]
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymm0, [rbp+57h+var_80]
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymm1, [rbp+57h+var_60]
    vmovups [rbp+57h+var_80], ymm0
    vmovups [rbp+57h+var_60], ymm1
  }
  R_GP_PrefixSum512(computeState, data, v9, 0, &v35, &v34, &v33, &v36);
}

/*
==============
RBT_GP_GenerateClusterWorkgroups
==============
*/
void RBT_GP_GenerateClusterWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v38; 
  R_RT_Handle v44; 
  R_RT_BufferHandle v45; 
  R_RT_BufferHandle v46; 
  R_RT_BufferHandle v47; 
  R_RT_BufferHandle v48; 
  R_RT_BufferHandle v49; 
  R_RT_BufferHandle v50; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_60], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_80], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovd   eax, xmm1
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v38 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+50h+var_40] }
      if ( v38 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+150h+var_E0]
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymm0, [rbp+50h+var_C0]
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymm1, [rbp+50h+var_A0]
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymm0, [rbp+50h+var_80]
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymm1, [rbp+50h+var_60]
    vmovups [rbp+50h+var_80], ymm0
    vmovups [rbp+50h+var_60], ymm1
  }
  R_GP_GenerateClusterWorkgroups(computeState, data, v9, &v49, &v48, &v47, &v46, &v45, &v50);
}

/*
==============
RBT_GP_GenerateClusterWorkgroupsAndVisBits
==============
*/
void RBT_GP_GenerateClusterWorkgroupsAndVisBits(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v63; 
  R_RT_Handle v74; 
  R_RT_BufferHandle v75; 
  R_RT_BufferHandle v76; 
  R_RT_BufferHandle v77; 
  R_RT_BufferHandle v78; 
  R_RT_BufferHandle v79; 
  R_RT_BufferHandle v80; 
  R_RT_BufferHandle v81; 
  R_RT_BufferHandle v82; 
  R_RT_BufferHandle v83; 
  R_RT_BufferHandle v84; 
  R_RT_BufferHandle v85; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+110h+var_60], ymm0
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+110h+var_80], ymm1
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+110h+var_A0], ymm0
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+110h+var_C0], ymm1
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_C0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_C0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rbp+110h+var_E0], ymm0
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_E0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_E0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm1
    vmovups [rbp+110h+var_100], ymm1
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_100], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_100], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups [rbp+110h+var_120], ymm0
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_120], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_120], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm1
    vmovups [rbp+110h+var_140], ymm1
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_140], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_140], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+100h]
    vmovd   eax, xmm0
    vmovups [rbp+110h+var_160], ymm0
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_160], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_160], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+120h]
    vmovd   eax, xmm1
    vmovups [rbp+110h+var_180], ymm1
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_180], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID]
        vmovups [rbp+110h+var_180], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+140h]
    vmovd   eax, xmm0
    vmovups [rbp+110h+var_40], ymm0
    vmovups ymmword ptr [rsp+210h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v74);
    if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+210h+var_1A0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v63 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+110h+var_40] }
      if ( v63 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+110h+var_180]
    vmovups [rbp+110h+var_40], ymm0
    vmovups ymm0, [rbp+110h+var_160]
    vmovups [rbp+110h+var_180], ymm1
    vmovups ymm1, [rbp+110h+var_140]
    vmovups [rbp+110h+var_160], ymm0
    vmovups ymm0, [rbp+110h+var_120]
    vmovups [rbp+110h+var_140], ymm1
    vmovups ymm1, [rbp+110h+var_100]
    vmovups [rbp+110h+var_120], ymm0
    vmovups ymm0, [rbp+110h+var_E0]
    vmovups [rbp+110h+var_100], ymm1
    vmovups ymm1, [rbp+110h+var_C0]
    vmovups [rbp+110h+var_E0], ymm0
    vmovups ymm0, [rbp+110h+var_A0]
    vmovups [rbp+110h+var_C0], ymm1
    vmovups ymm1, [rbp+110h+var_80]
    vmovups [rbp+110h+var_A0], ymm0
    vmovups ymm0, [rbp+110h+var_60]
    vmovups [rbp+110h+var_80], ymm1
    vmovups [rbp+110h+var_60], ymm0
  }
  R_GP_GenerateClusterWorkgroupsAndVisBits(computeState, data, v9, &v84, &v83, &v82, &v81, &v80, &v79, &v78, &v77, &v76, &v75, &v85);
}

/*
==============
RBT_GP_GenerateClutter
==============
*/
void RBT_GP_GenerateClutter(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_GPU_GenerateClutter(computeState, data, *taskInfo->pTaskData, 0);
}

/*
==============
RBT_GP_GenerateDynSurfData
==============
*/
void RBT_GP_GenerateDynSurfData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v10; 
  R_RT_Handle v29; 
  R_RT_BufferHandle v30; 
  R_RT_BufferHandle v31; 
  R_RT_BufferHandle v32; 
  void *retaddr; 

  _R11 = &retaddr;
  v10 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [r11-38h], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_38], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_38], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rsp+0C8h+var_58], ymm1
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_78], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v29);
    if ( (R_RT_Handle::GetSurface(&v29)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_98.m_surfaceID]
        vmovups [rsp+0C8h+var_78], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  R_GP_Wait(v10, computeState->computeContextType == COMPUTE_CONTEXT_TYPE_GFX);
  __asm
  {
    vmovups ymm0, [rsp+0C8h+var_78]
    vmovups ymm1, [rsp+0C8h+var_58]
    vmovups [rsp+0C8h+var_78], ymm0
    vmovups ymm0, [rsp+0C8h+var_38]
    vmovups [rsp+0C8h+var_38], ymm0
    vmovups [rsp+0C8h+var_58], ymm1
  }
  R_GP_GenerateDynSurfData(computeState, data, v10, &v32, &v31, &v30);
}

/*
==============
RBT_GP_GenerateSModelDataGenIndirectArgs
==============
*/
void RBT_GP_GenerateSModelDataGenIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v18; 
  R_RT_Handle v20; 
  R_RT_BufferHandle v21; 
  R_RT_BufferHandle v22; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rsp+0C8h+var_58], ymm1
    vmovups ymmword ptr [rsp+0C8h+var_78.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_38], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0C8h+var_38] }
      if ( v18 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+0C8h+var_58]
    vmovups [rsp+0C8h+var_38], ymm0
    vmovups [rsp+0C8h+var_58], ymm1
  }
  R_GP_GenerateIndirectArgsFromCounter(computeState, data, v9, 0x40u, 0, 0, 0x10000u, &v21, &v22);
}

/*
==============
RBT_GP_GenerateSModelSurfData
==============
*/
void RBT_GP_GenerateSModelSurfData(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v43; 
  R_RT_Handle v50; 
  R_RT_BufferHandle v51; 
  R_RT_BufferHandle v52; 
  R_RT_BufferHandle v53; 
  R_RT_BufferHandle v54; 
  R_RT_BufferHandle v55; 
  R_RT_BufferHandle v56; 
  R_RT_BufferHandle v57; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+70h+var_60], ymm0
    vmovups ymmword ptr [rsp+170h+var_120.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+70h+var_80], ymm1
    vmovups ymmword ptr [rsp+170h+var_120.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+70h+var_A0], ymm0
    vmovups ymmword ptr [rsp+170h+var_120.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+60h]
    vmovd   eax, xmm1
    vmovups [rbp+70h+var_C0], ymm1
    vmovups ymmword ptr [rsp+170h+var_120.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_C0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_C0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rbp+70h+var_E0], ymm0
    vmovups ymmword ptr [rsp+170h+var_120.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_E0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rbp+70h+var_E0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm1
    vmovups [rsp+170h+var_100], ymm1
    vmovups ymmword ptr [rsp+170h+var_120.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rsp+170h+var_100], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID]
        vmovups [rsp+170h+var_100], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm0
    vmovups [rbp+70h+var_40], ymm0
    vmovups ymmword ptr [rsp+170h+var_120.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+170h+var_120.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v43 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+70h+var_40] }
      if ( v43 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+170h+var_100]
    vmovups [rbp+70h+var_40], ymm0
    vmovups ymm0, [rbp+70h+var_E0]
    vmovups [rsp+170h+var_100], ymm1
    vmovups ymm1, [rbp+70h+var_C0]
    vmovups [rbp+70h+var_E0], ymm0
    vmovups ymm0, [rbp+70h+var_A0]
    vmovups [rbp+70h+var_C0], ymm1
    vmovups ymm1, [rbp+70h+var_80]
    vmovups [rbp+70h+var_A0], ymm0
    vmovups ymm0, [rbp+70h+var_60]
    vmovups [rbp+70h+var_80], ymm1
    vmovups [rbp+70h+var_60], ymm0
  }
  R_GP_GenerateSModelSurfData(computeState, data, v9, &v56, &v55, &v54, &v53, &v52, &v51, &v57);
}

/*
==============
RBT_GP_GenerateSModelSurfs
==============
*/
void RBT_GP_GenerateSModelSurfs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v28; 
  R_RT_Handle v32; 
  R_RT_BufferHandle v33; 
  R_RT_BufferHandle v34; 
  R_RT_BufferHandle v35; 
  R_RT_BufferHandle v36; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_60], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+57h+var_40] }
      if ( v28 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+57h+var_A0]
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymm0, [rbp+57h+var_80]
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymm1, [rbp+57h+var_60]
    vmovups [rbp+57h+var_80], ymm0
    vmovups [rbp+57h+var_60], ymm1
  }
  R_GP_GenerateSModelSurfs(computeState, data, v9, &v35, &v34, &v33, &v36);
}

/*
==============
RBT_GP_GenerateSModelWorkgroups
==============
*/
void RBT_GP_GenerateSModelWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v18; 
  R_RT_Handle v20; 
  R_RT_BufferHandle v21; 
  R_RT_BufferHandle v22; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rsp+0A8h+var_58], ymm1
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0A8h+var_38], ymm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0A8h+var_38] }
      if ( v18 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_58], ymm1
    vmovups [rsp+0A8h+var_38], ymm0
  }
  R_GP_GenerateSModelWorkgroups(computeState, data, v9, &v21, &v22);
}

/*
==============
RBT_GP_GenerateSubMeshClusterIndirectArgs
==============
*/
void RBT_GP_GenerateSubMeshClusterIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v28; 
  R_RT_Handle v35; 
  R_RT_BufferHandle v36; 
  R_RT_BufferHandle v37; 
  R_RT_BufferHandle v38; 
  R_RT_BufferHandle v39; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_40], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_40], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_40], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_60], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_80], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_A0], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm1, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm1, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm1, [rbp+57h+var_A0] }
      if ( v28 )
        __debugbreak();
    }
    else
    {
      __asm { vmovups ymm1, [rbp+57h+var_A0] }
    }
  }
  v36.m_surfaceID = 0;
  v36.m_tracking.m_allocCounter = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+57h+var_A0+10h], xmm0
    vmovups ymm0, [rbp+57h+var_80]
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymm0, [rbp+57h+var_A0]
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
    vmovups ymm1, [rbp+57h+var_60]
    vmovups [rbp+57h+var_A0], ymm0
    vmovups ymm0, [rbp+57h+var_40]
    vmovups [rbp+57h+var_60], ymm1
    vmovups [rbp+57h+var_40], ymm0
  }
  R_GP_InitIndirectArgsFromPrefixSum(computeState, data, v9, 0, 0x200u, 0x10000u, 0x40000u, &v39, &v38, &v36, &v37, (R_RT_BufferHandle *)&v35);
}

/*
==============
RBT_GP_GenerateSubMeshClusterOffsets
==============
*/
void RBT_GP_GenerateSubMeshClusterOffsets(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v28; 
  R_RT_Handle v32; 
  R_RT_BufferHandle v33; 
  R_RT_BufferHandle v34; 
  R_RT_BufferHandle v35; 
  R_RT_BufferHandle v36; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_60], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v32);
    if ( (R_RT_Handle::GetSurface(&v32)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+57h+var_40] }
      if ( v28 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+57h+var_A0]
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymm0, [rbp+57h+var_80]
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymm1, [rbp+57h+var_60]
    vmovups [rbp+57h+var_80], ymm0
    vmovups [rbp+57h+var_60], ymm1
  }
  R_GP_PrefixSum256(computeState, data, v9, 0, &v35, &v34, &v33, &v36);
}

/*
==============
RBT_GP_GenerateSubMeshWorkgroupGenIndirectArgs
==============
*/
void RBT_GP_GenerateSubMeshWorkgroupGenIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v10; 
  unsigned int PassDynSurfCount; 
  R_RT_Handle v24; 
  R_RT_BufferHandle v25; 
  R_RT_BufferHandle v26; 
  void *retaddr; 

  _R11 = &retaddr;
  v10 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups ymmword ptr [r11-38h], ymm1
    vmovups ymmword ptr [rsp+0C8h+var_78.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v24);
    if ( (R_RT_Handle::GetSurface(&v24)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID]
        vmovups [rsp+0C8h+var_38], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID]
        vmovups [rsp+0C8h+var_38], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0C8h+var_58], ymm0
    vmovups ymmword ptr [rsp+0C8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v24);
    if ( (R_RT_Handle::GetSurface(&v24)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0C8h+var_78.m_surfaceID]
        vmovups [rsp+0C8h+var_58], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  PassDynSurfCount = R_GP_GetPassDynSurfCount(data, v10);
  __asm
  {
    vmovups ymm0, [rsp+0C8h+var_58]
    vmovups ymm1, [rsp+0C8h+var_38]
    vmovups [rsp+0C8h+var_58], ymm0
    vmovups [rsp+0C8h+var_38], ymm1
  }
  R_GP_GenerateIndirectArgsFromCounter(computeState, data, v10, 0x40u, 0, PassDynSurfCount, 0x10000u, &v26, &v25);
}

/*
==============
RBT_GP_GenerateSubMeshWorkgroups
==============
*/
void RBT_GP_GenerateSubMeshWorkgroups(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v38; 
  R_RT_Handle v44; 
  R_RT_BufferHandle v45; 
  R_RT_BufferHandle v46; 
  R_RT_BufferHandle v47; 
  R_RT_BufferHandle v48; 
  R_RT_BufferHandle v49; 
  R_RT_BufferHandle v50; 

  v9 = *taskInfo->pTaskData;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_60], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_80], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovd   eax, xmm1
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v44);
    if ( (R_RT_Handle::GetSurface(&v44)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v38 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+50h+var_40] }
      if ( v38 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+150h+var_E0]
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymm0, [rbp+50h+var_C0]
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymm1, [rbp+50h+var_A0]
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymm0, [rbp+50h+var_80]
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymm1, [rbp+50h+var_60]
    vmovups [rbp+50h+var_80], ymm0
    vmovups [rbp+50h+var_60], ymm1
  }
  R_GP_GenerateSubMeshWorkgroups(computeState, data, v9, &v49, &v48, &v47, &v46, &v45, &v50);
}

/*
==============
RBT_GP_InitClutterFrame
==============
*/
void RBT_GP_InitClutterFrame(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_GPU_InitClutterFrame(computeState, data, *taskInfo->pTaskData);
}

/*
==============
RBT_GP_InitDrawIndirectArgs
==============
*/
void RBT_GP_InitDrawIndirectArgs(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  bool v10; 
  unsigned int v11; 
  bool v13; 
  bool v31; 
  R_RT_Handle v35; 
  R_RT_BufferHandle v36; 
  R_RT_BufferHandle v37; 
  R_RT_BufferHandle v38; 
  R_RT_BufferHandle v39; 

  pTaskData = taskInfo->pTaskData;
  v10 = pTaskData[1] == 0;
  v11 = *pTaskData;
  _RAX = taskInfo->attachments;
  v13 = !v10;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_60], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_80], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID]
        vmovups [rbp+57h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rbp+57h+var_C0.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v31 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+57h+var_40] }
      if ( v31 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rbp+57h+var_A0]
    vmovups [rbp+57h+var_40], ymm0
    vmovups ymm0, [rbp+57h+var_80]
    vmovups [rbp+57h+var_A0], ymm1
    vmovups ymm1, [rbp+57h+var_60]
    vmovups [rbp+57h+var_80], ymm0
    vmovups [rbp+57h+var_60], ymm1
  }
  R_GP_InitDrawIndirectArgs(computeState, data, v11, v13, &v38, &v37, &v36, &v39);
}

/*
==============
RBT_GP_ReadBackGPStats
==============
*/
void RBT_GP_ReadBackGPStats(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  bool v10; 
  unsigned int v11; 
  bool v13; 
  bool v41; 
  R_RT_Handle v47; 
  R_RT_BufferHandle v48; 
  R_RT_BufferHandle v49; 
  R_RT_BufferHandle v50; 
  R_RT_BufferHandle v51; 
  R_RT_BufferHandle v52; 
  R_RT_BufferHandle v53; 

  pTaskData = taskInfo->pTaskData;
  v10 = pTaskData[1] == 0;
  v11 = *pTaskData;
  _RAX = taskInfo->attachments;
  v13 = !v10;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_60], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_60], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_80], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_80], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_A0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rbp+50h+var_C0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovd   eax, xmm1
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID]
        vmovups [rsp+150h+var_E0], ymm0
      }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymmword ptr [rsp+150h+var_100.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+150h+var_100.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v41 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rbp+50h+var_40] }
      if ( v41 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+150h+var_E0]
    vmovups [rbp+50h+var_40], ymm0
    vmovups ymm0, [rbp+50h+var_C0]
    vmovups [rsp+150h+var_E0], ymm1
    vmovups ymm1, [rbp+50h+var_A0]
    vmovups [rbp+50h+var_C0], ymm0
    vmovups ymm0, [rbp+50h+var_80]
    vmovups [rbp+50h+var_A0], ymm1
    vmovups ymm1, [rbp+50h+var_60]
    vmovups [rbp+50h+var_80], ymm0
    vmovups [rbp+50h+var_60], ymm1
  }
  R_GP_ReadBackGPStats(computeState, data, v11, &v52, &v51, &v50, &v49, &v48, &v53, v13);
}

/*
==============
RBT_GP_ResetClutterFrame
==============
*/
void RBT_GP_ResetClutterFrame(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_GPU_ResetClutterFrame(computeState, data);
}

/*
==============
RT_GP_DObjSurfsSetup
==============
*/
void RT_GP_DObjSurfsSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ;
}

/*
==============
RT_GP_SModelSurfsSetup
==============
*/
void RT_GP_SModelSurfsSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ;
}

/*
==============
R_TGS_GP_ProcessSurfs
==============
*/
void R_TGS_GP_ProcessSurfs(R_TG_Script *pScript, const GfxGPConfig *gpConfig, R_TG_Handle beginToken, R_TG_Handle *triIDTexture, R_TG_Handle *occlusionDepthTexture, R_TG_Handle *umbraOcclusionTexture, R_TG_Handle *inoutSceneIndices, R_TG_Handle *inoutSceneIndirectArgs, R_TG_Handle *inoutPerSurfData, TG_GP_PerPassBuffers *perPassBuffers, R_TG_Handle *nullBuffer, R_TG_Handle *nullRwBuffer, R_TG_Handle *indiciesToken)
{
  R_TG_Handle *v13; 
  TG_GP_PerPassBuffers *v14; 
  R_TG_Script *v16; 
  R_TG_Handle *v17; 
  R_TG_Handle *v18; 
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v21; 
  bool v22; 
  unsigned int v23; 
  GFX_GP_PASS passIndex; 
  unsigned int v25; 
  __int64 v26; 
  GFX_GP_PASS v27; 
  unsigned int v28; 
  __int64 v29; 
  __int64 v30; 
  GFX_GP_PASS v31; 
  R_TG_Handle *v32; 
  unsigned int v33; 
  GFX_GP_PASS v34; 
  __int64 v35; 
  GFX_GP_PASS v36; 
  unsigned int v37; 
  __int64 v38; 
  __int64 v39; 
  GFX_GP_PASS v40; 
  unsigned int v41; 
  __int64 v42; 
  __int64 v43; 
  __int64 v44; 
  GFX_GP_PASS v45; 
  unsigned int v46; 
  __int64 v47; 
  GFX_GP_PASS v48; 
  unsigned int v49; 
  __int64 v50; 
  __int64 v51; 
  __int64 v52; 
  GFX_GP_PASS v53; 
  __int64 v54; 
  __int64 v55; 
  GFX_GP_PASS v56; 
  unsigned int v57; 
  __int64 v58; 
  GFX_GP_PASS v59; 
  unsigned int v60; 
  __int64 v61; 
  __int64 v62; 
  GFX_GP_PASS v63; 
  unsigned int v64; 
  __int64 v65; 
  __int64 v66; 
  __int64 v67; 
  GFX_GP_PASS v68; 
  bool *p_reusePrepassVisData; 
  unsigned int v70; 
  __int64 v71; 
  __int64 v72; 
  bool v73; 
  R_TG_Handle *p_prevCulledSubMeshBuffer; 
  const R_TG_Handle *p_prevCulledTriClusterBuffer; 
  R_TG_Handle *p_prevSubMeshClusterOffsetsBuffer; 
  R_TG_Handle *v77; 
  unsigned int v78; 
  __int64 v79; 
  __int64 v80; 
  __int64 v81; 
  GFX_GP_PASS v82; 
  R_TG_Script *v83; 
  unsigned int v84; 
  __int64 v85; 
  __int64 v86; 
  __int64 v87; 
  GFX_GP_PASS v88; 
  unsigned int v89; 
  R_TG_Script *v90; 
  R_TG_Script *v91; 
  unsigned int v92; 
  const R_TG_Handle *p_clusterWorkgroupArgsBuffer; 
  R_TG_Handle *v94; 
  unsigned int v95; 
  __int64 v96; 
  __int64 v97; 
  __int64 v98; 
  unsigned int v99; 
  R_TG_Handle *v100; 
  bool v101; 
  unsigned int v102; 
  __int64 v103; 
  R_TG_Handle *v104; 
  bool v105; 
  R_TG_Handle v106; 
  R_TG_Handle v107; 
  R_TG_Handle v108; 
  R_TG_Handle v109; 
  R_TG_Handle v110; 
  int v111; 
  R_TG_Handle v112; 
  R_TG_Handle v113; 
  R_TG_Handle v114; 
  R_TG_Handle v115; 
  int v116; 
  int v117; 
  int v118; 
  int v119; 
  int v120; 
  int v121; 
  R_TG_Handle value; 
  R_TG_Handle v123; 
  int v124; 
  int v125; 
  R_TG_Handle v126; 
  R_TG_Handle v127; 
  int v128; 
  int v129; 
  R_TG_Script *context; 
  R_TG_Handle *v131; 
  R_TG_AddTaskStack stack; 
  unsigned int index; 

  index = beginToken.index;
  v13 = inoutSceneIndices;
  v14 = perPassBuffers;
  v131 = triIDTexture;
  v16 = pScript;
  context = pScript;
  if ( inoutSceneIndices->index == -1 )
  {
    v17 = inoutSceneIndirectArgs;
    if ( inoutSceneIndirectArgs->index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 782, ASSERT_TYPE_ASSERT, "(!inoutSceneIndirectArgs.IsValid())", (const char *)&queryFormat, "!inoutSceneIndirectArgs.IsValid()") )
      __debugbreak();
    v18 = inoutPerSurfData;
    if ( inoutPerSurfData->index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 783, ASSERT_TYPE_ASSERT, "(!inoutPerSurfData.IsValid())", (const char *)&queryFormat, "!inoutPerSurfData.IsValid()") )
      __debugbreak();
    memset_0(&stack, 0, sizeof(stack));
    ++stack.paramArgCount;
    m_index = g_R_TG_Def_RBT_GP_CreateBuffers.m_index;
    stack.paramArgs[0] = 163840;
    if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.handleArgs[stack.handleArgCount] = &v13->index;
    handleArgCount = stack.handleArgCount + 1;
    stack.handleArgCount = handleArgCount;
    if ( (unsigned int)handleArgCount >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      handleArgCount = stack.handleArgCount;
    }
    stack.handleArgs[handleArgCount] = &v17->index;
    v21 = stack.handleArgCount + 1;
    stack.handleArgCount = v21;
    if ( (unsigned int)v21 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v21 = stack.handleArgCount;
    }
    stack.handleArgs[v21] = &v18->index;
    ++stack.handleArgCount;
    R_TG_AddTask(v16, m_index, &stack);
  }
  if ( v14->batchSubMeshOffsetsBuffer.index == -1 )
  {
    if ( v14->subMeshWorkgroupArgsBuffer.index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 793, ASSERT_TYPE_ASSERT, "(!perPassBuffers.subMeshWorkgroupArgsBuffer.IsValid())", (const char *)&queryFormat, "!perPassBuffers.subMeshWorkgroupArgsBuffer.IsValid()") )
      __debugbreak();
    if ( v14->subMeshCountBuffer.index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 794, ASSERT_TYPE_ASSERT, "(!perPassBuffers.subMeshCountBuffer.IsValid())", (const char *)&queryFormat, "!perPassBuffers.subMeshCountBuffer.IsValid()") )
      __debugbreak();
    if ( v14->clusterPassIndirectArgsBuffer.index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 795, ASSERT_TYPE_ASSERT, "(!perPassBuffers.clusterPassIndirectArgsBuffer.IsValid())", (const char *)&queryFormat, "!perPassBuffers.clusterPassIndirectArgsBuffer.IsValid()") )
      __debugbreak();
    if ( v14->clusterPPSumIndirectArgsBuffer.index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 796, ASSERT_TYPE_ASSERT, "(!perPassBuffers.clusterPPSumIndirectArgsBuffer.IsValid())", (const char *)&queryFormat, "!perPassBuffers.clusterPPSumIndirectArgsBuffer.IsValid()") )
      __debugbreak();
    if ( v14->prevCulledSubMeshBuffer.index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 797, ASSERT_TYPE_ASSERT, "(!perPassBuffers.prevCulledSubMeshBuffer.IsValid())", (const char *)&queryFormat, "!perPassBuffers.prevCulledSubMeshBuffer.IsValid()") )
      __debugbreak();
    if ( v14->prevSubMeshClusterOffsetsBuffer.index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 798, ASSERT_TYPE_ASSERT, "(!perPassBuffers.prevSubMeshClusterOffsetsBuffer.IsValid())", (const char *)&queryFormat, "!perPassBuffers.prevSubMeshClusterOffsetsBuffer.IsValid()") )
      __debugbreak();
    if ( v14->prevCulledTriClusterBuffer.index != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_gpu_pipeline.h", 799, ASSERT_TYPE_ASSERT, "(!perPassBuffers.prevCulledTriClusterBuffer.IsValid())", (const char *)&queryFormat, "!perPassBuffers.prevCulledTriClusterBuffer.IsValid()") )
      __debugbreak();
    memset_0(&stack, 0, sizeof(stack));
    v16 = context;
    R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_GP_CreatePassBuffers.m_index, &stack, &v14->batchSubMeshOffsetsBuffer, &v14->subMeshWorkgroupArgsBuffer, &v14->subMeshCountBuffer, &v14->clusterPassIndirectArgsBuffer, &v14->clusterPPSumIndirectArgsBuffer, &v14->prevCulledSubMeshBuffer, &v14->prevSubMeshClusterOffsetsBuffer, &v14->prevCulledTriClusterBuffer, &v14->clusterWorkgroupArgsBuffer);
  }
  v22 = !gpConfig->skipPerSurfData;
  v108.index = -1;
  v107.index = -1;
  if ( v22 )
  {
    v116 = -1;
    memset_0(&stack, 0, sizeof(stack));
    v23 = g_R_TG_Def_RBT_GP_InitClutterFrame.m_index;
    passIndex = gpConfig->passIndex;
    stack.handleArgs[0] = (unsigned int *)&v116;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = passIndex;
    if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.handleArgs[stack.handleArgCount++] = &index;
    R_TG_AddTask(v16, v23, &stack);
    v117 = -1;
    memset_0(&stack, 0, sizeof(stack));
    v25 = g_R_TG_Def_RBT_GP_GenerateClutter.m_index;
    stack.handleArgs[0] = (unsigned int *)&v116;
    v26 = stack.handleArgCount + 1;
    stack.handleArgCount = v26;
    if ( (unsigned int)v26 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v26 = stack.handleArgCount;
    }
    v27 = gpConfig->passIndex;
    stack.handleArgs[v26] = (unsigned int *)&v117;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v27;
    if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.handleArgs[stack.handleArgCount++] = &index;
    R_TG_AddTask(v16, v25, &stack);
    v111 = -1;
    memset_0(&stack, 0, sizeof(stack));
    v28 = g_R_TG_Def_RBT_GP_ClearCounterResourcesToZero.m_index;
    stack.handleArgs[0] = (unsigned int *)&v111;
    v29 = stack.handleArgCount + 1;
    stack.handleArgCount = v29;
    if ( (unsigned int)v29 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v29 = stack.handleArgCount;
    }
    stack.handleArgs[v29] = (unsigned int *)&v108;
    v30 = stack.handleArgCount + 1;
    stack.handleArgCount = v30;
    if ( (unsigned int)v30 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v30 = stack.handleArgCount;
    }
    v31 = gpConfig->passIndex;
    stack.handleArgs[v30] = (unsigned int *)&v107;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v31;
    R_TG_AddTask(v16, v28, &stack);
    v114.index = -1;
    memset_0(&stack, 0, sizeof(stack));
    v32 = inoutPerSurfData;
    v33 = g_R_TG_Def_RBT_GP_GenerateDynSurfData.m_index;
    v34 = gpConfig->passIndex;
    stack.handleArgs[0] = &inoutPerSurfData->index;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v34;
    if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.handleArgs[stack.handleArgCount] = (unsigned int *)&v111;
    v35 = stack.handleArgCount + 1;
    stack.handleArgCount = v35;
    if ( (unsigned int)v35 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v35 = stack.handleArgCount;
    }
    v36 = gpConfig->passIndex;
    stack.handleArgs[v35] = (unsigned int *)&v114;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v36;
    if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.handleArgs[stack.handleArgCount++] = &index;
    R_TG_AddTask(v16, v33, &stack);
    v118 = -1;
    v119 = -1;
    memset_0(&stack, 0, sizeof(stack));
    v37 = g_R_TG_Def_RBT_GP_GenerateSModelWorkgroups.m_index;
    stack.handleArgs[0] = (unsigned int *)&v118;
    v38 = stack.handleArgCount + 1;
    stack.handleArgCount = v38;
    if ( (unsigned int)v38 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v38 = stack.handleArgCount;
    }
    stack.handleArgs[v38] = (unsigned int *)&v119;
    v39 = stack.handleArgCount + 1;
    stack.handleArgCount = v39;
    if ( (unsigned int)v39 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v39 = stack.handleArgCount;
    }
    v40 = gpConfig->passIndex;
    stack.handleArgs[v39] = (unsigned int *)&v117;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v40;
    R_TG_AddTask(v16, v37, &stack);
    v121 = -1;
    memset_0(&stack, 0, sizeof(stack));
    v41 = g_R_TG_Def_RBT_GP_GenerateSModelSurfs.m_index;
    stack.handleArgs[0] = (unsigned int *)&v118;
    v42 = stack.handleArgCount + 1;
    stack.handleArgCount = v42;
    if ( (unsigned int)v42 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v42 = stack.handleArgCount;
    }
    stack.handleArgs[v42] = (unsigned int *)&v119;
    v43 = stack.handleArgCount + 1;
    stack.handleArgCount = v43;
    if ( (unsigned int)v43 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v43 = stack.handleArgCount;
    }
    stack.handleArgs[v43] = (unsigned int *)&v121;
    v44 = stack.handleArgCount + 1;
    stack.handleArgCount = v44;
    if ( (unsigned int)v44 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v44 = stack.handleArgCount;
    }
    v45 = gpConfig->passIndex;
    stack.handleArgs[v44] = (unsigned int *)&v108;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v45;
    R_TG_AddTask(v16, v41, &stack);
    v120 = -1;
    memset_0(&stack, 0, sizeof(stack));
    v46 = g_R_TG_Def_RBT_GP_GenerateSModelDataGenIndirectArgs.m_index;
    stack.handleArgs[0] = (unsigned int *)&v108;
    v47 = stack.handleArgCount + 1;
    stack.handleArgCount = v47;
    if ( (unsigned int)v47 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v47 = stack.handleArgCount;
    }
    v48 = gpConfig->passIndex;
    stack.handleArgs[v47] = (unsigned int *)&v120;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v48;
    R_TG_AddTask(v16, v46, &stack);
    memset_0(&stack, 0, sizeof(stack));
    v49 = g_R_TG_Def_RBT_GP_GenerateSModelSurfData.m_index;
    stack.handleArgs[0] = (unsigned int *)&v120;
    v50 = stack.handleArgCount + 1;
    stack.handleArgCount = v50;
    if ( (unsigned int)v50 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v50 = stack.handleArgCount;
    }
    stack.handleArgs[v50] = (unsigned int *)&v121;
    v51 = stack.handleArgCount + 1;
    stack.handleArgCount = v51;
    if ( (unsigned int)v51 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v51 = stack.handleArgCount;
    }
    stack.handleArgs[v51] = (unsigned int *)&v108;
    v52 = stack.handleArgCount + 1;
    stack.handleArgCount = v52;
    if ( (unsigned int)v52 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v52 = stack.handleArgCount;
    }
    v53 = gpConfig->passIndex;
    stack.handleArgs[v52] = &v32->index;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v53;
    if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.handleArgs[stack.handleArgCount] = (unsigned int *)&v107;
    v54 = stack.handleArgCount + 1;
    stack.handleArgCount = v54;
    if ( (unsigned int)v54 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v54 = stack.handleArgCount;
    }
    stack.handleArgs[v54] = (unsigned int *)&v111;
    v55 = stack.handleArgCount + 1;
    stack.handleArgCount = v55;
    if ( (unsigned int)v55 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v55 = stack.handleArgCount;
    }
    v56 = gpConfig->passIndex;
    stack.handleArgs[v55] = (unsigned int *)&v114;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v56;
    R_TG_AddTask(v16, v49, &stack);
    value.index = -1;
    memset_0(&stack, 0, sizeof(stack));
    v57 = g_R_TG_Def_RBT_GP_GenerateSubMeshWorkgroupGenIndirectArgs.m_index;
    stack.handleArgs[0] = (unsigned int *)&v107;
    v58 = stack.handleArgCount + 1;
    stack.handleArgCount = v58;
    if ( (unsigned int)v58 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v58 = stack.handleArgCount;
    }
    v59 = gpConfig->passIndex;
    stack.handleArgs[v58] = (unsigned int *)&value;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v59;
    R_TG_AddTask(v16, v57, &stack);
    v125 = -1;
    memset_0(&stack, 0, sizeof(stack));
    v60 = g_R_TG_Def_RBT_GP_GenerateBatchSubMeshOffsets.m_index;
    stack.handleArgs[0] = (unsigned int *)&v111;
    v61 = stack.handleArgCount + 1;
    stack.handleArgCount = v61;
    if ( (unsigned int)v61 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v61 = stack.handleArgCount;
    }
    stack.handleArgs[v61] = (unsigned int *)&v125;
    v62 = stack.handleArgCount + 1;
    stack.handleArgCount = v62;
    if ( (unsigned int)v62 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v62 = stack.handleArgCount;
    }
    v63 = gpConfig->passIndex;
    stack.handleArgs[v62] = &v14->batchSubMeshOffsetsBuffer.index;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v63;
    R_TG_AddTask(v16, v60, &stack);
    memset_0(&stack, 0, sizeof(stack));
    v64 = g_R_TG_Def_RBT_GP_GenerateBatchSubMeshIndirectArgs.m_index;
    v65 = stack.handleArgCount + 1;
    stack.handleArgs[0] = &v14->batchSubMeshOffsetsBuffer.index;
    stack.handleArgCount = v65;
    if ( (unsigned int)v65 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v65 = stack.handleArgCount;
    }
    stack.handleArgs[v65] = &v14->subMeshCountBuffer.index;
    v66 = stack.handleArgCount + 1;
    stack.handleArgCount = v66;
    if ( (unsigned int)v66 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v66 = stack.handleArgCount;
    }
    stack.handleArgs[v66] = &v14->clusterPassIndirectArgsBuffer.index;
    v67 = stack.handleArgCount + 1;
    stack.handleArgCount = v67;
    if ( (unsigned int)v67 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v67 = stack.handleArgCount;
    }
    v68 = gpConfig->passIndex;
    stack.handleArgs[v67] = &v14->clusterPPSumIndirectArgsBuffer.index;
    if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    stack.paramArgs[stack.paramArgCount++] = v68;
    R_TG_AddTask(v16, v64, &stack);
    memset_0(&stack, 0, sizeof(stack));
    R_TG_AddTask<R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS>(v16, g_R_TG_Def_RBT_GP_GenerateSubMeshWorkgroups.m_index, &stack, &value, &v107, v32, &gpConfig->passIndex, &v14->batchSubMeshOffsetsBuffer, &v114, &v14->subMeshWorkgroupArgsBuffer, &gpConfig->passIndex);
  }
  else
  {
    v108.index = nullRwBuffer->index;
    v107.index = v108.index;
  }
  v22 = !gpConfig->reusePrepassVisData;
  p_reusePrepassVisData = &gpConfig->reusePrepassVisData;
  v109.index = -1;
  v106.index = -1;
  v110.index = -1;
  if ( v22 )
  {
    p_prevCulledSubMeshBuffer = &v14->prevCulledSubMeshBuffer;
    v109.index = v14->prevCulledSubMeshBuffer.index;
    p_prevCulledTriClusterBuffer = &v14->prevCulledTriClusterBuffer;
    v73 = 0;
    v106.index = v14->prevSubMeshClusterOffsetsBuffer.index;
    v110.index = v14->prevCulledTriClusterBuffer.index;
  }
  else
  {
    memset_0(&stack, 0, sizeof(stack));
    v70 = g_R_TG_Def_RBT_GP_CreateTemporaryBuffers.m_index;
    stack.handleArgs[0] = (unsigned int *)&v109;
    v71 = stack.handleArgCount + 1;
    stack.handleArgCount = v71;
    if ( (unsigned int)v71 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v71 = stack.handleArgCount;
    }
    stack.handleArgs[v71] = (unsigned int *)&v106;
    v72 = stack.handleArgCount + 1;
    stack.handleArgCount = v72;
    if ( (unsigned int)v72 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v72 = stack.handleArgCount;
    }
    stack.handleArgs[v72] = (unsigned int *)&v110;
    ++stack.handleArgCount;
    R_TG_AddTask(v16, v70, &stack);
    v73 = *p_reusePrepassVisData;
    p_prevCulledSubMeshBuffer = &v14->prevCulledSubMeshBuffer;
    p_prevCulledTriClusterBuffer = &v14->prevCulledTriClusterBuffer;
  }
  p_prevSubMeshClusterOffsetsBuffer = nullBuffer;
  v77 = nullBuffer;
  v123.index = -1;
  if ( v73 )
    v77 = p_prevCulledSubMeshBuffer;
  v127.index = v77->index;
  if ( v73 )
    p_prevSubMeshClusterOffsetsBuffer = &v14->prevSubMeshClusterOffsetsBuffer;
  v126.index = p_prevSubMeshClusterOffsetsBuffer->index;
  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &v14->clusterPassIndirectArgsBuffer.index;
  R_TG_AddTask<R_TG_Handle,enum GFX_GP_PASS,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,bool,bool>(v16, g_R_TG_Def_RBT_GP_CullClusters.m_index, &stack, &v14->subMeshWorkgroupArgsBuffer, inoutPerSurfData, &gpConfig->passIndex, &v127, &v126, occlusionDepthTexture, umbraOcclusionTexture, &v109, &v123, p_prevCulledTriClusterBuffer, &gpConfig->passIndex, &gpConfig->reusePrepassVisData, &gpConfig->useVisBufferPrepass);
  v128 = -1;
  memset_0(&stack, 0, sizeof(stack));
  v78 = g_R_TG_Def_RBT_GP_GenerateSubMeshClusterOffsets.m_index;
  stack.handleArgs[0] = &v14->clusterPPSumIndirectArgsBuffer.index;
  v79 = stack.handleArgCount + 1;
  stack.handleArgCount = v79;
  if ( (unsigned int)v79 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v79 = stack.handleArgCount;
  }
  stack.handleArgs[v79] = (unsigned int *)&v123;
  v80 = stack.handleArgCount + 1;
  stack.handleArgCount = v80;
  if ( (unsigned int)v80 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v80 = stack.handleArgCount;
  }
  stack.handleArgs[v80] = (unsigned int *)&v128;
  v81 = stack.handleArgCount + 1;
  stack.handleArgCount = v81;
  if ( (unsigned int)v81 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v81 = stack.handleArgCount;
  }
  v82 = gpConfig->passIndex;
  stack.handleArgs[v81] = (unsigned int *)&v106;
  if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
    __debugbreak();
  v83 = context;
  stack.paramArgs[stack.paramArgCount++] = v82;
  R_TG_AddTask(v83, v78, &stack);
  v115.index = -1;
  v124 = -1;
  memset_0(&stack, 0, sizeof(stack));
  v84 = g_R_TG_Def_RBT_GP_GenerateSubMeshClusterIndirectArgs.m_index;
  stack.handleArgs[0] = &v14->subMeshCountBuffer.index;
  v85 = stack.handleArgCount + 1;
  stack.handleArgCount = v85;
  if ( (unsigned int)v85 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v85 = stack.handleArgCount;
  }
  stack.handleArgs[v85] = (unsigned int *)&v106;
  v86 = stack.handleArgCount + 1;
  stack.handleArgCount = v86;
  if ( (unsigned int)v86 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v86 = stack.handleArgCount;
  }
  stack.handleArgs[v86] = (unsigned int *)&v115;
  v87 = stack.handleArgCount + 1;
  stack.handleArgCount = v87;
  if ( (unsigned int)v87 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v87 = stack.handleArgCount;
  }
  v88 = gpConfig->passIndex;
  stack.handleArgs[v87] = (unsigned int *)&v124;
  if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
    __debugbreak();
  v89 = v84;
  v90 = context;
  v91 = context;
  stack.paramArgs[stack.paramArgCount++] = v88;
  R_TG_AddTask(v91, v89, &stack);
  v112.index = -1;
  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = (unsigned int *)&v112;
  R_TG_AddTask(v90, g_R_TG_Def_RBT_GP_CreateClusterTriCountsBuffer.m_index, &stack);
  if ( *p_reusePrepassVisData )
  {
    if ( gpConfig->useVisBufferPrepass && gpConfig->passIndex == GFX_GP_PASS_CAMERA )
    {
      memset_0(&stack, 0, sizeof(stack));
      v92 = g_R_TG_Def_RBT_GPV_VisibilityBufferPrepassMSAA.m_index;
      if ( !gpConfig->useMSAAVisBufferPrepass )
        v92 = g_R_TG_Def_RBT_GPV_VisibilityBufferPrepass.m_index;
      R_TG_AddTask<R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,R_TG_Handle,enum GFX_GP_PASS>(v90, v92, &stack, v131, &v14->clusterWorkgroupArgsBuffer, inoutPerSurfData, &gpConfig->passIndex, p_prevCulledTriClusterBuffer, &gpConfig->passIndex);
    }
    memset_0(&stack, 0, sizeof(stack));
    ++stack.handleArgCount;
    p_clusterWorkgroupArgsBuffer = &v14->clusterWorkgroupArgsBuffer;
    stack.handleArgs[0] = &v14->clusterPassIndirectArgsBuffer.index;
    v104 = p_prevCulledSubMeshBuffer;
    v94 = inoutPerSurfData;
    R_TG_AddTask<R_TG_Handle,enum GFX_GP_PASS,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS>(v90, g_R_TG_Def_RBT_GP_GenerateClusterWorkgroupsAndVisBits.m_index, &stack, &v14->subMeshWorkgroupArgsBuffer, inoutPerSurfData, &gpConfig->passIndex, &v109, &v106, v104, &v14->prevSubMeshClusterOffsetsBuffer, p_prevCulledTriClusterBuffer, &v14->clusterWorkgroupArgsBuffer, &v110, &v112, &gpConfig->passIndex);
  }
  else
  {
    memset_0(&stack, 0, sizeof(stack));
    v94 = inoutPerSurfData;
    p_clusterWorkgroupArgsBuffer = &v14->clusterWorkgroupArgsBuffer;
    R_TG_AddTask<R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS>(v90, g_R_TG_Def_RBT_GP_GenerateClusterWorkgroups.m_index, &stack, &v14->clusterPassIndirectArgsBuffer, &v14->subMeshWorkgroupArgsBuffer, inoutPerSurfData, &gpConfig->passIndex, &v109, &v106, &v14->clusterWorkgroupArgsBuffer, &gpConfig->passIndex);
  }
  if ( !gpConfig->useVisBufferPrepass )
  {
    memset_0(&stack, 0, sizeof(stack));
    R_TG_AddTask<R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,bool>(v90, g_R_TG_Def_RBT_GP_CullTriangles.m_index, &stack, &v115, p_clusterWorkgroupArgsBuffer, v94, &gpConfig->passIndex, occlusionDepthTexture, umbraOcclusionTexture, &v110, &v112, &gpConfig->passIndex, &gpConfig->reusePrepassVisData);
  }
  v129 = -1;
  v113.index = -1;
  memset_0(&stack, 0, sizeof(stack));
  v95 = g_R_TG_Def_RBT_GP_GenerateClusterTriOffsets.m_index;
  stack.handleArgs[0] = (unsigned int *)&v124;
  v96 = stack.handleArgCount + 1;
  stack.handleArgCount = v96;
  if ( (unsigned int)v96 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v96 = stack.handleArgCount;
  }
  stack.handleArgs[v96] = (unsigned int *)&v112;
  v97 = stack.handleArgCount + 1;
  stack.handleArgCount = v97;
  if ( (unsigned int)v97 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v97 = stack.handleArgCount;
  }
  stack.handleArgs[v97] = (unsigned int *)&v129;
  v98 = stack.handleArgCount + 1;
  stack.handleArgCount = v98;
  if ( (unsigned int)v98 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v98 = stack.handleArgCount;
  }
  v99 = gpConfig->passIndex;
  stack.handleArgs[v98] = (unsigned int *)&v113;
  ++stack.handleArgCount;
  R_TG_AddTask<>(v90, v95, &stack, v99);
  memset_0(&stack, 0, sizeof(stack));
  v100 = inoutSceneIndirectArgs;
  R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,bool>(v90, g_R_TG_Def_RBT_GP_InitDrawIndirectArgs.m_index, &stack, &v14->batchSubMeshOffsetsBuffer, &v106, &v113, inoutSceneIndirectArgs, &gpConfig->passIndex, &gpConfig->isPrepass);
  v101 = gpConfig->passIndex || *p_reusePrepassVisData;
  v105 = v101;
  memset_0(&stack, 0, sizeof(stack));
  R_TG_AddTask<R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,bool>(v90, g_R_TG_Def_RBT_GP_ExpandIndexBuffers.m_index, &stack, &v115, p_clusterWorkgroupArgsBuffer, v94, &gpConfig->passIndex, &v110, &v113, inoutSceneIndices, indiciesToken, &gpConfig->passIndex, &v105);
  if ( gpConfig->readBackPass )
  {
    memset_0(&stack, 0, sizeof(stack));
    v102 = g_R_TG_Def_RBT_GP_ReadBackGPStats.m_index;
    v103 = stack.handleArgCount + 1;
    stack.handleArgs[0] = &v14->batchSubMeshOffsetsBuffer.index;
    stack.handleArgCount = v103;
    if ( (unsigned int)v103 >= 0x1E )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v103 = stack.handleArgCount;
    }
    stack.handleArgs[v103] = (unsigned int *)&v106;
    ++stack.handleArgCount;
    R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,enum GFX_GP_PASS,bool>(v90, v102, &stack, &v113, &v108, &v107, v100, &gpConfig->passIndex, &gpConfig->occlusionPass);
  }
}

