/*
==============
cRBT_SSAO_GenerateAO<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSAO_GenerateAO<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  return ??$cRBT_SSAO_GenerateAO@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
RBT_SSAO_FilterAOPrepassHorizontal
==============
*/

void __fastcall RBT_SSAO_FilterAOPrepassHorizontal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSAO_FilterAOPrepassHorizontal@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSAO_FilterAOPrepassVertical<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSAO_FilterAOPrepassVertical<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_SSAO_FilterAOPrepassVertical@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_SSAO_GenerateAO
==============
*/

void __fastcall RBT_SSAO_GenerateAO(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSAO_GenerateAO@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSAO_FilterAOPrepassHorizontal<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSAO_FilterAOPrepassHorizontal<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_SSAO_FilterAOPrepassHorizontal@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_SSAO_GenerateAOInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSAO_GenerateAOInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  return ??$cRBT_SSAO_GenerateAOInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
RBT_SSAO_FilterAOPrepassVertical
==============
*/

void __fastcall RBT_SSAO_FilterAOPrepassVertical(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSAO_FilterAOPrepassVertical@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSAO_GenerateAOPrepass
==============
*/

void __fastcall RBT_SSAO_GenerateAOPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSAO_GenerateAOPrepass@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSAO_GenerateAOPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSAO_GenerateAOPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_SSAO_GenerateAOPrepass@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_SSAO_GenerateAOInlineResolve
==============
*/

void __fastcall RBT_SSAO_GenerateAOInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSAO_GenerateAOInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSAO_FilterAOPrepassHorizontal<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSAO_FilterAOPrepassHorizontal<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSAO_FilterAOPrepassHorizontal.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSAO_FilterAOPrepassVertical<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSAO_FilterAOPrepassVertical<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSAO_FilterAOPrepassVertical.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSAO_GenerateAO<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSAO_GenerateAO<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SSAO_GenerateAO.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_SSAO_GenerateAOInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSAO_GenerateAOInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SSAO_GenerateAOInlineResolve.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
cRBT_SSAO_GenerateAOPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSAO_GenerateAOPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSAO_GenerateAOPrepass.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBT_SSAO_FilterAOPrepassHorizontal
==============
*/
void RBT_SSAO_FilterAOPrepassHorizontal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v18; 
  R_RT_Handle v20; 
  R_RT_ColorHandle v21; 
  R_RT_ColorHandle v22; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rsp+0A8h+var_58], ymm1
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0A8h+var_38], ymm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0A8h+var_38] }
      if ( v18 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_38], ymm1
    vmovups [rsp+0A8h+var_58], ymm0
  }
  R_SSAO_Filter(computeState, viewInfo, data, &v21, &v22, 1);
}

/*
==============
RBT_SSAO_FilterAOPrepassVertical
==============
*/
void RBT_SSAO_FilterAOPrepassVertical(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v18; 
  R_RT_Handle v20; 
  R_RT_ColorHandle v21; 
  R_RT_ColorHandle v22; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rsp+0A8h+var_58], ymm1
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID]
        vmovups [rsp+0A8h+var_58], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rsp+0A8h+var_38], ymm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v20);
    if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0A8h+var_38] }
      if ( v18 )
        __debugbreak();
    }
  }
  __asm
  {
    vmovups ymm1, [rsp+0A8h+var_58]
    vmovups [rsp+0A8h+var_38], ymm1
    vmovups [rsp+0A8h+var_58], ymm0
  }
  R_SSAO_Filter(computeState, viewInfo, data, &v21, &v22, 0);
}

/*
==============
RBT_SSAO_GenerateAO
==============
*/
void RBT_SSAO_GenerateAO(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v48; 
  R_RT_Handle v62; 
  R_RT_ColorHandle v63; 
  R_RT_ColorHandle v64; 
  R_RT_ColorHandle v65; 
  R_RT_ColorHandle v66; 
  R_RT_ColorHandle v67; 
  R_RT_ColorHandle v68; 
  R_RT_ColorHandle v69; 
  R_RT_ColorHandle v70; 
  R_RT_ColorHandle v71; 
  R_RT_ColorHandle v72; 
  R_RT_ColorHandle v73; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_160], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_160], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_160], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_E0], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_E0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_E0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_60], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_60], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_60], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_A0], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_A0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_A0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_C0], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_C0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_C0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_80], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_80], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_80], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_100], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_100], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_100], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_180], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm1, ymmword ptr [rbp+120h+var_1A0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm1, ymmword ptr [rbp+120h+var_1A0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v48 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm1, [rbp+120h+var_180] }
      if ( v48 )
        __debugbreak();
    }
    else
    {
      __asm { vmovups ymm1, [rbp+120h+var_180] }
    }
  }
  __asm { vmovups ymm2, [rbp+120h+var_160] }
  v63.m_surfaceID = 0;
  v63.m_tracking.m_allocCounter = 0;
  v62.m_surfaceID = 0;
  v62.m_tracking.m_allocCounter = 0;
  v65.m_surfaceID = 0;
  v65.m_tracking.m_allocCounter = 0;
  v66.m_surfaceID = 0;
  v66.m_tracking.m_allocCounter = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+120h+var_1A0.m_tracking.m_name], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_120+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_180+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_140+10h], xmm0
    vmovups ymm0, [rbp+120h+var_180]
    vmovups [rbp+120h+var_40], ymm1
    vmovups ymm1, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
    vmovups [rbp+120h+var_180], ymm0
    vmovups ymm0, [rbp+120h+var_140]
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
    vmovups ymm1, [rbp+120h+var_120]
    vmovups [rbp+120h+var_140], ymm0
    vmovups ymm0, [rbp+120h+var_100]
    vmovups [rbp+120h+var_120], ymm1
    vmovups ymm1, [rbp+120h+var_E0]
    vmovups [rbp+120h+var_100], ymm0
    vmovups ymm0, [rbp+120h+var_C0]
    vmovups [rbp+120h+var_E0], ymm1
    vmovups ymm1, [rbp+120h+var_A0]
    vmovups [rbp+120h+var_C0], ymm0
    vmovups ymm0, [rbp+120h+var_80]
    vmovups [rbp+120h+var_A0], ymm1
    vmovups ymm1, [rbp+120h+var_60]
    vmovups [rbp+120h+var_160], ymm2
    vmovups [rbp+120h+var_80], ymm0
    vmovups [rbp+120h+var_60], ymm1
  }
  R_SSAO_Generate(computeState, viewInfo, data, &v72, &v71, &v70, &v69, &v68, &v67, &v66, &v65, (const R_RT_ColorHandle *)&v62, &v63, &v73, &v64, SSAO_ZONE_ALL, 0);
}

/*
==============
RBT_SSAO_GenerateAOInlineResolve
==============
*/
void RBT_SSAO_GenerateAOInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v48; 
  R_RT_Handle v62; 
  R_RT_ColorHandle v63; 
  R_RT_ColorHandle v64; 
  R_RT_ColorHandle v65; 
  R_RT_ColorHandle v66; 
  R_RT_ColorHandle v67; 
  R_RT_ColorHandle v68; 
  R_RT_ColorHandle v69; 
  R_RT_ColorHandle v70; 
  R_RT_ColorHandle v71; 
  R_RT_ColorHandle v72; 
  R_RT_ColorHandle v73; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_160], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_160], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_160], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_E0], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_E0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_E0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_60], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_60], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_60], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_A0], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_A0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_A0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_C0], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_C0], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_C0], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_80], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_80], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_80], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+0C0h]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_100], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_100], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_100], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_180], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v62);
    if ( (R_RT_Handle::GetSurface(&v62)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm1, ymmword ptr [rbp+120h+var_1A0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm1, ymmword ptr [rbp+120h+var_1A0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v48 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm1, [rbp+120h+var_180] }
      if ( v48 )
        __debugbreak();
    }
    else
    {
      __asm { vmovups ymm1, [rbp+120h+var_180] }
    }
  }
  __asm { vmovups ymm2, [rbp+120h+var_160] }
  v63.m_surfaceID = 0;
  v63.m_tracking.m_allocCounter = 0;
  v62.m_surfaceID = 0;
  v62.m_tracking.m_allocCounter = 0;
  v65.m_surfaceID = 0;
  v65.m_tracking.m_allocCounter = 0;
  v66.m_surfaceID = 0;
  v66.m_tracking.m_allocCounter = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+120h+var_1A0.m_tracking.m_name], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_120+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_180+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_140+10h], xmm0
    vmovups ymm0, [rbp+120h+var_180]
    vmovups [rbp+120h+var_40], ymm1
    vmovups ymm1, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
    vmovups [rbp+120h+var_180], ymm0
    vmovups ymm0, [rbp+120h+var_140]
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
    vmovups ymm1, [rbp+120h+var_120]
    vmovups [rbp+120h+var_140], ymm0
    vmovups ymm0, [rbp+120h+var_100]
    vmovups [rbp+120h+var_120], ymm1
    vmovups ymm1, [rbp+120h+var_E0]
    vmovups [rbp+120h+var_100], ymm0
    vmovups ymm0, [rbp+120h+var_C0]
    vmovups [rbp+120h+var_E0], ymm1
    vmovups ymm1, [rbp+120h+var_A0]
    vmovups [rbp+120h+var_C0], ymm0
    vmovups ymm0, [rbp+120h+var_80]
    vmovups [rbp+120h+var_A0], ymm1
    vmovups ymm1, [rbp+120h+var_60]
    vmovups [rbp+120h+var_160], ymm2
    vmovups [rbp+120h+var_80], ymm0
    vmovups [rbp+120h+var_60], ymm1
  }
  R_SSAO_Generate(computeState, viewInfo, data, &v72, &v71, &v70, &v69, &v68, &v67, &v66, &v65, (const R_RT_ColorHandle *)&v62, &v63, &v73, &v64, SSAO_ZONE_ALL, 0);
}

/*
==============
RBT_SSAO_GenerateAOPrepass
==============
*/
void RBT_SSAO_GenerateAOPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v23; 
  R_RT_Handle v37; 
  R_RT_ColorHandle v38; 
  R_RT_ColorHandle v39; 
  R_RT_ColorHandle v40; 
  R_RT_ColorHandle v41; 
  R_RT_ColorHandle v42; 
  R_RT_ColorHandle v43; 
  R_RT_ColorHandle v44; 
  R_RT_ColorHandle v45; 
  R_RT_ColorHandle v46; 
  R_RT_ColorHandle v47; 
  R_RT_ColorHandle v48; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_160], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_160], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_160], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vmovd   eax, xmm1
    vmovups [rbp+120h+var_120], ymm1
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm1
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_120], ymm0
      }
      __debugbreak();
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
        vmovups [rbp+120h+var_120], ymm0
      }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovd   eax, xmm0
    vmovups [rbp+120h+var_180], ymm0
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm2, ymmword ptr [rbp+120h+var_1A0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm2, ymmword ptr [rbp+120h+var_1A0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm2, [rbp+120h+var_180] }
      if ( v23 )
        __debugbreak();
    }
    else
    {
      __asm { vmovups ymm2, [rbp+120h+var_180] }
    }
  }
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v38.m_surfaceID = 0;
  v38.m_tracking.m_allocCounter = 0;
  v37.m_surfaceID = 0;
  v37.m_tracking.m_allocCounter = 0;
  v40.m_surfaceID = 0;
  v40.m_tracking.m_allocCounter = 0;
  v42.m_surfaceID = 0;
  v42.m_tracking.m_allocCounter = 0;
  v43.m_surfaceID = 0;
  v43.m_tracking.m_allocCounter = 0;
  v44.m_surfaceID = 0;
  v44.m_tracking.m_allocCounter = 0;
  v45.m_surfaceID = 0;
  v45.m_tracking.m_allocCounter = 0;
  v46.m_surfaceID = 0;
  v46.m_tracking.m_allocCounter = 0;
  v47.m_surfaceID = 0;
  v47.m_tracking.m_allocCounter = 0;
  __asm
  {
    vmovdqu xmmword ptr [rbp+120h+var_180+10h], xmm0
    vmovups ymm1, [rbp+120h+var_180]
    vmovdqu xmmword ptr [rbp+120h+var_140+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_E0+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_A0+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_60+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_1A0.m_tracking.m_name], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_100+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_C0+10h], xmm0
    vmovdqu xmmword ptr [rbp+120h+var_80+10h], xmm0
    vmovups ymm0, [rbp+120h+var_160]
    vmovups [rbp+120h+var_160], ymm0
    vmovups ymm0, ymmword ptr [rbp+120h+var_1A0.m_surfaceID]
    vmovups [rbp+120h+var_180], ymm1
    vmovups ymm1, [rbp+120h+var_140]
    vmovups ymmword ptr [rbp+120h+var_1A0.m_surfaceID], ymm0
    vmovups ymm0, [rbp+120h+var_120]
    vmovups [rbp+120h+var_140], ymm1
    vmovups ymm1, [rbp+120h+var_E0]
    vmovups [rbp+120h+var_120], ymm0
    vmovups ymm0, [rbp+120h+var_100]
    vmovups [rbp+120h+var_100], ymm0
    vmovups ymm0, [rbp+120h+var_C0]
    vmovups [rbp+120h+var_E0], ymm1
    vmovups ymm1, [rbp+120h+var_A0]
    vmovups [rbp+120h+var_C0], ymm0
    vmovups ymm0, [rbp+120h+var_80]
    vmovups [rbp+120h+var_A0], ymm1
    vmovups ymm1, [rbp+120h+var_60]
    vmovups [rbp+120h+var_40], ymm2
    vmovups [rbp+120h+var_80], ymm0
    vmovups [rbp+120h+var_60], ymm1
  }
  R_SSAO_Generate(computeState, viewInfo, data, &v47, &v46, &v45, &v44, &v43, &v42, &v41, &v48, &v40, (const R_RT_ColorHandle *)&v37, &v39, &v38, SSAO_ZONE_ALL, 1);
}

