/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/

void __fastcall ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAPEAVIWMemAllocator@@UAllocatorSortFunctor@@@ntl@@YAXPEAPEAVIWMemAllocator@@0UAllocatorSortFunctor@@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@0U12@@Z(first, last, compare);
}

/*
==============
ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/

void __fastcall ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *const *r_iBegin, CachedLookup::Entry *iEnd, unsigned __int64 depthLimit, CachedLookup::SortFunc predicate)
{
  ??$introsort_loop@PEAUEntry@CachedLookup@@VSortFunc@2@@internal@ntl@@YAXAEBQEAUEntry@CachedLookup@@PEAU23@_KVSortFunc@3@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/

void __fastcall ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *predicate)
{
  ??$introsort_loop@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@U12@@internal@ntl@@YAXAEBQEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@PEAU23@_KU23@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare)
{
  ??$sort@PEAPEAUdropBagPlayerInfo_t@@VPlayerPotentialPartnersPredicate@@@ntl@@YAXPEAPEAUdropBagPlayerInfo_t@@0VPlayerPotentialPartnersPredicate@@@Z(first, last, compare);
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/

void __fastcall ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUEntry@CachedLookup@@VSortFunc@2@@ntl@@YAXPEAUEntry@CachedLookup@@0VSortFunc@2@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<ConeTargetHitInfo *>
==============
*/

void __fastcall ntl::sort<ConeTargetHitInfo *>(ConeTargetHitInfo *first, ConeTargetHitInfo *last)
{
  ??$sort@PEAUConeTargetHitInfo@@@ntl@@YAXPEAUConeTargetHitInfo@@0@Z(first, last);
}

/*
==============
ntl::sort<CAssistTarget *>
==============
*/

void __fastcall ntl::sort<CAssistTarget *>(CAssistTarget *first, CAssistTarget *last)
{
  ??$sort@PEAVCAssistTarget@@@ntl@@YAXPEAVCAssistTarget@@0@Z(first, last);
}

/*
==============
ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/

void __fastcall ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **const *r_iBegin, IWMemAllocator **iEnd, unsigned __int64 depthLimit, AllocatorSortFunctor predicate)
{
  ??$introsort_loop@PEAPEAVIWMemAllocator@@UAllocatorSortFunctor@@@internal@ntl@@YAXAEBQEAPEAVIWMemAllocator@@PEAPEAV2@_KUAllocatorSortFunctor@@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare)
{
  ??$sort@PEAPEAUdropBagClusterInfo_t@@VClusterPotentialPlayersPredicate@@@ntl@@YAXPEAPEAUdropBagClusterInfo_t@@0VClusterPotentialPlayersPredicate@@@Z(first, last, compare);
}

/*
==============
ntl::sort<GAssistTarget *>
==============
*/

void __fastcall ntl::sort<GAssistTarget *>(GAssistTarget *first, GAssistTarget *last)
{
  ??$sort@PEAVGAssistTarget@@@ntl@@YAXPEAVGAssistTarget@@0@Z(first, last);
}

/*
==============
ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/

void __fastcall ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *const *r_iBegin, EdgePropertyTuple *iEnd, unsigned __int64 depthLimit, EdgePropertyTuple *predicate)
{
  ??$introsort_loop@PEAUEdgePropertyTuple@@U1@@internal@ntl@@YAXAEBQEAUEdgePropertyTuple@@PEAU2@_KU2@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAPEAUdropBagPlayerInfo_t@@VPlayerPotentialPartnersPredicate@@@ntl@@YAXPEAPEAUdropBagPlayerInfo_t@@0VPlayerPotentialPartnersPredicate@@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/

void __fastcall ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare)
{
  ??$sort@PEAPEAVIWMemAllocator@@UAllocatorSortFunctor@@@ntl@@YAXPEAPEAVIWMemAllocator@@0UAllocatorSortFunctor@@@Z(first, last, compare);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@0U12@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/

void __fastcall ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **const *r_iBegin, dropBagClusterInfo_t **iEnd, unsigned __int64 depthLimit, ClusterPotentialPlayersPredicate predicate)
{
  ??$introsort_loop@PEAPEAUdropBagClusterInfo_t@@VClusterPotentialPlayersPredicate@@@internal@ntl@@YAXAEBQEAPEAUdropBagClusterInfo_t@@PEAPEAU2@_KVClusterPotentialPlayersPredicate@@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/

void __fastcall ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUEdgePropertyTuple@@U1@@ntl@@YAXPEAUEdgePropertyTuple@@0U1@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/

void __fastcall ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare)
{
  ??$sort@PEAUEntry@CachedLookup@@VSortFunc@2@@ntl@@YAXPEAUEntry@CachedLookup@@0VSortFunc@2@@Z(first, last, compare);
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAPEAUdropBagClusterInfo_t@@VClusterPotentialPlayersPredicate@@@ntl@@YAXPEAPEAUdropBagClusterInfo_t@@0VClusterPotentialPlayersPredicate@@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/

void __fastcall ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *predicate)
{
  ??$introsort_loop@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@U12@@internal@ntl@@YAXAEBQEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@PEAU23@_KU23@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@0U12@@Z(first, last, compare);
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/

void __fastcall ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare)
{
  ??$sort@PEAUEdgePropertyTuple@@U1@@ntl@@YAXPEAUEdgePropertyTuple@@0U1@@Z(first, last, compare);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@0U12@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/

void __fastcall ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **const *r_iBegin, dropBagPlayerInfo_t **iEnd, unsigned __int64 depthLimit, PlayerPotentialPartnersPredicate predicate)
{
  ??$introsort_loop@PEAPEAUdropBagPlayerInfo_t@@VPlayerPotentialPartnersPredicate@@@internal@ntl@@YAXAEBQEAPEAUdropBagPlayerInfo_t@@PEAPEAU2@_KVPlayerPotentialPartnersPredicate@@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/
void ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *const *r_iBegin, EdgePropertyTuple *iEnd, unsigned __int64 depthLimit, EdgePropertyTuple *predicate)
{
  EdgePropertyTuple *v4; 
  EdgePropertyTuple *v7; 
  float viewDot; 
  float v10; 
  EdgePropertyTuple *v11; 
  float v12; 
  bool v13; 
  float v14; 
  EdgePropertyTuple *v15; 
  __m256i v16; 
  __m256i v17; 
  __m256i v18; 
  double v19; 
  __m256i v20; 
  __m256i v21; 
  double v22; 
  EdgePropertyTuple *v23; 
  signed __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 i; 
  EdgePropertyTuple *v28; 
  __int64 v29; 
  __int64 v30; 
  double v31; 
  __m256i v32; 
  __m256i v33; 
  __m256i v34; 
  EdgePropertyTuple *v35; 
  __int64 v36; 
  __int64 v37; 
  __int64 v38; 
  __int64 v39; 
  float v40; 
  EdgePropertyTuple *v41; 
  __int64 v42; 
  __int64 v43; 
  EdgePropertyTuple *v44; 
  __int64 v45; 
  EdgePropertyTuple *j; 
  EdgePropertyTuple *v47; 
  EdgePropertyTuple *v48; 
  __m256i v49; 
  __m256i v50; 
  __m256i v51; 
  double v52; 
  EdgePropertyTuple *v53; 
  __int64 v54; 
  __int64 v55; 
  EdgePropertyTuple *v56; 
  signed __int64 v57; 
  bool v58; 
  EdgePropertyTuple *v59; 
  __int64 v60; 
  __int64 v61; 
  __int64 v62; 
  __int64 v63; 
  float v64; 
  EdgePropertyTuple *v65; 
  __int64 v66; 
  __int64 v67; 
  EdgePropertyTuple *v68; 
  __int64 v69; 
  __m256i v70; 
  EdgePropertyTuple v71; 
  __int64 v72; 
  EdgePropertyTuple *v73; 

  v4 = *r_iBegin;
  v7 = iEnd;
  if ( (char *)iEnd - (char *)*r_iBegin < 1768 )
    return;
  while ( depthLimit )
  {
    viewDot = v4->viewDot;
    v10 = v7[-1].viewDot;
    --depthLimit;
    v11 = &v4[((char *)v7 - (char *)v4) / 208];
    v12 = v11->viewDot;
    if ( viewDot <= v12 )
    {
      if ( viewDot <= v10 )
      {
        v13 = v12 <= v10;
LABEL_9:
        if ( !v13 )
          v11 = v7 - 1;
        goto LABEL_11;
      }
      v11 = v4;
    }
    else if ( v12 <= v10 )
    {
      v11 = v4;
      v13 = viewDot <= v10;
      goto LABEL_9;
    }
LABEL_11:
    v72 = *(_QWORD *)&v11->viewDot;
    v14 = *(float *)&v72;
    v15 = v7;
    while ( 1 )
    {
      for ( ; v14 < v4->viewDot; ++v4 )
        ;
      for ( --v15; v14 > v15->viewDot; --v15 )
        ;
      if ( v4 >= v15 )
        break;
      v16 = *(__m256i *)v4->edge.normal.v;
      v17 = *(__m256i *)&v4->edge.below.z;
      v18 = *(__m256i *)&v4->edge.normalFaceIndex;
      v19 = *(double *)&v4->viewDot;
      *(__m256i *)v4->edge.normal.v = *(__m256i *)v15->edge.normal.v;
      *(__m256i *)&v4->edge.below.z = *(__m256i *)&v15->edge.below.z;
      *(__m256i *)&v4->edge.normalFaceIndex = *(__m256i *)&v15->edge.normalFaceIndex;
      *(double *)&v4->viewDot = *(double *)&v15->viewDot;
      *(__m256i *)v15->edge.normal.v = v16;
      *(__m256i *)&v15->edge.below.z = v17;
      *(__m256i *)&v15->edge.normalFaceIndex = v18;
      *(double *)&v15->viewDot = v19;
      ++v4;
    }
    v20 = *(__m256i *)&predicate->edge.below.z;
    *(__m256i *)v71.edge.normal.v = *(__m256i *)predicate->edge.normal.v;
    v21 = *(__m256i *)&predicate->edge.normalFaceIndex;
    *(__m256i *)&v71.edge.below.z = v20;
    v22 = *(double *)&predicate->viewDot;
    v73 = v4;
    *(__m256i *)&v71.edge.normalFaceIndex = v21;
    *(double *)&v71.viewDot = v22;
    ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(&v73, v7, depthLimit, &v71);
    v7 = v73;
    v4 = *r_iBegin;
    if ( (char *)v73 - (char *)*r_iBegin < 1768 )
      return;
  }
  if ( v4 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v23 = *r_iBegin;
  v24 = v7 - *r_iBegin;
  if ( v24 >= 2 )
  {
    v25 = (v24 - 2) / 2;
    v26 = v25;
    for ( i = 2 * v25 + 2; ; i -= 2i64 )
    {
      v28 = *r_iBegin;
      v29 = v25;
      v30 = i;
      v31 = *(double *)&(*r_iBegin)[v26].viewDot;
      v32 = *(__m256i *)(*r_iBegin)[v26].edge.normal.v;
      v33 = *(__m256i *)&(*r_iBegin)[v26].edge.below.z;
      v34 = *(__m256i *)&(*r_iBegin)[v26].edge.normalFaceIndex;
      *(double *)&v71.viewDot = v31;
      if ( i < v24 )
      {
        do
        {
          v35 = *r_iBegin;
          v36 = v30 - 1;
          if ( (*r_iBegin)[v30].viewDot <= (*r_iBegin)[v30 - 1].viewDot )
            v36 = v30;
          v37 = v29;
          v30 = 2 * v36 + 2;
          *(__m256i *)v35[v37].edge.normal.v = *(__m256i *)v35[v36].edge.normal.v;
          *(__m256i *)&v35[v37].edge.below.z = *(__m256i *)&v35[v36].edge.below.z;
          *(__m256i *)&v35[v37].edge.normalFaceIndex = *(__m256i *)&v35[v36].edge.normalFaceIndex;
          *(double *)&v35[v37].viewDot = *(double *)&v35[v36].viewDot;
          v29 = v36;
        }
        while ( v30 < v24 );
        v28 = *r_iBegin;
      }
      if ( v30 == v24 )
      {
        v38 = v29;
        *(__m256i *)v28[v38].edge.normal.v = *(__m256i *)v28[v30 - 1].edge.normal.v;
        *(__m256i *)&v28[v38].edge.below.z = *(__m256i *)&v28[v30 - 1].edge.below.z;
        *(__m256i *)&v28[v38].edge.normalFaceIndex = *(__m256i *)&v28[v30 - 1].edge.normalFaceIndex;
        *(double *)&v28[v38].viewDot = *(double *)&v28[v30 - 1].viewDot;
        v29 = v30 - 1;
      }
      v39 = (v29 - 1) / 2;
      if ( v29 > v25 )
      {
        v40 = v71.viewDot;
        do
        {
          v41 = *r_iBegin;
          v42 = v39;
          if ( v40 >= (*r_iBegin)[v39].viewDot )
            break;
          v43 = v29;
          *(__m256i *)v41[v43].edge.normal.v = *(__m256i *)v41[v42].edge.normal.v;
          *(__m256i *)&v41[v43].edge.below.z = *(__m256i *)&v41[v42].edge.below.z;
          *(__m256i *)&v41[v43].edge.normalFaceIndex = *(__m256i *)&v41[v42].edge.normalFaceIndex;
          *(double *)&v41[v43].viewDot = *(double *)&v41[v42].viewDot;
          v29 = v39;
          v39 = (v39 - 1) / 2;
        }
        while ( v29 > v25 );
      }
      v44 = *r_iBegin;
      v45 = v29;
      *(__m256i *)v44[v45].edge.normal.v = v32;
      *(__m256i *)&v44[v45].edge.below.z = v33;
      *(__m256i *)&v44[v45].edge.normalFaceIndex = v34;
      *(double *)&v44[v45].viewDot = v31;
      if ( !v25 )
        break;
      --v25;
      --v26;
    }
    v23 = *r_iBegin;
  }
  for ( j = v23 + 1; v7 > j; *(double *)&v68[v69].viewDot = v52 )
  {
    v47 = v7--;
    v48 = v47 - 1;
    v49 = *(__m256i *)v48->edge.normal.v;
    v50 = *(__m256i *)&v48->edge.below.z;
    v51 = *(__m256i *)&v48->edge.normalFaceIndex;
    v52 = *(double *)&v48->viewDot;
    v70 = *(__m256i *)v48->edge.normal.v;
    *(double *)&v71.viewDot = v52;
    if ( v48 < *r_iBegin )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
        __debugbreak();
      v49 = v70;
    }
    v53 = *r_iBegin;
    v54 = 0i64;
    v55 = 2i64;
    *(__m256i *)v48->edge.normal.v = *(__m256i *)(*r_iBegin)->edge.normal.v;
    *(__m256i *)&v48->edge.below.z = *(__m256i *)&v53->edge.below.z;
    *(__m256i *)&v48->edge.normalFaceIndex = *(__m256i *)&v53->edge.normalFaceIndex;
    *(double *)&v48->viewDot = *(double *)&v53->viewDot;
    v56 = *r_iBegin;
    v57 = v48 - *r_iBegin;
    v58 = v57 == 2;
    if ( v57 > 2 )
    {
      do
      {
        v59 = *r_iBegin;
        v60 = v55 - 1;
        if ( (*r_iBegin)[v55].viewDot <= (*r_iBegin)[v55 - 1].viewDot )
          v60 = v55;
        v61 = v54;
        v55 = 2 * v60 + 2;
        *(__m256i *)v59[v61].edge.normal.v = *(__m256i *)v59[v60].edge.normal.v;
        *(__m256i *)&v59[v61].edge.below.z = *(__m256i *)&v59[v60].edge.below.z;
        *(__m256i *)&v59[v61].edge.normalFaceIndex = *(__m256i *)&v59[v60].edge.normalFaceIndex;
        *(double *)&v59[v61].viewDot = *(double *)&v59[v60].viewDot;
        v54 = v60;
        v58 = v55 == v57;
      }
      while ( v55 < v57 );
      v56 = *r_iBegin;
    }
    if ( v58 )
    {
      v62 = v54;
      *(__m256i *)v56[v62].edge.normal.v = *(__m256i *)v56[v55 - 1].edge.normal.v;
      *(__m256i *)&v56[v62].edge.below.z = *(__m256i *)&v56[v55 - 1].edge.below.z;
      *(__m256i *)&v56[v62].edge.normalFaceIndex = *(__m256i *)&v56[v55 - 1].edge.normalFaceIndex;
      *(double *)&v56[v62].viewDot = *(double *)&v56[v55 - 1].viewDot;
      v54 = v55 - 1;
    }
    v63 = (v54 - 1) / 2;
    if ( v54 > 0 )
    {
      v64 = v71.viewDot;
      do
      {
        v65 = *r_iBegin;
        v66 = v63;
        if ( v64 >= (*r_iBegin)[v63].viewDot )
          break;
        v67 = v54;
        *(__m256i *)v65[v67].edge.normal.v = *(__m256i *)v65[v66].edge.normal.v;
        *(__m256i *)&v65[v67].edge.below.z = *(__m256i *)&v65[v66].edge.below.z;
        *(__m256i *)&v65[v67].edge.normalFaceIndex = *(__m256i *)&v65[v66].edge.normalFaceIndex;
        *(double *)&v65[v67].viewDot = *(double *)&v65[v66].viewDot;
        v54 = v63;
        v63 = (v63 - 1) / 2;
      }
      while ( v54 > 0 );
    }
    v68 = *r_iBegin;
    v69 = v54;
    *(__m256i *)v68[v69].edge.normal.v = v49;
    *(__m256i *)&v68[v69].edge.below.z = v50;
    *(__m256i *)&v68[v69].edge.normalFaceIndex = v51;
  }
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/
void ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *predicate)
{
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v4; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v7; 
  float dist; 
  float v10; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v11; 
  float v12; 
  bool v13; 
  float v14; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v15; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v16; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v17; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 i; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v24; 
  __int64 v25; 
  __int64 v26; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v27; 
  __int64 v28; 
  __int64 v29; 
  float v30; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *j; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v32; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v33; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v34; 
  __int64 v35; 
  __int64 v36; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v37; 
  __int64 v38; 
  bool v39; 
  __int64 v40; 
  __int64 v41; 
  float v42; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v43; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v44; 

  v4 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
    return;
  while ( depthLimit )
  {
    dist = v4->dist;
    v10 = v7[-1].dist;
    --depthLimit;
    v11 = &v4[(v7 - v4) / 2];
    v12 = v11->dist;
    if ( dist >= v12 )
    {
      if ( dist >= v10 )
      {
        v13 = v10 <= v12;
LABEL_9:
        if ( !v13 )
          v11 = v7 - 1;
        goto LABEL_11;
      }
      v11 = v4;
    }
    else if ( v12 >= v10 )
    {
      v11 = v4;
      v13 = v10 <= dist;
      goto LABEL_9;
    }
LABEL_11:
    v43 = *v11;
    v14 = v43.dist;
    v15 = v7;
    while ( 1 )
    {
      for ( ; v14 > v4->dist; ++v4 )
        ;
      for ( --v15; v14 < v15->dist; --v15 )
        ;
      if ( v4 >= v15 )
        break;
      v16 = *v4;
      *v4 = *v15;
      *v15 = v16;
      ++v4;
    }
    v17 = *predicate;
    v44 = v4;
    v43 = v17;
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(&v44, v7, depthLimit, &v43);
    v7 = v44;
    v4 = *r_iBegin;
    if ( (__int64)(((char *)v44 - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
      return;
  }
  if ( v4 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v18 = *r_iBegin;
  v19 = v7 - *r_iBegin;
  if ( v19 >= 2 )
  {
    v20 = (v19 - 2) / 2;
    v21 = v20;
    v22 = v20;
    for ( i = 2 * v20 + 2; ; i -= 2i64 )
    {
      v24 = *r_iBegin;
      v25 = v21;
      v26 = i;
      v27 = (*r_iBegin)[v22];
      v43 = v27;
      if ( i < v19 )
      {
        do
        {
          v28 = v26 - 1;
          if ( (*r_iBegin)[v26 - 1].dist <= (*r_iBegin)[v26].dist )
            v28 = v26;
          v26 = 2 * v28 + 2;
          (*r_iBegin)[v25] = (*r_iBegin)[v28];
          v25 = v28;
        }
        while ( v26 < v19 );
        v24 = *r_iBegin;
      }
      if ( v26 == v19 )
      {
        v24[v25] = v24[v26 - 1];
        v25 = v26 - 1;
      }
      v29 = (v25 - 1) / 2;
      if ( v25 > v21 )
      {
        v30 = v43.dist;
        do
        {
          if ( v30 <= (*r_iBegin)[v29].dist )
            break;
          (*r_iBegin)[v25] = (*r_iBegin)[v29];
          v25 = v29;
          v29 = (v29 - 1) / 2;
        }
        while ( v25 > v21 );
      }
      (*r_iBegin)[v25] = v27;
      if ( !v21 )
        break;
      --v21;
      --v22;
    }
    v18 = *r_iBegin;
  }
  for ( j = v18 + 1; v7 > j; (*r_iBegin)[v35] = v34 )
  {
    v32 = v7--;
    v33 = v32 - 1;
    v34 = *v33;
    v43 = *v33;
    if ( v33 < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin", *(_QWORD *)&v43.edgeId) )
      __debugbreak();
    v35 = 0i64;
    v36 = 2i64;
    *v33 = *(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *)*r_iBegin;
    v37 = *r_iBegin;
    v38 = v33 - *r_iBegin;
    v39 = v38 == 2;
    if ( v38 > 2 )
    {
      do
      {
        v40 = v36 - 1;
        if ( (*r_iBegin)[v36 - 1].dist <= (*r_iBegin)[v36].dist )
          v40 = v36;
        v36 = 2 * v40 + 2;
        (*r_iBegin)[v35] = (*r_iBegin)[v40];
        v35 = v40;
        v39 = v36 == v38;
      }
      while ( v36 < v38 );
      v37 = *r_iBegin;
    }
    if ( v39 )
    {
      v37[v35] = v37[v36 - 1];
      v35 = v36 - 1;
    }
    v41 = (v35 - 1) / 2;
    if ( v35 > 0 )
    {
      v42 = v43.dist;
      do
      {
        if ( v42 <= (*r_iBegin)[v41].dist )
          break;
        (*r_iBegin)[v35] = (*r_iBegin)[v41];
        v35 = v41;
        v41 = (v41 - 1) / 2;
      }
      while ( v35 > 0 );
    }
  }
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/
void ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *predicate)
{
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v4; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v7; 
  float dist; 
  float v10; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v11; 
  float v12; 
  bool v13; 
  float v14; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v15; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v16; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v17; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 i; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v24; 
  __int64 v25; 
  __int64 v26; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v27; 
  __int64 v28; 
  __int64 v29; 
  float v30; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *j; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v32; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v33; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v34; 
  __int64 v35; 
  __int64 v36; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v37; 
  __int64 v38; 
  bool v39; 
  __int64 v40; 
  __int64 v41; 
  float v42; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v43; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v44; 

  v4 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
    return;
  while ( depthLimit )
  {
    dist = v4->dist;
    v10 = v7[-1].dist;
    --depthLimit;
    v11 = &v4[(v7 - v4) / 2];
    v12 = v11->dist;
    if ( dist >= v12 )
    {
      if ( dist >= v10 )
      {
        v13 = v10 <= v12;
LABEL_9:
        if ( !v13 )
          v11 = v7 - 1;
        goto LABEL_11;
      }
      v11 = v4;
    }
    else if ( v12 >= v10 )
    {
      v11 = v4;
      v13 = v10 <= dist;
      goto LABEL_9;
    }
LABEL_11:
    v43 = *v11;
    v14 = v43.dist;
    v15 = v7;
    while ( 1 )
    {
      for ( ; v14 > v4->dist; ++v4 )
        ;
      for ( --v15; v14 < v15->dist; --v15 )
        ;
      if ( v4 >= v15 )
        break;
      v16 = *v4;
      *v4 = *v15;
      *v15 = v16;
      ++v4;
    }
    v17 = *predicate;
    v44 = v4;
    v43 = v17;
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(&v44, v7, depthLimit, &v43);
    v7 = v44;
    v4 = *r_iBegin;
    if ( (__int64)(((char *)v44 - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
      return;
  }
  if ( v4 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v18 = *r_iBegin;
  v19 = v7 - *r_iBegin;
  if ( v19 >= 2 )
  {
    v20 = (v19 - 2) / 2;
    v21 = v20;
    v22 = v20;
    for ( i = 2 * v20 + 2; ; i -= 2i64 )
    {
      v24 = *r_iBegin;
      v25 = v21;
      v26 = i;
      v27 = (*r_iBegin)[v22];
      v43 = v27;
      if ( i < v19 )
      {
        do
        {
          v28 = v26 - 1;
          if ( (*r_iBegin)[v26 - 1].dist <= (*r_iBegin)[v26].dist )
            v28 = v26;
          v26 = 2 * v28 + 2;
          (*r_iBegin)[v25] = (*r_iBegin)[v28];
          v25 = v28;
        }
        while ( v26 < v19 );
        v24 = *r_iBegin;
      }
      if ( v26 == v19 )
      {
        v24[v25] = v24[v26 - 1];
        v25 = v26 - 1;
      }
      v29 = (v25 - 1) / 2;
      if ( v25 > v21 )
      {
        v30 = v43.dist;
        do
        {
          if ( v30 <= (*r_iBegin)[v29].dist )
            break;
          (*r_iBegin)[v25] = (*r_iBegin)[v29];
          v25 = v29;
          v29 = (v29 - 1) / 2;
        }
        while ( v25 > v21 );
      }
      (*r_iBegin)[v25] = v27;
      if ( !v21 )
        break;
      --v21;
      --v22;
    }
    v18 = *r_iBegin;
  }
  for ( j = v18 + 1; v7 > j; (*r_iBegin)[v35] = v34 )
  {
    v32 = v7--;
    v33 = v32 - 1;
    v34 = *v33;
    v43 = *v33;
    if ( v33 < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin", *(_QWORD *)&v43.edgeId) )
      __debugbreak();
    v35 = 0i64;
    v36 = 2i64;
    *v33 = *(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *)*r_iBegin;
    v37 = *r_iBegin;
    v38 = v33 - *r_iBegin;
    v39 = v38 == 2;
    if ( v38 > 2 )
    {
      do
      {
        v40 = v36 - 1;
        if ( (*r_iBegin)[v36 - 1].dist <= (*r_iBegin)[v36].dist )
          v40 = v36;
        v36 = 2 * v40 + 2;
        (*r_iBegin)[v35] = (*r_iBegin)[v40];
        v35 = v40;
        v39 = v36 == v38;
      }
      while ( v36 < v38 );
      v37 = *r_iBegin;
    }
    if ( v39 )
    {
      v37[v35] = v37[v36 - 1];
      v35 = v36 - 1;
    }
    v41 = (v35 - 1) / 2;
    if ( v35 > 0 )
    {
      v42 = v43.dist;
      do
      {
        if ( v42 <= (*r_iBegin)[v41].dist )
          break;
        (*r_iBegin)[v35] = (*r_iBegin)[v41];
        v35 = v41;
        v41 = (v41 - 1) / 2;
      }
      while ( v35 > 0 );
    }
  }
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/
void ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare)
{
  __m256i v3; 
  __m256i v4; 
  double v5; 
  EdgePropertyTuple v6; 
  ntl::random_access_iterator_tag v7; 

  v3 = *(__m256i *)&compare->edge.below.z;
  *(__m256i *)v6.edge.normal.v = *(__m256i *)compare->edge.normal.v;
  v4 = *(__m256i *)&compare->edge.normalFaceIndex;
  *(__m256i *)&v6.edge.below.z = v3;
  v5 = *(double *)&compare->viewDot;
  *(__m256i *)&v6.edge.normalFaceIndex = v4;
  *(double *)&v6.viewDot = v5;
  ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(first, last, &v6, v7);
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/
void ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v5; 
  unsigned __int64 v8; 
  unsigned __int64 v9; 
  unsigned __int64 v10; 
  __m256i v11; 
  __m256i v12; 
  double v13; 
  EdgePropertyTuple *v14; 
  EdgePropertyTuple *k; 
  double v16; 
  __m256i v17; 
  __m256i v18; 
  __m256i v19; 
  EdgePropertyTuple *m; 
  __m256i v21; 
  EdgePropertyTuple *v22; 
  EdgePropertyTuple *v23; 
  double v24; 
  __m256i v25; 
  __m256i v26; 
  __m256i v27; 
  EdgePropertyTuple *v28; 
  EdgePropertyTuple *v29; 
  EdgePropertyTuple *i; 
  double v31; 
  __m256i v32; 
  __m256i v33; 
  __m256i v34; 
  EdgePropertyTuple *j; 
  __m256i v36; 
  EdgePropertyTuple *v37; 
  EdgePropertyTuple *v38; 
  EdgePropertyTuple v39; 
  EdgePropertyTuple *v40; 

  if ( first != last )
  {
    v40 = first;
    v5 = (char *)last - (char *)first;
    v8 = (__int64)((unsigned __int128)(((char *)last - (char *)first) * (__int128)0x4EC4EC4EC4EC4EC5i64) >> 64) >> 5;
    v9 = (v8 >> 63) + v8;
    if ( v9 )
      v10 = 63 - __lzcnt(v9);
    else
      v10 = 0i64;
    v11 = *(__m256i *)&compare->edge.below.z;
    *(__m256i *)v39.edge.normal.v = *(__m256i *)compare->edge.normal.v;
    v12 = *(__m256i *)&compare->edge.normalFaceIndex;
    *(__m256i *)&v39.edge.below.z = v11;
    v13 = *(double *)&compare->viewDot;
    *(__m256i *)&v39.edge.normalFaceIndex = v12;
    *(double *)&v39.viewDot = v13;
    ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(&v40, last, 2 * v10, &v39);
    if ( v5 < 1768 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v31 = *(double *)&i->viewDot;
        v32 = *(__m256i *)i->edge.normal.v;
        v33 = *(__m256i *)&i->edge.below.z;
        v34 = *(__m256i *)&i->edge.normalFaceIndex;
        if ( *(float *)&v31 <= first->viewDot )
        {
          v37 = i;
          v38 = i - 1;
          if ( *(float *)&v31 > i[-1].viewDot )
          {
            do
            {
              *(__m256i *)v37->edge.normal.v = *(__m256i *)v38->edge.normal.v;
              *(__m256i *)&v37->edge.below.z = *(__m256i *)&v38->edge.below.z;
              *(__m256i *)&v37->edge.normalFaceIndex = *(__m256i *)&v38->edge.normalFaceIndex;
              *(double *)&v37->viewDot = *(double *)&v38->viewDot;
              v37 = v38--;
            }
            while ( *(float *)&v31 > v38->viewDot );
          }
          *(__m256i *)v37->edge.normal.v = v32;
          *(__m256i *)&v37->edge.below.z = v33;
          *(__m256i *)&v37->edge.normalFaceIndex = v34;
          *(double *)&v37->viewDot = v31;
        }
        else
        {
          for ( j = i; j != first; *(double *)&j[1].viewDot = *(double *)&j->viewDot )
          {
            v36 = *(__m256i *)j[-1].edge.normal.v;
            --j;
            *(__m256i *)j[1].edge.normal.v = v36;
            *(__m256i *)&j[1].edge.below.z = *(__m256i *)&j->edge.below.z;
            *(__m256i *)&j[1].edge.normalFaceIndex = *(__m256i *)&j->edge.normalFaceIndex;
          }
          *(__m256i *)first->edge.normal.v = v32;
          *(__m256i *)&first->edge.below.z = v33;
          *(__m256i *)&first->edge.normalFaceIndex = v34;
          *(double *)&first->viewDot = v31;
        }
      }
    }
    else
    {
      v14 = first + 16;
      if ( first != &first[16] )
      {
        for ( k = first + 1; k != v14; ++k )
        {
          v16 = *(double *)&k->viewDot;
          v17 = *(__m256i *)k->edge.normal.v;
          v18 = *(__m256i *)&k->edge.below.z;
          v19 = *(__m256i *)&k->edge.normalFaceIndex;
          if ( *(float *)&v16 <= first->viewDot )
          {
            v22 = k;
            v23 = k - 1;
            if ( *(float *)&v16 > k[-1].viewDot )
            {
              do
              {
                *(__m256i *)v22->edge.normal.v = *(__m256i *)v23->edge.normal.v;
                *(__m256i *)&v22->edge.below.z = *(__m256i *)&v23->edge.below.z;
                *(__m256i *)&v22->edge.normalFaceIndex = *(__m256i *)&v23->edge.normalFaceIndex;
                *(double *)&v22->viewDot = *(double *)&v23->viewDot;
                v22 = v23--;
              }
              while ( *(float *)&v16 > v23->viewDot );
            }
            *(__m256i *)v22->edge.normal.v = v17;
            *(__m256i *)&v22->edge.below.z = v18;
            *(__m256i *)&v22->edge.normalFaceIndex = v19;
            *(double *)&v22->viewDot = v16;
          }
          else
          {
            for ( m = k; m != first; *(double *)&m[1].viewDot = *(double *)&m->viewDot )
            {
              v21 = *(__m256i *)m[-1].edge.normal.v;
              --m;
              *(__m256i *)m[1].edge.normal.v = v21;
              *(__m256i *)&m[1].edge.below.z = *(__m256i *)&m->edge.below.z;
              *(__m256i *)&m[1].edge.normalFaceIndex = *(__m256i *)&m->edge.normalFaceIndex;
            }
            *(__m256i *)first->edge.normal.v = v17;
            *(__m256i *)&first->edge.below.z = v18;
            *(__m256i *)&first->edge.normalFaceIndex = v19;
            *(double *)&first->viewDot = v16;
          }
        }
      }
      for ( ; v14 != last; *(double *)&v28->viewDot = v24 )
      {
        v24 = *(double *)&v14->viewDot;
        v25 = *(__m256i *)v14->edge.normal.v;
        v26 = *(__m256i *)&v14->edge.below.z;
        v27 = *(__m256i *)&v14->edge.normalFaceIndex;
        v28 = v14;
        v29 = v14 - 1;
        if ( *(float *)&v24 > v14[-1].viewDot )
        {
          do
          {
            *(__m256i *)v28->edge.normal.v = *(__m256i *)v29->edge.normal.v;
            *(__m256i *)&v28->edge.below.z = *(__m256i *)&v29->edge.below.z;
            *(__m256i *)&v28->edge.normalFaceIndex = *(__m256i *)&v29->edge.normalFaceIndex;
            *(double *)&v28->viewDot = *(double *)&v29->viewDot;
            v28 = v29--;
          }
          while ( *(float *)&v24 > v29->viewDot );
        }
        *(__m256i *)v28->edge.normal.v = v25;
        *(__m256i *)&v28->edge.below.z = v26;
        ++v14;
        *(__m256i *)&v28->edge.normalFaceIndex = v27;
      }
    }
  }
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare)
{
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v3; 
  ntl::random_access_iterator_tag v4; 

  v3 = *compare;
  ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(first, last, &v3, v4);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v9; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *k; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v11; 
  float v12; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *m; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v14; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v15; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v16; 
  __m128 v17; 
  float v18; 
  _OWORD *v19; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v20; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *i; 
  __m128 v22; 
  float v23; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *j; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v25; 
  _OWORD *p_edgeId; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v27; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v28; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v29; 

  if ( first != last )
  {
    v29 = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    v28 = *compare;
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(&v29, last, 2 * v8, &v28);
    if ( v7 <= 16 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v22 = *(__m128 *)i;
        v23 = _mm_shuffle_ps(v22, v22, 170).m128_f32[0];
        if ( v23 >= first->dist )
        {
          p_edgeId = &i->edgeId;
          v27 = i - 1;
          if ( v23 < i[-1].dist )
          {
            do
            {
              *p_edgeId = *v27;
              p_edgeId = &v27->edgeId;
              --v27;
            }
            while ( v23 < v27->dist );
          }
          *p_edgeId = v22;
        }
        else
        {
          for ( j = i; j != first; j[1] = v25 )
          {
            v25 = j[-1];
            --j;
          }
          *first = (EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge)v22;
        }
      }
    }
    else
    {
      v9 = first + 16;
      if ( first != &first[16] )
      {
        for ( k = first + 1; k != v9; ++k )
        {
          v11 = *k;
          v12 = _mm_shuffle_ps((__m128)v11, (__m128)v11, 170).m128_f32[0];
          if ( v12 >= first->dist )
          {
            v15 = k;
            v16 = k - 1;
            if ( v12 < k[-1].dist )
            {
              do
              {
                *v15 = *v16;
                v15 = v16--;
              }
              while ( v12 < v16->dist );
            }
            *v15 = v11;
          }
          else
          {
            for ( m = k; m != first; m[1] = v14 )
            {
              v14 = m[-1];
              --m;
            }
            *first = v11;
          }
        }
      }
      for ( ; v9 != last; *v19 = v17 )
      {
        v17 = *(__m128 *)v9;
        v18 = _mm_shuffle_ps(v17, v17, 170).m128_f32[0];
        v19 = &v9->edgeId;
        v20 = v9 - 1;
        if ( v18 < v9[-1].dist )
        {
          do
          {
            *v19 = *v20;
            v19 = &v20->edgeId;
            --v20;
          }
          while ( v18 < v20->dist );
        }
        ++v9;
      }
    }
  }
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare)
{
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v3; 
  ntl::random_access_iterator_tag v4; 

  v3 = *compare;
  ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(first, last, &v3, v4);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v9; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *k; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v11; 
  float v12; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *m; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v14; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v15; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v16; 
  __m128 v17; 
  float v18; 
  _OWORD *v19; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v20; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *i; 
  __m128 v22; 
  float v23; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *j; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v25; 
  _OWORD *p_edgeId; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v27; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v28; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v29; 

  if ( first != last )
  {
    v29 = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    v28 = *compare;
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(&v29, last, 2 * v8, &v28);
    if ( v7 <= 16 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v22 = *(__m128 *)i;
        v23 = _mm_shuffle_ps(v22, v22, 170).m128_f32[0];
        if ( v23 >= first->dist )
        {
          p_edgeId = &i->edgeId;
          v27 = i - 1;
          if ( v23 < i[-1].dist )
          {
            do
            {
              *p_edgeId = *v27;
              p_edgeId = &v27->edgeId;
              --v27;
            }
            while ( v23 < v27->dist );
          }
          *p_edgeId = v22;
        }
        else
        {
          for ( j = i; j != first; j[1] = v25 )
          {
            v25 = j[-1];
            --j;
          }
          *first = (EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge)v22;
        }
      }
    }
    else
    {
      v9 = first + 16;
      if ( first != &first[16] )
      {
        for ( k = first + 1; k != v9; ++k )
        {
          v11 = *k;
          v12 = _mm_shuffle_ps((__m128)v11, (__m128)v11, 170).m128_f32[0];
          if ( v12 >= first->dist )
          {
            v15 = k;
            v16 = k - 1;
            if ( v12 < k[-1].dist )
            {
              do
              {
                *v15 = *v16;
                v15 = v16--;
              }
              while ( v12 < v16->dist );
            }
            *v15 = v11;
          }
          else
          {
            for ( m = k; m != first; m[1] = v14 )
            {
              v14 = m[-1];
              --m;
            }
            *first = v11;
          }
        }
      }
      for ( ; v9 != last; *v19 = v17 )
      {
        v17 = *(__m128 *)v9;
        v18 = _mm_shuffle_ps(v17, v17, 170).m128_f32[0];
        v19 = &v9->edgeId;
        v20 = v9 - 1;
        if ( v18 < v9[-1].dist )
        {
          do
          {
            *v19 = *v20;
            v19 = &v20->edgeId;
            --v20;
          }
          while ( v18 < v20->dist );
        }
        ++v9;
      }
    }
  }
}

/*
==============
ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/
void ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *const *r_iBegin, CachedLookup::Entry *iEnd, unsigned __int64 depthLimit, CachedLookup::SortFunc predicate)
{
  CachedLookup::Entry *v5; 
  CachedLookup::Entry *v7; 
  unsigned __int64 address; 
  unsigned __int64 v10; 
  CachedLookup::Entry *v11; 
  unsigned __int64 v12; 
  bool v13; 
  unsigned __int64 v14; 
  CachedLookup::Entry *v15; 
  CachedLookup::Entry v16; 
  CachedLookup::Entry *v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 i; 
  CachedLookup::Entry *v23; 
  __int64 v24; 
  __int64 v25; 
  CachedLookup::Entry v26; 
  __int64 v27; 
  __int64 j; 
  CachedLookup::Entry *k; 
  CachedLookup::Entry *v30; 
  CachedLookup::Entry *v31; 
  CachedLookup::Entry v32; 
  __int64 v33; 
  __int64 v34; 
  CachedLookup::Entry *v35; 
  __int64 v36; 
  bool v37; 
  __int64 v38; 
  __int64 m; 
  CachedLookup::Entry v40; 
  CachedLookup::Entry v41; 
  CachedLookup::Entry *r_iBegina; 

  v5 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
    return;
  while ( depthLimit )
  {
    address = v7[-1].address;
    --depthLimit;
    v10 = v5->address;
    v11 = &v5[(v7 - v5) / 2];
    v12 = v11->address;
    if ( v5->address >= v11->address )
    {
      if ( v10 >= address )
      {
        v13 = v12 < address;
LABEL_9:
        if ( v13 )
          v11 = v7 - 1;
        goto LABEL_11;
      }
      v11 = v5;
    }
    else if ( v12 >= address )
    {
      v11 = v5;
      v13 = v10 < address;
      goto LABEL_9;
    }
LABEL_11:
    v14 = v11->address;
    v15 = v7;
    while ( 1 )
    {
      if ( v10 < v14 )
      {
        do
          ++v5;
        while ( v5->address < v14 );
      }
      for ( --v15; v14 < v15->address; --v15 )
        ;
      if ( v5 >= v15 )
        break;
      v16 = *v5;
      *v5++ = *v15;
      *v15 = v16;
      v10 = v5->address;
    }
    r_iBegina = v5;
    ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(&r_iBegina, v7, depthLimit, predicate);
    v7 = r_iBegina;
    v5 = *r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
      return;
  }
  if ( v5 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v17 = *r_iBegin;
  v18 = v7 - *r_iBegin;
  if ( v18 >= 2 )
  {
    v19 = (v18 - 2) / 2;
    v20 = v19;
    v21 = v19;
    for ( i = 2 * v19 + 2; ; i -= 2i64 )
    {
      v23 = *r_iBegin;
      v24 = v20;
      v25 = i;
      v26 = (*r_iBegin)[v21];
      if ( i < v18 )
      {
        do
        {
          v27 = v25 - 1;
          if ( (*r_iBegin)[v25].address >= (*r_iBegin)[v25 - 1].address )
            v27 = v25;
          v25 = 2 * v27 + 2;
          (*r_iBegin)[v24] = (*r_iBegin)[v27];
          v24 = v27;
        }
        while ( v25 < v18 );
        v23 = *r_iBegin;
      }
      if ( v25 == v18 )
      {
        v23[v24] = v23[v25 - 1];
        v24 = v25 - 1;
      }
      for ( j = (v24 - 1) / 2; v24 > v20; j = (j - 1) / 2 )
      {
        if ( (*r_iBegin)[j].address >= v26.address )
          break;
        (*r_iBegin)[v24] = (*r_iBegin)[j];
        v24 = j;
      }
      (*r_iBegin)[v24] = v26;
      if ( !v20 )
        break;
      --v20;
      --v21;
    }
    v17 = *r_iBegin;
  }
  for ( k = v17 + 1; v7 > k; (*r_iBegin)[v33] = v32 )
  {
    v30 = v7--;
    v31 = v30 - 1;
    v32 = *v31;
    v40 = *v31;
    v41 = *v31;
    if ( v31 < *r_iBegin )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
        __debugbreak();
      v32 = v40;
    }
    v33 = 0i64;
    v34 = 2i64;
    *v31 = *(CachedLookup::Entry *)*r_iBegin;
    v35 = *r_iBegin;
    v36 = v31 - *r_iBegin;
    v37 = v36 == 2;
    if ( v36 > 2 )
    {
      do
      {
        v38 = v34 - 1;
        if ( (*r_iBegin)[v34].address >= (*r_iBegin)[v34 - 1].address )
          v38 = v34;
        v34 = 2 * v38 + 2;
        (*r_iBegin)[v33] = (*r_iBegin)[v38];
        v33 = v38;
        v37 = v34 == v36;
      }
      while ( v34 < v36 );
      v35 = *r_iBegin;
    }
    if ( v37 )
    {
      v35[v33] = v35[v34 - 1];
      v33 = v34 - 1;
    }
    for ( m = (v33 - 1) / 2; v33 > 0; m = (m - 1) / 2 )
    {
      if ( (*r_iBegin)[m].address >= v41.address )
        break;
      (*r_iBegin)[v33] = (*r_iBegin)[m];
      v33 = m;
    }
  }
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/
void ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(first, last, compare, v3);
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/
void ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  CachedLookup::Entry *v9; 
  CachedLookup::Entry *m; 
  CachedLookup::Entry v11; 
  CachedLookup::Entry *ii; 
  CachedLookup::Entry v13; 
  CachedLookup::Entry *v14; 
  CachedLookup::Entry *n; 
  CachedLookup::Entry v16; 
  unsigned __int64 address; 
  CachedLookup::Entry *v18; 
  CachedLookup::Entry *jj; 
  CachedLookup::Entry *i; 
  CachedLookup::Entry v21; 
  CachedLookup::Entry *k; 
  CachedLookup::Entry v23; 
  CachedLookup::Entry *v24; 
  CachedLookup::Entry *j; 
  CachedLookup::Entry *r_iBegin; 

  if ( first != last )
  {
    r_iBegin = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(&r_iBegin, last, 2 * v8, compare);
    if ( v7 <= 16 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v21 = *i;
        if ( i->address >= first->address )
        {
          v24 = i - 1;
          for ( j = i; v21.address < v24->address; --v24 )
          {
            *j = *v24;
            j = v24;
          }
          *j = v21;
        }
        else
        {
          for ( k = i; k != first; k[1] = v23 )
          {
            v23 = k[-1];
            --k;
          }
          *first = v21;
        }
      }
    }
    else
    {
      v9 = first + 16;
      if ( first != &first[16] )
      {
        for ( m = first + 1; m != v9; ++m )
        {
          v11 = *m;
          if ( m->address >= first->address )
          {
            v14 = m - 1;
            for ( n = m; v11.address < v14->address; --v14 )
            {
              *n = *v14;
              n = v14;
            }
            *n = v11;
          }
          else
          {
            for ( ii = m; ii != first; ii[1] = v13 )
            {
              v13 = ii[-1];
              --ii;
            }
            *first = v11;
          }
        }
      }
      for ( ; v9 != last; *jj = v16 )
      {
        v16 = *v9;
        address = v9->address;
        v18 = v9 - 1;
        for ( jj = v9; address < v18->address; --v18 )
        {
          *jj = *v18;
          jj = v18;
        }
        ++v9;
      }
    }
  }
}

/*
==============
ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/
void ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **const *r_iBegin, dropBagClusterInfo_t **iEnd, unsigned __int64 depthLimit, ClusterPotentialPlayersPredicate predicate)
{
  dropBagClusterInfo_t **v4; 
  dropBagClusterInfo_t **v7; 
  dropBagClusterInfo_t *v9; 
  unsigned __int64 m_size; 
  dropBagClusterInfo_t *v11; 
  unsigned __int64 v12; 
  unsigned __int64 v13; 
  bool v14; 
  dropBagClusterInfo_t **v15; 
  unsigned __int64 v16; 
  dropBagClusterInfo_t *v17; 
  __int64 v18; 
  __int64 v19; 
  dropBagClusterInfo_t *v20; 
  dropBagClusterInfo_t **v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 i; 
  dropBagClusterInfo_t **v25; 
  __int64 v26; 
  __int64 v27; 
  dropBagClusterInfo_t *v28; 
  __int64 v29; 
  __int64 j; 
  dropBagClusterInfo_t *v31; 
  dropBagClusterInfo_t **k; 
  dropBagClusterInfo_t **v33; 
  dropBagClusterInfo_t **v34; 
  dropBagClusterInfo_t *v35; 
  __int64 v36; 
  __int64 v37; 
  dropBagClusterInfo_t **v38; 
  __int64 v39; 
  bool v40; 
  __int64 v41; 
  __int64 m; 
  dropBagClusterInfo_t *v43; 
  dropBagClusterInfo_t **r_iBegina; 

  v4 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
    return;
  while ( depthLimit )
  {
    --depthLimit;
    v9 = *v4;
    m_size = (*v4)->potentialPlayers.m_size;
    v11 = v4[(v7 - v4) / 2];
    v12 = (*(v7 - 1))->potentialPlayers.m_size;
    v13 = v11->potentialPlayers.m_size;
    if ( m_size >= v13 )
    {
      if ( m_size >= v12 )
      {
        v14 = v13 < v12;
LABEL_9:
        if ( v14 )
          v11 = *(v7 - 1);
        goto LABEL_11;
      }
      v11 = *v4;
    }
    else if ( v13 >= v12 )
    {
      v11 = *v4;
      v14 = m_size < v12;
      goto LABEL_9;
    }
LABEL_11:
    v15 = v7;
    while ( 1 )
    {
      v16 = v11->potentialPlayers.m_size;
      if ( v9->potentialPlayers.m_size < v16 )
      {
        do
        {
          v17 = v4[1];
          ++v4;
        }
        while ( v17->potentialPlayers.m_size < v16 );
      }
      v18 = (__int64)*--v15;
      if ( v16 < *(_QWORD *)(v18 + 272) )
      {
        do
          v19 = (__int64)*--v15;
        while ( v16 < *(_QWORD *)(v19 + 272) );
      }
      if ( v4 >= v15 )
        break;
      v20 = *v4;
      *v4++ = *v15;
      *v15 = v20;
      v9 = *v4;
    }
    r_iBegina = v4;
    ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(&r_iBegina, v7, depthLimit, predicate);
    v7 = r_iBegina;
    v4 = *r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
      return;
  }
  if ( v4 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v21 = *r_iBegin;
  v22 = v7 - *r_iBegin;
  if ( v22 >= 2 )
  {
    v23 = (v22 - 2) / 2;
    for ( i = 2 * v23 + 2; ; i -= 2i64 )
    {
      v25 = *r_iBegin;
      v26 = v23;
      v27 = i;
      v28 = (*r_iBegin)[v23];
      if ( i < v22 )
      {
        do
        {
          v29 = v27 - 1;
          if ( (*r_iBegin)[v27]->potentialPlayers.m_size >= (*r_iBegin)[v27 - 1]->potentialPlayers.m_size )
            v29 = v27;
          v27 = 2 * v29 + 2;
          (*r_iBegin)[v26] = (*r_iBegin)[v29];
          v26 = v29;
        }
        while ( v27 < v22 );
        v25 = *r_iBegin;
      }
      if ( v27 == v22 )
      {
        v25[v26] = v25[v27 - 1];
        v26 = v27 - 1;
      }
      for ( j = (v26 - 1) / 2; v26 > v23; j = (j - 1) / 2 )
      {
        v31 = (*r_iBegin)[j];
        if ( v31->potentialPlayers.m_size >= v28->potentialPlayers.m_size )
          break;
        (*r_iBegin)[v26] = v31;
        v26 = j;
      }
      (*r_iBegin)[v26] = v28;
      if ( !v23 )
        break;
      --v23;
    }
    v21 = *r_iBegin;
  }
  for ( k = v21 + 1; v7 > k; (*r_iBegin)[v36] = v35 )
  {
    v33 = v7--;
    v34 = v33 - 1;
    v35 = *v34;
    if ( v34 < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
      __debugbreak();
    v36 = 0i64;
    v37 = 2i64;
    *v34 = **r_iBegin;
    v38 = *r_iBegin;
    v39 = v34 - *r_iBegin;
    v40 = v39 == 2;
    if ( v39 > 2 )
    {
      do
      {
        v41 = v37 - 1;
        if ( (*r_iBegin)[v37]->potentialPlayers.m_size >= (*r_iBegin)[v37 - 1]->potentialPlayers.m_size )
          v41 = v37;
        v37 = 2 * v41 + 2;
        (*r_iBegin)[v36] = (*r_iBegin)[v41];
        v36 = v41;
        v40 = v37 == v39;
      }
      while ( v37 < v39 );
      v38 = *r_iBegin;
    }
    if ( v40 )
    {
      v38[v36] = v38[v37 - 1];
      v36 = v37 - 1;
    }
    for ( m = (v36 - 1) / 2; v36 > 0; m = (m - 1) / 2 )
    {
      v43 = (*r_iBegin)[m];
      if ( v43->potentialPlayers.m_size >= v35->potentialPlayers.m_size )
        break;
      (*r_iBegin)[v36] = v43;
      v36 = m;
    }
  }
}

/*
==============
ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/
void ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **const *r_iBegin, dropBagPlayerInfo_t **iEnd, unsigned __int64 depthLimit, PlayerPotentialPartnersPredicate predicate)
{
  dropBagPlayerInfo_t **v4; 
  dropBagPlayerInfo_t **v7; 
  dropBagPlayerInfo_t *v9; 
  unsigned __int64 m_size; 
  dropBagPlayerInfo_t *v11; 
  unsigned __int64 v12; 
  unsigned __int64 v13; 
  bool v14; 
  dropBagPlayerInfo_t **v15; 
  unsigned __int64 v16; 
  dropBagPlayerInfo_t *v17; 
  __int64 v18; 
  __int64 v19; 
  dropBagPlayerInfo_t *v20; 
  dropBagPlayerInfo_t **v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 i; 
  dropBagPlayerInfo_t **v25; 
  __int64 v26; 
  __int64 v27; 
  dropBagPlayerInfo_t *v28; 
  __int64 v29; 
  __int64 j; 
  dropBagPlayerInfo_t *v31; 
  dropBagPlayerInfo_t **k; 
  dropBagPlayerInfo_t **v33; 
  dropBagPlayerInfo_t **v34; 
  dropBagPlayerInfo_t *v35; 
  __int64 v36; 
  __int64 v37; 
  dropBagPlayerInfo_t **v38; 
  __int64 v39; 
  bool v40; 
  __int64 v41; 
  __int64 m; 
  dropBagPlayerInfo_t *v43; 
  dropBagPlayerInfo_t **r_iBegina; 

  v4 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
    return;
  while ( depthLimit )
  {
    --depthLimit;
    v9 = *v4;
    m_size = (*v4)->potentialPartners.m_size;
    v11 = v4[(v7 - v4) / 2];
    v12 = (*(v7 - 1))->potentialPartners.m_size;
    v13 = v11->potentialPartners.m_size;
    if ( m_size >= v13 )
    {
      if ( m_size >= v12 )
      {
        v14 = v13 < v12;
LABEL_9:
        if ( v14 )
          v11 = *(v7 - 1);
        goto LABEL_11;
      }
      v11 = *v4;
    }
    else if ( v13 >= v12 )
    {
      v11 = *v4;
      v14 = m_size < v12;
      goto LABEL_9;
    }
LABEL_11:
    v15 = v7;
    while ( 1 )
    {
      v16 = v11->potentialPartners.m_size;
      if ( v9->potentialPartners.m_size < v16 )
      {
        do
        {
          v17 = v4[1];
          ++v4;
        }
        while ( v17->potentialPartners.m_size < v16 );
      }
      v18 = (__int64)*--v15;
      if ( v16 < *(_QWORD *)(v18 + 176) )
      {
        do
          v19 = (__int64)*--v15;
        while ( v16 < *(_QWORD *)(v19 + 176) );
      }
      if ( v4 >= v15 )
        break;
      v20 = *v4;
      *v4++ = *v15;
      *v15 = v20;
      v9 = *v4;
    }
    r_iBegina = v4;
    ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(&r_iBegina, v7, depthLimit, predicate);
    v7 = r_iBegina;
    v4 = *r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
      return;
  }
  if ( v4 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v21 = *r_iBegin;
  v22 = v7 - *r_iBegin;
  if ( v22 >= 2 )
  {
    v23 = (v22 - 2) / 2;
    for ( i = 2 * v23 + 2; ; i -= 2i64 )
    {
      v25 = *r_iBegin;
      v26 = v23;
      v27 = i;
      v28 = (*r_iBegin)[v23];
      if ( i < v22 )
      {
        do
        {
          v29 = v27 - 1;
          if ( (*r_iBegin)[v27]->potentialPartners.m_size >= (*r_iBegin)[v27 - 1]->potentialPartners.m_size )
            v29 = v27;
          v27 = 2 * v29 + 2;
          (*r_iBegin)[v26] = (*r_iBegin)[v29];
          v26 = v29;
        }
        while ( v27 < v22 );
        v25 = *r_iBegin;
      }
      if ( v27 == v22 )
      {
        v25[v26] = v25[v27 - 1];
        v26 = v27 - 1;
      }
      for ( j = (v26 - 1) / 2; v26 > v23; j = (j - 1) / 2 )
      {
        v31 = (*r_iBegin)[j];
        if ( v31->potentialPartners.m_size >= v28->potentialPartners.m_size )
          break;
        (*r_iBegin)[v26] = v31;
        v26 = j;
      }
      (*r_iBegin)[v26] = v28;
      if ( !v23 )
        break;
      --v23;
    }
    v21 = *r_iBegin;
  }
  for ( k = v21 + 1; v7 > k; (*r_iBegin)[v36] = v35 )
  {
    v33 = v7--;
    v34 = v33 - 1;
    v35 = *v34;
    if ( v34 < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
      __debugbreak();
    v36 = 0i64;
    v37 = 2i64;
    *v34 = **r_iBegin;
    v38 = *r_iBegin;
    v39 = v34 - *r_iBegin;
    v40 = v39 == 2;
    if ( v39 > 2 )
    {
      do
      {
        v41 = v37 - 1;
        if ( (*r_iBegin)[v37]->potentialPartners.m_size >= (*r_iBegin)[v37 - 1]->potentialPartners.m_size )
          v41 = v37;
        v37 = 2 * v41 + 2;
        (*r_iBegin)[v36] = (*r_iBegin)[v41];
        v36 = v41;
        v40 = v37 == v39;
      }
      while ( v37 < v39 );
      v38 = *r_iBegin;
    }
    if ( v40 )
    {
      v38[v36] = v38[v37 - 1];
      v36 = v37 - 1;
    }
    for ( m = (v36 - 1) / 2; v36 > 0; m = (m - 1) / 2 )
    {
      v43 = (*r_iBegin)[m];
      if ( v43->potentialPartners.m_size >= v35->potentialPartners.m_size )
        break;
      (*r_iBegin)[v36] = v43;
      v36 = m;
    }
  }
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/
void ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(first, last, compare, v3);
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/
void ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  dropBagClusterInfo_t **v9; 
  dropBagClusterInfo_t **k; 
  dropBagClusterInfo_t *v11; 
  unsigned __int64 v12; 
  dropBagClusterInfo_t **m; 
  dropBagClusterInfo_t *v14; 
  dropBagClusterInfo_t *v15; 
  dropBagClusterInfo_t **v16; 
  dropBagClusterInfo_t **v17; 
  dropBagClusterInfo_t *v18; 
  dropBagClusterInfo_t **v19; 
  dropBagClusterInfo_t *v20; 
  dropBagClusterInfo_t **n; 
  dropBagClusterInfo_t **i; 
  dropBagClusterInfo_t *v23; 
  unsigned __int64 m_size; 
  dropBagClusterInfo_t **j; 
  dropBagClusterInfo_t *v26; 
  dropBagClusterInfo_t *v27; 
  dropBagClusterInfo_t **v28; 
  dropBagClusterInfo_t **v29; 
  dropBagClusterInfo_t **r_iBegin; 

  if ( first != last )
  {
    r_iBegin = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(&r_iBegin, last, 2 * v8, compare);
    if ( v7 <= 16 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v23 = *i;
        m_size = (*i)->potentialPlayers.m_size;
        if ( m_size >= (*first)->potentialPlayers.m_size )
        {
          v27 = *(i - 1);
          v28 = i - 1;
          v29 = i;
          if ( m_size < v27->potentialPlayers.m_size )
          {
            do
            {
              *v29 = v27;
              v29 = v28;
              v27 = *--v28;
            }
            while ( v23->potentialPlayers.m_size < v27->potentialPlayers.m_size );
          }
          *v29 = v23;
        }
        else
        {
          for ( j = i; j != first; j[1] = v26 )
            v26 = *--j;
          *first = v23;
        }
      }
    }
    else
    {
      v9 = first + 16;
      if ( first != first + 16 )
      {
        for ( k = first + 1; k != v9; ++k )
        {
          v11 = *k;
          v12 = (*k)->potentialPlayers.m_size;
          if ( v12 >= (*first)->potentialPlayers.m_size )
          {
            v15 = *(k - 1);
            v16 = k - 1;
            v17 = k;
            if ( v12 < v15->potentialPlayers.m_size )
            {
              do
              {
                *v17 = v15;
                v17 = v16;
                v15 = *--v16;
              }
              while ( v11->potentialPlayers.m_size < v15->potentialPlayers.m_size );
            }
            *v17 = v11;
          }
          else
          {
            for ( m = k; m != first; m[1] = v14 )
              v14 = *--m;
            *first = v11;
          }
        }
      }
      for ( ; v9 != last; *n = v20 )
      {
        v18 = *(v9 - 1);
        v19 = v9 - 1;
        v20 = *v9;
        for ( n = v9; v20->potentialPlayers.m_size < v18->potentialPlayers.m_size; --v19 )
        {
          *n = v18;
          n = v19;
          v18 = *(v19 - 1);
        }
        ++v9;
      }
    }
  }
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/
void ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(first, last, compare, v3);
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/
void ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  dropBagPlayerInfo_t **v9; 
  dropBagPlayerInfo_t **k; 
  dropBagPlayerInfo_t *v11; 
  unsigned __int64 v12; 
  dropBagPlayerInfo_t **m; 
  dropBagPlayerInfo_t *v14; 
  dropBagPlayerInfo_t *v15; 
  dropBagPlayerInfo_t **v16; 
  dropBagPlayerInfo_t **v17; 
  dropBagPlayerInfo_t *v18; 
  dropBagPlayerInfo_t **v19; 
  dropBagPlayerInfo_t *v20; 
  dropBagPlayerInfo_t **n; 
  dropBagPlayerInfo_t **i; 
  dropBagPlayerInfo_t *v23; 
  unsigned __int64 m_size; 
  dropBagPlayerInfo_t **j; 
  dropBagPlayerInfo_t *v26; 
  dropBagPlayerInfo_t *v27; 
  dropBagPlayerInfo_t **v28; 
  dropBagPlayerInfo_t **v29; 
  dropBagPlayerInfo_t **r_iBegin; 

  if ( first != last )
  {
    r_iBegin = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(&r_iBegin, last, 2 * v8, compare);
    if ( v7 <= 16 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v23 = *i;
        m_size = (*i)->potentialPartners.m_size;
        if ( m_size >= (*first)->potentialPartners.m_size )
        {
          v27 = *(i - 1);
          v28 = i - 1;
          v29 = i;
          if ( m_size < v27->potentialPartners.m_size )
          {
            do
            {
              *v29 = v27;
              v29 = v28;
              v27 = *--v28;
            }
            while ( v23->potentialPartners.m_size < v27->potentialPartners.m_size );
          }
          *v29 = v23;
        }
        else
        {
          for ( j = i; j != first; j[1] = v26 )
            v26 = *--j;
          *first = v23;
        }
      }
    }
    else
    {
      v9 = first + 16;
      if ( first != first + 16 )
      {
        for ( k = first + 1; k != v9; ++k )
        {
          v11 = *k;
          v12 = (*k)->potentialPartners.m_size;
          if ( v12 >= (*first)->potentialPartners.m_size )
          {
            v15 = *(k - 1);
            v16 = k - 1;
            v17 = k;
            if ( v12 < v15->potentialPartners.m_size )
            {
              do
              {
                *v17 = v15;
                v17 = v16;
                v15 = *--v16;
              }
              while ( v11->potentialPartners.m_size < v15->potentialPartners.m_size );
            }
            *v17 = v11;
          }
          else
          {
            for ( m = k; m != first; m[1] = v14 )
              v14 = *--m;
            *first = v11;
          }
        }
      }
      for ( ; v9 != last; *n = v20 )
      {
        v18 = *(v9 - 1);
        v19 = v9 - 1;
        v20 = *v9;
        for ( n = v9; v20->potentialPartners.m_size < v18->potentialPartners.m_size; --v19 )
        {
          *n = v18;
          n = v19;
          v18 = *(v19 - 1);
        }
        ++v9;
      }
    }
  }
}

/*
==============
ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/
void ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **const *r_iBegin, IWMemAllocator **iEnd, unsigned __int64 depthLimit, AllocatorSortFunctor predicate)
{
  const IWMemAllocator **v4; 
  IWMemAllocator **v6; 
  IWMemAllocator **const *v7; 
  const IWMemAllocator **v8; 
  const IWMemAllocator **v9; 
  bool v10; 
  const IWMemAllocator *v11; 
  bool v12; 
  const IWMemAllocator *v13; 
  IWMemAllocator **v14; 
  IWMemAllocator **i; 
  IWMemAllocator *v16; 
  unsigned __int64 m_address; 
  IWMemAllocatorType m_type; 
  unsigned __int64 v19; 
  unsigned __int64 v20; 
  IWMemAllocatorType v21; 
  IWMemAllocator *v22; 
  IWMemAllocator **v23; 
  __int64 v24; 
  __int64 v25; 
  __int64 j; 
  IWMemAllocator **v27; 
  __int64 v28; 
  __int64 v29; 
  unsigned __int64 v30; 
  IWMemAllocator *v31; 
  IWMemAllocator *v32; 
  unsigned __int64 v33; 
  bool v34; 
  IWMemAllocatorType v35; 
  __int64 v36; 
  __int64 v37; 
  IWMemAllocator *v38; 
  unsigned __int64 v39; 
  IWMemAllocatorType v40; 
  IWMemAllocator **const *v41; 
  IWMemAllocator **v42; 
  IWMemAllocator **v43; 
  unsigned __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  IWMemAllocator **v47; 
  __int64 v48; 
  bool v49; 
  IWMemAllocator *v50; 
  IWMemAllocator *v51; 
  unsigned __int64 v52; 
  bool v53; 
  IWMemAllocatorType v54; 
  __int64 v55; 
  __int64 v56; 
  IWMemAllocator *v57; 
  unsigned __int64 v58; 
  IWMemAllocatorType v59; 
  AllocatorSortFunctor v60; 
  AllocatorSortFunctor v61; 
  __int64 v62; 
  IWMemAllocator **r_iBegina; 
  __int64 v64; 
  unsigned __int64 v65; 
  unsigned __int64 v66; 
  IWMemAllocator **v68; 
  IWMemAllocator **iEnda; 
  IWMemAllocator **iEndb; 

  iEnda = iEnd;
  v61 = predicate;
  v4 = (const IWMemAllocator **)*r_iBegin;
  v6 = iEnd;
  v7 = r_iBegin;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
    return;
  while ( depthLimit )
  {
    v8 = (const IWMemAllocator **)(v6 - 1);
    --depthLimit;
    v9 = &v4[(((char *)v6 - (char *)v4) >> 3) / 2];
    v10 = AllocatorSortFunctor::operator()(&v60, *v4, *v9);
    v11 = *(v6 - 1);
    if ( v10 )
    {
      if ( !AllocatorSortFunctor::operator()(&v60, *v9, v11) )
      {
        v12 = AllocatorSortFunctor::operator()(&v60, *v4, *v8);
        v9 = v4;
        goto LABEL_9;
      }
    }
    else
    {
      if ( !AllocatorSortFunctor::operator()(&v60, *v4, v11) )
      {
        v12 = AllocatorSortFunctor::operator()(&v60, *v9, *v8);
LABEL_9:
        if ( v12 )
          v9 = (const IWMemAllocator **)(v6 - 1);
        goto LABEL_11;
      }
      v9 = v4;
    }
LABEL_11:
    v13 = *v9;
    v14 = v6;
    for ( i = *r_iBegin; ; ++i )
    {
      while ( 1 )
      {
        v16 = *i;
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
          __debugbreak();
        if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
          __debugbreak();
        m_address = v16->m_ownedRange.m_address;
        if ( m_address >= v13->m_ownedRange.m_address )
        {
          if ( m_address > v13->m_ownedRange.m_address )
            break;
          if ( AllocatorSortFunctor::IsParentOf(v16, v13) )
            break;
          if ( !AllocatorSortFunctor::IsParentOf(v13, v16) )
          {
            m_type = v16->m_type;
            if ( m_type >= v13->m_type && (m_type > v13->m_type || v16 >= v13) )
              break;
          }
        }
        ++i;
      }
      while ( 1 )
      {
        v19 = (unsigned __int64)*--v14;
        if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
          __debugbreak();
        v20 = v13->m_ownedRange.m_address;
        if ( v20 >= *(_QWORD *)(v19 + 64) )
        {
          if ( v20 > *(_QWORD *)(v19 + 64) )
            break;
          if ( AllocatorSortFunctor::IsParentOf(v13, (const IWMemAllocator *)v19) )
            break;
          if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v19, v13) )
          {
            v21 = v13->m_type;
            if ( v21 >= *(_DWORD *)(v19 + 136) && (v21 > *(_DWORD *)(v19 + 136) || (unsigned __int64)v13 >= v19) )
              break;
          }
        }
      }
      if ( i >= v14 )
        break;
      v22 = *i;
      *i = *v14;
      *v14 = v22;
    }
    r_iBegina = i;
    ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(&r_iBegina, iEnda, depthLimit, v61);
    v6 = r_iBegina;
    v7 = r_iBegin;
    iEnda = r_iBegina;
    v4 = (const IWMemAllocator **)*r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
      return;
  }
  if ( v4 > (const IWMemAllocator **)v6 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
      __debugbreak();
    v7 = r_iBegin;
  }
  v23 = *v7;
  v24 = v6 - *v7;
  v66 = v24;
  if ( v24 < 2 )
  {
    v41 = r_iBegin;
  }
  else
  {
    v25 = (v24 - 2) / 2;
    v64 = v25;
    for ( j = 2 * v25 + 2; ; j -= 2i64 )
    {
      v27 = *v7;
      v28 = v25;
      v62 = j;
      v29 = j;
      v30 = (unsigned __int64)v27[v25];
      v65 = v30;
      if ( j < v24 )
      {
        do
        {
          v31 = (*r_iBegin)[v29];
          v32 = (*r_iBegin)[v29 - 1];
          if ( !v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v33 = v31->m_ownedRange.m_address;
          if ( v33 >= v32->m_ownedRange.m_address )
          {
            if ( v33 <= v32->m_ownedRange.m_address )
            {
              if ( AllocatorSortFunctor::IsParentOf(v31, v32) )
              {
                v34 = 0;
              }
              else if ( AllocatorSortFunctor::IsParentOf(v32, v31) )
              {
                v34 = 1;
              }
              else
              {
                v35 = v31->m_type;
                v34 = v35 < v32->m_type || v35 <= v32->m_type && v31 < v32;
              }
            }
            else
            {
              v34 = 0;
            }
          }
          else
          {
            v34 = 1;
          }
          v36 = v29 - 1;
          if ( !v34 )
            v36 = v29;
          v29 = 2 * v36 + 2;
          (*r_iBegin)[v28] = (*r_iBegin)[v36];
          v28 = v36;
        }
        while ( v29 < v24 );
        v7 = r_iBegin;
        v30 = v65;
        v25 = v64;
        j = v62;
        v27 = *r_iBegin;
      }
      if ( v29 == v24 )
      {
        v27[v28] = v27[v29 - 1];
        v28 = v29 - 1;
      }
      v37 = (v28 - 1) / 2;
      if ( v28 > v25 )
      {
        while ( 1 )
        {
          v38 = (*v7)[v37];
          if ( !v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v39 = v38->m_ownedRange.m_address;
          if ( v39 >= *(_QWORD *)(v30 + 64) )
          {
            if ( v39 > *(_QWORD *)(v30 + 64) )
              break;
            if ( AllocatorSortFunctor::IsParentOf(v38, (const IWMemAllocator *)v30) )
              break;
            if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v30, v38) )
            {
              v40 = v38->m_type;
              if ( v40 >= *(_DWORD *)(v30 + 136) && (v40 > *(_DWORD *)(v30 + 136) || (unsigned __int64)v38 >= v30) )
                break;
            }
          }
          v7 = r_iBegin;
          (*r_iBegin)[v28] = (*r_iBegin)[v37];
          v28 = v37;
          v37 = (v37 - 1) / 2;
          if ( v28 <= v25 )
            goto LABEL_89;
        }
        v7 = r_iBegin;
LABEL_89:
        v24 = v66;
        j = v62;
      }
      (*v7)[v28] = (IWMemAllocator *)v30;
      if ( !v25 )
        break;
      v64 = --v25;
    }
    v41 = r_iBegin;
    v6 = iEnda;
    v23 = *r_iBegin;
  }
  v42 = v23 + 1;
  v68 = v23 + 1;
  if ( v6 > v23 + 1 )
  {
    do
    {
      v43 = v6 - 1;
      iEndb = v6 - 1;
      v44 = (unsigned __int64)*(v6 - 1);
      v66 = v44;
      if ( v6 - 1 < *v41 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
        __debugbreak();
      v45 = 0i64;
      v46 = 2i64;
      *v43 = **v41;
      v47 = *v41;
      v48 = v43 - *v41;
      v49 = v48 == 2;
      if ( v48 > 2 )
      {
        do
        {
          v50 = (*v41)[v46];
          v51 = (*v41)[v46 - 1];
          if ( !v50 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v51 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v52 = v50->m_ownedRange.m_address;
          if ( v52 >= v51->m_ownedRange.m_address )
          {
            if ( v52 <= v51->m_ownedRange.m_address )
            {
              if ( AllocatorSortFunctor::IsParentOf(v50, v51) )
              {
                v53 = 0;
              }
              else if ( AllocatorSortFunctor::IsParentOf(v51, v50) )
              {
                v53 = 1;
              }
              else
              {
                v54 = v50->m_type;
                v53 = v54 < v51->m_type || v54 <= v51->m_type && v50 < v51;
              }
            }
            else
            {
              v53 = 0;
            }
          }
          else
          {
            v53 = 1;
          }
          v55 = v46 - 1;
          if ( !v53 )
            v55 = v46;
          v46 = 2 * v55 + 2;
          (*v41)[v45] = (*v41)[v55];
          v45 = v55;
          v49 = v46 == v48;
        }
        while ( v46 < v48 );
        v47 = *v41;
        v44 = v66;
        v42 = v68;
      }
      if ( v49 )
      {
        v47[v45] = v47[v46 - 1];
        v45 = v46 - 1;
      }
      v56 = (v45 - 1) / 2;
      if ( v45 > 0 )
      {
        do
        {
          v57 = (*v41)[v56];
          if ( !v57 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v44 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v58 = v57->m_ownedRange.m_address;
          if ( v58 >= *(_QWORD *)(v44 + 64) )
          {
            if ( v58 > *(_QWORD *)(v44 + 64) )
              break;
            if ( AllocatorSortFunctor::IsParentOf(v57, (const IWMemAllocator *)v44) )
              break;
            if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v44, v57) )
            {
              v59 = v57->m_type;
              if ( v59 >= *(_DWORD *)(v44 + 136) && (v59 > *(_DWORD *)(v44 + 136) || (unsigned __int64)v57 >= v44) )
                break;
            }
          }
          (*v41)[v45] = (*v41)[v56];
          v45 = v56;
          v56 = (v56 - 1) / 2;
        }
        while ( v45 > 0 );
        v42 = v68;
      }
      (*v41)[v45] = (IWMemAllocator *)v44;
      v6 = iEndb;
    }
    while ( iEndb > v42 );
  }
}

/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/
void ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(first, last, compare, v3);
}

/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/
void ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare, ntl::random_access_iterator_tag __formal)
{
  IWMemAllocator **v5; 
  signed __int64 v6; 
  IWMemAllocator **v7; 
  unsigned __int64 v8; 
  const IWMemAllocator **v9; 
  const IWMemAllocator **v10; 
  const IWMemAllocator *v11; 
  const IWMemAllocator **k; 
  const IWMemAllocator *v13; 
  const IWMemAllocator **v14; 
  const IWMemAllocator **m; 
  unsigned __int64 v16; 
  unsigned __int64 v17; 
  IWMemAllocatorType v18; 
  IWMemAllocator **v19; 
  IWMemAllocator **v20; 
  IWMemAllocator *v21; 
  IWMemAllocator **v22; 
  IWMemAllocator **n; 
  unsigned __int64 v24; 
  unsigned __int64 v25; 
  IWMemAllocatorType v26; 
  const IWMemAllocator **v27; 
  const IWMemAllocator *v28; 
  const IWMemAllocator **i; 
  const IWMemAllocator *v30; 
  const IWMemAllocator **v31; 
  const IWMemAllocator **j; 
  unsigned __int64 v33; 
  unsigned __int64 m_address; 
  IWMemAllocatorType v35; 
  __int64 v36; 
  AllocatorSortFunctor v37; 
  IWMemAllocator **r_iBegin; 
  IWMemAllocator **v39; 

  if ( first != last )
  {
    v39 = last;
    r_iBegin = first;
    LOBYTE(v36) = compare;
    v5 = last;
    v6 = last - first;
    v7 = first;
    if ( v6 )
      v8 = 63 - __lzcnt(v6);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(&r_iBegin, last, 2 * v8, compare);
    if ( v6 <= 16 )
    {
      v27 = (const IWMemAllocator **)(v7 + 1);
      if ( v7 + 1 != v5 )
      {
        do
        {
          v28 = *v27;
          if ( AllocatorSortFunctor::operator()(&v37, *v27, *v7) )
          {
            for ( i = v27; i != (const IWMemAllocator **)v7; i[1] = v30 )
              v30 = *--i;
            *v7 = (IWMemAllocator *)v28;
          }
          else
          {
            v31 = v27;
            for ( j = v27 - 1; ; --j )
            {
              v33 = (unsigned __int64)*j;
              if ( !v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first", v36) )
                __debugbreak();
              if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
                __debugbreak();
              m_address = v28->m_ownedRange.m_address;
              if ( m_address >= *(_QWORD *)(v33 + 64) )
              {
                if ( m_address > *(_QWORD *)(v33 + 64) )
                  break;
                if ( AllocatorSortFunctor::IsParentOf(v28, (const IWMemAllocator *)v33) )
                  break;
                if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v33, v28) )
                {
                  v35 = *(_DWORD *)(v33 + 136);
                  if ( v28->m_type >= v35 && (v28->m_type > v35 || (unsigned __int64)v28 >= v33) )
                    break;
                }
              }
              *v31 = *j;
              v31 = j;
            }
            v7 = r_iBegin;
            *v31 = v28;
          }
          ++v27;
        }
        while ( v27 != (const IWMemAllocator **)v39 );
      }
    }
    else
    {
      v9 = (const IWMemAllocator **)(v7 + 16);
      if ( v7 != v7 + 16 )
      {
        v10 = (const IWMemAllocator **)(v7 + 1);
        if ( v7 + 1 != (IWMemAllocator **)v9 )
        {
          do
          {
            v11 = *v10;
            if ( AllocatorSortFunctor::operator()(&v37, *v10, *v7) )
            {
              for ( k = v10; k != (const IWMemAllocator **)v7; k[1] = v13 )
                v13 = *--k;
              *v7 = (IWMemAllocator *)v11;
            }
            else
            {
              v14 = v10;
              for ( m = v10 - 1; ; --m )
              {
                v16 = (unsigned __int64)*m;
                if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first", v36) )
                  __debugbreak();
                if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
                  __debugbreak();
                v17 = v11->m_ownedRange.m_address;
                if ( v17 >= *(_QWORD *)(v16 + 64) )
                {
                  if ( v17 > *(_QWORD *)(v16 + 64) )
                    break;
                  if ( AllocatorSortFunctor::IsParentOf(v11, (const IWMemAllocator *)v16) )
                    break;
                  if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v16, v11) )
                  {
                    v18 = *(_DWORD *)(v16 + 136);
                    if ( v11->m_type >= v18 && (v11->m_type > v18 || (unsigned __int64)v11 >= v16) )
                      break;
                  }
                }
                *v14 = *m;
                v14 = m;
              }
              v7 = r_iBegin;
              *v14 = v11;
              v9 = (const IWMemAllocator **)(v7 + 16);
            }
            ++v10;
          }
          while ( v10 != v9 );
          v5 = v39;
        }
      }
      v19 = v7 + 16;
      r_iBegin = v7 + 16;
      if ( v7 + 16 != v5 )
      {
        v20 = v39;
        do
        {
          v21 = *v19;
          v22 = v19 - 1;
          for ( n = v19; ; n = v22-- )
          {
            v24 = (unsigned __int64)*v22;
            if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
              __debugbreak();
            if ( !v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
              __debugbreak();
            v25 = v21->m_ownedRange.m_address;
            if ( v25 >= *(_QWORD *)(v24 + 64) )
            {
              if ( v25 > *(_QWORD *)(v24 + 64) )
                break;
              if ( AllocatorSortFunctor::IsParentOf(v21, (const IWMemAllocator *)v24) )
                break;
              if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v24, v21) )
              {
                v26 = *(_DWORD *)(v24 + 136);
                if ( v21->m_type >= v26 && (v21->m_type > v26 || (unsigned __int64)v21 >= v24) )
                  break;
              }
            }
            *n = *v22;
          }
          v19 = r_iBegin + 1;
          *n = v21;
          r_iBegin = v19;
        }
        while ( v19 != v20 );
      }
    }
  }
}

/*
==============
ntl::sort<ConeTargetHitInfo *>
==============
*/
void ntl::sort<ConeTargetHitInfo *>(ConeTargetHitInfo *first, ConeTargetHitInfo *last)
{
  ntl::random_access_iterator_tag v2; 

  ntl::sort<ConeTargetHitInfo *,ntl::less<ConeTargetHitInfo,ConeTargetHitInfo>>(first, last, (ntl::less<ConeTargetHitInfo,ConeTargetHitInfo>)v2.ntl::input_iterator_tag, v2);
}

/*
==============
ntl::sort<GAssistTarget *>
==============
*/
void ntl::sort<GAssistTarget *>(GAssistTarget *first, GAssistTarget *last)
{
  ntl::random_access_iterator_tag v2; 

  ntl::sort<GAssistTarget *,ntl::less<GAssistTarget,GAssistTarget>>(first, last, (ntl::less<GAssistTarget,GAssistTarget>)v2.ntl::input_iterator_tag, v2);
}

/*
==============
ntl::sort<CAssistTarget *>
==============
*/
void ntl::sort<CAssistTarget *>(CAssistTarget *first, CAssistTarget *last)
{
  ntl::random_access_iterator_tag v2; 

  ntl::sort<CAssistTarget *,ntl::less<CAssistTarget,CAssistTarget>>(first, last, (ntl::less<CAssistTarget,CAssistTarget>)v2.ntl::input_iterator_tag, v2);
}

