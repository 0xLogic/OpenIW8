/*
==============
CgCompassSystem::GetItemInfo<CompassTurretMP>
==============
*/

CompassTurretMP *__fastcall CgCompassSystem::GetItemInfo<CompassTurretMP>(CgCompassSystem *this, const int entityNum, CompassTurretMP *list, unsigned int listMax, RWLock *lock)
{
  return ??$GetItemInfo@UCompassTurretMP@@@CgCompassSystem@@IEAAPEAUCompassTurretMP@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemMP>
==============
*/

void __fastcall CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemMP>(HunkUser *hunkUser, const int maxLocalClients)
{
  ??$AllocateCompassSystemCommon@VCgCompassSystemMP@@@CgCompassSystem@@KAXPEAUHunkUser@@H@Z(hunkUser, maxLocalClients);
}

/*
==============
CgCompassSystem::GetItemInfo<CompassPlane>
==============
*/

CompassPlane *__fastcall CgCompassSystem::GetItemInfo<CompassPlane>(CgCompassSystem *this, const int entityNum, CompassPlane *list, unsigned int listMax, RWLock *lock)
{
  return ??$GetItemInfo@UCompassPlane@@@CgCompassSystem@@IEAAPEAUCompassPlane@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemBR>
==============
*/

__int64 CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemBR>()
{
  return ??$FreeCompassSystemCommon@VCgCompassSystemBR@@@CgCompassSystem@@KAXXZ();
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemBR>
==============
*/

CgCompassSystemBR *__fastcall CgCompassSystem::GetCompassSystemCommon<CgCompassSystemBR>(const LocalClientNum_t localClientNum)
{
  return ??$GetCompassSystemCommon@VCgCompassSystemBR@@@CgCompassSystem@@KAPEAVCgCompassSystemBR@@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/

CgCompassSystemCPRaid *__fastcall CgCompassSystem::GetCompassSystemCommon<CgCompassSystemCPRaid>(const LocalClientNum_t localClientNum)
{
  return ??$GetCompassSystemCommon@VCgCompassSystemCPRaid@@@CgCompassSystem@@KAPEAVCgCompassSystemCPRaid@@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgCompassSystem::FindItemInfo<CompassTurret>
==============
*/

CompassTurret *__fastcall CgCompassSystem::FindItemInfo<CompassTurret>(CgCompassSystem *this, const int entityNum, CompassTurret *list, unsigned int listMax, RWLock *lock)
{
  return ??$FindItemInfo@UCompassTurret@@@CgCompassSystem@@IEAAPEAUCompassTurret@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemSP>
==============
*/

void __fastcall CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemSP>(const LocalClientNum_t localClientNum)
{
  ??$ClearCompassSystemCommon@VCgCompassSystemSP@@@CgCompassSystem@@KAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgCompassSystem::GetItemInfo<CompassTurret>
==============
*/

CompassTurret *__fastcall CgCompassSystem::GetItemInfo<CompassTurret>(CgCompassSystem *this, const int entityNum, CompassTurret *list, unsigned int listMax, RWLock *lock)
{
  return ??$GetItemInfo@UCompassTurret@@@CgCompassSystem@@IEAAPEAUCompassTurret@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CgCompassSystem::FindItemInfo<CompassMissile>
==============
*/

CompassMissile *__fastcall CgCompassSystem::FindItemInfo<CompassMissile>(CgCompassSystem *this, const int entityNum, CompassMissile *list, unsigned int listMax, RWLock *lock)
{
  return ??$FindItemInfo@UCompassMissile@@@CgCompassSystem@@IEAAPEAUCompassMissile@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CompassActor_SetLastEnemyPos
==============
*/

void __fastcall CompassActor_SetLastEnemyPos(CompassActor *const actor, const vec3_t *pos, const cg_t *const cgameGlob)
{
  ?CompassActor_SetLastEnemyPos@@YAXQEAUCompassActor@@AEBTvec3_t@@QEBVcg_t@@@Z(actor, pos, cgameGlob);
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemSP>
==============
*/

__int64 CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemSP>()
{
  return ??$FreeCompassSystemCommon@VCgCompassSystemSP@@@CgCompassSystem@@KAXXZ();
}

/*
==============
CgCompassSystem::FindItemInfo<CompassTurretMP>
==============
*/

CompassTurretMP *__fastcall CgCompassSystem::FindItemInfo<CompassTurretMP>(CgCompassSystem *this, const int entityNum, CompassTurretMP *list, unsigned int listMax, RWLock *lock)
{
  return ??$FindItemInfo@UCompassTurretMP@@@CgCompassSystem@@IEAAPEAUCompassTurretMP@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CompassActor_SetLastEnemyPosFromLastPos
==============
*/

void __fastcall CompassActor_SetLastEnemyPosFromLastPos(CompassActor *const actor)
{
  ?CompassActor_SetLastEnemyPosFromLastPos@@YAXQEAUCompassActor@@@Z(actor);
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemSP>
==============
*/

CgCompassSystemSP *__fastcall CgCompassSystem::GetCompassSystemCommon<CgCompassSystemSP>(const LocalClientNum_t localClientNum)
{
  return ??$GetCompassSystemCommon@VCgCompassSystemSP@@@CgCompassSystem@@KAPEAVCgCompassSystemSP@@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CompassActor_GetLastEnemyPos
==============
*/

void __fastcall CompassActor_GetLastEnemyPos(const CompassActor *const actor, vec2_t *outPos)
{
  ?CompassActor_GetLastEnemyPos@@YAXQEBUCompassActor@@AEATvec2_t@@@Z(actor, outPos);
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemSP>
==============
*/

void __fastcall CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemSP>(HunkUser *hunkUser, const int maxLocalClients)
{
  ??$AllocateCompassSystemCommon@VCgCompassSystemSP@@@CgCompassSystem@@KAXPEAUHunkUser@@H@Z(hunkUser, maxLocalClients);
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemBR>
==============
*/

void __fastcall CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemBR>(const LocalClientNum_t localClientNum)
{
  ??$ClearCompassSystemCommon@VCgCompassSystemBR@@@CgCompassSystem@@KAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgCompassSystem::GetItemInfo<CompassMissile>
==============
*/

CompassMissile *__fastcall CgCompassSystem::GetItemInfo<CompassMissile>(CgCompassSystem *this, const int entityNum, CompassMissile *list, unsigned int listMax, RWLock *lock)
{
  return ??$GetItemInfo@UCompassMissile@@@CgCompassSystem@@IEAAPEAUCompassMissile@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CgCompassSystem::GetCompassSystem
==============
*/

CgCompassSystem *__fastcall CgCompassSystem::GetCompassSystem(const LocalClientNum_t localClientNum)
{
  return ?GetCompassSystem@CgCompassSystem@@SAPEAV1@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CompassActor_GetLastPos
==============
*/

void __fastcall CompassActor_GetLastPos(const CompassActor *const actor, vec2_t *outPos)
{
  ?CompassActor_GetLastPos@@YAXQEBUCompassActor@@AEATvec2_t@@@Z(actor, outPos);
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemMP>
==============
*/

__int64 CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemMP>()
{
  return ??$FreeCompassSystemCommon@VCgCompassSystemMP@@@CgCompassSystem@@KAXXZ();
}

/*
==============
CompassActor_SetLastPosValue
==============
*/

void __fastcall CompassActor_SetLastPosValue(CompassActor *actor, const vec3_t *pos)
{
  ?CompassActor_SetLastPosValue@@YAXPEAUCompassActor@@AEBTvec3_t@@@Z(actor, pos);
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemBR>
==============
*/

void __fastcall CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemBR>(HunkUser *hunkUser, const int maxLocalClients)
{
  ??$AllocateCompassSystemCommon@VCgCompassSystemBR@@@CgCompassSystem@@KAXPEAUHunkUser@@H@Z(hunkUser, maxLocalClients);
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemMP>
==============
*/

void __fastcall CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemMP>(const LocalClientNum_t localClientNum)
{
  ??$ClearCompassSystemCommon@VCgCompassSystemMP@@@CgCompassSystem@@KAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/

void __fastcall CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemCPRaid>(const LocalClientNum_t localClientNum)
{
  ??$ClearCompassSystemCommon@VCgCompassSystemCPRaid@@@CgCompassSystem@@KAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/

void __fastcall CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemCPRaid>(HunkUser *hunkUser, const int maxLocalClients)
{
  ??$AllocateCompassSystemCommon@VCgCompassSystemCPRaid@@@CgCompassSystem@@KAXPEAUHunkUser@@H@Z(hunkUser, maxLocalClients);
}

/*
==============
CgCompassSystem::FindItemInfo<CompassPlane>
==============
*/

CompassPlane *__fastcall CgCompassSystem::FindItemInfo<CompassPlane>(CgCompassSystem *this, const int entityNum, CompassPlane *list, unsigned int listMax, RWLock *lock)
{
  return ??$FindItemInfo@UCompassPlane@@@CgCompassSystem@@IEAAPEAUCompassPlane@@HPEAU1@IPEAURWLock@@@Z(this, entityNum, list, listMax, lock);
}

/*
==============
CompassActor_GetLastPosValue
==============
*/

void __fastcall CompassActor_GetLastPosValue(const CompassActor *actor, vec3_t *pos)
{
  ?CompassActor_GetLastPosValue@@YAXPEBUCompassActor@@AEATvec3_t@@@Z(actor, pos);
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemMP>
==============
*/

CgCompassSystemMP *__fastcall CgCompassSystem::GetCompassSystemCommon<CgCompassSystemMP>(const LocalClientNum_t localClientNum)
{
  return ??$GetCompassSystemCommon@VCgCompassSystemMP@@@CgCompassSystem@@KAPEAVCgCompassSystemMP@@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/

__int64 CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemCPRaid>()
{
  return ??$FreeCompassSystemCommon@VCgCompassSystemCPRaid@@@CgCompassSystem@@KAXXZ();
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemBR>
==============
*/
CgCompassSystem *CgCompassSystem::GetCompassSystemCommon<CgCompassSystemBR>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v3; 
  __int64 v4; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 586, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type does not match-> System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", localClientNum, 2, (unsigned __int8)CgCompassSystem::ms_allocatedType) )
    __debugbreak();
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v4) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 587, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  if ( !CgCompassSystem::ms_compassSystemArray[v1] )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 588, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", v4) )
      __debugbreak();
  }
  return CgCompassSystem::ms_compassSystemArray[v1];
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemMP>
==============
*/
CgCompassSystem *CgCompassSystem::GetCompassSystemCommon<CgCompassSystemMP>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v3; 
  __int64 v4; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 586, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type does not match-> System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", localClientNum, 2, (unsigned __int8)CgCompassSystem::ms_allocatedType) )
    __debugbreak();
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v4) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 587, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  if ( !CgCompassSystem::ms_compassSystemArray[v1] )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 588, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", v4) )
      __debugbreak();
  }
  return CgCompassSystem::ms_compassSystemArray[v1];
}

/*
==============
CgCompassSystem::GetCompassSystem
==============
*/
CgCompassSystem *CgCompassSystem::GetCompassSystem(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v3; 
  __int64 v4; 

  v1 = localClientNum;
  if ( !(_BYTE)CgCompassSystem::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 575, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type is not known\n", "ms_allocatedType != GameModeType::NONE", localClientNum) )
    __debugbreak();
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v4) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 576, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  if ( !CgCompassSystem::ms_compassSystemArray[v1] )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 577, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", v4) )
      __debugbreak();
  }
  return CgCompassSystem::ms_compassSystemArray[v1];
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemBR>
==============
*/
void CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemBR>(HunkUser *hunkUser, const int maxLocalClients)
{
  __int64 v3; 
  int v4; 
  CgCompassSystemBR *v5; 
  CgCompassSystem **v6; 
  CgCompassSystem *v7; 
  __int64 v8; 
  int v9; 
  int v10; 

  v3 = maxLocalClients;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    v9 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 599, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE)", "%s\n\tTrying to allocate the compass system but it has already been allocated. Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE", v9) )
      __debugbreak();
  }
  v4 = 0;
  if ( (unsigned int)v3 > 2 )
  {
    v10 = 2;
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 600, ASSERT_TYPE_ASSERT, "( 0 ) <= ( maxLocalClients ) && ( maxLocalClients ) <= ( 2 )", "maxLocalClients not in [0, STATIC_MAX_LOCAL_CLIENTS]\n\t%i not in [%i, %i]", v8, 0i64, v10) )
      __debugbreak();
  }
  v5 = (CgCompassSystemBR *)Mem_HunkUser_AllocInternal(hunkUser, 64448 * v3, 8ui64, "CgCompassSystem::AllocateCompassSystemCommon");
  memset_0(v5, 0, 64448 * v3);
  if ( (int)v3 > 0 )
  {
    v6 = CgCompassSystem::ms_compassSystemArray;
    do
    {
      if ( *v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 610, ASSERT_TYPE_ASSERT, "(!ms_compassSystemArray[localClientIndex])", (const char *)&queryFormat, "!ms_compassSystemArray[localClientIndex]") )
        __debugbreak();
      CgCompassSystemBR::CgCompassSystemBR(v5, (const LocalClientNum_t)v4);
      *v6 = v7;
      ++v4;
      ++v6;
      ++v5;
    }
    while ( v4 < (int)v3 );
  }
  LOBYTE(CgCompassSystem::ms_allocatedType) = 2;
  CgCompassSystem::ms_allocatedCount = v3;
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/
void CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemCPRaid>(HunkUser *hunkUser, const int maxLocalClients)
{
  __int64 v3; 
  int v4; 
  CgCompassSystemCPRaid *v5; 
  CgCompassSystem **v6; 
  CgCompassSystem *v7; 
  __int64 v8; 
  int v9; 
  int v10; 

  v3 = maxLocalClients;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    v9 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 599, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE)", "%s\n\tTrying to allocate the compass system but it has already been allocated. Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE", v9) )
      __debugbreak();
  }
  v4 = 0;
  if ( (unsigned int)v3 > 2 )
  {
    v10 = 2;
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 600, ASSERT_TYPE_ASSERT, "( 0 ) <= ( maxLocalClients ) && ( maxLocalClients ) <= ( 2 )", "maxLocalClients not in [0, STATIC_MAX_LOCAL_CLIENTS]\n\t%i not in [%i, %i]", v8, 0i64, v10) )
      __debugbreak();
  }
  v5 = (CgCompassSystemCPRaid *)Mem_HunkUser_AllocInternal(hunkUser, 64304 * v3, 8ui64, "CgCompassSystem::AllocateCompassSystemCommon");
  memset_0(v5, 0, 64304 * v3);
  if ( (int)v3 > 0 )
  {
    v6 = CgCompassSystem::ms_compassSystemArray;
    do
    {
      if ( *v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 610, ASSERT_TYPE_ASSERT, "(!ms_compassSystemArray[localClientIndex])", (const char *)&queryFormat, "!ms_compassSystemArray[localClientIndex]") )
        __debugbreak();
      CgCompassSystemCPRaid::CgCompassSystemCPRaid(v5, (const LocalClientNum_t)v4);
      *v6 = v7;
      ++v4;
      ++v6;
      ++v5;
    }
    while ( v4 < (int)v3 );
  }
  LOBYTE(CgCompassSystem::ms_allocatedType) = 2;
  CgCompassSystem::ms_allocatedCount = v3;
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemMP>
==============
*/
void CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemMP>(HunkUser *hunkUser, const int maxLocalClients)
{
  __int64 v3; 
  int v4; 
  CgCompassSystemMP *v5; 
  CgCompassSystem **v6; 
  CgCompassSystem *v7; 
  __int64 v8; 
  int v9; 
  int v10; 

  v3 = maxLocalClients;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    v9 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 599, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE)", "%s\n\tTrying to allocate the compass system but it has already been allocated. Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE", v9) )
      __debugbreak();
  }
  v4 = 0;
  if ( (unsigned int)v3 > 2 )
  {
    v10 = 2;
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 600, ASSERT_TYPE_ASSERT, "( 0 ) <= ( maxLocalClients ) && ( maxLocalClients ) <= ( 2 )", "maxLocalClients not in [0, STATIC_MAX_LOCAL_CLIENTS]\n\t%i not in [%i, %i]", v8, 0i64, v10) )
      __debugbreak();
  }
  v5 = (CgCompassSystemMP *)Mem_HunkUser_AllocInternal(hunkUser, 64280 * v3, 8ui64, "CgCompassSystem::AllocateCompassSystemCommon");
  memset_0(v5, 0, 64280 * v3);
  if ( (int)v3 > 0 )
  {
    v6 = CgCompassSystem::ms_compassSystemArray;
    do
    {
      if ( *v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 610, ASSERT_TYPE_ASSERT, "(!ms_compassSystemArray[localClientIndex])", (const char *)&queryFormat, "!ms_compassSystemArray[localClientIndex]") )
        __debugbreak();
      CgCompassSystemMP::CgCompassSystemMP(v5, (const LocalClientNum_t)v4);
      *v6 = v7;
      ++v4;
      ++v6;
      ++v5;
    }
    while ( v4 < (int)v3 );
  }
  LOBYTE(CgCompassSystem::ms_allocatedType) = 2;
  CgCompassSystem::ms_allocatedCount = v3;
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemBR>
==============
*/
void CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemBR>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  void **v2; 
  CgCompassSystem *CompassSystem; 
  __int64 v4; 
  __int64 v5; 
  int v6; 
  int v7; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF_HALF )
  {
    v7 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v6 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 651, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tCgCompassSystem::ClearCompassSystemCommon: Trying to clear compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v6, v7) )
      __debugbreak();
  }
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v5) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 652, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v4, v5) )
      __debugbreak();
  }
  v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
  (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
  memset_0(*v2, 0, 0xFBC0ui64);
  CgCompassSystemBR::CgCompassSystemBR((CgCompassSystemBR *)*v2, (const LocalClientNum_t)v1);
  CompassSystem = CgCompassSystem::GetCompassSystem((const LocalClientNum_t)v1);
  CgCompassSystem::ResetCompassActorObfuscation(CompassSystem);
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/
void CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemCPRaid>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  void **v2; 
  CgCompassSystem *CompassSystem; 
  __int64 v4; 
  __int64 v5; 
  int v6; 
  int v7; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF_HALF )
  {
    v7 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v6 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 651, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tCgCompassSystem::ClearCompassSystemCommon: Trying to clear compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v6, v7) )
      __debugbreak();
  }
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v5) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 652, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v4, v5) )
      __debugbreak();
  }
  v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
  (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
  memset_0(*v2, 0, 0xFB30ui64);
  CgCompassSystemCPRaid::CgCompassSystemCPRaid((CgCompassSystemCPRaid *)*v2, (const LocalClientNum_t)v1);
  CompassSystem = CgCompassSystem::GetCompassSystem((const LocalClientNum_t)v1);
  CgCompassSystem::ResetCompassActorObfuscation(CompassSystem);
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemMP>
==============
*/
void CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemMP>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  void **v2; 
  CgCompassSystem *CompassSystem; 
  __int64 v4; 
  __int64 v5; 
  int v6; 
  int v7; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF_HALF )
  {
    v7 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v6 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 651, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tCgCompassSystem::ClearCompassSystemCommon: Trying to clear compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v6, v7) )
      __debugbreak();
  }
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v5) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 652, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v4, v5) )
      __debugbreak();
  }
  v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
  (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
  memset_0(*v2, 0, 0xFB18ui64);
  CgCompassSystemMP::CgCompassSystemMP((CgCompassSystemMP *)*v2, (const LocalClientNum_t)v1);
  CompassSystem = CgCompassSystem::GetCompassSystem((const LocalClientNum_t)v1);
  CgCompassSystem::ResetCompassActorObfuscation(CompassSystem);
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemBR>
==============
*/
void CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemBR>()
{
  char v0; 
  int v1; 
  void **v2; 
  int v3; 
  int v4; 

  v0 = CgCompassSystem::ms_allocatedType;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    if ( (_BYTE)CgCompassSystem::ms_allocatedType == HALF_HALF )
      goto LABEL_7;
    v4 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v3 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 624, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to free compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v3, v4) )
      __debugbreak();
    v0 = CgCompassSystem::ms_allocatedType;
  }
  if ( v0 != 2 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
    return;
  }
LABEL_7:
  if ( CgCompassSystem::ms_allocatedCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 628, ASSERT_TYPE_ASSERT, "(ms_allocatedCount > 0)", "%s\n\tCgCompassSystem::FreeCompassSystemCommon: Trying to free single-player compass system but no compass system has been allocated\n", "ms_allocatedCount > 0") )
    __debugbreak();
  v1 = CgCompassSystem::ms_allocatedCount - 1;
  if ( CgCompassSystem::ms_allocatedCount - 1 < 0 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
  else
  {
    v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
    do
    {
      (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
      DebugWipe(*v2, 0xFBC0ui64);
      --v1;
      *v2-- = NULL;
    }
    while ( v1 >= 0 );
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/
void CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemCPRaid>()
{
  char v0; 
  int v1; 
  void **v2; 
  int v3; 
  int v4; 

  v0 = CgCompassSystem::ms_allocatedType;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    if ( (_BYTE)CgCompassSystem::ms_allocatedType == HALF_HALF )
      goto LABEL_7;
    v4 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v3 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 624, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to free compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v3, v4) )
      __debugbreak();
    v0 = CgCompassSystem::ms_allocatedType;
  }
  if ( v0 != 2 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
    return;
  }
LABEL_7:
  if ( CgCompassSystem::ms_allocatedCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 628, ASSERT_TYPE_ASSERT, "(ms_allocatedCount > 0)", "%s\n\tCgCompassSystem::FreeCompassSystemCommon: Trying to free single-player compass system but no compass system has been allocated\n", "ms_allocatedCount > 0") )
    __debugbreak();
  v1 = CgCompassSystem::ms_allocatedCount - 1;
  if ( CgCompassSystem::ms_allocatedCount - 1 < 0 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
  else
  {
    v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
    do
    {
      (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
      DebugWipe(*v2, 0xFB30ui64);
      --v1;
      *v2-- = NULL;
    }
    while ( v1 >= 0 );
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemMP>
==============
*/
void CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemMP>()
{
  char v0; 
  int v1; 
  void **v2; 
  int v3; 
  int v4; 

  v0 = CgCompassSystem::ms_allocatedType;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    if ( (_BYTE)CgCompassSystem::ms_allocatedType == HALF_HALF )
      goto LABEL_7;
    v4 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v3 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 624, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to free compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v3, v4) )
      __debugbreak();
    v0 = CgCompassSystem::ms_allocatedType;
  }
  if ( v0 != 2 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
    return;
  }
LABEL_7:
  if ( CgCompassSystem::ms_allocatedCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 628, ASSERT_TYPE_ASSERT, "(ms_allocatedCount > 0)", "%s\n\tCgCompassSystem::FreeCompassSystemCommon: Trying to free single-player compass system but no compass system has been allocated\n", "ms_allocatedCount > 0") )
    __debugbreak();
  v1 = CgCompassSystem::ms_allocatedCount - 1;
  if ( CgCompassSystem::ms_allocatedCount - 1 < 0 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
  else
  {
    v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
    do
    {
      (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
      DebugWipe(*v2, 0xFB18ui64);
      --v1;
      *v2-- = NULL;
    }
    while ( v1 >= 0 );
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemCPRaid>
==============
*/
CgCompassSystem *CgCompassSystem::GetCompassSystemCommon<CgCompassSystemCPRaid>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v3; 
  __int64 v4; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 586, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type does not match-> System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", localClientNum, 2, (unsigned __int8)CgCompassSystem::ms_allocatedType) )
    __debugbreak();
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v4) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 587, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  if ( !CgCompassSystem::ms_compassSystemArray[v1] )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 588, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", v4) )
      __debugbreak();
  }
  return CgCompassSystem::ms_compassSystemArray[v1];
}

/*
==============
CgCompassSystem::GetCompassSystemCommon<CgCompassSystemSP>
==============
*/
CgCompassSystem *CgCompassSystem::GetCompassSystemCommon<CgCompassSystemSP>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v3; 
  __int64 v4; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 586, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type does not match-> System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", localClientNum, 1, (unsigned __int8)CgCompassSystem::ms_allocatedType) )
    __debugbreak();
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v4) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 587, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  if ( !CgCompassSystem::ms_compassSystemArray[v1] )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 588, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", v4) )
      __debugbreak();
  }
  return CgCompassSystem::ms_compassSystemArray[v1];
}

/*
==============
CgCompassSystem::FindItemInfo<CompassMissile>
==============
*/
CompassMissile *CgCompassSystem::FindItemInfo<CompassMissile>(CgCompassSystem *this, const int entityNum, CompassMissile *list, unsigned int listMax, RWLock *lock)
{
  CompassMissile *v6; 
  char v10; 
  unsigned int v11; 
  CompassMissile *v12; 

  v6 = NULL;
  v10 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v10 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 684, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireReadLock(lock);
  }
  v11 = 0;
  if ( listMax )
  {
    v12 = list;
    while ( v12->entityNum != entityNum )
    {
      ++v11;
      ++v12;
      if ( v11 >= listMax )
        goto LABEL_12;
    }
    v6 = &list[v11];
    v6->lastAccessTime = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  }
LABEL_12:
  if ( v10 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 157, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    ReleaseSRWLockShared((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  return v6;
}

/*
==============
CgCompassSystem::FindItemInfo<CompassPlane>
==============
*/
CompassPlane *CgCompassSystem::FindItemInfo<CompassPlane>(CgCompassSystem *this, const int entityNum, CompassPlane *list, unsigned int listMax, RWLock *lock)
{
  CompassPlane *v6; 
  char v10; 
  unsigned int v11; 
  CompassPlane *v12; 

  v6 = NULL;
  v10 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v10 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 684, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireReadLock(lock);
  }
  v11 = 0;
  if ( listMax )
  {
    v12 = list;
    while ( v12->entityNum != entityNum )
    {
      ++v11;
      ++v12;
      if ( v11 >= listMax )
        goto LABEL_12;
    }
    v6 = &list[v11];
    v6->lastAccessTime = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  }
LABEL_12:
  if ( v10 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 157, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    ReleaseSRWLockShared((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  return v6;
}

/*
==============
CgCompassSystem::FindItemInfo<CompassTurretMP>
==============
*/
CompassTurretMP *CgCompassSystem::FindItemInfo<CompassTurretMP>(CgCompassSystem *this, const int entityNum, CompassTurretMP *list, unsigned int listMax, RWLock *lock)
{
  CompassTurretMP *v6; 
  char v10; 
  unsigned int v11; 
  CompassTurretMP *v12; 

  v6 = NULL;
  v10 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v10 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 684, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireReadLock(lock);
  }
  v11 = 0;
  if ( listMax )
  {
    v12 = list;
    while ( v12->entityNum != entityNum )
    {
      ++v11;
      ++v12;
      if ( v11 >= listMax )
        goto LABEL_12;
    }
    v6 = &list[v11];
    v6->lastAccessTime = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  }
LABEL_12:
  if ( v10 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 157, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    ReleaseSRWLockShared((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  return v6;
}

/*
==============
CgCompassSystem::GetItemInfo<CompassMissile>
==============
*/
CompassMissile *CgCompassSystem::GetItemInfo<CompassMissile>(CgCompassSystem *this, const int entityNum, CompassMissile *list, unsigned int listMax, RWLock *lock)
{
  __int64 v5; 
  unsigned int v6; 
  CgCompassSystem *v8; 
  CompassMissile *v11; 
  char v12; 
  unsigned int v13; 
  CompassMissile *v14; 
  char v15; 
  int time; 
  int lastUpdateTime; 

  v5 = tls_index;
  v6 = 0;
  v8 = this;
  v11 = NULL;
  v12 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v12 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 684, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireReadLock(lock);
    v8 = this;
  }
  v13 = 0;
  if ( listMax )
  {
    v14 = list;
    while ( v14->entityNum != entityNum )
    {
      ++v13;
      ++v14;
      if ( v13 >= listMax )
        goto LABEL_12;
    }
    v11 = &list[v13];
    v11->lastAccessTime = CG_GetLocalClientGlobals((const LocalClientNum_t)v8->m_localClientNum)->time;
  }
LABEL_12:
  if ( v12 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 157, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    ReleaseSRWLockShared((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  if ( v11 )
    return v11;
  v15 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v5) + 1664i64);
  if ( v15 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 730, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireWriteLock(lock);
  }
  time = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  if ( !listMax )
    goto LABEL_36;
  while ( list->lastAccessTime == time )
  {
LABEL_29:
    ++v6;
    ++list;
    if ( v6 >= listMax )
      goto LABEL_32;
  }
  lastUpdateTime = list->lastUpdateTime;
  if ( lastUpdateTime )
  {
    if ( !v11 || lastUpdateTime < v11->lastUpdateTime )
      v11 = list;
    goto LABEL_29;
  }
  v11 = list;
LABEL_32:
  if ( !v11 )
  {
LABEL_36:
    Com_PrintError(14, "CgCompassSystem::GetItemInfo: Failed to get item info, list is full (%d)\n", listMax);
    goto LABEL_37;
  }
  if ( time - v11->lastUpdateTime <= 500 )
    Com_PrintWarning(14, "CgCompassSystem::GetItemInfo: Recycling old compass items pretty quickly.  Need to raise max? (current max: %d)", listMax);
  *(_QWORD *)&v11->entityNum = 0i64;
  *(_QWORD *)&v11->lastAccessTime = 0i64;
  *(_QWORD *)&v11->pos.y = 0i64;
  *(_QWORD *)&v11->yaw = 0i64;
  v11->entityNum = entityNum;
  v11->lastAccessTime = time;
LABEL_37:
  if ( v15 )
    Sys_ReleaseWriteLock(lock);
  return v11;
}

/*
==============
CgCompassSystem::GetItemInfo<CompassPlane>
==============
*/
CompassPlane *CgCompassSystem::GetItemInfo<CompassPlane>(CgCompassSystem *this, const int entityNum, CompassPlane *list, unsigned int listMax, RWLock *lock)
{
  __int64 v5; 
  unsigned int v6; 
  CgCompassSystem *v8; 
  CompassPlane *v11; 
  char v12; 
  unsigned int v13; 
  CompassPlane *v14; 
  char v15; 
  int time; 
  int lastUpdateTime; 

  v5 = tls_index;
  v6 = 0;
  v8 = this;
  v11 = NULL;
  v12 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v12 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 684, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireReadLock(lock);
    v8 = this;
  }
  v13 = 0;
  if ( listMax )
  {
    v14 = list;
    while ( v14->entityNum != entityNum )
    {
      ++v13;
      ++v14;
      if ( v13 >= listMax )
        goto LABEL_12;
    }
    v11 = &list[v13];
    v11->lastAccessTime = CG_GetLocalClientGlobals((const LocalClientNum_t)v8->m_localClientNum)->time;
  }
LABEL_12:
  if ( v12 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 157, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    ReleaseSRWLockShared((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  if ( v11 )
    return v11;
  v15 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v5) + 1664i64);
  if ( v15 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 730, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireWriteLock(lock);
  }
  time = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  if ( !listMax )
    goto LABEL_36;
  while ( list->lastAccessTime == time )
  {
LABEL_29:
    ++v6;
    ++list;
    if ( v6 >= listMax )
      goto LABEL_32;
  }
  lastUpdateTime = list->lastUpdateTime;
  if ( lastUpdateTime )
  {
    if ( !v11 || lastUpdateTime < v11->lastUpdateTime )
      v11 = list;
    goto LABEL_29;
  }
  v11 = list;
LABEL_32:
  if ( !v11 )
  {
LABEL_36:
    Com_PrintError(14, "CgCompassSystem::GetItemInfo: Failed to get item info, list is full (%d)\n", listMax);
    goto LABEL_37;
  }
  if ( time - v11->lastUpdateTime <= 500 )
    Com_PrintWarning(14, "CgCompassSystem::GetItemInfo: Recycling old compass items pretty quickly.  Need to raise max? (current max: %d)", listMax);
  *(_QWORD *)&v11->entityNum = 0i64;
  *(_QWORD *)&v11->lastAccessTime = 0i64;
  *(_QWORD *)&v11->lastPos.y = 0i64;
  *(_QWORD *)&v11->lastYaw = 0i64;
  v11->planeMedia.friendly = NULL;
  v11->planeMedia.enemy = NULL;
  v11->entityNum = entityNum;
  v11->lastAccessTime = time;
LABEL_37:
  if ( v15 )
    Sys_ReleaseWriteLock(lock);
  return v11;
}

/*
==============
CgCompassSystem::GetItemInfo<CompassTurretMP>
==============
*/
CompassTurretMP *CgCompassSystem::GetItemInfo<CompassTurretMP>(CgCompassSystem *this, const int entityNum, CompassTurretMP *list, unsigned int listMax, RWLock *lock)
{
  CompassTurretMP *v6; 
  CompassTurretMP *result; 
  CompassTurretMP *v10; 
  char v11; 
  int time; 
  unsigned int v13; 
  int lastUpdateTime; 

  v6 = list;
  result = CgCompassSystem::FindItemInfo<CompassTurretMP>(this, entityNum, list, listMax, lock);
  v10 = result;
  if ( result )
    return result;
  v11 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v11 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 730, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    Sys_AcquireWriteLock(lock);
  }
  time = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  v13 = 0;
  if ( !listMax )
    goto LABEL_20;
  while ( v6->lastAccessTime == time )
  {
LABEL_13:
    ++v13;
    ++v6;
    if ( v13 >= listMax )
      goto LABEL_16;
  }
  lastUpdateTime = v6->lastUpdateTime;
  if ( lastUpdateTime )
  {
    if ( !v10 || lastUpdateTime < v10->lastUpdateTime )
      v10 = v6;
    goto LABEL_13;
  }
  v10 = v6;
LABEL_16:
  if ( !v10 )
  {
LABEL_20:
    Com_PrintError(14, "CgCompassSystem::GetItemInfo: Failed to get item info, list is full (%d)\n", listMax);
    goto LABEL_21;
  }
  if ( time - v10->lastUpdateTime <= 500 )
    Com_PrintWarning(14, "CgCompassSystem::GetItemInfo: Recycling old compass items pretty quickly.  Need to raise max? (current max: %d)", listMax);
  *(_QWORD *)&v10->entityNum = 0i64;
  *(_QWORD *)&v10->lastAccessTime = 0i64;
  *(_QWORD *)v10->positionCurrent.v = 0i64;
  *(_QWORD *)&v10->positionCurrent.z = 0i64;
  *(_QWORD *)&v10->positionLastKnown.y = 0i64;
  *(_QWORD *)&v10->yawCurrent = 0i64;
  *(_QWORD *)&v10->isFriendly = 0i64;
  v10->entityNum = entityNum;
  v10->lastAccessTime = time;
LABEL_21:
  if ( v11 )
    Sys_ReleaseWriteLock(lock);
  return v10;
}

/*
==============
CompassActor_GetLastPos
==============
*/
void CompassActor_GetLastPos(const CompassActor *const actor, vec2_t *outPos)
{
  vec3_t pos; 

  CompassActor_GetLastPosValue(actor, &pos);
  *outPos = *(vec2_t *)pos.v;
  memset(&pos, 0, sizeof(pos));
}

/*
==============
CompassActor_GetLastPosValue
==============
*/
void CompassActor_GetLastPosValue(const CompassActor *actor, vec3_t *pos)
{
  if ( !actor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 169, ASSERT_TYPE_ASSERT, "(actor)", (const char *)&queryFormat, "actor") )
    __debugbreak();
  if ( !actor->lastPos.Get_lastPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 177, ASSERT_TYPE_ASSERT, "(actor->lastPos.Get_lastPos)", (const char *)&queryFormat, "actor->lastPos.Get_lastPos") )
    __debugbreak();
  ((void (__fastcall *)(vec4_t *, vec3_t *))((unsigned __int64)actor->lastPos.Get_lastPos ^ s_aab_get_pointer_lastpos ^ (unsigned __int64)&actor->lastPos))(&actor->lastPos.lastPos, pos);
}

/*
==============
CompassActor_SetLastEnemyPosFromLastPos
==============
*/
void CompassActor_SetLastEnemyPosFromLastPos(CompassActor *const actor)
{
  vec3_t pos; 

  if ( !actor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 879, ASSERT_TYPE_ASSERT, "(actor)", (const char *)&queryFormat, "actor", -2i64) )
    __debugbreak();
  CompassActor_GetLastPosValue(actor, &pos);
  if ( !actor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 253, ASSERT_TYPE_ASSERT, "(actor)", (const char *)&queryFormat, "actor") )
    __debugbreak();
  if ( !actor->lastEnemyPos.Set_lastEnemyPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 261, ASSERT_TYPE_ASSERT, "(actor->lastEnemyPos.Set_lastEnemyPos)", (const char *)&queryFormat, "actor->lastEnemyPos.Set_lastEnemyPos") )
    __debugbreak();
  ((void (__fastcall *)(vec3_t *, vec4_t *))((unsigned __int64)&actor->lastEnemyPos.Get_lastEnemyPos ^ (__int64)actor->lastEnemyPos.Set_lastEnemyPos ^ s_aab_set_pointer_lastenemypos))(&pos, &actor->lastEnemyPos.lastEnemyPos);
  actor->lastEnemyPosZ = actor->lastPosZ;
  memset(&pos, 0, sizeof(pos));
}

/*
==============
CompassActor_SetLastPosValue
==============
*/
void CompassActor_SetLastPosValue(CompassActor *actor, const vec3_t *pos)
{
  if ( !actor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 197, ASSERT_TYPE_ASSERT, "(actor)", (const char *)&queryFormat, "actor") )
    __debugbreak();
  if ( !actor->lastPos.Set_lastPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 205, ASSERT_TYPE_ASSERT, "(actor->lastPos.Set_lastPos)", (const char *)&queryFormat, "actor->lastPos.Set_lastPos") )
    __debugbreak();
  ((void (__fastcall *)(const vec3_t *, vec4_t *))((unsigned __int64)actor->lastPos.Set_lastPos ^ s_aab_set_pointer_lastpos ^ (unsigned __int64)&actor->lastPos.Get_lastPos))(pos, &actor->lastPos.lastPos);
}

/*
==============
CgCompassSystem::FindItemInfo<CompassTurret>
==============
*/
CompassTurret *CgCompassSystem::FindItemInfo<CompassTurret>(CgCompassSystem *this, const int entityNum, CompassTurret *list, unsigned int listMax, RWLock *lock)
{
  CompassTurret *v6; 
  char v10; 
  unsigned int v11; 
  CompassTurret *v12; 

  v6 = NULL;
  v10 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v10 )
  {
    if ( !lock )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 684, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 146, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
        __debugbreak();
    }
    Sys_CheckAcquireLock(lock);
    AcquireSRWLockShared((PSRWLOCK)lock);
  }
  v11 = 0;
  if ( listMax )
  {
    v12 = list;
    while ( v12->entityNum != entityNum )
    {
      ++v11;
      ++v12;
      if ( v11 >= listMax )
        goto LABEL_14;
    }
    v6 = &list[v11];
    v6->lastAccessTime = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  }
LABEL_14:
  if ( v10 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 157, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    ReleaseSRWLockShared((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  return v6;
}

/*
==============
CgCompassSystem::GetItemInfo<CompassTurret>
==============
*/
CompassTurret *CgCompassSystem::GetItemInfo<CompassTurret>(CgCompassSystem *this, const int entityNum, CompassTurret *list, unsigned int listMax, RWLock *lock)
{
  __int64 v5; 
  CompassTurret *v7; 
  char v11; 
  unsigned int v12; 
  CompassTurret *v13; 
  char v14; 
  threadId_t CurrentThreadId; 
  cg_t *LocalClientGlobals; 
  unsigned int v17; 
  int time; 
  int lastUpdateTime; 

  v5 = tls_index;
  v7 = NULL;
  v11 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64);
  if ( v11 )
  {
    if ( !lock )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 684, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 146, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
        __debugbreak();
    }
    Sys_CheckAcquireLock(lock);
    AcquireSRWLockShared((PSRWLOCK)lock);
  }
  v12 = 0;
  if ( listMax )
  {
    v13 = list;
    while ( v13->entityNum != entityNum )
    {
      ++v12;
      ++v13;
      if ( v12 >= listMax )
        goto LABEL_14;
    }
    v7 = &list[v12];
    v7->lastAccessTime = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->time;
  }
LABEL_14:
  if ( v11 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 157, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    ReleaseSRWLockShared((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  if ( v7 )
    return v7;
  v14 = *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v5) + 1664i64);
  if ( v14 )
  {
    if ( !lock )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 730, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 168, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
        __debugbreak();
    }
    Sys_CheckAcquireLock(lock);
    AcquireSRWLockExclusive((PSRWLOCK)lock);
    CurrentThreadId = Sys_GetCurrentThreadId();
    lock->writeThreadId = CurrentThreadId;
    if ( !CurrentThreadId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 177, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) != ( INVALID_THREAD_ID )", "%s != %s\n\t%i, %i", "lock->writeThreadId", "INVALID_THREAD_ID", 0, 0i64) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v17 = 0;
  time = LocalClientGlobals->time;
  if ( !listMax )
    goto LABEL_42;
  while ( list->lastAccessTime == time )
  {
LABEL_35:
    ++v17;
    ++list;
    if ( v17 >= listMax )
      goto LABEL_38;
  }
  lastUpdateTime = list->lastUpdateTime;
  if ( lastUpdateTime )
  {
    if ( !v7 || lastUpdateTime < v7->lastUpdateTime )
      v7 = list;
    goto LABEL_35;
  }
  v7 = list;
LABEL_38:
  if ( !v7 )
  {
LABEL_42:
    Com_PrintError(14, "CgCompassSystem::GetItemInfo: Failed to get item info, list is full (%d)\n", listMax);
    goto LABEL_43;
  }
  if ( time - v7->lastUpdateTime <= 500 )
    Com_PrintWarning(14, "CgCompassSystem::GetItemInfo: Recycling old compass items pretty quickly.  Need to raise max? (current max: %d)", listMax);
  v7->lastUpdateTime = 0;
  *(_QWORD *)&v7->firePingTime = 0i64;
  *(_QWORD *)&v7->positionCurrent.y = 0i64;
  *(_QWORD *)v7->positionLastKnown.v = 0i64;
  *(_QWORD *)&v7->positionLastKnown.z = 0i64;
  *(_QWORD *)&v7->yawLastKnown = 0i64;
  v7->entityNum = entityNum;
  v7->lastAccessTime = time;
LABEL_43:
  if ( v14 )
  {
    if ( !lock && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 216, ASSERT_TYPE_ASSERT, "(lock)", (const char *)&queryFormat, "lock") )
      __debugbreak();
    lock->writeThreadId = 0;
    ReleaseSRWLockExclusive((PSRWLOCK)lock);
    Sys_CheckReleaseLock(lock);
  }
  return v7;
}

/*
==============
CompassActor_SetLastEnemyPos
==============
*/
void CompassActor_SetLastEnemyPos(CompassActor *const actor, const vec3_t *pos, const cg_t *const cgameGlob)
{
  CompassEnemyElevation v6; 
  bool v7; 

  if ( !actor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 837, ASSERT_TYPE_ASSERT, "(actor)", (const char *)&queryFormat, "actor") )
    __debugbreak();
  v6 = CG_Compass_CalcElevation(cgameGlob, pos);
  v7 = actor->lastEnemyPos.Set_lastEnemyPos == NULL;
  actor->lastEnemyPosZ.elevation = v6;
  actor->lastEnemyPosZ.zIsValid = 1;
  if ( v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 261, ASSERT_TYPE_ASSERT, "(actor->lastEnemyPos.Set_lastEnemyPos)", (const char *)&queryFormat, "actor->lastEnemyPos.Set_lastEnemyPos") )
    __debugbreak();
  ((void (__fastcall *)(const vec3_t *, vec4_t *))((unsigned __int64)actor->lastEnemyPos.Set_lastEnemyPos ^ s_aab_set_pointer_lastenemypos ^ (unsigned __int64)&actor->lastEnemyPos.Get_lastEnemyPos))(pos, &actor->lastEnemyPos.lastEnemyPos);
}

/*
==============
CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemSP>
==============
*/
void CgCompassSystem::AllocateCompassSystemCommon<CgCompassSystemSP>(HunkUser *hunkUser, const int maxLocalClients)
{
  __int64 v3; 
  int v4; 
  CgCompassSystemSP *v5; 
  CgCompassSystem **v6; 
  CgCompassSystem *v7; 
  __int64 v8; 
  int v9; 
  int v10; 

  v3 = maxLocalClients;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    v9 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 599, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE)", "%s\n\tTrying to allocate the compass system but it has already been allocated. Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE", v9) )
      __debugbreak();
  }
  v4 = 0;
  if ( (unsigned int)v3 > 2 )
  {
    v10 = 2;
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 600, ASSERT_TYPE_ASSERT, "( 0 ) <= ( maxLocalClients ) && ( maxLocalClients ) <= ( 2 )", "maxLocalClients not in [0, STATIC_MAX_LOCAL_CLIENTS]\n\t%i not in [%i, %i]", v8, 0i64, v10) )
      __debugbreak();
  }
  v5 = (CgCompassSystemSP *)Mem_HunkUser_AllocInternal(hunkUser, 6712 * v3, 8ui64, "CgCompassSystem::AllocateCompassSystemCommon");
  memset_0(v5, 0, 6712 * v3);
  if ( (int)v3 > 0 )
  {
    v6 = CgCompassSystem::ms_compassSystemArray;
    do
    {
      if ( *v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 610, ASSERT_TYPE_ASSERT, "(!ms_compassSystemArray[localClientIndex])", (const char *)&queryFormat, "!ms_compassSystemArray[localClientIndex]") )
        __debugbreak();
      CgCompassSystemSP::CgCompassSystemSP(v5, (const LocalClientNum_t)v4);
      *v6 = v7;
      ++v4;
      ++v6;
      ++v5;
    }
    while ( v4 < (int)v3 );
  }
  LOBYTE(CgCompassSystem::ms_allocatedType) = 1;
  CgCompassSystem::ms_allocatedCount = v3;
}

/*
==============
CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemSP>
==============
*/
void CgCompassSystem::FreeCompassSystemCommon<CgCompassSystemSP>()
{
  char v0; 
  int v1; 
  void **v2; 
  int v3; 
  int v4; 

  v0 = CgCompassSystem::ms_allocatedType;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType )
  {
    if ( (_BYTE)CgCompassSystem::ms_allocatedType == HALF )
      goto LABEL_7;
    v4 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v3 = 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 624, ASSERT_TYPE_ASSERT, "(ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tTrying to free compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == GameModeType::NONE || ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v3, v4) )
      __debugbreak();
    v0 = CgCompassSystem::ms_allocatedType;
  }
  if ( v0 != 1 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
    return;
  }
LABEL_7:
  if ( CgCompassSystem::ms_allocatedCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 628, ASSERT_TYPE_ASSERT, "(ms_allocatedCount > 0)", "%s\n\tCgCompassSystem::FreeCompassSystemCommon: Trying to free single-player compass system but no compass system has been allocated\n", "ms_allocatedCount > 0") )
    __debugbreak();
  v1 = CgCompassSystem::ms_allocatedCount - 1;
  if ( CgCompassSystem::ms_allocatedCount - 1 < 0 )
  {
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
  else
  {
    v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
    do
    {
      (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
      DebugWipe(*v2, 0x1A38ui64);
      --v1;
      *v2-- = NULL;
    }
    while ( v1 >= 0 );
    CgCompassSystem::ms_allocatedCount = 0;
    LOBYTE(CgCompassSystem::ms_allocatedType) = 0;
  }
}

/*
==============
CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemSP>
==============
*/
void CgCompassSystem::ClearCompassSystemCommon<CgCompassSystemSP>(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  void **v2; 
  __int64 v3; 
  __int64 v4; 
  int v5; 
  int v6; 

  v1 = localClientNum;
  if ( (_BYTE)CgCompassSystem::ms_allocatedType != HALF )
  {
    v6 = (unsigned __int8)CgCompassSystem::ms_allocatedType;
    v5 = 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 651, ASSERT_TYPE_ASSERT, "(ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE)", "%s\n\tCgCompassSystem::ClearCompassSystemCommon: Trying to clear compass system but the allocated type does not match. System Type:%d  Allocated Type:%d\n", "ms_allocatedType == SubSystem::COMPASS_SYSTEM_TYPE", v5, v6) )
      __debugbreak();
  }
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v4) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 652, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  v2 = (void **)&CgCompassSystem::ms_compassSystemArray[v1];
  (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)*v2 + 120i64))(*v2, 0i64);
  memset_0(*v2, 0, 0x1A38ui64);
  CgCompassSystemSP::CgCompassSystemSP((CgCompassSystemSP *)*v2, (const LocalClientNum_t)v1);
  if ( !(_BYTE)CgCompassSystem::ms_allocatedType )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 575, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type is not known\n", "ms_allocatedType != GameModeType::NONE", v4) )
      __debugbreak();
  }
  if ( (unsigned int)v1 >= CgCompassSystem::ms_allocatedCount )
  {
    LODWORD(v4) = CgCompassSystem::ms_allocatedCount;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 576, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  if ( !*v2 )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 577, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", v4) )
      __debugbreak();
  }
  CgCompassSystem::ResetCompassActorObfuscation((CgCompassSystem *const)*v2);
}

/*
==============
CompassActor_GetLastEnemyPos
==============
*/
void CompassActor_GetLastEnemyPos(const CompassActor *const actor, vec2_t *outPos)
{
  __int64 v4[4]; 

  if ( !actor && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 225, ASSERT_TYPE_ASSERT, "(actor)", (const char *)&queryFormat, "actor", -2i64) )
    __debugbreak();
  if ( !actor->lastEnemyPos.Get_lastEnemyPos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 233, ASSERT_TYPE_ASSERT, "(actor->lastEnemyPos.Get_lastEnemyPos)", (const char *)&queryFormat, "actor->lastEnemyPos.Get_lastEnemyPos") )
    __debugbreak();
  ((void (__fastcall *)(vec4_t *, __int64 *))((unsigned __int64)&actor->lastEnemyPos ^ (__int64)actor->lastEnemyPos.Get_lastEnemyPos ^ s_aab_get_pointer_lastenemypos))(&actor->lastEnemyPos.lastEnemyPos, v4);
  *outPos = (vec2_t)v4[0];
  memset(v4, 0, 0xCui64);
}

