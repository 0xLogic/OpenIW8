/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::next(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::clear(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdPlayerVote@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::get(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const bdString *key, bdRichPresenceService **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdRichPresenceService@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::remove
==============
*/

bool __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::remove(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key)
{
  return ?remove@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEAA_NAEBVbdAddr@@@Z(this, key);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator
==============
*/

void *__fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this)
{
  return ?getIterator@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::clear(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::next(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::put(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const bdString *key, bdStorage *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdStorage@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::get(bdHashMap<bdString,bdService *,bdHashingClass> *this, const bdString *key, bdService **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdService@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::createMap(bdHashMap<bdString,bdService *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::next(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::put
==============
*/

bool __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::put(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key, const bdReference<bdConnection> *value)
{
  return ?put@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEAA_NAEBVbdAddrHandleRefWrapper@@AEBV?$bdReference@VbdConnection@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::releaseIterator(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator
==============
*/

void *__fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this)
{
  return ?getIterator@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, void **iterator)
{
  return ?remove@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEAA_NAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator(bdHashMap<bdString,bdStorage *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, void **iterator)
{
  return ?remove@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEAA_NAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::get(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const bdString *key, bdStorage **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdStorage@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::createMap
==============
*/

void __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::createMap(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::resize(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::clear(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::clear(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::next(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::next(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::bdHashMap<bdString,bdTeams *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::bdHashMap<bdString,bdTeams *,bdHashingClass>(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::createMap(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::get(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const bdString *key, bdMarketingComms **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdMarketingComms@@@Z(this, key, value);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::bdHashMap<bdString,bdService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::bdHashMap<bdString,bdService *,bdHashingClass>(bdHashMap<bdString,bdService *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::createMap(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::createMap(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::createMap(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator
==============
*/

void *__fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key)
{
  return ?getIterator@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEBAPEAXAEBVbdAddr@@@Z(this, key);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::resize(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::next
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::next(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, void **iterator)
{
  ?next@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdService *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::get(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const bdString *key, bdMail **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdMail@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::~bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>
==============
*/

void __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::~bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this)
{
  ??1?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::createMap(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::clear(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::createMap(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdService *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::putAll
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::putAll(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdHashMap<bdString,bdJSONValue,bdHashingClass> *map)
{
  ?putAll@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEAAXAEBV1@@Z(this, map);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::resize(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::get
==============
*/

bool __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::get(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key, bdReference<bdRelayAssociation> *value)
{
  return ?get@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEBA_NAEBVbdAddr@@AEAV?$bdReference@VbdRelayAssociation@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getIterator(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::resize(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::put(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const bdString *key, bdMail *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdMail@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::next(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key)
{
  return ?getIterator@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEBAPEAXAEBVbdEndpoint@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::next(bdHashMap<bdString,bdMail *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::bdHashMap<bdString,bdJSONValue,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::bdHashMap<bdString,bdJSONValue,bdHashingClass>(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::next(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator
==============
*/

void *__fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key)
{
  return ?getIterator@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEBAPEAXAEBVbdAddrHandleRefWrapper@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::remove(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key)
{
  return ?remove@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEAA_NAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::resize(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::get
==============
*/

bool __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::get(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key, bdReference<bdConnection> *value)
{
  return ?get@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEBA_NAEBVbdAddrHandleRefWrapper@@AEAV?$bdReference@VbdConnection@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::put(bdHashMap<bdString,bdService *,bdHashingClass> *this, const bdString *key, bdService *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdService@@@Z(this, key, value);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::next(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::resize(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::createMap(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::createMap(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMail *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getIterator(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key)
{
  return ?getIterator@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@QEBAPEAXAEBV?$bdReference@VbdCommonAddr@@@@@Z(this, key);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::get(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key, bdReference<bdRemoteTask> *value)
{
  return ?get@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEBA_NAEB_KAEAV?$bdReference@VbdRemoteTask@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::remove(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key)
{
  return ?remove@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEAA_NAEBVbdSecurityID@@@Z(this, key);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::createMap(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::get(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key, bdReference<bdDTLSAssociation> *value)
{
  return ?get@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEBA_NAEBVbdEndpoint@@AEAV?$bdReference@VbdDTLSAssociation@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::bdHashMap<bdString,bdReward *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::bdHashMap<bdString,bdReward *,bdHashingClass>(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::get(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const bdString *key, bdPublisherVariables **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdPublisherVariables@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::~bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::~bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this)
{
  ??1?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::~bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::~bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this)
{
  ??1?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::put(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const bdString *key, bdReward *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdReward@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::resize(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::~bdHashMap<bdString,bdMatchMaking *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::~bdHashMap<bdString,bdMatchMaking *,bdHashingClass>(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::get(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const bdString *key, bdReward **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdReward@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::get(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key, bdDemonataPushMessageHandler **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdDemonataPushMessageHandler@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator
==============
*/

void *__fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this)
{
  return ?getIterator@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::put(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const bdString *key, bdRichPresenceService *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdRichPresenceService@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::put
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::put(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key, const bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *value)
{
  return ?put@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEAA_NAEBV?$bdReference@VbdCommonAddr@@@@AEBV?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::put(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const bdEndpoint *key, const bdReference<bdAddrHandle> *value)
{
  return ?put@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@QEAA_NAEBVbdEndpoint@@AEBV?$bdReference@VbdAddrHandle@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::bdHashMap<bdString,bdMarketplace *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::bdHashMap<bdString,bdMarketplace *,bdHashingClass>(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::resize(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::createMap
==============
*/

void __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::createMap(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::resize(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::~bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::~bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::clear(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key)
{
  return ?remove@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEAA_NAEB_K@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::next(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::createMap(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::next(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::put(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key, const bdJSONValue *value)
{
  return ?put@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBVbdJSONValue@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::clear(bdHashMap<bdString,bdMail *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::next(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::~bdHashMap<bdString,bdMail *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::~bdHashMap<bdString,bdMail *,bdHashingClass>(bdHashMap<bdString,bdMail *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::clear(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::bdHashMap<bdString,bdMarketingComms *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::bdHashMap<bdString,bdMarketingComms *,bdHashingClass>(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::resize(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::next(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::createMap(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::get(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const bdString *key, bdMarketplace **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdMarketplace@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::put(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const bdString *key, bdMarketingComms *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdMarketingComms@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::next
==============
*/

void __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::next(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::clear(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::containsKey
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::containsKey(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key)
{
  return ?containsKey@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEBA_NAEBV?$bdReference@VbdCommonAddr@@@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::containsKey
==============
*/

bool __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::containsKey(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key)
{
  return ?containsKey@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEBA_NAEBVbdSecurityID@@@Z(this, key);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::put
==============
*/

bool __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::put(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key, const bdReference<bdRelayAssociation> *value)
{
  return ?put@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEAA_NAEBVbdAddr@@AEBV?$bdReference@VbdRelayAssociation@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::releaseIterator(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::put(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key, const bdReference<bdRemoteTask> *value)
{
  return ?put@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEAA_NAEB_KAEBV?$bdReference@VbdRemoteTask@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::put(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const bdString *key, bdTeamShowcase *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdTeamShowcase@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::put(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key, bdDemonataPushMessageHandler *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdDemonataPushMessageHandler@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::resize(bdHashMap<bdString,bdService *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::clear(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdPlayerVote@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key)
{
  return ?remove@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEAA_NAEBVbdEndpoint@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::~bdHashMap<bdString,bdPlayerVote *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::~bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdPlayerVote@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::resize(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::resize(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::next(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::get(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const bdString *key, bdTeamShowcase **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdTeamShowcase@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::next(bdHashMap<bdString,bdService *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMail *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::clear(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::next(bdHashMap<bdString,bdReward *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::clear(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::resize(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::resize
==============
*/

void __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::resize(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::bdHashMap<bdString,bdStorage *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::bdHashMap<bdString,bdStorage *,bdHashingClass>(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::put(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned __int64 *key, const bdReference<bdByteBuffer> *value)
{
  return ?put@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@QEAA_NAEB_KAEBV?$bdReference@VbdByteBuffer@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::~bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::~bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::clear(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::releaseIterator(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key)
{
  return ?getIterator@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEBAPEAXAEBVbdSecurityID@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::createMap(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::resize(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::clear(bdHashMap<bdString,bdTeams *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::releaseIterator(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::bdHashMap<bdString,bdMatchMaking *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::bdHashMap<bdString,bdMatchMaking *,bdHashingClass>(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::~bdHashMap<bdString,bdMarketplace *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::~bdHashMap<bdString,bdMarketplace *,bdHashingClass>(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key)
{
  return ?getIterator@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEBAPEAXAEB_K@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator(bdHashMap<bdString,bdReward *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::put(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key, const bdSecurityKey *value)
{
  return ?put@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEAA_NAEBVbdSecurityID@@AEBVbdSecurityKey@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::~bdHashMap<bdString,bdMarketingComms *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::~bdHashMap<bdString,bdMarketingComms *,bdHashingClass>(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::put(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const bdString *key, bdMarketplace *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdMarketplace@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::createMap(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdPlayerVote@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::createMap(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::bdHashMap<bdString,bdMail *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::bdHashMap<bdString,bdMail *,bdHashingClass>(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::resize(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::clear
==============
*/

void __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::clear(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this)
{
  ?clear@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::put(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const bdString *key, bdPublisherVariables *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdPublisherVariables@@@Z(this, key, value);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::createMap(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::remove(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key)
{
  return ?remove@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@QEAA_NAEBV?$bdReference@VbdCommonAddr@@@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::~bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::~bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::get(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const bdString *key, bdRedeemableCodeService **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdRedeemableCodeService@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::next(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::resize(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::clear(bdHashMap<bdString,bdService *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::createMap(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::bdHashMap<bdString,bdPlayerVote *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ??0?$bdHashMap@VbdString@@PEAVbdPlayerVote@@VbdHashingClass@@@@QEAA@IM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::createMap(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::~bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::~bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::~bdHashMap<bdString,bdReward *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::~bdHashMap<bdString,bdReward *,bdHashingClass>(bdHashMap<bdString,bdReward *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::clear(bdHashMap<bdString,bdReward *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::put(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key, const bdReference<bdDTLSAssociation> *value)
{
  return ?put@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@QEAA_NAEBV?$bdReference@VbdCommonAddr@@@@AEBV?$bdReference@VbdDTLSAssociation@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::clear(bdHashMap<bdString,bdStorage *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::get(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key, bdReference<bdDTLSAssociation> *value)
{
  return ?get@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@QEBA_NAEBV?$bdReference@VbdCommonAddr@@@@AEAV?$bdReference@VbdDTLSAssociation@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::~bdHashMap<bdString,bdTeams *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::~bdHashMap<bdString,bdTeams *,bdHashingClass>(bdHashMap<bdString,bdTeams *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::clear(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::put(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key, const bdReference<bdDTLSAssociation> *value)
{
  return ?put@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEAA_NAEBVbdEndpoint@@AEBV?$bdReference@VbdDTLSAssociation@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this)
{
  ??1?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::resize(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdDTLSAssociation@@@@VbdEndpointHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::~bdHashMap<bdString,bdService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::~bdHashMap<bdString,bdService *,bdHashingClass>(bdHashMap<bdString,bdService *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::releaseIterator(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, void **iterator)
{
  return ?remove@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEAA_NAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::containsKey
==============
*/

bool __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::containsKey(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key)
{
  return ?containsKey@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEBA_NAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdReward *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdReward@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::~bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::~bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::remove
==============
*/

bool __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::remove(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key)
{
  return ?remove@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEAA_NAEBVbdAddrHandleRefWrapper@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::createMap(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdService *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdService@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::put(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const bdString *key, bdTeams *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdTeams@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::~bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::~bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::remove(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned __int64 *key, bdReference<bdByteBuffer> *value)
{
  return ?remove@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@QEAA_NAEB_KAEAV?$bdReference@VbdByteBuffer@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getIterator(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdDemonataPushMessageHandler@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::resize
==============
*/

void __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::resize(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key)
{
  return ?remove@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEAA_NAEBV?$bdReference@VbdCommonAddr@@@@@Z(this, key);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::~bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>
==============
*/

void __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::~bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this)
{
  ??1?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::releaseIterator(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::resize
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::resize(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this)
{
  ??1?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::releaseIterator(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::put(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const bdString *key, bdMatchMaking *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdMatchMaking@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::get(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const bdString *key, bdMatchMaking **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdMatchMaking@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdMatchMaking@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::resize(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::resize
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::resize(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const unsigned int newSize)
{
  ?resize@?$bdHashMap@VbdString@@PEAVbdMail@@VbdHashingClass@@@@IEAAXI@Z(this, newSize);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::clear(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@_KV?$bdReference@VbdRemoteTask@@@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return ?getNextCapacity@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@KAII@Z(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::createMap(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const bdEndpoint *key)
{
  return ?remove@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@QEAA_NAEBVbdEndpoint@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::clear(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdTeamShowcase@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::clear
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::clear(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this)
{
  ?clear@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, void **iterator)
{
  return ?remove@?$bdHashMap@VbdEndpoint@@V?$bdReference@VbdAddrHandle@@@@VbdEndpointHashingClass@@@@QEAA_NAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::~bdHashMap<bdString,bdJSONValue,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::~bdHashMap<bdString,bdJSONValue,bdHashingClass>(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::clear
==============
*/

void __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::clear(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this)
{
  ?clear@?$bdHashMap@VbdAddrHandleRefWrapper@@V?$bdReference@VbdConnection@@@@V1@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::~bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::~bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this)
{
  ??1?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdReference@VbdDTLSAssociation@@@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::next
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::next(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::put
==============
*/

bool __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::put(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const bdString *key, bdRedeemableCodeService *const *value)
{
  return ?put@?$bdHashMap@VbdString@@PEAVbdRedeemableCodeService@@VbdHashingClass@@@@QEAA_NAEBVbdString@@AEBQEAVbdRedeemableCodeService@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::createMap
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::createMap(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::get
==============
*/

bool __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::get(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key, bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *value)
{
  return ?get@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEBA_NAEBV?$bdReference@VbdCommonAddr@@@@AEAV?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::next
==============
*/

void __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::next(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, void **iterator)
{
  ?next@?$bdHashMap@VbdAddr@@V?$bdReference@VbdRelayAssociation@@@@VbdAddrHash@@@@QEBAXAEAPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::createMap(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const unsigned int initialCapacity, const float loadFactor)
{
  ?createMap@?$bdHashMap@VbdString@@PEAVbdPublisherVariables@@VbdHashingClass@@@@IEAAXIM@Z(this, initialCapacity, loadFactor);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getIterator(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@_KV?$bdReference@VbdByteBuffer@@@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::get(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key, bdSecurityKey *value)
{
  return ?get@?$bdHashMap@VbdSecurityID@@VbdSecurityKey@@VbdHashingClass@@@@QEBA_NAEBVbdSecurityID@@AEAVbdSecurityKey@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::remove
==============
*/

bool __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::remove(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key)
{
  return ?remove@?$bdHashMap@VbdString@@VbdJSONValue@@VbdHashingClass@@@@QEAA_NAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::~bdHashMap<bdString,bdStorage *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::~bdHashMap<bdString,bdStorage *,bdHashingClass>(bdHashMap<bdString,bdStorage *,bdHashingClass> *this)
{
  ??1?$bdHashMap@VbdString@@PEAVbdStorage@@VbdHashingClass@@@@QEAA@XZ(this);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::clear
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::clear(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this)
{
  ?clear@?$bdHashMap@VbdString@@PEAVbdRichPresenceService@@VbdHashingClass@@@@QEAAXXZ(this);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator
==============
*/

void *__fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key)
{
  return ?getIterator@?$bdHashMap@V?$bdReference@VbdCommonAddr@@@@V?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@VbdCommonAddrHash@@@@QEBAPEAXAEBV?$bdReference@VbdCommonAddr@@@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::get
==============
*/

bool __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::get(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const bdString *key, bdTeams **value)
{
  return ?get@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEBA_NAEBVbdString@@AEAPEAVbdTeams@@@Z(this, key, value);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeams *,bdHashingClass> *this)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdTeams@@VbdHashingClass@@@@QEBAPEAXXZ(this);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator
==============
*/

void *__fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const bdString *key)
{
  return ?getIterator@?$bdHashMap@VbdString@@PEAVbdMarketingComms@@VbdHashingClass@@@@QEBAPEAXAEBVbdString@@@Z(this, key);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::releaseIterator
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, void *iterator)
{
  ?releaseIterator@?$bdHashMap@VbdString@@PEAVbdMarketplace@@VbdHashingClass@@@@QEBAXPEAX@Z(this, iterator);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::get
==============
*/
char bdHashMap<bdString,bdService *,bdHashingClass>::get(bdHashMap<bdString,bdService *,bdHashingClass> *this, const bdString *key, bdService **value)
{
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v6; 

  if ( !this->m_size )
    return 0;
  v6 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v6 )
    return 0;
  while ( !bdString::operator==((bdString *)key, &v6->m_key) )
  {
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  *value = v6->m_data;
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdService *,bdHashingClass>::Node *bdHashMap<bdString,bdService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdService *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdService *,bdHashingClass>::put(bdHashMap<bdString,bdService *,bdHashingClass> *this, const bdString *key, bdService *const *value)
{
  bdService *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdService *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdService *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdService *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdService *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdService *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdService *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdService *,bdHashingClass>::resize(bdHashMap<bdString,bdService *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdService *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdService *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::bdHashMap<bdString,bdJSONValue,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::bdHashMap<bdString,bdJSONValue,bdHashingClass>(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdJSONValue,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::~bdHashMap<bdString,bdJSONValue,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdJSONValue,bdHashingClass>::~bdHashMap<bdString,bdJSONValue,bdHashingClass>(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this)
{
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdJSONValue,bdHashingClass>::clear(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **m_map; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v5; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdJSONValue,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        bdString::~bdString((bdString *)&v6->m_key);
        bdJSONValue::~bdJSONValue(&v6->m_data);
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::containsKey
==============
*/
bool bdHashMap<bdString,bdJSONValue,bdHashingClass>::containsKey(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key)
{
  void *Iterator; 

  Iterator = bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdJSONValue,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
  return Iterator != NULL;
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::createMap(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdJSONValue,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *bdHashMap<bdString,bdJSONValue,bdHashingClass>::getIterator(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdJSONValue,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdJSONValue,bdHashingClass>::next(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[3].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 2);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdJSONValue,bdHashingClass>::put(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key, const bdJSONValue *value)
{
  unsigned int v6; 
  __int64 v7; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v8; 
  unsigned int m_size; 
  bdJSONValue *v10; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v11; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v12; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdJSONValue,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v7 = v6 & (this->m_capacity - 1);
  v8 = this->m_map[v7];
  if ( v8 )
  {
    while ( !bdString::operator==((bdString *)key, &v8->m_key) )
    {
      v8 = v8->m_next;
      if ( !v8 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      bdHashMap<bdString,bdJSONValue,bdHashingClass>::resize(this, 2 * this->m_capacity);
      v7 = v6 & (this->m_capacity - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v10 = (bdJSONValue *)bdMemory::allocate(0x20ui64);
    v11 = (bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *)v10;
    if ( v10 )
    {
      v12 = this->m_map[v7];
      bdJSONValue::bdJSONValue(v10, value);
      bdString::bdString((bdString *)&v11->m_key, key);
      v11->m_next = v12;
    }
    else
    {
      v11 = NULL;
    }
    this->m_map[v7] = v11;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::putAll
==============
*/
void bdHashMap<bdString,bdJSONValue,bdHashingClass>::putAll(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdHashMap<bdString,bdJSONValue,bdHashingClass> *map)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  __int64 i; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **m_map; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v14; 
  const bdString *p_m_key; 
  unsigned int v16; 
  unsigned int v17; 
  __int64 v18; 

  m_size = map->m_size;
  if ( m_size )
  {
    if ( m_size + this->m_size > this->m_threshold )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, rax
        vdivss  xmm1, xmm0, dword ptr [rcx+8]
        vaddss  xmm2, xmm1, cs:__real@3f800000
        vcvttss2si rdx, xmm2; newSize
      }
      bdHashMap<bdString,bdJSONValue,bdHashingClass>::resize(this, _RDX);
      m_size = map->m_size;
    }
    if ( m_size )
    {
      m_capacity = map->m_capacity;
      for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
      {
        if ( map->m_map[i] )
          break;
      }
      m_map = map->m_map;
      if ( m_map[i] )
      {
        _InterlockedExchangeAdd((volatile signed __int32 *)&map->m_numIterators, 1u);
        m_map = map->m_map;
      }
      v14 = m_map[i];
      if ( v14 )
      {
        while ( 1 )
        {
          do
          {
            p_m_key = &v14->m_key;
            bdHashMap<bdString,bdJSONValue,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
            v14 = v14->m_next;
          }
          while ( v14 );
          v16 = bdHashingClass::getHash<bdString>(&map->m_hashClass, p_m_key);
          v17 = map->m_capacity;
          v18 = (v16 & (v17 - 1)) + 1;
          if ( (unsigned int)v18 >= v17 )
            break;
          while ( 1 )
          {
            v14 = map->m_map[v18];
            if ( v14 )
              break;
            v18 = (unsigned int)(v18 + 1);
            if ( (unsigned int)v18 >= v17 )
              goto LABEL_15;
          }
        }
LABEL_15:
        _InterlockedExchangeAdd((volatile signed __int32 *)&map->m_numIterators, 0xFFFFFFFF);
      }
    }
  }
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdJSONValue,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdJSONValue,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::remove
==============
*/
char bdHashMap<bdString,bdJSONValue,bdHashingClass>::remove(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const bdString *key)
{
  __int64 v4; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v5; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v6; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdJSONValue,class bdHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  v4 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1);
  v5 = this->m_map[v4];
  v6 = NULL;
  if ( !v5 )
    return 0;
  while ( !bdString::operator==((bdString *)key, &v5->m_key) )
  {
    v6 = v5;
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  m_next = v5->m_next;
  if ( v6 )
    v6->m_next = m_next;
  else
    this->m_map[v4] = m_next;
  bdString::~bdString((bdString *)&v5->m_key);
  bdJSONValue::~bdJSONValue(&v5->m_data);
  bdMemory::deallocate(v5);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdString,bdJSONValue,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdJSONValue,bdHashingClass>::resize(bdHashMap<bdString,bdJSONValue,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v14; 
  bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdJSONValue,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdJSONValue,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = v14;
          v14 = v14->m_next;
          bdString::~bdString((bdString *)&v15->m_key);
          bdJSONValue::~bdJSONValue(&v15->m_data);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::~bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::~bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **m_map; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v5; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        if ( v6->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          if ( v6->m_data.m_ptr )
            ((void (__fastcall *)(bdRemoteTask *, __int64))v6->m_data.m_ptr->~bdReferencable)(v6->m_data.m_ptr, 1i64);
          v6->m_data.m_ptr = NULL;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::clear
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::clear(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **m_map; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v5; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdByteBuffer>,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        if ( v6->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          if ( v6->m_data.m_ptr )
            ((void (__fastcall *)(bdByteBuffer *, __int64))v6->m_data.m_ptr->~bdReferencable)(v6->m_data.m_ptr, 1i64);
          v6->m_data.m_ptr = NULL;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::clear
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::clear(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **m_map; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v5; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        if ( v6->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          if ( v6->m_data.m_ptr )
            ((void (__fastcall *)(bdRemoteTask *, __int64))v6->m_data.m_ptr->~bdReferencable)(v6->m_data.m_ptr, 1i64);
          v6->m_data.m_ptr = NULL;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::createMap(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdByteBuffer>,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::createMap(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::get
==============
*/
char bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::get(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key, bdReference<bdRemoteTask> *value)
{
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v5; 

  if ( !this->m_size )
    return 0;
  v5 = this->m_map[((16777619 * (*((unsigned __int8 *)key + 6) ^ (16777619 * (*((unsigned __int8 *)key + 5) ^ (16777619 * (*((unsigned __int8 *)key + 4) ^ (16777619 * (*((unsigned __int8 *)key + 3) ^ (16777619 * (*((unsigned __int8 *)key + 2) ^ (16777619 * (*((unsigned __int8 *)key + 1) ^ (16777619 * *(unsigned __int8 *)key))))))))))))) ^ *((unsigned __int8 *)key + 7)) & (this->m_capacity - 1)];
  if ( !v5 )
    return 0;
  while ( *key != v5->m_key )
  {
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  bdReference<bdRemoteTask>::operator=(value, &v5->m_data);
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getIterator
==============
*/
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getIterator(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator
==============
*/
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key)
{
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *result; 

  if ( !this->m_size )
    return 0i64;
  result = this->m_map[((16777619 * (*((unsigned __int8 *)key + 6) ^ (16777619 * (*((unsigned __int8 *)key + 5) ^ (16777619 * (*((unsigned __int8 *)key + 4) ^ (16777619 * (*((unsigned __int8 *)key + 3) ^ (16777619 * (*((unsigned __int8 *)key + 2) ^ (16777619 * (*((unsigned __int8 *)key + 1) ^ (16777619 * *(unsigned __int8 *)key))))))))))))) ^ *((unsigned __int8 *)key + 7)) & (this->m_capacity - 1)];
  if ( !result )
    return 0i64;
  while ( *key != result->m_key )
  {
    result = result->m_next;
    if ( !result )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return result;
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator
==============
*/
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getIterator(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::next
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::next(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, void **iterator)
{
  unsigned __int8 *v2; 
  void *v4; 
  unsigned int m_capacity; 
  __int64 v6; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v7; 

  v4 = (void *)*((_QWORD *)*iterator + 2);
  if ( v4 )
  {
    *iterator = v4;
  }
  else
  {
    m_capacity = this->m_capacity;
    v2 = (unsigned __int8 *)*iterator;
    v6 = ((v2[15] ^ (16777619 * (v2[14] ^ (16777619 * (v2[13] ^ (16777619 * (v2[12] ^ (16777619 * (v2[11] ^ (16777619 * (v2[10] ^ (16777619 * (v2[9] ^ (16777619 * v2[8])))))))))))))) & (m_capacity - 1)) + 1;
    if ( (unsigned int)v6 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v7 = this->m_map[v6];
        if ( v7 )
          break;
        v6 = (unsigned int)(v6 + 1);
        if ( (unsigned int)v6 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v7;
    }
  }
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::next
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::next(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, void **iterator)
{
  unsigned __int8 *v2; 
  void *v4; 
  unsigned int m_capacity; 
  __int64 v6; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v7; 

  v4 = (void *)*((_QWORD *)*iterator + 2);
  if ( v4 )
  {
    *iterator = v4;
  }
  else
  {
    m_capacity = this->m_capacity;
    v2 = (unsigned __int8 *)*iterator;
    v6 = ((v2[15] ^ (16777619 * (v2[14] ^ (16777619 * (v2[13] ^ (16777619 * (v2[12] ^ (16777619 * (v2[11] ^ (16777619 * (v2[10] ^ (16777619 * (v2[9] ^ (16777619 * v2[8])))))))))))))) & (m_capacity - 1)) + 1;
    if ( (unsigned int)v6 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v7 = this->m_map[v6];
        if ( v7 )
          break;
        v6 = (unsigned int)(v6 + 1);
        if ( (unsigned int)v6 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v7;
    }
  }
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::put
==============
*/
char bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::put(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned __int64 *key, const bdReference<bdByteBuffer> *value)
{
  const bdReference<bdByteBuffer> *v4; 
  int v7; 
  __int64 m_capacity; 
  __int64 v9; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **m_map; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v11; 
  unsigned int m_size; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **v19; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v22; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v23; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v24; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v25; 
  bdByteBuffer *m_ptr; 
  int v28; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdByteBuffer>,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = *((unsigned __int8 *)key + 7) ^ (16777619 * (*((unsigned __int8 *)key + 6) ^ (16777619 * (*((unsigned __int8 *)key + 5) ^ (16777619 * (*((unsigned __int8 *)key + 4) ^ (16777619 * (*((unsigned __int8 *)key + 3) ^ (16777619 * (*((unsigned __int8 *)key + 2) ^ (16777619 * (*((unsigned __int8 *)key + 1) ^ (16777619 * *(unsigned __int8 *)key)))))))))))));
  v28 = v7;
  m_capacity = this->m_capacity;
  v9 = v7 & (unsigned int)(m_capacity - 1);
  m_map = this->m_map;
  v11 = m_map[v9];
  if ( v11 )
  {
    while ( *key != v11->m_key )
    {
      v11 = v11->m_next;
      if ( !v11 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( (_DWORD)m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = v22;
              v22 = v22->m_next;
              if ( v23->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v23->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
              {
                if ( v23->m_data.m_ptr )
                  ((void (__fastcall *)(bdByteBuffer *, __int64))v23->m_data.m_ptr->~bdReferencable)(v23->m_data.m_ptr, 1i64);
                v23->m_data.m_ptr = NULL;
              }
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v7 = v28;
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v9 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *)bdMemory::allocate(0x18ui64);
    if ( v24 )
    {
      v25 = this->m_map[v9];
      m_ptr = v4->m_ptr;
      v24->m_data = (bdReference<bdByteBuffer>)v4->m_ptr;
      if ( m_ptr )
        _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
      v24->m_key = *key;
      v24->m_next = v25;
    }
    else
    {
      v24 = NULL;
    }
    this->m_map[(unsigned int)v9] = v24;
    return 1;
  }
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::put
==============
*/
char bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::put(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key, const bdReference<bdRemoteTask> *value)
{
  const bdReference<bdRemoteTask> *v4; 
  int v7; 
  __int64 m_capacity; 
  __int64 v9; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **m_map; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v11; 
  unsigned int m_size; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **v19; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v22; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v23; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v24; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v25; 
  bdRemoteTask *m_ptr; 
  int v28; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = *((unsigned __int8 *)key + 7) ^ (16777619 * (*((unsigned __int8 *)key + 6) ^ (16777619 * (*((unsigned __int8 *)key + 5) ^ (16777619 * (*((unsigned __int8 *)key + 4) ^ (16777619 * (*((unsigned __int8 *)key + 3) ^ (16777619 * (*((unsigned __int8 *)key + 2) ^ (16777619 * (*((unsigned __int8 *)key + 1) ^ (16777619 * *(unsigned __int8 *)key)))))))))))));
  v28 = v7;
  m_capacity = this->m_capacity;
  v9 = v7 & (unsigned int)(m_capacity - 1);
  m_map = this->m_map;
  v11 = m_map[v9];
  if ( v11 )
  {
    while ( *key != v11->m_key )
    {
      v11 = v11->m_next;
      if ( !v11 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( (_DWORD)m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = v22;
              v22 = v22->m_next;
              if ( v23->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v23->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
              {
                if ( v23->m_data.m_ptr )
                  ((void (__fastcall *)(bdRemoteTask *, __int64))v23->m_data.m_ptr->~bdReferencable)(v23->m_data.m_ptr, 1i64);
                v23->m_data.m_ptr = NULL;
              }
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v7 = v28;
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v9 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *)bdMemory::allocate(0x18ui64);
    if ( v24 )
    {
      v25 = this->m_map[v9];
      m_ptr = v4->m_ptr;
      v24->m_data = (bdReference<bdRemoteTask>)v4->m_ptr;
      if ( m_ptr )
        _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
      v24->m_key = *key;
      v24->m_next = v25;
    }
    else
    {
      v24 = NULL;
    }
    this->m_map[(unsigned int)v9] = v24;
    return 1;
  }
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::releaseIterator(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::remove
==============
*/
char bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::remove(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned __int64 *key, bdReference<bdByteBuffer> *value)
{
  __int64 v6; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v7; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v8; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *m_next; 
  bdByteBuffer *m_ptr; 

  v6 = (*((unsigned __int8 *)key + 7) ^ (16777619 * (*((unsigned __int8 *)key + 6) ^ (16777619 * (*((unsigned __int8 *)key + 5) ^ (16777619 * (*((unsigned __int8 *)key + 4) ^ (16777619 * (*((unsigned __int8 *)key + 3) ^ (16777619 * (*((unsigned __int8 *)key + 2) ^ (16777619 * (*((unsigned __int8 *)key + 1) ^ (16777619 * *(unsigned __int8 *)key)))))))))))))) & (this->m_capacity - 1);
  v7 = this->m_map[v6];
  v8 = NULL;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdByteBuffer>,class bdHashingClass>::remove", 0xD4u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  if ( !v7 )
    return 0;
  while ( *key != v7->m_key )
  {
    v8 = v7;
    v7 = v7->m_next;
    if ( !v7 )
      return 0;
  }
  m_next = v7->m_next;
  if ( v8 )
    v8->m_next = m_next;
  else
    this->m_map[v6] = m_next;
  if ( v7 != (bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *)value )
  {
    if ( value->m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&value->m_ptr->m_refCount, 0xFFFFFFFF) == 1 && value->m_ptr )
      ((void (__fastcall *)(bdByteBuffer *, __int64))value->m_ptr->~bdReferencable)(value->m_ptr, 1i64);
    m_ptr = v7->m_data.m_ptr;
    value->m_ptr = (bdByteBuffer *)v7->m_data;
    if ( m_ptr )
      _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
  }
  if ( v7->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v7->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
  {
    if ( v7->m_data.m_ptr )
      ((void (__fastcall *)(bdByteBuffer *, __int64))v7->m_data.m_ptr->~bdReferencable)(v7->m_data.m_ptr, 1i64);
    v7->m_data.m_ptr = NULL;
  }
  bdMemory::deallocate(v7);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove
==============
*/
char bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, void **iterator)
{
  unsigned __int8 *v4; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **v5; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v6; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v7; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *m_next; 
  void *iteratora; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 1, "(m_numIterators == 1)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::remove", 0xF9u, "bdHashMap::remove, more than one iterator held while removing from hashmap", -2i64);
  iteratora = *iterator;
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::next(this, &iteratora);
  v4 = (unsigned __int8 *)*iterator;
  *iterator = iteratora;
  v5 = &this->m_map[(this->m_capacity - 1) & (v4[15] ^ (16777619 * (v4[14] ^ (16777619 * (v4[13] ^ (16777619 * (v4[12] ^ (16777619 * (v4[11] ^ (16777619 * (v4[10] ^ (16777619 * (v4[9] ^ (16777619 * v4[8]))))))))))))))];
  v6 = *v5;
  v7 = NULL;
  if ( !*v5 )
    return 0;
  while ( *((_QWORD *)v4 + 1) != v6->m_key )
  {
    v7 = v6;
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  m_next = v6->m_next;
  if ( v7 )
    v7->m_next = m_next;
  else
    *v5 = m_next;
  if ( v6->m_data.m_ptr && !_InterlockedDecrement((volatile signed __int32 *)&v6->m_data.m_ptr->m_refCount) )
  {
    if ( v6->m_data.m_ptr )
      ((void (__fastcall *)(bdRemoteTask *, __int64))v6->m_data.m_ptr->~bdReferencable)(v6->m_data.m_ptr, 1i64);
    v6->m_data.m_ptr = NULL;
  }
  bdMemory::deallocate(v6);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove
==============
*/
char bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::remove(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned __int64 *key)
{
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **v4; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v5; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v6; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<unsigned __int64,class bdReference<class bdRemoteTask>,class bdHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  v4 = &this->m_map[(this->m_capacity - 1) & (*((unsigned __int8 *)key + 7) ^ (16777619 * (*((unsigned __int8 *)key + 6) ^ (16777619 * (*((unsigned __int8 *)key + 5) ^ (16777619 * (*((unsigned __int8 *)key + 4) ^ (16777619 * (*((unsigned __int8 *)key + 3) ^ (16777619 * (*((unsigned __int8 *)key + 2) ^ (16777619 * (*((unsigned __int8 *)key + 1) ^ (16777619 * *(unsigned __int8 *)key))))))))))))))];
  v5 = *v4;
  v6 = NULL;
  if ( !*v4 )
    return 0;
  while ( *key != v5->m_key )
  {
    v6 = v5;
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  m_next = v5->m_next;
  if ( v6 )
    v6->m_next = m_next;
  else
    *v4 = m_next;
  if ( v5->m_data.m_ptr && !_InterlockedDecrement((volatile signed __int32 *)&v5->m_data.m_ptr->m_refCount) )
  {
    if ( v5->m_data.m_ptr )
      ((void (__fastcall *)(bdRemoteTask *, __int64))v5->m_data.m_ptr->~bdReferencable)(v5->m_data.m_ptr, 1i64);
    v5->m_data.m_ptr = NULL;
  }
  bdMemory::deallocate(v5);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::resize
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::resize(bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **v11; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v14; 
  bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<unsigned __int64,bdReference<bdByteBuffer>,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = v14;
          v14 = v14->m_next;
          if ( v15->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v15->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
          {
            if ( v15->m_data.m_ptr )
              ((void (__fastcall *)(bdByteBuffer *, __int64))v15->m_data.m_ptr->~bdReferencable)(v15->m_data.m_ptr, 1i64);
            v15->m_data.m_ptr = NULL;
          }
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::resize
==============
*/
void bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::resize(bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **v11; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v14; 
  bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<unsigned __int64,bdReference<bdRemoteTask>,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = v14;
          v14 = v14->m_next;
          if ( v15->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v15->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
          {
            if ( v15->m_data.m_ptr )
              ((void (__fastcall *)(bdRemoteTask *, __int64))v15->m_data.m_ptr->~bdReferencable)(v15->m_data.m_ptr, 1i64);
            v15->m_data.m_ptr = NULL;
          }
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::bdHashMap<bdString,bdMail *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::bdHashMap<bdString,bdMail *,bdHashingClass>(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMail *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::bdHashMap<bdString,bdMarketingComms *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::bdHashMap<bdString,bdMarketingComms *,bdHashingClass>(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::bdHashMap<bdString,bdMarketplace *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::bdHashMap<bdString,bdMarketplace *,bdHashingClass>(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::bdHashMap<bdString,bdMatchMaking *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::bdHashMap<bdString,bdMatchMaking *,bdHashingClass>(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMatchMaking *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::bdHashMap<bdString,bdPlayerVote *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPlayerVote *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::bdHashMap<bdString,bdReward *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::bdHashMap<bdString,bdReward *,bdHashingClass>(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdReward *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::bdHashMap<bdString,bdService *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::bdHashMap<bdString,bdService *,bdHashingClass>(bdHashMap<bdString,bdService *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdService *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdService *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::bdHashMap<bdString,bdStorage *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::bdHashMap<bdString,bdStorage *,bdHashingClass>(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::bdHashMap<bdString,bdTeams *,bdHashingClass>
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::bdHashMap<bdString,bdTeams *,bdHashingClass>(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::~bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::~bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::~bdHashMap<bdString,bdMail *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdMail *,bdHashingClass>::~bdHashMap<bdString,bdMail *,bdHashingClass>(bdHashMap<bdString,bdMail *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdMail *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::~bdHashMap<bdString,bdMarketingComms *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::~bdHashMap<bdString,bdMarketingComms *,bdHashingClass>(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::~bdHashMap<bdString,bdMarketplace *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdMarketplace *,bdHashingClass>::~bdHashMap<bdString,bdMarketplace *,bdHashingClass>(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::~bdHashMap<bdString,bdMatchMaking *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::~bdHashMap<bdString,bdMatchMaking *,bdHashingClass>(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::~bdHashMap<bdString,bdPlayerVote *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::~bdHashMap<bdString,bdPlayerVote *,bdHashingClass>(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPlayerVote *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::~bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::~bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::~bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::~bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::~bdHashMap<bdString,bdReward *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdReward *,bdHashingClass>::~bdHashMap<bdString,bdReward *,bdHashingClass>(bdHashMap<bdString,bdReward *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdReward *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::~bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::~bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::~bdHashMap<bdString,bdService *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdService *,bdHashingClass>::~bdHashMap<bdString,bdService *,bdHashingClass>(bdHashMap<bdString,bdService *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdService *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::~bdHashMap<bdString,bdStorage *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdStorage *,bdHashingClass>::~bdHashMap<bdString,bdStorage *,bdHashingClass>(bdHashMap<bdString,bdStorage *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdStorage *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::~bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::~bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::~bdHashMap<bdString,bdTeams *,bdHashingClass>
==============
*/
void bdHashMap<bdString,bdTeams *,bdHashingClass>::~bdHashMap<bdString,bdTeams *,bdHashingClass>(bdHashMap<bdString,bdTeams *,bdHashingClass> *this)
{
  bdHashMap<bdString,bdTeams *,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::clear(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdMail *,bdHashingClass>::clear(bdHashMap<bdString,bdMail *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::clear(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdMarketplace *,bdHashingClass>::clear(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::clear(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMatchMaking *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::clear(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPlayerVote *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::clear(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::clear(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdReward *,bdHashingClass>::clear(bdHashMap<bdString,bdReward *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::clear(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdService *,bdHashingClass>::clear(bdHashMap<bdString,bdService *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdService *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdStorage *,bdHashingClass>::clear(bdHashMap<bdString,bdStorage *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::clear(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::clear
==============
*/
void bdHashMap<bdString,bdTeams *,bdHashingClass>::clear(bdHashMap<bdString,bdTeams *,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **m_map; 
  bdString *m_string; 
  bdString *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    m_string = (bdString *)m_map[v3];
    if ( m_string )
    {
      do
      {
        v6 = m_string;
        m_string = (bdString *)m_string[2].m_string;
        bdString::~bdString(v6 + 1);
        bdMemory::deallocate(v6);
      }
      while ( m_string );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::createMap(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::createMap(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMail *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::createMap(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::createMap(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::createMap(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMatchMaking *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::createMap(bdHashMap<bdString,bdPlayerVote *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPlayerVote *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::createMap(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::createMap(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::createMap(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdReward *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::createMap(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdService *,bdHashingClass>::createMap(bdHashMap<bdString,bdService *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdService *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdService *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::createMap(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::createMap(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::createMap(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::get
==============
*/
char bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::get(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key, bdDemonataPushMessageHandler **value)
{
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v6; 

  if ( !this->m_size )
    return 0;
  v6 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v6 )
    return 0;
  while ( !bdString::operator==((bdString *)key, &v6->m_key) )
  {
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  *value = v6->m_data;
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdMail *,bdHashingClass>::get(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const bdString *key, bdMail **value)
{
  bdMail **Iterator; 

  Iterator = (bdMail **)bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::get(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const bdString *key, bdMarketingComms **value)
{
  bdMarketingComms **Iterator; 

  Iterator = (bdMarketingComms **)bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdMarketplace *,bdHashingClass>::get(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const bdString *key, bdMarketplace **value)
{
  bdMarketplace **Iterator; 

  Iterator = (bdMarketplace **)bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::get
==============
*/
char bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::get(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const bdString *key, bdMatchMaking **value)
{
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v6; 

  if ( !this->m_size )
    return 0;
  v6 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v6 )
    return 0;
  while ( !bdString::operator==((bdString *)key, &v6->m_key) )
  {
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  *value = v6->m_data;
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMatchMaking *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::get(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const bdString *key, bdPublisherVariables **value)
{
  bdPublisherVariables **Iterator; 

  Iterator = (bdPublisherVariables **)bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::get(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const bdString *key, bdRedeemableCodeService **value)
{
  bdRedeemableCodeService **Iterator; 

  Iterator = (bdRedeemableCodeService **)bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdReward *,bdHashingClass>::get(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const bdString *key, bdReward **value)
{
  bdReward **Iterator; 

  Iterator = (bdReward **)bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::get(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const bdString *key, bdRichPresenceService **value)
{
  bdRichPresenceService **Iterator; 

  Iterator = (bdRichPresenceService **)bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdStorage *,bdHashingClass>::get(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const bdString *key, bdStorage **value)
{
  bdStorage **Iterator; 

  Iterator = (bdStorage **)bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::get(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const bdString *key, bdTeamShowcase **value)
{
  bdTeamShowcase **Iterator; 

  Iterator = (bdTeamShowcase **)bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::get
==============
*/
bool bdHashMap<bdString,bdTeams *,bdHashingClass>::get(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const bdString *key, bdTeams **value)
{
  bdTeams **Iterator; 

  Iterator = (bdTeams **)bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    *value = *Iterator;
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(Iterator) = 1;
  }
  return (char)Iterator;
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getIterator(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMail *,bdHashingClass>::Node *bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMail *,bdHashingClass>::Node *bdHashMap<bdString,bdMail *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMail *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getIterator(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getIterator(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdReward *,bdHashingClass>::Node *bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdReward *,bdHashingClass>::Node *bdHashMap<bdString,bdReward *,bdHashingClass>::getIterator(bdHashMap<bdString,bdReward *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdService *,bdHashingClass>::Node *bdHashMap<bdString,bdService *,bdHashingClass>::getIterator(bdHashMap<bdString,bdService *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *bdHashMap<bdString,bdStorage *,bdHashingClass>::getIterator(bdHashMap<bdString,bdStorage *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const bdString *key)
{
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdString::operator==((bdString *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *bdHashMap<bdString,bdTeams *,bdHashingClass>::getIterator(bdHashMap<bdString,bdTeams *,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMail *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMarketplace *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdPlayerVote *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdReward *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdStorage *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdString,bdTeams *,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdMail *,bdHashingClass>::next(bdHashMap<bdString,bdMail *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::next(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdMarketplace *,bdHashingClass>::next(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::next(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::next(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::next(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdReward *,bdHashingClass>::next(bdHashMap<bdString,bdReward *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::next(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdService *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdService *,bdHashingClass>::next(bdHashMap<bdString,bdService *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdService *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdStorage *,bdHashingClass>::next(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::next(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::next
==============
*/
void bdHashMap<bdString,bdTeams *,bdHashingClass>::next(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, void **iterator)
{
  const bdString *v4; 
  char *m_string; 
  unsigned int v6; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v9; 

  v4 = (const bdString *)*iterator;
  m_string = v4[2].m_string;
  if ( m_string )
  {
    *iterator = m_string;
  }
  else
  {
    v6 = bdHashingClass::getHash<bdString>(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (v6 & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::put(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key, bdDemonataPushMessageHandler *const *value)
{
  bdDemonataPushMessageHandler *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdMail *,bdHashingClass>::put(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const bdString *key, bdMail *const *value)
{
  bdMail *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdMail *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdMail *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdMail *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::put(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const bdString *key, bdMarketingComms *const *value)
{
  bdMarketingComms *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdMarketplace *,bdHashingClass>::put(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const bdString *key, bdMarketplace *const *value)
{
  bdMarketplace *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdMarketplace *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::put(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const bdString *key, bdMatchMaking *const *value)
{
  bdMatchMaking *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMatchMaking *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::put(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const bdString *key, bdPublisherVariables *const *value)
{
  bdPublisherVariables *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::put(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const bdString *key, bdRedeemableCodeService *const *value)
{
  bdRedeemableCodeService *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdReward *,bdHashingClass>::put(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const bdString *key, bdReward *const *value)
{
  bdReward *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdReward *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdReward *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdReward *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::put(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const bdString *key, bdRichPresenceService *const *value)
{
  bdRichPresenceService *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdStorage *,bdHashingClass>::put(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const bdString *key, bdStorage *const *value)
{
  bdStorage *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdStorage *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::put(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const bdString *key, bdTeamShowcase *const *value)
{
  bdTeamShowcase *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::put
==============
*/
char bdHashMap<bdString,bdTeams *,bdHashingClass>::put(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const bdString *key, bdTeams *const *value)
{
  bdTeams *const *v4; 
  unsigned int v7; 
  __int64 v8; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **m_map; 
  const bdString *m_string; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **v19; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v22; 
  bdString *v23; 
  bdString *v24; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v25; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key);
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  m_string = (const bdString *)m_map[v8];
  if ( m_string )
  {
    while ( !bdString::operator==((bdString *)key, m_string + 1) )
    {
      m_string = (const bdString *)m_string[2].m_string;
      if ( !m_string )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdString,bdTeams *,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = (bdString *)v22;
              v22 = v22->m_next;
              bdString::~bdString(v23 + 1);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdString *)bdMemory::allocate(0x18ui64);
    v25 = (bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      v24->m_string = *(char **)v4;
      bdString::bdString(v24 + 1, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdMail *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMail *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMail *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketingComms *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdMarketplace *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMarketplace *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdMatchMaking *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdPublisherVariables *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRedeemableCodeService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdReward *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdReward *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdReward *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdRichPresenceService *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdStorage *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdStorage *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeamShowcase *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdString,bdTeams *,bdHashingClass>::releaseIterator(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdTeams *,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::remove
==============
*/
char bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::remove(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const bdString *key)
{
  __int64 v4; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v5; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v6; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdString,class bdDemonataPushMessageHandler *,class bdHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  v4 = bdHashingClass::getHash<bdString>(&this->m_hashClass, key) & (this->m_capacity - 1);
  v5 = this->m_map[v4];
  v6 = NULL;
  if ( !v5 )
    return 0;
  while ( !bdString::operator==((bdString *)key, &v5->m_key) )
  {
    v6 = v5;
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  m_next = v5->m_next;
  if ( v6 )
    v6->m_next = m_next;
  else
    this->m_map[v4] = m_next;
  bdString::~bdString((bdString *)&v5->m_key);
  bdMemory::deallocate(v5);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::resize(bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdDemonataPushMessageHandler *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdMail *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdMail *,bdHashingClass>::resize(bdHashMap<bdString,bdMail *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdMail *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdMail *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdMail *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::resize(bdHashMap<bdString,bdMarketingComms *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdMarketingComms *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdMarketplace *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdMarketplace *,bdHashingClass>::resize(bdHashMap<bdString,bdMarketplace *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdMarketplace *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdMarketplace *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::resize(bdHashMap<bdString,bdMatchMaking *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdMatchMaking *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::resize(bdHashMap<bdString,bdPublisherVariables *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdPublisherVariables *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::resize(bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdRedeemableCodeService *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdReward *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdReward *,bdHashingClass>::resize(bdHashMap<bdString,bdReward *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdReward *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdReward *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdReward *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::resize(bdHashMap<bdString,bdRichPresenceService *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdRichPresenceService *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdStorage *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdStorage *,bdHashingClass>::resize(bdHashMap<bdString,bdStorage *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdStorage *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdStorage *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdStorage *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::resize(bdHashMap<bdString,bdTeamShowcase *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdTeamShowcase *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdString,bdTeams *,bdHashingClass>::resize
==============
*/
void bdHashMap<bdString,bdTeams *,bdHashingClass>::resize(bdHashMap<bdString,bdTeams *,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **v11; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdString,bdTeams *,bdHashingClass>::Node *v14; 
  bdString *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdString,bdTeams *,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdString,bdTeams *,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdString *)v14;
          v14 = v14->m_next;
          bdString::~bdString(v15 + 1);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  this->m_numIterators.m_value._My_val = 0;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  memset_0(v14, 0, v15);
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::~bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::~bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this)
{
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::clear
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::clear(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **m_map; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v5; 
  bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *p_m_data; 
  bdQoSProbe::bdQoSProbeEntryWrapper *m_data; 
  bdQoSProbe::bdQoSProbeEntryWrapper *v8; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        p_m_data = &v5->m_data;
        v5 = v5->m_next;
        m_data = p_m_data[1].m_data;
        if ( m_data && _InterlockedExchangeAdd((volatile signed __int32 *)&m_data->m_id, 0xFFFFFFFF) == 1 )
        {
          v8 = p_m_data[1].m_data;
          if ( v8 )
            ((void (__fastcall *)(bdQoSProbe::bdQoSProbeEntryWrapper *, __int64))v8->m_addr.m_ptr->__vftable)(v8, 1i64);
          p_m_data[1].m_data = NULL;
        }
        bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>(p_m_data);
        bdMemory::deallocate(p_m_data);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::containsKey
==============
*/
bool bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::containsKey(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key)
{
  bdCommonAddr *m_ptr; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v4; 

  if ( !this->m_size )
    return 0;
  m_ptr = key->m_ptr;
  v4 = this->m_map[m_ptr->m_hash & (this->m_capacity - 1)];
  if ( !v4 )
    return 0;
  while ( m_ptr != v4->m_key.m_ptr )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return v4 != NULL;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::createMap
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::createMap(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::get
==============
*/
char bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::get(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key, bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *value)
{
  bdCommonAddr *m_ptr; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v5; 

  if ( !this->m_size )
    return 0;
  m_ptr = key->m_ptr;
  v5 = this->m_map[key->m_ptr->m_hash & (this->m_capacity - 1)];
  if ( !v5 )
    return 0;
  while ( m_ptr != v5->m_key.m_ptr )
  {
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::operator=(value, &v5->m_data);
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator
==============
*/
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key)
{
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *result; 

  if ( !this->m_size )
    return 0i64;
  result = this->m_map[key->m_ptr->m_hash & (this->m_capacity - 1)];
  if ( !result )
    return 0i64;
  while ( key->m_ptr != result->m_key.m_ptr )
  {
    result = result->m_next;
    if ( !result )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return result;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator
==============
*/
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getIterator(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::next
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::next(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, void **iterator)
{
  void *v3; 
  unsigned int m_capacity; 
  __int64 v5; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v6; 

  v3 = (void *)*((_QWORD *)*iterator + 3);
  if ( v3 )
  {
    *iterator = v3;
  }
  else
  {
    m_capacity = this->m_capacity;
    v5 = ((m_capacity - 1) & *(_DWORD *)(*((_QWORD *)*iterator + 2) + 940i64)) + 1;
    if ( (unsigned int)v5 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v6 = this->m_map[v5];
        if ( v6 )
          break;
        v5 = (unsigned int)(v5 + 1);
        if ( (unsigned int)v5 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v6;
    }
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::put
==============
*/
char bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::put(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key, const bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *value)
{
  bdCommonAddr *m_ptr; 
  unsigned int m_hash; 
  __int64 m_capacity; 
  __int64 v10; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **m_map; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v12; 
  unsigned int m_size; 
  bdQoSProbe::bdQoSProbeEntryWrapper *v14; 
  unsigned int PowerOf2; 
  unsigned int v16; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v21; 
  __int64 v22; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v23; 
  bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *p_m_data; 
  bdQoSProbe::bdQoSProbeEntryWrapper *m_data; 
  bdQoSProbe::bdQoSProbeEntryWrapper *v26; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v27; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v28; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v29; 
  __int64 v30; 
  bdCommonAddr *v31; 
  unsigned int v33; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v35; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  m_ptr = key->m_ptr;
  m_hash = key->m_ptr->m_hash;
  v33 = m_hash;
  m_capacity = this->m_capacity;
  v10 = m_hash & ((_DWORD)m_capacity - 1);
  m_map = this->m_map;
  v35 = m_map;
  v12 = m_map[v10];
  if ( v12 )
  {
    while ( m_ptr != v12->m_key.m_ptr )
    {
      v12 = v12->m_next;
      if ( !v12 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    v14 = NULL;
    if ( this->m_size + 1 > this->m_threshold )
    {
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v16 = this->m_capacity;
      if ( PowerOf2 > v16 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v21 = (bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v21;
        this->m_size = 0;
        memset_0(v21, 0, 8i64 * this->m_capacity);
        if ( (_DWORD)m_capacity )
        {
          v22 = m_capacity;
          do
          {
            v23 = *m_map;
            while ( v23 )
            {
              bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::put(this, &v23->m_key, &v23->m_data);
              p_m_data = &v23->m_data;
              v23 = v23->m_next;
              m_data = p_m_data[1].m_data;
              if ( m_data && _InterlockedExchangeAdd((volatile signed __int32 *)&m_data->m_id, 0xFFFFFFFF) == 1 )
              {
                v26 = p_m_data[1].m_data;
                if ( v26 )
                  ((void (__fastcall *)(bdQoSProbe::bdQoSProbeEntryWrapper *, __int64))v26->m_addr.m_ptr->__vftable)(v26, 1i64);
                p_m_data[1].m_data = NULL;
              }
              bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>(p_m_data);
              bdMemory::deallocate(p_m_data);
            }
            ++m_map;
            --v22;
          }
          while ( v22 );
          m_map = v35;
          m_hash = v33;
        }
        bdMemory::deallocate(m_map);
        v16 = this->m_capacity;
      }
      v10 = m_hash & (v16 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v27 = (bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *)bdMemory::allocate(0x20ui64);
    v28 = v27;
    if ( v27 )
    {
      v29 = this->m_map[v10];
      v27->m_data.m_capacity = value->m_capacity;
      v27->m_data.m_size = value->m_size;
      v30 = value->m_capacity;
      if ( (_DWORD)v30 )
      {
        v14 = (bdQoSProbe::bdQoSProbeEntryWrapper *)bdMemory::allocate(640 * v30);
        bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray(&v28->m_data, v14, value->m_data, value->m_size);
      }
      v28->m_data.m_data = v14;
      v31 = key->m_ptr;
      v28->m_key.m_ptr = key->m_ptr;
      if ( v31 )
        _InterlockedExchangeAdd((volatile signed __int32 *)&v31->m_refCount, 1u);
      v28->m_next = v29;
    }
    else
    {
      v28 = NULL;
    }
    this->m_map[v10] = v28;
    return 1;
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::releaseIterator
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::releaseIterator(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove
==============
*/
char bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, void **iterator)
{
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v4; 
  unsigned int m_capacity; 
  __int64 v6; 
  _QWORD *v7; 
  bdCommonAddr *v8; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v9; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v10; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v11; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *m_next; 
  bdCommonAddr *m_ptr; 
  bdCommonAddr *v15; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 1, "(m_numIterators == 1)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::remove", 0xF9u, "bdHashMap::remove, more than one iterator held while removing from hashmap", -2i64);
  v4 = (bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *)*((_QWORD *)*iterator + 3);
  if ( !v4 )
  {
    m_capacity = this->m_capacity;
    v6 = (*(_DWORD *)(*((_QWORD *)*iterator + 2) + 940i64) & (m_capacity - 1)) + 1;
    if ( (unsigned int)v6 >= m_capacity )
    {
LABEL_5:
      v4 = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v4 = this->m_map[v6];
        if ( v4 )
          break;
        v6 = (unsigned int)(v6 + 1);
        if ( (unsigned int)v6 >= m_capacity )
          goto LABEL_5;
      }
    }
  }
  v7 = *iterator;
  *iterator = v4;
  v8 = (bdCommonAddr *)v7[2];
  v9 = &this->m_map[v8->m_hash & (this->m_capacity - 1)];
  v10 = *v9;
  v11 = NULL;
  if ( !*v9 )
    return 0;
  while ( v8 != v10->m_key.m_ptr )
  {
    v11 = v10;
    v10 = v10->m_next;
    if ( !v10 )
      return 0;
  }
  m_next = v10->m_next;
  if ( v11 )
    v11->m_next = m_next;
  else
    *v9 = m_next;
  m_ptr = v10->m_key.m_ptr;
  if ( m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
  {
    v15 = v10->m_key.m_ptr;
    if ( v15 )
      ((void (__fastcall *)(bdCommonAddr *, __int64))v15->~bdReferencable)(v15, 1i64);
    v10->m_key.m_ptr = NULL;
  }
  bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>(&v10->m_data);
  bdMemory::deallocate(v10);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove
==============
*/
char bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::remove(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const bdReference<bdCommonAddr> *key)
{
  bdCommonAddr *m_ptr; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v5; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v6; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v7; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *m_next; 
  bdCommonAddr *v10; 
  bdCommonAddr *v11; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>,class bdCommonAddrHash>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  m_ptr = key->m_ptr;
  v5 = &this->m_map[key->m_ptr->m_hash & (this->m_capacity - 1)];
  v6 = *v5;
  v7 = NULL;
  if ( !*v5 )
    return 0;
  while ( m_ptr != v6->m_key.m_ptr )
  {
    v7 = v6;
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  m_next = v6->m_next;
  if ( v7 )
    v7->m_next = m_next;
  else
    *v5 = m_next;
  v10 = v6->m_key.m_ptr;
  if ( v10 && !_InterlockedDecrement((volatile signed __int32 *)&v10->m_refCount) )
  {
    v11 = v6->m_key.m_ptr;
    if ( v11 )
      ((void (__fastcall *)(bdCommonAddr *, __int64))v11->~bdReferencable)(v11, 1i64);
    v6->m_key.m_ptr = NULL;
  }
  bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>(&v6->m_data);
  bdMemory::deallocate(v6);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::resize
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::resize(bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash> *this, const unsigned int newSize)
{
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v11; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node *v14; 
  bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *p_m_data; 
  bdQoSProbe::bdQoSProbeEntryWrapper *m_data; 
  bdQoSProbe::bdQoSProbeEntryWrapper *v17; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdReference<bdCommonAddr>,bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>,bdCommonAddrHash>::put(this, &v14->m_key, &v14->m_data);
          p_m_data = &v14->m_data;
          v14 = v14->m_next;
          m_data = p_m_data[1].m_data;
          if ( m_data && _InterlockedExchangeAdd((volatile signed __int32 *)&m_data->m_id, 0xFFFFFFFF) == 1 )
          {
            v17 = p_m_data[1].m_data;
            if ( v17 )
              ((void (__fastcall *)(bdQoSProbe::bdQoSProbeEntryWrapper *, __int64))v17->m_addr.m_ptr->__vftable)(v17, 1i64);
            p_m_data[1].m_data = NULL;
          }
          bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>(p_m_data);
          bdMemory::deallocate(p_m_data);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::~bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::~bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this)
{
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this)
{
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::~bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this)
{
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::clear
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::clear(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **m_map; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v5; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v6; 
  bdCommonAddr *m_ptr; 
  bdCommonAddr *v8; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdReference<class bdDTLSAssociation>,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        m_ptr = v6->m_key.m_ptr;
        if ( m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          v8 = v6->m_key.m_ptr;
          if ( v8 )
            ((void (__fastcall *)(bdCommonAddr *, __int64))v8->~bdReferencable)(v8, 1i64);
          v6->m_key.m_ptr = NULL;
        }
        if ( v6->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          if ( v6->m_data.m_ptr )
            ((void (__fastcall *)(bdDTLSAssociation *, __int64))v6->m_data.m_ptr->~bdReferencable)(v6->m_data.m_ptr, 1i64);
          v6->m_data.m_ptr = NULL;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::clear
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::clear(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **m_map; 
  bdSecurityID *v5; 
  bdSecurityID *v6; 
  bdSecurityID v7; 
  void (__fastcall ***v8)(_QWORD, __int64); 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdAddrHandle>,class bdEndpointHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = (bdSecurityID *)m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = (bdSecurityID *)v5[3];
        bdSecurityID::~bdSecurityID(v6 + 2);
        v7 = v6[1];
        if ( *(_QWORD *)&v7 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)&v7 + 8i64), 0xFFFFFFFF) == 1 )
        {
          v8 = (void (__fastcall ***)(_QWORD, __int64))v6[1];
          if ( v8 )
            (**v8)(v8, 1i64);
          v6[1] = 0i64;
        }
        if ( *(_QWORD *)v6 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)v6 + 8i64), 0xFFFFFFFF) == 1 )
        {
          if ( *v6 )
            (***(void (__fastcall ****)(bdSecurityID, __int64))v6)(*v6, 1i64);
          *v6 = 0i64;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::clear
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::clear(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **m_map; 
  bdSecurityID *v5; 
  bdSecurityID *v6; 
  bdSecurityID v7; 
  void (__fastcall ***v8)(_QWORD, __int64); 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdDTLSAssociation>,class bdEndpointHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = (bdSecurityID *)m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = (bdSecurityID *)v5[3];
        bdSecurityID::~bdSecurityID(v6 + 2);
        v7 = v6[1];
        if ( *(_QWORD *)&v7 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)&v7 + 8i64), 0xFFFFFFFF) == 1 )
        {
          v8 = (void (__fastcall ***)(_QWORD, __int64))v6[1];
          if ( v8 )
            (**v8)(v8, 1i64);
          v6[1] = 0i64;
        }
        if ( *(_QWORD *)v6 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)v6 + 8i64), 0xFFFFFFFF) == 1 )
        {
          if ( *v6 )
            (***(void (__fastcall ****)(bdSecurityID, __int64))v6)(*v6, 1i64);
          *v6 = 0i64;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::clear
==============
*/
void bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::clear(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **m_map; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v5; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdSecurityID,class bdSecurityKey,class bdHashingClass>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        bdSecurityID::~bdSecurityID((bdSecurityID *)&v6->m_key);
        bdSecurityKey::~bdSecurityKey(&v6->m_data);
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::createMap(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdReference<class bdDTLSAssociation>,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::createMap(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdAddrHandle>,class bdEndpointHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::createMap(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdDTLSAssociation>,class bdEndpointHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::get
==============
*/
char bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::get(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key, bdReference<bdDTLSAssociation> *value)
{
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v5; 

  if ( !this->m_size )
    return 0;
  v5 = this->m_map[((16777619 * (BYTE6(key->m_ptr) ^ (16777619 * (BYTE5(key->m_ptr) ^ (16777619 * (BYTE4(key->m_ptr) ^ (16777619 * (BYTE3(key->m_ptr) ^ (16777619 * (BYTE2(key->m_ptr) ^ (16777619 * (BYTE1(key->m_ptr) ^ (16777619 * LOBYTE(key->m_ptr)))))))))))))) ^ HIBYTE(key->m_ptr)) & (this->m_capacity - 1)];
  if ( !v5 )
    return 0;
  while ( key->m_ptr != v5->m_key.m_ptr )
  {
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  bdReference<bdDTLSAssociation>::operator=(value, &v5->m_data);
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdReference<class bdDTLSAssociation>,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::get
==============
*/
char bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::get(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key, bdReference<bdDTLSAssociation> *value)
{
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v6; 

  if ( !this->m_size )
    return 0;
  v6 = this->m_map[bdEndpointHashingClass::getHash(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v6 )
    return 0;
  while ( !bdEndpoint::operator==((bdEndpoint *)key, &v6->m_key) )
  {
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  bdReference<bdDTLSAssociation>::operator=(value, &v6->m_data);
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdDTLSAssociation>,class bdEndpointHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getIterator(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key)
{
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *result; 

  if ( !this->m_size )
    return 0i64;
  result = this->m_map[((16777619 * (BYTE6(key->m_ptr) ^ (16777619 * (BYTE5(key->m_ptr) ^ (16777619 * (BYTE4(key->m_ptr) ^ (16777619 * (BYTE3(key->m_ptr) ^ (16777619 * (BYTE2(key->m_ptr) ^ (16777619 * (BYTE1(key->m_ptr) ^ (16777619 * LOBYTE(key->m_ptr)))))))))))))) ^ HIBYTE(key->m_ptr)) & (this->m_capacity - 1)];
  if ( !result )
    return 0i64;
  while ( key->m_ptr != result->m_key.m_ptr )
  {
    result = result->m_next;
    if ( !result )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return result;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getIterator
==============
*/
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getIterator(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator
==============
*/
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key)
{
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdEndpointHashingClass::getHash(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdEndpoint::operator==((bdEndpoint *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator
==============
*/
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getIterator(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::next
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::next(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, void **iterator)
{
  char *v4; 
  void *v5; 
  unsigned int Hash; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v9; 

  v4 = (char *)*iterator;
  v5 = (void *)*((_QWORD *)v4 + 3);
  if ( v5 )
  {
    *iterator = v5;
  }
  else
  {
    Hash = bdEndpointHashingClass::getHash(&this->m_hashClass, (const bdEndpoint *)(v4 + 8));
    m_capacity = this->m_capacity;
    v8 = (Hash & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::next
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::next(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, void **iterator)
{
  char *v4; 
  void *v5; 
  unsigned int Hash; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v9; 

  v4 = (char *)*iterator;
  v5 = (void *)*((_QWORD *)v4 + 3);
  if ( v5 )
  {
    *iterator = v5;
  }
  else
  {
    Hash = bdEndpointHashingClass::getHash(&this->m_hashClass, (const bdEndpoint *)(v4 + 8));
    m_capacity = this->m_capacity;
    v8 = (Hash & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::put
==============
*/
char bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::put(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key, const bdReference<bdDTLSAssociation> *value)
{
  unsigned int m_capacity; 
  int v7; 
  __int64 v8; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v9; 
  unsigned int m_size; 
  bdReference<bdDTLSAssociation> *v11; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v12; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v13; 
  bdDTLSAssociation *m_ptr; 
  bdCommonAddr *v15; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdReference<class bdDTLSAssociation>,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap");
  m_capacity = this->m_capacity;
  v7 = HIBYTE(key->m_ptr) ^ (16777619 * (BYTE6(key->m_ptr) ^ (16777619 * (BYTE5(key->m_ptr) ^ (16777619 * (BYTE4(key->m_ptr) ^ (16777619 * (BYTE3(key->m_ptr) ^ (16777619 * (BYTE2(key->m_ptr) ^ (16777619 * (BYTE1(key->m_ptr) ^ (16777619 * LOBYTE(key->m_ptr))))))))))))));
  v8 = v7 & (m_capacity - 1);
  v9 = this->m_map[v8];
  if ( v9 )
  {
    while ( key->m_ptr != v9->m_key.m_ptr )
    {
      v9 = v9->m_next;
      if ( !v9 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::resize(this, 2 * m_capacity);
      m_size = this->m_size;
      v8 = v7 & (this->m_capacity - 1);
    }
    this->m_size = m_size + 1;
    v11 = (bdReference<bdDTLSAssociation> *)bdMemory::allocate(0x18ui64);
    v12 = (bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *)v11;
    if ( v11 )
    {
      v13 = this->m_map[v8];
      m_ptr = value->m_ptr;
      v11->m_ptr = value->m_ptr;
      if ( m_ptr )
        _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
      v15 = key->m_ptr;
      v12->m_key.m_ptr = key->m_ptr;
      if ( v15 )
        _InterlockedExchangeAdd((volatile signed __int32 *)&v15->m_refCount, 1u);
      v12->m_next = v13;
    }
    else
    {
      v12 = NULL;
    }
    this->m_map[v8] = v12;
    return 1;
  }
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::put
==============
*/
char bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::put(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const bdEndpoint *key, const bdReference<bdAddrHandle> *value)
{
  unsigned int Hash; 
  __int64 v7; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v8; 
  unsigned int m_size; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v10; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v11; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v12; 
  bdAddrHandle *m_ptr; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdAddrHandle>,class bdEndpointHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  Hash = bdEndpointHashingClass::getHash(&this->m_hashClass, key);
  v7 = Hash & (this->m_capacity - 1);
  v8 = this->m_map[v7];
  if ( v8 )
  {
    while ( !bdEndpoint::operator==((bdEndpoint *)key, &v8->m_key) )
    {
      v8 = v8->m_next;
      if ( !v8 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::resize(this, 2 * this->m_capacity);
      v7 = Hash & (this->m_capacity - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v10 = (bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *)bdMemory::allocate(0x20ui64);
    v11 = v10;
    if ( v10 )
    {
      v12 = this->m_map[v7];
      m_ptr = value->m_ptr;
      v10->m_data = (bdReference<bdAddrHandle>)value->m_ptr;
      if ( m_ptr )
        _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
      bdEndpoint::bdEndpoint((bdEndpoint *)&v10->m_key, key);
      v11->m_next = v12;
    }
    else
    {
      v11 = NULL;
    }
    this->m_map[v7] = v11;
    return 1;
  }
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::put
==============
*/
char bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::put(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key, const bdReference<bdDTLSAssociation> *value)
{
  unsigned int Hash; 
  __int64 v7; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v8; 
  unsigned int m_size; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v10; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v11; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v12; 
  bdDTLSAssociation *m_ptr; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdDTLSAssociation>,class bdEndpointHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  Hash = bdEndpointHashingClass::getHash(&this->m_hashClass, key);
  v7 = Hash & (this->m_capacity - 1);
  v8 = this->m_map[v7];
  if ( v8 )
  {
    while ( !bdEndpoint::operator==((bdEndpoint *)key, &v8->m_key) )
    {
      v8 = v8->m_next;
      if ( !v8 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::resize(this, 2 * this->m_capacity);
      v7 = Hash & (this->m_capacity - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v10 = (bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *)bdMemory::allocate(0x20ui64);
    v11 = v10;
    if ( v10 )
    {
      v12 = this->m_map[v7];
      m_ptr = value->m_ptr;
      v10->m_data = (bdReference<bdDTLSAssociation>)value->m_ptr;
      if ( m_ptr )
        _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
      bdEndpoint::bdEndpoint((bdEndpoint *)&v10->m_key, key);
      v11->m_next = v12;
    }
    else
    {
      v11 = NULL;
    }
    this->m_map[v7] = v11;
    return 1;
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::releaseIterator(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdReference<class bdDTLSAssociation>,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::releaseIterator(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdDTLSAssociation>,class bdEndpointHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::remove
==============
*/
char bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::remove(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const bdReference<bdCommonAddr> *key)
{
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **m_map; 
  unsigned __int64 v5; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v6; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **v7; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v8; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdReference<class bdCommonAddr>,class bdReference<class bdDTLSAssociation>,class bdHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap");
  m_map = this->m_map;
  v5 = (this->m_capacity - 1) & (HIBYTE(key->m_ptr) ^ (unsigned __int64)(16777619 * (BYTE6(key->m_ptr) ^ (16777619 * (BYTE5(key->m_ptr) ^ (16777619 * (BYTE4(key->m_ptr) ^ (16777619 * (BYTE3(key->m_ptr) ^ (16777619 * (BYTE2(key->m_ptr) ^ (16777619 * (BYTE1(key->m_ptr) ^ (16777619 * (unsigned int)LOBYTE(key->m_ptr)))))))))))))));
  v6 = m_map[v5];
  v7 = &m_map[v5];
  v8 = NULL;
  if ( !v6 )
    return 0;
  while ( 1 )
  {
    m_next = v6->m_next;
    if ( key->m_ptr == v6->m_key.m_ptr )
      break;
    v8 = v6;
    v6 = v6->m_next;
    if ( !m_next )
      return 0;
  }
  if ( v8 )
    v8->m_next = m_next;
  else
    *v7 = m_next;
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node::`scalar deleting destructor'(v6, 1u);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove
==============
*/
char bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, void **iterator)
{
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v4; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v5; 
  unsigned int Hash; 
  unsigned int m_capacity; 
  __int64 v8; 
  char *v9; 
  __int64 v10; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v11; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 1, "(m_numIterators == 1)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdAddrHandle>,class bdEndpointHashingClass>::remove", 0xF9u, "bdHashMap::remove, more than one iterator held while removing from hashmap");
  v4 = NULL;
  v5 = (bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *)*((_QWORD *)*iterator + 3);
  if ( !v5 )
  {
    Hash = bdEndpointHashingClass::getHash(&this->m_hashClass, (const bdEndpoint *)((char *)*iterator + 8));
    m_capacity = this->m_capacity;
    v8 = (Hash & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_5:
      v5 = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v5 = this->m_map[v8];
        if ( v5 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_5;
      }
    }
  }
  v9 = (char *)*iterator;
  *iterator = v5;
  v10 = bdEndpointHashingClass::getHash(&this->m_hashClass, (const bdEndpoint *)(v9 + 8)) & (this->m_capacity - 1);
  v11 = this->m_map[v10];
  if ( !v11 )
    return 0;
  while ( !bdEndpoint::operator==((bdEndpoint *)(v9 + 8), &v11->m_key) )
  {
    v4 = v11;
    v11 = v11->m_next;
    if ( !v11 )
      return 0;
  }
  m_next = v11->m_next;
  if ( v4 )
    v4->m_next = m_next;
  else
    this->m_map[v10] = m_next;
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node::`scalar deleting destructor'(v11, 1u);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove
==============
*/
char bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const bdEndpoint *key)
{
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v4; 
  __int64 v5; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v6; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdAddrHandle>,class bdEndpointHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap");
  v4 = NULL;
  v5 = bdEndpointHashingClass::getHash(&this->m_hashClass, key) & (this->m_capacity - 1);
  v6 = this->m_map[v5];
  if ( !v6 )
    return 0;
  while ( !bdEndpoint::operator==((bdEndpoint *)key, &v6->m_key) )
  {
    v4 = v6;
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  m_next = v6->m_next;
  if ( v4 )
    v4->m_next = m_next;
  else
    this->m_map[v5] = m_next;
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node::`scalar deleting destructor'(v6, 1u);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove
==============
*/
char bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, void **iterator)
{
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v4; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v5; 
  unsigned int Hash; 
  unsigned int m_capacity; 
  __int64 v8; 
  char *v9; 
  __int64 v10; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v11; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 1, "(m_numIterators == 1)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdDTLSAssociation>,class bdEndpointHashingClass>::remove", 0xF9u, "bdHashMap::remove, more than one iterator held while removing from hashmap");
  v4 = NULL;
  v5 = (bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *)*((_QWORD *)*iterator + 3);
  if ( !v5 )
  {
    Hash = bdEndpointHashingClass::getHash(&this->m_hashClass, (const bdEndpoint *)((char *)*iterator + 8));
    m_capacity = this->m_capacity;
    v8 = (Hash & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_5:
      v5 = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v5 = this->m_map[v8];
        if ( v5 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_5;
      }
    }
  }
  v9 = (char *)*iterator;
  *iterator = v5;
  v10 = bdEndpointHashingClass::getHash(&this->m_hashClass, (const bdEndpoint *)(v9 + 8)) & (this->m_capacity - 1);
  v11 = this->m_map[v10];
  if ( !v11 )
    return 0;
  while ( !bdEndpoint::operator==((bdEndpoint *)(v9 + 8), &v11->m_key) )
  {
    v4 = v11;
    v11 = v11->m_next;
    if ( !v11 )
      return 0;
  }
  m_next = v11->m_next;
  if ( v4 )
    v4->m_next = m_next;
  else
    this->m_map[v10] = m_next;
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node::`scalar deleting destructor'(v11, 1u);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove
==============
*/
char bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::remove(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const bdEndpoint *key)
{
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v4; 
  __int64 v5; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v6; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdEndpoint,class bdReference<class bdDTLSAssociation>,class bdEndpointHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap");
  v4 = NULL;
  v5 = bdEndpointHashingClass::getHash(&this->m_hashClass, key) & (this->m_capacity - 1);
  v6 = this->m_map[v5];
  if ( !v6 )
    return 0;
  while ( !bdEndpoint::operator==((bdEndpoint *)key, &v6->m_key) )
  {
    v4 = v6;
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  m_next = v6->m_next;
  if ( v4 )
    v4->m_next = m_next;
  else
    this->m_map[v5] = m_next;
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node::`scalar deleting destructor'(v6, 1u);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::resize
==============
*/
void bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::resize(bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **v11; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v14; 
  bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node *v15; 
  bdCommonAddr *m_ptr; 
  bdCommonAddr *v17; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdReference<bdCommonAddr>,bdReference<bdDTLSAssociation>,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = v14;
          v14 = v14->m_next;
          m_ptr = v15->m_key.m_ptr;
          if ( m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
          {
            v17 = v15->m_key.m_ptr;
            if ( v17 )
              ((void (__fastcall *)(bdCommonAddr *, __int64))v17->~bdReferencable)(v17, 1i64);
            v15->m_key.m_ptr = NULL;
          }
          if ( v15->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v15->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
          {
            if ( v15->m_data.m_ptr )
              ((void (__fastcall *)(bdDTLSAssociation *, __int64))v15->m_data.m_ptr->~bdReferencable)(v15->m_data.m_ptr, 1i64);
            v15->m_data.m_ptr = NULL;
          }
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::resize
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::resize(bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **v11; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node *v14; 
  bdSecurityID *v15; 
  bdSecurityID v16; 
  void (__fastcall ***v17)(_QWORD, __int64); 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdEndpoint,bdReference<bdAddrHandle>,bdEndpointHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdSecurityID *)v14;
          v14 = v14->m_next;
          bdSecurityID::~bdSecurityID(v15 + 2);
          v16 = v15[1];
          if ( *(_QWORD *)&v16 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)&v16 + 8i64), 0xFFFFFFFF) == 1 )
          {
            v17 = (void (__fastcall ***)(_QWORD, __int64))v15[1];
            if ( v17 )
              (**v17)(v17, 1i64);
            v15[1] = 0i64;
          }
          if ( *(_QWORD *)v15 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)v15 + 8i64), 0xFFFFFFFF) == 1 )
          {
            if ( *v15 )
              (***(void (__fastcall ****)(bdSecurityID, __int64))v15)(*v15, 1i64);
            *v15 = 0i64;
          }
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::resize
==============
*/
void bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::resize(bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **v11; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node *v14; 
  bdSecurityID *v15; 
  bdSecurityID v16; 
  void (__fastcall ***v17)(_QWORD, __int64); 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdEndpoint,bdReference<bdDTLSAssociation>,bdEndpointHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = (bdSecurityID *)v14;
          v14 = v14->m_next;
          bdSecurityID::~bdSecurityID(v15 + 2);
          v16 = v15[1];
          if ( *(_QWORD *)&v16 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)&v16 + 8i64), 0xFFFFFFFF) == 1 )
          {
            v17 = (void (__fastcall ***)(_QWORD, __int64))v15[1];
            if ( v17 )
              (**v17)(v17, 1i64);
            v15[1] = 0i64;
          }
          if ( *(_QWORD *)v15 && _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)v15 + 8i64), 0xFFFFFFFF) == 1 )
          {
            if ( *v15 )
              (***(void (__fastcall ****)(bdSecurityID, __int64))v15)(*v15, 1i64);
            *v15 = 0i64;
          }
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::~bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>
==============
*/
void bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::~bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this)
{
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::containsKey
==============
*/
bool bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::containsKey(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key)
{
  void *Iterator; 

  Iterator = bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator(this, key);
  if ( Iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdSecurityID,class bdSecurityKey,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
  return Iterator != NULL;
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::createMap
==============
*/

void __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::createMap(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdSecurityID,class bdSecurityKey,class bdHashingClass>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::get
==============
*/
bool bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::get(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key, bdSecurityKey *value)
{
  _RDI = value;
  _RAX = bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator(this, key);
  if ( _RAX )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rdi], xmm0
    }
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdSecurityID,class bdSecurityKey,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    LOBYTE(_RAX) = 1;
  }
  return (char)_RAX;
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key)
{
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[((16777619 * (key->ab[6] ^ (16777619 * (key->ab[5] ^ (16777619 * (key->ab[4] ^ (16777619 * (key->ab[3] ^ (16777619 * (key->ab[2] ^ (16777619 * (key->ab[1] ^ (16777619 * key->ab[0]))))))))))))) ^ key->ab[7]) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdSecurityID::operator==((bdSecurityID *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator
==============
*/
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getIterator(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::next
==============
*/
void bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::next(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, void **iterator)
{
  unsigned __int8 *v2; 
  void *v4; 
  unsigned int m_capacity; 
  __int64 v6; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v7; 

  v4 = (void *)*((_QWORD *)*iterator + 3);
  if ( v4 )
  {
    *iterator = v4;
  }
  else
  {
    m_capacity = this->m_capacity;
    v2 = (unsigned __int8 *)*iterator;
    v6 = ((v2[23] ^ (16777619 * (v2[22] ^ (16777619 * (v2[21] ^ (16777619 * (v2[20] ^ (16777619 * (v2[19] ^ (16777619 * (v2[18] ^ (16777619 * (v2[17] ^ (16777619 * v2[16])))))))))))))) & (m_capacity - 1)) + 1;
    if ( (unsigned int)v6 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v7 = this->m_map[v6];
        if ( v7 )
          break;
        v6 = (unsigned int)(v6 + 1);
        if ( (unsigned int)v6 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v7;
    }
  }
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::put
==============
*/
char bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::put(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key, const bdSecurityKey *value)
{
  const bdSecurityKey *v4; 
  int v7; 
  __int64 v8; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **m_map; 
  const bdSecurityID *v10; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **v19; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v22; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v23; 
  bdSecurityKey *v24; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v25; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v26; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdSecurityID,class bdSecurityKey,class bdHashingClass>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  v7 = key->ab[7] ^ (16777619 * (key->ab[6] ^ (16777619 * (key->ab[5] ^ (16777619 * (key->ab[4] ^ (16777619 * (key->ab[3] ^ (16777619 * (key->ab[2] ^ (16777619 * (key->ab[1] ^ (16777619 * key->ab[0])))))))))))));
  v8 = v7 & (this->m_capacity - 1);
  m_map = this->m_map;
  v10 = (const bdSecurityID *)m_map[v8];
  if ( v10 )
  {
    while ( !bdSecurityID::operator==((bdSecurityID *)key, v10 + 2) )
    {
      v10 = (const bdSecurityID *)v10[3];
      if ( !v10 )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::put(this, &v22->m_key, &v22->m_data);
              v23 = v22;
              v22 = v22->m_next;
              bdSecurityID::~bdSecurityID((bdSecurityID *)&v23->m_key);
              bdSecurityKey::~bdSecurityKey(&v23->m_data);
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = v7 & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdSecurityKey *)bdMemory::allocate(0x20ui64);
    v25 = (bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *)v24;
    if ( v24 )
    {
      v26 = this->m_map[v8];
      bdSecurityKey::bdSecurityKey(v24, v4);
      bdSecurityID::bdSecurityID((bdSecurityID *)&v25->m_key, key);
      v25->m_next = v26;
    }
    else
    {
      v25 = NULL;
    }
    this->m_map[v8] = v25;
    return 1;
  }
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::releaseIterator
==============
*/
void bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::releaseIterator(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdSecurityID,class bdSecurityKey,class bdHashingClass>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::remove
==============
*/
char bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::remove(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const bdSecurityID *key)
{
  __int64 v4; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v5; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v6; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdSecurityID,class bdSecurityKey,class bdHashingClass>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  v4 = (key->ab[7] ^ (16777619 * (key->ab[6] ^ (16777619 * (key->ab[5] ^ (16777619 * (key->ab[4] ^ (16777619 * (key->ab[3] ^ (16777619 * (key->ab[2] ^ (16777619 * (key->ab[1] ^ (16777619 * key->ab[0])))))))))))))) & (this->m_capacity - 1);
  v5 = this->m_map[v4];
  v6 = NULL;
  if ( !v5 )
    return 0;
  while ( !bdSecurityID::operator==((bdSecurityID *)key, &v5->m_key) )
  {
    v6 = v5;
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  m_next = v5->m_next;
  if ( v6 )
    v6->m_next = m_next;
  else
    this->m_map[v4] = m_next;
  bdSecurityID::~bdSecurityID((bdSecurityID *)&v5->m_key);
  bdSecurityKey::~bdSecurityKey(&v5->m_data);
  bdMemory::deallocate(v5);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::resize
==============
*/
void bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::resize(bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass> *this, const unsigned int newSize)
{
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **v11; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v14; 
  bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdSecurityID,bdSecurityKey,bdHashingClass>::put(this, &v14->m_key, &v14->m_data);
          v15 = v14;
          v14 = v14->m_next;
          bdSecurityID::~bdSecurityID((bdSecurityID *)&v15->m_key);
          bdSecurityKey::~bdSecurityKey(&v15->m_data);
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::~bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>
==============
*/
void bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::~bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this)
{
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::clear(this);
  bdMemory::deallocate(this->m_map);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::clear
==============
*/
void bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::clear(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **m_map; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v5; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v6; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddr,class bdReference<class bdRelayAssociation>,class bdAddrHash>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        if ( v6->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          if ( v6->m_data.m_ptr )
            ((void (__fastcall *)(bdRelayAssociation *, __int64))v6->m_data.m_ptr->~bdReferencable)(v6->m_data.m_ptr, 1i64);
          v6->m_data.m_ptr = NULL;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::createMap
==============
*/

void __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::createMap(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddr,class bdReference<class bdRelayAssociation>,class bdAddrHash>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::get
==============
*/
char bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::get(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key, bdReference<bdRelayAssociation> *value)
{
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v6; 

  if ( !this->m_size )
    return 0;
  v6 = this->m_map[bdAddr::getHash((bdAddr *)key) & (this->m_capacity - 1)];
  if ( !v6 )
    return 0;
  while ( !bdSockAddr::compare(&key->m_address, &v6->m_key.m_address, 1) )
  {
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  bdReference<bdRelayAssociation>::operator=(value, &v6->m_data);
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddr,class bdReference<class bdRelayAssociation>,class bdAddrHash>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator
==============
*/
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key)
{
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdAddr::getHash((bdAddr *)key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdSockAddr::compare(&key->m_address, &v4->m_key.m_address, 1) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator
==============
*/
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getIterator(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::next
==============
*/
void bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::next(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, void **iterator)
{
  void *v4; 
  unsigned int Hash; 
  unsigned int m_capacity; 
  __int64 v7; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v8; 

  v4 = (void *)*((_QWORD *)*iterator + 20);
  if ( v4 )
  {
    *iterator = v4;
  }
  else
  {
    Hash = bdAddr::getHash((bdAddr *)((char *)*iterator + 8));
    m_capacity = this->m_capacity;
    v7 = (Hash & (m_capacity - 1)) + 1;
    if ( (unsigned int)v7 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v8 = this->m_map[v7];
        if ( v8 )
          break;
        v7 = (unsigned int)(v7 + 1);
        if ( (unsigned int)v7 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v8;
    }
  }
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::put
==============
*/
char bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::put(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key, const bdReference<bdRelayAssociation> *value)
{
  const bdReference<bdRelayAssociation> *v4; 
  unsigned int Hash; 
  __int64 v8; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **m_map; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v10; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  unsigned int v14; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **v19; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **v20; 
  __int64 v21; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v22; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v23; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v24; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v25; 
  bdRelayAssociation *m_ptr; 
  unsigned int v28; 

  v4 = value;
  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddr,class bdReference<class bdRelayAssociation>,class bdAddrHash>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap", -2i64);
  Hash = bdAddr::getHash((bdAddr *)key);
  v28 = Hash;
  v8 = Hash & (this->m_capacity - 1);
  m_map = this->m_map;
  v10 = m_map[v8];
  if ( v10 )
  {
    while ( !bdSockAddr::compare(&key->m_address, &v10->m_key.m_address, 1) )
    {
      v10 = v10->m_next;
      if ( !v10 )
      {
        m_map = this->m_map;
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      m_capacity = this->m_capacity;
      PowerOf2 = bdBitOperations::nextPowerOf2(2 * m_capacity);
      v14 = this->m_capacity;
      if ( PowerOf2 > v14 )
      {
        this->m_capacity = PowerOf2;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rcx
          vmulss  xmm0, xmm0, dword ptr [rsi+8]
          vcvttss2si rcx, xmm0
        }
        this->m_threshold = _RCX;
        v19 = (bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **)bdMemory::allocate(8i64 * PowerOf2);
        this->m_map = v19;
        this->m_size = 0;
        memset_0(v19, 0, 8i64 * this->m_capacity);
        if ( m_capacity )
        {
          v20 = m_map;
          v21 = m_capacity;
          do
          {
            v22 = *v20;
            while ( v22 )
            {
              bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::put(this, &v22->m_key, &v22->m_data);
              v23 = v22;
              v22 = v22->m_next;
              if ( v23->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v23->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
              {
                if ( v23->m_data.m_ptr )
                  ((void (__fastcall *)(bdRelayAssociation *, __int64))v23->m_data.m_ptr->~bdReferencable)(v23->m_data.m_ptr, 1i64);
                v23->m_data.m_ptr = NULL;
              }
              bdMemory::deallocate(v23);
            }
            ++v20;
            --v21;
          }
          while ( v21 );
          Hash = v28;
          v4 = value;
        }
        bdMemory::deallocate(m_map);
        v14 = this->m_capacity;
      }
      v8 = Hash & (v14 - 1);
      m_size = this->m_size;
    }
    this->m_size = m_size + 1;
    v24 = (bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *)bdMemory::allocate(0xA8ui64);
    if ( v24 )
    {
      v25 = this->m_map[v8];
      m_ptr = v4->m_ptr;
      v24->m_data = (bdReference<bdRelayAssociation>)v4->m_ptr;
      if ( m_ptr )
        _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
      bdAddr::bdAddr((bdAddr *)&v24->m_key, key);
      v24->m_next = v25;
    }
    else
    {
      v24 = NULL;
    }
    this->m_map[v8] = v24;
    return 1;
  }
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::releaseIterator
==============
*/
void bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::releaseIterator(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddr,class bdReference<class bdRelayAssociation>,class bdAddrHash>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::remove
==============
*/
char bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::remove(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const bdAddr *key)
{
  __int64 v4; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v5; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v6; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddr,class bdReference<class bdRelayAssociation>,class bdAddrHash>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap", -2i64);
  v4 = bdAddr::getHash((bdAddr *)key) & (this->m_capacity - 1);
  v5 = this->m_map[v4];
  v6 = NULL;
  if ( !v5 )
    return 0;
  while ( !bdSockAddr::compare(&key->m_address, &v5->m_key.m_address, 1) )
  {
    v6 = v5;
    v5 = v5->m_next;
    if ( !v5 )
      return 0;
  }
  m_next = v5->m_next;
  if ( v6 )
    v6->m_next = m_next;
  else
    this->m_map[v4] = m_next;
  if ( v5->m_data.m_ptr && !_InterlockedDecrement((volatile signed __int32 *)&v5->m_data.m_ptr->m_refCount) )
  {
    if ( v5->m_data.m_ptr )
      ((void (__fastcall *)(bdRelayAssociation *, __int64))v5->m_data.m_ptr->~bdReferencable)(v5->m_data.m_ptr, 1i64);
    v5->m_data.m_ptr = NULL;
  }
  bdMemory::deallocate(v5);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::resize
==============
*/
void bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::resize(bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash> *this, const unsigned int newSize)
{
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **v11; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v14; 
  bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node *v15; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdAddr,bdReference<bdRelayAssociation>,bdAddrHash>::put(this, &v14->m_key, &v14->m_data);
          v15 = v14;
          v14 = v14->m_next;
          if ( v15->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v15->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
          {
            if ( v15->m_data.m_ptr )
              ((void (__fastcall *)(bdRelayAssociation *, __int64))v15->m_data.m_ptr->~bdReferencable)(v15->m_data.m_ptr, 1i64);
            v15->m_data.m_ptr = NULL;
          }
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::~bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>
==============
*/
void bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::~bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this)
{
  bdAddrHandle *m_ptr; 
  bdAddrHandle *v3; 

  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::clear(this);
  bdMemory::deallocate(this->m_map);
  m_ptr = this->m_hashClass.m_handle.m_ptr;
  if ( m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
  {
    v3 = this->m_hashClass.m_handle.m_ptr;
    if ( v3 )
      ((void (__fastcall *)(bdAddrHandle *, __int64))v3->~bdReferencable)(v3, 1i64);
    this->m_hashClass.m_handle.m_ptr = NULL;
  }
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::clear
==============
*/
void bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::clear(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this)
{
  unsigned int i; 
  __int64 v3; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **m_map; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v5; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v6; 
  bdAddrHandle *m_ptr; 
  bdAddrHandle *v8; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddrHandleRefWrapper,class bdReference<class bdConnection>,class bdAddrHandleRefWrapper>::clear", 0x3Au, "bdHashMap::clear, another iterator is being held while clearing the hashmap", -2i64);
  for ( i = 0; i < this->m_capacity; ++i )
  {
    v3 = i;
    m_map = this->m_map;
    v5 = m_map[v3];
    if ( v5 )
    {
      do
      {
        v6 = v5;
        v5 = v5->m_next;
        m_ptr = v6->m_key.m_handle.m_ptr;
        if ( m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          v8 = v6->m_key.m_handle.m_ptr;
          if ( v8 )
            ((void (__fastcall *)(bdAddrHandle *, __int64))v8->~bdReferencable)(v8, 1i64);
          v6->m_key.m_handle.m_ptr = NULL;
        }
        if ( v6->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v6->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
        {
          if ( v6->m_data.m_ptr )
            ((void (__fastcall *)(bdConnection *, __int64))v6->m_data.m_ptr->~bdReferencable)(v6->m_data.m_ptr, 1i64);
          v6->m_data.m_ptr = NULL;
        }
        bdMemory::deallocate(v6);
      }
      while ( v5 );
      m_map = this->m_map;
    }
    m_map[v3] = NULL;
  }
  this->m_size = 0;
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::createMap
==============
*/

void __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::createMap(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const unsigned int initialCapacity, double loadFactor)
{
  __int64 PowerOf2; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **v14; 
  size_t v15; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm2, xmm0
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps xmm6, xmm2
  }
  _RBX = this;
  __asm { vcomiss xmm2, cs:__real@3f800000 }
  bdLogMessage(BD_LOG_WARNING, "warn/", "hashmap", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddrHandleRefWrapper,class bdReference<class bdConnection>,class bdAddrHandleRefWrapper>::createMap", 0x1E6u, "Illegal loadFactor. Using default value.");
  _RBX->m_loadFactor = 0.75;
  _RBX->m_size = 0;
  PowerOf2 = bdBitOperations::nextPowerOf2(initialCapacity);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vmulss  xmm1, xmm0, xmm6
    vcvttss2si rax, xmm1
  }
  _RBX->m_capacity = PowerOf2;
  _RBX->m_threshold = _RAX;
  __asm { vmovss  dword ptr [rbx+8], xmm6 }
  v14 = (bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **)bdMemory::allocate(8 * PowerOf2);
  v15 = 8i64 * _RBX->m_capacity;
  _RBX->m_map = v14;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
  memset_0(v14, 0, v15);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::get
==============
*/
char bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::get(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key, bdReference<bdConnection> *value)
{
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v6; 
  bdConnection *m_ptr; 

  if ( !this->m_size )
    return 0;
  v6 = this->m_map[bdAddrHandleRefWrapper::getHash(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v6 )
    return 0;
  while ( !bdAddrHandleRefWrapper::operator==((bdAddrHandleRefWrapper *)key, &v6->m_key) )
  {
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  if ( v6 != (bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *)value )
  {
    if ( value->m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&value->m_ptr->m_refCount, 0xFFFFFFFF) == 1 && value->m_ptr )
      ((void (__fastcall *)(bdConnection *, __int64))value->m_ptr->~bdReferencable)(value->m_ptr, 1i64);
    m_ptr = v6->m_data.m_ptr;
    value->m_ptr = (bdConnection *)v6->m_data;
    if ( m_ptr )
      _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
  }
  bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddrHandleRefWrapper,class bdReference<class bdConnection>,class bdAddrHandleRefWrapper>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  return 1;
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator
==============
*/
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key)
{
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v4; 

  if ( !this->m_size )
    return 0i64;
  v4 = this->m_map[bdAddrHandleRefWrapper::getHash(&this->m_hashClass, key) & (this->m_capacity - 1)];
  if ( !v4 )
    return 0i64;
  while ( !bdAddrHandleRefWrapper::operator==((bdAddrHandleRefWrapper *)key, &v4->m_key) )
  {
    v4 = v4->m_next;
    if ( !v4 )
      return 0i64;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
  return v4;
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator
==============
*/
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getIterator(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this)
{
  unsigned int m_capacity; 
  __int64 i; 
  __int64 v4; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **m_map; 

  if ( !this->m_size )
    return 0i64;
  m_capacity = this->m_capacity;
  for ( i = 0i64; (unsigned int)i < m_capacity; i = (unsigned int)(i + 1) )
  {
    if ( this->m_map[i] )
      break;
  }
  v4 = i;
  m_map = this->m_map;
  if ( m_map[v4] )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 1u);
    m_map = this->m_map;
  }
  return m_map[v4];
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getNextCapacity
==============
*/

unsigned int __fastcall bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::getNextCapacity(const unsigned int targetCapacity)
{
  return bdBitOperations::nextPowerOf2(targetCapacity);
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::next
==============
*/
void bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::next(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, void **iterator)
{
  const bdAddrHandleRefWrapper *v4; 
  bdAddrHandle *m_ptr; 
  unsigned int Hash; 
  unsigned int m_capacity; 
  __int64 v8; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v9; 

  v4 = (const bdAddrHandleRefWrapper *)*iterator;
  m_ptr = v4[2].m_handle.m_ptr;
  if ( m_ptr )
  {
    *iterator = m_ptr;
  }
  else
  {
    Hash = bdAddrHandleRefWrapper::getHash(&this->m_hashClass, v4 + 1);
    m_capacity = this->m_capacity;
    v8 = (Hash & (m_capacity - 1)) + 1;
    if ( (unsigned int)v8 >= m_capacity )
    {
LABEL_6:
      *iterator = NULL;
      _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
    }
    else
    {
      while ( 1 )
      {
        v9 = this->m_map[v8];
        if ( v9 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= m_capacity )
          goto LABEL_6;
      }
      *iterator = v9;
    }
  }
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::put
==============
*/
char bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::put(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key, const bdReference<bdConnection> *value)
{
  unsigned int Hash; 
  __int64 v7; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v8; 
  unsigned int m_size; 
  bdReference<bdConnection> *v10; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v11; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v12; 
  bdConnection *m_ptr; 
  bdAddrHandle *v14; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddrHandleRefWrapper,class bdReference<class bdConnection>,class bdAddrHandleRefWrapper>::put", 0x64u, "bdHashMap::put, another iterator is being held while inserting to hashmap");
  Hash = bdAddrHandleRefWrapper::getHash(&this->m_hashClass, key);
  v7 = Hash & (this->m_capacity - 1);
  v8 = this->m_map[v7];
  if ( v8 )
  {
    while ( !bdAddrHandleRefWrapper::operator==((bdAddrHandleRefWrapper *)key, &v8->m_key) )
    {
      v8 = v8->m_next;
      if ( !v8 )
        goto LABEL_4;
    }
    return 0;
  }
  else
  {
LABEL_4:
    m_size = this->m_size;
    if ( this->m_size + 1 > this->m_threshold )
    {
      bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::resize(this, 2 * this->m_capacity);
      m_size = this->m_size;
      v7 = Hash & (this->m_capacity - 1);
    }
    this->m_size = m_size + 1;
    v10 = (bdReference<bdConnection> *)bdMemory::allocate(0x18ui64);
    v11 = (bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *)v10;
    if ( v10 )
    {
      v12 = this->m_map[v7];
      m_ptr = value->m_ptr;
      v10->m_ptr = value->m_ptr;
      if ( m_ptr )
        _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
      v14 = key->m_handle.m_ptr;
      v11->m_key.m_handle.m_ptr = key->m_handle.m_ptr;
      if ( v14 )
        _InterlockedExchangeAdd((volatile signed __int32 *)&v14->m_refCount, 1u);
      v11->m_next = v12;
    }
    else
    {
      v11 = NULL;
    }
    this->m_map[v7] = v11;
    return 1;
  }
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::releaseIterator
==============
*/
void bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::releaseIterator(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, void *iterator)
{
  if ( iterator )
  {
    bdHandleAssert(this->m_numIterators.m_value._My_val != 0, "m_numIterators != 0", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddrHandleRefWrapper,class bdReference<class bdConnection>,class bdAddrHandleRefWrapper>::releaseIterator", 0x18Au, "bdHashMap::releaseIterator Iterator count reached 0, can't release iterator");
    _InterlockedExchangeAdd((volatile signed __int32 *)&this->m_numIterators, 0xFFFFFFFF);
  }
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::remove
==============
*/
char bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::remove(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const bdAddrHandleRefWrapper *key)
{
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v4; 
  __int64 v5; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v6; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *m_next; 

  bdHandleAssert(this->m_numIterators.m_value._My_val == 0, "(m_numIterators == 0)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdhashmap.inl", "bdHashMap<class bdAddrHandleRefWrapper,class bdReference<class bdConnection>,class bdAddrHandleRefWrapper>::remove", 0xA5u, "bdHashMap::remove, another iterator is being held while removing from hashmap");
  v4 = NULL;
  v5 = bdAddrHandleRefWrapper::getHash(&this->m_hashClass, key) & (this->m_capacity - 1);
  v6 = this->m_map[v5];
  if ( !v6 )
    return 0;
  while ( !bdAddrHandleRefWrapper::operator==((bdAddrHandleRefWrapper *)key, &v6->m_key) )
  {
    v4 = v6;
    v6 = v6->m_next;
    if ( !v6 )
      return 0;
  }
  m_next = v6->m_next;
  if ( v4 )
    v4->m_next = m_next;
  else
    this->m_map[v5] = m_next;
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node::`scalar deleting destructor'(v6, 1u);
  --this->m_size;
  return 1;
}

/*
==============
bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::resize
==============
*/
void bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::resize(bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper> *this, const unsigned int newSize)
{
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **m_map; 
  unsigned int m_capacity; 
  unsigned int PowerOf2; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **v11; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **v12; 
  __int64 v13; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v14; 
  bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node *v15; 
  bdAddrHandle *m_ptr; 
  bdAddrHandle *v17; 

  m_map = this->m_map;
  m_capacity = this->m_capacity;
  PowerOf2 = bdBitOperations::nextPowerOf2(newSize);
  if ( PowerOf2 > this->m_capacity )
  {
    this->m_capacity = PowerOf2;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rdx
      vmulss  xmm0, xmm0, dword ptr [rsi+8]
      vcvttss2si rcx, xmm0
    }
    this->m_threshold = _RCX;
    v11 = (bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::Node **)bdMemory::allocate(8i64 * PowerOf2);
    this->m_map = v11;
    this->m_size = 0;
    memset_0(v11, 0, 8i64 * this->m_capacity);
    if ( m_capacity )
    {
      v12 = m_map;
      v13 = m_capacity;
      do
      {
        v14 = *v12;
        while ( v14 )
        {
          bdHashMap<bdAddrHandleRefWrapper,bdReference<bdConnection>,bdAddrHandleRefWrapper>::put(this, &v14->m_key, &v14->m_data);
          v15 = v14;
          v14 = v14->m_next;
          m_ptr = v15->m_key.m_handle.m_ptr;
          if ( m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
          {
            v17 = v15->m_key.m_handle.m_ptr;
            if ( v17 )
              ((void (__fastcall *)(bdAddrHandle *, __int64))v17->~bdReferencable)(v17, 1i64);
            v15->m_key.m_handle.m_ptr = NULL;
          }
          if ( v15->m_data.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&v15->m_data.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
          {
            if ( v15->m_data.m_ptr )
              ((void (__fastcall *)(bdConnection *, __int64))v15->m_data.m_ptr->~bdReferencable)(v15->m_data.m_ptr, 1i64);
            v15->m_data.m_ptr = NULL;
          }
          bdMemory::deallocate(v15);
        }
        ++v12;
        --v13;
      }
      while ( v13 );
    }
    bdMemory::deallocate(m_map);
  }
}

