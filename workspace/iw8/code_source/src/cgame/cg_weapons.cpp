/*
==============
CG_KillstreakSlotDown
==============
*/

void __fastcall CG_KillstreakSlotDown(LocalClientNum_t localClientNum, int bindingIndex)
{
  ?CG_KillstreakSlotDown@@YAXW4LocalClientNum_t@@H@Z(localClientNum, bindingIndex);
}

/*
==============
CG_NightVisionViewModelGogglesShouldBeAttached
==============
*/

bool __fastcall CG_NightVisionViewModelGogglesShouldBeAttached(LocalClientNum_t localClientNum)
{
  return ?CG_NightVisionViewModelGogglesShouldBeAttached@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::IsPlayerWeaponLaserOn
==============
*/

bool __fastcall CgWeaponSystem::IsPlayerWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon)
{
  return ?IsPlayerWeaponLaserOn@CgWeaponSystem@@UEBA_NAEBUWeapon@@@Z(this, r_weapon);
}

/*
==============
CG_SelectWeapon
==============
*/

bool __fastcall CG_SelectWeapon(LocalClientNum_t localClientNum, const Weapon *weapon, int useAltMode)
{
  return ?CG_SelectWeapon@@YA_NW4LocalClientNum_t@@AEBUWeapon@@H@Z(localClientNum, weapon, useAltMode);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel)
{
  ?ChargedWeaponUpdateRumbleAndSound@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEAUcentity_t@@AEBUWeapon@@_NH@Z(this, ps, cent, weapon, isAlternate, bViewModel);
}

/*
==============
CG_SaveViewModelAnimTrees
==============
*/

void __fastcall CG_SaveViewModelAnimTrees(MemoryFile *memFile, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  ?CG_SaveViewModelAnimTrees@@YAXPEAUMemoryFile@@PEBUplayerState_s@@W4LocalClientNum_t@@@Z(memFile, ps, localClientNum);
}

/*
==============
CG_Weapons_GetEntityHitId
==============
*/

unsigned __int16 __fastcall CG_Weapons_GetEntityHitId(const trace_t *trace)
{
  return ?CG_Weapons_GetEntityHitId@@YAGPEBUtrace_t@@@Z(trace);
}

/*
==============
CG_AddViewWeapon
==============
*/

void __fastcall CG_AddViewWeapon(LocalClientNum_t localClientNum)
{
  ?CG_AddViewWeapon@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate)
{
  ?ChargedWeaponUpdateClientOnlyChargeAmountOverride@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEAUcentity_t@@W4PlayerHandIndex@@AEBUWeapon@@_N@Z(this, ps, cent, hand, weapon, isAlternate);
}

/*
==============
CG_Weapons_RebuildWeaponsArray
==============
*/

void __fastcall CG_Weapons_RebuildWeaponsArray(LocalClientNum_t localClientNum)
{
  ?CG_Weapons_RebuildWeaponsArray@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_UpdateWeaponViewmodels
==============
*/

void __fastcall CG_UpdateWeaponViewmodels(LocalClientNum_t localClientNum)
{
  ?CG_UpdateWeaponViewmodels@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_CycleNeedsToWaitForHoldTime
==============
*/

bool __fastcall CG_CycleNeedsToWaitForHoldTime(LocalClientNum_t localClientNum)
{
  return ?CG_CycleNeedsToWaitForHoldTime@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetStowedOffsetModel
==============
*/

XModel *__fastcall CG_Weapons_GetStowedOffsetModel(const WeaponDef *weapDef)
{
  return ?CG_Weapons_GetStowedOffsetModel@@YAPEAUXModel@@PEBUWeaponDef@@@Z(weapDef);
}

/*
==============
CG_Weapons_GetVisibilityBoneIndex
==============
*/

int __fastcall CG_Weapons_GetVisibilityBoneIndex(const DObj *obj, const characterInfo_t *ci, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand, bool *outUseWeaponTag)
{
  return ?CG_Weapons_GetVisibilityBoneIndex@@YAHPEBUDObj@@PEBUcharacterInfo_t@@AEBUWeapon@@_NW4PlayerHandIndex@@PEA_N@Z(obj, ci, r_weapon, isAlternate, hand, outUseWeaponTag);
}

/*
==============
CG_NightVisionGetExposureAdjustTimings
==============
*/

void __fastcall CG_NightVisionGetExposureAdjustTimings(const int NVGToggleTime, int *outExposureStartBlendInTime, int *outExposureStartBlendOutTime, int *outExposureInDuration, int *outExposureOutDuration)
{
  ?CG_NightVisionGetExposureAdjustTimings@@YAXHPEAH000@Z(NVGToggleTime, outExposureStartBlendInTime, outExposureStartBlendOutTime, outExposureInDuration, outExposureOutDuration);
}

/*
==============
CG_Weapons_CurrentWeaponCanAltToggle
==============
*/

bool __fastcall CG_Weapons_CurrentWeaponCanAltToggle(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_CurrentWeaponCanAltToggle@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::TrySpawnTracer
==============
*/

void __fastcall CgWeaponSystem::TrySpawnTracer(CgWeaponSystem *this, const int bulletId, bool needsDeferring, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  ?TrySpawnTracer@CgWeaponSystem@@QEBAXH_N0HAEBV?$bitarray@$0EA@@@W4PlayerHandIndex@@VTagPair@@AEBTvec3_t@@4AEBUWeapon@@0H@Z(this, bulletId, needsDeferring, blendFromViewmodel, inflictorEntNum, r_inflictorPerks, hand, sourceTagPair, tracerStart, tracerEnd, r_weapon, isAlternate, spawnDelay);
}

/*
==============
CG_ExplosiveImpactOnShieldEvent
==============
*/

void __fastcall CG_ExplosiveImpactOnShieldEvent(LocalClientNum_t localClientNum)
{
  ?CG_ExplosiveImpactOnShieldEvent@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_OffhandGestureWeaponHideParts
==============
*/

void __fastcall CG_OffhandGestureWeaponHideParts(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_OffhandGestureWeaponHideParts@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CG_FireWeaponWithHighPrecisionData
==============
*/

void __fastcall CG_FireWeaponWithHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  ?CG_FireWeaponWithHighPrecisionData@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444PEBUCgFireEventHighPrecisionData@@@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, highPrecisionFireData);
}

/*
==============
CG_OffhandShield_CheckViewModelUpdate
==============
*/

bool __fastcall CG_OffhandShield_CheckViewModelUpdate(const LocalClientNum_t localClientNum)
{
  return ?CG_OffhandShield_CheckViewModelUpdate@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
MovementAnimState::GetCycleAnimation
==============
*/

weapAnimFiles_t __fastcall MovementAnimState::GetCycleAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  return ?GetCycleAnimation@MovementAnimState@@AEBA?AW4weapAnimFiles_t@@W4State@1@@Z(this, state);
}

/*
==============
CG_ShouldTriggerOffhandShield
==============
*/

bool __fastcall CG_ShouldTriggerOffhandShield(LocalClientNum_t localClientNum, int sourceEntityNum)
{
  return ?CG_ShouldTriggerOffhandShield@@YA_NW4LocalClientNum_t@@H@Z(localClientNum, sourceEntityNum);
}

/*
==============
CgWeaponSystem::GetIconDimsForPlayer
==============
*/

int __fastcall CgWeaponSystem::GetIconDimsForPlayer(CgWeaponSystem *this, const centity_t *cent, float *x, float *y, float *w, float *h, bool forceCheck)
{
  return ?GetIconDimsForPlayer@CgWeaponSystem@@QEBAHPEBUcentity_t@@PEAM111_N@Z(this, cent, x, y, w, h, forceCheck);
}

/*
==============
MovementAnimState::GetTransitionAnimation
==============
*/

weapAnimFiles_t __fastcall MovementAnimState::GetTransitionAnimation(MovementAnimState *this, MovementAnimState::State prevState, const MovementAnimState::State nextState)
{
  return ?GetTransitionAnimation@MovementAnimState@@AEBA?AW4weapAnimFiles_t@@W4State@1@W431@@Z(this, prevState, nextState);
}

/*
==============
CAssistTarget::GetEntNum
==============
*/

int __fastcall CAssistTarget::GetEntNum(CAssistTarget *this)
{
  return ?GetEntNum@CAssistTarget@@UEBAHXZ(this);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer(CgWeaponSystem *this, const playerState_s *ps)
{
  ?ChargedWeaponUpdateChargeStateForLocalPlayer@CgWeaponSystem@@IEBAXPEBUplayerState_s@@@Z(this, ps);
}

/*
==============
CG_DebugBulletFireLog_ShouldLog
==============
*/

bool __fastcall CG_DebugBulletFireLog_ShouldLog(const int entNum)
{
  return ?CG_DebugBulletFireLog_ShouldLog@@YA_NH@Z(entNum);
}

/*
==============
CG_SndUpdateSubmix
==============
*/

void __fastcall CG_SndUpdateSubmix(LocalClientNum_t localClientNum)
{
  ?CG_SndUpdateSubmix@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::DrawDebugBulletLines
==============
*/

void __fastcall CgWeaponSystem::DrawDebugBulletLines(CgWeaponSystem *this)
{
  ?DrawDebugBulletLines@CgWeaponSystem@@QEAAXXZ(this);
}

/*
==============
CG_Weapons_ToggleWeaponAltMode
==============
*/

bool __fastcall CG_Weapons_ToggleWeaponAltMode(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_ToggleWeaponAltMode@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_IsBulletWeapon
==============
*/

int __fastcall CG_Weapons_IsBulletWeapon(const Weapon *weapon, bool isAlternate)
{
  return ?CG_Weapons_IsBulletWeapon@@YAHAEBUWeapon@@_N@Z(weapon, isAlternate);
}

/*
==============
CG_GetImpactEffectForWeapon
==============
*/

void __fastcall CG_GetImpactEffectForWeapon(LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, const bool filterByContents, const int hitContents, const Weapon *weapon, bool isAlternate, const int surfType, const unsigned int impactFlags, SndHitArmorType hitArmorType, FXRegisteredDef *outFx, const SndAliasList **outSnd, bool *outIsSfxExplosion)
{
  ?CG_GetImpactEffectForWeapon@@YAXW4LocalClientNum_t@@HH_NHAEBUWeapon@@_NHIW4SndHitArmorType@@QEAVFXRegisteredDef@@PEAPEBUSndAliasList@@PEA_N@Z(localClientNum, sourceEntityNum, targetEntityNum, filterByContents, hitContents, weapon, isAlternate, surfType, impactFlags, hitArmorType, outFx, outSnd, outIsSfxExplosion);
}

/*
==============
CG_GetWeaponZoom
==============
*/

double __fastcall CG_GetWeaponZoom(const cg_t *cgameGlob, const Weapon *weapon, const float weapPosFrac, const CG_FovSpace fovSpace)
{
  double result; 

  *(float *)&result = ?CG_GetWeaponZoom@@YAMPEBVcg_t@@AEBUWeapon@@MW4CG_FovSpace@@@Z(cgameGlob, weapon, weapPosFrac, fovSpace);
  return result;
}

/*
==============
CgWeaponSystem::ShouldWeaponPing
==============
*/

int __fastcall CgWeaponSystem::ShouldWeaponPing(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, const bool isAlternate, const vec3_t *origin)
{
  return ?ShouldWeaponPing@CgWeaponSystem@@UEBAHPEBUcentity_t@@AEBUWeapon@@_NAEBTvec3_t@@@Z(this, cent, weapon, isAlternate, origin);
}

/*
==============
CG_Weapons_CreateRiotShieldPhysics
==============
*/

void __fastcall CG_Weapons_CreateRiotShieldPhysics(LocalClientNum_t localClientNum, const DObj *obj, const XModel *model, int entityNum)
{
  ?CG_Weapons_CreateRiotShieldPhysics@@YAXW4LocalClientNum_t@@PEBUDObj@@PEBUXModel@@H@Z(localClientNum, obj, model, entityNum);
}

/*
==============
CgWeaponSystem::AddDebugBulletLine
==============
*/

void __fastcall CgWeaponSystem::AddDebugBulletLine(CgWeaponSystem *this, const vec3_t *start, const vec3_t *end)
{
  ?AddDebugBulletLine@CgWeaponSystem@@QEAAXAEBTvec3_t@@0@Z(this, start, end);
}

/*
==============
CG_GetLocalClientGlobalsForEnt
==============
*/

cg_t *__fastcall CG_GetLocalClientGlobalsForEnt(int entityNum)
{
  return ?CG_GetLocalClientGlobalsForEnt@@YAPEAVcg_t@@H@Z(entityNum);
}

/*
==============
CgWeaponSystem::PlayPullbackSound
==============
*/

void __fastcall CgWeaponSystem::PlayPullbackSound(CgWeaponSystem *this, const int entNum, const bool isPlayerView, const Weapon *r_weapon, const bool isAlternate)
{
  ?PlayPullbackSound@CgWeaponSystem@@QEBAXH_NAEBUWeapon@@0@Z(this, entNum, isPlayerView, r_weapon, isAlternate);
}

/*
==============
CG_IsJogging
==============
*/

bool __fastcall CG_IsJogging(LocalClientNum_t localClientNum)
{
  return ?CG_IsJogging@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_IsAutoSimFiring
==============
*/

bool __fastcall CG_IsAutoSimFiring(cg_t *cgameGlob)
{
  return ?CG_IsAutoSimFiring@@YA_NPEAVcg_t@@@Z(cgameGlob);
}

/*
==============
CG_GetWeaponDisplayName
==============
*/

const char *__fastcall CG_GetWeaponDisplayName(const Weapon *weapon, bool isAlternate, char *outputBuffer, unsigned __int64 bufferLen, bool isNewlineSpacer)
{
  return ?CG_GetWeaponDisplayName@@YAPEBDAEBUWeapon@@_NPEAD_K1@Z(weapon, isAlternate, outputBuffer, bufferLen, isNewlineSpacer);
}

/*
==============
CG_Weapons_ToggleEquip
==============
*/

void __fastcall CG_Weapons_ToggleEquip(LocalClientNum_t localClientNum)
{
  ?CG_Weapons_ToggleEquip@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_DoBulletPathSim
==============
*/

bool __fastcall CgWeaponSystem::SimulateBulletFire_DoBulletPathSim(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, const int knownHitClientNum, const int autoTargetedEntNum, const scr_string_t autoTargetedEntTag, const vec3_t *tracerStart, float aimSpreadAmount, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, const int shotIndex, bool shouldSpawnTracer, bool shouldSpawnExitTracers, bool shouldDeferEvents, bool forceClientSideImpactFx, vec3_t *outLastBulletPos)
{
  return ?SimulateBulletFire_DoBulletPathSim@CgWeaponSystem@@QEAA_NPEAUBulletFireParams@@HAEBUWeapon@@_NPEAUcentity_t@@AEBV?$bitarray@$0EA@@@HHW4scr_string_t@@AEBTvec3_t@@M2W4PlayerHandIndex@@VTagPair@@H2222AEAT7@@Z(this, bp, bulletId, weapon, isAlternate, inflictorEnt, r_attackerPerks, knownHitClientNum, autoTargetedEntNum, autoTargetedEntTag, tracerStart, aimSpreadAmount, isPlayerWeaponView, hand, tagPair, shotIndex, shouldSpawnTracer, shouldSpawnExitTracers, shouldDeferEvents, forceClientSideImpactFx, outLastBulletPos);
}

/*
==============
CG_GetAirburstMarkDistance
==============
*/

int __fastcall CG_GetAirburstMarkDistance(LocalClientNum_t localClientNum, playerState_s *ps, unsigned __int64 buttons, unsigned int *outDistance)
{
  return ?CG_GetAirburstMarkDistance@@YAHW4LocalClientNum_t@@PEAUplayerState_s@@_KPEAI@Z(localClientNum, ps, buttons, outDistance);
}

/*
==============
MovementAnimState::UpdateInternal
==============
*/

void __fastcall MovementAnimState::UpdateInternal(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps, const MovementAnimState::State newGoal)
{
  ?UpdateInternal@MovementAnimState@@AEAAXW4LocalClientNum_t@@W4PlayerHandIndex@@PEBUplayerState_s@@W4State@1@@Z(this, localClientNum, hand, ps, newGoal);
}

/*
==============
CG_DebugBulletFireLog_AddServerEntry
==============
*/

void __fastcall CG_DebugBulletFireLog_AddServerEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  ?CG_DebugBulletFireLog_AddServerEntry@@YAXHHAEBTvec3_t@@0@Z(entNum, serverTime, bulletOrigin, bulletDir);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxTryStart
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxTryStart(CgWeaponSystem *this)
{
  ?OffhandWeaponVmFxTryStart@CgWeaponSystem@@IEBAXXZ(this);
}

/*
==============
CG_ValidateWeaponAnimGroupsUniqueness
==============
*/

void CG_ValidateWeaponAnimGroupsUniqueness(void)
{
  ?CG_ValidateWeaponAnimGroupsUniqueness@@YAXXZ();
}

/*
==============
CgWeaponSystem::ChargedWeaponOnBeginCharging
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnBeginCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnBeginCharging@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEBUcentity_t@@AEBUWeapon@@_N3PEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, ps, cent, weapon, isAlternate, isPlayerView, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::BloodSplatterOnShield
==============
*/

void __fastcall CgWeaponSystem::BloodSplatterOnShield(CgWeaponSystem *this, int entityNum)
{
  ?BloodSplatterOnShield@CgWeaponSystem@@IEBAXH@Z(this, entityNum);
}

/*
==============
CG_RegisterWeapon
==============
*/

bool __fastcall CG_RegisterWeapon(LocalClientNum_t localClientNum, const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeaponFlags, const Weapon *weapon, ClientPlayerWeaponInfo *weapInfo)
{
  return ?CG_RegisterWeapon@@YA_NW4LocalClientNum_t@@PEBUplayerState_s@@V?$GameModeFlagContainer@W4PWeaponFlagsCommon@@W4PWeaponFlagsSP@@W4PWeaponFlagsMP@@$0EA@@@AEBUWeapon@@PEAUClientPlayerWeaponInfo@@@Z(localClientNum, ps, prevWeaponFlags, weapon, weapInfo);
}

/*
==============
CG_FireWeaponWithLodAndHighPrecisionData
==============
*/

void __fastcall CG_FireWeaponWithLodAndHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  ?CG_FireWeaponWithLodAndHighPrecisionData@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444AEBUCgEventLodData@@PEBUCgFireEventHighPrecisionData@@@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, eventLodData, highPrecisionFireData);
}

/*
==============
CAssistTarget::GetTarget
==============
*/

const centity_t *__fastcall CAssistTarget::GetTarget(CAssistTarget *this)
{
  return ?GetTarget@CAssistTarget@@QEBAPEBUcentity_t@@XZ(this);
}

/*
==============
CG_FireWeapon
==============
*/

void __fastcall CG_FireWeapon(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer)
{
  ?CG_FireWeapon@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer);
}

/*
==============
CG_GetViewModelPoseForHand
==============
*/

cpose_t *__fastcall CG_GetViewModelPoseForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  return ?CG_GetViewModelPoseForHand@@YAPEAUcpose_t@@W4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(CgWeaponSystem *this, const int entNum, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponStopAllSoundsAndRumble@CgWeaponSystem@@IEBAXHPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, entNum, soundRumbleInfo);
}

/*
==============
CG_UpdateViewModelPose
==============
*/

void __fastcall CG_UpdateViewModelPose(const DObj *obj, LocalClientNum_t localClientNum)
{
  ?CG_UpdateViewModelPose@@YAXPEBUDObj@@W4LocalClientNum_t@@@Z(obj, localClientNum);
}

/*
==============
CgWeaponSystem::ChargeWeaponOnRespawn
==============
*/

void __fastcall CgWeaponSystem::ChargeWeaponOnRespawn(CgWeaponSystem *this, const playerState_s *ps)
{
  ?ChargeWeaponOnRespawn@CgWeaponSystem@@QEAAXPEBUplayerState_s@@@Z(this, ps);
}

/*
==============
CG_DebugBulletFireLog_AddClientEntry
==============
*/

void __fastcall CG_DebugBulletFireLog_AddClientEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  ?CG_DebugBulletFireLog_AddClientEntry@@YAXHHAEBTvec3_t@@0@Z(entNum, serverTime, bulletOrigin, bulletDir);
}

/*
==============
CG_Weapons_HoldBreathInit
==============
*/

void __fastcall CG_Weapons_HoldBreathInit(cg_t *cgameGlob)
{
  ?CG_Weapons_HoldBreathInit@@YAXPEAVcg_t@@@Z(cgameGlob);
}

/*
==============
CG_ForceSwitchToValidWeapon
==============
*/

int __fastcall CG_ForceSwitchToValidWeapon(LocalClientNum_t localClientNum)
{
  return ?CG_ForceSwitchToValidWeapon@@YAHW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_ExplosiveSplashOnShieldEvent
==============
*/

void __fastcall CG_ExplosiveSplashOnShieldEvent(LocalClientNum_t localClientNum, int originalDamage)
{
  ?CG_ExplosiveSplashOnShieldEvent@@YAXW4LocalClientNum_t@@H@Z(localClientNum, originalDamage);
}

/*
==============
CG_DisplayViewmodelAnim
==============
*/

void __fastcall CG_DisplayViewmodelAnim(LocalClientNum_t localClientNum)
{
  ?CG_DisplayViewmodelAnim@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ClientViewLockedOnTurret
==============
*/

int __fastcall CgWeaponSystem::ClientViewLockedOnTurret(CgWeaponSystem *this, int entnum)
{
  return ?ClientViewLockedOnTurret@CgWeaponSystem@@QEBAHH@Z(this, entnum);
}

/*
==============
CG_LoadViewModelAnimTrees
==============
*/

void __fastcall CG_LoadViewModelAnimTrees(SaveGame *save, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  ?CG_LoadViewModelAnimTrees@@YAXPEAUSaveGame@@PEBUplayerState_s@@W4LocalClientNum_t@@@Z(save, ps, localClientNum);
}

/*
==============
CG_GetImpactEffectList
==============
*/

void __fastcall CG_GetImpactEffectList(int impactType, int surfaceType, bool isFlesh, bool isExit, bool isNoImpact, FXRegisteredDef *outFx)
{
  ?CG_GetImpactEffectList@@YAXHH_N00QEAVFXRegisteredDef@@@Z(impactType, surfaceType, isFlesh, isExit, isNoImpact, outFx);
}

/*
==============
MovementAnimState::GetOffsetAnimation
==============
*/

weapAnimFiles_t __fastcall MovementAnimState::GetOffsetAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  return ?GetOffsetAnimation@MovementAnimState@@AEBA?AW4weapAnimFiles_t@@W4State@1@@Z(this, state);
}

/*
==============
CG_PlayerUsingOutlineEnemiesTurret
==============
*/

bool __fastcall CG_PlayerUsingOutlineEnemiesTurret(LocalClientNum_t localClientNum)
{
  return ?CG_PlayerUsingOutlineEnemiesTurret@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_NightVisionIsAvailable
==============
*/

bool __fastcall CG_NightVisionIsAvailable(LocalClientNum_t localClientNum)
{
  return ?CG_NightVisionIsAvailable@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponOnMaxCharge
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnMaxCharge(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnMaxCharge@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEBUcentity_t@@AEBUWeapon@@_N3PEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, ps, cent, weapon, isAlternate, isPlayerView, soundRumbleInfo);
}

/*
==============
CG_FireWeaponRicochet
==============
*/

void __fastcall CG_FireWeaponRicochet(LocalClientNum_t localClientNum, centity_t *attackerEnt, centity_t *shieldEnt, const vec3_t *firePos, const vec3_t *fireDir, int ricochetCount, float travelDistance, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield)
{
  ?CG_FireWeaponRicochet@@YAXW4LocalClientNum_t@@PEAUcentity_t@@1AEBTvec3_t@@2HMAEBUWeapon@@_NW4PlayerHandIndex@@44@Z(localClientNum, attackerEnt, shieldEnt, firePos, fireDir, ricochetCount, travelDistance, weapon, isAlternate, hand, isPlayerView, isDualWield);
}

/*
==============
CG_BulletHitClientShieldEvent
==============
*/

void __fastcall CG_BulletHitClientShieldEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, int surfType, int event, unsigned int eventParm)
{
  ?CG_BulletHitClientShieldEvent@@YAXW4LocalClientNum_t@@HAEBUWeapon@@_NHHI@Z(localClientNum, sourceEntityNum, weapon, isAlternate, surfType, event, eventParm);
}

/*
==============
CG_GetEntWeapon
==============
*/

const Weapon *__fastcall CG_GetEntWeapon(LocalClientNum_t localClientNum, const centity_t *cent)
{
  return ?CG_GetEntWeapon@@YAAEBUWeapon@@W4LocalClientNum_t@@PEBUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CG_BinocularsADS
==============
*/

bool __fastcall CG_BinocularsADS(LocalClientNum_t localClientNum)
{
  return ?CG_BinocularsADS@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponOnStopCharging
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnStopCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnStopCharging@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEBUcentity_t@@AEBUWeapon@@_N3PEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, ps, cent, weapon, isAlternate, isPlayerView, soundRumbleInfo);
}

/*
==============
CG_CycleWeapon
==============
*/

void __fastcall CG_CycleWeapon(LocalClientNum_t localClientNum, int cycleSlot, int cycleForward)
{
  ?CG_CycleWeapon@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, cycleSlot, cycleForward);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxUpdate
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxUpdate(CgWeaponSystem *this, const Weapon *currWeap, bool isAlternate)
{
  ?OffhandWeaponVmFxUpdate@CgWeaponSystem@@QEBAXAEBUWeapon@@_N@Z(this, currWeap, isAlternate);
}

/*
==============
CG_Weapons_EntityHasShield
==============
*/

bool __fastcall CG_Weapons_EntityHasShield(const LocalClientNum_t localClientNum, const centity_t *const cent)
{
  return ?CG_Weapons_EntityHasShield@@YA_NW4LocalClientNum_t@@QEBUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::BulletScriptableImpact
==============
*/

void __fastcall CgWeaponSystem::BulletScriptableImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  ?BulletScriptableImpact@CgWeaponSystem@@QEBAXIIAEBUWeapon@@_NW4meansOfDeath_t@@AEBTvec3_t@@3W4scr_string_t@@@Z(this, inflictorEntNum, targetEntityNum, weapon, isAlternate, mod, start, hitPos, hitPartName);
}

/*
==============
CG_OffhandShield_DamageFeedback
==============
*/

void __fastcall CG_OffhandShield_DamageFeedback(LocalClientNum_t localClientNum, int sourceEntityNum, unsigned int eventParm, bool damaged)
{
  ?CG_OffhandShield_DamageFeedback@@YAXW4LocalClientNum_t@@HI_N@Z(localClientNum, sourceEntityNum, eventParm, damaged);
}

/*
==============
CG_Weapons_GetScriptableHitId
==============
*/

unsigned int __fastcall CG_Weapons_GetScriptableHitId(const trace_t *trace)
{
  return ?CG_Weapons_GetScriptableHitId@@YAIPEBUtrace_t@@@Z(trace);
}

/*
==============
CG_Entity_HasWeapon
==============
*/

bool __fastcall CG_Entity_HasWeapon(LocalClientNum_t localClientNum, centity_t *cent)
{
  return ?CG_Entity_HasWeapon@@YA_NW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CG_JavelinADS
==============
*/

bool __fastcall CG_JavelinADS(LocalClientNum_t localClientNum)
{
  return ?CG_JavelinADS@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_OnOffhandKeyDown
==============
*/

void __fastcall CG_OnOffhandKeyDown(LocalClientNum_t localClientNum, unsigned __int64 offhandButton)
{
  ?CG_OnOffhandKeyDown@@YAXW4LocalClientNum_t@@_K@Z(localClientNum, offhandButton);
}

/*
==============
CgWeaponSystem::ProcessDeferredTracer
==============
*/

void __fastcall CgWeaponSystem::ProcessDeferredTracer(CgWeaponSystem *this)
{
  ?ProcessDeferredTracer@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CgWeaponSystem::DrawTargetBox
==============
*/

void __fastcall CgWeaponSystem::DrawTargetBox(CgWeaponSystem *this, float x, float y, float w, float h, Material *icon, float alpha)
{
  ?DrawTargetBox@CgWeaponSystem@@QEBAXMMMMPEAUMaterial@@M@Z(this, x, y, w, h, icon, alpha);
}

/*
==============
CG_UpdateViewWeaponAnim
==============
*/

void __fastcall CG_UpdateViewWeaponAnim(LocalClientNum_t localClientNum)
{
  ?CG_UpdateViewWeaponAnim@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_ClearAutoComplete
==============
*/

void CG_Weapons_ClearAutoComplete(void)
{
  ?CG_Weapons_ClearAutoComplete@@YAXXZ();
}

/*
==============
CgWeaponSystem::CalculateTagOffset
==============
*/

bool __fastcall CgWeaponSystem::CalculateTagOffset(CgWeaponSystem *this, const int entNum, scr_string_t tagName, const vec3_t *worldPos, vec3_t *outTagOffset)
{
  return ?CalculateTagOffset@CgWeaponSystem@@QEBA_NHW4scr_string_t@@AEBTvec3_t@@AEAT3@@Z(this, entNum, tagName, worldPos, outTagOffset);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_HitEffect
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire_HitEffect(CgWeaponSystem *this, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  ?SimulateBulletFire_HitEffect@CgWeaponSystem@@MEBAXHHIHAEBUWeapon@@_NAEBTvec3_t@@222HIIH_N@Z(this, sourceEntityNum, targetEntityNum, targetScriptableIndex, knownHitClientNum, weapon, isAlternate, initialShootingPos, startPos, position, normal, surfType, meansOfDeath, impactEffects, hitContents, forceClientSideHandling);
}

/*
==============
CG_Weapon_FreeViewModelDobjHand
==============
*/

void __fastcall CG_Weapon_FreeViewModelDobjHand(const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_Weapon_FreeViewModelDobjHand@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponSetChargeAmountOverride
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponSetChargeAmountOverride(CgWeaponSystem *this, const centity_t *cent, const PlayerHandIndex hand, const int chargeAmount)
{
  ?ChargedWeaponSetChargeAmountOverride@CgWeaponSystem@@QEAAXPEBUcentity_t@@W4PlayerHandIndex@@H@Z(this, cent, hand, chargeAmount);
}

/*
==============
CG_Weapons_DestroyRiotShieldPhysics
==============
*/

void __fastcall CG_Weapons_DestroyRiotShieldPhysics(LocalClientNum_t localClientNum, int entityNum)
{
  ?CG_Weapons_DestroyRiotShieldPhysics@@YAXW4LocalClientNum_t@@H@Z(localClientNum, entityNum);
}

/*
==============
CG_BinocularsGetZoomLevel
==============
*/

int __fastcall CG_BinocularsGetZoomLevel(LocalClientNum_t localClientNum)
{
  return ?CG_BinocularsGetZoomLevel@@YAHW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_GetViewDirection
==============
*/

bool __fastcall CG_GetViewDirection(LocalClientNum_t localClientNum, int entityNum, vec3_t *outForward, vec3_t *outRight, vec3_t *outUp)
{
  return ?CG_GetViewDirection@@YA_NW4LocalClientNum_t@@HAEATvec3_t@@11@Z(localClientNum, entityNum, outForward, outRight, outUp);
}

/*
==============
CG_DebugBulletFireLog_GetEntry
==============
*/

const DebugBulletFireInfoEntry *__fastcall CG_DebugBulletFireLog_GetEntry(int entryIndex)
{
  return ?CG_DebugBulletFireLog_GetEntry@@YAPEBUDebugBulletFireInfoEntry@@H@Z(entryIndex);
}

/*
==============
CConeTargetEvaluator::EvaluateTarget
==============
*/

bool __fastcall CConeTargetEvaluator::EvaluateTarget(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const CAssistTarget *assistTarget, const vec3_t *bulletStart, float range, vec3_t *outBulletEnd, vec3_t *outBulletDir)
{
  return ?EvaluateTarget@CConeTargetEvaluator@@UEBA_NW4LocalClientNum_t@@PEBVCAssistTarget@@AEBTvec3_t@@MAEAT4@3@Z(this, localClientNum, assistTarget, bulletStart, range, outBulletEnd, outBulletDir);
}

/*
==============
CG_Weapon_FreeViewModelDobj
==============
*/

void __fastcall CG_Weapon_FreeViewModelDobj(const LocalClientNum_t localClientNum)
{
  ?CG_Weapon_FreeViewModelDobj@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::TryCG_TrackingLaserBeamAdd
==============
*/

void __fastcall CgWeaponSystem::TryCG_TrackingLaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate, const int shotIndex, const int trackedEntNum, const scr_string_t autoTargetEntTag, const vec3_t *tagOffset, const float aimSpreadAmount)
{
  ?TryCG_TrackingLaserBeamAdd@CgWeaponSystem@@QEBAX_NW4LocalClientNum_t@@AEBTvec3_t@@2PEBUcentity_t@@AEBUWeapon@@_NHHW4scr_string_t@@2M@Z(this, needsDeferring, localClientNum, start, end, owner, weapon, isAlternate, shotIndex, trackedEntNum, autoTargetEntTag, tagOffset, aimSpreadAmount);
}

/*
==============
CG_SmoothOutWeaponPosFracForMispredictionErrors
==============
*/

void __fastcall CG_SmoothOutWeaponPosFracForMispredictionErrors(const LocalClientNum_t localClientNum)
{
  ?CG_SmoothOutWeaponPosFracForMispredictionErrors@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_EjectWeaponBrass
==============
*/

void __fastcall CG_EjectWeaponBrass(LocalClientNum_t localClientNum, const entityState_t *ent, int event, bool isAlternate)
{
  ?CG_EjectWeaponBrass@@YAXW4LocalClientNum_t@@PEBUentityState_t@@H_N@Z(localClientNum, ent, event, isAlternate);
}

/*
==============
CgWeaponSystem::ShouldSpawnTracer
==============
*/

bool __fastcall CgWeaponSystem::ShouldSpawnTracer(CgWeaponSystem *this, const int attackerEntNum, const bitarray<64> *r_perks, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate, const bool isMainBulletSimulation)
{
  return ?ShouldSpawnTracer@CgWeaponSystem@@QEBA_NHAEBV?$bitarray@$0EA@@@W4PlayerHandIndex@@AEBUWeapon@@_N_N@Z(this, attackerEntNum, r_perks, hand, weapon, isAlternate, isMainBulletSimulation);
}

/*
==============
MovementAnimState::IsOffsetAnimationTransition
==============
*/

bool __fastcall MovementAnimState::IsOffsetAnimationTransition(MovementAnimState *this, const weapAnimFiles_t animIndex)
{
  return ?IsOffsetAnimationTransition@MovementAnimState@@AEBA_NW4weapAnimFiles_t@@@Z(this, animIndex);
}

/*
==============
CgWeaponSystem::ChargedWeaponStartRumble
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStartRumble(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponStartRumble@CgWeaponSystem@@IEBAXAEBUWeapon@@_NPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, weapon, isAlternate, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot(CgWeaponSystem *this, const int entityNum, const CharacterChargedWeaponInfo *characterChargedWeaponInfo)
{
  ?ChargedWeaponUpdateChargeStateFromSnapshot@CgWeaponSystem@@QEAAXHPEBUCharacterChargedWeaponInfo@@@Z(this, entityNum, characterChargedWeaponInfo);
}

/*
==============
CgWeaponSystem::TryCG_Glass_BreakGlass
==============
*/

void __fastcall CgWeaponSystem::TryCG_Glass_BreakGlass(CgWeaponSystem *this, bool needsDeferring, LocalClientNum_t localClientNum, const vec3_t *cameraPosition, unsigned __int16 glassPieceIndex, const vec3_t *hitPosition, const vec3_t *hitDirection)
{
  ?TryCG_Glass_BreakGlass@CgWeaponSystem@@QEBAX_NW4LocalClientNum_t@@AEBTvec3_t@@G22@Z(this, needsDeferring, localClientNum, cameraPosition, glassPieceIndex, hitPosition, hitDirection);
}

/*
==============
CG_FireWeaponWithLod
==============
*/

void __fastcall CG_FireWeaponWithLod(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData)
{
  ?CG_FireWeaponWithLod@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444AEBUCgEventLodData@@@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, eventLodData);
}

/*
==============
CG_IsWeaponInspectOnAltToggle
==============
*/

bool __fastcall CG_IsWeaponInspectOnAltToggle(LocalClientNum_t localClientNum)
{
  return ?CG_IsWeaponInspectOnAltToggle@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetSFXImpactType
==============
*/

int __fastcall CG_Weapons_GetSFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  return ?CG_Weapons_GetSFXImpactType@@YAHW4LocalClientNum_t@@HAEBUWeapon@@_N@Z(localClientNum, sourceEntityNum, inWeapon, isAlternate);
}

/*
==============
CG_PlayerUsingThermalTurret
==============
*/

bool __fastcall CG_PlayerUsingThermalTurret(LocalClientNum_t localClientNum)
{
  return ?CG_PlayerUsingThermalTurret@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::StopPullbackSound
==============
*/

void __fastcall CgWeaponSystem::StopPullbackSound(CgWeaponSystem *this, const int entNum)
{
  ?StopPullbackSound@CgWeaponSystem@@QEBAXH@Z(this, entNum);
}

/*
==============
CG_PlayerUsingScopedTurret
==============
*/

bool __fastcall CG_PlayerUsingScopedTurret(LocalClientNum_t localClientNum)
{
  return ?CG_PlayerUsingScopedTurret@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetSFXWhizbyType
==============
*/

unsigned int __fastcall CG_Weapons_GetSFXWhizbyType(const Weapon *inWeapon, bool isAlternate)
{
  return ?CG_Weapons_GetSFXWhizbyType@@YAIAEBUWeapon@@_N@Z(inWeapon, isAlternate);
}

/*
==============
CG_CanCycleWeapon
==============
*/

bool __fastcall CG_CanCycleWeapon(LocalClientNum_t localClientNum)
{
  return ?CG_CanCycleWeapon@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_WeaponInspect_IsUIHidden
==============
*/

bool __fastcall CG_WeaponInspect_IsUIHidden(LocalClientNum_t localClientNum)
{
  return ?CG_WeaponInspect_IsUIHidden@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps)
{
  ?ChargedWeaponClearClientOnlyChargeAmountOverride@CgWeaponSystem@@QEBAXPEBUplayerState_s@@@Z(this, ps);
}

/*
==============
CG_BulletHitClientEvent
==============
*/

void __fastcall CG_BulletHitClientEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *startPos, const vec3_t *position, int surfType, int event, unsigned int impactEffects, SndHitArmorType hitArmorType)
{
  ?CG_BulletHitClientEvent@@YAXW4LocalClientNum_t@@HAEBUWeapon@@_NAEBTvec3_t@@3HHIW4SndHitArmorType@@@Z(localClientNum, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, event, impactEffects, hitArmorType);
}

/*
==============
CG_NightVisionDown
==============
*/

void __fastcall CG_NightVisionDown(LocalClientNum_t localClientNum)
{
  ?CG_NightVisionDown@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponGetChargeAmount
==============
*/

int __fastcall CgWeaponSystem::ChargedWeaponGetChargeAmount(CgWeaponSystem *this, const playerState_s *ps, const PlayerHandIndex hand)
{
  return ?ChargedWeaponGetChargeAmount@CgWeaponSystem@@QEBAHPEBUplayerState_s@@W4PlayerHandIndex@@@Z(this, ps, hand);
}

/*
==============
CG_Weapons_ActionSlotUsageAllowed
==============
*/

bool __fastcall CG_Weapons_ActionSlotUsageAllowed(const cg_t *const cgameGlob, const int slot)
{
  return ?CG_Weapons_ActionSlotUsageAllowed@@YA_NQEBVcg_t@@H@Z(cgameGlob, slot);
}

/*
==============
CG_DebugBulletFireLog_GetNumEntries
==============
*/

int __fastcall CG_DebugBulletFireLog_GetNumEntries()
{
  return ?CG_DebugBulletFireLog_GetNumEntries@@YAHXZ();
}

/*
==============
CG_BinocularsThermalEnabled
==============
*/

bool __fastcall CG_BinocularsThermalEnabled(LocalClientNum_t localClientNum)
{
  return ?CG_BinocularsThermalEnabled@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_GetWeaponAnimTime
==============
*/

double __fastcall CG_GetWeaponAnimTime(LocalClientNum_t localClientNum, PlayerHandIndex handIndex, weapAnimFiles_t animFile)
{
  double result; 

  *(float *)&result = ?CG_GetWeaponAnimTime@@YAMW4LocalClientNum_t@@W4PlayerHandIndex@@W4weapAnimFiles_t@@@Z(localClientNum, handIndex, animFile);
  return result;
}

/*
==============
CgWeaponSystem::ChargedWeaponPlaySound
==============
*/

SndAliasLookup __fastcall CgWeaponSystem::ChargedWeaponPlaySound(CgWeaponSystem *this, const int entNum, SndAliasLookup sndAliasLookup)
{
  return ?ChargedWeaponPlaySound@CgWeaponSystem@@IEBA?AUSndAliasLookup@@HU2@@Z(this, entNum, sndAliasLookup);
}

/*
==============
CConeTargetEvaluator::FindTargets
==============
*/

int __fastcall CConeTargetEvaluator::FindTargets(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *attacker, const vec3_t *bulletStart, const vec3_t *bulletDir, float range, float spread, int maxTargets, const bool isBeamWeapon, const unsigned int hitLocMask, const int gameTime, const bool isFiring, ntl::fixed_array<CAssistTarget,20> *outTargetArray)
{
  return ?FindTargets@CConeTargetEvaluator@@UEAAHW4LocalClientNum_t@@AEBUWeapon@@_NPEBUcentity_t@@AEBTvec3_t@@4MMH2IH2PEAV?$fixed_array@VCAssistTarget@@$0BE@@ntl@@@Z(this, localClientNum, r_weapon, isAlternate, attacker, bulletStart, bulletDir, range, spread, maxTargets, isBeamWeapon, hitLocMask, gameTime, isFiring, outTargetArray);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxStopAll
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxStopAll(CgWeaponSystem *this)
{
  ?OffhandWeaponVmFxStopAll@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CG_GetCurrentWeaponSlot
==============
*/

WeaponSlot __fastcall CG_GetCurrentWeaponSlot(LocalClientNum_t localClientNum)
{
  return ?CG_GetCurrentWeaponSlot@@YA?AW4WeaponSlot@@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_ScopeIsOverlayed
==============
*/

bool __fastcall CG_Weapons_ScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_ScopeIsOverlayed@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_AddPlayerExecutionProp
==============
*/

void __fastcall CG_AddPlayerExecutionProp(LocalClientNum_t localClientNum, centity_t *cent)
{
  ?CG_AddPlayerExecutionProp@@YAXW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_Ricochet
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire_Ricochet(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, float bulletRange, int ricochetCount, bool shouldSpawnTracer, bool shouldDeferEvents)
{
  ?SimulateBulletFire_Ricochet@CgWeaponSystem@@QEAAXPEAUBulletFireParams@@HAEBUWeapon@@_NPEAUcentity_t@@AEBV?$bitarray@$0EA@@@2W4PlayerHandIndex@@VTagPair@@MH22@Z(this, bp, bulletId, weapon, isAlternate, inflictorEnt, r_attackerPerks, isPlayerWeaponView, hand, tagPair, bulletRange, ricochetCount, shouldSpawnTracer, shouldDeferEvents);
}

/*
==============
CG_Weapons_Init
==============
*/

void __fastcall CG_Weapons_Init(LocalClientNum_t localClientNum, bool isFirstInitizingClient)
{
  ?CG_Weapons_Init@@YAXW4LocalClientNum_t@@_N@Z(localClientNum, isFirstInitizingClient);
}

/*
==============
CG_PlayBulletImpactEffect
==============
*/

void __fastcall CG_PlayBulletImpactEffect(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, unsigned int targetScriptableIndex, const unsigned __int8 boneIndex, const vec3_t *position, const vec3_t *normal, const int surfType, const unsigned int impactFlags, FXRegisteredDef hitFx, const bool dismembermentAllowed)
{
  ?CG_PlayBulletImpactEffect@@YAXW4LocalClientNum_t@@HHIEAEBTvec3_t@@1HIVFXRegisteredDef@@_N@Z(localClientNum, sourceEntityNum, targetEntityNum, targetScriptableIndex, boneIndex, position, normal, surfType, impactFlags, hitFx, dismembermentAllowed);
}

/*
==============
CG_DebugBulletFireLog_Compact
==============
*/

void __fastcall CG_DebugBulletFireLog_Compact(const int serverTime)
{
  ?CG_DebugBulletFireLog_Compact@@YAXH@Z(serverTime);
}

/*
==============
CgWeaponSystem::CullBulletHitEffect
==============
*/

int __fastcall CgWeaponSystem::CullBulletHitEffect(CgWeaponSystem *this, int eventType, const vec3_t *position, const vec3_t *up, int sourceEntityNum, int targetEntityNum, unsigned int impactFlags)
{
  return ?CullBulletHitEffect@CgWeaponSystem@@IEBAHHAEBTvec3_t@@0HHI@Z(this, eventType, position, up, sourceEntityNum, targetEntityNum, impactFlags);
}

/*
==============
CG_ActionSlotDown
==============
*/

void __fastcall CG_ActionSlotDown(LocalClientNum_t localClientNum, int slot)
{
  ?CG_ActionSlotDown@@YAXW4LocalClientNum_t@@H@Z(localClientNum, slot);
}

/*
==============
CG_UpdateRecoilState
==============
*/

void __fastcall CG_UpdateRecoilState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_UpdateRecoilState@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponGetInfoStruct
==============
*/

ClientChargeWeaponInfo *__fastcall CgWeaponSystem::ChargedWeaponGetInfoStruct(CgWeaponSystem *this, const int entNum)
{
  return ?ChargedWeaponGetInfoStruct@CgWeaponSystem@@IEBAPEAUClientChargeWeaponInfo@@H@Z(this, entNum);
}

/*
==============
CG_SndAutoSimEntLastBurst
==============
*/

void __fastcall CG_SndAutoSimEntLastBurst(const centity_t *ent, const PlayerHandIndex hand)
{
  ?CG_SndAutoSimEntLastBurst@@YAXPEBUcentity_t@@W4PlayerHandIndex@@@Z(ent, hand);
}

/*
==============
CG_ViewWeaponCleanUp
==============
*/

void __fastcall CG_ViewWeaponCleanUp(const LocalClientNum_t localClientNum)
{
  ?CG_ViewWeaponCleanUp@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_SimulateBulletFire_EndPos
==============
*/

void __fastcall CG_Weapons_SimulateBulletFire_EndPos(unsigned int *randSeed, const float spreadInner, const float spreadOuter, const vec3_t *start, vec3_t *end, vec3_t *dir, const float angleMin, const float angleMax, const vec3_t *forwardDir, const vec3_t *rightDir, const vec3_t *upDir, const float maxRange)
{
  ?CG_Weapons_SimulateBulletFire_EndPos@@YAXPEAIMMAEBTvec3_t@@AEAT1@2MM111M@Z(randSeed, spreadInner, spreadOuter, start, end, dir, angleMin, angleMax, forwardDir, rightDir, upDir, maxRange);
}

/*
==============
CG_NightVisionBloomDisabled
==============
*/

bool __fastcall CG_NightVisionBloomDisabled()
{
  return ?CG_NightVisionBloomDisabled@@YA_NXZ();
}

/*
==============
MovementAnimState::GetTransitionDuration
==============
*/

void __fastcall MovementAnimState::GetTransitionDuration(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  ?GetTransitionDuration@MovementAnimState@@AEBAXW4LocalClientNum_t@@PEBUplayerState_s@@W4State@1@2PEAM3@Z(this, localClientNum, ps, prevState, nextState, outTransDurationSec, outCycleTransDurationSec);
}

/*
==============
CG_Weapons_DevWeaponReport
==============
*/

void CG_Weapons_DevWeaponReport(void)
{
  ?CG_Weapons_DevWeaponReport@@YAXXZ();
}

/*
==============
CG_CanChangeZoomLevel
==============
*/

bool __fastcall CG_CanChangeZoomLevel(LocalClientNum_t localClientNum)
{
  return ?CG_CanChangeZoomLevel@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_AddPlayerWeapon
==============
*/

void __fastcall CG_AddPlayerWeapon(LocalClientNum_t localClientNum, const vec3_t *weapOrigin, const vec4_t *weapOrient, const playerState_s *ps, const vec3_t *localPlayerGunAngles, centity_t *cent, int bDrawGun, const CgEventLodData *optionalEventLodData)
{
  ?CG_AddPlayerWeapon@@YAXW4LocalClientNum_t@@AEBTvec3_t@@AEBTvec4_t@@PEBUplayerState_s@@PEBT2@PEAUcentity_t@@HPEBUCgEventLodData@@@Z(localClientNum, weapOrigin, weapOrient, ps, localPlayerGunAngles, cent, bDrawGun, optionalEventLodData);
}

/*
==============
MovementAnimState::PlayerActionForcesWalk
==============
*/

bool __fastcall MovementAnimState::PlayerActionForcesWalk(const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  return ?PlayerActionForcesWalk@MovementAnimState@@CA_NW4LocalClientNum_t@@PEBUplayerState_s@@@Z(localClientNum, ps);
}

/*
==============
CgWeaponSystem::SimulateBulletFirePellet
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFirePellet(CgWeaponSystem *this, SimulateBulletFirePelletData *pelletFireData, bool shouldDeferEvents)
{
  ?SimulateBulletFirePellet@CgWeaponSystem@@QEAAXPEAUSimulateBulletFirePelletData@@_N@Z(this, pelletFireData, shouldDeferEvents);
}

/*
==============
CG_SndAutoSimReset
==============
*/

void CG_SndAutoSimReset(void)
{
  ?CG_SndAutoSimReset@@YAXXZ();
}

/*
==============
CG_Weapons_IsPlayerSprinting
==============
*/

bool __fastcall CG_Weapons_IsPlayerSprinting(const characterInfo_t *ci, const centity_t *cent)
{
  return ?CG_Weapons_IsPlayerSprinting@@YA_NPEBUcharacterInfo_t@@PEBUcentity_t@@@Z(ci, cent);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopSound
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopSound(CgWeaponSystem *this, const int entNum, SndAliasLookup *sndAliasLookup)
{
  ?ChargedWeaponStopSound@CgWeaponSystem@@IEBAXHPEAUSndAliasLookup@@@Z(this, entNum, sndAliasLookup);
}

/*
==============
CG_Weapons_SetupAutoComplete
==============
*/

void CG_Weapons_SetupAutoComplete(void)
{
  ?CG_Weapons_SetupAutoComplete@@YAXXZ();
}

/*
==============
CG_UpdateViewModelPoseForHand
==============
*/

void __fastcall CG_UpdateViewModelPoseForHand(DObj *obj, LocalClientNum_t localClientNum, PlayerHandIndex hand, const bool sendingToRenderer)
{
  ?CG_UpdateViewModelPoseForHand@@YAXPEAUDObj@@W4LocalClientNum_t@@W4PlayerHandIndex@@_N@Z(obj, localClientNum, hand, sendingToRenderer);
}

/*
==============
CG_Weapon_PlayADSSettleAnim
==============
*/

void __fastcall CG_Weapon_PlayADSSettleAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, float weaponPosFrac, DObj *obj, PlayerHandIndex hand, float settleAnimWeight)
{
  ?CG_Weapon_PlayADSSettleAnim@@YAXW4LocalClientNum_t@@QEBUplayerState_s@@MPEAUDObj@@W4PlayerHandIndex@@M@Z(localClientNum, ps, weaponPosFrac, obj, hand, settleAnimWeight);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopRumble
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopRumble(CgWeaponSystem *this, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponStopRumble@CgWeaponSystem@@IEBAXPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, soundRumbleInfo);
}

/*
==============
CG_MissileTrajectoryEvent
==============
*/

void __fastcall CG_MissileTrajectoryEvent(LocalClientNum_t localClientNum, centity_t *cent)
{
  ?CG_MissileTrajectoryEvent@@YAXW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::DebugDrawBulletHitLocation
==============
*/

void __fastcall CgWeaponSystem::DebugDrawBulletHitLocation(CgWeaponSystem *this)
{
  ?DebugDrawBulletHitLocation@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CgWeaponSystem::OutOfAmmoChange
==============
*/

void __fastcall CgWeaponSystem::OutOfAmmoChange(CgWeaponSystem *this, bool clipOnly)
{
  ?OutOfAmmoChange@CgWeaponSystem@@QEBAX_N@Z(this, clipOnly);
}

/*
==============
CG_SelectNthPrimaryWeapon
==============
*/

void __fastcall CG_SelectNthPrimaryWeapon(LocalClientNum_t localClientNum, int nthIndex)
{
  ?CG_SelectNthPrimaryWeapon@@YAXW4LocalClientNum_t@@H@Z(localClientNum, nthIndex);
}

/*
==============
CG_Weapons_ThermalScopeIsOverlayed
==============
*/

bool __fastcall CG_Weapons_ThermalScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_ThermalScopeIsOverlayed@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
MovementAnimState::Update
==============
*/

void __fastcall MovementAnimState::Update(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps)
{
  ?Update@MovementAnimState@@QEAAXW4LocalClientNum_t@@W4PlayerHandIndex@@PEBUplayerState_s@@@Z(this, localClientNum, hand, ps);
}

/*
==============
CG_Weapons_CalculateMovement
==============
*/

void __fastcall CG_Weapons_CalculateMovement(cg_t *cgameGlob, PlayerViewValues *viewValues, const tmat43_t<vec3_t> *viewTransform, vec3_t *outGunOffset, vec3_t *outGunAngles, vec3_t *outWeapOrigin, vec4_t *outWeapOrient)
{
  ?CG_Weapons_CalculateMovement@@YAXPEAVcg_t@@AEAUPlayerViewValues@@AEBT?$tmat43_t@Tvec3_t@@@@AEATvec3_t@@33AEATvec4_t@@@Z(cgameGlob, viewValues, viewTransform, outGunOffset, outGunAngles, outWeapOrigin, outWeapOrient);
}

/*
==============
CG_WeaponInspect
==============
*/

void __fastcall CG_WeaponInspect(LocalClientNum_t localClientNum)
{
  ?CG_WeaponInspect@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_PlayMissileProjectedConeSound
==============
*/

void __fastcall CG_PlayMissileProjectedConeSound(LocalClientNum_t localClientNum, centity_t *cent)
{
  ?CG_PlayMissileProjectedConeSound@@YAXW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::TryBulletScriptableImpact
==============
*/

void __fastcall CgWeaponSystem::TryBulletScriptableImpact(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  ?TryBulletScriptableImpact@CgWeaponSystem@@QEBAXH_NIIAEBUWeapon@@0W4meansOfDeath_t@@AEBTvec3_t@@3W4scr_string_t@@@Z(this, triggerTime, needsDeferring, inflictorEntNum, targetEntityNum, weapon, isAlternate, mod, start, hitPos, hitPartName);
}

/*
==============
CgWeaponSystem::GetIconDims
==============
*/

int __fastcall CgWeaponSystem::GetIconDims(CgWeaponSystem *this, const vec3_t *targetPos, float *x, float *y, float *w, float *h)
{
  return ?GetIconDims@CgWeaponSystem@@QEBAHAEBTvec3_t@@PEAM111@Z(this, targetPos, x, y, w, h);
}

/*
==============
CG_Weapons_ActionSlotTypeUsageAllowed
==============
*/

bool __fastcall CG_Weapons_ActionSlotTypeUsageAllowed(const cg_t *const cgameGlob, const ActionSlotType type)
{
  return ?CG_Weapons_ActionSlotTypeUsageAllowed@@YA_NQEBVcg_t@@W4ActionSlotType@@@Z(cgameGlob, type);
}

/*
==============
CG_SndKillAutoSimEntNum
==============
*/

void __fastcall CG_SndKillAutoSimEntNum(int entityNum, bool bKillAggressively)
{
  ?CG_SndKillAutoSimEntNum@@YAXH_N@Z(entityNum, bKillAggressively);
}

/*
==============
CG_Weapon_GetRecoilAnims
==============
*/

void __fastcall CG_Weapon_GetRecoilAnims(const LocalClientNum_t localClientNum, const playerState_s *const ps, weapAnimFiles_t *outRootAnim, weapAnimFiles_t *outRecoilAnim, bool *outIsAdditive)
{
  ?CG_Weapon_GetRecoilAnims@@YAXW4LocalClientNum_t@@QEBUplayerState_s@@PEAW4weapAnimFiles_t@@2PEA_N@Z(localClientNum, ps, outRootAnim, outRecoilAnim, outIsAdditive);
}

/*
==============
CG_Weapons_CurrentWeaponCanHoldBreath
==============
*/

bool __fastcall CG_Weapons_CurrentWeaponCanHoldBreath(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_CurrentWeaponCanHoldBreath@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetWeaponForName
==============
*/

Weapon *__fastcall CG_Weapons_GetWeaponForName(Weapon *result, const char *weaponName)
{
  return ?CG_Weapons_GetWeaponForName@@YA?AUWeapon@@PEBD@Z(result, weaponName);
}

/*
==============
CG_UpdateViewModelPreviousPositionForHand
==============
*/

void __fastcall CG_UpdateViewModelPreviousPositionForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  ?CG_UpdateViewModelPreviousPositionForHand@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::BulletClientAuthPhysicsImpact
==============
*/

void __fastcall CgWeaponSystem::BulletClientAuthPhysicsImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, const bool hasBulletExploded, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos)
{
  ?BulletClientAuthPhysicsImpact@CgWeaponSystem@@IEBAXIAEBUWeapon@@_N_NW4meansOfDeath_t@@AEBTvec3_t@@4@Z(this, inflictorEntNum, weapon, isAlternate, hasBulletExploded, mod, start, hitPos);
}

/*
==============
MovementAnimState::ShouldApplyQuickDescendTransition
==============
*/

bool __fastcall MovementAnimState::ShouldApplyQuickDescendTransition(const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  return ?ShouldApplyQuickDescendTransition@MovementAnimState@@CA_NW4LocalClientNum_t@@PEBUplayerState_s@@W4State@1@2AEAM3@Z(localClientNum, ps, prevState, nextState, outTransDurationSec, outCycleTransDurationSec);
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_MissEffect
==============
*/

void __fastcall CgWeaponSystem::TrySimulateBulletFire_MissEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  ?TrySimulateBulletFire_MissEffect@CgWeaponSystem@@QEBAXH_NHAEBUWeapon@@0AEBTvec3_t@@22H@Z(this, triggerTime, needsDeferring, sourceEntityNum, weapon, isAlternate, initialShootingPos, startPos, position, surfType);
}

/*
==============
CG_NightVisionShouldHideGoggles
==============
*/

bool __fastcall CG_NightVisionShouldHideGoggles(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  return ?CG_NightVisionShouldHideGoggles@@YA_NW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CAssistTarget::SetTarget
==============
*/

void __fastcall CAssistTarget::SetTarget(CAssistTarget *this, const centity_t *target)
{
  ?SetTarget@CAssistTarget@@QEAAXPEBUcentity_t@@@Z(this, target);
}

/*
==============
CgWeaponSystem::ShouldSpawnTracerFromEvent
==============
*/

bool __fastcall CgWeaponSystem::ShouldSpawnTracerFromEvent(CgWeaponSystem *this, const int eventId, const centity_t *hitEventEnt, const int attackerEntNum, const bitarray<64> *r_attackerPerks, const Weapon *weapon, bool isAlternate)
{
  return ?ShouldSpawnTracerFromEvent@CgWeaponSystem@@QEBA_NHPEBUcentity_t@@HAEBV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(this, eventId, hitEventEnt, attackerEntNum, r_attackerPerks, weapon, isAlternate);
}

/*
==============
CG_Weapons_GetWeaponViewRoughOriginIfValid
==============
*/

bool __fastcall CG_Weapons_GetWeaponViewRoughOriginIfValid(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *result)
{
  return ?CG_Weapons_GetWeaponViewRoughOriginIfValid@@YA_NW4LocalClientNum_t@@PEBUplayerState_s@@AEATvec3_t@@@Z(localClientNum, ps, result);
}

/*
==============
CG_Weapons_BuildDObj
==============
*/

void __fastcall CG_Weapons_BuildDObj(const PlayerHandIndex hand, const Weapon *r_weapon, const bool useViewModel, const bool useStowedModel, const bool useDefaultModel, const bool useDualWielding, scr_string_t attachBoneName, const unsigned int maxDObjModels, DObjModel *outDObjModels, unsigned __int16 *outModelIndex, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  ?CG_Weapons_BuildDObj@@YAXW4PlayerHandIndex@@AEBUWeapon@@_N222W4scr_string_t@@IPEAUDObjModel@@PEAGPEAVXAnimWeaponIKModelsContainer@@@Z(hand, r_weapon, useViewModel, useStowedModel, useDefaultModel, useDualWielding, attachBoneName, maxDObjModels, outDObjModels, outModelIndex, outWeaponIKModels);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateViewModelFX
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateViewModelFX(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate)
{
  ?ChargedWeaponUpdateViewModelFX@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEAUcentity_t@@AEBUWeapon@@_N@Z(this, ps, cent, weapon, isAlternate);
}

/*
==============
CgWeaponSystem::ChargedWeaponClearViewModelFX
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponClearViewModelFX(CgWeaponSystem *this, const centity_t *cent)
{
  ?ChargedWeaponClearViewModelFX@CgWeaponSystem@@IEBAXPEBUcentity_t@@@Z(this, cent);
}

/*
==============
MovementAnimState::Reset
==============
*/

void __fastcall MovementAnimState::Reset(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?Reset@MovementAnimState@@QEAAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(this, localClientNum, hand);
}

/*
==============
CG_SndUpdateAutoSim
==============
*/

void CG_SndUpdateAutoSim(void)
{
  ?CG_SndUpdateAutoSim@@YAXXZ();
}

/*
==============
CG_ActionSlotUp
==============
*/

void __fastcall CG_ActionSlotUp(LocalClientNum_t localClientNum, int slot, bool mustRelease)
{
  ?CG_ActionSlotUp@@YAXW4LocalClientNum_t@@H_N@Z(localClientNum, slot, mustRelease);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxValidate
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxValidate(CgWeaponSystem *this)
{
  ?OffhandWeaponVmFxValidate@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CgWeaponSystem::ClaimBulletId
==============
*/

int __fastcall CgWeaponSystem::ClaimBulletId(CgWeaponSystem *this)
{
  return ?ClaimBulletId@CgWeaponSystem@@QEAAHXZ(this);
}

/*
==============
MovementAnimState::GetGoalState
==============
*/

MovementAnimState::State __fastcall MovementAnimState::GetGoalState(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  return ?GetGoalState@MovementAnimState@@AEBA?AW4State@1@W4LocalClientNum_t@@PEBUplayerState_s@@@Z(this, localClientNum, ps);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_MissEffect
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire_MissEffect(CgWeaponSystem *this, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  ?SimulateBulletFire_MissEffect@CgWeaponSystem@@MEBAXHAEBUWeapon@@_NAEBTvec3_t@@22H@Z(this, sourceEntityNum, weapon, isAlternate, initialShootingPos, startPos, position, surfType);
}

/*
==============
CG_ViewmodelShieldHitsProcess
==============
*/

void __fastcall CG_ViewmodelShieldHitsProcess(LocalClientNum_t localClientNum)
{
  ?CG_ViewmodelShieldHitsProcess@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetVFXImpactType
==============
*/

int __fastcall CG_Weapons_GetVFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  return ?CG_Weapons_GetVFXImpactType@@YAHW4LocalClientNum_t@@HAEBUWeapon@@_N@Z(localClientNum, sourceEntityNum, inWeapon, isAlternate);
}

/*
==============
CgWeaponSystem::GetTargetEvaluator
==============
*/

CTargetEvaluator *__fastcall CgWeaponSystem::GetTargetEvaluator(targetAssistType_t assistType)
{
  return ?GetTargetEvaluator@CgWeaponSystem@@SAPEAVCTargetEvaluator@@W4targetAssistType_t@@@Z(assistType);
}

/*
==============
CgWeaponSystem::SpawnTracer
==============
*/

void __fastcall CgWeaponSystem::SpawnTracer(CgWeaponSystem *this, const int bulletId, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  ?SpawnTracer@CgWeaponSystem@@QEBAXH_NHAEBV?$bitarray@$0EA@@@W4PlayerHandIndex@@VTagPair@@AEBTvec3_t@@4AEBUWeapon@@0H@Z(this, bulletId, blendFromViewmodel, inflictorEntNum, r_inflictorPerks, hand, sourceTagPair, tracerStart, tracerEnd, r_weapon, isAlternate, spawnDelay);
}

/*
==============
CgWeaponSystem::TryCG_LaserBeamAdd
==============
*/

void __fastcall CgWeaponSystem::TryCG_LaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate)
{
  ?TryCG_LaserBeamAdd@CgWeaponSystem@@QEBAX_NW4LocalClientNum_t@@AEBTvec3_t@@2PEBUcentity_t@@AEBUWeapon@@_N@Z(this, needsDeferring, localClientNum, start, end, owner, weapon, isAlternate);
}

/*
==============
CgWeaponSystem::ChargedWeaponOnEmptyCharge
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnEmptyCharge(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnEmptyCharge@CgWeaponSystem@@IEBAXPEBUcentity_t@@AEBUWeapon@@_NPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, cent, weapon, isAlternate, soundRumbleInfo);
}

/*
==============
CG_OffhandGestureWeapon_SetVisibilityState
==============
*/

void __fastcall CG_OffhandGestureWeapon_SetVisibilityState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_OffhandGestureWeapon_SetVisibilityState@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdate
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdate(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel, int bDrawGun)
{
  ?ChargedWeaponUpdate@CgWeaponSystem@@QEBAXPEBUplayerState_s@@PEAUcentity_t@@AEBUWeapon@@_NHH@Z(this, ps, cent, weapon, isAlternate, bViewModel, bDrawGun);
}

/*
==============
MovementAnimState::CalcOffsetTransitionParams
==============
*/

void __fastcall MovementAnimState::CalcOffsetTransitionParams(MovementAnimState *this, const LocalClientNum_t localClientNum, const XAnimTree *const animTree, const XAnimParts *const *const animArray, const MovementAnimState::State prev, const MovementAnimState::State next, const weapAnimFiles_t prevAnim, weapAnimFiles_t *outNextAnim, float *outBlendTime, float *outPrevRate, float *outNextRate)
{
  ?CalcOffsetTransitionParams@MovementAnimState@@AEBAXW4LocalClientNum_t@@QEBUXAnimTree@@QEBQEBUXAnimParts@@W4State@1@3W4weapAnimFiles_t@@AEAW46@AEAM66@Z(this, localClientNum, animTree, animArray, prev, next, prevAnim, outNextAnim, outBlendTime, outPrevRate, outNextRate);
}

/*
==============
CG_GetFleshImpactAxis
==============
*/

void __fastcall CG_GetFleshImpactAxis(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int boneIndex, const vec3_t *position, tmat33_t<vec3_t> *outAxis)
{
  ?CG_GetFleshImpactAxis@@YAXW4LocalClientNum_t@@HHAEBTvec3_t@@AEAT?$tmat33_t@Tvec3_t@@@@@Z(localClientNum, sourceEntityNum, boneIndex, position, outAxis);
}

/*
==============
CgWeaponSystem::IsWeaponLaserOn
==============
*/

bool __fastcall CgWeaponSystem::IsWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon, const playerState_s *ps, const centity_t *cent)
{
  return ?IsWeaponLaserOn@CgWeaponSystem@@UEBA_NAEBUWeapon@@PEBUplayerState_s@@PEBUcentity_t@@@Z(this, r_weapon, ps, cent);
}

/*
==============
CG_GetTracerSpeed
==============
*/

double __fastcall CG_GetTracerSpeed(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?CG_GetTracerSpeed@@YAMV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
  return result;
}

/*
==============
CG_Weapons_ToggleEquip_OnOffhandEnd
==============
*/

void __fastcall CG_Weapons_ToggleEquip_OnOffhandEnd(LocalClientNum_t localClientNum)
{
  ?CG_Weapons_ToggleEquip_OnOffhandEnd@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_NextSlotHasWeapons
==============
*/

bool __fastcall CG_NextSlotHasWeapons(LocalClientNum_t localClientNum)
{
  return ?CG_NextSlotHasWeapons@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetVehicleViewOrigin
==============
*/

bool __fastcall CG_Weapons_GetVehicleViewOrigin(const LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *outOrigin)
{
  return ?CG_Weapons_GetVehicleViewOrigin@@YA_NW4LocalClientNum_t@@PEBUplayerState_s@@AEATvec3_t@@@Z(localClientNum, ps, outOrigin);
}

/*
==============
CgWeaponSystem::SimulateImpactEffectForBeamWeapons
==============
*/

void __fastcall CgWeaponSystem::SimulateImpactEffectForBeamWeapons(CgWeaponSystem *this, const int attackerEntNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *victimEnt, const BulletFireParams *bp, const vec3_t *bulletEndPos, const bool shouldDeferEvents, vec3_t *outImpactPos)
{
  ?SimulateImpactEffectForBeamWeapons@CgWeaponSystem@@QEBAXHAEBUWeapon@@_NPEBUcentity_t@@PEBUBulletFireParams@@AEBTvec3_t@@1AEAT5@@Z(this, attackerEntNum, r_weapon, isAlternate, victimEnt, bp, bulletEndPos, shouldDeferEvents, outImpactPos);
}

/*
==============
CG_UpdateHandViewmodels
==============
*/

void __fastcall CG_UpdateHandViewmodels(LocalClientNum_t localClientNum, XModel *handModel)
{
  ?CG_UpdateHandViewmodels@@YAXW4LocalClientNum_t@@PEAUXModel@@@Z(localClientNum, handModel);
}

/*
==============
CG_SndKillAutoSimEnt
==============
*/

void __fastcall CG_SndKillAutoSimEnt(centity_t *ent, bool bKillAggressively)
{
  ?CG_SndKillAutoSimEnt@@YAXPEAUcentity_t@@_N@Z(ent, bKillAggressively);
}

/*
==============
CG_Weapons_CurrentWeaponCanHybridToggle
==============
*/

bool __fastcall CG_Weapons_CurrentWeaponCanHybridToggle(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_CurrentWeaponCanHybridToggle@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::DrawFriendOrFoeTargetBoxes
==============
*/

void __fastcall CgWeaponSystem::DrawFriendOrFoeTargetBoxes(CgWeaponSystem *this)
{
  ?DrawFriendOrFoeTargetBoxes@CgWeaponSystem@@UEBAXXZ(this);
}

/*
==============
CG_MeleeBloodEvent
==============
*/

void __fastcall CG_MeleeBloodEvent(LocalClientNum_t localClientNum, int attackerEntityNum)
{
  ?CG_MeleeBloodEvent@@YAXW4LocalClientNum_t@@H@Z(localClientNum, attackerEntityNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllEffects
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopAllEffects(CgWeaponSystem *this, const centity_t *cent)
{
  ?ChargedWeaponStopAllEffects@CgWeaponSystem@@QEBAXPEBUcentity_t@@@Z(this, cent);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateWeaponType
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateWeaponType(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel)
{
  ?ChargedWeaponUpdateWeaponType@CgWeaponSystem@@IEBAXPEBUcentity_t@@AEBUWeapon@@_NH@Z(this, cent, weapon, isAlternate, bViewModel);
}

/*
==============
CG_Weapons_BuildStickerSlotList
==============
*/

DObjStickerSlotList *__fastcall CG_Weapons_BuildStickerSlotList(DObjStickerSlotList *result, const LocalClientNum_t localClientNum, const CharacterModelType *modelTypesToApply, const int modelTypesToApplyCount, const Weapon *weapon)
{
  return ?CG_Weapons_BuildStickerSlotList@@YA?AUDObjStickerSlotList@@W4LocalClientNum_t@@QEBW4CharacterModelType@@HAEBUWeapon@@@Z(result, localClientNum, modelTypesToApply, modelTypesToApplyCount, weapon);
}

/*
==============
CG_Weapons_CreateWeaponPhysics
==============
*/

void __fastcall CG_Weapons_CreateWeaponPhysics(LocalClientNum_t localClientNum, int clientNum)
{
  ?CG_Weapons_CreateWeaponPhysics@@YAXW4LocalClientNum_t@@H@Z(localClientNum, clientNum);
}

/*
==============
CgWeaponSystem::BulletWhizbySound
==============
*/

void __fastcall CgWeaponSystem::BulletWhizbySound(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, const vec3_t *start, const vec3_t *end)
{
  ?BulletWhizbySound@CgWeaponSystem@@QEBAXAEBUWeapon@@_NAEBTvec3_t@@2@Z(this, weapon, isAlternate, start, end);
}

/*
==============
CgWeaponSystem::SimulateBulletFire
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire(CgWeaponSystem *this, int eventId, centity_t *inflictorEnt, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const TagPair tagPair, bool isPlayerView, bool isPlayerWeaponView, PlayerHandIndex hand, const int fireSequenceIndex, const CgEventLodData *optionalEventLod, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  ?SimulateBulletFire@CgWeaponSystem@@IEAAXHPEAUcentity_t@@HAEBUWeapon@@_NVTagPair@@22W4PlayerHandIndex@@HPEBUCgEventLodData@@PEBUCgFireEventHighPrecisionData@@@Z(this, eventId, inflictorEnt, knownHitClientNum, weapon, isAlternate, tagPair, isPlayerView, isPlayerWeaponView, hand, fireSequenceIndex, optionalEventLod, highPrecisionFireData);
}

/*
==============
CG_Weapons_PrecacheMedia
==============
*/

void CG_Weapons_PrecacheMedia(void)
{
  ?CG_Weapons_PrecacheMedia@@YAXXZ();
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_HitEffect
==============
*/

void __fastcall CgWeaponSystem::TrySimulateBulletFire_HitEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  ?TrySimulateBulletFire_HitEffect@CgWeaponSystem@@QEBAXH_NHHIHAEBUWeapon@@0AEBTvec3_t@@222HIIH_N@Z(this, triggerTime, needsDeferring, sourceEntityNum, targetEntityNum, targetScriptableIndex, knownHitClientNum, weapon, isAlternate, initialShootingPos, startPos, position, normal, surfType, meansOfDeath, impactEffects, hitContents, forceClientSideHandling);
}

/*
==============
CG_NightVisionGetBloomTimings
==============
*/

void __fastcall CG_NightVisionGetBloomTimings(const int NVGToggleTime, const bool isOn, const bool isInstant, int *outBloomStartBlendInTime, int *outBloomStartBlendOutTime, int *outBlendInDuration, int *outBlendOutDuration)
{
  ?CG_NightVisionGetBloomTimings@@YAXH_N0PEAH111@Z(NVGToggleTime, isOn, isInstant, outBloomStartBlendInTime, outBloomStartBlendOutTime, outBlendInDuration, outBlendOutDuration);
}

/*
==============
CG_GetTransitionToThrowBlendTime
==============
*/
void CG_GetTransitionToThrowBlendTime(const LocalClientNum_t localClientNum, const Weapon *r_weapon, const playerState_s *const ps, const WeaponAnimNumber blendOutAnim, const unsigned int blendOutAnimIndex, const WeaponAnimNumber blendInAnim, const unsigned int blendInAnimIndex, float *blendOutTime, float *blendInTime)
{
  cg_t *LocalClientGlobals; 
  int WeaponFieldTime; 
  int v14; 
  int v15; 
  unsigned __int16 v16; 
  float v17; 
  float v18; 
  int v19; 
  const DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  double Time; 
  float v23; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( blendOutAnim == WEAP_ALTSWITCHTO )
  {
    WeaponFieldTime = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 350i64);
    v14 = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 348i64);
    v15 = BG_AltRaiseTime(ps, r_weapon, 0, 0);
    v16 = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 334i64);
  }
  else
  {
    WeaponFieldTime = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 346i64);
    v14 = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 344i64);
    v15 = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 16i64);
    v16 = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 342i64);
  }
  v17 = (float)v15;
  v18 = (float)v14 * 0.001;
  v19 = v16;
  if ( (float)v15 <= 0.0 || v16 > v15 )
  {
    *blendOutTime = 0;
    *blendInTime = 0;
  }
  else
  {
    if ( !LocalClientGlobals->m_weaponHand[0].viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1462, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
      __debugbreak();
    viewModelDObj = LocalClientGlobals->m_weaponHand[0].viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1465, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1468, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    Time = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, blendOutAnimIndex);
    v23 = (float)v19 / v17;
    if ( *(float *)&Time > v23 )
      v18 = (float)((float)(1.0 - (float)((float)(*(float *)&Time - v23) / (float)(1.0 - v23))) * (float)(v18 - (float)((float)WeaponFieldTime * 0.001))) + (float)((float)WeaponFieldTime * 0.001);
    *blendOutTime = v18;
    *blendInTime = v18;
  }
}

/*
==============
CConeTargetEvaluator::FindTargets
==============
*/
int CConeTargetEvaluator::FindTargets(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *attacker, const vec3_t *bulletStart, const vec3_t *bulletDir, float range, float spread, int maxTargets, const bool isBeamWeapon, const unsigned int hitLocMask, const int gameTime, const bool isFiring, ntl::fixed_array<CAssistTarget,20> *outTargetArray)
{
  __int64 v15; 
  const centity_t *v16; 
  float v17; 
  int v18; 
  CgTargetAssist *Instance; 
  __int64 v20; 
  __int64 v21; 
  unsigned __int64 v22; 
  const centity_t **p_m_target; 
  __int64 v24; 
  CgEntitySystem *v25; 
  __int64 v26; 
  unsigned int v27; 
  unsigned int v28; 
  unsigned int v29; 
  DObj *v30; 
  void (__fastcall *FunctionPointer_origin)(const vec4_t *, vec3_t *); 
  __int128 v35; 
  char *v45; 
  ConeTargetHitResults *p_outSearchResults; 
  __int64 v47; 
  ConeTargetHitResults *HitResults; 
  char *v49; 
  __int64 v50; 
  cg_t *LocalClientGlobals; 
  GHandler *Handler; 
  tmat33_t<vec3_t> *p_m_axis; 
  __int16 attackerEntNum; 
  CgHandler *v55; 
  char *fmt; 
  __int64 targetCount; 
  tmat33_t<vec3_t> *bulletAxis; 
  int v61; 
  __int64 v62[2]; 
  const centity_t *v63; 
  unsigned int v64; 
  vec3_t *forward; 
  BgTargetAssist *v66; 
  vec3_t *v67; 
  ntl::fixed_array<CAssistTarget,20> *inOutTargetArray; 
  Weapon *r_weapona; 
  __int64 v70; 
  char v71[840]; 
  BGConeTargetBoneSearchParam searchParam; 
  WorldUpReferenceFrame axis; 
  tmat33_t<vec3_t> outAxis; 
  ConeTargetHitResults outSearchResults; 

  v70 = -2i64;
  r_weapona = (Weapon *)r_weapon;
  v15 = localClientNum;
  v16 = attacker;
  v63 = attacker;
  v67 = (vec3_t *)bulletStart;
  forward = (vec3_t *)bulletDir;
  inOutTargetArray = outTargetArray;
  if ( !attacker && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25686, ASSERT_TYPE_ASSERT, "( attacker )", (const char *)&queryFormat, "attacker") )
    __debugbreak();
  v17 = cosf_0(spread * 0.017453292);
  v18 = 0;
  Instance = CgTargetAssist::GetInstance((const LocalClientNum_t)v15);
  v66 = Instance;
  v20 = 0xFFFFFFFFi64;
  LOWORD(v61) = 2047;
  v21 = v15;
  v22 = 0i64;
  p_m_target = &outTargetArray->m_data[0].m_target;
  while ( 1 )
  {
    LODWORD(fmt) = gameTime;
    v64 = Instance->FindNextTarget(Instance, (const LocalClientNum_t)v15, v16->nextState.number, v20, (const int)fmt, (__int16 *)&v61);
    if ( v64 == 0x7FFFFFFF )
      break;
    v24 = (__int16)v61;
    if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
    {
      LODWORD(bulletAxis) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", bulletAxis) )
        __debugbreak();
    }
    if ( (unsigned int)v15 >= CgEntitySystem::ms_allocatedCount )
    {
      LODWORD(bulletAxis) = CgEntitySystem::ms_allocatedCount;
      LODWORD(targetCount) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", targetCount, bulletAxis) )
        __debugbreak();
    }
    if ( !CgEntitySystem::ms_entitySystemArray[v21] )
    {
      LODWORD(bulletAxis) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", bulletAxis) )
        __debugbreak();
    }
    v25 = CgEntitySystem::ms_entitySystemArray[v21];
    if ( (unsigned int)v24 >= 0x800 )
    {
      LODWORD(bulletAxis) = 2048;
      LODWORD(targetCount) = v24;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", targetCount, bulletAxis) )
        __debugbreak();
    }
    v26 = (__int64)&v25->m_entities[v24];
    if ( (*(_BYTE *)(v26 + 648) & 1) != 0 )
    {
      v27 = *(__int16 *)(v26 + 400);
      if ( v27 > 0x9E4 )
      {
        LODWORD(bulletAxis) = *(__int16 *)(v26 + 400);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 55, ASSERT_TYPE_ASSERT, "( ( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) ) )", "%s\n\t( handle ) = %i", "( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) )", bulletAxis) )
          __debugbreak();
      }
      if ( (unsigned int)v15 >= 2 )
      {
        LODWORD(bulletAxis) = 2;
        LODWORD(targetCount) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 58, ASSERT_TYPE_ASSERT, "(unsigned)( localClientIndex ) < (unsigned)( (2) )", "localClientIndex doesn't index MAX_DOBJ_CLIENTS\n\t%i not in [0, %i)", targetCount, bulletAxis) )
          __debugbreak();
      }
      v28 = 2533 * v15 + v27;
      if ( v28 >= 0x13CA )
      {
        LODWORD(bulletAxis) = v28;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 62, ASSERT_TYPE_ASSERT, "( ( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) ) )", "%s\n\t( handle ) = %i", "( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) )", bulletAxis) )
          __debugbreak();
      }
      v29 = clientObjMap[v28];
      if ( v29 )
      {
        if ( v29 >= (unsigned int)s_objCount )
        {
          LODWORD(bulletAxis) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 64, ASSERT_TYPE_ASSERT, "( ( !objIndex || ( (unsigned)objIndex < s_objCount ) ) )", "%s\n\t( objIndex ) = %i", "( !objIndex || ( (unsigned)objIndex < s_objCount ) )", bulletAxis) )
            __debugbreak();
        }
        v30 = (DObj *)s_objBuf[v29];
        if ( v30 && DObjGetFirstModel(v30) )
        {
          AnglesToAxis((const vec3_t *)(v26 + 72), (tmat33_t<vec3_t> *)&axis);
          if ( !*(_QWORD *)(v26 + 48) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 380, ASSERT_TYPE_ASSERT, "(pose->origin.Get_origin)", (const char *)&queryFormat, "pose->origin.Get_origin") )
            __debugbreak();
          FunctionPointer_origin = ObfuscateGetFunctionPointer_origin(*(void (__fastcall *const *)(const vec4_t *, vec3_t *))(v26 + 48), (const cpose_t *)v26);
          FunctionPointer_origin((const vec4_t *)(v26 + 56), (vec3_t *)v62);
          if ( *(_BYTE *)(v26 + 2) )
          {
            _XMM0 = LODWORD(v62[0]);
            __asm { vcvtdq2pd xmm0, xmm0 }
            *((_QWORD *)&v35 + 1) = *((_QWORD *)&_XMM0 + 1);
            *(double *)&v35 = *(double *)&_XMM0 * 0.000244140625;
            _XMM1 = v35;
            __asm { vcvtsd2ss xmm3, xmm1, xmm1 }
            _XMM2 = HIDWORD(v62[0]);
            __asm { vcvtdq2pd xmm2, xmm2 }
            *((_QWORD *)&v35 + 1) = *((_QWORD *)&_XMM2 + 1);
            *(double *)&v35 = *(double *)&_XMM2 * 0.000244140625;
            _XMM0 = v35;
            __asm { vcvtsd2ss xmm4, xmm0, xmm0 }
            _XMM1 = LODWORD(v62[1]);
            __asm { vcvtdq2pd xmm1, xmm1 }
            *((_QWORD *)&v35 + 1) = *((_QWORD *)&_XMM1 + 1);
            *(double *)&v35 = *(double *)&_XMM1 * 0.000244140625;
            _XMM2 = v35;
            __asm { vcvtsd2ss xmm5, xmm2, xmm2 }
          }
          else
          {
            LODWORD(_XMM5) = v62[1];
            LODWORD(_XMM4) = HIDWORD(v62[0]);
            LODWORD(_XMM3) = v62[0];
          }
          *(float *)v62 = (float)(int)*(float *)&_XMM3;
          *((float *)v62 + 1) = (float)(int)*(float *)&_XMM4;
          *(float *)&v62[1] = (float)(int)*(float *)&_XMM5;
          memset_0(&searchParam, 0, sizeof(searchParam));
          searchParam.pmoveHandler = CgHandler::getHandler((LocalClientNum_t)v15);
          searchParam.es = (const entityState_t *)(v26 + 400);
          searchParam.entityDobj = v30;
          searchParam.entityOrigin.v[0] = *(float *)v62;
          searchParam.entityOrigin.v[1] = *((float *)v62 + 1);
          searchParam.entityOrigin.v[2] = *(float *)&v62[1];
          AxisCopy((const tmat33_t<vec3_t> *)&axis, &searchParam.entityAxis);
          searchParam.pmoveHandler = CgHandler::getHandler((LocalClientNum_t)v15);
          searchParam.bulletStart = *v67;
          searchParam.bulletDir = *forward;
          searchParam.bulletRange = range;
          searchParam.maxDot = v17;
          searchParam.hitLocMask = hitLocMask;
          searchParam.localClientNum = v15;
          searchParam.isFiring = isFiring;
          if ( BgTargetAssist::FindBonesWithinCone(v66, &searchParam, &outSearchResults) )
          {
            v45 = v71;
            p_outSearchResults = &outSearchResults;
            v47 = 6i64;
            do
            {
              *(__m256i *)v45 = *(__m256i *)p_outSearchResults->hits[0].tagWorldPos.v;
              *((__m256i *)v45 + 1) = *(__m256i *)&p_outSearchResults->hits[0].tagWorldRot.row1.z;
              *((__m256i *)v45 + 2) = *(__m256i *)&p_outSearchResults->hits[0].priority;
              *((_OWORD *)v45 + 6) = *(_OWORD *)&p_outSearchResults->hits[1].tagWorldRot.row1.y;
              v45 += 128;
              *((_OWORD *)v45 - 1) = *(_OWORD *)&p_outSearchResults->hits[1].tagWorldRot.row2.z;
              p_outSearchResults = (ConeTargetHitResults *)((char *)p_outSearchResults + 128);
              --v47;
            }
            while ( v47 );
            *(__m256i *)v45 = *(__m256i *)p_outSearchResults->hits[0].tagWorldPos.v;
            *((_OWORD *)v45 + 2) = *(_OWORD *)&p_outSearchResults->hits[0].tagWorldRot.row1.z;
            *((_QWORD *)v45 + 6) = *(_QWORD *)&p_outSearchResults->hits[0].tagName;
            *((_DWORD *)v45 + 14) = p_outSearchResults->hits[0].modelIndex;
            if ( (unsigned __int64)v18 >= 0x14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\array\\fixed_array.h", 87, ASSERT_TYPE_ASSERT, "( index < size() )", (const char *)&queryFormat, "index < size()") )
              __debugbreak();
            HitResults = ConeTargetInfo::GetHitResults(&inOutTargetArray->m_data[v18]);
            v49 = v71;
            v50 = 6i64;
            do
            {
              *(__m256i *)HitResults->hits[0].tagWorldPos.v = *(__m256i *)v49;
              *(__m256i *)&HitResults->hits[0].tagWorldRot.row1.z = *((__m256i *)v49 + 1);
              *(__m256i *)&HitResults->hits[0].priority = *((__m256i *)v49 + 2);
              *(_OWORD *)&HitResults->hits[1].tagWorldRot.row1.y = *((_OWORD *)v49 + 6);
              HitResults = (ConeTargetHitResults *)((char *)HitResults + 128);
              *(_OWORD *)&HitResults[-1].hits[11].priority = *((_OWORD *)v49 + 7);
              v49 += 128;
              --v50;
            }
            while ( v50 );
            *(__m256i *)HitResults->hits[0].tagWorldPos.v = *(__m256i *)v49;
            *(_OWORD *)&HitResults->hits[0].tagWorldRot.row1.z = *((_OWORD *)v49 + 2);
            *(_QWORD *)&HitResults->hits[0].tagName = *((_QWORD *)v49 + 6);
            HitResults->hits[0].modelIndex = *((_DWORD *)v49 + 14);
            if ( v22 >= 0x14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\array\\fixed_array.h", 87, ASSERT_TYPE_ASSERT, "( index < size() )", (const char *)&queryFormat, "index < size()") )
              __debugbreak();
            *p_m_target = (const centity_t *)v26;
            ++v18;
            ++v22;
            p_m_target += 106;
          }
          memset(v62, 0, 0xCui64);
        }
      }
      v16 = v63;
    }
    v20 = v64;
    v21 = v15;
    if ( (unsigned int)v18 >= 0x14 )
      break;
    Instance = (CgTargetAssist *)v66;
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v15);
  if ( LocalClientGlobals->predictedPlayerState.clientNum == v16->nextState.number )
  {
    Handler = GHandler::getHandler();
    WorldUpReferenceFrame::WorldUpReferenceFrame(&axis, &LocalClientGlobals->predictedPlayerState, Handler);
    p_m_axis = &axis.m_axis;
  }
  else
  {
    MatrixIdentity33((tmat33_t<vec3_t> *)&axis);
    p_m_axis = (tmat33_t<vec3_t> *)&axis;
  }
  GenerateAxisFromForwardVector(forward, p_m_axis, &outAxis);
  attackerEntNum = v16->nextState.number;
  v55 = CgHandler::getHandler((LocalClientNum_t)v15);
  return BgTargetAssist::EvaluateTargetsWithinCone<CAssistTarget>(v66, v55, r_weapona, isAlternate, inOutTargetArray, v18, &outAxis, v67, maxTargets, attackerEntNum, (const Physics_WorldId)(3 * v15 + 4), isFiring);
}

/*
==============
CConeTargetEvaluator::EvaluateTarget
==============
*/
bool CConeTargetEvaluator::EvaluateTarget(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const CAssistTarget *assistTarget, const vec3_t *bulletStart, float range, vec3_t *outBulletEnd, vec3_t *outBulletDir)
{
  ConeTargetHitResults *HitResults; 
  const ConeTargetHitInfo *FirstVisibleHit; 
  ConeTargetHitResults *v11; 
  float v12; 
  float v13; 
  __int128 v14; 
  float v15; 

  if ( !assistTarget && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25773, ASSERT_TYPE_ASSERT, "(assistTarget)", (const char *)&queryFormat, "assistTarget") )
    __debugbreak();
  HitResults = (ConeTargetHitResults *)ConeTargetInfo::GetHitResults(&assistTarget->ConeTargetInfo);
  FirstVisibleHit = ConeTargetHitResults::GetFirstVisibleHit(HitResults);
  if ( FirstVisibleHit )
  {
    v11 = (ConeTargetHitResults *)ConeTargetInfo::GetHitResults(&assistTarget->ConeTargetInfo);
    FirstVisibleHit = ConeTargetHitResults::GetFirstVisibleHit(v11);
    v12 = FirstVisibleHit->tagWorldPos.v[0] - bulletStart->v[0];
    v14 = LODWORD(FirstVisibleHit->tagWorldPos.v[1]);
    v13 = FirstVisibleHit->tagWorldPos.v[1] - bulletStart->v[1];
    v15 = FirstVisibleHit->tagWorldPos.v[2] - bulletStart->v[2];
    *(float *)&v14 = fsqrt((float)((float)(v13 * v13) + (float)(v12 * v12)) + (float)(v15 * v15));
    _XMM4 = v14;
    __asm
    {
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm1, xmm0
    }
    LOBYTE(FirstVisibleHit) = 1;
    outBulletDir->v[1] = (float)(1.0 / *(float *)&_XMM0) * v13;
    outBulletDir->v[2] = (float)(1.0 / *(float *)&_XMM0) * v15;
    *(float *)&v14 = (float)(1.0 / *(float *)&_XMM0) * v12;
    outBulletDir->v[0] = *(float *)&v14;
    outBulletEnd->v[0] = (float)(*(float *)&v14 * range) + bulletStart->v[0];
    outBulletEnd->v[1] = (float)(range * outBulletDir->v[1]) + bulletStart->v[1];
    outBulletEnd->v[2] = (float)(range * outBulletDir->v[2]) + bulletStart->v[2];
  }
  return (char)FirstVisibleHit;
}

/*
==============
CgWeaponSystem::AddDebugBulletLine
==============
*/
void CgWeaponSystem::AddDebugBulletLine(CgWeaponSystem *this, const vec3_t *start, const vec3_t *end)
{
  volatile int *p_m_numBulletDebugLines; 
  __int64 v7; 
  int v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 

  p_m_numBulletDebugLines = &this->m_numBulletDebugLines;
  v7 = ((_BYTE)this - 52) & 3;
  if ( (((_BYTE)this - 52) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &this->m_numBulletDebugLines) )
    __debugbreak();
  v8 = _InterlockedExchangeAdd(p_m_numBulletDebugLines, 1u);
  if ( v8 < 200 )
  {
    v9 = 2 * v8;
    v10 = 3 * v9 + 3;
    *((_DWORD *)&this->__vftable + v10) = LODWORD(start->v[0]);
    *((_DWORD *)&this->__vftable + v10 + 1) = LODWORD(start->v[1]);
    *((_DWORD *)&this->m_localClientNum + v10) = LODWORD(start->v[2]);
    v11 = 3 * v9 + 6;
    *((_DWORD *)&this->__vftable + v11) = LODWORD(end->v[0]);
    *((_DWORD *)&this->__vftable + v11 + 1) = LODWORD(end->v[1]);
    *((_DWORD *)&this->m_localClientNum + v11) = LODWORD(end->v[2]);
  }
  else
  {
    if ( v7 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)p_m_numBulletDebugLines) )
        __debugbreak();
    }
    _InterlockedDecrement(p_m_numBulletDebugLines);
  }
}

/*
==============
BlendViewModelAnimIfPlaying
==============
*/
void BlendViewModelAnimIfPlaying(DObj *obj, weapAnimFiles_t blendOutAnim, weapAnimFiles_t blendInAnim, float blendOutTime, float blendInTime)
{
  const dvar_t *v5; 
  const XAnimTree *Tree; 
  double Weight; 
  double GoalTime; 

  v5 = DCONST_DVARBOOL_cg_viewmodelAnimBlending;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimBlending && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimBlending") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.enabled )
  {
    if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3252, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(obj);
    Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, blendOutAnim);
    if ( *(float *)&Weight > 0.0 )
    {
      GoalTime = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, blendOutAnim);
      if ( *(float *)&GoalTime == 0.0 )
      {
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, blendOutAnim, 0.0, blendOutTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, blendInAnim, 1.0, blendInTime, 0.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      }
    }
  }
}

/*
==============
CgWeaponSystem::BloodSplatterOnShield
==============
*/
void CgWeaponSystem::BloodSplatterOnShield(CgWeaponSystem *this, int entityNum)
{
  centity_t *Entity; 
  centity_t *v5; 
  LocalClientNum_t m_localClientNum; 
  const DObj *ClientDObj; 
  float v8; 
  LocalClientNum_t v9; 
  const Material *markMaterialOverride; 
  cg_t *LocalClientGlobals; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> forward; 
  vec3_t outPos; 

  if ( (unsigned int)(entityNum - 2046) > 1 )
  {
    if ( cgMedia.fxBloodOnRiotshield.m_particleSystemDef )
    {
      Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, entityNum);
      v5 = Entity;
      if ( (Entity->flags & 1) != 0 )
      {
        AnglesToAxis(&Entity->pose.angles, &axis);
        LODWORD(forward.m[0].v[0]) = LODWORD(axis.m[0].v[0]) ^ _xmm;
        LODWORD(forward.m[0].v[2]) = LODWORD(axis.m[0].v[2]) ^ _xmm;
        LODWORD(forward.m[0].v[1]) = LODWORD(axis.m[0].v[1]) ^ _xmm;
        AxisRandomAroundForward(forward.m, &forward.m[1], &forward.m[2]);
        CG_GetPoseOrigin(&v5->pose, &outOrigin);
        m_localClientNum = this->m_localClientNum;
        if ( (v5->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20503, ASSERT_TYPE_ASSERT, "(CENextValid( targetEnt ))", (const char *)&queryFormat, "CENextValid( targetEnt )") )
          __debugbreak();
        ClientDObj = Com_GetClientDObj(v5->nextState.number, m_localClientNum);
        if ( ClientDObj && CG_DObjGetWorldTagPos(&v5->pose, ClientDObj, scr_const.tag_weapon_left, &outPos) )
          v8 = outPos.v[2];
        else
          v8 = FLOAT_40_0;
        v9 = this->m_localClientNum;
        markMaterialOverride = MARK_MATERIAL_OVERRIDE_NONE_2;
        outOrigin.v[0] = (float)(10.0 * axis.m[0].v[0]) + outOrigin.v[0];
        outOrigin.v[1] = (float)(10.0 * axis.m[0].v[1]) + outOrigin.v[1];
        outOrigin.v[2] = (float)(10.0 * axis.m[0].v[2]) + v8;
        LocalClientGlobals = CG_GetLocalClientGlobals(v9);
        FX_PlayOrientedEffectWithMarkEntity(this->m_localClientNum, &cgMedia.fxBloodOnRiotshield, LocalClientGlobals->time, &outOrigin, &forward, 0, entityNum, 1, 0xFEu, markMaterialOverride);
      }
    }
  }
}

/*
==============
CgWeaponSystem::BulletClientAuthPhysicsImpact
==============
*/
void CgWeaponSystem::BulletClientAuthPhysicsImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, const bool hasBulletExploded, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos)
{
  double ExplDmg; 
  float Damage; 
  double ExplRadius; 
  float v15; 
  double ExplDmgMin; 
  float v17; 
  cg_t *LocalClientGlobals; 
  double v19; 

  if ( hasBulletExploded )
  {
    ExplDmg = BG_WeaponBulletFire_GetExplDmg(weapon, isAlternate);
    Damage = *(float *)&ExplDmg;
  }
  else
  {
    Damage = (float)BG_GetDamage(WEAP_DMG_CALC_TYPE_DEFAULT, weapon, isAlternate);
  }
  Physics_AddDeferredBulletForce((const Physics_WorldId)(3 * this->m_localClientNum + 3), start, hitPos, inflictorEntNum, 0, weapon, isAlternate, mod, CG_BulletHitEffectCallback);
  if ( hasBulletExploded )
  {
    ExplRadius = BG_WeaponBulletFire_GetExplRadius(weapon, isAlternate);
    v15 = *(float *)&ExplRadius;
    ExplDmgMin = BG_WeaponBulletFire_GetExplDmgMin(weapon, isAlternate);
    v17 = *(float *)&ExplDmgMin;
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    v19 = BG_ExplosionForceScalar(weapon, isAlternate);
    Physics_AddDeferredRadiusForce((const Physics_WorldId)(3 * this->m_localClientNum + 3), hitPos, v15, Damage, v17, 0.0, &vec3_origin, LocalClientGlobals->time, *(float *)&v19);
  }
}

/*
==============
BulletHitClientEventSound
==============
*/
void BulletHitClientEventSound(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *hitPosition, int surfType, int event, unsigned int impactEffects, SndHitArmorType hitArmorType)
{
  cg_t *LocalClientGlobals; 
  __int64 ImpactSoundHitLocation; 
  WeaponSFXPackage *SfxPackage; 
  SfxImpactGroup *p_npcImpactSounds; 
  SndAliasList *bulletExplodeSound; 
  bool v18; 
  const dvar_t *v19; 
  meansOfDeath_t MethodOfDeath; 
  bool ShouldRicochet; 
  bool v22; 
  centity_t *Entity; 
  float v24; 
  float v25; 
  float v26; 
  __int128 v27; 
  float v28; 
  float v29; 
  float v30; 
  double Float_Internal_DebugName; 
  CgSoundSystem *SoundSystem; 
  int fxImpactType; 
  vec3_t outOrg; 
  unsigned int clientNum; 
  vec3_t outOrigin; 
  __int64 v41; 
  vec3_t v42; 
  bitarray<64> outPerks; 

  v41 = -2i64;
  if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20559, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20562, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
  ImpactSoundHitLocation = CG_GetImpactSoundHitLocation(localClientNum, clientNum, impactEffects);
  SfxPackage = BG_GetSfxPackage(weapon, isAlternate);
  fxImpactType = CG_Main_RegisteredImpactTypeToImpactType(UNKNOWN);
  if ( SfxPackage )
    fxImpactType = SfxPackage->sfxImpactType;
  CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, &fxImpactType);
  p_npcImpactSounds = &cgMedia.npcImpactSounds;
  if ( CG_IsPlayerEntityNumber(&LocalClientGlobals->predictedPlayerState, sourceEntityNum) )
    p_npcImpactSounds = &cgMedia.playerImpactSounds;
  switch ( CG_Main_ImpactTypeToRegisteredImpactType(fxImpactType) )
  {
    case 1:
    case 2:
      bulletExplodeSound = cgMedia.fleshBulletSmall.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 3:
    case 4:
      bulletExplodeSound = cgMedia.fleshBulletLarge.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 5:
      bulletExplodeSound = cgMedia.fleshBulletExplode.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 6:
      bulletExplodeSound = cgMedia.fleshShotgun.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 7:
      bulletExplodeSound = p_npcImpactSounds->bulletExplodeSound;
      goto LABEL_36;
    case 10:
      bulletExplodeSound = cgMedia.grenadeExplodeSound;
      goto LABEL_36;
    case 12:
      bulletExplodeSound = cgMedia.rocketExplodeSound;
      goto LABEL_36;
    case 13:
      bulletExplodeSound = cgMedia.rocketExplodeSoundSmall;
      goto LABEL_36;
    case 14:
      v18 = isAlternate;
      bulletExplodeSound = (SndAliasList *)BG_ProjDudSound(weapon, isAlternate);
      goto LABEL_37;
    case 15:
      bulletExplodeSound = cgMedia.fleshVehBullet.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 16:
      bulletExplodeSound = cgMedia.fleshVehBulletExplode.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 17:
      bulletExplodeSound = cgMedia.vehMissileExplodeSound;
      goto LABEL_36;
    case 19:
      bulletExplodeSound = cgMedia.fleshArcaneRed.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 21:
      bulletExplodeSound = cgMedia.fleshArcaneYellow.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 22:
      bulletExplodeSound = cgMedia.fleshArcanePink.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 23:
      bulletExplodeSound = cgMedia.fleshArcaneBlue.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 25:
      bulletExplodeSound = cgMedia.fleshRock1.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 26:
      bulletExplodeSound = cgMedia.fleshRock2.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 27:
      bulletExplodeSound = cgMedia.fleshRock3.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 28:
      bulletExplodeSound = cgMedia.fleshRock4.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 29:
      bulletExplodeSound = cgMedia.fleshDLC1.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 30:
      bulletExplodeSound = cgMedia.fleshDLC2.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 31:
      bulletExplodeSound = cgMedia.fleshDLC3.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 32:
      bulletExplodeSound = cgMedia.fleshDLC4.player[ImpactSoundHitLocation][hitArmorType];
LABEL_36:
      v18 = isAlternate;
LABEL_37:
      v42 = *hitPosition;
      v19 = DCONST_DVARMPBOOL_cg_adjustClientImpactSound;
      if ( !DCONST_DVARMPBOOL_cg_adjustClientImpactSound && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_adjustClientImpactSound") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v19);
      if ( v19->current.enabled )
      {
        CG_GetPerks(localClientNum, sourceEntityNum, &outPerks);
        MethodOfDeath = BG_WeaponBulletFire_GetMethodOfDeath(outPerks, weapon, v18);
        ShouldRicochet = BG_WeaponBulletFire_ShouldRicochet(outPerks, weapon, v18);
        v22 = ((MethodOfDeath - 1) & 0xFFFFFFF6) == 0 && MethodOfDeath != MOD_MELEE_DOG;
        if ( !ShouldRicochet && (unsigned int)sourceEntityNum < 0x7FF && v22 )
        {
          Entity = CG_GetEntity(localClientNum, sourceEntityNum);
          if ( Entity )
          {
            if ( (Entity->flags & 1) != 0 )
            {
              CG_GetPoseOrigin(&Entity->pose, &outOrigin);
              RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
              v24 = outOrigin.v[0] - outOrg.v[0];
              v27 = LODWORD(outOrigin.v[1]);
              v25 = outOrigin.v[1] - outOrg.v[1];
              v26 = outOrigin.v[2] - outOrg.v[2];
              *(float *)&v27 = (float)((float)(v25 * v25) + (float)(v24 * v24)) + (float)(v26 * v26);
              if ( *(float *)&v27 >= 0.001 )
              {
                *(float *)&v27 = fsqrt(*(float *)&v27);
                _XMM1 = v27;
                __asm
                {
                  vcmpless xmm0, xmm1, cs:__real@80000000
                  vblendvps xmm1, xmm1, xmm6, xmm0
                }
                v28 = v24 * (float)(1.0 / *(float *)&_XMM1);
                v29 = v25 * (float)(1.0 / *(float *)&_XMM1);
                v30 = v26 * (float)(1.0 / *(float *)&_XMM1);
              }
              else
              {
                v28 = LocalClientGlobals->refdef.view.axis.m[0].v[0];
                v29 = LocalClientGlobals->refdef.view.axis.m[0].v[1];
                v30 = LocalClientGlobals->refdef.view.axis.m[0].v[2];
              }
              Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_cg_adjustClientImpactSoundDistance, "cg_adjustClientImpactSoundDistance");
              v42.v[0] = (float)(*(float *)&Float_Internal_DebugName * v28) + outOrg.v[0];
              v42.v[1] = (float)(*(float *)&Float_Internal_DebugName * v29) + outOrg.v[1];
              v42.v[2] = (float)(v30 * *(float *)&Float_Internal_DebugName) + outOrg.v[2];
              memset(&outOrg, 0, sizeof(outOrg));
              memset(&outOrigin, 0, sizeof(outOrigin));
            }
          }
        }
      }
      SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
      ((void (__fastcall *)(CgSoundSystem *, _QWORD, vec3_t *, SndAliasList *, int, _DWORD, _DWORD, _DWORD))SoundSystem->PlaySurfaceSound)(SoundSystem, clientNum, &v42, bulletExplodeSound, surfType, LODWORD(FLOAT_1_0), LODWORD(FLOAT_1_0), 0);
      break;
    default:
      return;
  }
}

/*
==============
CgWeaponSystem::BulletScriptableImpact
==============
*/
void CgWeaponSystem::BulletScriptableImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  centity_t *Entity; 
  unsigned int scriptableIndex; 

  if ( targetEntityNum < 0x7FE )
  {
    Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, targetEntityNum);
    if ( (Entity->flags & 1) != 0 && ScriptableCl_GetIndexForEntity((const LocalClientNum_t)this->m_localClientNum, Entity, &scriptableIndex) )
      ScriptableCl_EntityBulletHitEvent((const LocalClientNum_t)this->m_localClientNum, scriptableIndex, inflictorEntNum, start, hitPos, mod, weapon, isAlternate, hitPartName);
  }
}

/*
==============
CgWeaponSystem::BulletWhizbySound
==============
*/
void CgWeaponSystem::BulletWhizbySound(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, const vec3_t *start, const vec3_t *end)
{
  LocalClientNum_t m_localClientNum; 
  CgSoundSystem *SoundSystem; 
  _BOOL8 v10; 
  bool v11; 
  char v12; 
  __int64 v13; 

  m_localClientNum = this->m_localClientNum;
  v13 = 0i64;
  SoundSystem = CgSoundSystem::GetSoundSystem(m_localClientNum);
  LOBYTE(v10) = 1;
  v11 = isAlternate;
  SoundSystem->PlayWhizbyAndImpactSfx(SoundSystem, (const CgSfxImpactInfo *)&v12, v10, 2046, start, start, end, -1, weapon, v11, -1, SND_HITMARKER_TYPE_STANDARD);
}

/*
==============
CG_ActionSlotDown
==============
*/
void CG_ActionSlotDown(LocalClientNum_t localClientNum, int slot)
{
  __int64 v2; 
  __int64 v3; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *v6; 
  ActionSlotType *v7; 
  cg_t *v8; 
  const Weapon *v9; 
  bool v10; 
  const Weapon *CurrentWeaponForPlayer; 
  const Weapon *Weapon; 
  const PlayerEquippedWeaponState *EquippedWeaponState; 
  const Weapon *p_weaponLatestPrimary; 
  __int64 forceWrapAround; 
  __int64 v16; 

  v2 = localClientNum;
  v3 = slot;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (clientUIActives[v2].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18187, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v6 = CgWeaponMap::ms_instance[v2];
  if ( CG_Weapons_ActionSlotUsageAllowed(LocalClientGlobals, v3) )
  {
    v7 = &p_predictedPlayerState->actionSlotType[v3];
    if ( *v7 == ACTIONSLOTTYPE_SPECIFYWEAPON )
    {
      CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v6, p_predictedPlayerState);
      if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1026, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1027, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (unsigned int)v3 >= 7 )
      {
        LODWORD(v16) = 7;
        LODWORD(forceWrapAround) = v3;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1028, ASSERT_TYPE_ASSERT, "(unsigned)( actionSlotIndex ) < (unsigned)( 7 )", "actionSlotIndex doesn't index ACTIONSLOTS_COUNT_STATIC\n\t%i not in [0, %i)", forceWrapAround, v16) )
          __debugbreak();
      }
      if ( !BG_ActionSlotIsWeaponType(p_predictedPlayerState, v3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1029, ASSERT_TYPE_ASSERT, "(BG_ActionSlotIsWeaponType( ps, actionSlotIndex ))", (const char *)&queryFormat, "BG_ActionSlotIsWeaponType( ps, actionSlotIndex )") )
        __debugbreak();
      Weapon = BgWeaponMap::GetWeapon(v6, p_predictedPlayerState->actionSlotParam[v3].specifyWeapon.weaponHandle);
      if ( BG_WeaponDef(CurrentWeaponForPlayer, 0)->inventoryType != WEAPINVENTORY_EXCLUSIVE )
      {
        if ( !memcmp_0(Weapon, &LocalClientGlobals->weaponSelect, 0x3Cui64) )
        {
          if ( !memcmp_0(Weapon, &LocalClientGlobals->weaponLatestPrimary, 0x3Cui64) || !BG_PlayerHasWeapon(v6, p_predictedPlayerState, &LocalClientGlobals->weaponLatestPrimary) )
          {
            v10 = CycleWeapPrimary((LocalClientNum_t)v2, 0, 1, 0, 0, 0);
            goto LABEL_54;
          }
          EquippedWeaponState = BG_GetEquippedWeaponState(v6, p_predictedPlayerState, &LocalClientGlobals->weaponLatestPrimary);
          if ( EquippedWeaponState )
            LOBYTE(EquippedWeaponState) = EquippedWeaponState->inAltMode;
          p_weaponLatestPrimary = &LocalClientGlobals->weaponLatestPrimary;
        }
        else
        {
          if ( !BG_PlayerHasWeapon(v6, p_predictedPlayerState, Weapon) || !memcmp_0(CurrentWeaponForPlayer, Weapon, 0x3Cui64) )
            return;
          EquippedWeaponState = BG_GetEquippedWeaponState(v6, p_predictedPlayerState, Weapon);
          if ( EquippedWeaponState )
            LOBYTE(EquippedWeaponState) = EquippedWeaponState->inAltMode;
          p_weaponLatestPrimary = Weapon;
        }
        CG_SelectWeapon((LocalClientNum_t)v2, p_weaponLatestPrimary, (unsigned __int8)EquippedWeaponState);
LABEL_62:
        if ( Com_GameMode_SupportsFeature(WEAPON_SCOPE_TOGGLE_OFF|WEAPON_LADDER_AIM) && BG_IsTurretActive(p_predictedPlayerState) && *v7 == ACTIONSLOTTYPE_SPECIFYWEAPON )
          LocalClientGlobals->extraButtons |= 0x20ui64;
      }
    }
    else
    {
      if ( *v7 != ACTIONSLOTTYPE_ALTWEAPONTOGGLE )
      {
        if ( *v7 == ACTIONSLOTTYPE_NIGHTVISION )
        {
          if ( !CL_Input_IsGamepadEnabled((LocalClientNum_t)v2) )
            return;
          LocalClientGlobals->extraButtons |= 0x10000ui64;
        }
        else
        {
          if ( *v7 != ACTIONSLOTTYPE_TAUNT )
            return;
          LocalClientGlobals->extraButtons |= 0x80000000ui64;
        }
        goto LABEL_62;
      }
      if ( CL_Input_IsGamepadEnabled((LocalClientNum_t)v2) && !CG_IsWeaponInspectOnAltToggle((LocalClientNum_t)v2) && Dvar_GetBool_Internal_DebugName(DVARBOOL_bg_underbarrelWeaponEnabled, "bg_underbarrelWeaponEnabled") )
      {
        v8 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
        if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
          __debugbreak();
        v9 = BG_GetCurrentWeaponForPlayer(CgWeaponMap::ms_instance[v2], &v8->predictedPlayerState);
        if ( !BG_IsThrowingAxe(v9) && BG_HasUnderbarrelAmmo(v9) && !BG_UseLeftTriggerAltFireMode(v9) )
        {
          if ( BG_OffhandIsUnderbarrelWeapon(v6, p_predictedPlayerState, 0x3000ui64) )
          {
            if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18236, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
              __debugbreak();
            return;
          }
          v10 = CG_Weapons_ToggleWeaponAltMode((LocalClientNum_t)v2);
LABEL_54:
          if ( !v10 )
            return;
          goto LABEL_62;
        }
      }
    }
  }
}

/*
==============
CG_ActionSlotUp
==============
*/
void CG_ActionSlotUp(LocalClientNum_t localClientNum, int slot, bool mustRelease)
{
  __int64 v3; 
  __int64 v5; 
  const cg_t *LocalClientGlobals; 

  v3 = localClientNum;
  v5 = slot;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (clientUIActives[v3].frontEndSceneState[0] || !clientUIActives[v3].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18314, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
  if ( CG_Weapons_ActionSlotUsageAllowed(LocalClientGlobals, v5) && LocalClientGlobals->predictedPlayerState.actionSlotType[v5] == ACTIONSLOTTYPE_ALTWEAPONTOGGLE && CG_IsWeaponInspectOnAltToggle((LocalClientNum_t)v3) && !mustRelease )
    CG_Weapons_ToggleWeaponAltMode((LocalClientNum_t)v3);
}

/*
==============
CG_AddPlayerExecutionProp
==============
*/
void CG_AddPlayerExecutionProp(LocalClientNum_t localClientNum, centity_t *cent)
{
  const BgWeaponMap **v4; 
  cg_t *LocalClientGlobals; 
  unsigned int number; 
  const cg_t *v7; 
  const characterInfo_t *CharacterInfo; 
  Weapon *p_dobjExecutionWeapon; 
  CgWeaponSystem *WeaponSystem; 

  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[localClientNum];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  if ( !BG_GetWeaponForEntity(*v4, &cent->nextState)->weaponIdx )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    number = cent->nextState.number;
    v7 = LocalClientGlobals;
    if ( LocalClientGlobals->HasCharacterInfo(LocalClientGlobals, number) )
    {
      CharacterInfo = CG_GetCharacterInfo(v7, number);
      if ( CharacterInfo )
      {
        p_dobjExecutionWeapon = &CharacterInfo->dobjExecutionWeapon;
        if ( CharacterInfo->dobjExecutionWeapon.weaponIdx )
        {
          WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
          WeaponSystem->AddWeaponLaserForCharacter(WeaponSystem, p_dobjExecutionWeapon, cent);
          WeaponSystem->UpdateMuzzleFlash(WeaponSystem, cent, p_dobjExecutionWeapon, 0, 0, 1, NULL);
        }
      }
    }
  }
}

/*
==============
CG_AddPlayerWeapon
==============
*/
void CG_AddPlayerWeapon(LocalClientNum_t localClientNum, const vec3_t *weapOrigin, const vec4_t *weapOrient, const playerState_s *ps, const vec3_t *localPlayerGunAngles, centity_t *cent, int bDrawGun, const CgEventLodData *optionalEventLodData)
{
  const playerState_s *v8; 
  __int64 v11; 
  cg_t *LocalClientGlobals; 
  BgWeaponMap *v13; 
  Weapon *ViewmodelWeapon; 
  bool inAltWeaponMode; 
  const dvar_t *v16; 
  const dvar_t *v17; 
  unsigned int v18; 
  const dvar_t *v19; 
  const dvar_t *v20; 
  CgViewSystem *ViewSystem; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  int WeaponHandForViewWeapon; 
  unsigned int v38; 
  PlayerHandIndex v39; 
  const WeaponDef *v40; 
  WeaponHand *ViewModelHand; 
  cg_t *v42; 
  __int64 v43; 
  float dualWieldViewModelOffset; 
  vec3_t *p_inOrigin; 
  __int128 v46; 
  double v47; 
  void (__fastcall *v48)(const vec3_t *, vec4_t *); 
  cpose_t *p_viewModelPoseLeftHand; 
  cpose_t *p_viewModelPose; 
  __int64 v51; 
  void (__fastcall *v52)(const vec4_t *, vec3_t *); 
  float v53; 
  int v54; 
  CgHandler *Handler; 
  PlayerHandIndex v56; 
  const DObj **v57; 
  cg_t *v58; 
  __int64 v59; 
  const dvar_t *v60; 
  __int64 v61; 
  cpose_t *v62; 
  double v63; 
  float v64; 
  CgMLGSpectator *MLGSpectator; 
  const characterInfo_t *CharacterInfo; 
  CgGlobalsMP *v67; 
  CgStatic *LocalClientStatics; 
  int v69; 
  const HudOutlineDef *HudOutlineDef; 
  int outlineWidth; 
  centity_t *v72; 
  float v73; 
  CgGlobalsMP *v74; 
  int clientNum; 
  double Float_Internal_DebugName; 
  unsigned int v77; 
  BgWeaponMap *v78; 
  double OffhandAdsFrac; 
  const Weapon *OffhandGestureWeapon; 
  CgHandler *v81; 
  const DObj *v82; 
  unsigned int v83; 
  void (__fastcall **p_FunctionPointer_prevOrigin)(const vec4_t *, vec3_t *); 
  float fWeaponPosFrac; 
  CgHandler *v86; 
  const DObj *v87; 
  unsigned int v88; 
  scr_string_t *v89; 
  CgHandler *v90; 
  const WeaponHeat *v91; 
  double Heat; 
  cpose_t *v93; 
  bool v94; 
  int pm_type; 
  CgWeaponSystem *v96; 
  cg_t *v97; 
  __int64 weaponIdx; 
  WeaponCompleteDef *v99; 
  float dofPhysicalViewModelFocusDistance; 
  float dofPhysicalViewModelFstop; 
  float adsDofPhysicalFocusDistance; 
  float adsDofPhysicalFstop; 
  char v104; 
  CgHandler *v105; 
  float v106; 
  cpose_t *v107; 
  scr_string_t tag_attachment_focus; 
  double v109; 
  const DObj **p_viewModelDObj; 
  __int64 v111; 
  CgWeaponSystem *v112; 
  centity_t *v113; 
  int v114; 
  BgHybridScopeFraction *hybridScopeFraction; 
  GfxScopeInfo *settingOut; 
  bool isAlternate; 
  unsigned int outRenderFlags; 
  __int64 v119; 
  centity_t *v120; 
  vec3_t pose; 
  StreamImageMip streamMip; 
  int v123; 
  vec3_t outOrigin; 
  vec3_t inOrigin; 
  BgWeaponMap *weaponMap; 
  vec3_t v127; 
  float characterEVOffset; 
  CgWeaponSystem *WeaponSystem; 
  const playerState_s *v130; 
  CgViewSystem *laserInfo; 
  const WeaponDef *v132; 
  void (__fastcall *FunctionPointer_prevOrigin)(const vec4_t *, vec3_t *); 
  __m256i v134; 
  int bViewModel; 
  vec3_t *v136; 
  const CgEventLodData *v137; 
  __int64 v138; 
  GfxSceneHudOutlineInfo v139; 
  shaderOverride_t v140; 
  __m256i v141; 
  __m256i v142; 
  __m256i v143; 
  __m256i v144; 
  __m256i v145; 
  __m256i v146; 
  float dofPhysicalFocusDistance; 
  vec3_t functionPointer; 
  vec3_t right; 
  vec3_t outlinedEntityOrigin; 
  vec3_t vec; 
  vec3_t playerViewOrigin; 
  Weapon r_weapon; 
  tmat33_t<vec3_t> axis; 
  vec3_t outOrg; 
  __m256i v156; 
  float v157; 
  GfxScopeInfo scope; 
  WorldUpReferenceFrame v159; 
  int v160[6]; 

  v138 = -2i64;
  v8 = ps;
  v130 = ps;
  v11 = localClientNum;
  LODWORD(v119) = localClientNum;
  v136 = (vec3_t *)localPlayerGunAngles;
  v120 = cent;
  v137 = optionalEventLodData;
  if ( ps && !localPlayerGunAngles && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15059, ASSERT_TYPE_ASSERT, "(!ps || localPlayerGunAngles)", (const char *)&queryFormat, "!ps || localPlayerGunAngles") )
    __debugbreak();
  v134 = *(__m256i *)&NULL_HUDOUTLINE_INFO_7.color;
  characterEVOffset = NULL_HUDOUTLINE_INFO_7.characterEVOffset;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v11);
  if ( !CgWeaponMap::ms_instance[v11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  weaponMap = CgWeaponMap::ms_instance[v11];
  bViewModel = v8 != NULL;
  if ( cent == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2088, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( BG_IsTurretActiveFlags(&cent->nextState.lerp.eFlags) )
    goto LABEL_209;
  if ( cent == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2032, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cent->nextState.lerp.eFlags, ACTIVE, 0xBu) )
  {
LABEL_209:
    if ( !v8 )
      return;
    v13 = weaponMap;
    if ( !BG_IsUsingTurretViewarms(weaponMap, v8) )
      return;
  }
  else
  {
    v13 = weaponMap;
  }
  if ( v8 || CG_MainMP_IsPrematchCountdown((const LocalClientNum_t)v11) )
  {
    streamMip = 4 - CL_TransientsWorldMP_UseLowAlwaysloadedFlagging();
    if ( v8 )
    {
      ViewmodelWeapon = (Weapon *)BG_GetViewmodelWeapon(v13, v8);
      goto LABEL_26;
    }
  }
  else
  {
    streamMip = !CL_TransientsWorldMP_UseLowAlwaysloadedFlagging();
  }
  ViewmodelWeapon = (Weapon *)BG_GetWeaponForEntity(weaponMap, &cent->nextState);
LABEL_26:
  r_weapon = *ViewmodelWeapon;
  if ( v8 )
    inAltWeaponMode = BG_UsingAlternate(v8);
  else
    inAltWeaponMode = v120->nextState.inAltWeaponMode;
  isAlternate = inAltWeaponMode;
  if ( r_weapon.weaponIdx )
  {
    WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v11);
    v132 = BG_WeaponDef(&r_weapon, inAltWeaponMode);
    if ( !v132 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15109, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    outRenderFlags = 1033;
    v16 = DVARBOOL_depthSortViewmodel;
    if ( !DVARBOOL_depthSortViewmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "depthSortViewmodel") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
    if ( v16->current.enabled )
      outRenderFlags &= ~1u;
    v17 = DVARBOOL_viewModelHacks;
    if ( !DVARBOOL_viewModelHacks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "viewModelHacks") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v17);
    v18 = outRenderFlags;
    if ( !v17->current.enabled )
      v18 = 0;
    outRenderFlags = v18;
    v19 = DCONST_DVARBOOL_duckedRotationPivotDebug;
    if ( !DCONST_DVARBOOL_duckedRotationPivotDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "duckedRotationPivotDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v19);
    if ( v19->current.enabled )
      outRenderFlags &= ~1u;
    v20 = DCONST_DVARBOOL_advancedSwayDebug;
    if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v20);
    if ( v20->current.enabled )
      outRenderFlags &= ~1u;
    if ( !v8 )
    {
      v54 = bDrawGun;
      if ( bDrawGun )
      {
        v112 = WeaponSystem;
        v113 = v120;
        WeaponSystem->AddWeaponLaserForCharacter(WeaponSystem, &r_weapon, v120);
        goto LABEL_203;
      }
LABEL_202:
      v112 = WeaponSystem;
      v113 = v120;
LABEL_203:
      v114 = bViewModel;
      CgWeaponSystem::ChargedWeaponUpdate(v112, v8, v113, &r_weapon, isAlternate, bViewModel, v54);
      v112->UpdateMuzzleFlash(v112, v113, &r_weapon, isAlternate, v114, v54, v137);
      CG_PlayContinuousFireSounds((const LocalClientNum_t)v11, v8, v113);
      CG_PlayADSSounds((const LocalClientNum_t)v11, &r_weapon, isAlternate, v8, v113);
      return;
    }
    ViewSystem = CgViewSystem::GetViewSystem((const LocalClientNum_t)v11);
    laserInfo = ViewSystem;
    if ( !ViewSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15140, ASSERT_TYPE_ASSERT, "(view)", (const char *)&queryFormat, "view") )
      __debugbreak();
    ViewSystem->CalcLinkedToPlayerViewTags(ViewSystem, VM_PRE_MOTION);
    right.v[0] = 0.0;
    right.v[1] = 0.0;
    right.v[2] = 0.0;
    outOrigin.v[0] = 0.0;
    outOrigin.v[1] = 0.0;
    outOrigin.v[2] = 0.0;
    v22 = weapOrient->v[1];
    v23 = weapOrient->v[0];
    v24 = weapOrient->v[2];
    v25 = weapOrient->v[3];
    v26 = (float)((float)((float)(v23 * v23) + (float)(v22 * v22)) + (float)(v24 * v24)) + (float)(v25 * v25);
    if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(v26 - 1.0) & _xmm) >= 0.0020000001 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 770, ASSERT_TYPE_ASSERT, "( Vec4IsNormalized( quat ) )", "(%g, %g, %g, %g) len: %g", v23, v22, v24, v25, fsqrt(v26)) )
      __debugbreak();
    v27 = 2.0 * weapOrient->v[0];
    v28 = v27 * weapOrient->v[0];
    v29 = weapOrient->v[1];
    v30 = v27 * v29;
    v31 = weapOrient->v[2];
    v32 = weapOrient->v[3];
    v33 = (float)(v29 * 2.0) * v29;
    v34 = (float)(v29 * 2.0) * v31;
    v35 = (float)(v29 * 2.0) * v32;
    v36 = (float)(v31 * 2.0) * v32;
    axis.m[0].v[0] = 1.0 - (float)((float)((float)(v31 * 2.0) * v31) + v33);
    axis.m[0].v[1] = v36 + v30;
    axis.m[0].v[2] = (float)(v27 * v31) - v35;
    axis.m[1].v[0] = v30 - v36;
    axis.m[1].v[1] = 1.0 - (float)((float)((float)(v31 * 2.0) * v31) + v28);
    axis.m[1].v[2] = v34 + (float)(v27 * v32);
    axis.m[2].v[0] = v35 + (float)(v27 * v31);
    axis.m[2].v[1] = v34 - (float)(v27 * v32);
    axis.m[2].v[2] = 1.0 - (float)(v33 + v28);
    cg_t::SetViewModelTransform(LocalClientGlobals, &axis, weapOrigin);
    WeaponHandForViewWeapon = BG_PlayerLastWeaponHandForViewWeapon(weaponMap, v8);
    v123 = WeaponHandForViewWeapon;
    v38 = 0;
    v39 = WEAPON_HAND_DEFAULT;
    if ( WeaponHandForViewWeapon >= 0 )
    {
      v40 = v132;
      while ( 1 )
      {
        ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, v39);
        if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15157, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
          __debugbreak();
        CG_UpdateViewModelPoseForHand(ViewModelHand->viewModelDObj, (LocalClientNum_t)v11, v39, 1);
        CG_Ladder_ResetHandInterpolation((LocalClientNum_t)v11, v8, v39);
        if ( BG_HasLadderHand(v8) )
        {
          v42 = CG_GetLocalClientGlobals((const LocalClientNum_t)v11);
          v43 = 303328i64;
          if ( v39 )
            v43 = 303616i64;
          CG_Ladder_InterpolateHand((LocalClientNum_t)v11, v8, v39, (cpose_t *)((char *)v42 + v43));
          goto LABEL_87;
        }
        if ( v39 )
          break;
        if ( BG_PlayerDualWieldingWeapon(weaponMap, v8, &r_weapon) )
        {
          CG_GetPoseOrigin(&LocalClientGlobals->viewModelPose, &outOrigin);
          AngleVectors(&v8->viewangles, NULL, &right, NULL);
          dualWieldViewModelOffset = v40->dualWieldViewModelOffset;
          inOrigin.v[0] = (float)(dualWieldViewModelOffset * right.v[0]) + outOrigin.v[0];
          inOrigin.v[1] = (float)(dualWieldViewModelOffset * right.v[1]) + outOrigin.v[1];
          inOrigin.v[2] = (float)(dualWieldViewModelOffset * right.v[2]) + outOrigin.v[2];
          CG_SetPoseOrigin(&LocalClientGlobals->viewModelPose, &inOrigin);
          p_inOrigin = &inOrigin;
LABEL_86:
          memset(p_inOrigin, 0, sizeof(vec3_t));
        }
LABEL_87:
        if ( ++v39 > WeaponHandForViewWeapon )
        {
          ViewSystem = laserInfo;
          v38 = 0;
          goto LABEL_89;
        }
      }
      if ( v39 != WEAPON_HAND_LEFT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15183, ASSERT_TYPE_ASSERT, "(hand == WEAPON_HAND_LEFT)", (const char *)&queryFormat, "hand == WEAPON_HAND_LEFT") )
        __debugbreak();
      if ( right.v[0] == 0.0 && right.v[1] == 0.0 && right.v[2] == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15184, ASSERT_TYPE_ASSERT, "(!Vec3Compare( vRight, vec3_origin ))", (const char *)&queryFormat, "!Vec3Compare( vRight, vec3_origin )") )
        __debugbreak();
      v46 = *(_OWORD *)&LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.frameCount;
      v47 = *(double *)&LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.subdivCacheOffset;
      v48 = ObfuscateSetFunctionPointer_origin(LocalClientGlobals->viewModelPoseLeftHand.origin.Set_origin, &LocalClientGlobals->viewModelPoseLeftHand);
      *(_QWORD *)functionPointer.v = ObfuscateGetFunctionPointer_origin(LocalClientGlobals->viewModelPoseLeftHand.origin.Get_origin, &LocalClientGlobals->viewModelPoseLeftHand);
      *(_QWORD *)pose.v = ObfuscateSetFunctionPointer_prevOrigin(LocalClientGlobals->viewModelPoseLeftHand.prevOrigin.Set_prevOrigin, &LocalClientGlobals->viewModelPoseLeftHand);
      FunctionPointer_prevOrigin = ObfuscateGetFunctionPointer_prevOrigin(LocalClientGlobals->viewModelPoseLeftHand.prevOrigin.Get_prevOrigin, &LocalClientGlobals->viewModelPoseLeftHand);
      p_viewModelPoseLeftHand = &LocalClientGlobals->viewModelPoseLeftHand;
      p_viewModelPose = &LocalClientGlobals->viewModelPose;
      v51 = 2i64;
      do
      {
        *(_OWORD *)&p_viewModelPoseLeftHand->eType = *(_OWORD *)&p_viewModelPose->eType;
        *(_OWORD *)&p_viewModelPoseLeftHand->ragdollHandle = *(_OWORD *)&p_viewModelPose->ragdollHandle;
        *(_OWORD *)&p_viewModelPoseLeftHand->actualOrigin.y = *(_OWORD *)&p_viewModelPose->actualOrigin.y;
        *(_OWORD *)&p_viewModelPoseLeftHand->origin.Get_origin = *(_OWORD *)&p_viewModelPose->origin.Get_origin;
        *(SecureOrigin::secureUnion *)((char *)&p_viewModelPoseLeftHand->origin.origin + 8) = *(SecureOrigin::secureUnion *)((char *)&p_viewModelPose->origin.origin + 8);
        *(_OWORD *)&p_viewModelPoseLeftHand->angles.z = *(_OWORD *)&p_viewModelPose->angles.z;
        *(_OWORD *)&p_viewModelPoseLeftHand->prevOrigin.Get_prevOrigin = *(_OWORD *)&p_viewModelPose->prevOrigin.Get_prevOrigin;
        p_viewModelPoseLeftHand = (cpose_t *)((char *)p_viewModelPoseLeftHand + 128);
        *((_OWORD *)&p_viewModelPoseLeftHand[-1].moverFx + 7) = *(vec4_t *)((char *)&p_viewModelPose->prevOrigin.prevOrigin + 8);
        p_viewModelPose = (cpose_t *)((char *)p_viewModelPose + 128);
        --v51;
      }
      while ( v51 );
      *(_OWORD *)&p_viewModelPoseLeftHand->eType = *(_OWORD *)&p_viewModelPose->eType;
      *(_OWORD *)&p_viewModelPoseLeftHand->ragdollHandle = *(_OWORD *)&p_viewModelPose->ragdollHandle;
      LocalClientGlobals->viewModelPoseLeftHand.origin.Set_origin = NULL;
      LocalClientGlobals->viewModelPoseLeftHand.origin.Get_origin = NULL;
      LocalClientGlobals->viewModelPoseLeftHand.prevOrigin.Set_prevOrigin = NULL;
      LocalClientGlobals->viewModelPoseLeftHand.prevOrigin.Get_prevOrigin = NULL;
      LocalClientGlobals->viewModelPoseLeftHand.origin.Set_origin = ObfuscateSetFunctionPointer_origin(v48, &LocalClientGlobals->viewModelPoseLeftHand);
      LocalClientGlobals->viewModelPoseLeftHand.origin.Get_origin = ObfuscateGetFunctionPointer_origin(*(void (__fastcall *const *)(const vec4_t *, vec3_t *))functionPointer.v, &LocalClientGlobals->viewModelPoseLeftHand);
      LocalClientGlobals->viewModelPoseLeftHand.prevOrigin.Set_prevOrigin = ObfuscateSetFunctionPointer_prevOrigin(*(void (__fastcall *const *)(const vec3_t *, vec4_t *))pose.v, &LocalClientGlobals->viewModelPoseLeftHand);
      LocalClientGlobals->viewModelPoseLeftHand.prevOrigin.Get_prevOrigin = ObfuscateGetFunctionPointer_prevOrigin(FunctionPointer_prevOrigin, &LocalClientGlobals->viewModelPoseLeftHand);
      CG_GetPoseOrigin(&LocalClientGlobals->viewModelPose, &v127);
      CG_SetPoseOrigin(&LocalClientGlobals->viewModelPoseLeftHand, &v127);
      if ( !LocalClientGlobals->viewModelPose.prevOrigin.Get_prevOrigin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 568, ASSERT_TYPE_ASSERT, "(pose->prevOrigin.Get_prevOrigin)", (const char *)&queryFormat, "pose->prevOrigin.Get_prevOrigin") )
        __debugbreak();
      v52 = ObfuscateGetFunctionPointer_prevOrigin(LocalClientGlobals->viewModelPose.prevOrigin.Get_prevOrigin, &LocalClientGlobals->viewModelPose);
      v52(&LocalClientGlobals->viewModelPose.prevOrigin.prevOrigin, &v127);
      CG_SetPrevPoseOrigin(&LocalClientGlobals->viewModelPoseLeftHand, &v127);
      memset(&v127, 0, sizeof(v127));
      *(_OWORD *)&LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.frameCount = v46;
      *(double *)&LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.subdivCacheOffset = v47;
      v53 = -1.7 * v132->dualWieldViewModelOffset;
      outlinedEntityOrigin.v[0] = (float)(v53 * right.v[0]) + outOrigin.v[0];
      outlinedEntityOrigin.v[1] = (float)(v53 * right.v[1]) + outOrigin.v[1];
      outlinedEntityOrigin.v[2] = (float)(v53 * right.v[2]) + outOrigin.v[2];
      CG_SetPoseOrigin(&LocalClientGlobals->viewModelPoseLeftHand, &outlinedEntityOrigin);
      p_inOrigin = &outlinedEntityOrigin;
      LODWORD(v11) = v119;
      WeaponHandForViewWeapon = v123;
      v40 = v132;
      goto LABEL_86;
    }
LABEL_89:
    ViewSystem->CalcLinkedToPlayerViewTags(ViewSystem, VM_POST_MOTION);
    *(_QWORD *)functionPointer.v = WeaponHandForViewWeapon;
    v54 = bDrawGun;
    if ( !bDrawGun )
    {
      if ( WeaponHandForViewWeapon < 0i64 )
      {
LABEL_201:
        HoldBreathUpdate((LocalClientNum_t)v11);
        memset(&outOrigin, 0, sizeof(outOrigin));
        goto LABEL_202;
      }
      p_viewModelDObj = (const DObj **)&LocalClientGlobals->m_weaponHand[0].viewModelDObj;
      v111 = WeaponHandForViewWeapon + 1i64;
      do
      {
        if ( v38 >= 2 )
        {
          LODWORD(settingOut) = 2;
          LODWORD(hybridScopeFraction) = v38;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hybridScopeFraction, settingOut) )
            __debugbreak();
        }
        if ( !*p_viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15473, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
          __debugbreak();
        Stream_TouchDObj(*p_viewModelDObj, streamMip);
        ++v38;
        p_viewModelDObj += 5;
        --v111;
      }
      while ( v111 );
      v8 = v130;
      LODWORD(v11) = v119;
LABEL_200:
      v54 = bDrawGun;
      goto LABEL_201;
    }
    memset_0(&v141, 0, 0xC4ui64);
    Handler = CgHandler::getHandler((LocalClientNum_t)v11);
    WorldUpReferenceFrame::WorldUpReferenceFrame(&v159, v8, Handler);
    vec = v8->origin;
    WorldUpReferenceFrame::AddUpContribution(&v159, v8->viewHeightCurrent, &vec);
    v56 = WEAPON_HAND_DEFAULT;
    LODWORD(v119) = 0;
    if ( WeaponHandForViewWeapon >= 0i64 )
    {
      v130 = NULL;
      laserInfo = (CgViewSystem *)LocalClientGlobals->laserInfo;
      v57 = (const DObj **)&LocalClientGlobals->m_weaponHand[0].viewModelDObj;
      *(_QWORD *)v127.v = LocalClientGlobals->m_weaponHand;
      while ( 1 )
      {
        if ( (unsigned int)v56 >= NUM_WEAPON_HANDS )
        {
          LODWORD(settingOut) = 2;
          LODWORD(hybridScopeFraction) = v56;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hybridScopeFraction, settingOut) )
            __debugbreak();
        }
        if ( !*v57 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15219, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
          __debugbreak();
        v58 = CG_GetLocalClientGlobals((const LocalClientNum_t)v11);
        v59 = 303328i64;
        if ( v56 )
          v59 = 303616i64;
        *(_QWORD *)pose.v = (char *)v58 + v59;
        v123 = (v56 != WEAPON_HAND_DEFAULT) + 2048;
        v60 = DCONST_DVARBOOL_cg_defaultWeaponHidesViewmodel;
        if ( !DCONST_DVARBOOL_cg_defaultWeaponHidesViewmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_defaultWeaponHidesViewmodel") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v60);
        if ( v60->current.enabled && LocalClientGlobals->playerWeaponInfo.isWeaponDefault )
          goto LABEL_160;
        Stream_TouchDObj(*v57, streamMip);
        if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&v8->otherFlags, ACTIVE, 0x20u) )
        {
          v61 = (__int64)LocalClientGlobals->nextSnap->GetPlayerState(LocalClientGlobals->nextSnap, (unsigned int)v11);
          v62 = *(cpose_t **)pose.v;
          *(_DWORD *)(*(_QWORD *)pose.v + 72i64) = *(_DWORD *)(v61 + 472);
          v62->angles.v[1] = *(float *)(v61 + 476);
          v62->angles.v[2] = *(float *)(v61 + 480);
          inOrigin = *(vec3_t *)(v61 + 48);
          inOrigin.v[2] = inOrigin.v[2] + *(float *)(v61 + 488);
          CG_SetPoseOrigin(v62, &inOrigin);
          memset(&inOrigin, 0, sizeof(inOrigin));
        }
        v63 = ((double (__fastcall *)(CgWeaponSystem *))WeaponSystem->GetWeaponUVAnimOverride)(WeaponSystem);
        v64 = *(float *)&v63;
        MLGSpectator = NULL;
        CharacterInfo = NULL;
        if ( MLG_IsCoDCasterEnabled() && cg_t::ms_allocatedType == GLOB_TYPE_MP )
        {
          v67 = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)v11);
          if ( v67 )
          {
            if ( v67->m_isMLGSpectator )
            {
              MLGSpectator = CgMLGSpectator::GetMLGSpectator((const LocalClientNum_t)v11);
              LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)v11);
              CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, v120->nextState.clientNum);
            }
          }
        }
        if ( (*(_DWORD *)&v8->outlineData.viewmodel & 0x3F) != 0 )
        {
          v69 = LocalClientGlobals->time - LocalClientGlobals->predictedPlayerState.deltaTime;
          HudOutlineDef = BG_GetHudOutlineDef(*(_DWORD *)&v8->outlineData.viewmodel & 0x3F);
          outlinedEntityOrigin.v[0] = 0.0;
          outlinedEntityOrigin.v[1] = 0.0;
          outlinedEntityOrigin.v[2] = 0.0;
          playerViewOrigin.v[0] = 0.0;
          playerViewOrigin.v[1] = 0.0;
          playerViewOrigin.v[2] = 0.0;
          v134.m256i_i32[0] = BG_HudOutline_GetColor(HudOutlineDef, LocalClientGlobals->hudOutlineStartTime, v69, &playerViewOrigin, &outlinedEntityOrigin);
          v134.m256i_i8[8] = HudOutlineDef->drawOccludedPixels;
          v134.m256i_i8[9] = HudOutlineDef->drawNonOccludedPixels;
          outlineWidth = HudOutlineDef->outlineWidth;
          if ( (outlineWidth < 0 || (unsigned int)outlineWidth > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,int>(int)", "unsigned", (unsigned __int8)outlineWidth, "signed", outlineWidth) )
            __debugbreak();
          v134.m256i_i8[15] = outlineWidth;
          v134.m256i_i8[14] = HudOutlineDef->outlineType;
          v134.m256i_i8[10] = HudOutlineDef->drawFill;
        }
        else if ( MLGSpectator && CharacterInfo && CgMLGSpectator::GetOutlineViewmodel(MLGSpectator) )
        {
          v72 = v120;
          v120->currentHudOutlineIndex = 0;
          v73 = 1.0 - (float)(1.5 * v8->weapCommon.fWeaponPosFrac);
          I_fclamp(v73, 0.0, 1.0);
          v74 = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)v11);
          clientNum = v72->nextState.clientNum;
          v134.m256i_i32[0] = CG_Utils_GetHudOutlineTeamColor(v74, (const LocalClientNum_t)v11, (const team_t)CharacterInfo->team, 1, v73);
          if ( v134.m256i_i32[0] )
          {
            v134.m256i_i8[12] = 1;
            v134.m256i_i16[4] = 257;
            Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_r_hudOutlineWidth, "r_hudOutlineWidth");
            v134.m256i_i8[15] = (int)*(float *)&Float_Internal_DebugName;
            v134.m256i_i8[14] = 0;
            v134.m256i_i8[13] = CgMLGSpectator::IsClientSpecialActive(MLGSpectator, clientNum) != 0;
          }
          else
          {
            v134 = *(__m256i *)&NULL_HUDOUTLINE_INFO_7.color;
            characterEVOffset = NULL_HUDOUTLINE_INFO_7.characterEVOffset;
          }
          v56 = (int)v119;
        }
        else if ( (*(_BYTE *)&v8->outlineData.viewmodel & 0x3F) == 0 )
        {
          v120->currentHudOutlineIndex = 0;
        }
        v77 = outRenderFlags & 0xFFFFFBFF;
        outRenderFlags = v77;
        if ( (v77 & 1) != 0 && LocalClientGlobals->dualViewScope )
          outRenderFlags = v77 | 0x4000;
        LocalClientGlobals->GetShaderOverrideData(LocalClientGlobals, (shaderOverride_t *)&v156, v8->clientNum, &r_weapon);
        if ( v130 == *(const playerState_s **)functionPointer.v )
        {
          v78 = weaponMap;
          if ( BG_IsUsingOffhandGestureWeaponADSSupport(weaponMap, v8) )
            break;
        }
        if ( v56 == WEAPON_HAND_DEFAULT )
        {
          fWeaponPosFrac = v8->weapCommon.fWeaponPosFrac;
          v86 = CgHandler::getHandler((LocalClientNum_t)v11);
          BG_GetScopeLensSettings(v86, v8, &r_weapon, isAlternate, fWeaponPosFrac, &LocalClientGlobals->scopeToggleInfo.fractionInfo, &scope);
          if ( scope.dofOverride )
          {
            v141 = *(__m256i *)&scope.foundSight;
            v142 = *(__m256i *)&scope.scopeLensAxis.row1.y;
            v143 = *(__m256i *)&scope.scopeLensOuterRing;
            v144 = *(__m256i *)&scope.scopeLensBrightness;
            v145 = *(__m256i *)&scope.scopeEyeRelief_outOfFocusDistance;
            v146 = *(__m256i *)&scope.scopeEyeRelief_idleSway_movement;
            dofPhysicalFocusDistance = scope.dofPhysicalFocusDistance;
          }
          v87 = **(const DObj ***)v127.v;
          Sys_ProfBeginNamedEvent(0xFFFAEBD7, "CG_GetScopePosition");
          v160[0] = scr_const.tag_front_lens;
          v160[1] = scr_const.tag_reticle_attach;
          v160[2] = scr_const.tag_reticle_attach2;
          v88 = 0;
          v89 = (scr_string_t *)v160;
          while ( !CG_DObjGetWorldTagMatrix(&LocalClientGlobals->viewModelPose, v87, *v89, &scope.scopeLensAxis, &scope.scopeLensPos) )
          {
            ++v88;
            ++v89;
            if ( v88 >= 3 )
            {
              RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &scope.scopeLensPos);
              MatrixCopy33(&LocalClientGlobals->refdef.view.axis, &scope.scopeLensAxis);
              Sys_ProfEndNamedEvent();
              goto LABEL_147;
            }
          }
          Sys_ProfEndNamedEvent();
          goto LABEL_147;
        }
LABEL_148:
        CG_Ladder_SetRenderFlagsForHand((LocalClientNum_t)v11, v8, v56, &outRenderFlags);
        v90 = CgHandler::getHandler((LocalClientNum_t)v11);
        v91 = v90->GetPlayerWeaponHeat(v90, v8, &r_weapon, v56);
        Heat = BG_Heat_GetHeat(v91, &r_weapon, isAlternate, v8->serverTime);
        *(float *)&v134.m256i_i32[6] = 0.0;
        v134.m256i_i8[16] = 1;
        v134.m256i_i32[7] = SLODWORD(Heat);
        *(__m256i *)&v139.color = v134;
        v139.characterEVOffset = characterEVOffset;
        *(__m256i *)&v140.scrollRateX = v156;
        v140.atlasTime = v157;
        v93 = *(cpose_t **)pose.v;
        v57 = *(const DObj ***)v127.v;
        CG_Entity_AddViewmodelDObjToScene((const LocalClientNum_t)v11, **(const DObj ***)v127.v, *(const cpose_t **)pose.v, v123, outRenderFlags, &v140, &v139, &vec, v64, 0, v132->markableViewmodel);
        if ( WeaponSystem->IsPlayerWeaponLaserOn(WeaponSystem, &r_weapon) )
        {
          if ( !v136 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15384, ASSERT_TYPE_ASSERT, "(localPlayerGunAngles)", (const char *)&queryFormat, "localPlayerGunAngles") )
            __debugbreak();
          RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
          if ( CG_LaserShouldDeferLocalPlayerDraw() )
          {
            CG_LaserAddDeferredDrawPlayerRequest((LocalClientNum_t)v11, v56, v8, v136, v120, &outOrg, LASER_LIGHT_ON, &r_weapon, isAlternate);
          }
          else
          {
            v94 = CG_LaserDrawPlayer((LocalClientNum_t)v11, v8, v136, v120, (DObj *)*v57, v93, &outOrg, LASER_LIGHT_ON, &r_weapon, isAlternate);
            LOBYTE(laserInfo->__vftable) = v94;
          }
          FX_Beam_SetPlayerLaser();
        }
        if ( v56 == WEAPON_HAND_DEFAULT )
        {
          pm_type = v8->pm_type;
          v96 = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v11);
          if ( pm_type < 7 )
          {
            CgWeaponSystem::OffhandWeaponVmFxUpdate(v96, &r_weapon, isAlternate);
          }
          else
          {
            CgWeaponSystem::OffhandWeaponVmFxStopAll(v96);
            v97 = CG_GetLocalClientGlobals((const LocalClientNum_t)v11);
            v97->offhandWeaponVmFxInfo.weapon = NULL_WEAPON;
            v97->offhandWeaponVmFxInfo.currentWeaponIsAlt = 0;
          }
        }
LABEL_160:
        LODWORD(v119) = ++v56;
        v130 = (const playerState_s *)((char *)v130 + 1);
        v57 += 5;
        *(_QWORD *)v127.v = v57;
        laserInfo = (CgViewSystem *)((char *)laserInfo + 12);
        if ( (__int64)v130 > *(__int64 *)functionPointer.v )
          goto LABEL_161;
      }
      OffhandAdsFrac = BG_GetOffhandAdsFrac(v8);
      OffhandGestureWeapon = BG_GetOffhandGestureWeapon(v78, v8);
      v81 = CgHandler::getHandler((LocalClientNum_t)v11);
      BG_GetScopeLensSettings(v81, v8, OffhandGestureWeapon, 0, *(const float *)&OffhandAdsFrac, &LocalClientGlobals->scopeToggleInfo.fractionInfo, &scope);
      v82 = **(const DObj ***)v127.v;
      Sys_ProfBeginNamedEvent(0xFFFAEBD7, "CG_GetScopePositionForOffhand");
      FunctionPointer_prevOrigin = *(void (__fastcall **)(const vec4_t *, vec3_t *))&scr_const.tag_front_lens_offhand;
      v83 = 0;
      p_FunctionPointer_prevOrigin = &FunctionPointer_prevOrigin;
      while ( !CG_DObjGetWorldTagMatrix(&LocalClientGlobals->viewModelPose, v82, *(scr_string_t *)p_FunctionPointer_prevOrigin, &scope.scopeLensAxis, &scope.scopeLensPos) )
      {
        ++v83;
        p_FunctionPointer_prevOrigin = (void (__fastcall **)(const vec4_t *, vec3_t *))((char *)p_FunctionPointer_prevOrigin + 4);
        if ( v83 >= 2 )
        {
          RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &scope.scopeLensPos);
          MatrixCopy33(&LocalClientGlobals->refdef.view.axis, &scope.scopeLensAxis);
          Sys_ProfEndNamedEvent();
          goto LABEL_137;
        }
      }
      Sys_ProfEndNamedEvent();
LABEL_137:
      if ( scope.dofOverride )
      {
        v141 = *(__m256i *)&scope.foundSight;
        v142 = *(__m256i *)&scope.scopeLensAxis.row1.y;
        v143 = *(__m256i *)&scope.scopeLensOuterRing;
        v144 = *(__m256i *)&scope.scopeLensBrightness;
        v145 = *(__m256i *)&scope.scopeEyeRelief_outOfFocusDistance;
        v146 = *(__m256i *)&scope.scopeEyeRelief_idleSway_movement;
        dofPhysicalFocusDistance = scope.dofPhysicalFocusDistance;
      }
LABEL_147:
      R_SceneSetupWeaponScope(&scope);
      v56 = (int)v119;
      goto LABEL_148;
    }
LABEL_161:
    LocalClientGlobals->refdef.weaponOverridesSceneDoF = 0;
    weaponIdx = r_weapon.weaponIdx;
    if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
    {
      LODWORD(settingOut) = bg_lastParsedWeaponIndex;
      LODWORD(hybridScopeFraction) = r_weapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", hybridScopeFraction, settingOut) )
        __debugbreak();
    }
    if ( !bg_weaponCompleteDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
      __debugbreak();
    v99 = bg_weaponCompleteDefs[weaponIdx];
    if ( v99 && v99->useSceneDof )
    {
      LocalClientGlobals->refdef.dofPhysical.viewModelFocusDistance = LocalClientGlobals->refdef.dofPhysical.focusDistance;
      LocalClientGlobals->refdef.dofPhysical.viewModelFstop = LocalClientGlobals->refdef.dofPhysical.fstop;
      goto LABEL_200;
    }
    dofPhysicalViewModelFocusDistance = v8->dofPhysicalViewModelFocusDistance;
    dofPhysicalViewModelFstop = v8->dofPhysicalViewModelFstop;
    adsDofPhysicalFocusDistance = v99->adsDofPhysicalFocusDistance;
    adsDofPhysicalFstop = v99->adsDofPhysicalFstop;
    v104 = v146.m256i_i8[12];
    if ( v146.m256i_i8[12] )
    {
      adsDofPhysicalFocusDistance = *(float *)&v146.m256i_i32[5];
      adsDofPhysicalFstop = *(float *)&v146.m256i_i32[4];
    }
    v105 = CgHandler::getHandler((LocalClientNum_t)v11);
    if ( !BG_PlayerUsesNVGHalfADS(v8, v105) && v146.m256i_i8[13] )
    {
      LocalClientGlobals->refdef.weaponOverridesSceneDoF = 1;
      LocalClientGlobals->refdef.dualViewScopeState.hipFocusDistance = dofPhysicalFocusDistance;
      LocalClientGlobals->refdef.dualViewScopeState.hipFstop = *(float *)&v146.m256i_i32[7];
    }
    v106 = v8->weapCommon.fWeaponPosFrac;
    if ( v106 <= 0.0 )
    {
LABEL_189:
      LocalClientGlobals->refdef.dofPhysical.viewModelFocusDistance = (float)((float)(1.0 - v106) * dofPhysicalViewModelFocusDistance) + (float)(v106 * adsDofPhysicalFocusDistance);
      v109 = I_fclamp((float)((float)(1.0 - v8->weapCommon.fWeaponPosFrac) * dofPhysicalViewModelFstop) + (float)(v8->weapCommon.fWeaponPosFrac * adsDofPhysicalFstop), 0.125, 30.0);
      LocalClientGlobals->refdef.dofPhysical.viewModelFstop = *(float *)&v109;
      goto LABEL_200;
    }
    if ( (unsigned int)(v8->weapState[0].weaponState - 18) <= 3 )
    {
      adsDofPhysicalFocusDistance = v99->adsDofPhysicalReloadFocusDistance;
      adsDofPhysicalFstop = v99->adsDofPhysicalReloadFstop;
      goto LABEL_189;
    }
    v107 = &CG_GetLocalClientGlobals((const LocalClientNum_t)v11)->viewModelPose;
    if ( !LocalClientGlobals->m_weaponHand[0].viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15443, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
      __debugbreak();
    RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &pose);
    if ( v104 )
    {
      if ( v146.m256i_i8[24] )
      {
        tag_attachment_focus = scr_const.tag_attachment_focus;
        goto LABEL_185;
      }
    }
    else if ( v99->adsDofPhysicalFocalTag )
    {
      tag_attachment_focus = scr_const.tag_weapon_focus;
LABEL_185:
      if ( CG_DObjGetWorldTagPos(v107, LocalClientGlobals->m_weaponHand[0].viewModelDObj, tag_attachment_focus, &functionPointer) )
        adsDofPhysicalFocusDistance = fsqrt((float)((float)((float)(pose.v[1] - functionPointer.v[1]) * (float)(pose.v[1] - functionPointer.v[1])) + (float)((float)(pose.v[0] - functionPointer.v[0]) * (float)(pose.v[0] - functionPointer.v[0]))) + (float)((float)(pose.v[2] - functionPointer.v[2]) * (float)(pose.v[2] - functionPointer.v[2])));
    }
    memset(&pose, 0, sizeof(pose));
    v106 = v8->weapCommon.fWeaponPosFrac;
    goto LABEL_189;
  }
}

/*
==============
CG_AddViewWeapon
==============
*/
void CG_AddViewWeapon(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v3; 
  const Weapon *ViewmodelWeapon; 
  CgWeaponSystem *WeaponSystem; 
  const dvar_t *v6; 
  const dvar_t *v7; 
  cg_t *v8; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  int v11; 
  bool hideViewModel; 
  bool v13; 
  __int64 v14; 
  bool v15; 
  float fWeaponPosFrac; 
  const tmat43_t<vec3_t> *ViewModelTransform; 
  int v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  CgViewSystem *ViewSystem; 
  vec3_t outGunAngles; 
  vec3_t outGunOffset; 
  vec3_t weapOrigin; 
  Weapon v27; 
  vec4_t weapOrient; 

  v1 = localClientNum;
  Sys_ProfBeginNamedEvent(0xFF000000, "CG_AddViewWeapon");
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  LocalClientGlobals->laserInfo[0].drawnLaserThisFrame = 0;
  LocalClientGlobals->laserInfo[1].drawnLaserThisFrame = 0;
  CG_LaserClearDeferredDrawPlayerRequests((LocalClientNum_t)v1);
  LocalClientGlobals->nvgInfo.nvgAreaLightFXProcessedThisFrame = 0;
  if ( !CgWeaponMap::ms_instance[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v3 = CgWeaponMap::ms_instance[v1];
  ViewmodelWeapon = BG_GetViewmodelWeapon(v3, &LocalClientGlobals->predictedPlayerState);
  *(_QWORD *)outGunOffset.v = ViewmodelWeapon;
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v1);
  WeaponSystem->TouchHandModel(WeaponSystem);
  if ( ViewmodelWeapon->weaponIdx )
  {
    if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1105, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1106, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v6 = DVARBOOL_bg_giveAll;
    if ( !DVARBOOL_bg_giveAll || (Dvar_CheckFrontendServerThread(DVARBOOL_bg_giveAll), !v6->current.enabled) )
    {
      if ( !BG_GetEquippedWeaponStateConst(v3, &LocalClientGlobals->predictedPlayerState, ViewmodelWeapon) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15855, ASSERT_TYPE_ASSERT, "(BG_PlayerHasWeapon( weaponMap, ps, r_weapon ))", (const char *)&queryFormat, "BG_PlayerHasWeapon( weaponMap, ps, r_weapon )") )
        __debugbreak();
    }
    CG_TouchViewModel((const LocalClientNum_t)v1, ViewmodelWeapon, LocalClientGlobals->playerWeaponInfo.isWeaponDefault, &LocalClientGlobals->predictedPlayerState);
  }
  if ( LocalClientGlobals->predictedPlayerState.accessoryIndex != 127 )
  {
    BG_Accessory_GetWeapon(v3, &LocalClientGlobals->predictedPlayerState, &v27);
    if ( !v27.weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15865, ASSERT_TYPE_ASSERT, "(!BG_IsNullWeapon( accessoryWeapon ))", (const char *)&queryFormat, "!BG_IsNullWeapon( accessoryWeapon )") )
      __debugbreak();
    if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1105, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    v7 = DVARBOOL_bg_giveAll;
    if ( !DVARBOOL_bg_giveAll || (Dvar_CheckFrontendServerThread(DVARBOOL_bg_giveAll), !v7->current.enabled) )
    {
      if ( !BG_GetEquippedWeaponStateConst(v3, &LocalClientGlobals->predictedPlayerState, &v27) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15866, ASSERT_TYPE_ASSERT, "(BG_PlayerHasWeapon( weaponMap, ps, accessoryWeapon ))", (const char *)&queryFormat, "BG_PlayerHasWeapon( weaponMap, ps, accessoryWeapon )") )
        __debugbreak();
    }
    CG_TouchViewModel((const LocalClientNum_t)v1, &v27, LocalClientGlobals->playerWeaponInfo.isAccessoryDefault, &LocalClientGlobals->predictedPlayerState);
  }
  if ( cgMedia.nightVisionGoggles )
    Stream_TouchXModel(cgMedia.nightVisionGoggles, MIP3);
  LocalClientGlobals->refdef.dofPhysical.viewModelFocusDistance = 29.301001;
  LocalClientGlobals->refdef.dofPhysical.viewModelFstop = 22.0;
  CgWeaponSystem::OffHandWeaponsUpdate(WeaponSystem, &LocalClientGlobals->predictedPlayerState);
  if ( (unsigned int)(LocalClientGlobals->predictedPlayerState.pm_type - 5) > 1 )
  {
    CG_NightVisionProcessLightFX((LocalClientNum_t)v1, &LocalClientGlobals->predictedPlayerState, NULL, WEAPON_HAND_DEFAULT);
    v8 = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
    if ( !v8->renderingThirdPerson )
    {
      p_predictedPlayerState = &v8->predictedPlayerState;
      Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v1);
      if ( !BG_IsThirdPersonMode(Instance, p_predictedPlayerState) && !CG_Camera_Transition_IsHidingViewmodel((LocalClientNum_t)v1) && WeaponSystem->DrawUFOViewModel(WeaponSystem, &LocalClientGlobals->predictedPlayerState) && LocalClientGlobals->predictedPlayerState.pm_type != 4 )
      {
        if ( LocalClientGlobals->cubemapShot || !Dvar_GetBool_Internal_DebugName(DVARBOOL_cg_drawGun, "cg_drawGun") || (v11 = 1, CG_GetWeapReticleZoom(LocalClientGlobals, NULL)) && !BG_HasDualFOVEquipped(v3, &LocalClientGlobals->predictedPlayerState) )
          v11 = 0;
        hideViewModel = LocalClientGlobals->hideViewModel;
        if ( !BG_IsTurretActive(&LocalClientGlobals->predictedPlayerState) && !BG_IsVehicleActive(&LocalClientGlobals->predictedPlayerState) || BG_IsUsingTurretViewarms(v3, &LocalClientGlobals->predictedPlayerState) )
        {
          if ( (LocalClientGlobals->predictedPlayerState.linkFlags.m_flags[0] & 4) != 0 || (v13 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, ACTIVE, 1u)) )
            v13 = 1;
          if ( **(_WORD **)outGunOffset.v && !v13 && LocalClientGlobals->playerWeaponInfo.handModel )
          {
            v14 = LocalClientGlobals->localClientNum;
            if ( !CgWeaponMap::ms_instance[v14] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
              __debugbreak();
            v27 = *BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v14], &LocalClientGlobals->predictedPlayerState);
            v15 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
            if ( BG_IsAimDownSight(&v27, v15) )
            {
              fWeaponPosFrac = LocalClientGlobals->predictedPlayerState.weapCommon.fWeaponPosFrac;
              if ( fWeaponPosFrac == 1.0 )
              {
                LocalClientGlobals->playerEntity.bPositionToADS = 0;
              }
              else if ( fWeaponPosFrac == 0.0 )
              {
                LocalClientGlobals->playerEntity.bPositionToADS = 1;
              }
            }
            ViewModelTransform = cg_t::GetViewModelTransform(LocalClientGlobals);
            CG_Weapons_CalculateMovement(LocalClientGlobals, &LocalClientGlobals->playerViewValues, ViewModelTransform, &outGunOffset, &outGunAngles, &weapOrigin, &weapOrient);
            v18 = 0;
            if ( !hideViewModel )
              v18 = v11;
            CG_AddPlayerWeapon((LocalClientNum_t)v1, &weapOrigin, &weapOrient, &LocalClientGlobals->predictedPlayerState, &outGunAngles, LocalClientGlobals->predictedPlayerEntity, v18, NULL);
            v19 = outGunOffset.v[2];
            v20 = outGunOffset.v[1];
            v21 = outGunOffset.v[0];
          }
          else
          {
            v22 = LocalClientGlobals->refdefViewAngles.v[1];
            outGunAngles.v[0] = LocalClientGlobals->refdefViewAngles.v[0];
            outGunAngles.v[1] = v22;
            v19 = 0.0;
            outGunAngles.v[2] = 0.0;
            v21 = 0.0;
            v20 = 0.0;
            ViewSystem = CgViewSystem::GetViewSystem((const LocalClientNum_t)v1);
            if ( !ViewSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15959, ASSERT_TYPE_ASSERT, "(view)", (const char *)&queryFormat, "view") )
              __debugbreak();
            ViewSystem->CalcLinkedToPlayerViewTags(ViewSystem, VM_NONE);
          }
          if ( LocalClientGlobals->originPredicted || LocalClientGlobals->originInterpolated )
          {
            LocalClientGlobals->gunOffset.v[0] = v21;
            LocalClientGlobals->gunOffset.v[1] = v20;
            LocalClientGlobals->gunOffset.v[2] = v19;
            LocalClientGlobals->gunAngles = outGunAngles;
          }
          LocalClientGlobals->gunAnglesExtrapolated = outGunAngles;
        }
      }
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_AppendNameToBuffer
==============
*/
void CG_AppendNameToBuffer(const char *delimiter, const char *newName, unsigned __int64 *outputLen, unsigned __int64 bufferLen, char *outputBuffer)
{
  const char *v8; 
  unsigned __int64 v9; 
  unsigned __int64 v10; 
  char i; 
  char j; 

  v8 = delimiter;
  if ( !delimiter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22332, ASSERT_TYPE_ASSERT, "(delimiter)", (const char *)&queryFormat, "delimiter") )
    __debugbreak();
  if ( !outputLen && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22333, ASSERT_TYPE_ASSERT, "(outputLen)", (const char *)&queryFormat, "outputLen") )
    __debugbreak();
  if ( !outputBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22334, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
    __debugbreak();
  v9 = *outputLen;
  v10 = *outputLen;
  if ( *outputLen )
  {
    for ( i = *v8; *v8; i = *v8 )
    {
      v10 = v9;
      if ( v9 >= bufferLen - 1 )
        break;
      outputBuffer[v9] = i;
      ++v8;
      v10 = *outputLen + 1;
      *outputLen = v10;
      v9 = v10;
    }
  }
  if ( newName )
  {
    for ( j = *newName; *newName; j = *newName )
    {
      if ( v10 >= bufferLen - 1 )
        break;
      outputBuffer[v10] = j;
      ++newName;
      v10 = ++*outputLen;
    }
  }
}

/*
==============
CG_BinocularsADS
==============
*/
bool CG_BinocularsADS(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  bool result; 
  CgWeaponMap *Instance; 
  const Weapon *OffhandGestureWeapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  result = BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState);
  if ( result )
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    OffhandGestureWeapon = BG_GetOffhandGestureWeapon(Instance, &LocalClientGlobals->predictedPlayerState);
    return BG_WeaponDef(OffhandGestureWeapon, 0)->overlayInterface == WEAPOVERLAYINTERFACE_BINOCULARS;
  }
  return result;
}

/*
==============
CG_BinocularsGetZoomLevel
==============
*/
int CG_BinocularsGetZoomLevel(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  const Weapon *OffhandGestureWeapon; 
  cg_t *v5; 
  CgWeaponMap *v6; 
  const Weapon *v7; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  OffhandGestureWeapon = BG_GetOffhandGestureWeapon(Instance, &LocalClientGlobals->predictedPlayerState);
  if ( BG_WeaponDef(OffhandGestureWeapon, 0)->overlayInterface != WEAPOVERLAYINTERFACE_BINOCULARS )
    return 0;
  v5 = CG_GetLocalClientGlobals(localClientNum);
  v6 = CgWeaponMap::GetInstance(localClientNum);
  v7 = BG_GetOffhandGestureWeapon(v6, &v5->predictedPlayerState);
  memset(&outZoomInfo, 0, sizeof(outZoomInfo));
  hybridScopeFractionInfo = 0i64;
  BG_GetADSZoomInfo(v6, v7, 0, &hybridScopeFractionInfo, &outZoomInfo);
  return BG_GetADSZoomLevel(v6, &v5->predictedPlayerState, v7, outZoomInfo.zoomCount);
}

/*
==============
CG_BinocularsThermalEnabled
==============
*/
bool CG_BinocularsThermalEnabled(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  const Weapon *OffhandGestureWeapon; 
  cg_t *v5; 
  CgWeaponMap *v6; 
  const Weapon *v7; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  OffhandGestureWeapon = BG_GetOffhandGestureWeapon(Instance, &LocalClientGlobals->predictedPlayerState);
  if ( BG_WeaponDef(OffhandGestureWeapon, 0)->overlayInterface != WEAPOVERLAYINTERFACE_BINOCULARS )
    return 0;
  v5 = CG_GetLocalClientGlobals(localClientNum);
  v6 = CgWeaponMap::GetInstance(localClientNum);
  v7 = BG_GetOffhandGestureWeapon(v6, &v5->predictedPlayerState);
  return BG_IsThermalEnabled(v6, v7, &v5->predictedPlayerState);
}

/*
==============
CG_BulletHitClientEvent
==============
*/
void CG_BulletHitClientEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *startPos, const vec3_t *position, int surfType, int event, unsigned int impactEffects, SndHitArmorType hitArmorType)
{
  CgWeaponSystem *WeaponSystem; 

  if ( sourceEntityNum < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20697, ASSERT_TYPE_ASSERT, "(sourceEntityNum >= 0)", (const char *)&queryFormat, "sourceEntityNum >= 0") )
    __debugbreak();
  if ( sourceEntityNum == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20698, ASSERT_TYPE_ASSERT, "(sourceEntityNum != ENTITYNUM_NONE)", (const char *)&queryFormat, "sourceEntityNum != ENTITYNUM_NONE") )
    __debugbreak();
  if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20699, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFF008080, "CG_BulletHitClientEvent");
  BulletHitClientEventSound(localClientNum, sourceEntityNum, weapon, isAlternate, position, surfType, event, impactEffects, hitArmorType);
  if ( (impactEffects & 4) == 0 )
  {
    WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
    WeaponSystem->BulletTrajectoryEffects(WeaponSystem, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, event);
  }
  CG_Rumble_PlayOnPositionByName(localClientNum, "damage_bullet", startPos);
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_BulletHitClientShieldEvent
==============
*/
void CG_BulletHitClientShieldEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, int surfType, int event, unsigned int eventParm)
{
  cg_t *LocalClientGlobals; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  const dvar_t *v16; 
  int integer; 
  const dvar_t *v18; 
  bool v19; 
  cg_t *v20; 
  __int64 delayedShieldHitEventsCount; 
  bool resultHitFront; 
  vec3_t outOrg; 
  __int64 v24; 
  vec3_t result; 

  v24 = -2i64;
  if ( sourceEntityNum < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21088, ASSERT_TYPE_ASSERT, "(sourceEntityNum >= 0)", (const char *)&queryFormat, "sourceEntityNum >= 0") )
    __debugbreak();
  if ( sourceEntityNum == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21089, ASSERT_TYPE_ASSERT, "(sourceEntityNum != ENTITYNUM_NONE)", (const char *)&queryFormat, "sourceEntityNum != ENTITYNUM_NONE") )
    __debugbreak();
  if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21090, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  BG_ShieldHitDecode((unsigned __int8)eventParm, &result, &resultHitFront);
  v12 = LocalClientGlobals->refdef.view.axis.m[0].v[1];
  v13 = LocalClientGlobals->refdef.view.axis.m[0].v[2];
  v14 = (float)((float)((float)(result.v[1] * LocalClientGlobals->refdef.view.axis.m[1].v[1]) + (float)(result.v[0] * v12)) + (float)(result.v[2] * LocalClientGlobals->refdef.view.axis.m[2].v[1])) + LocalClientGlobals->refdef.viewOffset.v[1];
  v15 = (float)((float)((float)(result.v[1] * LocalClientGlobals->refdef.view.axis.m[1].v[2]) + (float)(result.v[0] * v13)) + (float)(result.v[2] * LocalClientGlobals->refdef.view.axis.m[2].v[2])) + LocalClientGlobals->refdef.viewOffset.v[2];
  result.v[0] = (float)(LocalClientGlobals->refdef.view.axis.m[0].v[0] * 10.0) + (float)((float)((float)((float)(result.v[0] * LocalClientGlobals->refdef.view.axis.m[0].v[0]) + (float)(result.v[1] * LocalClientGlobals->refdef.view.axis.m[1].v[0])) + (float)(result.v[2] * LocalClientGlobals->refdef.view.axis.m[2].v[0])) + LocalClientGlobals->refdef.viewOffset.v[0]);
  result.v[1] = (float)(v12 * 10.0) + v14;
  result.v[2] = (float)(v13 * 10.0) + v15;
  CG_Rumble_PlayOnClientSafeByName(localClientNum, "riotshield_impact");
  RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
  v16 = DVARINT_shieldImpactBulletShakeDuration;
  if ( !DVARINT_shieldImpactBulletShakeDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactBulletShakeDuration") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v16);
  integer = v16->current.integer;
  v18 = DVARFLT_shieldImpactBulletShakeScale;
  if ( !DVARFLT_shieldImpactBulletShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactBulletShakeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v18);
  CG_StartShakeCamera(localClientNum, v18->current.value, integer, &outOrg, 100.0);
  BulletHitClientEventSound(localClientNum, sourceEntityNum, weapon, isAlternate, &result, surfType, event, 0x80u, SND_HIT_ARMOR_TYPE_NONE);
  v19 = resultHitFront;
  v20 = CG_GetLocalClientGlobals(localClientNum);
  delayedShieldHitEventsCount = v20->delayedShieldHitEventsCount;
  if ( (int)delayedShieldHitEventsCount < 2 )
  {
    v20->delayedShieldHitEvents[delayedShieldHitEventsCount].eventParm = eventParm;
    v20->delayedShieldHitEvents[v20->delayedShieldHitEventsCount++].damaged = v19;
  }
  CG_OffhandShield_DamageFeedback(localClientNum, sourceEntityNum, eventParm, resultHitFront);
  memset(&outOrg, 0, sizeof(outOrg));
}

/*
==============
CG_BulletHitEffectCallback
==============
*/
void CG_BulletHitEffectCallback(const LocalClientNum_t localClientNum, unsigned int hitBody, unsigned int shapeKey, const vec3_t *start, const vec3_t *hitPos, const int hitSurfaceFlags, const vec3_t *hitNormal, const scr_string_t *partName, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, int mod)
{
  __int128 v13; 
  __int64 v15; 
  cg_t *LocalClientGlobals; 
  __int64 *p_npcImpactSounds; 
  int VFXImpactType; 
  RegisteredImpactType v19; 
  RegisteredImpactType v20; 
  FXRegisteredDef *v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v25; 
  const ParticleSystemDef *particleSystemDef; 
  int Ref; 
  Physics_WorldId RefSystem; 
  __int64 v29; 
  unsigned __int8 IsBoneDismembered; 
  int EntityNum; 
  const DObj *ClientDObj; 
  const DObj *v33; 
  scr_string_t v34; 
  __int64 v35; 
  FXRegisteredDef *v36; 
  unsigned int v37; 
  float v38; 
  int markEntnum; 
  scr_string_t v40; 
  centity_t *Entity; 
  const DObj *v42; 
  unsigned __int16 spawnFlags; 
  const Material *markMaterialOverride; 
  cg_t *v45; 
  unsigned __int16 v46; 
  unsigned __int16 v47; 
  unsigned int dynEntDefId; 
  cg_t *v49; 
  unsigned int BoneIdx; 
  cg_t *v51; 
  cg_t *v52; 
  __int64 v53; 
  CgSoundSystem *SoundSystem; 
  vec3_t *v55; 
  const DynEntityDef *v56; 
  unsigned int runtimeInstanceCount; 
  unsigned int v58; 
  unsigned int RefSubSystem; 
  unsigned int RefId; 
  vec3_t *worldOrigin; 
  tmat33_t<vec3_t> *worldAxis; 
  unsigned __int8 inOutIndex; 
  DynEntityBasis basisOut; 
  unsigned __int8 markBoneIndex[6]; 
  vec3_t *origin; 
  int impactType; 
  unsigned int bodyId; 
  Physics_WorldId worldId; 
  unsigned int dynEntIdOut; 
  __int64 v71; 
  int sourceEntityNum; 
  const scr_string_t *v73; 
  FXRegisteredDef def[2]; 
  unsigned int shapeKeya; 
  __int64 v76; 
  FXRegisteredDef *v77; 
  Weapon *r_weapon; 
  vec3_t *starta; 
  tmat33_t<vec3_t> left; 
  __int128 v81; 

  origin = (vec3_t *)hitPos;
  bodyId = hitBody;
  v15 = localClientNum;
  v73 = partName;
  starta = (vec3_t *)start;
  shapeKeya = shapeKey;
  sourceEntityNum = inflictorEntNum;
  r_weapon = (Weapon *)weapon;
  Sys_ProfBeginNamedEvent(0xFF008008, "CG_BulletHitEffectCallback");
  worldId = 3 * v15 + 3;
  if ( !Physics_IsRigidBodyValid(worldId, hitBody) || !cgMedia.impactFx )
    goto LABEL_102;
  v81 = v13;
  dynEntIdOut = (hitSurfaceFlags >> 19) & 0x3F;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v15);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14705, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_npcImpactSounds = (__int64 *)&cgMedia.npcImpactSounds;
  if ( CG_IsPlayerEntityNumber(&LocalClientGlobals->predictedPlayerState, inflictorEntNum) )
    p_npcImpactSounds = (__int64 *)&cgMedia.playerImpactSounds;
  Sys_ProfBeginNamedEvent(0xFF008008, "Calculate FX");
  VFXImpactType = CG_Weapons_GetVFXImpactType((LocalClientNum_t)v15, inflictorEntNum, weapon, isAlternate);
  impactType = CG_Weapons_GetSFXImpactType((LocalClientNum_t)v15, sourceEntityNum, weapon, isAlternate);
  v19 = CG_Main_ImpactTypeToRegisteredImpactType(VFXImpactType);
  if ( v19 != -1 )
  {
    switch ( v19 )
    {
      case 5:
        v20 = 4;
        break;
      case 7:
        v20 = 6;
        break;
      case 16:
        v20 = 15;
        break;
      default:
        goto LABEL_16;
    }
    VFXImpactType = CG_Main_RegisteredImpactTypeToImpactType(v20);
  }
LABEL_16:
  v21 = def;
  v22 = 2i64;
  do
  {
    FXRegisteredDef::FXRegisteredDef(v21++);
    --v22;
  }
  while ( v22 );
  v23 = 0i64;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&def[0].m_particleSystemDef = _XMM0;
  if ( VFXImpactType >= 0 && (hitSurfaceFlags & 0x10) == 0 && cgMedia.impactFx )
  {
    if ( !cgMedia.impactFx->table && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20022, ASSERT_TYPE_ASSERT, "(cgMedia.impactFx->table)", (const char *)&queryFormat, "cgMedia.impactFx->table") )
      __debugbreak();
    v25 = (hitSurfaceFlags >> 19) & 0x3F;
    do
    {
      if ( VFXImpactType >= cgMedia.impactFx->impactTypeCount )
      {
        LODWORD(worldAxis) = cgMedia.impactFx->impactTypeCount;
        LODWORD(worldOrigin) = VFXImpactType;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20025, ASSERT_TYPE_ASSERT, "(unsigned)( impactType ) < (unsigned)( cgMedia.impactFx->impactTypeCount )", "impactType doesn't index cgMedia.impactFx->impactTypeCount\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
          __debugbreak();
      }
      particleSystemDef = cgMedia.impactFx->table[VFXImpactType].normal->nonflesh[v25].particleSystemDef;
      v25 += 87i64;
      def[v23++].m_particleSystemDef = particleSystemDef;
    }
    while ( v23 < 2 );
  }
  Sys_ProfEndNamedEvent();
  Sys_ProfBeginNamedEvent(0xFF008008, "Calculate Sound");
  v71 = 0i64;
  switch ( CG_Main_ImpactTypeToRegisteredImpactType(impactType) )
  {
    case 1:
    case 2:
      v71 = p_npcImpactSounds[2];
      break;
    case 3:
    case 4:
      v71 = p_npcImpactSounds[1];
      break;
    case 5:
      v71 = *p_npcImpactSounds;
      break;
    case 6:
    case 7:
      v71 = p_npcImpactSounds[3];
      break;
    case 15:
    case 16:
      v71 = p_npcImpactSounds[4];
      break;
    default:
      break;
  }
  Sys_ProfEndNamedEvent();
  Ref = Physics_GetRef(worldId, bodyId);
  RefSystem = Physics_GetRefSystem(Ref);
  v29 = RefSystem;
  IsBoneDismembered = 0;
  worldId = RefSystem;
  inOutIndex = 0;
  if ( RefSystem == PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE )
  {
    EntityNum = Physics_GetEntityNum(Ref);
    if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_corpseImpactEffectsEnabled, "corpseImpactEffectsEnabled") )
    {
      inOutIndex = CG_CorpseFade_CullImpactEffects((const LocalClientNum_t)v15, EntityNum);
      IsBoneDismembered = inOutIndex;
      if ( !inOutIndex )
      {
        if ( v73 )
        {
          if ( *v73 )
          {
            if ( FX_Dismemberment_EntryExists((LocalClientNum_t)v15, EntityNum) )
            {
              ClientDObj = Com_GetClientDObj(EntityNum, (LocalClientNum_t)v15);
              v33 = ClientDObj;
              if ( ClientDObj )
              {
                v34 = *v73;
                inOutIndex = -2;
                DObjGetBoneIndexInternal_66(ClientDObj, v34, &inOutIndex, (int *)&bodyId);
                IsBoneDismembered = FX_Dismemberment_IsBoneDismembered((LocalClientNum_t)v15, v33, inOutIndex, 0);
                inOutIndex = IsBoneDismembered;
              }
            }
          }
        }
      }
    }
    else
    {
      IsBoneDismembered = 1;
      inOutIndex = 1;
    }
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "Play FX");
  v35 = v29;
  v76 = v29;
  v36 = def;
  v37 = 0;
  v77 = def;
  do
  {
    if ( v36->m_particleSystemDef && !IsBoneDismembered && (hitNormal->v[0] != 0.0 || hitNormal->v[1] != 0.0 || hitNormal->v[2] != 0.0) )
    {
      v38 = hitNormal->v[2];
      *(_QWORD *)left.row2.v = *(_QWORD *)hitNormal->v;
      left.m[2].v[2] = v38;
      AxisRandomAroundForward(&left.m[2], left.m, &left.m[1]);
      if ( v35 == 6 )
      {
        markEntnum = Physics_GetEntityNum(Ref);
        markBoneIndex[0] = -2;
        v40 = *v73;
        Entity = CG_GetEntity((const LocalClientNum_t)v15, markEntnum);
        if ( Entity )
        {
          v42 = Com_GetClientDObj(Entity->nextState.number, (LocalClientNum_t)v15);
          if ( v42 )
          {
            if ( v40 )
              DObjGetBoneIndexInternal_66(v42, v40, markBoneIndex, (int *)&bodyId);
          }
        }
        spawnFlags = 0;
        if ( !BG_GetWeaponDismembermentEnabled(r_weapon, isAlternate) )
          spawnFlags = 128;
        markMaterialOverride = MARK_MATERIAL_OVERRIDE_NONE_2;
        v45 = CG_GetLocalClientGlobals((const LocalClientNum_t)v15);
        FX_PlayBoltedOffsetEffectWithMarkEntity((LocalClientNum_t)v15, &def[v37], v45->time, markEntnum, markBoneIndex[0], origin, &left, spawnFlags, markEntnum, 0, markBoneIndex[0], markMaterialOverride);
        v36 = v77;
        v35 = v76;
      }
      else if ( v35 == 1 && fx_marks_dynents_ext_killswitch->current.enabled && (DynEnt_GetBasisAndDynEntClientId(Ref, &basisOut, (unsigned __int16 *)&impactType), basisOut == DYNENT_BASIS_MODEL) )
      {
        v46 = impactType;
        if ( (unsigned int)v15 >= 2 )
        {
          LODWORD(worldAxis) = 2;
          LODWORD(worldOrigin) = v15;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 322, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
            __debugbreak();
        }
        v47 = g_dynEntClientEntsAllocCount[v15][0];
        if ( v46 >= v47 )
        {
          LODWORD(worldAxis) = v47;
          LODWORD(worldOrigin) = v46;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 324, ASSERT_TYPE_ASSERT, "(unsigned)( clientId ) < (unsigned)( g_dynEntClientEntsAllocCount[localClientNum][basis] )", "clientId doesn't index g_dynEntClientEntsAllocCount[localClientNum][basis]\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
            __debugbreak();
        }
        if ( !g_dynEntClientLists[v15][0] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 325, ASSERT_TYPE_ASSERT, "(g_dynEntClientLists[localClientNum][basis])", (const char *)&queryFormat, "g_dynEntClientLists[localClientNum][basis]") )
          __debugbreak();
        dynEntDefId = g_dynEntClientLists[v15][0][v46].dynEntDefId;
        if ( (unsigned __int8)(DynEnt_GetDef(dynEntDefId, DYNENT_BASIS_MODEL)->type - 1) <= 3u )
        {
          BoneIdx = DynEnt_GetBoneIdx((LocalClientNum_t)v15, dynEntDefId, *v73, "CG_BulletHitEffectCallback");
          v51 = CG_GetLocalClientGlobals((const LocalClientNum_t)v15);
          FX_PlayBoltedOffsetToDynEntEffectWithMarkEntity((LocalClientNum_t)v15, &def[v37], v51->time, dynEntDefId, BoneIdx, origin, &left);
        }
        else
        {
          v49 = CG_GetLocalClientGlobals((const LocalClientNum_t)v15);
          FX_PlayOrientedEffect((LocalClientNum_t)v15, &def[v37], v49->time, origin, &left);
        }
        v35 = v76;
      }
      else
      {
        v52 = CG_GetLocalClientGlobals((const LocalClientNum_t)v15);
        FX_PlayOrientedEffect((LocalClientNum_t)v15, &def[v37], v52->time, origin, &left);
      }
    }
    IsBoneDismembered = inOutIndex;
    ++v36;
    ++v37;
    v77 = v36;
  }
  while ( v37 < 2 );
  Sys_ProfEndNamedEvent();
  v53 = v71;
  if ( !v71 || IsBoneDismembered )
  {
    v55 = origin;
  }
  else
  {
    Sys_ProfBeginNamedEvent(0xFF008008, "Play Sound");
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)v15);
    v55 = origin;
    ((void (__fastcall *)(CgSoundSystem *, __int64, vec3_t *, __int64, unsigned int, _DWORD, _DWORD, _DWORD))SoundSystem->PlaySurfaceSound)(SoundSystem, 2046i64, origin, v53, dynEntIdOut, LODWORD(FLOAT_1_0), LODWORD(FLOAT_1_0), 0);
    Sys_ProfEndNamedEvent();
  }
  if ( worldId == PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    Sys_ProfBeginNamedEvent(0xFF008008, "Scriptable Damage Check");
    DynEnt_GetBasisAndDynEntId(Ref, (const LocalClientNum_t)v15, &basisOut, &dynEntIdOut);
    v56 = DynEnt_GetDef(dynEntIdOut, basisOut);
    if ( !v56 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14904, ASSERT_TYPE_ASSERT, "(dynEntDef)", (const char *)&queryFormat, "dynEntDef") )
      __debugbreak();
    if ( v56->type == DYNENT_TYPE_SCRIPTABLEINST )
    {
      if ( !cm.mapEnts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_common_utility.h", 113, ASSERT_TYPE_ASSERT, "( cm.mapEnts != nullptr )", (const char *)&queryFormat, "cm.mapEnts != nullptr") )
        __debugbreak();
      if ( v56->scriptableMapIndex >= cm.mapEnts->scriptableMapEnts.mapInstanceCount )
      {
        LODWORD(worldAxis) = cm.mapEnts->scriptableMapEnts.mapInstanceCount;
        LODWORD(worldOrigin) = v56->scriptableMapIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14910, ASSERT_TYPE_ASSERT, "(unsigned)( dynEntDef->scriptableMapIndex ) < (unsigned)( ScriptableCommon_GetMapInstanceCount() )", "dynEntDef->scriptableMapIndex doesn't index ScriptableCommon_GetMapInstanceCount()\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
          __debugbreak();
      }
      ScriptableCommon_AssertCountsInitialized();
      runtimeInstanceCount = g_scriptableWorldCounts.runtimeInstanceCount;
      if ( !cm.mapEnts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_common_utility.h", 106, ASSERT_TYPE_ASSERT, "( cm.mapEnts != nullptr )", (const char *)&queryFormat, "cm.mapEnts != nullptr") )
        __debugbreak();
      v58 = runtimeInstanceCount + cm.mapEnts->scriptableMapEnts.lootInstanceCount + v56->scriptableMapIndex;
      ScriptableCommon_AssertCountsInitialized();
      if ( v58 >= g_scriptableWorldCounts.totalInstanceCount )
      {
        ScriptableCommon_AssertCountsInitialized();
        LODWORD(worldAxis) = g_scriptableWorldCounts.totalInstanceCount;
        LODWORD(worldOrigin) = v58;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14913, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( ScriptableCommon_GetTotalInstanceCount() )", "scriptableIndex doesn't index ScriptableCommon_GetTotalInstanceCount()\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
          __debugbreak();
      }
      ScriptableCl_EntityBulletHitEvent((const LocalClientNum_t)v15, v58, sourceEntityNum, starta, v55, mod, r_weapon, isAlternate, *v73);
    }
    Sys_ProfEndNamedEvent();
  }
  else if ( worldId == (PHYSICS_WORLD_ID_COUNT|PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE) )
  {
    RefSubSystem = Physics_GetRefSubSystem(Ref);
    RefId = Physics_GetRefId(Ref);
    if ( Cloth_IsInstanceInUse(v15, RefId) )
      Cloth_Update_ApplyBulletImpact(v15, RefId, RefSubSystem, shapeKeya, starta, v55);
  }
LABEL_102:
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_CalcBallisticBulletEffectTime
==============
*/
__int64 CG_CalcBallisticBulletEffectTime(const cg_t *cgameGlob, const vec3_t *initialBulletPos, const float fullTraceLength, const vec3_t *effectPos, const bool isBallisticRound, const int ballisticSimStartTime)
{
  const dvar_t *v10; 
  float v11; 
  float v12; 
  double v13; 
  const dvar_t *v14; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24330, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v10 = DCONST_DVARBOOL_bg_ballisticsSyncImpactFx;
  if ( !DCONST_DVARBOOL_bg_ballisticsSyncImpactFx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSyncImpactFx") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( !v10->current.enabled || !isBallisticRound || fullTraceLength <= 0.000001 )
    return (unsigned int)cgameGlob->time;
  v11 = effectPos->v[1] - initialBulletPos->v[1];
  v12 = effectPos->v[2] - initialBulletPos->v[2];
  v13 = I_fclamp(fsqrt((float)((float)(v11 * v11) + (float)((float)(effectPos->v[0] - initialBulletPos->v[0]) * (float)(effectPos->v[0] - initialBulletPos->v[0]))) + (float)(v12 * v12)) * (float)(1.0 / fullTraceLength), 0.0, 1.0);
  v14 = DCONST_DVARINT_bg_ballisticsSimTimeStepMs;
  if ( !DCONST_DVARINT_bg_ballisticsSimTimeStepMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSimTimeStepMs") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  return (unsigned int)(int)(float)((float)((float)(ballisticSimStartTime + v14->current.integer) * *(float *)&v13) + (float)((float)(1.0 - *(float *)&v13) * (float)ballisticSimStartTime));
}

/*
==============
CG_CalculateWeaponMovement_CalcAngles
==============
*/
void CG_CalculateWeaponMovement_CalcAngles(const cg_t *cgameGlob, const PlayerViewValues *viewValues, const vec3_t *weapOrigin, const vec3_t *weapAngles, const vec3_t *springTiltAngles, const float springTiltOffset, vec3_t *outGunAngles, vec3_t *outWeapOrigin, vec4_t *outWeapOrient)
{
  float v13; 
  float v14; 
  float v15; 
  const dvar_t *v16; 
  LocalClientNum_t localClientNum; 
  ClientFov *ViewFovBySpace; 
  double v19; 
  ClientFov *v20; 
  double v21; 
  __int64 v22; 
  CgWeaponMap *v23; 
  PlayerHandIndex v24; 
  int *p_weaponState; 
  __int64 v26; 
  unsigned __int64 v27; 
  PlayerHandIndex WeaponHand; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  float v43; 
  float v44; 
  float v45; 
  float v46; 
  float v47; 
  float v48; 
  __int64 v49; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  const dvar_t *v55; 
  vec3_t *p_weapDuckedAnglesPivotOffset; 
  float v57; 
  float v58; 
  float v59; 
  const dvar_t *v60; 
  const dvar_t *v61; 
  vec3_t *p_weapVmMotionPivotOffset; 
  float v63; 
  float v64; 
  float v65; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v68; 
  bool enabled; 
  vec4_t v70; 
  vec3_t pivotPoint; 
  vec3_t dst; 
  vec3_t center; 
  tmat33_t<vec3_t> axis; 
  vec4_t quat; 
  vec4_t result; 
  vec3_t angles; 
  vec3_t v78; 
  vec3_t v79; 
  vec3_t v80; 
  vec3_t v81; 
  vec3_t v82; 
  tmat33_t<vec3_t> rotation; 
  vec3_t localGunAngles; 
  tmat33_t<vec3_t> in1; 
  tmat33_t<vec3_t> out; 
  tmat33_t<vec3_t> v87; 
  tmat33_t<vec3_t> v88; 

  *(_QWORD *)pivotPoint.v = springTiltAngles;
  *(_QWORD *)center.v = outWeapOrigin;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14146, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  AnglesToAxis(&cgameGlob->baseGunAngles, &axis);
  v13 = FLOAT_1_0;
  *outWeapOrigin = *weapOrigin;
  v14 = weapAngles->v[1];
  angles.v[0] = weapAngles->v[0];
  v15 = weapAngles->v[2];
  v16 = DVARBOOL_cg_gun_motion_enable_fov_compensation;
  angles.v[1] = v14;
  angles.v[2] = v15;
  if ( !DVARBOOL_cg_gun_motion_enable_fov_compensation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_motion_enable_fov_compensation") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v16);
  enabled = v16->current.enabled;
  if ( enabled )
  {
    if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14110, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    localClientNum = cgameGlob->localClientNum;
    ViewFovBySpace = CG_GetViewFovBySpace((ClientFov *)&result, localClientNum, CG_FovSpace_Scene, 0);
    v19 = *(double *)&ViewFovBySpace->finalFov;
    v70.v[2] = ViewFovBySpace->baseFovAdjustment;
    *(double *)v70.v = v19;
    if ( CG_View_ShouldRenderGunAtDifferentFov(cgameGlob, &cgameGlob->predictedPlayerState) )
    {
      v20 = CG_GetViewFovBySpace((ClientFov *)&v70, localClientNum, CG_FovSpace_DepthHack, 0);
      v21 = *(double *)&v20->finalFov;
      v70.v[2] = v20->baseFovAdjustment;
      *(double *)v70.v = v21;
    }
    else
    {
      LODWORD(v21) = LODWORD(v19);
    }
    v13 = *(float *)&v21 / *(float *)&v19;
    AnglesToQuat(&angles, &v70);
    QuatSlerp(&quat_identity, &v70, *(float *)&v21 / *(float *)&v19, &result);
    QuatToAngles(&result, &angles);
  }
  AnglesToAxis(&angles, &in1);
  MatrixMultiply(&in1, &axis, &out);
  AxisToQuat(&out, outWeapOrient);
  v22 = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[v22] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v23 = CgWeaponMap::ms_instance[v22];
  v24 = WEAPON_HAND_DEFAULT;
  if ( BG_PlayerLastWeaponHand(v23, &cgameGlob->predictedPlayerState) < WEAPON_HAND_DEFAULT )
  {
LABEL_23:
    dst.v[0] = 0.0;
    dst.v[1] = 0.0;
    dst.v[2] = 0.0;
    if ( enabled )
    {
      AnglesToQuat(&viewValues->weapMoveAnglesCategorized[1], &v70);
      QuatSlerp(&quat_identity, &v70, v13, &quat);
      QuatToAngles(&quat, &v78);
      AnglesToQuat(&viewValues->weapMoveAnglesCategorized[2], &quat);
      QuatSlerp(&quat_identity, &quat, v13, &v70);
      QuatToAngles(&v70, &v79);
      AnglesToQuat(&viewValues->weapMoveAnglesCategorized[9], &quat);
      QuatSlerp(&quat_identity, &quat, v13, &v70);
      QuatToAngles(&v70, &v80);
      AnglesToQuat(&viewValues->weapMoveAnglesCategorized[11], &quat);
      QuatSlerp(&quat_identity, &quat, v13, &v70);
      QuatToAngles(&v70, &v81);
      AnglesToQuat(&viewValues->weapMoveAnglesCategorized[16], &quat);
      QuatSlerp(&quat_identity, &quat, v13, &v70);
      QuatToAngles(&v70, (vec3_t *)&result);
      AnglesToQuat(*(const vec3_t **)pivotPoint.v, &quat);
      QuatSlerp(&quat_identity, &quat, v13, &v70);
      QuatToAngles(&v70, &v82);
    }
    else
    {
      v29 = viewValues->weapMoveAnglesCategorized[1].v[1];
      v78.v[0] = viewValues->weapMoveAnglesCategorized[1].v[0];
      v30 = viewValues->weapMoveAnglesCategorized[1].v[2];
      v78.v[1] = v29;
      v31 = viewValues->weapMoveAnglesCategorized[2].v[0];
      v78.v[2] = v30;
      v32 = viewValues->weapMoveAnglesCategorized[2].v[1];
      v79.v[0] = v31;
      v33 = viewValues->weapMoveAnglesCategorized[2].v[2];
      v79.v[1] = v32;
      v34 = viewValues->weapMoveAnglesCategorized[9].v[0];
      v79.v[2] = v33;
      v35 = viewValues->weapMoveAnglesCategorized[9].v[1];
      v80.v[0] = v34;
      v36 = viewValues->weapMoveAnglesCategorized[9].v[2];
      v80.v[1] = v35;
      v37 = viewValues->weapMoveAnglesCategorized[11].v[0];
      v80.v[2] = v36;
      v38 = viewValues->weapMoveAnglesCategorized[11].v[1];
      v81.v[0] = v37;
      v39 = viewValues->weapMoveAnglesCategorized[11].v[2];
      v81.v[1] = v38;
      v40 = viewValues->weapMoveAnglesCategorized[16].v[0];
      v81.v[2] = v39;
      v41 = viewValues->weapMoveAnglesCategorized[16].v[1];
      result.v[0] = v40;
      v42 = viewValues->weapMoveAnglesCategorized[16].v[2];
      result.v[1] = v41;
      v43 = **(float **)pivotPoint.v;
      result.v[2] = v42;
      v44 = *(float *)(*(_QWORD *)pivotPoint.v + 4i64);
      v82.v[0] = v43;
      v45 = *(float *)(*(_QWORD *)pivotPoint.v + 8i64);
      v82.v[1] = v44;
      v82.v[2] = v45;
    }
    pivotPoint.v[0] = 0.0;
    pivotPoint.v[1] = 0.0;
    pivotPoint.v[2] = 0.0;
    if ( !VecNCompareCustomEpsilon(v78.v, pivotPoint.v, 0.000001, 3) )
    {
      AnglesToAxis(&v78, &rotation);
      RotatePointAroundPoint(&dst, &dst, &viewValues->weapStandAnglesPivotOffset, &rotation);
    }
    pivotPoint.v[0] = 0.0;
    pivotPoint.v[1] = 0.0;
    pivotPoint.v[2] = 0.0;
    if ( !VecNCompareCustomEpsilon(v79.v, pivotPoint.v, 0.000001, 3) )
    {
      AnglesToAxis(&v79, &rotation);
      RotatePointAroundPoint(&dst, &dst, &viewValues->weapDuckedAnglesPivotOffset, &rotation);
    }
    v70.v[0] = viewValues->weapTiltOffset;
    v70.v[1] = 0.0;
    v70.v[2] = 0.0;
    pivotPoint.v[0] = 0.0;
    pivotPoint.v[1] = 0.0;
    pivotPoint.v[2] = 0.0;
    if ( !VecNCompareCustomEpsilon(v80.v, pivotPoint.v, 0.000001, 3) )
    {
      AnglesToAxis(&v80, &rotation);
      RotatePointAroundPoint(&dst, &dst, (const vec3_t *)&v70, &rotation);
    }
    pivotPoint.v[0] = viewValues->weapMoveTiltOffset;
    pivotPoint.v[1] = 0.0;
    pivotPoint.v[2] = 0.0;
    v70.v[0] = 0.0;
    v70.v[1] = 0.0;
    v70.v[2] = 0.0;
    if ( !VecNCompareCustomEpsilon(v81.v, v70.v, 0.000001, 3) )
    {
      AnglesToAxis(&v81, &rotation);
      RotatePointAroundPoint(&dst, &dst, &pivotPoint, &rotation);
    }
    pivotPoint.v[0] = springTiltOffset;
    pivotPoint.v[1] = 0.0;
    pivotPoint.v[2] = 0.0;
    v70.v[0] = 0.0;
    v70.v[1] = 0.0;
    v70.v[2] = 0.0;
    if ( !VecNCompareCustomEpsilon(v82.v, v70.v, 0.000001, 3) )
    {
      AnglesToAxis(&v82, &rotation);
      RotatePointAroundPoint(&dst, &dst, &pivotPoint, &rotation);
    }
    v70.v[0] = 0.0;
    v70.v[1] = 0.0;
    v70.v[2] = 0.0;
    if ( !VecNCompareCustomEpsilon(result.v, v70.v, 0.000001, 3) )
    {
      AnglesToAxis((const vec3_t *)&result, &rotation);
      RotatePointAroundPoint(&dst, &dst, &viewValues->weapVmMotionPivotOffset, &rotation);
    }
    v46 = dst.v[1];
    v47 = dst.v[0];
    v48 = dst.v[2];
    v49 = *(_QWORD *)center.v;
    v50 = dst.v[2] * axis.m[2].v[1];
    v51 = dst.v[0] * axis.m[0].v[1];
    **(float **)center.v = (float)((float)((float)(dst.v[1] * axis.m[1].v[0]) + (float)(dst.v[0] * axis.m[0].v[0])) + (float)(dst.v[2] * axis.m[2].v[0])) + weapOrigin->v[0];
    v52 = (float)((float)((float)(v46 * axis.m[1].v[1]) + v51) + v50) + weapOrigin->v[1];
    v53 = v47 * axis.m[0].v[2];
    v54 = v48 * axis.m[2].v[2];
    *(float *)(v49 + 4) = v52;
    *(float *)(v49 + 8) = (float)((float)((float)(v46 * axis.m[1].v[2]) + v53) + v54) + weapOrigin->v[2];
    v55 = DCONST_DVARBOOL_duckedRotationPivotDebug;
    if ( !DCONST_DVARBOOL_duckedRotationPivotDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "duckedRotationPivotDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v55);
    if ( v55->current.enabled )
    {
      p_weapDuckedAnglesPivotOffset = &viewValues->weapDuckedAnglesPivotOffset;
      if ( &viewValues->weapDuckedAnglesPivotOffset == &center && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
        __debugbreak();
      v57 = viewValues->weapDuckedAnglesPivotOffset.v[1];
      v58 = p_weapDuckedAnglesPivotOffset->v[0];
      v59 = viewValues->weapDuckedAnglesPivotOffset.v[2];
      center.v[0] = (float)((float)((float)(p_weapDuckedAnglesPivotOffset->v[0] * axis.m[0].v[0]) + (float)(v57 * axis.m[1].v[0])) + (float)(v59 * axis.m[2].v[0])) + weapOrigin->v[0];
      center.v[1] = (float)((float)((float)(v58 * axis.m[0].v[1]) + (float)(v57 * axis.m[1].v[1])) + (float)(v59 * axis.m[2].v[1])) + weapOrigin->v[1];
      center.v[2] = (float)((float)((float)(v58 * axis.m[0].v[2]) + (float)(v57 * axis.m[1].v[2])) + (float)(v59 * axis.m[2].v[2])) + weapOrigin->v[2];
      CG_DebugSphere(&center, *(float *)&dword_147FA82CC, &colorRed, 1, 0);
    }
    v60 = DCONST_DVARBOOL_advancedSwayDebug;
    if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v60);
    if ( v60->current.enabled )
    {
      v61 = DCONST_DVARBOOL_advancedSwayGunDirEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayGunDirEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v61);
      if ( v61->current.enabled )
      {
        p_weapVmMotionPivotOffset = &viewValues->weapVmMotionPivotOffset;
        if ( &viewValues->weapVmMotionPivotOffset == &center && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
          __debugbreak();
        v63 = viewValues->weapVmMotionPivotOffset.v[1];
        v64 = p_weapVmMotionPivotOffset->v[0];
        v65 = viewValues->weapVmMotionPivotOffset.v[2];
        center.v[0] = (float)((float)((float)(p_weapVmMotionPivotOffset->v[0] * axis.m[0].v[0]) + (float)(v63 * axis.m[1].v[0])) + (float)(v65 * axis.m[2].v[0])) + weapOrigin->v[0];
        center.v[1] = (float)((float)((float)(v64 * axis.m[0].v[1]) + (float)(v63 * axis.m[1].v[1])) + (float)(v65 * axis.m[2].v[1])) + weapOrigin->v[1];
        center.v[2] = (float)((float)((float)(v64 * axis.m[0].v[2]) + (float)(v63 * axis.m[1].v[2])) + (float)(v65 * axis.m[2].v[2])) + weapOrigin->v[2];
        CG_DebugSphere(&center, *(float *)&dword_147FA82CC, &colorBlue, 1, 0);
      }
    }
  }
  else
  {
    p_weaponState = &cgameGlob->predictedPlayerState.weapState[0].weaponState;
    v26 = 0x800000001020i64;
    while ( 1 )
    {
      v27 = *p_weaponState;
      if ( (unsigned int)v27 <= 0x2F )
      {
        if ( _bittest64(&v26, v27) )
          break;
      }
      ++v24;
      p_weaponState += 20;
      WeaponHand = BG_PlayerLastWeaponHand(v23, &cgameGlob->predictedPlayerState);
      v26 = 0x800000001020i64;
      if ( v24 > WeaponHand )
        goto LABEL_23;
    }
  }
  Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &cgameGlob->predictedPlayerState);
  v68 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
  BG_GetWeaponAnglesForShootingDirection(Instance, &cgameGlob->predictedPlayerState, CurrentWeaponForPlayer, v68, (const vec3_t (*)[30])viewValues->weapMoveAnglesCategorized, &localGunAngles);
  AnglesToAxis(&localGunAngles, &v87);
  MatrixMultiply(&v87, &axis, &v88);
  AxisToAngles(&v88, outGunAngles);
  CG_Weapons_PrintWeaponShootingAngles(cgameGlob, &cgameGlob->baseGunAngles, &localGunAngles, outGunAngles);
}

/*
==============
CG_CalculateWeaponMovement_FovCompensation
==============
*/
void CG_CalculateWeaponMovement_FovCompensation(const cg_t *cgameGlob, vec3_t *origin)
{
  const dvar_t *v4; 
  const CameraDef *Def; 
  double v6; 
  const dvar_t *v7; 
  float v8; 
  const dvar_t *v9; 
  float v10; 
  const dvar_t *v11; 
  float v12; 
  const tmat43_t<vec3_t> *ViewModelTransform; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13735, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v4 = DVARBOOL_cg_disable_fov_comp;
  if ( !DVARBOOL_cg_disable_fov_comp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_disable_fov_comp") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( !v4->current.enabled )
  {
    Def = CG_Camera_Active_TryGetDef(cgameGlob->localClientNum);
    if ( !Def || Def->profile || !Def->firstPerson.disableFOVWeaponOffset )
    {
      v6 = CG_View_CalcFovCompensation(cgameGlob);
      v7 = DCONST_DVARFLT_cg_gun_fovcomp_x;
      if ( !DCONST_DVARFLT_cg_gun_fovcomp_x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_fovcomp_x") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v7);
      v8 = *(float *)&v6 * v7->current.value;
      v9 = DCONST_DVARFLT_cg_gun_fovcomp_y;
      if ( !DCONST_DVARFLT_cg_gun_fovcomp_y && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_fovcomp_y") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v9);
      v10 = *(float *)&v6 * v9->current.value;
      v11 = DCONST_DVARFLT_cg_gun_fovcomp_z;
      if ( !DCONST_DVARFLT_cg_gun_fovcomp_z && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_fovcomp_z") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      v12 = *(float *)&v6 * v11->current.value;
      ViewModelTransform = cg_t::GetViewModelTransform((cg_t *)cgameGlob);
      v14 = (float)(v8 * ViewModelTransform->m[0].v[0]) + origin->v[0];
      origin->v[0] = v14;
      v15 = (float)(v8 * ViewModelTransform->m[0].v[1]) + origin->v[1];
      origin->v[1] = v15;
      v16 = (float)(v8 * ViewModelTransform->m[0].v[2]) + origin->v[2];
      origin->v[2] = v16;
      v17 = (float)(v10 * ViewModelTransform->m[1].v[0]) + v14;
      origin->v[0] = v17;
      v18 = (float)(v10 * ViewModelTransform->m[1].v[1]) + v15;
      origin->v[1] = v18;
      v19 = (float)(v10 * ViewModelTransform->m[1].v[2]) + v16;
      origin->v[2] = v19;
      origin->v[0] = (float)(v12 * ViewModelTransform->m[2].v[0]) + v17;
      origin->v[1] = (float)(v12 * ViewModelTransform->m[2].v[1]) + v18;
      origin->v[2] = (float)(v12 * ViewModelTransform->m[2].v[2]) + v19;
    }
  }
}

/*
==============
CG_CalculateWeaponMovement_GetAdsOffset
==============
*/
void CG_CalculateWeaponMovement_GetAdsOffset(const cg_t *cgameGlob, const vec4_t *orient, bool isAlternate, vec3_t *offset)
{
  __int128 v4; 
  __int64 localClientNum; 
  CgWeaponMap *v10; 
  float fWeaponPosFrac; 
  double OffhandAdsFrac; 
  bool AdsAlign; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  DObj *viewModelDObj; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float v34; 
  float v38; 
  float v39; 
  unsigned __int8 v40; 
  unsigned __int8 inOutIndex; 
  unsigned __int8 v42; 
  bool outDisableTagAlignX; 
  int modelIndex; 
  AdsOffsetInterpolationType lerpType; 
  AdsOffsetInterpolationType outAlignmentLerpType; 
  tmat33_t<vec3_t> axis; 
  vec3_t outAdsAlignOffset; 
  DObjAnimMat v49; 
  Weapon r_weapon; 
  DObjAnimMat v51; 
  DObjAnimMat outMat; 
  __int128 v53; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13765, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  *(_QWORD *)offset->v = 0i64;
  offset->v[2] = 0.0;
  localClientNum = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v10 = CgWeaponMap::ms_instance[localClientNum];
  fWeaponPosFrac = cgameGlob->predictedPlayerState.weapCommon.fWeaponPosFrac;
  if ( BG_IsUsingOffhandGestureWeaponADSSupport(v10, &cgameGlob->predictedPlayerState) )
  {
    OffhandAdsFrac = BG_GetOffhandAdsFrac(&cgameGlob->predictedPlayerState);
    _XMM9 = 0i64;
    fWeaponPosFrac = *(float *)&OffhandAdsFrac;
    if ( *(float *)&OffhandAdsFrac <= 0.0 )
      return;
    r_weapon = *BG_GetOffhandGestureWeapon(v10, &cgameGlob->predictedPlayerState);
  }
  else
  {
    _XMM9 = 0i64;
    if ( fWeaponPosFrac <= 0.0 )
      return;
    r_weapon = *BG_GetCurrentWeaponForPlayer(v10, &cgameGlob->predictedPlayerState);
    if ( !BG_IsAimDownSight(&r_weapon, isAlternate) )
      return;
  }
  v53 = v4;
  outDisableTagAlignX = 0;
  AdsAlign = BG_GetAdsAlign(v10, &cgameGlob->predictedPlayerState, &r_weapon, isAlternate, &cgameGlob->scopeToggleInfo.fractionInfo, &outAdsAlignOffset, &lerpType, &outAlignmentLerpType, &outDisableTagAlignX);
  BG_CalculateEaseMotionFactor(fWeaponPosFrac, lerpType);
  v15 = fWeaponPosFrac;
  BG_CalculateEaseMotionFactor(fWeaponPosFrac, outAlignmentLerpType);
  v16 = fWeaponPosFrac;
  QuatToAxis(orient, &axis);
  v17 = outAdsAlignOffset.v[1];
  v18 = outAdsAlignOffset.v[2];
  v19 = axis.m[0].v[1] * outAdsAlignOffset.v[0];
  v20 = axis.m[0].v[2];
  v21 = outAdsAlignOffset.v[1] * axis.m[1].v[1];
  v22 = outAdsAlignOffset.v[2] * axis.m[2].v[1];
  offset->v[0] = (float)((float)((float)(axis.m[0].v[0] * outAdsAlignOffset.v[0]) + (float)(outAdsAlignOffset.v[1] * axis.m[1].v[0])) + (float)(outAdsAlignOffset.v[2] * axis.m[2].v[0])) * v15;
  v23 = v19 + v21;
  v24 = v20 * outAdsAlignOffset.v[0];
  v25 = v23 + v22;
  v26 = v18 * axis.m[2].v[2];
  v27 = v25 * v15;
  v28 = v17 * axis.m[1].v[2];
  offset->v[1] = v27;
  offset->v[2] = (float)((float)(v24 + v28) + v26) * v15;
  if ( AdsAlign )
  {
    viewModelDObj = cgameGlob->m_weaponHand[0].viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13827, ASSERT_TYPE_ASSERT, "(viewModelDobj)", (const char *)&queryFormat, "viewModelDobj") )
      __debugbreak();
    inOutIndex = -2;
    DObjGetBoneIndexInternal_66(viewModelDObj, scr_const.tag_align_gun, &inOutIndex, &modelIndex);
    if ( inOutIndex <= 0xFDu )
    {
      v40 = -2;
      v42 = -2;
      DObjGetBoneIndexInternal_66(viewModelDObj, scr_const.tag_reticle_attach, &v40, &modelIndex);
      if ( BG_CanHybridToggle(&cgameGlob->predictedPlayerState, &r_weapon, isAlternate) )
        DObjGetBoneIndexInternal_66(viewModelDObj, scr_const.tag_reticle_attach2, &v42, &modelIndex);
      if ( v40 <= 0xFDu )
      {
        DObjGetBasePoseMatrix(viewModelDObj, inOutIndex, &outMat);
        if ( v42 > 0xFDu )
        {
          DObjGetBasePoseMatrix(viewModelDObj, v40, &v49);
          v31 = v49.trans.v[1];
          v32 = v49.trans.v[2];
        }
        else
        {
          v30 = (float)(sinf_0((float)(cgameGlob->scopeToggleInfo.fractionInfo.fraction - 0.5) * 3.1415927) + 1.0) * 0.5;
          DObjGetBasePoseMatrix(viewModelDObj, v40, &v51);
          DObjGetBasePoseMatrix(viewModelDObj, v42, &v49);
          v31 = (float)((float)(v49.trans.v[1] - v51.trans.v[1]) * v30) + v51.trans.v[1];
          v32 = (float)((float)(v49.trans.v[2] - v51.trans.v[2]) * v30) + v51.trans.v[2];
        }
        v33 = outMat.trans.v[2] - v32;
        v34 = outMat.trans.v[1] - v31;
        _XMM0 = outDisableTagAlignX;
        __asm { vpcmpeqd xmm2, xmm0, xmm1 }
        *(float *)&_XMM0 = (float)(outMat.trans.v[1] - v31) * axis.m[1].v[0];
        __asm { vblendvps xmm4, xmm9, xmm3, xmm2 }
        *(float *)&_XMM2 = (float)((float)(*(float *)&_XMM4 * axis.m[0].v[1]) + (float)(v34 * axis.m[1].v[1])) + (float)(v33 * axis.m[2].v[1]);
        v38 = *(float *)&_XMM4 * axis.m[0].v[2];
        offset->v[0] = (float)((float)((float)((float)(*(float *)&_XMM4 * axis.m[0].v[0]) + *(float *)&_XMM0) + (float)(v33 * axis.m[2].v[0])) * v16) + offset->v[0];
        v39 = (float)((float)(v38 + (float)(v34 * axis.m[1].v[2])) + (float)(v33 * axis.m[2].v[2])) * v16;
        offset->v[1] = (float)(*(float *)&_XMM2 * v16) + offset->v[1];
        offset->v[2] = v39 + offset->v[2];
      }
    }
  }
}

/*
==============
CG_CalculateWeaponMovement_GetFOVXOffset
==============
*/
float CG_CalculateWeaponMovement_GetFOVXOffset(const cg_t *cgameGlob)
{
  __int64 localClientNum; 
  CgWeaponMap *v3; 
  const Weapon *ViewmodelOrOffhandADSSupportWeapon; 
  float correctedWeaponPosFrac; 
  const Weapon *v6; 
  double OffhandAdsFrac; 
  float v8; 
  CgWeaponMap *Instance; 
  bool v10; 
  float v11; 
  double v12; 
  double v13; 
  float v14; 
  bool v15; 
  CgHandler *Handler; 
  double v17; 
  float v18; 
  double ADSNVGFOVXOffset; 
  float zoomFovXOffset; 
  double v21; 
  bool outIsAlternate; 
  float adsZoomInFrac; 
  float adsZoomOutFrac; 
  BgAdsZoomInfo outZoomInfo; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13927, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  localClientNum = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v3 = CgWeaponMap::ms_instance[localClientNum];
  ViewmodelOrOffhandADSSupportWeapon = BG_GetViewmodelOrOffhandADSSupportWeapon(v3, &cgameGlob->predictedPlayerState, &outIsAlternate);
  correctedWeaponPosFrac = cgameGlob->weaponPosFracAnimData.correctedWeaponPosFrac;
  v6 = ViewmodelOrOffhandADSSupportWeapon;
  if ( BG_IsUsingOffhandGestureWeaponADSSupport(v3, &cgameGlob->predictedPlayerState) )
  {
    OffhandAdsFrac = BG_GetOffhandAdsFrac(&cgameGlob->predictedPlayerState);
    correctedWeaponPosFrac = *(float *)&OffhandAdsFrac;
  }
  if ( correctedWeaponPosFrac <= 0.0 )
    return 0.0;
  if ( correctedWeaponPosFrac < 1.0 )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|WEAPON_FIRING) || !BG_IsThirdPersonMode(Instance, &cgameGlob->predictedPlayerState) || BG_UsingSniperScope(Instance, &cgameGlob->predictedPlayerState) )
    {
      v10 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
      BG_GetADSZoomInFracs(Instance, &cgameGlob->predictedPlayerState, v6, v10, 1, &adsZoomInFrac, &adsZoomOutFrac);
      if ( cgameGlob->playerEntity.bPositionToADS )
        v11 = adsZoomInFrac;
      else
        v11 = adsZoomOutFrac;
      if ( v11 <= 0.0 )
        return 0.0;
      correctedWeaponPosFrac = (float)(correctedWeaponPosFrac - (float)(1.0 - v11)) / v11;
    }
    v12 = I_fclamp(correctedWeaponPosFrac, 0.0, 1.0);
    v8 = correctedWeaponPosFrac;
    if ( *(float *)&v12 > 0.0 )
      goto LABEL_21;
    return 0.0;
  }
  v8 = FLOAT_1_0;
LABEL_21:
  if ( BG_ADSReloadEnabled(v3, &cgameGlob->predictedPlayerState, v6, outIsAlternate) )
  {
    v13 = BG_WeaponReloadingFraction(v3, &cgameGlob->predictedPlayerState);
    v14 = *(float *)&v13;
  }
  else
  {
    v14 = 0.0;
  }
  v15 = outIsAlternate;
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  v17 = BG_ADSReloadFovXOffset(Handler, &cgameGlob->predictedPlayerState, v6, v15);
  memset(&outZoomInfo, 0, sizeof(outZoomInfo));
  v18 = *(float *)&v17;
  BG_GetADSZoomInfo(v3, v6, outIsAlternate, &cgameGlob->scopeToggleInfo.fractionInfo, &outZoomInfo);
  if ( cgameGlob->fovCalcWeights.fovSpaces[0].weights[5] <= 0.0 )
  {
    zoomFovXOffset = outZoomInfo.zoomFovXOffset;
  }
  else
  {
    ADSNVGFOVXOffset = BG_GetADSNVGFOVXOffset(v6, outIsAlternate);
    zoomFovXOffset = *(float *)&ADSNVGFOVXOffset;
  }
  BG_CalculateEaseMotionFactor(v14, outZoomInfo.depthHackZoomLerpType);
  v21 = BG_CalculateEaseMotionFactor(v8, outZoomInfo.depthHackZoomLerpType);
  return *(float *)&v21 * (float)((float)((float)(1.0 - v14) * zoomFovXOffset) + (float)(v14 * v18));
}

/*
==============
CG_CalculateWeaponMovement_ProceduralAdsMovement
==============
*/
void CG_CalculateWeaponMovement_ProceduralAdsMovement(const cg_t *cgameGlob, const tmat43_t<vec3_t> *viewTransfrom, vec3_t *outOrigin, vec3_t *outAngles)
{
  vec3_t *v5; 
  const tmat43_t<vec3_t> *v6; 
  __int64 localClientNum; 
  CgWeaponMap *v8; 
  const Weapon *ViewmodelWeapon; 
  bool v10; 
  const WeaponDef *v11; 
  float adsForwardOffset; 
  float adsRoll; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  __int64 WeaponAttachments; 
  char v16; 
  __int128 v17; 
  __int128 v18; 
  WeaponAttachment **v19; 
  WeaponAttachment *v20; 
  AttAdsMovement *adsMovement; 
  AttAdsMovement *v22; 
  float fraction; 
  float v24; 
  float v25; 
  float v26; 
  AttAdsMovement *v27; 
  AttAdsMovement *v28; 
  AttAdsMovement *v29; 
  __int128 v30; 
  __int128 v31; 
  __int128 v32; 
  __int128 v33; 
  float v34; 
  __int64 v35; 
  float v36; 
  float v37; 
  WeaponAttachment *outDataAttachment; 
  vec3_t *v39; 
  const tmat43_t<vec3_t> *v40; 
  playerState_s *p_predictedPlayerState; 
  vec3_t *v42; 
  WeaponAttachment *attachments[30]; 

  v42 = outAngles;
  v39 = outOrigin;
  v5 = outOrigin;
  v40 = viewTransfrom;
  v6 = viewTransfrom;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14312, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  localClientNum = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[localClientNum];
  p_predictedPlayerState = &cgameGlob->predictedPlayerState;
  ViewmodelWeapon = BG_GetViewmodelWeapon(v8, &cgameGlob->predictedPlayerState);
  v10 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
  LOBYTE(v8) = BG_CanEquipWeapon(v8, &cgameGlob->predictedPlayerState, ViewmodelWeapon);
  v11 = BG_WeaponDef(ViewmodelWeapon, v10);
  adsForwardOffset = v11->adsForwardOffset;
  adsRoll = v11->adsRoll;
  HybridScopeEnablerAttachment = NULL;
  WeaponAttachments = BG_GetWeaponAttachments(ViewmodelWeapon, v10, (const WeaponAttachment **)attachments);
  outDataAttachment = NULL;
  if ( (_BYTE)v8 )
    HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(ViewmodelWeapon, v10, (const WeaponAttachment **)&outDataAttachment);
  v16 = 0;
  v17 = 0i64;
  v18 = 0i64;
  if ( (_DWORD)WeaponAttachments )
  {
    v19 = attachments;
    do
    {
      v20 = *v19;
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14342, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
        __debugbreak();
      adsMovement = v20->adsMovement;
      if ( adsMovement )
      {
        if ( v20 == HybridScopeEnablerAttachment && outDataAttachment && (v22 = outDataAttachment->adsMovement) != NULL && (fraction = cgameGlob->scopeToggleInfo.fractionInfo.fraction, fraction > 0.0) )
        {
          v24 = sinf_0((float)(fraction - 0.5) * 3.1415927) * 0.5;
          v26 = v24 + 0.5;
          v25 = v24 + 0.5;
          if ( v22->isOverride != HybridScopeEnablerAttachment->adsMovement->isOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14357, ASSERT_TYPE_ASSERT, "( hybridScopeReferenceAttachment->adsMovement->isOverride == hybridScopeEnablerAttachment->adsMovement->isOverride )", "ADS movement override/add flags must match between the hybrid enabling attachment and the referenced data attachment.") )
            __debugbreak();
          v27 = v20->adsMovement;
          if ( v27->isOverride )
          {
            if ( !v16 )
            {
              v16 = 1;
              v28 = outDataAttachment->adsMovement;
              adsForwardOffset = (float)((float)(0.5 - v24) * v27->forwardOffset) + (float)(v26 * v28->forwardOffset);
              adsRoll = (float)((float)(0.5 - v24) * v27->roll) + (float)(v26 * v28->roll);
            }
          }
          else
          {
            v29 = outDataAttachment->adsMovement;
            v30 = v17;
            *(float *)&v30 = *(float *)&v17 + (float)((float)((float)(0.5 - v24) * v27->forwardOffset) + (float)(v25 * v29->forwardOffset));
            v17 = v30;
            v31 = v18;
            *(float *)&v31 = *(float *)&v18 + (float)((float)((float)(0.5 - v24) * v27->roll) + (float)(v25 * v29->roll));
            v18 = v31;
          }
        }
        else if ( adsMovement->isOverride )
        {
          if ( !v16 )
          {
            adsForwardOffset = adsMovement->forwardOffset;
            adsRoll = adsMovement->roll;
            v16 = 1;
          }
        }
        else
        {
          v32 = v17;
          *(float *)&v32 = *(float *)&v17 + adsMovement->forwardOffset;
          v17 = v32;
          v33 = v18;
          *(float *)&v33 = *(float *)&v18 + adsMovement->roll;
          v18 = v33;
        }
      }
      ++v19;
      --WeaponAttachments;
    }
    while ( WeaponAttachments );
    v5 = v39;
    v6 = v40;
  }
  v34 = sinf_0((float)(p_predictedPlayerState->weapCommon.fWeaponPosFrac - 0.5) * 3.1415927);
  v35 = (__int64)v42;
  v36 = (float)(v34 + 1.0) * 0.5;
  v37 = (float)(*(float *)&v17 + adsForwardOffset) * v36;
  v5->v[0] = (float)(v37 * v6->m[0].v[0]) + v5->v[0];
  v5->v[1] = (float)(v37 * v6->m[0].v[1]) + v5->v[1];
  v5->v[2] = (float)(v37 * v6->m[0].v[2]) + v5->v[2];
  *(float *)(v35 + 8) = (float)((float)(*(float *)&v18 + adsRoll) * v36) + *(float *)(v35 + 8);
}

/*
==============
CG_CanChangeZoomLevel
==============
*/
bool CG_CanChangeZoomLevel(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  __int64 v3; 
  CgWeaponMap *v4; 
  const Weapon *ViewmodelOrOffhandADSWeapon; 
  int v7; 
  int v8; 
  bool outIsAlternate; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16367, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !BG_InADS(&LocalClientGlobals->predictedPlayerState) && !BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  v3 = LocalClientGlobals->localClientNum;
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v3];
  ViewmodelOrOffhandADSWeapon = BG_GetViewmodelOrOffhandADSWeapon(v4, p_predictedPlayerState, &outIsAlternate);
  if ( !BG_GetEquippedWeaponState(v4, p_predictedPlayerState, ViewmodelOrOffhandADSWeapon) )
    return 0;
  v7 = BG_ADSZoomCount(v4, p_predictedPlayerState, ViewmodelOrOffhandADSWeapon, outIsAlternate);
  v8 = v7;
  if ( v7 > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16389, ASSERT_TYPE_ASSERT, "( adsZoomCount ) <= ( 3 )", "%s <= %s\n\t%i, %i", "adsZoomCount", "WEAPON_VZSCOPE_MAXFOVS", v7, 3) )
    __debugbreak();
  return v8 > 1;
}

/*
==============
CG_CanCycleWeapon
==============
*/
bool CG_CanCycleWeapon(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v3; 
  const playerState_s *p_predictedPlayerState; 
  bool IsUsingOffhandGestureWeapon; 
  CgWeaponMap *Instance; 
  const Weapon *Weapon; 
  bool v8; 
  bool v9; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return 0;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  IsUsingOffhandGestureWeapon = BG_IsUsingOffhandGestureWeapon(&LocalClientGlobals->predictedPlayerState);
  if ( IsUsingOffhandGestureWeapon || (unsigned int)(p_predictedPlayerState->weapState[0].weaponState - 26) <= 3 )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v3->localClientNum);
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 916, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !p_predictedPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 917, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon(Instance, p_predictedPlayerState->weapCommon.offHandHandle);
    if ( BG_WeaponDef(Weapon, 0)->offhandHoldIsCancelable || (v8 = BG_PWF_UseAlternateAsOffhand(p_predictedPlayerState)) )
      v8 = 1;
    v9 = 0;
    if ( !p_predictedPlayerState->throwbackGrenadeTimeLeft )
      v9 = v8;
    if ( v9 && (!IsUsingOffhandGestureWeapon || BG_CanCancelOffhandGestureWeapon(p_predictedPlayerState)) )
    {
      v3->extraButtons |= 0x80000ui64;
      return 0;
    }
  }
  if ( v3->localClientNum != localClientNum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16342, ASSERT_TYPE_ASSERT, "( cgameGlob->localClientNum ) == ( localClientNum )", "%s == %s\n\t%i, %i", "cgameGlob->localClientNum", "localClientNum", v3->localClientNum, localClientNum) )
    __debugbreak();
  return WeaponCycleAllowed(v3);
}

/*
==============
CG_CanModifyAnimWeight
==============
*/
bool CG_CanModifyAnimWeight(const playerState_s *ps, weapAnimFiles_t anim)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2397, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return anim == WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH || anim <= WEAP_ANIM_GRENADE_PRIME_READY_TO_THROW || anim >= WEAP_ANIM_MELEE_FIRST;
}

/*
==============
CG_CreateWeaponViewModelAdditiveAnims
==============
*/
void CG_CreateWeaponViewModelAdditiveAnims(XAnimParts *const *animArray, WeaponXAnim *pAnims)
{
  weapAnimFiles_t *p_additiveChildStart; 
  signed int v5; 
  int i; 
  XAnimParts *WeaponAnim; 
  int v8; 
  __int64 flags; 
  __int64 syncGroup; 
  __int64 allowAllocs; 
  __int64 v12; 

  p_additiveChildStart = &s_additiveAnims[0].additiveChildStart;
  do
  {
    if ( (unsigned int)(*((_DWORD *)p_additiveChildStart - 1) - 28) > 0xCF )
    {
      LODWORD(allowAllocs) = 235;
      LODWORD(syncGroup) = 28;
      SLODWORD(flags) = *(p_additiveChildStart - 1);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9120, ASSERT_TYPE_ASSERT, "( WEAP_ANIM_ADDITIVE_START ) <= ( additiveInfo->additiveRoot ) && ( additiveInfo->additiveRoot ) <= ( WEAP_ANIM_ADDITIVE_END )", "additiveInfo->additiveRoot not in [WEAP_ANIM_ADDITIVE_START, WEAP_ANIM_ADDITIVE_END]\n\t%i not in [%i, %i]", flags, syncGroup, allowAllocs) )
        __debugbreak();
    }
    if ( (unsigned int)(*p_additiveChildStart - 28) > 0xCF )
    {
      LODWORD(allowAllocs) = 235;
      LODWORD(syncGroup) = 28;
      SLODWORD(flags) = *p_additiveChildStart;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9121, ASSERT_TYPE_ASSERT, "( WEAP_ANIM_ADDITIVE_START ) <= ( additiveInfo->additiveChildStart ) && ( additiveInfo->additiveChildStart ) <= ( WEAP_ANIM_ADDITIVE_END )", "additiveInfo->additiveChildStart not in [WEAP_ANIM_ADDITIVE_START, WEAP_ANIM_ADDITIVE_END]\n\t%i not in [%i, %i]", flags, syncGroup, allowAllocs) )
        __debugbreak();
    }
    if ( (unsigned int)(*((_DWORD *)p_additiveChildStart + 1) - 28) > 0xCF )
    {
      LODWORD(allowAllocs) = 235;
      LODWORD(syncGroup) = 28;
      SLODWORD(flags) = p_additiveChildStart[1];
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9122, ASSERT_TYPE_ASSERT, "( WEAP_ANIM_ADDITIVE_START ) <= ( additiveInfo->additiveChildEnd ) && ( additiveInfo->additiveChildEnd ) <= ( WEAP_ANIM_ADDITIVE_END )", "additiveInfo->additiveChildEnd not in [WEAP_ANIM_ADDITIVE_START, WEAP_ANIM_ADDITIVE_END]\n\t%i not in [%i, %i]", flags, syncGroup, allowAllocs) )
        __debugbreak();
    }
    if ( *p_additiveChildStart > *((_DWORD *)p_additiveChildStart + 1) )
    {
      SLODWORD(v12) = p_additiveChildStart[1];
      SLODWORD(allowAllocs) = *p_additiveChildStart;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9123, ASSERT_TYPE_ASSERT, "( additiveInfo->additiveChildStart ) <= ( additiveInfo->additiveChildEnd )", "%s <= %s\n\t%i, %i", "additiveInfo->additiveChildStart", "additiveInfo->additiveChildEnd", allowAllocs, v12) )
        __debugbreak();
    }
    v5 = *p_additiveChildStart;
    for ( i = 0; v5 <= *((_DWORD *)p_additiveChildStart + 1); ++v5 )
    {
      WeaponAnim = CG_GetWeaponAnim(animArray, v5);
      if ( !WeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9130, ASSERT_TYPE_ASSERT, "(additiveAnim)", (const char *)&queryFormat, "additiveAnim") )
        __debugbreak();
      if ( !i )
      {
        v8 = 16;
        if ( *((_BYTE *)p_additiveChildStart + 8) )
          v8 = 512;
        LOBYTE(syncGroup) = 4;
        XAnimBlend(&pAnims->xanim, *((_DWORD *)p_additiveChildStart - 1), *(const char **)(p_additiveChildStart - 3), *p_additiveChildStart, *((_DWORD *)p_additiveChildStart + 1) - *p_additiveChildStart + 1, *((_DWORD *)p_additiveChildStart + 3) | v8, (const XAnimSyncGroupID)syncGroup, 0);
        i = 1;
      }
      BG_CreateXAnimFromParts(&pAnims->xanim, v5, WeaponAnim, 0);
    }
    p_additiveChildStart += 8;
  }
  while ( (__int64)p_additiveChildStart < (__int64)&s_blendSpaceNodes[0].rootName + 4 );
}

/*
==============
CG_CreateWeaponViewModelBlendSpaceNodes
==============
*/
void CG_CreateWeaponViewModelBlendSpaceNodes(XAnimParts *const *animArray, const BlendSpace2DDef **blendSpaces, WeaponXAnim *pAnims)
{
  WeaponAnimParameter *p_yParam; 
  const BlendSpace2DDef **v6; 
  __int64 v7; 
  const BlendSpace2DDef *v8; 
  unsigned int numAnimEntries; 
  unsigned int v10; 
  unsigned int v11; 
  unsigned int v12; 
  int v13; 
  __int64 v14; 
  __int64 v15; 
  unsigned int v16; 
  scr_string_t StringOfSize; 
  unsigned int numTriangleCoords; 
  int v19; 
  __int64 v20; 
  unsigned int v21; 
  scr_string_t v22; 
  int v23; 
  scr_string_t xanimBlendSpace2DValueX; 
  int v25; 
  scr_string_t xanimBlendSpace2DValueY; 
  unsigned int v27; 
  XAnimParts *WeaponAnim; 
  XAnimFieldType fmt; 
  XAnimFieldType fmta; 
  __int64 num; 
  __int64 flags; 
  XAnimSyncGroupID syncGroup; 
  WeaponAnimParameter *v35; 
  char str[4]; 
  int v37[195]; 
  char v38[4]; 
  int v39[195]; 

  p_yParam = &s_blendSpaceNodes[0].yParam;
  v35 = &s_blendSpaceNodes[0].yParam;
  v6 = blendSpaces;
  do
  {
    if ( *((_DWORD *)p_yParam - 6) >= 8u )
    {
      LODWORD(flags) = 8;
      SLODWORD(num) = *(p_yParam - 6);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9168, ASSERT_TYPE_ASSERT, "(unsigned)( blendSpaceNodeInfo->blendSpaceType ) < (unsigned)( WEAPON_BLEND_SPACE_COUNT )", "blendSpaceNodeInfo->blendSpaceType doesn't index WEAPON_BLEND_SPACE_COUNT\n\t%i not in [0, %i)", num, flags) )
        __debugbreak();
    }
    v7 = *((int *)p_yParam - 6);
    v8 = v6[v7];
    if ( v8 )
    {
      numAnimEntries = v8->numAnimEntries;
      if ( numAnimEntries )
      {
        v10 = 20 * v7 + 448;
        v11 = v7 + 397;
        LOBYTE(syncGroup) = 4;
        XAnimCustomNode(scr_const.xanimBlendSpace2D, &pAnims->xanim, v7 + 397, *((const char **)p_yParam - 2), v10, numAnimEntries, *((_DWORD *)p_yParam - 2), syncGroup, 0);
        XAnimBindVec2ToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpace2DAxisXRange, &v8->rangeX);
        XAnimBindVec2ToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpace2DAxisYRange, &v8->rangeY);
        XAnimBindUInt32ToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpaceBlendTime, v8->blendTimeMs);
        XAnimBindBoolToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpaceAllAnimsNotify, v8->allAnimsNotify);
        v12 = 0;
        v13 = 2 * LOBYTE(v8->numAnimEntries);
        *(_DWORD *)str = v13;
        if ( v8->numAnimEntries )
        {
          do
          {
            v14 = 2 * v12;
            v15 = (__int64)&v8->animEntries[v12++];
            v37[v14] = *(_DWORD *)(v15 + 8);
            v37[(unsigned int)(v14 + 1)] = *(_DWORD *)(v15 + 12);
          }
          while ( v12 < v8->numAnimEntries );
          v13 = *(_DWORD *)str;
        }
        v16 = 4 * v13 + 4;
        if ( 4 * v13 == -4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_node_api.h", 297, ASSERT_TYPE_ASSERT, "(fieldSize > 0)", (const char *)&queryFormat, "fieldSize > 0") )
          __debugbreak();
        StringOfSize = j_SL_GetStringOfSize(str, 0, v16, 4);
        XAnimRegisterConstString(StringOfSize, v16);
        SL_RemoveRefToString(StringOfSize);
        LOWORD(fmt) = 18;
        XAnimBindArrayToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpaceCoords, StringOfSize, fmt);
        numTriangleCoords = v8->numTriangleCoords;
        if ( numTriangleCoords > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)numTriangleCoords, "unsigned", v8->numTriangleCoords) )
          __debugbreak();
        v19 = (unsigned __int8)numTriangleCoords;
        v20 = 0i64;
        *(_DWORD *)v38 = (unsigned __int8)numTriangleCoords;
        if ( v8->numTriangleCoords )
        {
          do
          {
            v39[v20] = v8->triangleCoords[v20];
            v20 = (unsigned int)(v20 + 1);
          }
          while ( (unsigned int)v20 < v8->numTriangleCoords );
          v19 = *(_DWORD *)v38;
        }
        v21 = 4 * v19 + 4;
        if ( 4 * v19 == -4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_node_api.h", 297, ASSERT_TYPE_ASSERT, "(fieldSize > 0)", (const char *)&queryFormat, "fieldSize > 0") )
          __debugbreak();
        v22 = j_SL_GetStringOfSize(v38, 0, v21, 4);
        XAnimRegisterConstString(v22, v21);
        SL_RemoveRefToString(v22);
        LOWORD(fmta) = 14;
        XAnimBindArrayToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpace2DEdges, v22, fmta);
        v23 = *((_DWORD *)p_yParam - 1);
        xanimBlendSpace2DValueX = scr_const.xanimBlendSpace2DValueX;
        if ( (v23 < 0 || (unsigned int)v23 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v23, "signed", v23) )
          __debugbreak();
        XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, v11, v23, xanimBlendSpace2DValueX);
        v25 = *p_yParam;
        xanimBlendSpace2DValueY = scr_const.xanimBlendSpace2DValueY;
        if ( (*(int *)p_yParam < 0 || (unsigned int)v25 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v25, "signed", v25) )
          __debugbreak();
        XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, v11, v25, xanimBlendSpace2DValueY);
        v27 = v10;
        if ( v10 < v10 + v8->numAnimEntries )
        {
          do
          {
            WeaponAnim = CG_GetWeaponAnim(animArray, v27);
            if ( !WeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9225, ASSERT_TYPE_ASSERT, "(blendSpaceAnim)", (const char *)&queryFormat, "blendSpaceAnim") )
              __debugbreak();
            BG_CreateXAnimFromParts(&pAnims->xanim, v27++, WeaponAnim, 0);
          }
          while ( v27 < v10 + v8->numAnimEntries );
          p_yParam = v35;
        }
        v6 = blendSpaces;
      }
    }
    p_yParam += 8;
    v35 = p_yParam;
  }
  while ( (__int64)p_yParam < (__int64)&s_skydiveParachuteAdditiveGroups[0].scrub1DTimeRange.y );
}

/*
==============
CG_CreateWeaponViewModelRelativeAnims
==============
*/
void CG_CreateWeaponViewModelRelativeAnims(XAnimParts *const *animArray, WeaponXAnim *pAnims, const int startIndex, const int numAnims)
{
  __int64 v4; 
  __int64 v6; 
  __int64 v8; 
  XAnimParts **v9; 
  XAnimParts *GameDefaultWeaponAnim; 
  __int64 v11; 
  __int64 v12; 

  v4 = numAnims;
  v6 = startIndex;
  if ( !animArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9235, ASSERT_TYPE_ASSERT, "(animArray)", (const char *)&queryFormat, "animArray") )
    __debugbreak();
  if ( !pAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9236, ASSERT_TYPE_ASSERT, "(pAnims)", (const char *)&queryFormat, "pAnims") )
    __debugbreak();
  v8 = v4;
  if ( (int)v4 > 0 )
  {
    v9 = (XAnimParts **)&animArray[v6];
    do
    {
      if ( (unsigned int)v6 >= 0x260 )
      {
        LODWORD(v12) = 608;
        LODWORD(v11) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9088, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v11, v12) )
          __debugbreak();
      }
      GameDefaultWeaponAnim = *v9;
      if ( !*v9 )
      {
        GameDefaultWeaponAnim = BG_GetGameDefaultWeaponAnim(v6);
        if ( !GameDefaultWeaponAnim )
        {
          if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
            __debugbreak();
          GameDefaultWeaponAnim = (XAnimParts *)*((_QWORD *)animArray + 236);
        }
        if ( !GameDefaultWeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9242, ASSERT_TYPE_ASSERT, "(xanim)", (const char *)&queryFormat, "xanim") )
          __debugbreak();
      }
      BG_CreateXAnimFromParts(&pAnims->xanim, v6, GameDefaultWeaponAnim, 0);
      LODWORD(v6) = v6 + 1;
      ++v9;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
CG_CreateWeaponViewModelSkydiveAdditiveAnims
==============
*/
void CG_CreateWeaponViewModelSkydiveAdditiveAnims(XAnimParts *const *animArray, WeaponXAnim *pAnims)
{
  const char **p_scrub1DRootName; 
  unsigned int v5; 
  int v6; 
  scr_string_t xanimScrubTimeValue; 
  int v8; 
  scr_string_t xanimBlendSpace1DValue; 
  double v10; 
  int v11; 
  scr_string_t StringOfSize; 
  unsigned int i; 
  XAnimParts *WeaponAnim; 
  const char **v15; 
  int v16; 
  scr_string_t v17; 
  unsigned int j; 
  XAnimParts *v19; 
  XAnimParts *GameDefaultWeaponAnim; 
  XAnimParts *v21; 
  signed int num; 
  XAnimSyncGroupID syncGroup; 
  XAnimSyncGroupID syncGroupa; 
  XAnimSyncGroupID syncGroupb; 
  XAnimSyncGroupID allowAllocs; 
  char str[4]; 
  double v28; 
  int v29; 

  LOBYTE(syncGroup) = 4;
  XAnimBlend(&pAnims->xanim, 0xC5u, "skydive_root", 0xC6u, 2u, 0x10u, syncGroup, 0);
  LOBYTE(syncGroupa) = 4;
  XAnimBlend(&pAnims->xanim, 0xC6u, "skydive_freefall_root", 0xC8u, 6u, 0x20u, syncGroupa, 0);
  LOBYTE(syncGroupb) = 4;
  XAnimBlend(&pAnims->xanim, 0xC7u, "skydive_parachute_root", 0xE1u, 6u, 0x20u, syncGroupb, 0);
  p_scrub1DRootName = &s_skydiveFreefallAdditiveGroups[0].scrub1DRootName;
  do
  {
    v5 = *((_DWORD *)p_scrub1DRootName - 2);
    if ( v5 )
    {
      LOBYTE(allowAllocs) = 4;
      XAnimCustomNode(scr_const.xanimScrub1D, &pAnims->xanim, v5, *p_scrub1DRootName, *((_DWORD *)p_scrub1DRootName + 6), 1u, *((_DWORD *)p_scrub1DRootName + 2), allowAllocs, 0);
      XAnimBindVec2ToNodeParameter(&pAnims->xanim, *((_DWORD *)p_scrub1DRootName - 2), scr_const.xanimScrubTimeRange, (const vec2_t *)((char *)p_scrub1DRootName + 12));
      v6 = *((_DWORD *)p_scrub1DRootName + 5);
      xanimScrubTimeValue = scr_const.xanimScrubTimeValue;
      if ( (v6 < 0 || (unsigned int)v6 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v6, "signed", v6) )
        __debugbreak();
      XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, *((_DWORD *)p_scrub1DRootName - 2), v6, xanimScrubTimeValue);
    }
    LOBYTE(allowAllocs) = 4;
    XAnimCustomNode(scr_const.xanimBlendSpace1D, &pAnims->xanim, *((_DWORD *)p_scrub1DRootName + 6), p_scrub1DRootName[4], *((_DWORD *)p_scrub1DRootName + 17), *((_DWORD *)p_scrub1DRootName + 18) - *((_DWORD *)p_scrub1DRootName + 17) + 1, *((_DWORD *)p_scrub1DRootName + 10), allowAllocs, 0);
    XAnimBindVec2ToNodeParameter(&pAnims->xanim, *((_DWORD *)p_scrub1DRootName + 6), scr_const.xanimBlendSpace1DRange, (const vec2_t *)((char *)p_scrub1DRootName + 44));
    v8 = *((_DWORD *)p_scrub1DRootName + 13);
    xanimBlendSpace1DValue = scr_const.xanimBlendSpace1DValue;
    if ( (v8 < 0 || (unsigned int)v8 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v8, "signed", v8) )
      __debugbreak();
    XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, *((_DWORD *)p_scrub1DRootName + 6), v8, xanimBlendSpace1DValue);
    v10 = *((double *)p_scrub1DRootName + 7);
    v11 = *((_DWORD *)p_scrub1DRootName + 16);
    *(_DWORD *)str = 3;
    v28 = v10;
    v29 = v11;
    StringOfSize = j_SL_GetStringOfSize(str, 0, 0x10ui64, 4);
    XAnimRegisterConstString(StringOfSize, 0x10u);
    SL_RemoveRefToString(StringOfSize);
    LOWORD(num) = 18;
    XAnimBindArrayToNodeParameter(&pAnims->xanim, *((_DWORD *)p_scrub1DRootName + 6), scr_const.xanimBlendSpaceCoords, StringOfSize, (const XAnimFieldType)num);
    for ( i = *((_DWORD *)p_scrub1DRootName + 17); i <= *((_DWORD *)p_scrub1DRootName + 18); ++i )
    {
      WeaponAnim = CG_GetWeaponAnim(animArray, i);
      if ( !WeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9327, ASSERT_TYPE_ASSERT, "(anim)", (const char *)&queryFormat, "anim") )
        __debugbreak();
      BG_CreateXAnimFromParts(&pAnims->xanim, i, WeaponAnim, 0);
    }
    p_scrub1DRootName += 11;
  }
  while ( (__int64)p_scrub1DRootName < (__int64)s_blendAnimStates );
  v15 = &s_skydiveParachuteAdditiveGroups[0].scrub1DRootName;
  do
  {
    LOBYTE(allowAllocs) = 4;
    XAnimCustomNode(scr_const.xanimScrub1D, &pAnims->xanim, *((_DWORD *)v15 - 2), *v15, *((_DWORD *)v15 + 6), *((_DWORD *)v15 + 7) - *((_DWORD *)v15 + 6) + 1, *((_DWORD *)v15 + 2), allowAllocs, 0);
    XAnimBindVec2ToNodeParameter(&pAnims->xanim, *((_DWORD *)v15 - 2), scr_const.xanimScrubTimeRange, (const vec2_t *)((char *)v15 + 12));
    v16 = *((_DWORD *)v15 + 5);
    v17 = scr_const.xanimScrubTimeValue;
    if ( (v16 < 0 || (unsigned int)v16 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v16, "signed", v16) )
      __debugbreak();
    XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, *((_DWORD *)v15 - 2), v16, v17);
    for ( j = *((_DWORD *)v15 + 6); j <= *((_DWORD *)v15 + 7); ++j )
    {
      v19 = CG_GetWeaponAnim(animArray, j);
      if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9349, ASSERT_TYPE_ASSERT, "(anim)", (const char *)&queryFormat, "anim") )
        __debugbreak();
      BG_CreateXAnimFromParts(&pAnims->xanim, j, v19, 0);
    }
    v15 += 5;
  }
  while ( (__int64)v15 < (__int64)s_skydiveFreefallAdditiveGroups );
  GameDefaultWeaponAnim = (XAnimParts *)*((_QWORD *)animArray + 230);
  if ( !GameDefaultWeaponAnim )
  {
    GameDefaultWeaponAnim = BG_GetGameDefaultWeaponAnim(230);
    if ( !GameDefaultWeaponAnim )
    {
      if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
        __debugbreak();
      GameDefaultWeaponAnim = (XAnimParts *)*((_QWORD *)animArray + 236);
    }
    if ( !GameDefaultWeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9356, ASSERT_TYPE_ASSERT, "(anim)", (const char *)&queryFormat, "anim") )
      __debugbreak();
  }
  BG_CreateXAnimFromParts(&pAnims->xanim, 0xE6u, GameDefaultWeaponAnim, 0);
  v21 = (XAnimParts *)*((_QWORD *)animArray + 205);
  if ( !v21 )
  {
    v21 = BG_GetGameDefaultWeaponAnim(205);
    if ( !v21 )
    {
      if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
        __debugbreak();
      v21 = (XAnimParts *)*((_QWORD *)animArray + 236);
    }
    if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9361, ASSERT_TYPE_ASSERT, "(axietyAnim)", (const char *)&queryFormat, "axietyAnim") )
      __debugbreak();
  }
  BG_CreateXAnimFromParts(&pAnims->xanim, 0xCDu, v21, 0);
}

/*
==============
CG_CreateWeaponViewModelXAnim
==============
*/
void CG_CreateWeaponViewModelXAnim(LocalClientNum_t localClientNum, const playerState_s *ps, XAnimParts *const *animArray, const BlendSpace2DDef **blendSpaces, WeaponXAnim *pAnims, const PlayerHandIndex hand, const bool isDualWield)
{
  WeaponXAnim *v7; 
  __int64 v12; 
  char **debugAnimNames; 
  char (*debugNames)[36]; 
  char *debugName; 
  bool v16; 
  unsigned int animIndex; 
  const char *v18; 
  XAnimSyncGroupID bindingArrayMemory; 
  XAnimSyncGroupID bindingArrayMemorya; 
  XAnimSyncGroupID bindingArrayMemoryb; 
  XAnimSyncGroupID bindingArrayMemoryc; 
  int maxPublicNodes; 
  int maxPublicNodesa; 
  int maxPublicNodesb; 
  int maxPublicNodesc; 

  v7 = pAnims;
  if ( !pAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9375, ASSERT_TYPE_ASSERT, "(pAnims)", (const char *)&queryFormat, "pAnims") )
    __debugbreak();
  XAnimCreateAnimsInPlaceWithParameters(XANIM_SUBTREE_DEFAULT, &v7->xanim, 609, 36, NULL, 160, v7->bindings, 1, weaponXanimPublicNodes);
  XAnimSetNumGameParameters(&v7->xanim, 0x24u);
  v12 = 608i64;
  v7->xanim.debugName = v7->debugName;
  debugAnimNames = v7->debugAnimNames;
  debugNames = v7->debugNames;
  do
  {
    *debugAnimNames++ = (char *)debugNames++;
    --v12;
  }
  while ( v12 );
  debugName = v7->xanim.debugName;
  v7->xanim.debugAnimNames = v7->debugAnimNames;
  *(double *)debugName = *(double *)"VIEWMODEL";
  strcpy(debugName + 8, "L");
  LOBYTE(bindingArrayMemory) = 4;
  XAnimBlend(&v7->xanim, 0, "root", 1u, 0xBu, 0, bindingArrayMemory, 0);
  LOBYTE(bindingArrayMemorya) = 4;
  XAnimBlend(&v7->xanim, 1u, "inner_root", 0xEu, 0xDEu, 0, bindingArrayMemorya, 0);
  LOBYTE(bindingArrayMemoryb) = 4;
  XAnimBlend(&v7->xanim, 0xEu, "relative_root", 0xECu, 0xD4u, 0, bindingArrayMemoryb, 0);
  if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9397, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
    __debugbreak();
  CG_CreateWeaponViewModelAdditiveAnims(animArray, v7);
  CG_CreateWeaponViewModelSkydiveAdditiveAnims(animArray, v7);
  v16 = isDualWield;
  CG_Gesture_CreateTree(localClientNum, ps, v7, hand, isDualWield, 1);
  CG_CreateWeaponViewModelRelativeAnims(animArray, v7, 15, 13);
  CG_CreateWeaponViewModelRelativeAnims(animArray, v7, 236, 212);
  LOBYTE(maxPublicNodes) = 4;
  XAnimCustomNode(scr_const.xanimScrub1D, &v7->xanim, 0xF6u, "skydive_freefall_idle_root", 0xF7u, 1u, 0, (const XAnimSyncGroupID)maxPublicNodes, 0);
  XAnimBindVec2ToNodeParameter(&v7->xanim, 0xF6u, scr_const.xanimScrubTimeRange, &stru_1442DD4F0);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 0xF6u, 0x22u, scr_const.xanimScrubTimeValue);
  LOBYTE(bindingArrayMemoryc) = 4;
  XAnimBlend(&v7->xanim, 0x103u, "toggle_scope", 0x104u, 2u, 0, bindingArrayMemoryc, 0);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9252, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  animIndex = ps->viewModelAnimScripted.animIndex;
  if ( animIndex )
  {
    NetConstStrings_GetNameFromIndexPlusOne(NETCONSTSTRINGTYPE_ANIM, animIndex, (const char **)&pAnims);
    if ( !pAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9259, ASSERT_TYPE_ASSERT, "(animName)", (const char *)&queryFormat, "animName") )
      __debugbreak();
    v18 = (const char *)pAnims;
  }
  else
  {
    v18 = "void";
  }
  BG_CreateXAnim(&v7->xanim, 0x17Cu, v18, 0);
  CG_Gesture_CreateTree(localClientNum, ps, v7, hand, v16, 0);
  CG_CreateWeaponViewModelBlendSpaceNodes(animArray, blendSpaces, v7);
  LOBYTE(maxPublicNodesa) = 4;
  XAnimCustomNode(scr_const.xanimAnalogClock, &v7->xanim, 8u, "analog_clock", 9u, 1u, 0x40u, (const XAnimSyncGroupID)maxPublicNodesa, 0);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x1Bu, scr_const.clockHourAngle);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x1Cu, scr_const.clockMinuteAngle);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x1Du, scr_const.clockSecondAngle);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x23u, scr_const.clockOscillationFraction);
  LOBYTE(maxPublicNodesb) = 4;
  XAnimCustomNode(scr_const.ik_node, &v7->xanim, 0xAu, "ik_node", 0xCu, 1u, 0, (const XAnimSyncGroupID)maxPublicNodesb, 0);
  LOBYTE(maxPublicNodesc) = 4;
  XAnimCustomNode(scr_const.proc_node, &v7->xanim, 0xBu, "proc_node", 0xDu, 1u, 0x2000u, (const XAnimSyncGroupID)maxPublicNodesc, 0);
  XAnimAddPublicNode(&v7->xanim, scr_const.proc_node, 0xBu);
  CG_Ladder_CreateAnims(v7);
  XAnimSetupBindingIndexes(&v7->xanim);
}

/*
==============
CG_CreateWeaponViewModelXAnimDefs
==============
*/
__int64 CG_CreateWeaponViewModelXAnimDefs(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, ClientPlayerWeaponInfo *weapInfo)
{
  unsigned __int8 v8; 
  int i; 
  WeaponXAnim *p_animsTwoHanded; 
  const WeaponDef *v11; 
  const WeaponDef *v12; 
  WeaponAnimPackage *szXAnims; 
  int *p_fontScaleTime; 
  bool v15; 
  bool v16; 
  const dvar_t *v17; 
  CgHandler *Handler; 
  char *WeaponName; 
  playerState_s *psa; 
  playerState_s *psb; 
  RawWeaponAnimArrays outAnimArrays; 
  char output[1024]; 

  RawWeaponAnimArrays::RawWeaponAnimArrays(&outAnimArrays);
  v8 = 0;
  if ( !weapInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9459, ASSERT_TYPE_ASSERT, "(weapInfo)", (const char *)&queryFormat, "weapInfo") )
    __debugbreak();
  psa = (playerState_s *)CG_GetLocalClientGlobals(localClientNum);
  if ( !psa && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9462, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !memcmp_0(&psa[4].hud.current[6].height, weapon, 0x3Cui64) )
  {
    p_animsTwoHanded = &weapInfo->animsTwoHanded;
  }
  else
  {
    for ( i = 0; i < 2; ++i )
      CG_Weapons_FreeAnimTreeHand(localClientNum, (const PlayerHandIndex)i);
    p_animsTwoHanded = &weapInfo->animsTwoHanded;
    memset_0(&weapInfo->animsTwoHanded, 0, sizeof(weapInfo->animsTwoHanded));
    memset_0(&weapInfo->animsTwoHandedAltMode, 0, sizeof(weapInfo->animsTwoHandedAltMode));
    memset_0(&weapInfo->animsRightHanded, 0, sizeof(weapInfo->animsRightHanded));
    memset_0(&weapInfo->animsLeftHanded, 0, sizeof(weapInfo->animsLeftHanded));
    v8 = 1;
  }
  v11 = BG_WeaponDef(weapon, 0);
  v12 = v11;
  szXAnims = v11->szXAnims;
  if ( szXAnims && *((_QWORD *)szXAnims->anims + 236) )
  {
    BG_Suit_GetOverriddenAnims(ps, weapon, &outAnimArrays);
    CG_CreateWeaponViewModelXAnim(localClientNum, ps, outAnimArrays.xAnims, outAnimArrays.blendSpaces, p_animsTwoHanded, WEAPON_HAND_DEFAULT, 0);
    if ( BG_OneHandedViewModelAnimsValid(v12) )
    {
      CG_CreateWeaponViewModelXAnim(localClientNum, ps, outAnimArrays.xAnimsRightHanded, outAnimArrays.blendSpacesRightHanded, &weapInfo->animsRightHanded, WEAPON_HAND_DEFAULT, 1);
      CG_CreateWeaponViewModelXAnim(localClientNum, ps, outAnimArrays.xAnimsLeftHanded, outAnimArrays.blendSpacesLeftHanded, &weapInfo->animsLeftHanded, WEAPON_HAND_LEFT, 1);
    }
    p_fontScaleTime = &psa[36].hud.archival[12].fontScaleTime;
    if ( psa == (playerState_s *)-790760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9514, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
      __debugbreak();
    memset_0(p_fontScaleTime, 0, 0x1330ui64);
    memset_0(&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.attachmentVariationIndices[5], 0, 0x1330ui64);
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[5].clipIndex.weapon.weaponCamo = 0i64;
    *(_QWORD *)psa[37].weapCommon.ammoInClip[5].chamberedCount = 0i64;
    *(_QWORD *)psa[37].weapCommon.ammoInClip[5].shotsSinceRechamber = 0i64;
    *(_QWORD *)psa[37].weapCommon.ammoInClip[5].ammoCount = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.weaponIdx = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.stickerIndices[3] = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.weaponAttachments[2] = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.weaponAttachments[10] = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[3].y = 0i64;
    *(_QWORD *)psa[37].objectives[21].origin[4].v = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[4].z = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[5].y = 0i64;
    *(_QWORD *)psa[37].objectives[21].origin[6].v = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[6].z = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[7].y = 0i64;
    *(_QWORD *)&psa[37].objectives[21].validLocations = 0i64;
    psb = (playerState_s *)&psa->inputTime;
    v15 = BG_PlayerDualWielding(psb) != 0;
    v16 = BG_UsingAlternate(ps);
    if ( !BG_BuildWeaponAnimArrays(psb, weapon, v15, v16, &outAnimArrays, (XAnimParts **)p_fontScaleTime, (const BlendSpace2DDef **)p_fontScaleTime + 614, (XAnimParts **)p_fontScaleTime + 622, (const BlendSpace2DDef **)p_fontScaleTime + 1236, (FootstepAnim *)(p_fontScaleTime + 2488), WEAP_ANIM_ROOT, 608) || (CG_CreateWeaponViewModelXAnim(localClientNum, ps, (XAnimParts *const *)p_fontScaleTime, (const BlendSpace2DDef **)p_fontScaleTime + 614, &weapInfo->animsTwoHanded, WEAPON_HAND_DEFAULT, 0), BG_HasUnderbarrelAmmo(weapon)) )
      CG_CreateWeaponViewModelXAnim(localClientNum, ps, (XAnimParts *const *)p_fontScaleTime + 622, (const BlendSpace2DDef **)p_fontScaleTime + 1236, &weapInfo->animsTwoHandedAltMode, WEAPON_HAND_DEFAULT, 0);
    v17 = DCONST_DVARBOOL_cg_viewmodelAnimatedJumps;
    if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedJumps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedJumps") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v17);
    if ( v17->current.enabled )
    {
      Handler = CgHandler::getHandler(localClientNum);
      if ( !BG_ViewModelAnimExists(psb, WEAP_ANIM_ADDITIVE_JUMP_LAND, WEAPON_HAND_DEFAULT, Handler) )
        Com_PrintWarning(19, "cg_viewmodelAnimatedJumps enabled, but jump land anim is not set\n");
    }
  }
  else if ( v11->gunXModel && v11->handXModel )
  {
    WeaponName = BG_GetWeaponName(weapon, output, 0x400u);
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DD5F0, 604i64, WeaponName);
  }
  return v8;
}

/*
==============
CG_CycleNeedsToWaitForHoldTime
==============
*/
bool CG_CycleNeedsToWaitForHoldTime(LocalClientNum_t localClientNum)
{
  CG_GetLocalClientGlobals(localClientNum);
  return CG_GetCurrentWeaponSlot(localClientNum) == WEAPON_SLOT_PRIMARY;
}

/*
==============
CG_CycleWeapon
==============
*/
void CG_CycleWeapon(LocalClientNum_t localClientNum, int cycleSlot, int cycleForward)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  LocalClientGlobals->weaponSelectTime = LocalClientGlobals->time;
  CycleWeapPrimary(localClientNum, cycleSlot, cycleForward, 0, 0, 0);
}

/*
==============
CG_DebugBulletFireLog_AddClientEntry
==============
*/
void CG_DebugBulletFireLog_AddClientEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  cg_t *LocalClientGlobals; 
  DebugBulletFireInfoEntry *v8; 
  DebugBulletFireInfoLog *v9; 
  bool v10; 
  double v11; 

  if ( CG_DebugBulletFireLog_ShouldLog(entNum) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    v8 = NULL;
    if ( s_debugBulletFireInfoLog.entryCount == 50 )
    {
      v8 = &s_debugBulletFireInfoLog.entries[49];
    }
    else
    {
      v9 = &s_debugBulletFireInfoLog;
      while ( v9->entries[0].isUsed )
      {
        v9 = (DebugBulletFireInfoLog *)((char *)v9 + 160);
        if ( (__int64)v9 >= (__int64)&s_debugBulletFireInfoLog.entryCount )
          goto LABEL_9;
      }
      v8 = (DebugBulletFireInfoEntry *)v9;
      ++s_debugBulletFireInfoLog.entryCount;
    }
LABEL_9:
    v10 = CgWeaponMap::ms_instance[0] == NULL;
    v8->isUsed = 1;
    v8->serverTime = serverTime;
    v8->clientGunPitch = LocalClientGlobals->gunAngles.v[0];
    v8->clientGunYaw = LocalClientGlobals->gunAngles.v[1];
    v8->clientViewAngles.v[0] = LocalClientGlobals->predictedPlayerState.viewangles.v[0];
    v8->clientViewAngles.v[1] = LocalClientGlobals->predictedPlayerState.viewangles.v[1];
    v8->clientViewAngles.v[2] = LocalClientGlobals->predictedPlayerState.viewangles.v[2];
    v8->clientDeltaAngles.v[0] = LocalClientGlobals->predictedPlayerState.delta_angles.v[0];
    v8->clientDeltaAngles.v[1] = LocalClientGlobals->predictedPlayerState.delta_angles.v[1];
    v8->clientDeltaAngles.v[2] = LocalClientGlobals->predictedPlayerState.delta_angles.v[2];
    v8->clientAdsStartTime = LocalClientGlobals->predictedPlayerState.weapCommon.adsStartTime;
    v8->clientAdsFraction = LocalClientGlobals->predictedPlayerState.weapCommon.fWeaponPosFrac;
    if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    v11 = BG_WeaponADSFractionAffectedByReload(CgWeaponMap::ms_instance[0], &LocalClientGlobals->predictedPlayerState);
    v8->clientAdsFractionNotReloading = *(float *)&v11;
    v8->clientIdleTimer1 = LocalClientGlobals->predictedPlayerState.weapCommon.weaponIdleTime;
    v8->clientIdleTimer2 = LocalClientGlobals->predictedPlayerState.weapCommon.weaponIdleTime2;
    v8->clientBulletOrigin.v[0] = bulletOrigin->v[0];
    v8->clientBulletOrigin.v[1] = bulletOrigin->v[1];
    v8->clientBulletOrigin.v[2] = bulletOrigin->v[2];
    v8->clientBulletDir.v[0] = bulletDir->v[0];
    v8->clientBulletDir.v[1] = bulletDir->v[1];
    v8->clientBulletDir.v[2] = bulletDir->v[2];
    v8->serverBulletEntryAdded = 0;
    *(_QWORD *)v8->serverBulletOrigin.v = 0i64;
    *(_QWORD *)&v8->serverBulletOrigin.z = 0i64;
    *(_QWORD *)&v8->serverBulletDir.y = 0i64;
    std::_Sort_unchecked<DebugBulletFireInfoEntry *,bool (*)(DebugBulletFireInfoEntry &,DebugBulletFireInfoEntry &)>(s_debugBulletFireInfoLog.entries, (DebugBulletFireInfoEntry *)&s_debugBulletFireInfoLog.entryCount, 50i64, CG_DebugBulletFireLog_Sorter);
    Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
  }
}

/*
==============
CG_DebugBulletFireLog_AddServerEntry
==============
*/
void CG_DebugBulletFireLog_AddServerEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  __int64 v4; 
  DebugBulletFireInfoLog *v8; 
  gentity_s *v9; 
  bool v10; 
  gclient_s *client; 
  double v12; 
  bool v13; 
  bool v14; 

  v4 = entNum;
  if ( CG_DebugBulletFireLog_ShouldLog(entNum) )
  {
    Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    v8 = &s_debugBulletFireInfoLog;
    while ( !v8->entries[0].isUsed || v8->entries[0].serverTime != serverTime )
    {
      v8 = (DebugBulletFireInfoLog *)((char *)v8 + 160);
      if ( (__int64)v8 >= (__int64)&s_debugBulletFireInfoLog.entryCount )
        goto LABEL_14;
    }
    v9 = &g_entities[v4];
    v10 = CgWeaponMap::ms_instance[0] == NULL;
    client = v9->client;
    v8->entries[0].serverBulletEntryAdded = 1;
    v8->entries[0].serverBulletOrigin.v[0] = bulletOrigin->v[0];
    v8->entries[0].serverBulletOrigin.v[1] = bulletOrigin->v[1];
    v8->entries[0].serverBulletOrigin.v[2] = bulletOrigin->v[2];
    v8->entries[0].serverBulletDir.v[0] = bulletDir->v[0];
    v8->entries[0].serverBulletDir.v[1] = bulletDir->v[1];
    v8->entries[0].serverBulletDir.v[2] = bulletDir->v[2];
    v8->entries[0].serverGunPitch = v9->client->fGunPitch;
    v8->entries[0].serverGunYaw = v9->client->fGunYaw;
    v8->entries[0].serverViewAngles.v[0] = client->ps.viewangles.v[0];
    v8->entries[0].serverViewAngles.v[1] = client->ps.viewangles.v[1];
    v8->entries[0].serverViewAngles.v[2] = client->ps.viewangles.v[2];
    v8->entries[0].serverDeltaAngles.v[0] = client->ps.delta_angles.v[0];
    v8->entries[0].serverDeltaAngles.v[1] = client->ps.delta_angles.v[1];
    v8->entries[0].serverDeltaAngles.v[2] = client->ps.delta_angles.v[2];
    v8->entries[0].serverAdsStartTime = client->ps.weapCommon.adsStartTime;
    v8->entries[0].serverAdsFraction = client->ps.weapCommon.fWeaponPosFrac;
    if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    v12 = BG_WeaponADSFractionAffectedByReload(CgWeaponMap::ms_instance[0], &client->ps);
    v8->entries[0].serverAdsFractionNotReloading = *(float *)&v12;
    v8->entries[0].serverIdleTimer1 = client->ps.weapCommon.weaponIdleTime;
    v8->entries[0].serverIdleTimer2 = client->ps.weapCommon.weaponIdleTime2;
    v13 = VecNCompareCustomEpsilon(v8->entries[0].clientBulletOrigin.v, v8->entries[0].serverBulletOrigin.v, 0.001, 3);
    v14 = VecNCompareCustomEpsilon(v8->entries[0].clientBulletDir.v, v8->entries[0].serverBulletDir.v, 0.001, 3);
    if ( v13 && v14 )
      Com_Printf(17, "Bullet fire matched. Time: %d CL Origin[%.4f, %.4f, %.4f] SV Origin[%.4f, %.4f, %.4f] CL Dir[%.4f, %.4f, %.4f] SV Dir[%.4f, %.4f, %.4f]\n", (unsigned int)serverTime, v8->entries[0].clientBulletOrigin.v[0], v8->entries[0].clientBulletOrigin.v[1], v8->entries[0].clientBulletOrigin.v[2], v8->entries[0].serverBulletOrigin.v[0], v8->entries[0].serverBulletOrigin.v[1], v8->entries[0].serverBulletOrigin.v[2], v8->entries[0].clientBulletDir.v[0], v8->entries[0].clientBulletDir.v[1], v8->entries[0].clientBulletDir.v[2], v8->entries[0].serverBulletDir.v[0], v8->entries[0].serverBulletDir.v[1], v8->entries[0].serverBulletDir.v[2]);
    else
      Com_PrintWarning(17, "Bullet fire mismatch. Time: %d CL Origin[%.4f, %.4f, %.4f] SV Origin[%.4f, %.4f, %.4f] CL Dir[%.4f, %.4f, %.4f] SV Dir[%.4f, %.4f, %.4f]\n", (unsigned int)serverTime, v8->entries[0].clientBulletOrigin.v[0], v8->entries[0].clientBulletOrigin.v[1], v8->entries[0].clientBulletOrigin.v[2], v8->entries[0].serverBulletOrigin.v[0], v8->entries[0].serverBulletOrigin.v[1], v8->entries[0].serverBulletOrigin.v[2], v8->entries[0].clientBulletDir.v[0], v8->entries[0].clientBulletDir.v[1], v8->entries[0].clientBulletDir.v[2], v8->entries[0].serverBulletDir.v[0], v8->entries[0].serverBulletDir.v[1], v8->entries[0].serverBulletDir.v[2]);
LABEL_14:
    Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
  }
}

/*
==============
CG_DebugBulletFireLog_Compact
==============
*/
void CG_DebugBulletFireLog_Compact(const int serverTime)
{
  char v2; 
  bool *p_isUsed; 
  int v4; 
  int v5; 
  int v6; 
  int v7; 
  int v8; 
  int v9; 
  int v10; 
  int v11; 
  int v12; 
  int v13; 

  Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
  v2 = 0;
  p_isUsed = &s_debugBulletFireInfoLog.entries[2].isUsed;
  do
  {
    if ( *(p_isUsed - 320) )
    {
      v4 = *((_DWORD *)p_isUsed - 119);
      if ( v4 > serverTime || serverTime - v4 > 120000 )
      {
        memset_0(p_isUsed - 476, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( *(p_isUsed - 160) )
    {
      v5 = *((_DWORD *)p_isUsed - 79);
      if ( v5 > serverTime || serverTime - v5 > 120000 )
      {
        memset_0(p_isUsed - 316, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( *p_isUsed )
    {
      v6 = *((_DWORD *)p_isUsed - 39);
      if ( v6 > serverTime || serverTime - v6 > 120000 )
      {
        memset_0(p_isUsed - 156, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[160] )
    {
      v7 = *((_DWORD *)p_isUsed + 1);
      if ( v7 > serverTime || serverTime - v7 > 120000 )
      {
        memset_0(p_isUsed + 4, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[320] )
    {
      v8 = *((_DWORD *)p_isUsed + 41);
      if ( v8 > serverTime || serverTime - v8 > 120000 )
      {
        memset_0(p_isUsed + 164, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[480] )
    {
      v9 = *((_DWORD *)p_isUsed + 81);
      if ( v9 > serverTime || serverTime - v9 > 120000 )
      {
        memset_0(p_isUsed + 324, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[640] )
    {
      v10 = *((_DWORD *)p_isUsed + 121);
      if ( v10 > serverTime || serverTime - v10 > 120000 )
      {
        memset_0(p_isUsed + 484, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[800] )
    {
      v11 = *((_DWORD *)p_isUsed + 161);
      if ( v11 > serverTime || serverTime - v11 > 120000 )
      {
        memset_0(p_isUsed + 644, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[960] )
    {
      v12 = *((_DWORD *)p_isUsed + 201);
      if ( v12 > serverTime || serverTime - v12 > 120000 )
      {
        memset_0(p_isUsed + 804, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[1120] )
    {
      v13 = *((_DWORD *)p_isUsed + 241);
      if ( v13 > serverTime || serverTime - v13 > 120000 )
      {
        memset_0(p_isUsed + 964, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    p_isUsed += 1600;
  }
  while ( (__int64)p_isUsed < (__int64)&unk_1512FCD8C );
  if ( v2 )
    std::_Sort_unchecked<DebugBulletFireInfoEntry *,bool (*)(DebugBulletFireInfoEntry &,DebugBulletFireInfoEntry &)>(s_debugBulletFireInfoLog.entries, (DebugBulletFireInfoEntry *)&s_debugBulletFireInfoLog.entryCount, 50i64, CG_DebugBulletFireLog_Sorter);
  Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
}

/*
==============
CG_DebugBulletFireLog_GetEntry
==============
*/
const DebugBulletFireInfoEntry *CG_DebugBulletFireLog_GetEntry(int entryIndex)
{
  __int64 v1; 
  int entryCount; 

  v1 = entryIndex;
  if ( (unsigned int)entryIndex >= s_debugBulletFireInfoLog.entryCount )
  {
    entryCount = s_debugBulletFireInfoLog.entryCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1317, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( s_debugBulletFireInfoLog.entryCount )", "entryIndex doesn't index s_debugBulletFireInfoLog.entryCount\n\t%i not in [0, %i)", entryIndex, entryCount) )
      __debugbreak();
  }
  return (const DebugBulletFireInfoEntry *)((char *)&s_debugBulletFireInfoLog + 160 * v1);
}

/*
==============
CG_DebugBulletFireLog_GetNumEntries
==============
*/
__int64 CG_DebugBulletFireLog_GetNumEntries()
{
  return (unsigned int)s_debugBulletFireInfoLog.entryCount;
}

/*
==============
CG_DebugBulletFireLog_ShouldLog
==============
*/
bool CG_DebugBulletFireLog_ShouldLog(const int entNum)
{
  const dvar_t *v1; 
  cg_t *LocalClientGlobals; 
  bool result; 

  v1 = DVARINT_debugOverlay;
  if ( !DVARINT_debugOverlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "debugOverlay") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  result = 0;
  if ( v1->current.integer == 10 )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    if ( LocalClientGlobals->predictedPlayerState.clientNum == entNum && !LocalClientGlobals->inKillCam && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) )
      return 1;
  }
  return result;
}

/*
==============
CG_DebugBulletFireLog_Sorter
==============
*/
bool CG_DebugBulletFireLog_Sorter(DebugBulletFireInfoEntry *sortItem1, DebugBulletFireInfoEntry *sortItem2)
{
  return sortItem1->isUsed && !sortItem2->isUsed || sortItem1->serverTime > sortItem2->serverTime;
}

/*
==============
CG_DisplayViewmodelAnim
==============
*/
void CG_DisplayViewmodelAnim(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  DObjDisplayAnim(LocalClientGlobals->m_weaponHand[0].viewModelDObj, (const char *)&queryFormat.fmt + 3);
}

/*
==============
CG_EjectWeaponBrass
==============
*/
void CG_EjectWeaponBrass(LocalClientNum_t localClientNum, const entityState_t *ent, int event, bool isAlternate)
{
  const dvar_t *v8; 
  CgWeaponMap *Instance; 
  const Weapon *WeaponForEntity; 
  cg_t *LocalClientGlobals; 
  int number; 
  playerState_s *p_predictedPlayerState; 
  bool v14; 
  bool v15; 
  FxCombinedDef v16; 
  const ParticleSystemDef *particleSystemDef; 
  FxCombinedDef v18; 
  PlayerHandIndex HandFromWeaponEvent; 
  int v20; 
  FXRegisteredDef fxDef; 
  __int64 v22; 

  v22 = -2i64;
  v8 = DVARBOOL_cg_brass;
  if ( !DVARBOOL_cg_brass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_brass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled && ent->eType < ET_EVENTS )
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    WeaponForEntity = BG_GetWeaponForEntity(Instance, ent);
    if ( WeaponForEntity->weaponIdx )
    {
      if ( WeaponForEntity->weaponIdx < BG_GetNumWeapons() )
      {
        Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CG_EjectWeaponBrass");
        LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
        number = ent->number;
        p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
        if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 120, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        v14 = number == p_predictedPlayerState->clientNum || p_predictedPlayerState->viewlocked && p_predictedPlayerState->viewlocked_entNum == number;
        v15 = (BG_IsPlayer(p_predictedPlayerState) || BG_IsAgent(p_predictedPlayerState) || BG_IsSpectating(p_predictedPlayerState)) && v14;
        BG_WeaponDef(WeaponForEntity, isAlternate);
        if ( v15 )
          v16.particleSystemDef = BG_ViewShellEjectEffect(WeaponForEntity, isAlternate).particleSystemDef;
        else
          v16.particleSystemDef = BG_WorldShellEjectEffect(WeaponForEntity, isAlternate).particleSystemDef;
        particleSystemDef = v16.particleSystemDef;
        if ( BG_IsLastShotWeaponEvent(event) )
        {
          v18.particleSystemDef = v15 ? BG_ViewLastShotEjectEffect(WeaponForEntity, isAlternate).particleSystemDef : BG_WorldLastShotEjectEffect(WeaponForEntity, isAlternate).particleSystemDef;
          if ( v18.particleSystemDef )
            particleSystemDef = v18.particleSystemDef;
        }
        if ( particleSystemDef )
        {
          fxDef.m_particleSystemDef = particleSystemDef;
          HandFromWeaponEvent = BG_GetHandFromWeaponEvent(event);
          if ( CG_IsPlayerEntityNumber(p_predictedPlayerState, ent->number) )
            v20 = HandFromWeaponEvent + 2048;
          else
            v20 = ent->number;
          CG_PlayBoltedEffect(localClientNum, &fxDef, v20, scr_const.tag_brass);
          CG_PlayBoltedEffect(localClientNum, &fxDef, v20, scr_const.tag_brass_2);
        }
        Sys_ProfEndNamedEvent();
      }
      else
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DFC60, 616i64);
      }
    }
  }
}

/*
==============
CG_Entity_HasWeapon
==============
*/
bool CG_Entity_HasWeapon(LocalClientNum_t localClientNum, centity_t *cent)
{
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 

  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19041, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
    __debugbreak();
  if ( cent->nextState.number >= (int)ComCharacterLimits::ms_gameData.m_characterCount )
    return cent->nextState.weaponHandle.m_mapEntryId != 0;
  LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
  if ( !LocalClientStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19045, ASSERT_TYPE_ASSERT, "( ( cgameStatic != nullptr ) )", "( cgameStatic ) = %p", NULL) )
    __debugbreak();
  if ( !LocalClientStatics->HasCharacterInfo(LocalClientStatics, cent->nextState.number) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19047, ASSERT_TYPE_ASSERT, "(cgameStatic->HasCharacterInfo( cent->nextState.number ))", (const char *)&queryFormat, "cgameStatic->HasCharacterInfo( cent->nextState.number )") )
    __debugbreak();
  CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, cent->nextState.number);
  if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19050, ASSERT_TYPE_ASSERT, "( ( ci != nullptr ) )", "( ci ) = %p", NULL) )
    __debugbreak();
  return CharacterInfo->dobjHeldWeapon.weaponIdx || CharacterInfo->dobjStowedWeapon.weaponIdx || CharacterInfo->dobjThrownWeapon.weaponIdx || CharacterInfo->dobjTurretWeapon.weaponIdx || CharacterInfo->dobjExecutionWeapon.weaponIdx || CharacterInfo->dobjAccessoryWeapon.weaponIdx;
}

/*
==============
CG_ExplosiveImpactOnShieldEvent
==============
*/
void CG_ExplosiveImpactOnShieldEvent(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v3; 
  int integer; 
  const dvar_t *v5; 
  vec3_t outOrg; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
  v3 = DVARINT_shieldImpactMissileShakeDuration;
  if ( !DVARINT_shieldImpactMissileShakeDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactMissileShakeDuration") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  integer = v3->current.integer;
  v5 = DVARFLT_shieldImpactMissileShakeScale;
  if ( !DVARFLT_shieldImpactMissileShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactMissileShakeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  CG_StartShakeCamera(localClientNum, v5->current.value, integer, &outOrg, 100.0);
  CG_Rumble_PlayOnClientSafeByName(localClientNum, "riotshield_impact");
  memset(&outOrg, 0, sizeof(outOrg));
}

/*
==============
CG_ExplosiveSplashOnShieldEvent
==============
*/
void CG_ExplosiveSplashOnShieldEvent(LocalClientNum_t localClientNum, int originalDamage)
{
  const dvar_t *v4; 
  const dvar_t *v5; 
  float value; 
  const dvar_t *v7; 
  const char *v8; 
  const dvar_t *v9; 
  int integer; 
  cg_t *LocalClientGlobals; 
  vec3_t outOrg; 

  v4 = DVARINT_shieldImpactExplosionThreshold;
  if ( !DVARINT_shieldImpactExplosionThreshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactExplosionThreshold") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( originalDamage <= v4->current.integer )
  {
    v9 = DVARFLT_shieldImpactExplosionLowShakeScale;
    if ( !DVARFLT_shieldImpactExplosionLowShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactExplosionLowShakeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    value = v9->current.value;
    v7 = DVARINT_shieldImpactExplosionLowShakeDuration;
    if ( !DVARINT_shieldImpactExplosionLowShakeDuration )
    {
      v8 = "shieldImpactExplosionLowShakeDuration";
LABEL_15:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v8) )
        __debugbreak();
    }
  }
  else
  {
    v5 = DVARFLT_shieldImpactExplosionHighShakeScale;
    if ( !DVARFLT_shieldImpactExplosionHighShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactExplosionHighShakeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    value = v5->current.value;
    v7 = DVARINT_shieldImpactExplosionHighShakeDuration;
    if ( !DVARINT_shieldImpactExplosionHighShakeDuration )
    {
      v8 = "shieldImpactExplosionHighShakeDuration";
      goto LABEL_15;
    }
  }
  Dvar_CheckFrontendServerThread(v7);
  integer = v7->current.integer;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
  CG_StartShakeCamera(localClientNum, value, integer, &outOrg, 100.0);
  CG_Rumble_PlayOnClientSafeByName(localClientNum, "riotshield_impact");
  memset(&outOrg, 0, sizeof(outOrg));
}

/*
==============
CG_FireWeapSound
==============
*/
void CG_FireWeapSound(const LocalClientNum_t localClientNum, centity_t *cent, const Weapon *weapon, const scr_string_t tagName, bool isPlayerView, bool isAlternate, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, PlayerHandIndex hand, const int autoSimId, const __int64 autoSimTimeStamp, const float autoSimDistSq, const SndWeapShotCountId shotCount, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags)
{
  vec3_t origin; 

  CG_FireWeaponSound_CalcOrigin(localClientNum, cent, weapon, tagName, isPlayerView, hand, &origin);
  CG_FireWeapSound_KnownOrigin(localClientNum, cent, weapon, isPlayerView, isAlternate, isPlayerHeli, isDualWield, useLastFireSound, hand, autoSimId, autoSimTimeStamp, autoSimDistSq, shotCount, pm_flags, &origin);
  memset(&origin, 0, sizeof(origin));
}

/*
==============
CG_FireWeapSound_KnownOrigin
==============
*/
void CG_FireWeapSound_KnownOrigin(const LocalClientNum_t localClientNum, centity_t *cent, const Weapon *weapon, bool isPlayerView, bool isAlternate, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, PlayerHandIndex hand, const int autoSimId, const __int64 autoSimTimeStamp, const float autoSimDistSq, const SndWeapShotCountId shotCount, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags, const vec3_t *origin)
{
  CgSoundSystem *SoundSystem; 
  bool v20; 
  const HyperBurstInfo *HyperBurstInfo; 
  const SndAliasList *WeapHyperBurstFireSound; 
  bool v23; 
  CgWeaponSystem *WeaponSystem; 
  PlayerHandIndex v25; 
  PlayerHandIndex v26; 
  SndWeapShotCountId v27; 
  SndWeapShotCountId v28; 
  int v29; 
  int v30; 
  const SndAliasList *WeapFireSound; 
  WeaponSFXPackage *sfxPackage; 

  Sys_ProfBeginNamedEvent(0xFF008080, "CG_FireWeapSound");
  sfxPackage = BG_GetSfxPackage(weapon, isAlternate);
  WeapFireSound = CG_GetWeapFireSound(sfxPackage, isPlayerView, isPlayerHeli, isDualWield, useLastFireSound, hand, shotCount);
  if ( WeapFireSound )
  {
    SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
    Sys_ProfBeginNamedEvent(0xFF008080, "PlayWeaponSound");
    v20 = isPlayerView || isPlayerHeli;
    LOBYTE(v27) = v20;
    LOBYTE(v25) = isAlternate;
    ((void (__fastcall *)(CgSoundSystem *, _QWORD, const vec3_t *, const SndAliasList *, const Weapon *, PlayerHandIndex, SndWeapShotCountId, const int, const __int64, _DWORD, const SndWeapShotCountId, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *, bool, PlayerHandIndex, _BYTE))SoundSystem->PlayWeaponSound)(SoundSystem, (unsigned int)cent->nextState.number, origin, WeapFireSound, weapon, v25, v27, autoSimId, autoSimTimeStamp, LODWORD(autoSimDistSq), shotCount, pm_flags, isDualWield, hand, 0);
    Sys_ProfEndNamedEvent();
    if ( !useLastFireSound && shotCount == SND_WEAP_SHOT_FIRST )
    {
      HyperBurstInfo = BG_GetHyperBurstInfo(weapon, isAlternate);
      if ( !HyperBurstInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18838, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
        __debugbreak();
      if ( HyperBurstInfo->enabled )
      {
        WeapHyperBurstFireSound = CG_GetWeapHyperBurstFireSound(sfxPackage, isPlayerView, isDualWield, hand);
        if ( WeapHyperBurstFireSound )
        {
          Sys_ProfBeginNamedEvent(0xFF008080, "PlayWeaponSound");
          v23 = isPlayerView || isPlayerHeli;
          LOBYTE(v30) = 1;
          LOBYTE(v29) = isDualWield;
          LOBYTE(v28) = v23;
          LOBYTE(v26) = isAlternate;
          ((void (__fastcall *)(CgSoundSystem *, _QWORD, const vec3_t *, const SndAliasList *, const Weapon *, PlayerHandIndex, SndWeapShotCountId, const int, const __int64, _DWORD, int, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *, int, PlayerHandIndex, int))SoundSystem->PlayWeaponSound)(SoundSystem, (unsigned int)cent->nextState.number, origin, WeapHyperBurstFireSound, weapon, v26, v28, autoSimId, autoSimTimeStamp, LODWORD(autoSimDistSq), 1, pm_flags, v29, hand, v30);
          Sys_ProfEndNamedEvent();
        }
      }
    }
    if ( BG_IsCharacterEntity(&cent->nextState) )
    {
      WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
      if ( WeaponSystem->ShouldWeaponPing(WeaponSystem, cent, weapon, isAlternate, origin) )
        CG_SndPingCompass(localClientNum, cent, weapon, isAlternate, origin);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_FireWeapon
==============
*/
void CG_FireWeapon(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, NULL, NULL);
}

/*
==============
CG_FireWeaponRicochet
==============
*/
void CG_FireWeaponRicochet(LocalClientNum_t localClientNum, centity_t *attackerEnt, centity_t *shieldEnt, const vec3_t *firePos, const vec3_t *fireDir, int ricochetCount, float travelDistance, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView)
{
  __int128 v11; 
  playerState_s *p_predictedPlayerState; 
  entityState_t *p_nextState; 
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  CgWeaponMap *Instance; 
  CgBallistics *System; 
  __int128 v21; 
  float v23; 
  double ADSDamageRangeScale; 
  float v25; 
  float v26; 
  __int64 p_perks; 
  const dvar_t *v28; 
  float value; 
  const dvar_t *v30; 
  float v31; 
  PlayerHandIndex v32; 
  double FireAtMaxDamageMultiplier; 
  float v34; 
  float v35; 
  float v36; 
  float v37; 
  CgWeaponSystem *WeaponSystem; 
  bool shouldSpawnTracer; 
  TagPair *v40; 
  TagPair tagPair; 
  int v42; 
  TagPair v43; 
  const vec3_t *v44; 
  bitarray<64> perks; 
  BulletFireParams v46; 

  v44 = firePos;
  v43 = (TagPair)shieldEnt;
  if ( !attackerEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19327, ASSERT_TYPE_ASSERT, "(attackerEnt)", (const char *)&queryFormat, "attackerEnt") )
    __debugbreak();
  if ( (attackerEnt->flags & 1) != 0 )
  {
    p_predictedPlayerState = NULL;
    p_nextState = &attackerEnt->nextState;
    perks = 0i64;
    if ( BG_IsCharacterEntity(&attackerEnt->nextState) )
    {
      LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
      CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, p_nextState->number);
      if ( CharacterInfo )
      {
        if ( CharacterInfo->infoValid )
          perks = CharacterInfo->perks;
      }
    }
    if ( !BG_WeaponBulletFire_ShouldRicochet(perks, weapon, isAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19347, ASSERT_TYPE_ASSERT, "(BG_WeaponBulletFire_ShouldRicochet( attackerPerks, weapon, isAlternate ))", (const char *)&queryFormat, "BG_WeaponBulletFire_ShouldRicochet( attackerPerks, weapon, isAlternate )") )
      __debugbreak();
    Instance = CgWeaponMap::GetInstance(localClientNum);
    if ( isPlayerView )
      p_predictedPlayerState = &CG_GetLocalClientGlobals(localClientNum)->predictedPlayerState;
    System = CgBallistics::GetSystem(localClientNum);
    *(double *)&v11 = BG_GetBulletRange<CgBallisticInstance>(Instance, System, p_predictedPlayerState, &attackerEnt->nextState, &perks, weapon, isAlternate);
    v21 = v11;
    *(float *)&v21 = *(float *)&v11 - travelDistance;
    _XMM2 = v21;
    __asm { vmaxss  xmm9, xmm2, xmm1 }
    v23 = *(float *)&v11;
    ADSDamageRangeScale = BG_GetADSDamageRangeScale(Instance, p_predictedPlayerState, weapon, isAlternate);
    v25 = FLOAT_1_0;
    v26 = *(float *)&ADSDamageRangeScale;
    if ( p_predictedPlayerState )
    {
      p_perks = (__int64)&p_predictedPlayerState->perks;
      if ( BG_HasPerk(&p_predictedPlayerState->perks, 0x18u) )
      {
        v28 = DCONST_DVARFLT_perk_longerRangeScale;
        if ( !DCONST_DVARFLT_perk_longerRangeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_longerRangeScale") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v28);
        value = v28->current.value;
        p_nextState = &attackerEnt->nextState;
        goto LABEL_22;
      }
    }
    else
    {
      p_perks = 4464i64;
    }
    value = FLOAT_1_0;
LABEL_22:
    if ( p_predictedPlayerState && BG_HasPerk((const bitarray<64> *)p_perks, 0x1Cu) )
    {
      v30 = DVARFLT_perk_bulletPenetrationMultiplier;
      if ( !DVARFLT_perk_bulletPenetrationMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_bulletPenetrationMultiplier") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v30);
      v31 = v30->current.value;
    }
    else
    {
      v31 = FLOAT_1_0;
    }
    if ( p_predictedPlayerState )
    {
      v32 = hand;
      if ( p_predictedPlayerState->weapState[hand].weaponFiredAtMaxCharge && BG_IsChargeShotWeapon(weapon, isAlternate) )
      {
        FireAtMaxDamageMultiplier = BG_WeaponCharge_GetFireAtMaxDamageMultiplier(weapon, isAlternate);
        v25 = *(float *)&FireAtMaxDamageMultiplier;
      }
    }
    else
    {
      v32 = hand;
    }
    memset_0(&v46, 0, sizeof(v46));
    v46.weaponEntIndex = p_nextState->number;
    v46.rangeScale = value * v26;
    v46.penetrationMultiplier = v31;
    v34 = v44->v[1];
    v35 = v44->v[2];
    v46.start.v[0] = v44->v[0];
    v46.chargedDamageMultiplier = v25;
    v46.start.v[1] = v34;
    v36 = fireDir->v[1];
    v37 = fireDir->v[2];
    v46.dir.v[0] = fireDir->v[0];
    v46.dir.v[1] = v36;
    v46.end.v[0] = (float)(v46.dir.v[0] * *(float *)&_XMM9) + v46.start.v[0];
    v46.end.v[2] = (float)(v37 * *(float *)&_XMM9) + v35;
    v46.start.v[2] = v35;
    v46.dir.v[2] = v37;
    v46.travelDistance = travelDistance;
    v46.end.v[1] = (float)(v36 * *(float *)&_XMM9) + v34;
    v46.methodOfDeath = BG_WeaponBulletFire_GetMethodOfDeath(perks, weapon, isAlternate);
    if ( v43 )
    {
      if ( (*(_BYTE *)(*(_QWORD *)&v43 + 648i64) & 1) != 0 )
        BG_AddIgnoreEntToBP(&v46, *(__int16 *)(*(_QWORD *)&v43 + 400i64));
    }
    WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
    shouldSpawnTracer = CgWeaponSystem::ShouldSpawnTracer(WeaponSystem, attackerEnt->nextState.number, &perks, v32, weapon, isAlternate, 1);
    TagPair::TagPair(&v43);
    tagPair = *v40;
    v42 = CgWeaponSystem::ClaimBulletId(WeaponSystem);
    CgWeaponSystem::SimulateBulletFire_Ricochet(WeaponSystem, &v46, v42, weapon, isAlternate, attackerEnt, &perks, isPlayerView, hand, tagPair, v23, ricochetCount, shouldSpawnTracer, 0);
  }
}

/*
==============
CG_FireWeaponSound_CalcOrigin
==============
*/
void CG_FireWeaponSound_CalcOrigin(const LocalClientNum_t localClientNum, const centity_t *const cent, const Weapon *weapon, const scr_string_t tagName, bool isPlayerView, const PlayerHandIndex hand, vec3_t *outOrigin)
{
  cg_t *LocalClientGlobals; 
  char v12; 
  cg_t *v13; 
  DObj *viewModelDObj; 
  clientLinkInfo_t clientLinkInfo; 
  DObj *ClientDObj; 
  vec3_t *v17; 
  int time; 
  centity_t *Entity; 
  scr_string_t tag_player; 
  const centity_t *v21; 
  CgTrajectory v22; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18746, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v12 = 0;
  v13 = LocalClientGlobals;
  if ( !isPlayerView || cent->nextState.eType == ET_TURRET )
  {
    clientLinkInfo = cent->nextState.clientLinkInfo;
    if ( (*(_DWORD *)&clientLinkInfo & 0x200000) != 0 )
    {
      if ( (*(_WORD *)&clientLinkInfo & 0x7FF) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18763, ASSERT_TYPE_ASSERT, "(ent->clientLinkInfo.parentId)", (const char *)&queryFormat, "ent->clientLinkInfo.parentId") )
        __debugbreak();
      ClientDObj = Com_GetClientDObj((*(_DWORD *)&cent->nextState.clientLinkInfo & 0x7FFu) - 1, localClientNum);
      v12 = 1;
    }
    else
    {
      if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18769, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", "%s\n\tCG_FireWeapSound invalid entity %d, eType %d, flags %d, weaponIdx %d", "CENextValid( cent )", cent->nextState.number, cent->nextState.eType, cent->flags, weapon->weaponIdx) )
        __debugbreak();
      if ( !tagName )
      {
        viewModelDObj = NULL;
        goto LABEL_19;
      }
      ClientDObj = Com_GetClientDObj(cent->nextState.number, localClientNum);
    }
    viewModelDObj = ClientDObj;
    goto LABEL_19;
  }
  viewModelDObj = cg_t::GetViewModelHand(LocalClientGlobals, hand)->viewModelDObj;
  CG_UpdateViewModelPoseForHand(viewModelDObj, localClientNum, hand, 0);
LABEL_19:
  CgTrajectory::CgTrajectory(&v22, localClientNum, cent, &cent->nextState.lerp);
  if ( !isPlayerView || cent->nextState.eType == ET_TURRET )
  {
    if ( v12 )
    {
      Entity = CG_GetEntity(localClientNum, (*(_DWORD *)&cent->nextState.clientLinkInfo & 0x7FFu) - 1);
      v17 = outOrigin;
      if ( viewModelDObj && Entity )
      {
        tag_player = scr_const.tag_player;
        v21 = Entity;
        goto LABEL_30;
      }
    }
    else
    {
      v17 = outOrigin;
      if ( viewModelDObj )
      {
        tag_player = tagName;
        v21 = cent;
LABEL_30:
        if ( CG_DObjGetWorldTagPos(&v21->pose, viewModelDObj, tag_player, v17) )
          return;
      }
    }
    time = CG_GetLocalClientGlobals(localClientNum)->time;
    goto LABEL_32;
  }
  v17 = outOrigin;
  if ( !viewModelDObj || !CG_DObjGetWorldTagPos(&v13->viewModelPose, viewModelDObj, tagName, outOrigin) )
  {
    time = v13->time;
LABEL_32:
    BgTrajectory::EvaluatePosTrajectory(&v22, time, v17);
  }
}

/*
==============
CG_FireWeaponWithHighPrecisionData
==============
*/
void CG_FireWeaponWithHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, NULL, highPrecisionFireData);
}

/*
==============
CG_FireWeaponWithLod
==============
*/
void CG_FireWeaponWithLod(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, eventLodData, NULL);
}

/*
==============
CG_FireWeaponWithLodAndHighPrecisionData
==============
*/
void CG_FireWeaponWithLodAndHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, eventLodData, highPrecisionFireData);
}

/*
==============
CG_FireWeapon_FireSound
==============
*/
void CG_FireWeapon_FireSound(LocalClientNum_t localClientNum, centity_t *cent, int event, const scr_string_t tagName, DObj *obj, const Weapon *weapon, bool isAlternate, bool isPlayerView, bool isDualWield, PlayerHandIndex hand)
{
  __int64 v12; 
  cg_t *LocalClientGlobals; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *v14; 
  entityType_s eType; 
  bool v17; 
  const VehicleClient *Client; 
  const VehicleDef *ClientDef; 
  const WeaponCompleteDef *PointerToWeaponCompleteDefConst; 
  const WeaponDef *v21; 
  bool useLastFireSound; 
  bool v24; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags; 
  __int128 v26; 
  double v27; 
  const dvar_t *v28; 
  __int64 v29; 
  vec3_t *outOrigin; 
  vec3_t origin; 
  __m256i v32; 
  Weapon v33; 
  bool weapona; 
  int isPlayerViewa; 

  v12 = localClientNum;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18935, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v12);
  v14 = (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)LocalClientGlobals;
  eType = cent->nextState.eType;
  if ( eType == ET_HELICOPTER )
  {
    if ( (LocalClientGlobals->predictedPlayerState.linkFlags.m_flags[0] & 4) != 0 && LocalClientGlobals->predictedPlayerState.linkEnt == cent->nextState.number )
    {
      weapona = 1;
      v17 = 0;
    }
    else
    {
      weapona = 0;
      v17 = 0;
    }
  }
  else
  {
    weapona = 0;
    v17 = 0;
    if ( eType == ET_VEHICLE )
    {
      if ( weapon->weaponIdx )
      {
        if ( !(_BYTE)CgVehicleSystem::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 406, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the vehicle system for localClientNum %d but the vehicle system type is not known\n", "ms_allocatedType != GameModeType::NONE", v12) )
          __debugbreak();
        if ( (unsigned int)v12 >= CgVehicleSystem::ms_allocatedCount )
        {
          LODWORD(outOrigin) = CgVehicleSystem::ms_allocatedCount;
          LODWORD(v29) = v12;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 407, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v29, outOrigin) )
            __debugbreak();
        }
        if ( !CgVehicleSystem::ms_vehicleSystemArray[v12] )
        {
          LODWORD(outOrigin) = v12;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 408, ASSERT_TYPE_ASSERT, "(ms_vehicleSystemArray[localClientNum])", "%s\n\tTrying to access unallocated vehicle system for localClientNum %d\n", "ms_vehicleSystemArray[localClientNum]", outOrigin) )
            __debugbreak();
        }
        Client = CgVehicleSystem::GetClient(CgVehicleSystem::ms_vehicleSystemArray[v12], cent);
        ClientDef = CgVehicleSystem::GetClientDef(Client);
        PointerToWeaponCompleteDefConst = BG_GetPointerToWeaponCompleteDefConst(weapon->weaponIdx);
        if ( !PointerToWeaponCompleteDefConst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18960, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
          __debugbreak();
        if ( ClientDef->turretWeapon == PointerToWeaponCompleteDefConst && ClientDef->turretFireType == VEH_TURRET_ALT_FIRE )
          v17 = 1;
      }
    }
    else if ( eType == ET_TURRET && weapon->weaponIdx )
    {
      v21 = BG_WeaponDef(weapon, 0);
      if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18970, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
        __debugbreak();
      v17 = v21->turretFireType == TURRET_ALTERNATE_FIRE;
    }
  }
  useLastFireSound = BG_IsLastShotWeaponEvent(event);
  if ( !useLastFireSound && isPlayerView )
    useLastFireSound = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(v14 + 230, ACTIVE, 0xCu);
  v24 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_LADDER_AIM) && !useLastFireSound && event == 204;
  pm_flags = (GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)((char *)&v14[3] + 4);
  if ( isPlayerView )
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(pm_flags, ACTIVE, 9u);
  v32 = *(__m256i *)&weapon->weaponIdx;
  *(__m256i *)&v33.weaponIdx = v32;
  v26 = *(_OWORD *)&weapon->attachmentVariationIndices[5];
  *(_OWORD *)&v33.attachmentVariationIndices[5] = v26;
  v27 = *(double *)&weapon->attachmentVariationIndices[21];
  *(double *)&v33.attachmentVariationIndices[21] = v27;
  isPlayerViewa = *(_DWORD *)&weapon->weaponCamo;
  *(_DWORD *)&v33.weaponCamo = isPlayerViewa;
  if ( isPlayerView && cent->nextState.number == (_DWORD)v12 )
    CG_SND_PlayerBreathsSetShooting((LocalClientNum_t)v12);
  v28 = DCONST_DVARBOOL_snd_autoSim;
  if ( !DCONST_DVARBOOL_snd_autoSim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_autoSim") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v28);
  if ( v28->current.enabled )
  {
    *(__m256i *)&v33.weaponIdx = v32;
    *(_OWORD *)&v33.attachmentVariationIndices[5] = v26;
    *(double *)&v33.attachmentVariationIndices[21] = v27;
    *(_DWORD *)&v33.weaponCamo = isPlayerViewa;
    CG_SndPingAutoSim((LocalClientNum_t)v12, cent, &v33, tagName, isPlayerView, isAlternate, weapona, isDualWield, useLastFireSound, v17, hand, v24, pm_flags);
  }
  else
  {
    CG_FireWeaponSound_CalcOrigin((const LocalClientNum_t)v12, cent, &v33, tagName, isPlayerView, hand, &origin);
    CG_FireWeapSound_KnownOrigin((const LocalClientNum_t)v12, cent, &v33, isPlayerView, isAlternate, weapona, isDualWield, useLastFireSound, hand, -1, 0i64, 0.0, SND_WEAP_SHOT_UNCOUNTED, pm_flags, &origin);
    memset(&origin, 0, sizeof(origin));
  }
}

/*
==============
CG_FireWeapon_Internal
==============
*/
void CG_FireWeapon_Internal(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const int fireSequenceIndex, const CgEventLodData *optionalEventLodData, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  const Weapon *v16; 
  PlayerHandIndex v17; 
  entityState_t *p_nextState; 
  cg_t *LocalClientGlobals; 
  CgWeaponSystem *WeaponSystem; 
  bool v21; 
  __int16 number; 
  cg_t *v23; 
  playerState_s *p_predictedPlayerState; 
  bool v25; 
  const DObj *ClientDObj; 
  DObj *viewModelDObj; 
  bool v28; 
  float pitchmove; 
  float yawmove; 
  CgWeaponMap *Instance; 
  CgHandler *Handler; 
  WeaponHeat *v33; 
  Weapon *v34; 
  bool v35; 
  centity_t *v36; 
  int flags; 
  int v38; 
  int v39; 
  int v40; 
  const characterInfo_t *CharacterInfo; 
  bool v42; 
  int v43; 
  bool v44; 
  const RumbleInfo *v45; 
  cg_t *v46; 
  CgWeaponSystem *v47; 
  int v48; 
  BOOL v49; 
  int ControllerFromClient; 
  unsigned __int16 ModelForController; 
  unsigned __int16 ModelFromPath; 
  LUIModelDataType DataType; 
  unsigned __int16 v54; 
  int v55; 
  BOOL fmt; 
  BOOL gunKickAngles; 
  BOOL outGunKickAVel; 
  BOOL outGunNeedsToCrossCenter; 
  PlayerHandIndex outViewKickAVel; 
  bool IsKillCamEntityView; 
  bool v62; 
  bool v63; 
  bool v64; 
  __int16 v65; 
  unsigned __int8 outBoneIndex[4]; 
  scr_string_t outTagName; 
  unsigned int v68; 
  PlayerHandIndex v69; 
  Weapon *r_weapon; 
  playerState_s *ps; 
  unsigned int v72; 
  centity_t *centa; 
  CgEventLodData *lodData; 
  CgWeaponSystem *v75; 
  cg_t *v76; 
  SecureVec3 inData; 
  const CgFireEventHighPrecisionData *v78; 
  __int64 v79; 
  bitarray<64> outPerks; 
  SecureVec3 outData; 

  v79 = -2i64;
  v72 = knownHitClientNum;
  v68 = event;
  centa = cent;
  v16 = weapon;
  r_weapon = (Weapon *)weapon;
  v17 = hand;
  v69 = hand;
  lodData = (CgEventLodData *)optionalEventLodData;
  v78 = highPrecisionFireData;
  p_nextState = &cent->nextState;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v76 = LocalClientGlobals;
  WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
  v75 = WeaponSystem;
  if ( !v16->weaponIdx )
    return;
  if ( v16->weaponIdx >= BG_GetNumWeapons() )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DFE40, 617i64);
    return;
  }
  IsKillCamEntityView = CG_View_IsKillCamEntityView(localClientNum);
  v65 = 0;
  if ( event == 41 )
  {
    HIBYTE(v65) = p_nextState->number == LocalClientGlobals->predictedPlayerState.clientNum;
    if ( p_nextState->number == LocalClientGlobals->predictedPlayerState.clientNum )
      goto LABEL_14;
    if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2510, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x38u) )
      goto LABEL_14;
    if ( !Com_GameMode_SupportsFeature(WEAPON_LADDER_CLIMB|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2514, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::MELEE_EXECUTION ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::MELEE_EXECUTION )") )
      __debugbreak();
    LOBYTE(v65) = 1;
    if ( LocalClientGlobals->predictedPlayerState.activeExecutionPartnerEntNum != p_nextState->number )
LABEL_14:
      LOBYTE(v65) = 0;
  }
  v21 = isPlayerView;
  v63 = isPlayerView;
  if ( p_nextState->eType == ET_TURRET )
  {
    number = p_nextState->number;
    v23 = CG_GetLocalClientGlobals((const LocalClientNum_t)WeaponSystem->m_localClientNum);
    p_predictedPlayerState = &v23->predictedPlayerState;
    if ( v23 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) )
      goto LABEL_24;
    v25 = p_predictedPlayerState->viewlocked_entNum == (unsigned __int16)number;
  }
  else
  {
    if ( !BG_IsVehicleEntity(p_nextState) )
    {
      if ( v21 )
        goto LABEL_35;
LABEL_25:
      ps = NULL;
      if ( !CG_Entity_CanUseDObj(localClientNum, p_nextState->number) || (ClientDObj = Com_GetClientDObj(p_nextState->number, localClientNum), (viewModelDObj = (DObj *)ClientDObj) != NULL) && !DObjVerifyNumBones(ClientDObj) )
        viewModelDObj = NULL;
      v28 = isAlternate;
      v62 = isAlternate;
      goto LABEL_30;
    }
    v25 = LocalClientGlobals->predictedPlayerState.vehicleState.entity == p_nextState->number;
  }
  if ( !v25 || IsKillCamEntityView )
  {
LABEL_24:
    v21 = 0;
    goto LABEL_25;
  }
  v21 = 1;
LABEL_35:
  ps = &LocalClientGlobals->predictedPlayerState;
  viewModelDObj = cg_t::GetViewModelHand(LocalClientGlobals, v17)->viewModelDObj;
  CG_UpdateViewModelPoseForHand(viewModelDObj, localClientNum, v17, 0);
  v28 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
  v62 = v28;
LABEL_30:
  if ( v63 )
  {
    pitchmove = (float)LocalClientGlobals->predictedPlayerState.lastInput.pitchmove;
    yawmove = (float)LocalClientGlobals->predictedPlayerState.lastInput.yawmove;
    secure_uint32_3_t::secureInt32_3_Get(&LocalClientGlobals->kickAngles, &outData);
    secure_uint32_3_t::secureInt32_3_Get(&LocalClientGlobals->kickAVel, &inData);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    BG_WeaponFireRecoil(Instance, ps, v69, pitchmove, yawmove, (const vec2_t *)&v76->predictedViewState.weapMoveState.recoilAngles, (const vec2_t *)&outData, (vec2_t *)&LocalClientGlobals->predictedViewState.weapMoveState.recoilSpeed, &LocalClientGlobals->predictedViewState.weapMoveState.recoilNeedsToCrossCenter, (vec3_t *)&inData, &LocalClientGlobals->kickNeedsToCrossCenter);
    secure_uint32_3_t::secureInt32_3_Set(&LocalClientGlobals->kickAngles, &outData);
    secure_uint32_3_t::secureInt32_3_Set(&LocalClientGlobals->kickAVel, &inData);
    memset(&inData, 0, sizeof(inData));
    memset(&outData, 0, sizeof(outData));
    Handler = CgHandler::getHandler(localClientNum);
    v17 = v69;
    v33 = Handler->GetPlayerWeaponHeat(Handler, ps, r_weapon, v69);
    v28 = v62;
    v34 = r_weapon;
    BG_Heat_ApplyFireHeat(v33, r_weapon, v62, ps->serverTime);
  }
  else
  {
    v34 = r_weapon;
  }
  CG_Heat_FireWeapon(localClientNum, p_nextState, v17);
  CG_GetPerks(localClientNum, p_nextState->number, &outPerks);
  Tracer_AdvanceDrawCounter(localClientNum, &outPerks, v17, v34, v28, p_nextState->number);
  if ( !bNoTracer )
  {
    LOBYTE(outGunNeedsToCrossCenter) = v63;
    LOBYTE(outGunKickAVel) = v21;
    LOBYTE(gunKickAngles) = v28;
    v75->UpdateBulletFire(v75, v68, centa, v72, r_weapon, gunKickAngles, weaponFlashTagPair, outGunKickAVel, outGunNeedsToCrossCenter, v17, fireSequenceIndex, lodData, v78);
    v34 = r_weapon;
  }
  v35 = Tracer_IsFirstInBurst(localClientNum, v17, p_nextState->number) == 1;
  v64 = v35;
  if ( v17 >= NUM_WEAPON_HANDS )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 625, ASSERT_TYPE_ASSERT, "(hand < NUM_WEAPON_HANDS)", (const char *)&queryFormat, "hand < NUM_WEAPON_HANDS") )
      __debugbreak();
    v35 = v64;
  }
  v36 = centa;
  flags = centa->flags;
  if ( (flags & 0x40) != 0 )
    flags &= 0xFFFFFF83;
  v38 = 16;
  if ( v17 == WEAPON_HAND_DEFAULT )
    v38 = 4;
  v39 = flags | v38;
  centa->flags = v39;
  if ( v35 )
  {
    v40 = 32;
    if ( v17 == WEAPON_HAND_DEFAULT )
      v40 = 8;
    v36->flags = v39 | v40;
  }
  LOBYTE(gunKickAngles) = v21;
  LOBYTE(fmt) = v28;
  v75->UpdateMuzzleFlashNonPlayer(v75, p_nextState, weaponFlashTagPair, v34, fmt, gunKickAngles);
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CG_FireWeapon_FireSound");
  outBoneIndex[0] = -2;
  outTagName = 0;
  if ( viewModelDObj && CG_EventLod_ShouldPerformEvent(localClientNum, CG_EVENT_LOD_TYPE_FIRE_WEAPON_EXACT_WEAPON_SOUND_ORIGIN, lodData) )
  {
    CharacterInfo = cg_t::TryGetCharacterInfo(v76, (unsigned int)viewModelDObj->entnum - 1);
    if ( CharacterInfo )
    {
      *(_QWORD *)&outData.x = 0xD0000000Ci64;
      LODWORD(outData.z) = 11;
      TagPair::GetTagNameAndBoneIndexForCharacter((TagPair *)&weaponFlashTagPair, viewModelDObj, CharacterInfo, (const CharacterModelType *)&outData, 3, &outTagName, outBoneIndex);
    }
    else
    {
      TagPair::GetTagNameAndBoneIndex((TagPair *)&weaponFlashTagPair, viewModelDObj, &outTagName, outBoneIndex);
    }
  }
  v42 = v21 || v65;
  outViewKickAVel = v17;
  v43 = v68;
  CG_FireWeapon_FireSound(localClientNum, centa, v68, outTagName, viewModelDObj, v34, v28, v42, isDualWield, outViewKickAVel);
  Sys_ProfEndNamedEvent();
  if ( !BG_IsBoltAction(v34, v28) && CG_EventLod_ShouldPerformEvent(localClientNum, CG_EVENT_LOD_TYPE_EJECT_BRASS, lodData) )
    CG_EjectWeaponBrass(localClientNum, p_nextState, v43, v28);
  v44 = v21 || HIBYTE(v65);
  v45 = BG_FireRumble(v34, v28);
  if ( v45 )
  {
    v46 = CG_GetLocalClientGlobals(localClientNum);
    v47 = CgWeaponSystem::GetWeaponSystem(localClientNum);
    v48 = v47->IsPlayerUsingVehicleWeapon(v47, &v46->predictedPlayerState, p_nextState);
    v49 = p_nextState->eType == ET_TURRET && (v46->predictedPlayerState.linkFlags.m_flags[0] & 4) != 0 && v46->predictedPlayerState.viewlocked_entNum == p_nextState->number;
    if ( v44 || v48 || v49 )
      CG_Rumble_PlayOnClient(localClientNum, v45);
  }
  if ( v21 )
    v75->UpdateWeaponPossession(v75, ps);
  if ( v68 != 41 && v76->predictedPlayerState.clientNum == p_nextState->number )
  {
    ControllerFromClient = CL_Mgr_GetControllerFromClient(localClientNum);
    ModelForController = LUI_Model_GetModelForController(ControllerFromClient);
    ModelFromPath = LUI_Model_CreateModelFromPath(ModelForController, "cg.player.currentWeapon.shotCounter");
    DataType = LUI_Model_GetDataType(ModelFromPath);
    v54 = ModelFromPath;
    if ( DataType == LUI_MODEL_DT_INT )
    {
      v55 = LUI_Model_GetInt(ModelFromPath) + 1;
      v54 = ModelFromPath;
    }
    else
    {
      v55 = 1;
    }
    LUI_Model_SetInt(v54, v55);
  }
}

/*
==============
CG_ForceSwitchToValidWeapon
==============
*/
_BOOL8 CG_ForceSwitchToValidWeapon(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v3; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  const Weapon *v6; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return 0i64;
  if ( LocalClientGlobals->demoType == HALF )
    return 0i64;
  if ( CG_View_IsKillCamView(localClientNum) )
    return 0i64;
  if ( v3->predictedPlayerState.pm_type >= 7 )
    return 0i64;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &v3->predictedPlayerState);
  v6 = CurrentWeaponForPlayer;
  return CurrentWeaponForPlayer->weaponIdx && !BG_IsWeaponUsableInState(&v3->predictedPlayerState, CurrentWeaponForPlayer) && (!memcmp_0(v6, &v3->weaponSelect, 0x3Cui64) || !BG_IsWeaponUsableInState(&v3->predictedPlayerState, &v3->weaponSelect)) && CycleWeapPrimary(localClientNum, 0, 1, 0, 1, 1);
}

/*
==============
CG_GetAirburstMarkDistance
==============
*/
__int64 CG_GetAirburstMarkDistance(LocalClientNum_t localClientNum, playerState_s *ps, unsigned __int64 buttons, unsigned int *outDistance)
{
  __int16 v5; 
  cg_t *LocalClientGlobals; 
  bool breathPressedLastFrame; 
  bool v10; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  int iProjectileActivateDist; 
  __int64 result; 

  v5 = buttons;
  if ( !outDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22160, ASSERT_TYPE_ASSERT, "(outDistance)", (const char *)&queryFormat, "outDistance") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22163, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  breathPressedLastFrame = LocalClientGlobals->breathPressedLastFrame;
  LocalClientGlobals->breathPressedLastFrame = (v5 & 0x800) != 0i64;
  if ( (v5 & 0x800) == 0 || breathPressedLastFrame )
    return 0i64;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22170, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = 1.0 == ps->weapCommon.fWeaponPosFrac;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, ps);
  if ( !v10 || !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) || !BG_WeaponDef(CurrentWeaponForPlayer, 0)->isAirburstWeapon )
    return 0i64;
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22176, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST )") )
    __debugbreak();
  iProjectileActivateDist = 0;
  if ( LocalClientGlobals->crosshairTraceDistance )
  {
    iProjectileActivateDist = BG_WeaponDef(CurrentWeaponForPlayer, 0)->iProjectileActivateDist;
    if ( (signed int)LocalClientGlobals->crosshairTraceDistance > iProjectileActivateDist )
      iProjectileActivateDist = LocalClientGlobals->crosshairTraceDistance;
  }
  ps->airburstMarkDistance = truncate_cast<unsigned short,unsigned int>(iProjectileActivateDist);
  result = 1i64;
  *outDistance = iProjectileActivateDist;
  return result;
}

/*
==============
CG_GetBlendedNVGFraction
==============
*/
float CG_GetBlendedNVGFraction(const cg_t *cgameGlob, const ClientNVGInfoWeightedBlind *weightedBlindInfo)
{
  bool blendingIn; 
  const dvar_t *v5; 
  int integer; 
  const dvar_t *v7; 
  const char *v8; 
  const dvar_t *v9; 
  int v10; 
  double v11; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13166, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  blendingIn = weightedBlindInfo->blendingIn;
  if ( blendingIn )
  {
    v5 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDelay;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlindWeighted_BlendInDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    integer = v5->current.integer;
    v7 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDuration;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDuration )
    {
      v8 = "NVG_ScriptBlindWeighted_BlendInDuration";
      goto LABEL_15;
    }
  }
  else
  {
    v9 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDelay;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlindWeighted_BlendOutDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    integer = v9->current.integer;
    v7 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDuration;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDuration )
    {
      v8 = "NVG_ScriptBlindWeighted_BlendOutDuration";
LABEL_15:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v8) )
        __debugbreak();
    }
  }
  Dvar_CheckFrontendServerThread(v7);
  v10 = v7->current.integer;
  if ( v10 > 0 )
    v11 = I_fclamp((float)(cgameGlob->time - weightedBlindInfo->blendStartTime - integer) / (float)v10, 0.0, 1.0);
  else
    *(float *)&v11 = FLOAT_1_0;
  if ( !blendingIn )
    *(float *)&v11 = 1.0 - *(float *)&v11;
  return *(float *)&v11;
}

/*
==============
CG_GetCurrentWeaponSlot
==============
*/

WeaponSlot __fastcall CG_GetCurrentWeaponSlot(LocalClientNum_t localClientNum, __int64 a2, double a3)
{
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  const WeaponDef *v7; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals->nextSnap && (p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState, BG_IsPlayer(&LocalClientGlobals->predictedPlayerState)) && (Instance = CgWeaponMap::GetInstance(localClientNum), r_weapon = *BG_GetCurrentWeaponForPlayer(Instance, p_predictedPlayerState), LOWORD(a3)) && (v7 = BG_WeaponDef(&r_weapon, 0)) != NULL && v7->inventoryType == WEAPINVENTORY_PRIMARY )
    return BG_PlayerWeaponGetEquippedSlot(Instance, p_predictedPlayerState, &r_weapon);
  else
    return 0;
}

/*
==============
CG_GetEntWeapon
==============
*/
const Weapon *CG_GetEntWeapon(LocalClientNum_t localClientNum, const centity_t *cent)
{
  const BgWeaponMap **v3; 

  v3 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[localClientNum];
  if ( !*v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  return BG_GetWeaponForEntity(*v3, &cent->nextState);
}

/*
==============
CG_GetFastADSBlendTimes
==============
*/
bool CG_GetFastADSBlendTimes(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const WeaponAnimNumber anim, const WeaponAnimNumber prevAnim, float *blendInTime, float *blendOutTime)
{
  float *v7; 
  float *v12; 
  cg_t *LocalClientGlobals; 
  const WeaponAnimNumber *v14; 
  unsigned int v15; 
  bool result; 
  CgWeaponMap *Instance; 
  bool v18; 
  float v19; 
  double v20; 
  double v21; 
  float v22; 
  float outAdsTransInSpeedMs; 

  v7 = blendInTime;
  if ( !blendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2355, ASSERT_TYPE_ASSERT, "(blendInTime)", (const char *)&queryFormat, "blendInTime") )
    __debugbreak();
  v12 = blendOutTime;
  if ( !blendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2356, ASSERT_TYPE_ASSERT, "(blendOutTime)", (const char *)&queryFormat, "blendOutTime") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2359, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( anim != WEAP_FORCE_IDLE || !LocalClientGlobals->fastADSTransActive )
    return 0;
  v14 = s_fastADSBlendAnimStates;
  v15 = 0;
  while ( prevAnim != *v14 )
  {
    ++v15;
    ++v14;
    if ( v15 >= 0xE )
      return 0;
  }
  Instance = CgWeaponMap::GetInstance(localClientNum);
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2376, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v18 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(Instance, ps, weapon, v18, &outAdsTransInSpeedMs, (float *)&blendInTime);
  v19 = 0.001 / outAdsTransInSpeedMs;
  v20 = BG_WeaponADSFractionAffectedByReload(Instance, ps);
  v21 = I_fclamp(1.0 - *(float *)&v20, 0.0, 1.0);
  v22 = (float)(*(float *)&v21 * v19) * 0.69999999;
  result = 1;
  *v7 = v22;
  *v12 = v22;
  return result;
}

/*
==============
CG_GetFleshImpactAxis
==============
*/
void CG_GetFleshImpactAxis(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int boneIndex, const vec3_t *position, tmat33_t<vec3_t> *outAxis)
{
  centity_t *Entity; 
  centity_t *v9; 
  const DObj *ClientDObj; 
  float v11; 
  float v12; 
  __int128 v13; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  vec3_t n; 
  orientation_t orient; 

  Entity = CG_GetEntity(localClientNum, sourceEntityNum);
  v9 = Entity;
  if ( (Entity->flags & 1) != 0 )
  {
    ClientDObj = Com_GetClientDObj(Entity->nextState.number, localClientNum);
    if ( ClientDObj )
    {
      if ( DObjIsValidBoneIndex(ClientDObj, boneIndex) && CG_Entity_GetBoneOrientation(localClientNum, v9->nextState.number, boneIndex, &orient) )
      {
        v11 = position->v[0] - orient.origin.v[0];
        v12 = position->v[2];
        v13 = LODWORD(position->v[1]);
        v14 = (float)((float)((float)(*(float *)&v13 - orient.origin.v[1]) * orient.axis.m[0].v[1]) + (float)(v11 * orient.axis.m[0].v[0])) + (float)((float)(v12 - orient.origin.v[2]) * orient.axis.m[0].v[2]);
        v15 = v11 - (float)(v14 * orient.axis.m[0].v[0]);
        v16 = (float)(v12 - orient.origin.v[2]) - (float)(v14 * orient.axis.m[0].v[2]);
        v17 = (float)(*(float *)&v13 - orient.origin.v[1]) - (float)(v14 * orient.axis.m[0].v[1]);
        *(float *)&v13 = fsqrt((float)((float)(v17 * v17) + (float)(v15 * v15)) + (float)(v16 * v16));
        _XMM4 = v13;
        __asm
        {
          vcmpless xmm0, xmm4, cs:__real@80000000
          vblendvps xmm0, xmm4, xmm1, xmm0
        }
        n.v[0] = v15 * (float)(1.0 / *(float *)&_XMM0);
        n.v[2] = v16 * (float)(1.0 / *(float *)&_XMM0);
        n.v[1] = v17 * (float)(1.0 / *(float *)&_XMM0);
        OrthonormalBasis(&n, outAxis);
      }
    }
  }
}

/*
==============
CG_GetImpactEffectForWeapon
==============
*/
void CG_GetImpactEffectForWeapon(LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, const bool filterByContents, const int hitContents, const Weapon *weapon, bool isAlternate, const int surfType, const unsigned int impactFlags, SndHitArmorType hitArmorType, FXRegisteredDef *outFx, const SndAliasList **outSnd, bool *outIsSfxExplosion)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  __int64 v17; 
  const playerState_s *p_predictedPlayerState; 
  __int16 *v19; 
  bool v20; 
  SfxImpactGroup *p_npcImpactSounds; 
  WeaponSFXPackage *SfxPackage; 
  const SndAliasList *v23; 
  bool v24; 
  SndHitType ImpactSoundHitLocation; 
  bool v26; 
  const SndAliasList *bulletExitSmallSound; 
  const SndAliasList *bulletExitLargeSound; 
  const SndAliasList *shotgunExitSound; 
  WeaponSFXPackage *v30; 
  bool v31; 
  const Weapon *v32; 
  const SndAliasList *vehBulletExitMediumSound; 
  const SndAliasList *WeaponSoundWithFallback; 
  bool v35; 
  unsigned int v36; 
  int v37; 
  FXRegisteredDef *v38; 
  __int64 v39; 
  int fxImpactType; 
  int targetEntityNuma; 
  FX_FleshType ImpactEffectHitLocation; 
  int impactType; 
  unsigned int v44; 
  FXRegisteredDef *v45; 
  const WeaponDef *v46; 
  playerState_s *ps; 
  char output[1024]; 

  v45 = outFx;
  targetEntityNuma = targetEntityNum;
  v44 = sourceEntityNum;
  outFx->m_particleSystemDef = NULL;
  outFx[1].m_particleSystemDef = NULL;
  *outSnd = NULL;
  *outIsSfxExplosion = 0;
  if ( (impactFlags & 0x18) != 24 && (!filterByContents || targetEntityNum != 2047 && (hitContents & 0x800) == 0) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20091, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    Handler = CgHandler::getHandler(localClientNum);
    ps = &LocalClientGlobals->predictedPlayerState;
    v17 = (__int64)Handler->PlayerTurretEnt(Handler, &LocalClientGlobals->predictedPlayerState);
    p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
    v19 = (__int16 *)v17;
    v20 = CG_IsPlayerEntityNumber(p_predictedPlayerState, sourceEntityNum) || v19 && *v19 == sourceEntityNum;
    p_npcImpactSounds = &cgMedia.npcImpactSounds;
    if ( v20 )
      p_npcImpactSounds = &cgMedia.playerImpactSounds;
    v46 = BG_WeaponDef(weapon, isAlternate);
    *outSnd = NULL;
    impactType = CG_Weapons_GetVFXImpactType(localClientNum, sourceEntityNum, weapon, isAlternate);
    SfxPackage = BG_GetSfxPackage(weapon, isAlternate);
    fxImpactType = CG_Main_RegisteredImpactTypeToImpactType(UNKNOWN);
    if ( SfxPackage )
      fxImpactType = SfxPackage->sfxImpactType;
    CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, &fxImpactType);
    v23 = NULL;
    v24 = !v20;
    ImpactSoundHitLocation = SND_NPC_HITLOC_HM_BODY;
    ImpactEffectHitLocation = FX_FLESHTYPE_BODY_NONFATAL;
    if ( surfType == 7 )
    {
      ImpactEffectHitLocation = CG_GetImpactEffectHitLocation(localClientNum, targetEntityNuma, impactFlags);
      ImpactSoundHitLocation = CG_GetImpactSoundHitLocation(localClientNum, targetEntityNuma, impactFlags);
    }
    switch ( CG_Main_ImpactTypeToRegisteredImpactType(fxImpactType) )
    {
      case 1:
      case 2:
      case 18:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          bulletExitSmallSound = p_npcImpactSounds->bulletExitSmallSound;
        else
          bulletExitSmallSound = p_npcImpactSounds->bulletHitSmallSound;
        *outSnd = bulletExitSmallSound;
        v23 = cgMedia.fleshBulletSmall.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 3:
      case 4:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          bulletExitLargeSound = p_npcImpactSounds->bulletExitLargeSound;
        else
          bulletExitLargeSound = p_npcImpactSounds->bulletHitLargeSound;
        *outSnd = bulletExitLargeSound;
        v23 = cgMedia.fleshBulletLarge.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 5:
        *outSnd = p_npcImpactSounds->bulletExplodeSound;
        v23 = cgMedia.fleshBulletExplode.npc[ImpactSoundHitLocation][v24][hitArmorType];
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 6:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          shotgunExitSound = p_npcImpactSounds->shotgunExitSound;
        else
          shotgunExitSound = p_npcImpactSounds->shotgunHitSound;
        *outSnd = shotgunExitSound;
        v23 = cgMedia.fleshShotgun.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 7:
        *outSnd = p_npcImpactSounds->bulletExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 9:
        v30 = v46->sfxPackage;
        if ( v30 )
          *outSnd = SND_FindAlias(v30->sounds->bounceSound.name);
        goto LABEL_60;
      case 10:
        *outSnd = cgMedia.grenadeExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 11:
        *outSnd = cgMedia.grenadeExplodeSoundSmall;
        goto LABEL_60;
      case 12:
        *outSnd = cgMedia.rocketExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 13:
        *outSnd = cgMedia.rocketExplodeSoundSmall;
        goto LABEL_60;
      case 14:
        v31 = isAlternate;
        v32 = weapon;
        v26 = (impactFlags & 4) != 0;
        *outSnd = BG_ProjDudSound(weapon, isAlternate);
        goto LABEL_62;
      case 15:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          vehBulletExitMediumSound = p_npcImpactSounds->vehBulletExitMediumSound;
        else
          vehBulletExitMediumSound = p_npcImpactSounds->vehBulletHitMediumSound;
        *outSnd = vehBulletExitMediumSound;
        v23 = cgMedia.fleshVehBullet.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 16:
        *outSnd = p_npcImpactSounds->vehBulletExplodeSound;
        v23 = cgMedia.fleshVehBulletExplode.npc[ImpactSoundHitLocation][v24][hitArmorType];
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 17:
        *outSnd = cgMedia.vehMissileExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 19:
        *outSnd = p_npcImpactSounds->arcaneRedSound;
        v23 = cgMedia.fleshArcaneRed.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 21:
        *outSnd = p_npcImpactSounds->arcaneYellowSound;
        v23 = cgMedia.fleshArcaneYellow.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 22:
        *outSnd = p_npcImpactSounds->arcanePinkSound;
        v23 = cgMedia.fleshArcanePink.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 23:
        *outSnd = p_npcImpactSounds->arcaneBlueSound;
        v23 = cgMedia.fleshArcaneBlue.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 24:
        *outSnd = cgMedia.waterSound;
        goto LABEL_60;
      case 25:
        *outSnd = p_npcImpactSounds->rock1Sound;
        v23 = cgMedia.fleshRock1.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 26:
        *outSnd = p_npcImpactSounds->rock2Sound;
        v23 = cgMedia.fleshRock2.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 27:
        *outSnd = p_npcImpactSounds->rock3Sound;
        v23 = cgMedia.fleshRock3.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 28:
        *outSnd = p_npcImpactSounds->rock4Sound;
        v23 = cgMedia.fleshRock4.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 29:
        *outSnd = p_npcImpactSounds->dlc1Sound;
        v23 = cgMedia.fleshDLC1.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 30:
        *outSnd = p_npcImpactSounds->dlc2Sound;
        v23 = cgMedia.fleshDLC2.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 31:
        *outSnd = p_npcImpactSounds->dlc3Sound;
        v23 = cgMedia.fleshDLC3.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 32:
        *outSnd = p_npcImpactSounds->dlc4Sound;
        v23 = cgMedia.fleshDLC4.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      default:
LABEL_60:
        v26 = (impactFlags & 4) != 0;
LABEL_61:
        v32 = weapon;
        v31 = isAlternate;
LABEL_62:
        if ( (impactFlags & 0x800) != 0 )
        {
          WeaponSoundWithFallback = BG_GetWeaponSoundWithFallback(v32, v31, 624i64);
          *outSnd = WeaponSoundWithFallback;
          if ( !WeaponSoundWithFallback )
          {
            BG_GetWeaponNameComplete(v32, v31, output, 0x400u);
            Com_PrintError(9, "Ricochet Impact sound alias not defined for weapon '%s'\n", output);
          }
        }
        if ( (impactFlags & 0x10) != 0 )
        {
          *outSnd = NULL;
        }
        else
        {
          v35 = surfType == 7;
          if ( surfType != 7 )
            goto LABEL_80;
          if ( v23 )
          {
            if ( !v26 )
            {
              v36 = targetEntityNuma;
              if ( targetEntityNuma != 2047 )
              {
                if ( v44 >= 0x800 )
                {
                  LODWORD(v38) = v44;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20255, ASSERT_TYPE_ASSERT, "(unsigned)( sourceEntityNum ) < (unsigned)( ( 2048 ) )", "sourceEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v38, 2048) )
                    __debugbreak();
                }
                if ( v36 >= 0x800 )
                {
                  LODWORD(v39) = 2048;
                  LODWORD(v38) = v36;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20256, ASSERT_TYPE_ASSERT, "(unsigned)( targetEntityNum ) < (unsigned)( ( 2048 ) )", "targetEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v38, v39) )
                    __debugbreak();
                }
                if ( !CG_IsPlayerEntityNumber(ps, v36) )
                  *outSnd = v23;
              }
            }
          }
        }
        v35 = surfType == 7;
LABEL_80:
        v37 = ImpactEffectHitLocation;
        if ( surfType != 7 )
          v37 = surfType;
        CG_GetImpactEffectList(impactType, v37, v35, v26, (impactFlags & 8) != 0, v45);
        break;
    }
  }
}

/*
==============
CG_GetImpactEffectHitLocation
==============
*/
__int64 CG_GetImpactEffectHitLocation(LocalClientNum_t localClientNum, const int targetEntityNum, const int impactFlags)
{
  centity_t *Entity; 
  const entityState_t *p_nextState; 
  const DObj *ClientDObj; 
  const XModel *Model; 
  ImpactEffectType impactType; 
  __int64 result; 
  int v12; 
  int v13; 
  int v14; 
  unsigned int v15; 

  Entity = CG_GetEntity(localClientNum, targetEntityNum);
  if ( (Entity->flags & 1) == 0 )
    goto LABEL_31;
  p_nextState = &Entity->nextState;
  if ( !BG_IsCharacterEntity(&Entity->nextState) && !BG_IsPlayerOrAgentCorpseEntity(p_nextState) )
    goto LABEL_31;
  ClientDObj = Com_GetClientDObj(targetEntityNum, localClientNum);
  if ( !ClientDObj )
    goto LABEL_31;
  Model = DObjGetModel(ClientDObj, 0);
  if ( !Model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19798, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  impactType = Model->impactType;
  switch ( impactType )
  {
    case IMPACT_EFFECT_TYPE_SMALL_ROBOT:
      if ( (impactFlags & 0x80u) != 0 )
        return 15i64;
      v12 = 0;
      v13 = impactFlags & 2;
      if ( (impactFlags & 1) != 0 )
      {
        LOBYTE(v12) = v13 != 0;
        return (unsigned int)(v12 + 9);
      }
      else
      {
        LOBYTE(v12) = v13 != 0;
        if ( (impactFlags & 0x40) != 0 )
          return (unsigned int)(v12 + 11);
        else
          return (unsigned int)(v12 + 13);
      }
    case IMPACT_EFFECT_TYPE_LARGE_ROBOT:
      if ( (impactFlags & 0x80u) != 0 )
        return 22i64;
      v14 = impactFlags & 2;
      if ( (impactFlags & 1) != 0 )
        return (v14 | 0x20u) >> 1;
      if ( (impactFlags & 0x40) != 0 )
        v15 = v14 | 0x24;
      else
        v15 = v14 | 0x28;
      return v15 >> 1;
    case IMPACT_EFFECT_TYPE_ALIEN:
      if ( (impactFlags & 2) != 0 )
      {
        return 7i64;
      }
      else
      {
        result = 6i64;
        if ( (impactFlags & 0x20) != 0 )
          return 8i64;
      }
      break;
    default:
LABEL_31:
      if ( (impactFlags & 0x400) != 0 )
      {
        return (impactFlags & 2 | 8u) >> 1;
      }
      else if ( (impactFlags & 1) != 0 )
      {
        return (impactFlags & 2 | 4u) >> 1;
      }
      else
      {
        result = ((unsigned int)impactFlags >> 1) & 1;
        if ( (impactFlags & 0x20) != 0 )
          return 8i64;
      }
      break;
  }
  return result;
}

/*
==============
CG_GetImpactEffectList
==============
*/
void CG_GetImpactEffectList(int impactType, int surfaceType, bool isFlesh, bool isExit, bool isNoImpact, FXRegisteredDef *outFx)
{
  __int64 v6; 
  __int64 v7; 
  bool v8; 
  __int64 v9; 
  __int64 v11; 
  __int64 v12; 
  const ParticleSystemDef *particleSystemDef; 
  FxImpactPack *exit; 
  __int64 v15; 
  __int64 v16; 

  v6 = 0i64;
  v7 = surfaceType;
  v8 = isExit;
  v9 = impactType;
  outFx->m_particleSystemDef = NULL;
  outFx[1].m_particleSystemDef = NULL;
  if ( impactType >= 0 && !isNoImpact && cgMedia.impactFx )
  {
    if ( !cgMedia.impactFx->table && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20022, ASSERT_TYPE_ASSERT, "(cgMedia.impactFx->table)", (const char *)&queryFormat, "cgMedia.impactFx->table") )
      __debugbreak();
    v11 = v7;
    do
    {
      if ( (unsigned int)v9 >= cgMedia.impactFx->impactTypeCount )
      {
        LODWORD(v16) = cgMedia.impactFx->impactTypeCount;
        LODWORD(v15) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20025, ASSERT_TYPE_ASSERT, "(unsigned)( impactType ) < (unsigned)( cgMedia.impactFx->impactTypeCount )", "impactType doesn't index cgMedia.impactFx->impactTypeCount\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      if ( v8 && (v12 = v9, cgMedia.impactFx->table[v9].exit) )
      {
        if ( isFlesh )
        {
          if ( (unsigned int)v7 >= 0x17 )
          {
            LODWORD(v16) = 23;
            LODWORD(v15) = v7;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20030, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( FX_FLESHTYPE_COUNT )", "surfaceType doesn't index FX_FLESHTYPE_COUNT\n\t%i not in [0, %i)", v15, v16) )
              __debugbreak();
          }
          particleSystemDef = cgMedia.impactFx->table[v12].exit->flesh[v11].particleSystemDef;
          goto LABEL_32;
        }
        if ( (unsigned int)v7 >= 0x40 )
        {
          LODWORD(v16) = 64;
          LODWORD(v15) = v7;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20035, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( 64 )", "surfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", v15, v16) )
            __debugbreak();
        }
        exit = cgMedia.impactFx->table[v12].exit;
      }
      else
      {
        if ( isFlesh )
        {
          if ( (unsigned int)v7 >= 0x17 )
          {
            LODWORD(v16) = 23;
            LODWORD(v15) = v7;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20043, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( FX_FLESHTYPE_COUNT )", "surfaceType doesn't index FX_FLESHTYPE_COUNT\n\t%i not in [0, %i)", v15, v16) )
              __debugbreak();
          }
          particleSystemDef = cgMedia.impactFx->table[v9].normal->flesh[v11].particleSystemDef;
          goto LABEL_32;
        }
        if ( (unsigned int)v7 >= 0x40 )
        {
          LODWORD(v16) = 64;
          LODWORD(v15) = v7;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20048, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( 64 )", "surfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", v15, v16) )
            __debugbreak();
        }
        exit = cgMedia.impactFx->table[v9].normal;
      }
      particleSystemDef = exit->nonflesh[v11].particleSystemDef;
LABEL_32:
      outFx[v6].m_particleSystemDef = particleSystemDef;
      v8 = isExit;
      ++v6;
      v11 += 87i64;
    }
    while ( v6 < 2 );
  }
}

/*
==============
CG_GetImpactSoundHitLocation
==============
*/
int CG_GetImpactSoundHitLocation(LocalClientNum_t localClientNum, const int targetEntityNum, const unsigned int impactFlags)
{
  centity_t *Entity; 
  const entityState_t *p_nextState; 
  const DObj *ClientDObj; 
  const XModel *Model; 
  ImpactEffectType impactType; 
  int v11; 

  Entity = CG_GetEntity(localClientNum, targetEntityNum);
  if ( (Entity->flags & 1) != 0 )
  {
    p_nextState = &Entity->nextState;
    if ( BG_IsCharacterEntity(&Entity->nextState) || BG_IsPlayerOrAgentCorpseEntity(p_nextState) )
    {
      ClientDObj = Com_GetClientDObj(targetEntityNum, localClientNum);
      if ( ClientDObj )
      {
        Model = DObjGetModel(ClientDObj, 0);
        if ( !Model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19701, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
          __debugbreak();
        impactType = Model->impactType;
        switch ( impactType )
        {
          case IMPACT_EFFECT_TYPE_SMALL_ROBOT:
            if ( (impactFlags & 0x80u) == 0 )
            {
              if ( (impactFlags & 1) != 0 )
                v11 = 7;
              else
                v11 = ((impactFlags & 0x40) != 0) + 5;
            }
            else
            {
              v11 = 8;
            }
            return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
          case IMPACT_EFFECT_TYPE_LARGE_ROBOT:
            if ( (impactFlags & 0x80u) == 0 )
            {
              if ( (impactFlags & 1) != 0 )
                v11 = 11;
              else
                v11 = ((impactFlags & 0x40) != 0) + 9;
            }
            else
            {
              v11 = 12;
            }
            return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
          case IMPACT_EFFECT_TYPE_ALIEN:
            v11 = 0;
            return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
        }
      }
    }
  }
  if ( (impactFlags & 0x80u) == 0 )
  {
    if ( (impactFlags & 0x400) != 0 )
    {
      v11 = 2;
    }
    else if ( (impactFlags & 1) != 0 )
    {
      v11 = 3;
    }
    else
    {
      v11 = ((unsigned __int8)impactFlags >> 6) & 1;
    }
  }
  else
  {
    v11 = 4;
  }
  return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
}

/*
==============
CG_GetLocalClientGlobalsForEnt
==============
*/
cg_t *CG_GetLocalClientGlobalsForEnt(int entityNum)
{
  unsigned int v1; 
  cg_t **v3; 
  connstate_t *i; 
  cg_t *v5; 
  const playerState_s *p_predictedPlayerState; 
  __int64 v8; 
  __int64 v9; 

  v1 = 0;
  if ( SLODWORD(cl_maxLocalClients) <= 0 )
    return 0i64;
  v3 = cg_t::ms_cgArray;
  for ( i = &clientUIActives[0].connectionState; ; i += 110 )
  {
    if ( v1 >= 2 )
    {
      LODWORD(v9) = 2;
      LODWORD(v8) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v8, v9) )
        __debugbreak();
    }
    if ( *i == CA_ACTIVE )
    {
      if ( v1 >= cg_t::ms_allocatedCount )
      {
        LODWORD(v9) = cg_t::ms_allocatedCount;
        LODWORD(v8) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1166, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( cg_t::ms_allocatedCount )", "localClientNum doesn't index cg_t::ms_allocatedCount\n\t%i not in [0, %i)", v8, v9) )
          __debugbreak();
      }
      if ( !*v3 )
      {
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", v9) )
          __debugbreak();
      }
      if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
      {
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", v9) )
          __debugbreak();
      }
      v5 = *v3;
      p_predictedPlayerState = &(*v3)->predictedPlayerState;
      if ( *v3 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 128, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (BG_IsPlayer(p_predictedPlayerState) || BG_IsAgent(p_predictedPlayerState) || BG_IsSpectating(p_predictedPlayerState)) && entityNum == p_predictedPlayerState->clientNum )
        break;
    }
    ++v1;
    ++v3;
    if ( (int)v1 >= SLODWORD(cl_maxLocalClients) )
      return 0i64;
  }
  return v5;
}

/*
==============
CG_GetTracerSpeed
==============
*/
float CG_GetTracerSpeed(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  TracerDef *tracerDefault; 

  tracerDefault = BG_TracerType(perks, r_weapon, isAlternate);
  if ( !tracerDefault )
  {
    tracerDefault = cgMedia.tracerDefault;
    if ( !cgMedia.tracerDefault && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19987, ASSERT_TYPE_ASSERT, "(tracerDef)", (const char *)&queryFormat, "tracerDef") )
      __debugbreak();
  }
  if ( tracerDefault->speed <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19988, ASSERT_TYPE_ASSERT, "(tracerDef->speed > 0.0f)", (const char *)&queryFormat, "tracerDef->speed > 0.0f") )
    __debugbreak();
  if ( tracerDefault->fadeOverTime )
    return FLOAT_3_4028235e38;
  else
    return tracerDefault->speed;
}

/*
==============
CG_GetViewDirection
==============
*/
char CG_GetViewDirection(LocalClientNum_t localClientNum, int entityNum, vec3_t *outForward, vec3_t *outRight, vec3_t *outUp)
{
  vec3_t *v5; 
  unsigned int v6; 
  cg_t **v10; 
  connstate_t *p_connectionState; 
  cg_t *v12; 
  const playerState_s *p_predictedPlayerState; 
  CgStatic *LocalClientStatics; 
  CgHandler *Handler; 
  __int64 ignoreArbitraryUp; 
  __int64 v18; 
  vec3_t angles; 

  v5 = outUp;
  v6 = 0;
  if ( SLODWORD(cl_maxLocalClients) <= 0 )
  {
LABEL_25:
    LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
    if ( LocalClientStatics->GetCharacterAngles(LocalClientStatics, entityNum, &angles) )
    {
      AngleVectors(&angles, outForward, outRight, v5);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v10 = cg_t::ms_cgArray;
    p_connectionState = &clientUIActives[0].connectionState;
    while ( 1 )
    {
      if ( v6 >= 2 )
      {
        LODWORD(v18) = 2;
        LODWORD(ignoreArbitraryUp) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", ignoreArbitraryUp, v18) )
          __debugbreak();
      }
      if ( *p_connectionState == CA_ACTIVE )
      {
        if ( v6 >= cg_t::ms_allocatedCount )
        {
          LODWORD(v18) = cg_t::ms_allocatedCount;
          LODWORD(ignoreArbitraryUp) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1166, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( cg_t::ms_allocatedCount )", "localClientNum doesn't index cg_t::ms_allocatedCount\n\t%i not in [0, %i)", ignoreArbitraryUp, v18) )
            __debugbreak();
        }
        if ( !*v10 )
        {
          LODWORD(v18) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", v18) )
            __debugbreak();
        }
        if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
        {
          LODWORD(v18) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", v18) )
            __debugbreak();
        }
        v12 = *v10;
        p_predictedPlayerState = &(*v10)->predictedPlayerState;
        if ( *v10 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 128, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        if ( (BG_IsPlayer(p_predictedPlayerState) || BG_IsAgent(p_predictedPlayerState) || BG_IsSpectating(p_predictedPlayerState)) && entityNum == p_predictedPlayerState->clientNum )
          break;
      }
      ++v6;
      p_connectionState += 110;
      ++v10;
      if ( (int)v6 >= SLODWORD(cl_maxLocalClients) )
        goto LABEL_24;
    }
    if ( !v12 )
    {
LABEL_24:
      v5 = outUp;
      goto LABEL_25;
    }
    Handler = CgHandler::getHandler(localClientNum);
    BG_GetPlayerViewDirection(p_predictedPlayerState, outForward, outRight, outUp, Handler, 0);
    return 1;
  }
}

/*
==============
CG_GetViewModelPoseForHand
==============
*/
cpose_t *CG_GetViewModelPoseForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  __int64 v4; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v4 = 303328i64;
  if ( hand )
    v4 = 303616i64;
  return (cpose_t *)((char *)LocalClientGlobals + v4);
}

/*
==============
CG_GetWeapFireSound
==============
*/
SndAliasList *CG_GetWeapFireSound(const WeaponSFXPackage *sfxPackage, bool isPlayerView, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, PlayerHandIndex hand, const SndWeapShotCountId shotCount)
{
  WeaponSFXPackageSounds *sounds; 
  const char *name; 
  const char *v12; 
  __int64 v13; 
  const char *v14; 
  const char *v15; 
  __int64 v16; 
  const char *v17; 
  const char *v18; 
  __int64 v19; 
  const char *v20; 
  SndAliasList *result; 
  const dvar_t *v22; 

  if ( !sfxPackage )
    return 0i64;
  sounds = sfxPackage->sounds;
  name = sounds->fireSound.name;
  if ( isPlayerView || isPlayerHeli )
  {
    v12 = sounds->fireSoundPlayer.name;
    if ( !v12 )
      v12 = sounds->fireSound.name;
    name = v12;
    if ( isDualWield )
    {
      v13 = 112i64;
      if ( hand != WEAPON_HAND_LEFT )
        v13 = 120i64;
      v14 = *(const char **)((char *)&sounds->name + v13);
      if ( v14 )
        name = v14;
    }
  }
  if ( useLastFireSound )
  {
    v15 = (const char *)*((_QWORD *)&sounds->fireLastSound.name + isPlayerView);
    if ( !v15 )
      v15 = name;
    name = v15;
    if ( isPlayerView && isDualWield )
    {
      v16 = 288i64;
      if ( hand != WEAPON_HAND_LEFT )
        v16 = 296i64;
      v17 = *(const char **)((char *)&sounds->name + v16);
      if ( v17 )
        name = v17;
    }
  }
  else if ( shotCount == SND_WEAP_SHOT_FIRST )
  {
    v18 = (const char *)*((_QWORD *)&sounds->fireFirstSound.name + isPlayerView);
    if ( !v18 )
      v18 = name;
    name = v18;
    if ( isPlayerView && isDualWield )
    {
      v19 = 224i64;
      if ( hand != WEAPON_HAND_LEFT )
        v19 = 232i64;
      v20 = *(const char **)((char *)&sounds->name + v19);
      if ( v20 )
        name = v20;
    }
  }
  if ( !name )
    return 0i64;
  result = SND_TryFindAlias(name);
  if ( !result )
  {
    v22 = DCONST_DVARBOOL_snd_bankDetailStreamingFallback;
    if ( !DCONST_DVARBOOL_snd_bankDetailStreamingFallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_bankDetailStreamingFallback") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v22);
    if ( v22->current.enabled )
    {
      if ( sfxPackage->transientFallbackPackage == sfxPackage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18726, ASSERT_TYPE_ASSERT, "(sfxPackage->transientFallbackPackage != sfxPackage)", (const char *)&queryFormat, "sfxPackage->transientFallbackPackage != sfxPackage") )
        __debugbreak();
      return (SndAliasList *)CG_GetWeapFireSound(sfxPackage->transientFallbackPackage, isPlayerView, isPlayerHeli, isDualWield, useLastFireSound, hand, shotCount);
    }
    else
    {
      SND_Missing(name);
      return 0i64;
    }
  }
  return result;
}

/*
==============
CG_GetWeapHyperBurstFireSound
==============
*/
SndAliasList *CG_GetWeapHyperBurstFireSound(const WeaponSFXPackage *sfxPackage, bool isPlayerView, bool isDualWield, PlayerHandIndex hand)
{
  WeaponSFXPackageSounds *sounds; 
  const char *name; 
  __int64 v10; 
  const char *v11; 
  SndAliasList *result; 
  const dvar_t *v13; 

  if ( !sfxPackage )
    return 0i64;
  sounds = sfxPackage->sounds;
  if ( isPlayerView )
  {
    name = sounds->fireHyperBurstSoundPlayer.name;
    if ( isDualWield )
    {
      v10 = 256i64;
      if ( hand != WEAPON_HAND_LEFT )
        v10 = 264i64;
      v11 = *(const char **)((char *)&sounds->name + v10);
      if ( v11 )
        name = v11;
    }
  }
  else
  {
    name = sounds->fireHyperBurstSound.name;
  }
  if ( !name )
    return 0i64;
  result = SND_TryFindAlias(name);
  if ( !result )
  {
    v13 = DCONST_DVARBOOL_snd_bankDetailStreamingFallback;
    if ( !DCONST_DVARBOOL_snd_bankDetailStreamingFallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_bankDetailStreamingFallback") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    if ( v13->current.enabled )
    {
      if ( sfxPackage->transientFallbackPackage == sfxPackage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18633, ASSERT_TYPE_ASSERT, "(sfxPackage->transientFallbackPackage != sfxPackage)", (const char *)&queryFormat, "sfxPackage->transientFallbackPackage != sfxPackage") )
        __debugbreak();
      return (SndAliasList *)CG_GetWeapHyperBurstFireSound(sfxPackage->transientFallbackPackage, isPlayerView, isDualWield, hand);
    }
    else
    {
      SND_Missing(name);
      return 0i64;
    }
  }
  return result;
}

/*
==============
CG_GetWeaponAnim
==============
*/
XAnimParts *CG_GetWeaponAnim(XAnimParts *const *animArray, int animIndex)
{
  __int64 v2; 
  XAnimParts *result; 

  v2 = animIndex;
  if ( (unsigned int)animIndex >= 0x260 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9088, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", animIndex, 608) )
    __debugbreak();
  result = animArray[v2];
  if ( !result )
  {
    result = BG_GetGameDefaultWeaponAnim(v2);
    if ( !result )
    {
      if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
        __debugbreak();
      return (XAnimParts *)*((_QWORD *)animArray + 236);
    }
  }
  return result;
}

/*
==============
CG_GetWeaponAnimTime
==============
*/
double CG_GetWeaponAnimTime(LocalClientNum_t localClientNum, PlayerHandIndex handIndex, weapAnimFiles_t animFile)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  const DObj **p_viewModelDObj; 
  const DObj *v7; 
  const XAnimTree *Tree; 
  double Weight; 
  double result; 

  v4 = handIndex;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v4 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v4, 2) )
    __debugbreak();
  p_viewModelDObj = (const DObj **)&LocalClientGlobals->m_weaponHand[v4].viewModelDObj;
  if ( !p_viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15581, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  v7 = *p_viewModelDObj;
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15583, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(v7);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15586, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, animFile);
  if ( *(float *)&Weight != 0.0 )
    return XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, animFile);
  *(_QWORD *)&result = LODWORD(FLOAT_N1_0);
  return result;
}

/*
==============
CG_GetWeaponAnimTimeRemaining
==============
*/
float CG_GetWeaponAnimTimeRemaining(XAnimTree *animTree, weapAnimFiles_t weaponAnimFile)
{
  double Weight; 
  double Length; 
  float v6; 
  double Rate; 
  float v8; 
  double Time; 
  __int128 v10; 

  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6376, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( XAnimIsLooped(animTree->anims, weaponAnimFile) || (Weight = XAnimGetWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, weaponAnimFile), *(float *)&Weight <= 0.0) )
  {
    LODWORD(_XMM0) = 0;
  }
  else
  {
    Length = XAnimGetLength(animTree->anims, weaponAnimFile);
    v6 = *(float *)&Length;
    Rate = XAnimGetRate(animTree, 0, XANIM_SUBTREE_DEFAULT, weaponAnimFile);
    v8 = *(float *)&Rate * v6;
    Time = XAnimGetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, weaponAnimFile);
    v10 = LODWORD(FLOAT_1_0);
    *(float *)&v10 = (float)(1.0 - *(float *)&Time) * v8;
    _XMM2 = v10;
    __asm { vmaxss  xmm0, xmm2, xmm7 }
  }
  return *(float *)&_XMM0;
}

/*
==============
CG_GetWeaponDisplayName
==============
*/
char *CG_GetWeaponDisplayName(const Weapon *weapon, bool isAlternate, char *outputBuffer, unsigned __int64 bufferLen, bool isNewlineSpacer)
{
  Weapon *AltWeapon; 
  unsigned __int8 weaponLootId; 
  unsigned __int64 v12; 
  unsigned int v13; 
  bool v14; 
  bool v15; 
  unsigned int AllWeaponAttachments; 
  unsigned int v17; 
  unsigned int v18; 
  WeaponAttachment **v19; 
  WeaponAttachment *v20; 
  const char *szDisplayName; 
  AttAddOns *addOns; 
  AttSight *sight; 
  AttADSSettings *adsSettings; 
  AttADSSettings *adsSettingsMain; 
  const dvar_t *v26; 
  unsigned int unsignedInt; 
  const char *v28; 
  const char *LootVariantDisplayName; 
  Weapon *v30; 
  const WeaponCompleteDef *v31; 
  const dvar_t *v32; 
  const dvar_t *v33; 
  unsigned int v34; 
  WeaponAttachment **v35; 
  const char *v36; 
  const char *String; 
  const char *v38; 
  const char *v39; 
  char *v40; 
  const char *v41; 
  WeaponAttachment **v42; 
  unsigned __int64 v43; 
  __int64 v44; 
  const char *v45; 
  __int64 v46; 
  const char *v47; 
  char v48; 
  int IsRightToLeft; 
  unsigned __int64 v50; 
  unsigned __int64 v51; 
  const char *v52; 
  char *v53; 
  char *v54; 
  unsigned __int64 v55; 
  char v56; 
  __int64 v57; 
  bool v58; 
  AttachmentSlot slot[2]; 
  bool v60; 
  unsigned __int64 destsize; 
  unsigned int v62; 
  char *dest; 
  Weapon *r_weapon; 
  WeaponAttachment *attachments[30]; 
  char text[1024]; 

  v60 = isNewlineSpacer;
  destsize = bufferLen;
  dest = outputBuffer;
  if ( !outputBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22358, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
    __debugbreak();
  if ( !bufferLen && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22359, ASSERT_TYPE_ASSERT, "(bufferLen > 0)", (const char *)&queryFormat, "bufferLen > 0") )
    __debugbreak();
  if ( !weapon->weaponIdx )
  {
    *outputBuffer = 0;
    return outputBuffer;
  }
  if ( isAlternate )
    AltWeapon = (Weapon *)BG_GetAltWeapon(weapon);
  else
    AltWeapon = (Weapon *)weapon;
  weaponLootId = AltWeapon->weaponLootId;
  v12 = 0i64;
  r_weapon = AltWeapon;
  if ( weaponLootId )
  {
    v13 = weaponLootId - 1;
    v62 = v13;
  }
  else
  {
    v13 = 0;
    v62 = 0;
  }
  v58 = v13 != 0;
  v14 = 0;
  if ( !isAlternate )
  {
    slot[0] = ATT_SLOT_UNDERBARREL;
    if ( BG_Weapon_GetPrimaryAttachmentIndex(weapon, slot) )
      v14 = 1;
  }
  slot[0] = ATT_SLOT_SCOPE;
  v15 = BG_Weapon_GetPrimaryAttachmentIndex(AltWeapon, slot) != 0;
  AllWeaponAttachments = BG_GetAllWeaponAttachments(weapon, (const WeaponAttachment **)attachments);
  v17 = AllWeaponAttachments;
  if ( AllWeaponAttachments > 0x1D )
  {
    LODWORD(v57) = AllWeaponAttachments;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22246, ASSERT_TYPE_ASSERT, "( attachmentCount ) <= ( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount not in [0, MAX_NUM_WEAPON_ATTACHMENTS]\n\t%u not in [0, %u]", v57, 29) )
      __debugbreak();
  }
  v18 = 0;
  if ( v17 )
  {
    do
    {
      v19 = &attachments[v18];
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22253, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v20 = *v19;
      szDisplayName = (*v19)->szDisplayName;
      if ( !szDisplayName || !*szDisplayName || v14 && v20->type == ATTACHMENT_UNDERBARREL && (addOns = v20->addOns) != NULL && addOns->silenced || v15 && (sight = v20->sight) != NULL && sight->hideRailWithThisScope && ((adsSettings = v20->adsSettings) == NULL || adsSettings->zoomSettings.scene.adsZoomCount <= 1) && ((adsSettingsMain = v20->adsSettingsMain) == NULL || adsSettingsMain->zoomSettings.scene.adsZoomCount <= 1) )
        v17 = CG_RemoveAttachmentFromList(v18, (const WeaponAttachment **)attachments, v17);
      else
        ++v18;
    }
    while ( v18 < v17 );
    v13 = v62;
    v12 = 0i64;
    AltWeapon = r_weapon;
  }
  v26 = DCONST_DVARMPSPINT_cg_maxAttachmentDisplays;
  if ( !DCONST_DVARMPSPINT_cg_maxAttachmentDisplays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_maxAttachmentDisplays") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v26);
  unsignedInt = v26->current.unsignedInt;
  if ( v58 )
  {
    LootVariantDisplayName = CG_Weapons_GetLootVariantDisplayName(AltWeapon, v13);
    *(_QWORD *)slot = LootVariantDisplayName;
  }
  else
  {
    v34 = 0;
    if ( !v17 )
      goto LABEL_49;
    v35 = attachments;
    while ( 1 )
    {
      if ( (*v35)->overrideDisplayName )
      {
        if ( !*v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22395, ASSERT_TYPE_ASSERT, "(attachments[i])", (const char *)&queryFormat, "attachments[i]") )
          __debugbreak();
        v36 = (*v35)->szDisplayName;
        if ( !v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22397, ASSERT_TYPE_ASSERT, "(attachmentNameRef)", (const char *)&queryFormat, "attachmentNameRef") )
          __debugbreak();
        if ( !*v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22398, ASSERT_TYPE_ASSERT, "(attachmentNameRef[0])", (const char *)&queryFormat, "attachmentNameRef[0]") )
          __debugbreak();
        String = SEH_StringEd_GetString(v36);
        *(_QWORD *)slot = String;
        LootVariantDisplayName = String;
        if ( String )
        {
          if ( *String )
            break;
        }
      }
      ++v34;
      ++v35;
      if ( v34 >= v17 )
        goto LABEL_49;
    }
  }
  if ( LootVariantDisplayName )
    goto LABEL_82;
LABEL_49:
  v30 = r_weapon;
  v31 = BG_WeaponCompleteDef(r_weapon, 0);
  *(_QWORD *)slot = SEH_StringEd_GetString(v31->szDisplayName);
  LootVariantDisplayName = *(const char **)slot;
  if ( *(_QWORD *)slot )
  {
LABEL_79:
    if ( !LootVariantDisplayName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22415, ASSERT_TYPE_ASSERT, "(baseWeaponName)", (const char *)&queryFormat, "baseWeaponName") )
      __debugbreak();
    goto LABEL_82;
  }
  v32 = DCONST_DVARBOOL_loc_warnings;
  if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v32);
  if ( v32->current.enabled )
  {
    v33 = DCONST_DVARBOOL_loc_warningsAsErrors;
    if ( !DCONST_DVARBOOL_loc_warningsAsErrors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warningsAsErrors") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v33);
    if ( v33->current.enabled )
      Com_Error_impl(ERR_LOCALIZATION, (const ObfuscateErrorText)&stru_1442E0B10, 618i64, v30->weaponIdx, v31->szDisplayName);
    else
      Com_PrintWarning(17, "WARNING: Weapon %d: Could not translate display name \"%s\"\n", v30->weaponIdx, v31->szDisplayName);
  }
  LootVariantDisplayName = v31->szDisplayName;
  *(_QWORD *)slot = LootVariantDisplayName;
  if ( !LootVariantDisplayName )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22213, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
      __debugbreak();
    goto LABEL_79;
  }
LABEL_82:
  if ( v17 <= unsignedInt )
  {
    v41 = " ";
    if ( v60 )
      v41 = "\n";
    if ( v58 || !v17 )
    {
      v48 = 0;
    }
    else
    {
      v42 = attachments;
      v43 = 0i64;
      v44 = v17;
      do
      {
        if ( !(*v42)->overrideDisplayName )
        {
          if ( !*v42 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22444, ASSERT_TYPE_ASSERT, "(attachments[i])", (const char *)&queryFormat, "attachments[i]") )
            __debugbreak();
          v45 = (*v42)->szDisplayName;
          if ( !v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22446, ASSERT_TYPE_ASSERT, "(attachmentNameRef)", (const char *)&queryFormat, "attachmentNameRef") )
            __debugbreak();
          if ( !*v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22447, ASSERT_TYPE_ASSERT, "(attachmentNameRef[0])", (const char *)&queryFormat, "attachmentNameRef[0]") )
            __debugbreak();
          v28 = SEH_StringEd_GetString(v45);
          if ( v28 )
          {
            v46 = -1i64;
            do
              ++v46;
            while ( v28[v46] );
            if ( v46 )
            {
              if ( v43 && *v41 )
              {
                v47 = &v41[-v43];
                do
                {
                  if ( v43 >= 0x3FF )
                    break;
                  text[v43] = v47[v43];
                  ++v43;
                }
                while ( v47[v43] );
              }
              if ( *v28 )
              {
                v28 -= v43;
                do
                {
                  if ( v43 >= 0x3FF )
                    break;
                  text[v43] = v28[v43];
                  ++v43;
                }
                while ( v28[v43] );
              }
            }
          }
        }
        ++v42;
        --v44;
      }
      while ( v44 );
      LootVariantDisplayName = *(const char **)slot;
      v12 = 0i64;
      if ( v43 >= 0x400 )
      {
        j___report_rangecheckfailure(v28);
        JUMPOUT(0x141DD92A7i64);
      }
      text[v43] = 0;
      v48 = 1;
      R_TextValidatePrintable(text);
    }
    *(_QWORD *)slot = 0i64;
    IsRightToLeft = Language_IsRightToLeft();
    v40 = dest;
    if ( IsRightToLeft )
    {
      if ( v48 )
      {
        v54 = text;
        if ( dest || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22334, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
        {
          v55 = destsize;
        }
        else
        {
          __debugbreak();
          v55 = destsize;
        }
        if ( text[0] )
        {
          do
          {
            if ( v12 >= v55 - 1 )
              break;
            v56 = *v54++;
            v40[v12++] = v56;
            *(_QWORD *)slot = v12;
          }
          while ( *v54 );
        }
      }
      else
      {
        v55 = destsize;
      }
      CG_AppendNameToBuffer(v41, LootVariantDisplayName, (unsigned __int64 *)slot, v55, v40);
    }
    else
    {
      v50 = destsize;
      CG_AppendNameToBuffer(v41, LootVariantDisplayName, (unsigned __int64 *)slot, destsize, dest);
      if ( v48 )
      {
        if ( !v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22334, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
          __debugbreak();
        v51 = *(_QWORD *)slot;
        if ( *(_QWORD *)slot && *v41 )
        {
          v52 = &v41[-*(_QWORD *)slot];
          do
          {
            if ( v51 >= v50 - 1 )
              break;
            v40[v51] = v52[v51];
            ++v51;
          }
          while ( v52[v51] );
        }
        if ( text[0] )
        {
          v53 = &text[-v51];
          do
          {
            if ( v51 >= v50 - 1 )
              break;
            v40[v51] = v53[v51];
            ++v51;
          }
          while ( v53[v51] );
        }
        goto LABEL_143;
      }
    }
    v51 = *(_QWORD *)slot;
LABEL_143:
    v40[v51] = 0;
    goto LABEL_144;
  }
  v38 = SEH_StringEd_GetString("WEAPON/CUSTOM_ATTACHMENT");
  v39 = UI_ReplaceConversionString(v38, LootVariantDisplayName);
  v40 = dest;
  Core_strcpy(dest, destsize, v39);
LABEL_144:
  R_TextValidatePrintable(v40);
  return v40;
}

/*
==============
CG_GetWeaponZoom
==============
*/
float CG_GetWeaponZoom(const cg_t *cgameGlob, const Weapon *weapon, const float weapPosFrac, const CG_FovSpace fovSpace)
{
  double v8; 
  CgWeaponMap *Instance; 
  bool v10; 
  float v11; 
  float adsZoomOutFrac; 
  float adsZoomInFrac; 

  if ( weapPosFrac <= 0.0 )
    goto LABEL_13;
  if ( weapPosFrac < 1.0 )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|WEAPON_FIRING) && BG_IsThirdPersonMode(Instance, &cgameGlob->predictedPlayerState) && !BG_UsingSniperScope(Instance, &cgameGlob->predictedPlayerState) )
    {
      v8 = I_fclamp(weapPosFrac, 0.0, 1.0);
      return *(float *)&v8;
    }
    v10 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
    BG_GetADSZoomInFracs(Instance, &cgameGlob->predictedPlayerState, weapon, v10, fovSpace == CG_FovSpace_DepthHack, &adsZoomInFrac, &adsZoomOutFrac);
    if ( cgameGlob->playerEntity.bPositionToADS )
      v11 = adsZoomInFrac;
    else
      v11 = adsZoomOutFrac;
    if ( v11 > 0.0 )
    {
      v8 = I_fclamp((float)(weapPosFrac - (float)(1.0 - v11)) / v11, 0.0, 1.0);
      return *(float *)&v8;
    }
LABEL_13:
    LODWORD(v8) = 0;
    return *(float *)&v8;
  }
  *(float *)&v8 = FLOAT_1_0;
  return *(float *)&v8;
}

/*
==============
CG_HasRecoilAnim
==============
*/
_BOOL8 CG_HasRecoilAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6946, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6949, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( &LocalClientGlobals->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6950, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
    __debugbreak();
  p_m_weaponAnimArrays = &LocalClientGlobals->m_weaponAnimArrays;
  if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6953, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( BG_UsingAlternate(ps) )
    p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
  return (p_m_weaponAnimArrays->normalAnimArray[412] || p_m_weaponAnimArrays->normalAnimArray[176]) && p_m_weaponAnimArrays->normalAnimArray[373];
}

/*
==============
CG_IsAutoSimFiring
==============
*/
char CG_IsAutoSimFiring(cg_t *cgameGlob)
{
  int v1; 
  int *i; 

  v1 = 0;
  for ( i = &s_snd_autosims[0].shot.entNum; !i[42] || cgameGlob->predictedPlayerState.clientNum != *i; i += 48 )
  {
    if ( (unsigned int)++v1 >= 0x40 )
      return 0;
  }
  return 1;
}

/*
==============
CG_IsJogging
==============
*/
bool CG_IsJogging(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  double v3; 
  float v4; 
  float v5; 
  float v6; 
  const dvar_t *v7; 
  const char *v8; 
  const dvar_t *v9; 
  const char *v10; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !CgWeaponMap::ms_instance[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  if ( !BG_CanJog(CgWeaponMap::ms_instance[v1], &LocalClientGlobals->predictedPlayerState) )
    return 0;
  v3 = BG_CmdScale_CalcCmdScale(LocalClientGlobals->predictedPlayerState.lastInput.forwardmove, LocalClientGlobals->predictedPlayerState.lastInput.rightmove);
  v4 = (float)(_mm_cvtepi32_ps((__m128i)(unsigned int)LocalClientGlobals->predictedPlayerState.lastInput.forwardmove).m128_f32[0] * 0.0078740157) * *(float *)&v3;
  v5 = _mm_cvtepi32_ps((__m128i)(unsigned int)LocalClientGlobals->predictedPlayerState.lastInput.rightmove).m128_f32[0];
  v6 = fsqrt((float)((float)((float)((float)(v5 * 0.000062000123) * *(float *)&v3) * v5) * *(float *)&v3) + (float)(v4 * v4));
  if ( LocalClientGlobals->isJogging )
  {
    v7 = DCONST_DVARFLT_jogStickMinDeflectionMaintain;
    if ( DCONST_DVARFLT_jogStickMinDeflectionMaintain )
      goto LABEL_12;
    v8 = "jogStickMinDeflectionMaintain";
  }
  else
  {
    v7 = DCONST_DVARFLT_jogStickMinDeflectionStart;
    if ( DCONST_DVARFLT_jogStickMinDeflectionStart )
      goto LABEL_12;
    v8 = "jogStickMinDeflectionStart";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v8) )
    __debugbreak();
LABEL_12:
  Dvar_CheckFrontendServerThread(v7);
  if ( v7->current.value > v6 || v6 <= 0.000001 )
    return 0;
  if ( LocalClientGlobals->isJogging )
  {
    v9 = DCONST_DVARFLT_jogStickMinAngleMaintain;
    if ( DCONST_DVARFLT_jogStickMinAngleMaintain )
      goto LABEL_21;
    v10 = "jogStickMinAngleMaintain";
  }
  else
  {
    v9 = DCONST_DVARFLT_jogStickMinAngleStart;
    if ( DCONST_DVARFLT_jogStickMinAngleStart )
      goto LABEL_21;
    v10 = "jogStickMinAngleStart";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v10) )
    __debugbreak();
LABEL_21:
  Dvar_CheckFrontendServerThread(v9);
  return cosf_0(v9->current.value * 0.017453292) <= v4;
}

/*
==============
CG_IsWeaponInspectOnAltToggle
==============
*/
char CG_IsWeaponInspectOnAltToggle(LocalClientNum_t localClientNum)
{
  const dvar_t *v2; 
  const dvar_t *v3; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_LEAP_OUT|0x80) || !CL_Input_IsGamepadEnabled(localClientNum) )
    return 0;
  v2 = DVARBOOL_killswitch_weapon_inspect_enabled;
  if ( !DVARBOOL_killswitch_weapon_inspect_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_inspect_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( !v2->current.enabled )
    return 0;
  v3 = DVARBOOL_killswitch_weapon_inspect_on_alt_switch_hold_enabled;
  if ( !DVARBOOL_killswitch_weapon_inspect_on_alt_switch_hold_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_inspect_on_alt_switch_hold_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( v3->current.enabled && (LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum), Instance = CgWeaponMap::GetInstance(localClientNum), CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &LocalClientGlobals->predictedPlayerState), v7 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState), BG_GetWeaponInspectEnabled(CurrentWeaponForPlayer, v7)) )
    return 1;
  else
    return 0;
}

/*
==============
CG_JavelinADS
==============
*/

bool __fastcall CG_JavelinADS(LocalClientNum_t localClientNum, __int64 a2, double a3)
{
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  const Weapon *ViewmodelWeapon; 
  __m256i v8; 
  __int128 v9; 
  double v10; 
  double v11; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  ViewmodelWeapon = BG_GetViewmodelWeapon(Instance, p_predictedPlayerState);
  v8 = *(__m256i *)&ViewmodelWeapon->weaponIdx;
  v9 = *(_OWORD *)&ViewmodelWeapon->attachmentVariationIndices[5];
  v10 = *(double *)&ViewmodelWeapon->attachmentVariationIndices[21];
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&ViewmodelWeapon->weaponCamo;
  *(__m256i *)&r_weapon.weaponIdx = v8;
  *(_OWORD *)&r_weapon.attachmentVariationIndices[5] = v9;
  *(double *)&r_weapon.attachmentVariationIndices[21] = v10;
  if ( !LOWORD(a3) )
    return 0;
  v11 = BG_WeaponADSFractionAffectedByReload(Instance, p_predictedPlayerState);
  return *(float *)&v11 == 1.0 && BG_WeaponDef(&r_weapon, 0)->overlayInterface == WEAPOVERLAYINTERFACE_JAVELIN;
}

/*
==============
CG_KillstreakSlotDown
==============
*/
void CG_KillstreakSlotDown(LocalClientNum_t localClientNum, int bindingIndex)
{
  __int64 v2; 
  int v4; 
  const char *v5; 
  unsigned int v6; 
  const char *v7; 
  int result; 
  int notifyData[4]; 

  v2 = bindingIndex;
  if ( !CL_Input_IsGamepadEnabled(localClientNum) )
  {
    if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() == LONG )
    {
      *(_OWORD *)notifyData = _xmm;
      v4 = notifyData[v2];
      v5 = "radial_menu_munition";
LABEL_7:
      CG_ServerCmd_NotifyServer(localClientNum, v5, v4);
      return;
    }
    *(_OWORD *)notifyData = _xmm;
    v6 = notifyData[v2];
    v7 = j_va("ui_score_streak_available_%i", v6);
    if ( CG_GetOmnvar_IntegerByName(localClientNum, v7, &result, NULL, NULL) && result == 1 )
    {
      v4 = v6;
      v5 = "streak_select";
      goto LABEL_7;
    }
  }
}

/*
==============
CG_LoadViewModelAnimIndexFixup
==============
*/
__int64 CG_LoadViewModelAnimIndexFixup(unsigned int savedAnimIndex, unsigned __int8 savedVersion, unsigned __int8 currentVersion)
{
  unsigned int v3; 

  v3 = savedAnimIndex;
  if ( savedVersion || currentVersion != 1 )
  {
    if ( savedVersion != currentVersion )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DEBF0, 6441i64, savedVersion);
  }
  else if ( savedAnimIndex >= 0xB5 )
  {
    v3 = savedAnimIndex + 16;
    if ( savedAnimIndex + 16 >= 0x260 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13540, ASSERT_TYPE_ASSERT, "(animIndex < NUM_WEAP_VIEWMODEL_ANIMS)", (const char *)&queryFormat, "animIndex < NUM_WEAP_VIEWMODEL_ANIMS") )
    {
      __debugbreak();
      return v3;
    }
  }
  return v3;
}

/*
==============
CG_LoadViewModelAnimTrees
==============
*/
void CG_LoadViewModelAnimTrees(SaveGame *save, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  __int64 v3; 
  MemoryFile *MemoryFile; 
  const Weapon *ViewmodelWeapon; 
  cg_t *LocalClientGlobals; 
  int v9; 
  bool v10; 
  WeaponHand *m_weaponHand; 
  DObj *viewModelDObj; 
  __int64 v13; 
  __int64 v14; 

  v3 = localClientNum;
  if ( !save && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13558, ASSERT_TYPE_ASSERT, "(save)", (const char *)&queryFormat, "save") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13559, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  MemoryFile = SaveMemory_GetMemoryFile(save);
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v3], ps);
  if ( ViewmodelWeapon->weaponIdx )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
    v9 = 0;
    v10 = 1;
    m_weaponHand = LocalClientGlobals->m_weaponHand;
    do
    {
      if ( !v10 )
      {
        LODWORD(v14) = 2;
        LODWORD(v13) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( m_weaponHand->hasAnimTree )
      {
        CG_Weapons_LoadViewModelDObj((const LocalClientNum_t)v3, ps, ViewmodelWeapon, (const PlayerHandIndex)v9);
        viewModelDObj = m_weaponHand->viewModelDObj;
        if ( !m_weaponHand->viewModelDObj )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DEC60, 614i64);
          viewModelDObj = m_weaponHand->viewModelDObj;
        }
        if ( m_weaponHand->tree )
        {
          XAnimClearTree(viewModelDObj);
          viewModelDObj = m_weaponHand->viewModelDObj;
        }
        XAnimLoadAnimTreeWithVersion(viewModelDObj, MemoryFile, 1u, (unsigned int (__fastcall *)(unsigned int, unsigned __int8, unsigned __int8))CG_LoadViewModelAnimIndexFixup);
      }
      ++v9;
      ++m_weaponHand;
      v10 = (unsigned int)v9 < 2;
    }
    while ( v9 < 2 );
  }
}

/*
==============
CG_MeleeBloodEvent
==============
*/
void CG_MeleeBloodEvent(LocalClientNum_t localClientNum, int attackerEntityNum)
{
  const dvar_t *v3; 
  FXRegisteredDef *p_fxKnifeBlood; 

  if ( CG_GetLocalClientGlobals(localClientNum)->predictedPlayerState.clientNum == attackerEntityNum && useBlood )
  {
    v3 = DVARBOOL_cg_blood;
    if ( !DVARBOOL_cg_blood && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_blood") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    p_fxKnifeBlood = &cgMedia.fxKnifeBlood;
    if ( !v3->current.enabled )
      p_fxKnifeBlood = &cgMedia.fxKnifeNoBlood;
    CG_PlayBoltedEffect(localClientNum, p_fxKnifeBlood, 2048, scr_const.tag_knife_fx);
  }
}

/*
==============
CG_MissileTrajectoryEvent
==============
*/
void CG_MissileTrajectoryEvent(LocalClientNum_t localClientNum, centity_t *cent)
{
  __int64 v3; 
  const BgWeaponMap **v4; 
  const Weapon *weapon; 
  bool isAlternate; 
  CgWeaponSystem *WeaponSystem; 
  CgSoundSystem *SoundSystem; 
  __int64 v9; 
  unsigned int groundEntityNum; 
  bool v11; 
  vec3_t outOrigin; 
  char v13[8]; 
  __int64 v14; 

  v3 = localClientNum;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_HOLD_PRIMED) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22125, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::EVENT_MISSILE_TRAJECTORY ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::EVENT_MISSILE_TRAJECTORY )") )
    __debugbreak();
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v3];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  weapon = BG_GetWeaponForEntity(*v4, &cent->nextState);
  isAlternate = cent->nextState.inAltWeaponMode;
  CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v3);
  CG_GetPoseOrigin(&cent->pose, &outOrigin);
  Physics_AddDeferredBulletForce((const Physics_WorldId)(3 * v3 + 3), (const vec3_t *)&cent->nextState.lerp.u, &outOrigin, cent->nextState.otherEntityNum, 0, weapon, isAlternate, 0, CG_BulletHitEffectCallback);
  if ( BG_ProjWhizByEnabled(weapon, isAlternate) )
  {
    v14 = 0i64;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)WeaponSystem->m_localClientNum);
    v11 = isAlternate;
    LOBYTE(v9) = 1;
    ((void (__fastcall *)(CgSoundSystem *, char *, __int64, __int64, LerpEntityStateTypeUnion *, LerpEntityStateTypeUnion *, vec3_t *, int, const Weapon *, bool, int, _DWORD, __int64))SoundSystem->PlayWhizbyAndImpactSfx)(SoundSystem, v13, v9, 2046i64, &cent->nextState.lerp.u, &cent->nextState.lerp.u, &outOrigin, -1, weapon, v11, -1, 0, -2i64);
  }
  groundEntityNum = cent->nextState.groundEntityNum;
  if ( groundEntityNum < 0x7FE )
    CgWeaponSystem::BulletScriptableImpact(WeaponSystem, cent->nextState.otherEntityNum, groundEntityNum, weapon, isAlternate, MOD_UNKNOWN, (const vec3_t *)&cent->nextState.lerp.u, &outOrigin, (const scr_string_t)cent->nextState.lerp.u.event.bulletHitSP.partName);
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_NextSlotHasWeapons
==============
*/
bool CG_NextSlotHasWeapons(LocalClientNum_t localClientNum)
{
  WeaponSlot CurrentWeaponSlot; 
  WeaponSlot v3; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  WeaponSlot CycleSlot; 

  CurrentWeaponSlot = CG_GetCurrentWeaponSlot(localClientNum);
  v3 = CurrentWeaponSlot;
  if ( CurrentWeaponSlot )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    CycleSlot = BG_PlayerWeaponGetCycleSlot(v3, 1);
    LOBYTE(CurrentWeaponSlot) = BG_PlayerWeaponCountWeaponsBySlot(Instance, &LocalClientGlobals->predictedPlayerState, CycleSlot) != 0;
  }
  return CurrentWeaponSlot;
}

/*
==============
CG_NightVisionBloomDisabled
==============
*/
__int64 CG_NightVisionBloomDisabled()
{
  const dvar_t *v0; 

  v0 = DCONST_DVARMPBOOL_NVG_DisableBloom;
  if ( !DCONST_DVARMPBOOL_NVG_DisableBloom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableBloom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.color[0];
}

/*
==============
CG_NightVisionDown
==============
*/
void CG_NightVisionDown(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  cg_t *v4; 
  __int64 v5; 
  cg_t *v6; 
  bool v7; 
  unsigned int v8; 
  __int64 v9; 
  __int64 v11; 
  int v12; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v12 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v12) )
      __debugbreak();
  }
  v2 = v1;
  if ( (clientUIActives[v1].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18400, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  if ( CG_Weapons_ActionSlotTypeUsageAllowed(LocalClientGlobals, ACTIONSLOTTYPE_NIGHTVISION) )
  {
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v11) = 2;
      LODWORD(v9) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v9, v11) )
        __debugbreak();
    }
    if ( (clientUIActives[v2].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18384, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
      __debugbreak();
    v4 = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
    v5 = 0i64;
    v6 = v4;
    while ( 1 )
    {
      v7 = Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
      v8 = 4;
      if ( v7 )
        v8 = 7;
      if ( (unsigned int)v5 >= v8 )
        break;
      if ( v6->predictedPlayerState.actionSlotType[v5] == ACTIONSLOTTYPE_NIGHTVISION )
      {
        LocalClientGlobals->extraButtons |= 0x10000ui64;
        return;
      }
      v5 = (unsigned int)(v5 + 1);
    }
  }
}

/*
==============
CG_NightVisionGetBloomTimings
==============
*/
void CG_NightVisionGetBloomTimings(const int NVGToggleTime, const bool isOn, const bool isInstant, int *outBloomStartBlendInTime, int *outBloomStartBlendOutTime, int *outBlendInDuration, int *outBlendOutDuration)
{
  const dvar_t *v9; 
  const char *v10; 
  int v11; 
  const dvar_t *v12; 
  const char *v13; 
  const dvar_t *v14; 
  const char *v15; 
  int integer; 
  const dvar_t *v17; 
  const char *v18; 
  const dvar_t *v19; 
  const char *v20; 
  const dvar_t *v21; 
  const char *v22; 

  if ( !outBloomStartBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12754, ASSERT_TYPE_ASSERT, "(outBloomStartBlendInTime)", (const char *)&queryFormat, "outBloomStartBlendInTime") )
    __debugbreak();
  if ( !outBloomStartBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12755, ASSERT_TYPE_ASSERT, "(outBloomStartBlendOutTime)", (const char *)&queryFormat, "outBloomStartBlendOutTime") )
    __debugbreak();
  if ( !outBlendInDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12756, ASSERT_TYPE_ASSERT, "(outBlendInDuration)", (const char *)&queryFormat, "outBlendInDuration") )
    __debugbreak();
  if ( !outBlendOutDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12757, ASSERT_TYPE_ASSERT, "(outBlendOutDuration)", (const char *)&queryFormat, "outBlendOutDuration") )
    __debugbreak();
  if ( isInstant )
  {
    v11 = 0;
    if ( isOn )
    {
      v19 = DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendInDurationMS;
      if ( DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendInDurationMS )
        goto LABEL_47;
      v20 = "NVG_ON_Instant_BloomBlendInDurationMS";
    }
    else
    {
      v19 = DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendInDurationMS;
      if ( DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendInDurationMS )
        goto LABEL_47;
      v20 = "NVG_OFF_Instant_BloomBlendInDurationMS";
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v20) )
      __debugbreak();
LABEL_47:
    Dvar_CheckFrontendServerThread(v19);
    *outBlendInDuration = v19->current.integer;
    if ( isOn )
    {
      v21 = DCONST_DVARMPINT_NVG_ON_Instant_BloomEndOffsetMS;
      if ( DCONST_DVARMPINT_NVG_ON_Instant_BloomEndOffsetMS )
        goto LABEL_54;
      v22 = "NVG_ON_Instant_BloomEndOffsetMS";
    }
    else
    {
      v21 = DCONST_DVARMPINT_NVG_OFF_Instant_BloomEndOffsetMS;
      if ( DCONST_DVARMPINT_NVG_OFF_Instant_BloomEndOffsetMS )
        goto LABEL_54;
      v22 = "NVG_OFF_Instant_BloomEndOffsetMS";
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v22) )
      __debugbreak();
LABEL_54:
    Dvar_CheckFrontendServerThread(v21);
    integer = v21->current.integer;
    if ( isOn )
    {
      v17 = DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendOutDurationMS;
      if ( DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendOutDurationMS )
        goto LABEL_61;
      v18 = "NVG_ON_Instant_BloomBlendOutDurationMS";
    }
    else
    {
      v17 = DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendOutDurationMS;
      if ( DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendOutDurationMS )
        goto LABEL_61;
      v18 = "NVG_OFF_Instant_BloomBlendOutDurationMS";
    }
    goto LABEL_59;
  }
  if ( isOn )
  {
    v9 = DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS )
      goto LABEL_21;
    v10 = "NVG_ON_BloomStartOffsetMS";
  }
  else
  {
    v9 = DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS )
      goto LABEL_21;
    v10 = "NVG_OFF_BloomStartOffsetMS";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v10) )
    __debugbreak();
LABEL_21:
  Dvar_CheckFrontendServerThread(v9);
  v11 = v9->current.integer;
  if ( isOn )
  {
    v12 = DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS )
      goto LABEL_28;
    v13 = "NVG_ON_BloomBlendInDurationMS";
  }
  else
  {
    v12 = DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS )
      goto LABEL_28;
    v13 = "NVG_OFF_BloomBlendInDurationMS";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v13) )
    __debugbreak();
LABEL_28:
  Dvar_CheckFrontendServerThread(v12);
  *outBlendInDuration = v12->current.integer;
  if ( isOn )
  {
    v14 = DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS )
      goto LABEL_35;
    v15 = "NVG_ON_BloomEndOffsetMS";
  }
  else
  {
    v14 = DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS )
      goto LABEL_35;
    v15 = "NVG_OFF_BloomEndOffsetMS";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v15) )
    __debugbreak();
LABEL_35:
  Dvar_CheckFrontendServerThread(v14);
  integer = v14->current.integer;
  if ( isOn )
  {
    v17 = DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS )
      goto LABEL_61;
    v18 = "NVG_ON_BloomBlendOutDurationMS";
  }
  else
  {
    v17 = DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS )
      goto LABEL_61;
    v18 = "NVG_OFF_BloomBlendOutDurationMS";
  }
LABEL_59:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v18) )
    __debugbreak();
LABEL_61:
  Dvar_CheckFrontendServerThread(v17);
  *outBlendOutDuration = v17->current.integer;
  *outBloomStartBlendInTime = NVGToggleTime - v11;
  *outBloomStartBlendOutTime = integer + NVGToggleTime;
}

/*
==============
CG_NightVisionGetExposureAdjustTimings
==============
*/
void CG_NightVisionGetExposureAdjustTimings(const int NVGToggleTime, int *outExposureStartBlendInTime, int *outExposureStartBlendOutTime, int *outExposureInDuration, int *outExposureOutDuration)
{
  const dvar_t *v9; 
  int integer; 
  const dvar_t *v11; 
  const dvar_t *v12; 
  int v13; 
  const dvar_t *v14; 

  if ( !outExposureStartBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12783, ASSERT_TYPE_ASSERT, "(outExposureStartBlendInTime)", (const char *)&queryFormat, "outExposureStartBlendInTime") )
    __debugbreak();
  if ( !outExposureStartBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12784, ASSERT_TYPE_ASSERT, "(outExposureStartBlendOutTime)", (const char *)&queryFormat, "outExposureStartBlendOutTime") )
    __debugbreak();
  if ( !outExposureInDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12785, ASSERT_TYPE_ASSERT, "(outExposureInDuration)", (const char *)&queryFormat, "outExposureInDuration") )
    __debugbreak();
  if ( !outExposureOutDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12786, ASSERT_TYPE_ASSERT, "(outExposureOutDuration)", (const char *)&queryFormat, "outExposureOutDuration") )
    __debugbreak();
  v9 = DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureStartOffsetMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  integer = v9->current.integer;
  v11 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendInDurationMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  *outExposureInDuration = v11->current.integer;
  v12 = DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureEndOffsetMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  v13 = v12->current.integer;
  v14 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendOutDurationMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  *outExposureOutDuration = v14->current.integer;
  *outExposureStartBlendInTime = NVGToggleTime - integer;
  *outExposureStartBlendOutTime = v13 + NVGToggleTime;
}

/*
==============
CG_NightVisionIsAvailable
==============
*/
char CG_NightVisionIsAvailable(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  __int64 v3; 
  cg_t *v4; 
  bool v5; 
  unsigned int v6; 
  int v9; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v9 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v9) )
      __debugbreak();
  }
  if ( (clientUIActives[v1].frontEndSceneState[0] || !clientUIActives[v1].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18384, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  v3 = 0i64;
  v4 = LocalClientGlobals;
  while ( 1 )
  {
    v5 = Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
    v6 = 4;
    if ( v5 )
      v6 = 7;
    if ( (unsigned int)v3 >= v6 )
      break;
    if ( v4->predictedPlayerState.actionSlotType[v3] == ACTIONSLOTTYPE_NIGHTVISION )
      return 1;
    v3 = (unsigned int)(v3 + 1);
  }
  return 0;
}

/*
==============
CG_NightVisionProcessLightFX
==============
*/
void CG_NightVisionProcessLightFX(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *dObj, const PlayerHandIndex hand)
{
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  int *v8; 
  const dvar_t *v9; 
  ParticleSystem *v10; 
  CgWeaponMap *Instance; 
  FXRegisteredDef *p_fxNightVisionAreaLightAlt; 
  unsigned __int8 v13; 
  cg_t *v14; 
  ParticleManager *ParticleManager; 
  ParticleSystemHandle killcamThirdpersonAreaLightFx; 
  cg_t *v17; 
  unsigned int v18; 
  __int64 v19; 
  vec4_t v21; 
  __m128 v24; 
  __m128 v; 
  __m128 v26; 
  __m128 v27; 
  __m128 v28; 
  __m128 v29; 
  vec4_t v30; 
  const float4 *v31; 
  vector3 *v32; 
  __m128 v33; 
  __m128 v34; 
  __m128 v35; 
  __m128 v36; 
  __m128 v37; 
  __m128 v38; 
  __m128 v39; 
  ParticleManager *v40; 
  unsigned __int16 boneIndex; 
  vec3_t outOrg; 
  float4 normal[2]; 
  float4 v44[2]; 
  __int64 v45; 
  vec4_t out; 
  tmat33_t<vec3_t> axis; 

  v45 = -2i64;
  v6 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12898, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_SPRINT_COMBAT_IDLE_COOLDOWN) && hand == WEAPON_HAND_DEFAULT )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12912, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    LocalClientGlobals->nvgInfo.nvgAreaLightFXProcessedThisFrame = 1;
    CG_NightVisionValidateFXHandles(LocalClientGlobals);
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12812, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v8 = (int *)CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
    v9 = DCONST_DVARMPBOOL_NVG_DisableAreaLight;
    if ( !DCONST_DVARMPBOOL_NVG_DisableAreaLight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableAreaLight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    v10 = NULL;
    if ( v9->current.enabled || v8[185398] && v8[185399] || v8[5] >= 7 )
      goto LABEL_52;
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2245, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 7u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 9u) || v8[128194] || (Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v6), BG_IsThirdPersonMode(Instance, ps)) )
    {
LABEL_52:
      if ( LocalClientGlobals->nvgInfo.nightVisionAreaLightFx )
      {
        ParticleManager = ParticleManager::GetParticleManager((LocalClientNum_t)v6);
        ParticleManager::KillSystem(ParticleManager, LocalClientGlobals->nvgInfo.nightVisionAreaLightFx);
        LocalClientGlobals->nvgInfo.nightVisionAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
      }
    }
    else
    {
      p_fxNightVisionAreaLightAlt = &cgMedia.fxNightVisionAreaLightAlt;
      if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 8u) )
        p_fxNightVisionAreaLightAlt = &cgMedia.fxNightVisionAreaLight;
      if ( LocalClientGlobals->nvgInfo.nightVisionAreaLightFx == PARTICLE_SYSTEM_INVALID_HANDLE && p_fxNightVisionAreaLightAlt->m_particleSystemDef )
      {
        boneIndex = 254;
        CG_GetBoneIndex((LocalClientNum_t)v6, 2048, scr_const.tag_view, &boneIndex);
        v13 = boneIndex;
        if ( boneIndex > 0xFFu && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned short>(unsigned short)", "unsigned", (unsigned __int8)boneIndex, "unsigned", boneIndex) )
          __debugbreak();
        if ( v13 != 0xFE )
        {
          v14 = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
          LocalClientGlobals->nvgInfo.nightVisionAreaLightFx = FX_PlayBoltedEffect((LocalClientNum_t)v6, p_fxNightVisionAreaLightAlt, v14->time, 2048, v13, 0);
        }
      }
    }
    if ( CG_NightVisionShouldDrawKillcamLightFX((LocalClientNum_t)v6) )
    {
      RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
      axis = LocalClientGlobals->refdef.view.axis;
      killcamThirdpersonAreaLightFx = LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx;
      if ( killcamThirdpersonAreaLightFx )
      {
        v18 = 0;
        if ( g_particleSystemsGeneration[4096 * v6 + (killcamThirdpersonAreaLightFx & 0xFFF)].__all32 == killcamThirdpersonAreaLightFx )
          v18 = LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx & 0xFFF;
        v19 = (v6 << 12) + v18;
        if ( g_particleSystems[0][v19] >= (ParticleSystem *)0x1000 )
          v10 = g_particleSystems[0][v19];
        if ( v10 )
        {
          out.v[3] = 0.0;
          v21 = out;
          v21.v[0] = outOrg.v[0];
          _XMM3 = v21;
          __asm
          {
            vinsertps xmm3, xmm3, dword ptr [rsp+148h+outOrg+4], 10h
            vinsertps xmm3, xmm3, dword ptr [rsp+148h+outOrg+8], 20h
          }
          out = _XMM3;
          v10->m_systemTransform.w = (float4)_XMM3;
          v24 = _mm_shuffle_ps(v10->m_systemTransform.x.v, v10->m_systemTransform.y.v, 68);
          v = v10->m_systemTransform.z.v;
          v26 = _mm_shuffle_ps(v, (__m128)_XMM3, 68);
          v27 = _mm_shuffle_ps(v10->m_systemTransform.x.v, v10->m_systemTransform.y.v, 238);
          v28 = _mm_shuffle_ps(v, (__m128)_XMM3, 238);
          normal[0].v = _mm_shuffle_ps(v24, v26, 136);
          normal[1].v = _mm_shuffle_ps(v24, v26, 221);
          v44[0].v = _mm_shuffle_ps(v27, v28, 136);
          v29 = _mm_shuffle_ps(v27, v28, 221);
          v44[1] = (float4)v29;
          *(__m256i *)v10->m_systemTransformTranspose.x.v.m128_f32 = *(__m256i *)normal[0].v.m128_f32;
          *(__m256i *)v10->m_systemTransformTranspose.z.v.m128_f32 = *(__m256i *)v44[0].v.m128_f32;
          AxisToQuat(&axis, &out);
          v30 = out;
          Float4UnitQuatToAxis(v32, v31);
          normal[1] = (float4)v29;
          normal[0] = (float4)v30;
          v44[0] = (float4)v27;
          Particle_AssertFloat4IsNormalized(normal);
          Particle_AssertFloat4IsNormalized(&normal[1]);
          Particle_AssertFloat4IsNormalized(v44);
          v33 = normal[0].v;
          v34 = normal[1].v;
          v35 = v44[0].v;
          v10->m_systemTransform.z = v44[0];
          v10->m_systemTransform.y.v = v34;
          v10->m_systemTransform.x.v = v33;
          v36 = _mm_shuffle_ps(v33, v34, 68);
          v37 = _mm_shuffle_ps(v35, v10->m_systemTransform.w.v, 68);
          v38 = _mm_shuffle_ps(v33, v34, 238);
          v39 = _mm_shuffle_ps(v35, v10->m_systemTransform.w.v, 238);
          normal[0].v = _mm_shuffle_ps(v36, v37, 136);
          normal[1].v = _mm_shuffle_ps(v36, v37, 221);
          v44[0].v = _mm_shuffle_ps(v38, v39, 136);
          v44[1].v = _mm_shuffle_ps(v38, v39, 221);
          *(__m256i *)v10->m_systemTransformTranspose.x.v.m128_f32 = *(__m256i *)normal[0].v.m128_f32;
          *(__m256i *)v10->m_systemTransformTranspose.z.v.m128_f32 = *(__m256i *)v44[0].v.m128_f32;
        }
      }
      else if ( cgMedia.fxKillcamAreaLight.m_particleSystemDef )
      {
        v17 = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
        LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx = FX_PlayOrientedEffect((LocalClientNum_t)v6, &cgMedia.fxKillcamAreaLight, v17->time, &outOrg, &axis);
      }
      memset(&outOrg, 0, sizeof(outOrg));
    }
    else if ( LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx )
    {
      v40 = ParticleManager::GetParticleManager((LocalClientNum_t)v6);
      ParticleManager::KillSystem(v40, LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx);
      LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
    }
  }
}

/*
==============
CG_NightVisionProcessNoteTracks
==============
*/
void CG_NightVisionProcessNoteTracks(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState, DObj *dObj, const PlayerHandIndex hand)
{
  __int128 v4; 
  __int128 v5; 
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  bool v9; 
  bool v10; 
  Gesture *v11; 
  bool IsUsingNightVision; 
  bool v13; 
  const dvar_t *v14; 
  const char *v15; 
  double v16; 
  double v17; 
  float v18; 
  ClientVisionSetData *p_cvsData; 
  const dvar_t *v20; 
  const XAnimParts *v21; 
  double NotetrackTimeFromParts; 
  float v23; 
  double AnimLengthInSeconds; 
  int v25; 
  const dvar_t *v26; 
  int integer; 
  const dvar_t *v28; 
  int v29; 
  const dvar_t *v30; 
  const dvar_t *v31; 
  NVGAnimBloomState nvgAnimBloomState; 
  const dvar_t *v33; 
  int NVGVisionStartTime; 
  int v35; 
  const dvar_t *v36; 
  int v37; 
  const dvar_t *v38; 
  int v39; 
  const dvar_t *v40; 
  int v41; 
  Gesture *v42; 
  const XAnimParts *v43; 
  double v44; 
  float v45; 
  double v46; 
  int v47; 
  const dvar_t *v48; 
  int v49; 
  const dvar_t *v50; 
  int v51; 
  const dvar_t *v52; 
  const dvar_t *v53; 
  const dvar_t *v54; 
  int v55; 
  const dvar_t *v56; 
  int v57; 
  const dvar_t *v58; 
  const dvar_t *v59; 
  const dvar_t *v60; 
  int v61; 
  int v62; 
  const dvar_t *v63; 
  int v64; 
  const dvar_t *v65; 
  int v66; 
  const dvar_t *v67; 
  int v68; 
  const dvar_t *v69; 
  int v70; 
  int v71; 
  const dvar_t *v72; 
  int v73; 
  const dvar_t *v74; 
  int v75; 
  const dvar_t *v76; 
  int v77; 
  bool v78; 
  bool IsPlaying; 
  int v80; 
  unsigned int outSlot; 
  unsigned int v82; 
  Gesture *gesture; 
  Weapon r_weapon; 
  __int128 v85; 
  __int128 v86; 

  v6 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v9 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
  v10 = BG_PlayerDualWielding(&LocalClientGlobals->predictedPlayerState) == 1;
  if ( !CgWeaponMap::ms_instance[v6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  r_weapon = *BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v6], &LocalClientGlobals->predictedPlayerState);
  CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
  if ( hand )
  {
    if ( hand == WEAPON_HAND_LEFT && !v10 )
      return;
  }
  else if ( v10 )
  {
    return;
  }
  outSlot = 2;
  v11 = BG_Suit_GetGesture(&LocalClientGlobals->predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v9, v10, GESTUREANIMTYPE_NVG_ON);
  IsPlaying = BG_NightVisionGestureIsPlaying(&LocalClientGlobals->predictedPlayerState, v11, &outSlot, NULL);
  v82 = 2;
  gesture = BG_Suit_GetGesture(&LocalClientGlobals->predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v9, v10, GESTUREANIMTYPE_NVG_OFF);
  v78 = BG_NightVisionGestureIsPlaying(&LocalClientGlobals->predictedPlayerState, gesture, &v82, NULL);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13209, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  IsUsingNightVision = BG_IsUsingNightVision(&LocalClientGlobals->predictedPlayerState);
  v13 = IsPlaying || IsUsingNightVision && !v78;
  if ( v13 != LocalClientGlobals->nvgInfo.weightedBlind.prevNVGOn )
  {
    LocalClientGlobals->nvgInfo.weightedBlind.blendStartTime = LocalClientGlobals->time;
    LocalClientGlobals->nvgInfo.weightedBlind.blendingIn = v13;
  }
  if ( LocalClientGlobals->nvgInfo.weightedBlind.scriptGoalWeight <= LocalClientGlobals->nvgInfo.weightedBlind.currentWeight )
  {
    v14 = DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendOutSpeed;
    if ( !DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendOutSpeed )
    {
      v15 = "NVG_ScriptBlindWeighted_ScriptValueBlendOutSpeed";
LABEL_24:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v15) )
        __debugbreak();
    }
  }
  else
  {
    v14 = DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendInSpeed;
    if ( !DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendInSpeed )
    {
      v15 = "NVG_ScriptBlindWeighted_ScriptValueBlendInSpeed";
      goto LABEL_24;
    }
  }
  Dvar_CheckFrontendServerThread(v14);
  v16 = DiffTrack(LocalClientGlobals->nvgInfo.weightedBlind.scriptGoalWeight, LocalClientGlobals->nvgInfo.weightedBlind.currentWeight, v14->current.value, (float)LocalClientGlobals->frametime * 0.001);
  v17 = I_fclamp(*(float *)&v16, 0.0, 1.0);
  LocalClientGlobals->nvgInfo.weightedBlind.currentWeight = *(float *)&v17;
  v18 = CG_GetBlendedNVGFraction(LocalClientGlobals, &LocalClientGlobals->nvgInfo.weightedBlind) * LocalClientGlobals->nvgInfo.weightedBlind.currentWeight;
  p_cvsData = &LocalClientGlobals->cvsData;
  if ( v18 > 0.0 )
    CG_VisionSetSetBlendPush(p_cvsData, VISIONSET_BLENDTYPE_NVG_BLIND_WEIGHTED, v18);
  else
    CG_VisionSetSetBlendOff(p_cvsData, VISIONSET_BLENDTYPE_NVG_BLIND_WEIGHTED);
  LocalClientGlobals->nvgInfo.weightedBlind.prevNVGOn = v13;
  v20 = DCONST_DVARMPBOOL_NVG_DisableBloom;
  if ( !DCONST_DVARMPBOOL_NVG_DisableBloom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableBloom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v20);
  if ( v20->current.enabled )
  {
    CG_VisionSetSetBlendOff(&LocalClientGlobals->cvsData, VISIONSET_BLENDTYPE_NVG_FADE);
  }
  else
  {
    v86 = v4;
    v85 = v5;
    if ( IsPlaying && LocalClientGlobals->nvgInfo.nvgAnimBloomState == INACTIVE )
    {
      if ( !*v11->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13301, ASSERT_TYPE_ASSERT, "(nvgOnGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOnGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
        __debugbreak();
      v21 = *v11->anims;
      if ( v21 )
      {
        NotetrackTimeFromParts = XAnimGetNotetrackTimeFromParts(v21, scr_const.night_vision_on);
        v23 = *(float *)&NotetrackTimeFromParts;
        if ( *(float *)&NotetrackTimeFromParts != -1.0 )
        {
          AnimLengthInSeconds = BG_Gesture_GetAnimLengthInSeconds(v11);
          v25 = LocalClientGlobals->predictedPlayerState.gestureState.gestures[outSlot].startTime - (int)(float)((float)(*(float *)&AnimLengthInSeconds * -1000.0) * v23);
          LocalClientGlobals->NVGVisionStartTime = v25;
          LocalClientGlobals->nvgInfo.nvgAnimBloomState = ACTIVE;
          v26 = DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomStartOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v26);
          integer = v26->current.integer;
          v28 = DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS;
          v80 = integer;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendInDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v28);
          v29 = v28->current.integer;
          v30 = DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomEndOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v30);
          v31 = DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendOutDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v31);
          CG_VisionSetRegisterBlendStart(&LocalClientGlobals->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v25 - v80, v29, 1, VISIONSETLERP_SMOOTH);
        }
      }
    }
    nvgAnimBloomState = LocalClientGlobals->nvgInfo.nvgAnimBloomState;
    if ( nvgAnimBloomState == ACTIVE )
    {
      v33 = DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS;
      NVGVisionStartTime = LocalClientGlobals->NVGVisionStartTime;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomStartOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v33);
      v35 = v33->current.integer;
      v36 = DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendInDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v36);
      v37 = v36->current.integer;
      v38 = DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomEndOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v38);
      v39 = v38->current.integer;
      v40 = DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendOutDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v40);
      v41 = v40->current.integer;
      if ( LocalClientGlobals->time >= v37 + NVGVisionStartTime - v35 )
      {
        LocalClientGlobals->nvgInfo.nvgAnimBloomState = INACTIVE;
        CG_VisionSetRegisterBlendStart(&LocalClientGlobals->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v39 + NVGVisionStartTime, v41, 0, VISIONSETLERP_SMOOTH);
      }
    }
    else if ( v78 && nvgAnimBloomState == INACTIVE )
    {
      v42 = gesture;
      if ( !*gesture->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13337, ASSERT_TYPE_ASSERT, "(nvgOffGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOffGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
        __debugbreak();
      v43 = *v42->anims;
      if ( v43 )
      {
        v44 = XAnimGetNotetrackTimeFromParts(v43, scr_const.night_vision_off);
        v45 = *(float *)&v44;
        if ( *(float *)&v44 != -1.0 )
        {
          v46 = BG_Gesture_GetAnimLengthInSeconds(v42);
          v47 = LocalClientGlobals->predictedPlayerState.gestureState.gestures[v82].startTime - (int)(float)((float)(*(float *)&v46 * -1000.0) * v45);
          LocalClientGlobals->NVGVisionStartTime = v47;
          LocalClientGlobals->nvgInfo.nvgAnimBloomState = 2;
          LocalClientGlobals->NVGExposureToggleState = 2;
          v48 = DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomStartOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v48);
          v49 = v48->current.integer;
          v50 = DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendInDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v50);
          v51 = v50->current.integer;
          v52 = DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomEndOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v52);
          v53 = DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendOutDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v53);
          CG_VisionSetRegisterBlendStart(&LocalClientGlobals->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v47 - v49, v51, 1, VISIONSETLERP_SMOOTH);
          v54 = DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureStartOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v54);
          v55 = v54->current.integer;
          v56 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendInDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v56);
          v57 = v56->current.integer;
          v58 = DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureEndOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v58);
          v59 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendOutDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v59);
          CG_VisionSetRegisterBlendStart(&LocalClientGlobals->cvsData, VISIONSET_BLENDTYPE_NVG_EXPOSURE, v47 - v55, v57, 1, VISIONSETLERP_SMOOTH);
        }
      }
    }
    if ( LocalClientGlobals->nvgInfo.nvgAnimBloomState == 2 )
    {
      v60 = DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS;
      v61 = LocalClientGlobals->NVGVisionStartTime;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomStartOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v60);
      v62 = v60->current.integer;
      v63 = DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendInDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v63);
      v64 = v63->current.integer;
      v65 = DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomEndOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v65);
      v66 = v65->current.integer;
      v67 = DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendOutDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v67);
      v68 = v67->current.integer;
      if ( LocalClientGlobals->time >= v64 + v61 - v62 )
      {
        LocalClientGlobals->nvgInfo.nvgAnimBloomState = INACTIVE;
        CG_VisionSetRegisterBlendStart(&LocalClientGlobals->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v66 + v61, v68, 0, VISIONSETLERP_SMOOTH);
      }
    }
    if ( LocalClientGlobals->NVGExposureToggleState == 2 )
    {
      v69 = DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS;
      v70 = LocalClientGlobals->NVGVisionStartTime;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureStartOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v69);
      v71 = v69->current.integer;
      v72 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendInDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v72);
      v73 = v72->current.integer;
      v74 = DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureEndOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v74);
      v75 = v74->current.integer;
      v76 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendOutDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v76);
      v77 = v76->current.integer;
      if ( LocalClientGlobals->time >= v73 + v70 - v71 )
      {
        LocalClientGlobals->NVGExposureToggleState = 0;
        CG_VisionSetRegisterBlendStart(&LocalClientGlobals->cvsData, VISIONSET_BLENDTYPE_NVG_EXPOSURE, v75 + v70, v77, 0, VISIONSETLERP_SMOOTH);
      }
    }
    CG_NightVision_UpdateScriptBlind(LocalClientGlobals, IsPlaying, v78);
  }
}

/*
==============
CG_NightVisionShouldDrawKillcamLightFX
==============
*/
bool CG_NightVisionShouldDrawKillcamLightFX(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v2; 
  const dvar_t *v3; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v2 = LocalClientGlobals;
  if ( !LocalClientGlobals->inKillCam || LocalClientGlobals->killCamEntityType == KC_NO_ENTITY )
    return 0;
  v3 = DCONST_DVARMPBOOL_NVG_DisableAreaLight;
  if ( !DCONST_DVARMPBOOL_NVG_DisableAreaLight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableAreaLight") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return !v3->current.enabled && v2->hasKillcamThirdpersonVisionSet;
}

/*
==============
CG_NightVisionShouldHideGoggles
==============
*/
_BOOL8 CG_NightVisionShouldHideGoggles(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  bool v5; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 
  int v8; 
  bool v9; 
  Gesture *Gesture; 
  Gesture *v11; 
  const XAnimParts *v12; 
  double NotetrackTimeFromParts; 
  float v14; 
  double v15; 
  float v16; 
  double ElapsedTime; 
  float v18; 
  double AnimLengthInSeconds; 
  double v20; 
  float v21; 
  double v22; 
  float v23; 
  double v24; 
  float v25; 
  double v26; 
  _BOOL8 result; 
  unsigned int outSlot; 
  unsigned int slot; 

  v2 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9617, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9620, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v5 = 1;
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(CgWeaponMap::ms_instance[v2], &LocalClientGlobals->predictedPlayerState);
  v7 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
  v8 = BG_PlayerDualWielding(&LocalClientGlobals->predictedPlayerState);
  outSlot = 2;
  v9 = v8 != 0;
  slot = 2;
  Gesture = BG_Suit_GetGesture(&LocalClientGlobals->predictedPlayerState, hand, CurrentWeaponForPlayer, v7, v8 != 0, GESTUREANIMTYPE_NVG_ON);
  v11 = BG_Suit_GetGesture(&LocalClientGlobals->predictedPlayerState, hand, CurrentWeaponForPlayer, v7, v9, GESTUREANIMTYPE_NVG_OFF);
  if ( BG_NightVisionGestureIsPlaying(&LocalClientGlobals->predictedPlayerState, Gesture, &outSlot, NULL) )
  {
    if ( !*Gesture->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9636, ASSERT_TYPE_ASSERT, "(nvgOnGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOnGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
      __debugbreak();
    v12 = *Gesture->anims;
    if ( v12 )
    {
      NotetrackTimeFromParts = XAnimGetNotetrackTimeFromParts(v12, scr_const.show_nvg_goggles);
      v14 = *(float *)&NotetrackTimeFromParts;
      v15 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)Gesture->anims, scr_const.hide_nvg_goggles);
      v16 = *(float *)&v15;
      if ( v14 >= 0.0 && *(float *)&v15 >= 0.0 )
      {
        ElapsedTime = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, outSlot, LocalClientGlobals->time);
        v18 = *(float *)&ElapsedTime;
        AnimLengthInSeconds = BG_Gesture_GetAnimLengthInSeconds(Gesture);
        if ( v18 >= (float)(*(float *)&AnimLengthInSeconds * v14) )
          v5 = (float)(*(float *)&AnimLengthInSeconds * v16) < v18;
      }
    }
  }
  if ( !BG_NightVisionGestureIsPlaying(&LocalClientGlobals->predictedPlayerState, v11, &slot, NULL) )
    return v5;
  if ( !*Gesture->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9659, ASSERT_TYPE_ASSERT, "(nvgOnGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOnGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
    __debugbreak();
  if ( !*Gesture->anims )
    return v5;
  v20 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v11->anims, scr_const.show_nvg_goggles);
  v21 = *(float *)&v20;
  v22 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v11->anims, scr_const.hide_nvg_goggles);
  v23 = *(float *)&v22;
  if ( v21 < 0.0 )
    return v5;
  if ( *(float *)&v22 < 0.0 )
    return v5;
  v24 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, slot, LocalClientGlobals->time);
  v25 = *(float *)&v24;
  v26 = BG_Gesture_GetAnimLengthInSeconds(v11);
  if ( v25 < (float)(*(float *)&v26 * v21) )
    return v5;
  result = v5;
  if ( (float)(*(float *)&v26 * v23) >= v25 )
    return 0i64;
  return result;
}

/*
==============
CG_NightVisionValidateFXHandles
==============
*/
void CG_NightVisionValidateFXHandles(cg_t *cgameGlob)
{
  ParticleSystemHandle nightVisionAreaLightFx; 
  __int64 localClientNum; 
  __int64 v4; 
  ParticleSystemHandle killcamThirdpersonAreaLightFx; 
  __int64 v6; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12876, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  nightVisionAreaLightFx = cgameGlob->nvgInfo.nightVisionAreaLightFx;
  localClientNum = cgameGlob->localClientNum;
  if ( nightVisionAreaLightFx )
  {
    v4 = (localClientNum << 12) + (nightVisionAreaLightFx & 0xFFF);
    if ( g_particleSystemsGeneration[v4].__all32 != nightVisionAreaLightFx || g_particleSystems[0][v4] < (ParticleSystem *)0x1000 )
      cgameGlob->nvgInfo.nightVisionAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
  killcamThirdpersonAreaLightFx = cgameGlob->nvgInfo.killcamThirdpersonAreaLightFx;
  if ( killcamThirdpersonAreaLightFx )
  {
    v6 = (localClientNum << 12) + (killcamThirdpersonAreaLightFx & 0xFFF);
    if ( g_particleSystemsGeneration[v6].__all32 != killcamThirdpersonAreaLightFx || g_particleSystems[0][v6] < (ParticleSystem *)0x1000 )
      cgameGlob->nvgInfo.killcamThirdpersonAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CG_NightVisionViewModelGogglesShouldBeAttached
==============
*/

bool __fastcall CG_NightVisionViewModelGogglesShouldBeAttached(LocalClientNum_t localClientNum, __int64 a2, double a3)
{
  __int64 v3; 
  playerState_s *p_predictedPlayerState; 
  bool v5; 
  bool v6; 
  Gesture *Gesture; 
  Gesture *v8; 
  bool result; 
  __int64 gestureAnimType; 
  Weapon r_weapon; 

  v3 = localClientNum;
  p_predictedPlayerState = &CG_GetLocalClientGlobals(localClientNum)->predictedPlayerState;
  v5 = BG_UsingAlternate(p_predictedPlayerState);
  v6 = BG_PlayerDualWielding(p_predictedPlayerState) == 1;
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  r_weapon = *BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v3], p_predictedPlayerState);
  if ( LOWORD(a3) > bg_lastParsedWeaponIndex )
  {
    LODWORD(gestureAnimType) = LOWORD(a3);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", gestureAnimType, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[LOWORD(a3)] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Gesture = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v5, v6, GESTUREANIMTYPE_NVG_ON);
  v8 = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v5, v6, GESTUREANIMTYPE_NVG_OFF);
  LOBYTE(Gesture) = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, Gesture, NULL, NULL);
  result = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, v8, NULL, NULL);
  if ( (_BYTE)Gesture || result )
    return 1;
  return result;
}

/*
==============
CG_NightVision_UpdateScriptBlind
==============
*/
void CG_NightVision_UpdateScriptBlind(cg_t *cgameGlob, const bool nvgAnimatingOn, const bool nvgAnimatingOff)
{
  int time; 
  const dvar_t *v7; 
  const SuitDef *SuitDef; 
  const char *name; 
  const SndAliasList *Alias; 
  CgSoundSystem *SoundSystem; 
  const dvar_t *v12; 
  int v13; 
  const dvar_t *v14; 
  const dvar_t *v15; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13069, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  time = cgameGlob->time;
  if ( cgameGlob->nvgInfo.activateBlindNow )
  {
    if ( !BG_IsUsingNightVision(&cgameGlob->predictedPlayerState) && !nvgAnimatingOn || nvgAnimatingOff || cgameGlob->nvgInfo.nvgAnimBloomState == 2 )
    {
      cgameGlob->nvgInfo.scriptBlindState = INACTIVE;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
    }
    else
    {
      if ( cgameGlob->nvgInfo.scriptBlindState == 4 && CG_VisionSetIsBlending(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time) )
        CG_VisionSetSetBlendStop(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time);
      cgameGlob->nvgInfo.scriptBlindState = ACTIVE;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
      v7 = DCONST_DVARMPINT_NVG_ScriptBlind_BlendIn;
      if ( !DCONST_DVARMPINT_NVG_ScriptBlind_BlendIn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_BlendIn") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v7);
      CG_VisionSetRegisterBlendStart(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time, v7->current.integer, 1, VISIONSETLERP_SMOOTH);
      SuitDef = BG_GetSuitDef(cgameGlob->predictedPlayerState.suitIndex);
      if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13041, ASSERT_TYPE_ASSERT, "(suit)", (const char *)&queryFormat, "suit") )
        __debugbreak();
      name = SuitDef->nvg_blindSound.name;
      if ( name )
      {
        Alias = SND_TryFindAlias(name);
        if ( Alias )
        {
          SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)cgameGlob->localClientNum);
          CgSoundSystem::PlayClientSoundAlias(SoundSystem, Alias);
        }
      }
    }
    cgameGlob->nvgInfo.activateBlindNow = 0;
  }
  if ( cgameGlob->nvgInfo.scriptBlindState == ACTIVE )
  {
    if ( !CG_VisionSetIsComplete(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time) )
      goto LABEL_42;
    cgameGlob->nvgInfo.scriptBlindState = 2;
    goto LABEL_41;
  }
  if ( cgameGlob->nvgInfo.scriptBlindState == 2 )
  {
    v12 = DCONST_DVARMPINT_NVG_ScriptBlind_Hold;
    v13 = time - cgameGlob->nvgInfo.scriptBlindStateStartTime;
    if ( v13 < 0 )
      v13 = 0;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlind_Hold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_Hold") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v12);
    if ( v13 >= v12->current.integer )
    {
      cgameGlob->nvgInfo.scriptBlindState = 3;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
      v14 = DCONST_DVARMPINT_NVG_ScriptBlind_BlendOut;
      if ( !DCONST_DVARMPINT_NVG_ScriptBlind_BlendOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_BlendOut") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v14);
      CG_VisionSetRegisterBlendStart(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time, v14->current.integer, 0, VISIONSETLERP_SMOOTH);
    }
  }
  else if ( (cgameGlob->nvgInfo.scriptBlindState == 3 || cgameGlob->nvgInfo.scriptBlindState == 4) && CG_VisionSetIsComplete(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time) )
  {
    cgameGlob->nvgInfo.scriptBlindState = INACTIVE;
LABEL_41:
    cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
  }
LABEL_42:
  if ( nvgAnimatingOff )
  {
    if ( !cgameGlob->NVGVisionStartTime )
      goto LABEL_51;
    v15 = DCONST_DVARMPINT_NVG_ScriptBlind_InterruptOffset;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlind_InterruptOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_InterruptOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v15);
    if ( time >= cgameGlob->NVGVisionStartTime + v15->current.integer )
      goto LABEL_51;
  }
  else if ( !nvgAnimatingOn && !BG_IsUsingNightVision(&cgameGlob->predictedPlayerState) )
  {
LABEL_51:
    if ( cgameGlob->nvgInfo.scriptBlindState )
    {
      cgameGlob->nvgInfo.scriptBlindState = INACTIVE;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
      CG_VisionSetSetBlendOff(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND);
    }
  }
}

/*
==============
CG_OffhandGestureWeaponHideParts
==============
*/
void CG_OffhandGestureWeaponHideParts(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  CgWeaponMap *Instance; 
  bool v7; 
  WeaponHand *v8; 
  DObj *viewModelDObj; 
  const XModel *gestureWeapModel; 
  int ModelIndex; 
  scr_string_t v12; 
  DObjPartBits *p_hidePartBits; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11197, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponIdx )
  {
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11205, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    if ( ViewModelHand->tree )
    {
      Instance = CgWeaponMap::GetInstance(localClientNum);
      v7 = BG_PlayerOrEntityDualWielding(Instance, &LocalClientGlobals->predictedPlayerState, NULL, NULL);
      if ( hand )
      {
        if ( hand == WEAPON_HAND_LEFT && !v7 )
          return;
      }
      else if ( v7 )
      {
        return;
      }
      CG_OffhandGestureWeapon_SetVisibilityState(localClientNum, hand);
      if ( LocalClientGlobals->gestureWeapInfo.shouldBeVisible != LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible )
      {
        v8 = cg_t::GetViewModelHand(LocalClientGlobals, hand);
        viewModelDObj = v8->viewModelDObj;
        if ( v8->viewModelDObj )
        {
          gestureWeapModel = LocalClientGlobals->gestureWeapInfo.gestureWeapModel;
          if ( gestureWeapModel )
          {
            ModelIndex = DObjGetModelIndex(v8->viewModelDObj, gestureWeapModel);
            v12 = *LocalClientGlobals->gestureWeapInfo.gestureWeapModel->boneNames;
            if ( v12 )
            {
              p_hidePartBits = &viewModelDObj->hidePartBits;
              if ( LocalClientGlobals->gestureWeapInfo.shouldBeVisible )
              {
                BG_ShowBone(v12, viewModelDObj, p_hidePartBits, ModelIndex);
                LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible = 1;
              }
              else
              {
                BG_HideBone(v12, viewModelDObj, p_hidePartBits, ModelIndex);
                LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible = 0;
              }
            }
          }
        }
      }
    }
  }
}

/*
==============
CG_OffhandGestureWeapon_IsInvisible
==============
*/
bool CG_OffhandGestureWeapon_IsInvisible(const LocalClientNum_t localClientNum, const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, const int offhandGesturesPlayingCount, const bool performingScriptedWeapon, const unsigned int scriptWeaponIdx, const unsigned int scriptWeaponSlot)
{
  unsigned int AvailableSlotCount; 
  bool v13; 
  const Gesture *AssetFromIndex; 
  unsigned int v15; 
  GestureAnimationState AnimationState; 
  int LastTreeRebuildTime; 
  GestureAnimationSettings *AnimationSettings; 
  CgWeaponMap *Instance; 
  bool v21; 
  unsigned int v22; 
  const WeaponHand *ViewModelHand; 
  const XAnimTree *tree; 
  double Weight; 
  double Time; 
  float v27; 
  double Rate; 
  float v29; 
  double Length; 
  weapAnimFiles_t outOutAnimation[4]; 
  weapAnimFiles_t outMainAnimation; 
  weapAnimFiles_t outInAnimation; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10889, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10890, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  AvailableSlotCount = BG_Gesture_GetAvailableSlotCount(ps);
  v13 = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xFu) && !AvailableSlotCount && offhandGesturesPlayingCount != 2;
  if ( cgameGlob->time - ps->weapCommon.offhandUseTime <= 99 || v13 )
    return 1;
  if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) && !cgameGlob->inKillCam || !performingScriptedWeapon )
    return 0;
  AssetFromIndex = BG_Gesture_GetAssetFromIndex(scriptWeaponIdx);
  if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10914, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
    __debugbreak();
  if ( AssetFromIndex->looping )
    return 0;
  v15 = scriptWeaponSlot;
  AnimationState = CG_Gesture_GetAnimationState(localClientNum, scriptWeaponSlot, hand);
  if ( AnimationState == GESTURE_ANIM_STATE_OFF )
    return 1;
  LastTreeRebuildTime = CG_Gesture_GetLastTreeRebuildTime(localClientNum, v15, hand);
  if ( LastTreeRebuildTime != BG_Gesture_GetStartTime(ps, v15) && AnimationState == GESTURE_ANIM_STATE_OUT )
    return 1;
  AnimationSettings = BG_Gesture_GetAnimationSettings(AssetFromIndex);
  if ( AnimationSettings->hasTransitions && AnimationState != GESTURE_ANIM_STATE_IN )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  v21 = BG_PlayerOrEntityDualWielding(Instance, ps, NULL, NULL);
  outMainAnimation = WEAP_ANIM_ROOT;
  outInAnimation = WEAP_ANIM_ROOT;
  outOutAnimation[0] = WEAP_ANIM_ROOT;
  CG_Gesture_GetWeaponAnims(AssetFromIndex, v15, hand, v21, &outMainAnimation, &outInAnimation, outOutAnimation);
  v22 = outMainAnimation;
  if ( AnimationSettings->hasTransitions )
    v22 = outInAnimation;
  ViewModelHand = cg_t::GetViewModelHand((cg_t *)cgameGlob, hand);
  if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10961, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  tree = ViewModelHand->tree;
  if ( !tree )
    return 1;
  Weight = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, v22);
  if ( *(float *)&Weight <= 0.0 )
    return 0;
  Time = XAnimGetTime(ViewModelHand->tree, 0, XANIM_SUBTREE_DEFAULT, v22);
  v27 = *(float *)&Time;
  Rate = XAnimGetRate(ViewModelHand->tree, 0, XANIM_SUBTREE_DEFAULT, v22);
  v29 = *(float *)&Rate;
  if ( *(float *)&Rate <= 0.000001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10973, ASSERT_TYPE_ASSERT, "(animRate > 1.0E-6)", (const char *)&queryFormat, "animRate > ZERO_EPSILON") )
    __debugbreak();
  Length = XAnimGetLength(ViewModelHand->tree->anims, v22);
  return (int)(float)((float)((float)(*(float *)&Length * v27) / v29) * 1000.0) <= 99;
}

/*
==============
CG_OffhandGestureWeapon_SetVisibilityState
==============
*/
void CG_OffhandGestureWeapon_SetVisibilityState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v4; 
  unsigned int v5; 
  int v6; 
  unsigned int scriptWeaponIdx; 
  bool v8; 
  bool performingScriptedWeapon; 
  bool v10; 
  const Gesture *AssetFromIndex; 
  const Gesture *v12; 
  const XAnimParts *v13; 
  double NotetrackTimeFromParts; 
  float v15; 
  double ElapsedTime; 
  float v17; 
  double AnimLengthInSeconds; 
  const Gesture *v19; 
  double v20; 
  float v21; 
  double v22; 
  float v23; 
  double v24; 
  bool IsStoppingByIndex; 
  const Gesture *v26; 
  GestureAnimationSettings *AnimationSettings; 
  double v28; 
  double v29; 
  float v30; 
  double v31; 
  const Gesture *v32; 
  double v33; 
  float v34; 
  double v35; 
  float v36; 
  double v37; 
  unsigned int v38; 
  unsigned int gestureIndex; 
  unsigned int GestureIdxForWeapon; 
  unsigned int outSlot; 
  unsigned int v42[4]; 
  bool IsPlayingByIndex; 
  bool v45; 
  unsigned int slot; 

  v2 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10993, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10996, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10998, ASSERT_TYPE_ASSERT, "(cgameGlob->gestureWeapInfo.offhandGestureWeapon.weaponIdx != 0)", (const char *)&queryFormat, "cgameGlob->gestureWeapInfo.offhandGestureWeapon.weaponIdx != WP_NONE") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v2];
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11006, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  GestureIdxForWeapon = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v4, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_THROW);
  v5 = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v4, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_PULLBACK);
  v6 = 0;
  gestureIndex = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v4, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_DETONATE);
  scriptWeaponIdx = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v4, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_WEAPON);
  IsPlayingByIndex = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, GestureIdxForWeapon, &outSlot);
  v45 = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, v5, &v38);
  v8 = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, gestureIndex, v42);
  performingScriptedWeapon = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, scriptWeaponIdx, &slot);
  if ( IsPlayingByIndex )
    v6 = 1;
  if ( v45 )
    ++v6;
  if ( v8 )
    ++v6;
  if ( !CG_OffhandGestureWeapon_IsInvisible((const LocalClientNum_t)v2, LocalClientGlobals, &LocalClientGlobals->predictedPlayerState, hand, v6, performingScriptedWeapon, scriptWeaponIdx, slot) )
  {
    if ( performingScriptedWeapon )
    {
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(scriptWeaponIdx);
      v12 = AssetFromIndex;
      if ( AssetFromIndex->looping )
        goto LABEL_45;
      v13 = *AssetFromIndex->anims;
      if ( v13 )
      {
        NotetrackTimeFromParts = XAnimGetNotetrackTimeFromParts(v13, scr_const.hide);
        v15 = *(float *)&NotetrackTimeFromParts;
        if ( *(float *)&NotetrackTimeFromParts >= 0.0 )
        {
          ElapsedTime = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, slot, LocalClientGlobals->time);
          v17 = *(float *)&ElapsedTime;
          AnimLengthInSeconds = BG_Gesture_GetAnimLengthInSeconds(v12);
          v10 = v17 < (float)(*(float *)&AnimLengthInSeconds * v15);
          goto LABEL_46;
        }
      }
    }
    else if ( IsPlayingByIndex )
    {
      v19 = BG_Gesture_GetAssetFromIndex(GestureIdxForWeapon);
      v20 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v19->anims, scr_const.hide);
      v21 = *(float *)&v20;
      if ( *(float *)&v20 >= 0.0 )
      {
        v22 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, outSlot, LocalClientGlobals->time);
        v23 = *(float *)&v22;
        v24 = BG_Gesture_GetAnimLengthInSeconds(v19);
        v10 = v23 < (float)(*(float *)&v24 * v21);
        goto LABEL_46;
      }
    }
    else if ( v45 )
    {
      IsStoppingByIndex = BG_Gesture_IsStoppingByIndex(&LocalClientGlobals->predictedPlayerState, v5);
      v26 = BG_Gesture_GetAssetFromIndex(v5);
      AnimationSettings = BG_Gesture_GetAnimationSettings(v26);
      if ( IsStoppingByIndex && (LocalClientGlobals->predictedPlayerState.weapCommon.offhandGestureFlags & 0x10) != 0 )
      {
        v28 = XAnimGetNotetrackTimeFromParts(*((const XAnimParts **)v26->anims + 11), scr_const.hide);
        if ( *(float *)&v28 >= 0.0 )
        {
          v10 = (float)((float)((float)AnimationSettings->outAnimLength * 0.001) * (float)(1.0 - *(float *)&v28)) < (float)((float)BG_Gesture_GetRemainingTime(&LocalClientGlobals->predictedPlayerState, v38, LocalClientGlobals->time) * 0.001);
          goto LABEL_46;
        }
      }
      else
      {
        v29 = XAnimGetNotetrackTimeFromParts(*((const XAnimParts **)v26->anims + 10), scr_const.show);
        v30 = *(float *)&v29;
        if ( *(float *)&v29 >= 0.0 )
        {
          v31 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, v38, LocalClientGlobals->time);
          v10 = *(float *)&v31 >= (float)((float)((float)AnimationSettings->inAnimLength * 0.001) * v30);
          goto LABEL_46;
        }
      }
    }
    else if ( v8 )
    {
      v32 = BG_Gesture_GetAssetFromIndex(gestureIndex);
      v33 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v32->anims, scr_const.hide);
      v34 = *(float *)&v33;
      if ( *(float *)&v33 >= 0.0 )
      {
        v35 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, v42[0], LocalClientGlobals->time);
        v36 = *(float *)&v35;
        v37 = BG_Gesture_GetAnimLengthInSeconds(v32);
        v10 = v36 < (float)(*(float *)&v37 * v34);
        goto LABEL_46;
      }
    }
    if ( (LocalClientGlobals->predictedPlayerState.weapCommon.offhandGestureFlags & 4) == 0 && !LocalClientGlobals->predictedPlayerState.weapCommon.offhandGestureFireTime )
    {
      v10 = 0;
      goto LABEL_46;
    }
LABEL_45:
    v10 = 1;
    goto LABEL_46;
  }
  v10 = 0;
LABEL_46:
  LocalClientGlobals->gestureWeapInfo.shouldBeVisible = v10;
}

/*
==============
CG_OffhandShield_CheckViewModelUpdate
==============
*/
bool CG_OffhandShield_CheckViewModelUpdate(const LocalClientNum_t localClientNum)
{
  return 0;
}

/*
==============
CG_OffhandShield_DamageFeedback
==============
*/
void CG_OffhandShield_DamageFeedback(LocalClientNum_t localClientNum, int sourceEntityNum, unsigned int eventParm, bool damaged)
{
  __int128 v4; 
  int v7; 
  unsigned int v8; 
  float v9; 
  cg_t *LocalClientGlobals; 
  viewDamage_t *LruDamageSlot; 
  const dvar_t *v12; 
  double v13; 
  double v14; 
  cg_t *v15; 
  CgHandler *Handler; 
  int clientNum; 
  CgHandler *v18; 
  team_t team; 
  CgStatic *LocalClientStatics; 
  const cg_t *v21; 
  const characterInfo_t *CharacterInfo; 
  double v23; 
  int v24; 
  int v25; 
  vec3_t angles; 
  vec3_t forward; 
  __int128 v28; 

  v7 = BYTE2(eventParm);
  v8 = eventParm >> 8;
  if ( v7 || (_BYTE)v8 )
  {
    v28 = v4;
    v9 = (float)v7 * 1.4117647;
    angles.v[2] = 0.0;
    angles.v[0] = (float)(unsigned __int8)v8 * 1.4117647;
    angles.v[1] = v9;
    AngleVectors(&angles, &forward, NULL, NULL);
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    LruDamageSlot = CG_PlayerState_FindLruDamageSlot(LocalClientGlobals);
    LruDamageSlot->time = LocalClientGlobals->snap->serverTime;
    v12 = DVARINT_cg_hudShieldDamageIconTime;
    if ( !DVARINT_cg_hudShieldDamageIconTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_hudShieldDamageIconTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v12);
    LruDamageSlot->duration = v12->current.integer;
    v13 = I_random();
    v14 = AngleNormalize360((float)((float)(*(float *)&v13 - 0.5) * 20.0) + v9);
    LruDamageSlot->inVehicle = 0;
    LruDamageSlot->yaw = *(float *)&v14;
    LruDamageSlot->type = 4;
    v15 = CG_GetLocalClientGlobals(localClientNum);
    Handler = CgHandler::getHandler(localClientNum);
    clientNum = v15->clientNum;
    v18 = Handler;
    team = TEAM_ZERO;
    LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)Handler->m_localClientNum);
    v21 = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
    if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    CharacterInfo = CG_GetCharacterInfo(v21, clientNum);
    if ( CharacterInfo )
      team = CharacterInfo->team;
    v24 = 0;
    v25 = sourceEntityNum;
    v18->GetEntityTeam(v18, (team_t *)&v24, sourceEntityNum, (unsigned int *)&v25);
    if ( team == v24 )
    {
      if ( team )
        LruDamageSlot->type = 5;
    }
    LruDamageSlot->dir = forward;
    AxisCopy(&LocalClientGlobals->refdef.view.axis, &LruDamageSlot->playerDir);
    v23 = vectoyaw((const vec2_t *)&LocalClientGlobals->refdef.view.axis);
    LruDamageSlot->playerYaw = *(float *)&v23;
  }
}

/*
==============
CG_OnOffhandKeyDown
==============
*/
void CG_OnOffhandKeyDown(LocalClientNum_t localClientNum, unsigned __int64 offhandButton)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v5; 
  CgHandler *Handler; 
  const Weapon *ViewmodelWeapon; 
  int v9; 

  v2 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v9 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v9) )
      __debugbreak();
  }
  if ( (clientUIActives[v2].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18417, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18427, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v5 = CgWeaponMap::ms_instance[v2];
  if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) || (Handler = CgHandler::getHandler((LocalClientNum_t)v2), PM_Weapon_IsInInterruptibleState(v5, &LocalClientGlobals->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler)) )
  {
    if ( BG_OffhandUnderbarrelInitAllowed(&LocalClientGlobals->predictedPlayerState) && (unsigned int)(LocalClientGlobals->predictedPlayerState.weapState[0].weaponState - 26) > 6 && BG_OffhandIsUnderbarrelWeapon(v5, &LocalClientGlobals->predictedPlayerState, offhandButton) )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18442, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
        __debugbreak();
      LocalClientGlobals->weaponSelectInAlt = 1;
      ViewmodelWeapon = BG_GetViewmodelWeapon(v5, &LocalClientGlobals->predictedPlayerState);
      if ( !BG_HasUnderbarrelWeapon(ViewmodelWeapon) )
      {
        if ( !BG_AnyUnderbarrelWeaponEquipped(v5, &LocalClientGlobals->predictedPlayerState) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18448, ASSERT_TYPE_ASSERT, "(BG_AnyUnderbarrelWeaponEquipped( weaponMap, ps ))", "%s\n\tAttempting to use offhand underbarrel weapon while none of the equipped weapons have an underbarrel weapon attachment.", "BG_AnyUnderbarrelWeaponEquipped( weaponMap, ps )") )
          __debugbreak();
        CG_Weapons_ToggleWeaponAltMode((LocalClientNum_t)v2);
      }
    }
  }
}

/*
==============
CG_OverrideImpactEffectType
==============
*/
void CG_OverrideImpactEffectType(const LocalClientNum_t localClientNum, const int sourceEntityNum, int *fxImpactType)
{
  centity_t *Entity; 
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  const dvar_t *v9; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v11; 
  int v12; 
  unsigned __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  bitarray<64> perks; 

  if ( (unsigned int)sourceEntityNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19644, ASSERT_TYPE_ASSERT, "(unsigned)( sourceEntityNum ) < (unsigned)( ( 2048 ) )", "sourceEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", sourceEntityNum, 2048) )
    __debugbreak();
  if ( !fxImpactType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19645, ASSERT_TYPE_ASSERT, "(fxImpactType)", (const char *)&queryFormat, "fxImpactType") )
    __debugbreak();
  Entity = CG_GetEntity(localClientNum, sourceEntityNum);
  LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
  if ( (Entity->flags & 1) != 0 && BG_IsCharacterEntity(&Entity->nextState) && (CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, Entity->nextState.number)) != NULL && CharacterInfo->infoValid )
    perks = CharacterInfo->perks;
  else
    perks = 0i64;
  v9 = DVARBOOL_bg_forceExplosiveBullets;
  if ( !DVARBOOL_bg_forceExplosiveBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_forceExplosiveBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
    *fxImpactType = CG_Main_RegisteredImpactTypeToImpactType((RegisteredImpactType)5);
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x22u);
  v11 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex >= 0 )
  {
    if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 )
    {
      LODWORD(v15) = 64;
      LODWORD(v14) = PerkNetworkPriorityIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v14, v15) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v11 & 0x1F)) & perks.array[v11 >> 5]) != 0 )
      *fxImpactType = CG_Main_RegisteredImpactTypeToImpactType((RegisteredImpactType)5);
  }
  v12 = BG_GetPerkNetworkPriorityIndex(0x1Cu);
  v13 = (unsigned int)v12;
  if ( v12 >= 0 )
  {
    if ( (unsigned int)v12 >= 0x40 )
    {
      LODWORD(v15) = 64;
      LODWORD(v14) = v12;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v14, v15) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v13 & 0x1F)) & perks.array[v13 >> 5]) != 0 )
      *fxImpactType = CG_Main_RegisteredImpactTypeToImpactType((RegisteredImpactType)4);
  }
}

/*
==============
CG_PlayBulletImpactEffect
==============
*/
void CG_PlayBulletImpactEffect(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, unsigned int targetScriptableIndex, const unsigned __int8 boneIndex, const vec3_t *position, const vec3_t *normal, const int surfType, const unsigned int impactFlags, FXRegisteredDef hitFx, const bool dismembermentAllowed)
{
  cg_t *LocalClientGlobals; 
  bool v15; 
  float v16; 
  const char *Name; 
  centity_t *Entity; 
  centity_t *v19; 
  const DObj *ClientDObj; 
  float v21; 
  float v22; 
  __int128 v23; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  const Material *markMaterialOverride; 
  unsigned int markEntnum; 
  centity_t *v33; 
  centity_t *v34; 
  const DObj *v35; 
  int ShouldDynamicBoltBullet; 
  vec3_t halfSize; 
  tmat33_t<vec3_t> left; 
  orientation_t orient; 

  ShouldDynamicBoltBullet = CGMovingPlatforms::ShouldDynamicBoltBullet(localClientNum, targetEntityNum);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v15 = surfType == 7 && (impactFlags & 4) == 0;
  v16 = normal->v[1];
  left.m[2].v[0] = normal->v[0];
  left.m[2].v[2] = normal->v[2];
  left.m[2].v[1] = v16;
  AxisRandomAroundForward(&left.m[2], left.m, &left.m[1]);
  if ( R_DecalVolumesMarks_DebugEnabled() )
  {
    halfSize.v[0] = FLOAT_0_5;
    halfSize.v[1] = FLOAT_1_5;
    halfSize.v[2] = FLOAT_1_0;
    R_DecalVolumesMarks_DebugAdd(position, &halfSize, &left, &colorCyan);
    Name = FXRegisteredDef::GetName(&hitFx);
    Com_Printf(21, "D+ CG mark: vfx: %s\n", Name);
  }
  if ( v15 )
  {
    Entity = CG_GetEntity(localClientNum, targetEntityNum);
    v19 = Entity;
    if ( (Entity->flags & 1) != 0 )
    {
      ClientDObj = Com_GetClientDObj(Entity->nextState.number, localClientNum);
      if ( ClientDObj )
      {
        if ( DObjIsValidBoneIndex(ClientDObj, boneIndex) && CG_Entity_GetBoneOrientation(localClientNum, v19->nextState.number, boneIndex, &orient) )
        {
          v21 = position->v[0] - orient.origin.v[0];
          v22 = position->v[2];
          v23 = LODWORD(position->v[1]);
          v24 = (float)((float)((float)(*(float *)&v23 - orient.origin.v[1]) * orient.axis.m[0].v[1]) + (float)(v21 * orient.axis.m[0].v[0])) + (float)((float)(v22 - orient.origin.v[2]) * orient.axis.m[0].v[2]);
          v25 = v21 - (float)(v24 * orient.axis.m[0].v[0]);
          v26 = (float)(v22 - orient.origin.v[2]) - (float)(v24 * orient.axis.m[0].v[2]);
          v27 = (float)(*(float *)&v23 - orient.origin.v[1]) - (float)(v24 * orient.axis.m[0].v[1]);
          *(float *)&v23 = fsqrt((float)((float)(v27 * v27) + (float)(v25 * v25)) + (float)(v26 * v26));
          _XMM1 = v23;
          __asm
          {
            vcmpless xmm0, xmm1, cs:__real@80000000
            vblendvps xmm0, xmm1, xmm10, xmm0
          }
          halfSize.v[0] = v25 * (float)(1.0 / *(float *)&_XMM0);
          halfSize.v[2] = v26 * (float)(1.0 / *(float *)&_XMM0);
          halfSize.v[1] = v27 * (float)(1.0 / *(float *)&_XMM0);
          OrthonormalBasis(&halfSize, &left);
        }
      }
    }
    if ( R_DecalVolumesMarks_DebugEnabled() )
    {
      halfSize.v[0] = FLOAT_0_625;
      halfSize.v[2] = FLOAT_1_25;
      halfSize.v[1] = FLOAT_2_0;
      R_DecalVolumesMarks_DebugAdd(position, &halfSize, &left, &colorOrange);
    }
  }
  markMaterialOverride = MARK_MATERIAL_OVERRIDE_NONE_2;
  if ( targetScriptableIndex == -1 || !ScriptableCl_GetLinkTypeEquals(localClientNum, targetScriptableIndex, SCRIPTABLE_LINK_DYNENT) || (markEntnum = ScriptableCl_GetLinkObject(localClientNum, targetScriptableIndex), markEntnum == -1) )
  {
    if ( ShouldDynamicBoltBullet )
    {
      FX_PlayDynamicBoltedEffect(localClientNum, &hitFx, LocalClientGlobals->time, targetEntityNum, position, &left, targetEntityNum, 1, 0, markMaterialOverride);
    }
    else
    {
      v33 = CG_GetEntity(localClientNum, targetEntityNum);
      v34 = v33;
      if ( (v33->flags & 1) != 0 && (v35 = Com_GetClientDObj(v33->nextState.number, localClientNum)) != NULL && DObjIsValidBoneIndex(v35, boneIndex) )
        FX_PlayBoltedOffsetEffectWithMarkEntity(localClientNum, &hitFx, LocalClientGlobals->time, v34->nextState.number, boneIndex, position, &left, !dismembermentAllowed << 7, targetEntityNum, 0, boneIndex, markMaterialOverride);
      else
        FX_PlayOrientedEffectWithMarkEntity(localClientNum, &hitFx, LocalClientGlobals->time, position, &left, 0, targetEntityNum, 0, boneIndex, markMaterialOverride);
    }
  }
  else
  {
    FX_PlayOrientedEffectWithMarkEntity(localClientNum, &hitFx, LocalClientGlobals->time, position, &left, 2u, markEntnum, 1, 0xFEu, markMaterialOverride);
  }
}

/*
==============
CG_PlayMissileProjectedConeSound
==============
*/
void CG_PlayMissileProjectedConeSound(LocalClientNum_t localClientNum, centity_t *cent)
{
  const dvar_t *v4; 
  cg_t *LocalClientGlobals; 
  float volumeScale; 
  float v7; 
  float v8; 
  SndAliasList *Alias; 
  SndAliasList *v10; 
  const SndAliasList *v11; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  const SndAliasList *v16; 
  float result_missile; 
  float result_line; 
  vec3_t outOrg; 
  __int64 v20; 
  MissileConeSoundVars mcv; 

  v20 = -2i64;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22009, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22010, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( cent->nextState.eType != ET_MISSILE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22011, ASSERT_TYPE_ASSERT, "(cent->nextState.eType == ET_MISSILE)", (const char *)&queryFormat, "cent->nextState.eType == ET_MISSILE") )
    __debugbreak();
  if ( CG_SetupAndValidateConeVars(localClientNum, cent, &mcv) )
  {
    if ( !mcv.alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22019, ASSERT_TYPE_ASSERT, "(mcv.alias)", (const char *)&queryFormat, "mcv.alias") )
      __debugbreak();
    v4 = DCONST_DVARBOOL_bg_missileDebugDraw;
    if ( DCONST_DVARBOOL_bg_missileDebugDraw )
    {
      Dvar_CheckFrontendServerThread(DCONST_DVARBOOL_bg_missileDebugDraw);
      if ( v4->current.enabled )
        DebugDrawMissileProjectedSound(&mcv);
    }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( (!GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, ACTIVE, 1u) || LocalClientGlobals->predictedPlayerState.remoteEyesEnt != cent->nextState.number) && (LocalClientGlobals->predictedPlayerState.linkFlags.m_flags[0] & 4) == 0 )
    {
      RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
      if ( !CalcDistanceFactors(&outOrg, &mcv, &result_line, &result_missile) || ((volumeScale = (float)((float)(mcv.volumescaleAtEdge - mcv.volumescaleAtCore) * NormalizeForMinMax(result_line, mcv.volumescaleCoreSize, 1.0)) + mcv.volumescaleAtCore, !mcv.pitchshiftEnabled) ? (v8 = FLOAT_1_0) : (v7 = NormalizeForMinMax(result_missile, mcv.pitchTopSize, 1.0 - mcv.pitchBottomSize), v8 = (float)((float)(mcv.pitchAtBottom - mcv.pitchAtTop) * v7) + mcv.pitchAtTop), (Alias = SND_FindAlias(mcv.alias), v10 = SND_FindAlias(mcv.aliasAtBase), v11 = v10, !Alias) || !v10) )
      {
LABEL_43:
        memset(&outOrg, 0, sizeof(outOrg));
        return;
      }
      if ( mcv.crossfadeEnabled )
      {
        if ( !mcv.aliasAtBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22073, ASSERT_TYPE_ASSERT, "(mcv.aliasAtBase)", (const char *)&queryFormat, "mcv.aliasAtBase") )
          __debugbreak();
        v12 = NormalizeForMinMax(result_missile, mcv.crossfadeTopSize, 1.0 - mcv.crossfadeBottomSize);
        v13 = v12;
        if ( Alias->head->assetId == v11->head->assetId )
        {
          SND_PlayBlendedSoundAliasAsync(Alias, v11, v12, localClientNum, cent->nextState.number, volumeScale, v8, &mcv.start, 0, SASYS_CGAME);
LABEL_38:
          if ( DVARBOOL_missileDebugText && Dvar_GetBool_Internal_DebugName(DVARBOOL_missileDebugText, "missileDebugText") )
          {
            Com_Printf(0, "Line:%.2f, Misl:%.2f  |  ", result_line, result_missile);
            Com_Printf(0, "Vol:%.2f, Pitch:%.2f", volumeScale, v8);
            if ( mcv.crossfadeEnabled )
              Com_Printf(0, ", XFade:%.2f", v13);
            Com_Printf(0, "\n");
          }
          goto LABEL_43;
        }
        v14 = (float)(1.0 - v12) * volumeScale;
        if ( v14 > 0.001 )
          SND_PlayScaledSoundAliasAsync(Alias, localClientNum, cent->nextState.number, v14, v8, &mcv.start, 0, SASYS_CGAME);
        if ( (float)(v12 * volumeScale) <= 0.001 )
          goto LABEL_38;
        v15 = v12 * volumeScale;
        v16 = v11;
      }
      else
      {
        v13 = 0.0;
        v15 = volumeScale;
        v16 = Alias;
      }
      SND_PlayScaledSoundAliasAsync(v16, localClientNum, cent->nextState.number, v15, v8, &mcv.start, 0, SASYS_CGAME);
      goto LABEL_38;
    }
  }
}

/*
==============
CG_PlayerUsingOutlineEnemiesTurret
==============
*/

bool __fastcall CG_PlayerUsingOutlineEnemiesTurret(LocalClientNum_t localClientNum, __int64 a2, double a3)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  bool result; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21515, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  r_weapon = *Handler->PlayerTurret(Handler, &LocalClientGlobals->predictedPlayerState);
  result = LOBYTE(a3);
  if ( LOWORD(a3) )
    return BG_ScopeOutlinesEnemies(&r_weapon, 0);
  return result;
}

/*
==============
CG_PlayerUsingScopedTurret
==============
*/

bool __fastcall CG_PlayerUsingScopedTurret(LocalClientNum_t localClientNum, __int64 a2, double a3)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  WeaponDef *v7; 
  __int64 v8; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21472, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  r_weapon = *Handler->PlayerTurret(Handler, &LocalClientGlobals->predictedPlayerState);
  if ( !LOWORD(a3) )
    return 0;
  if ( LOWORD(a3) > bg_lastParsedWeaponIndex )
  {
    LODWORD(v8) = LOWORD(a3);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v8, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[LOWORD(a3)] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  v7 = bg_weaponDefs[LOWORD(a3)];
  return BG_GetOverlay(&r_weapon, 0)->shaderMat || v7->overlayInterface == WEAPOVERLAYINTERFACE_TURRETSCOPE;
}

/*
==============
CG_PlayerUsingThermalTurret
==============
*/

bool __fastcall CG_PlayerUsingThermalTurret(LocalClientNum_t localClientNum, __int64 a2, double a3)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  bool result; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21496, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  r_weapon = *Handler->PlayerTurret(Handler, &LocalClientGlobals->predictedPlayerState);
  result = LOBYTE(a3);
  if ( LOWORD(a3) )
    return BG_HasThermalScope(&LocalClientGlobals->predictedPlayerState, &r_weapon, 0);
  return result;
}

/*
==============
CG_ProcessWeaponOnAltChange
==============
*/
void CG_ProcessWeaponOnAltChange(const LocalClientNum_t localClientNum, bool isAlternate)
{
  __int64 v2; 
  CgWeaponMap *v4; 
  cg_t *LocalClientGlobals; 
  int v6; 
  cg_t *v7; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v9; 
  DObj **p_viewModelDObj; 
  int *p_weapAnim; 
  int v12; 
  CgHandler *pmoveHandler; 
  weapAnimFiles_t v14; 
  bool v15; 
  __int64 bIsAlternate; 
  __int64 handIndex; 
  bool CanHybridToggle; 
  BgWeaponMap *weaponMap; 
  Weapon r_weapon; 

  v2 = localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v2];
  weaponMap = v4;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  v6 = 0;
  LocalClientGlobals->adsSettlePending = 0;
  LocalClientGlobals->adsSettleMaxADSFraction = 0.0;
  v7 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  r_weapon = *BG_GetViewmodelWeapon(v4, &v7->predictedPlayerState);
  CanHybridToggle = BG_CanHybridToggle(&v7->predictedPlayerState, &r_weapon, isAlternate);
  EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v4, &v7->predictedPlayerState, &r_weapon);
  v9 = !EquippedWeaponStateConst || !EquippedWeaponStateConst->hybridScope;
  p_viewModelDObj = &v7->m_weaponHand[0].viewModelDObj;
  p_weapAnim = &v7->predictedPlayerState.weapState[0].weapAnim;
  do
  {
    v12 = *p_weapAnim & 0xFFFFFF7F;
    pmoveHandler = CgHandler::getHandler((LocalClientNum_t)v2);
    v14 = BG_MapWeaponAnimStateToAnimIndex(weaponMap, &v7->predictedPlayerState, v12, 0, &r_weapon, isAlternate, (PlayerHandIndex)v6, pmoveHandler);
    v15 = !isAlternate && (unsigned int)(v14 - 326) <= 5;
    if ( (unsigned int)v6 >= 2 )
    {
      LODWORD(handIndex) = 2;
      LODWORD(bIsAlternate) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", bIsAlternate, handIndex) )
        __debugbreak();
    }
    if ( *p_viewModelDObj )
      BG_ShowHideTagsBasedOnAltMode(&r_weapon, *p_viewModelDObj, isAlternate, v15, v7->playerWeaponInfo.hideReticle, CanHybridToggle, v9);
    ++v6;
    p_weapAnim += 20;
    p_viewModelDObj += 5;
  }
  while ( v6 < 2 );
}

/*
==============
CG_RegisterWeapon
==============
*/
char CG_RegisterWeapon(LocalClientNum_t localClientNum, const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeaponFlags, const Weapon *weapon, ClientPlayerWeaponInfo *weapInfo)
{
  bool v10; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  bool v13; 
  SkydiveViewmodelState ViewmodelState; 
  int prevDualWielding; 
  bool v16; 
  bool v17; 
  const snapshot_t *snap; 
  __int64 v19; 
  char v20; 
  const char *WeaponName; 
  cg_t *v22; 
  char WeaponViewModelXAnimDefs; 
  unsigned int NumWeapons; 
  bool v25; 
  bool v26; 
  bool v27; 
  int v28; 
  DualWieldType dualWieldType; 
  unsigned int v30; 
  unsigned int carryObjectIndex; 
  const WeaponDef *v32; 
  char output[1024]; 

  if ( !weapon->weaponIdx )
    return 0;
  if ( weapon->weaponIdx >= BG_GetNumWeapons() )
  {
    NumWeapons = BG_GetNumWeapons();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9953, ASSERT_TYPE_ASSERT, "(unsigned)( weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", weapon->weaponIdx, NumWeapons) )
      __debugbreak();
  }
  v10 = !memcmp_0(&weapInfo->weapon, weapon, 0x3Cui64) || BG_WeaponsDifferOnlyInVariantForInstantSwitch(ps, prevWeaponFlags, &weapInfo->weapon, weapon);
  v32 = BG_WeaponDef(weapon, 0);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  Instance = CgWeaponMap::GetInstance(localClientNum);
  v28 = BG_PlayerDualWieldingWeapon(Instance, ps, weapon);
  dualWieldType = v32->dualWieldType;
  v25 = weapInfo->isAlternate != BG_UsingAlternate(ps);
  v13 = !memcmp_0(&weapInfo->weapon, weapon, 0x3Cui64) && weapInfo->meleeComboSeqIdx != ps->weapCommon.meleeComboSeqIdx;
  v26 = ViewModelScriptedStateChanged(localClientNum, ps);
  carryObjectIndex = weapInfo->carryObjectIndex;
  v30 = ps->carryState.carryObjectIndex;
  ViewmodelState = CG_Skydive_GetViewmodelState(localClientNum);
  prevDualWielding = LocalClientGlobals->prevDualWielding;
  v27 = ViewmodelState != weapInfo->skydiveViewmodelState;
  v16 = !prevDualWielding && LocalClientGlobals->prevLadderHand && v28;
  if ( prevDualWielding != v28 || v16 )
    v10 = 0;
  if ( dualWieldType == DUAL_WIELD_TYPE_ALT_MODE && v25 )
    v10 = 0;
  v17 = CG_Gesture_SetRebuildTree(localClientNum, ps, weapon);
  if ( !v10 || v13 || v17 || Com_GameMode_SupportsFeature(WEAPON_SPRINT_DROP|0x80) && (snap = CG_GetLocalClientGlobals(localClientNum)->snap) != NULL && (v19 = (__int64)snap->GetPlayerState(snap, (const LocalClientNum_t)localClientNum)) != 0 && *(_DWORD *)(v19 + 1124) != ps->demeanorState.targetState || v26 || carryObjectIndex != v30 || v27 )
  {
    v22 = CG_GetLocalClientGlobals(localClientNum);
    v22->adsSettlePending = 0;
    v22->adsSettleMaxADSFraction = 0.0;
    WeaponViewModelXAnimDefs = CG_CreateWeaponViewModelXAnimDefs(localClientNum, ps, weapon, weapInfo);
    v20 = WeaponViewModelXAnimDefs;
    if ( v13 || WeaponViewModelXAnimDefs )
      CG_Gesture_ForceRestoreAnims(localClientNum, ps, weapon);
  }
  else
  {
    if ( v25 )
      CG_Gesture_ForceRestoreAnims(localClientNum, ps, weapon);
    v20 = 0;
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|WEAPON_LADDER_AIM) && !v32->handXModel && BG_GetWeaponClass(weapon, 0) != WEAPCLASS_NON_PLAYER && BG_GetWeaponClass(weapon, 0) != WEAPCLASS_TURRET )
  {
    WeaponName = BG_GetWeaponName(weapon, output, 0x400u);
    Com_PrintError(17, "Weapon \"%s\" has no default view hands set.\n", WeaponName);
  }
  if ( !weapInfo->handModel || !v10 )
    weapInfo->handModel = v32->handXModel;
  weapInfo->weapon = *weapon;
  return v20;
}

/*
==============
CG_RemoveAttachmentFromList
==============
*/
__int64 CG_RemoveAttachmentFromList(unsigned int attachmentIndex, const WeaponAttachment **attachments, unsigned int attachmentCount)
{
  __int64 v6; 
  const WeaponAttachment **v7; 
  const WeaponAttachment *v8; 
  __int64 v9; 
  __int64 v11; 
  __int64 v12; 

  if ( attachmentCount > 0x1D && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22223, ASSERT_TYPE_ASSERT, "( attachmentCount ) <= ( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount not in [0, MAX_NUM_WEAPON_ATTACHMENTS]\n\t%u not in [0, %u]", attachmentCount, 29) )
    __debugbreak();
  if ( attachmentIndex >= attachmentCount )
  {
    LODWORD(v12) = attachmentCount;
    LODWORD(v11) = attachmentIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22224, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentIndex ) < (unsigned)( attachmentCount )", "attachmentIndex doesn't index attachmentCount\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  if ( !attachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22225, ASSERT_TYPE_ASSERT, "(attachments)", (const char *)&queryFormat, "attachments") )
    __debugbreak();
  v6 = attachmentIndex + 1;
  if ( (unsigned int)v6 < attachmentCount )
  {
    v7 = &attachments[v6];
    do
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22231, ASSERT_TYPE_ASSERT, "(attachments[nextAttachIndex])", (const char *)&queryFormat, "attachments[nextAttachIndex]") )
        __debugbreak();
      v8 = *v7++;
      v9 = attachmentIndex;
      attachmentIndex = v6;
      LODWORD(v6) = v6 + 1;
      attachments[v9] = v8;
    }
    while ( (unsigned int)v6 < attachmentCount );
  }
  if ( attachmentIndex >= attachmentCount )
  {
    LODWORD(v12) = attachmentCount;
    LODWORD(v11) = attachmentIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22235, ASSERT_TYPE_ASSERT, "(unsigned)( prevAttachIndex ) < (unsigned)( attachmentCount )", "prevAttachIndex doesn't index attachmentCount\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  attachments[attachmentIndex] = NULL;
  return attachmentCount - 1;
}

/*
==============
CG_SaveViewModelAnimTrees
==============
*/
void CG_SaveViewModelAnimTrees(MemoryFile *memFile, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  __int64 v3; 
  cg_t *LocalClientGlobals; 
  int v7; 
  bool v8; 
  WeaponHand *m_weaponHand; 
  const DObj *viewModelDObj; 
  __int64 v11; 
  __int64 v12; 

  v3 = localClientNum;
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13493, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  if ( (unsigned int)v3 >= 2 )
  {
    LODWORD(v11) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13494, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v11, 2) )
      __debugbreak();
  }
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  if ( BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v3], ps)->weaponIdx )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
    v7 = 0;
    v8 = 1;
    m_weaponHand = LocalClientGlobals->m_weaponHand;
    do
    {
      if ( !v8 )
      {
        LODWORD(v12) = 2;
        LODWORD(v11) = v7;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v11, v12) )
          __debugbreak();
      }
      if ( m_weaponHand->hasAnimTree )
      {
        viewModelDObj = m_weaponHand->viewModelDObj;
        if ( !m_weaponHand->viewModelDObj )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DEBA0, 613i64);
          viewModelDObj = m_weaponHand->viewModelDObj;
        }
        XAnimSaveAnimTreeWithVersion(viewModelDObj, memFile, 1u);
      }
      ++v7;
      ++m_weaponHand;
      v8 = (unsigned int)v7 < 2;
    }
    while ( v7 < 2 );
  }
}

/*
==============
CG_SelectNthPrimaryWeapon
==============
*/

void __fastcall CG_SelectNthPrimaryWeapon(LocalClientNum_t localClientNum, int nthIndex, double a3)
{
  int v3; 
  cg_t *LocalClientGlobals; 
  cg_t *v6; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  int i; 
  __int64 v10; 
  Weapon r_weapon; 

  v3 = nthIndex;
  if ( nthIndex < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21310, ASSERT_TYPE_ASSERT, "( nthIndex ) >= ( 0 )", "%s >= %s\n\t%i, %i", "nthIndex", "0", nthIndex, 0i64) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v6 = LocalClientGlobals;
  if ( LocalClientGlobals->nextSnap )
  {
    if ( WeaponCycleAllowed(LocalClientGlobals) )
    {
      p_predictedPlayerState = &v6->predictedPlayerState;
      if ( BG_IsPlayer(p_predictedPlayerState) && p_predictedPlayerState->pm_type < 7 && BG_GetNumWeapons() >= 2 )
      {
        Instance = CgWeaponMap::GetInstance(localClientNum);
        for ( i = 0; i < 15; ++i )
        {
          r_weapon = *BG_GetEquippedWeaponForPlayer(Instance, p_predictedPlayerState, i);
          if ( LOWORD(a3) && BG_WeaponDef(&r_weapon, 0)->inventoryType == WEAPINVENTORY_PRIMARY && BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, &r_weapon)->slot == WEAPON_SLOT_PRIMARY )
          {
            if ( v3 <= 0 )
            {
              if ( v3 )
              {
                LODWORD(v10) = v3;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21358, ASSERT_TYPE_ASSERT, "( nthIndex ) == ( 0 )", "%s == %s\n\t%i, %i", "nthIndex", "0", v10, 0i64) )
                  __debugbreak();
              }
              if ( BG_IsWeaponUsableInState(p_predictedPlayerState, &r_weapon) )
                CG_SelectWeapon(localClientNum, &r_weapon, 0);
              return;
            }
            --v3;
          }
        }
      }
    }
  }
}

/*
==============
CG_SelectWeapon
==============
*/
char CG_SelectWeapon(LocalClientNum_t localClientNum, const Weapon *weapon, int useAltMode)
{
  __int16 v3; 
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v8; 
  playerState_s *p_predictedPlayerState; 
  const dvar_t *v10; 
  const Weapon *v11; 
  const WeaponCompleteDef *v12; 
  const char *szInternalName; 
  const WeaponCompleteDef *v15; 
  bool v16; 
  int EquippedWeaponIndex; 
  __int64 v18; 
  bool v19; 
  unsigned int v20; 
  __m256i v21; 
  __int128 v22; 
  double v23; 
  int v24; 
  __int128 v25; 
  int v26; 
  double v27; 
  int ControllerFromClient; 
  unsigned __int16 ModelForController; 
  unsigned __int16 ModelFromPath; 
  bool v31; 
  char outHexString[128]; 

  v4 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[v4];
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( CG_HighPriorityWeapon_IsWeaponSwitchAllowed(v8, &LocalClientGlobals->predictedPlayerState, weapon) )
  {
    LocalClientGlobals->weaponSelectTime = LocalClientGlobals->time;
    v16 = memcmp_0(&LocalClientGlobals->weaponSelect, weapon, 0x3Cui64) != 0;
    v31 = v16;
    if ( !BG_HasUnderbarrelAmmo(weapon) )
      useAltMode = 0;
    if ( v16 )
    {
      if ( BG_HasUnderbarrelAmmo(weapon) )
      {
        if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1076, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
          __debugbreak();
        if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1077, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        EquippedWeaponIndex = BG_GetEquippedWeaponIndex(v8, &LocalClientGlobals->predictedPlayerState, weapon);
        useAltMode = 0;
        if ( EquippedWeaponIndex >= 0 )
        {
          v18 = EquippedWeaponIndex;
          if ( (playerState_s *)((char *)p_predictedPlayerState + 4 * v18) != (playerState_s *)-1540i64 && p_predictedPlayerState->weapEquippedData[v18].inAltMode )
            useAltMode = 1;
        }
      }
    }
    else if ( LocalClientGlobals->weaponSelectInAlt == useAltMode )
    {
      return 1;
    }
    if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1384, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v19 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
    if ( BG_WeaponDef(weapon, v19)->disableSwitchToWhenEmpty && !BG_WeaponAmmo(v8, &LocalClientGlobals->predictedPlayerState, weapon, v19) )
      return 0;
    if ( DVARBOOL_bg_giveAll && Dvar_GetBool_Internal_DebugName(DVARBOOL_bg_giveAll, "bg_giveAll") )
    {
      do
      {
        do
        {
          v20 = ((unsigned int)LocalClientGlobals->weaponSelect.weaponIdx + 1) % BG_GetNumWeapons();
          LocalClientGlobals->weaponSelect.weaponIdx = v20;
        }
        while ( !(_WORD)v20 );
      }
      while ( BG_WeaponDef(&LocalClientGlobals->weaponSelect, 0)->inventoryType );
    }
    else
    {
      *(__m256i *)&LocalClientGlobals->weaponSelect.weaponIdx = *(__m256i *)&weapon->weaponIdx;
      *(_OWORD *)&LocalClientGlobals->weaponSelect.attachmentVariationIndices[5] = *(_OWORD *)&weapon->attachmentVariationIndices[5];
      *(double *)&LocalClientGlobals->weaponSelect.attachmentVariationIndices[21] = *(double *)&weapon->attachmentVariationIndices[21];
      *(_DWORD *)&LocalClientGlobals->weaponSelect.weaponCamo = *(_DWORD *)&weapon->weaponCamo;
    }
    if ( weapon->weaponIdx && BG_WeaponDef(weapon, 0)->inventoryType )
    {
      v21 = *(__m256i *)&NULL_WEAPON.weaponIdx;
      v22 = *(_OWORD *)&NULL_WEAPON.attachmentVariationIndices[5];
      v23 = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
      v24 = *(_DWORD *)&NULL_WEAPON.weaponCamo;
    }
    else
    {
      v21 = *(__m256i *)&weapon->weaponIdx;
      v22 = *(_OWORD *)&weapon->attachmentVariationIndices[5];
      v23 = *(double *)&weapon->attachmentVariationIndices[21];
      v24 = *(_DWORD *)&weapon->weaponCamo;
    }
    if ( v3 )
    {
      v25 = *(_OWORD *)&LocalClientGlobals->weaponLatestPrimary.attachmentVariationIndices[5];
      v26 = *(_DWORD *)&LocalClientGlobals->weaponLatestPrimary.weaponCamo;
      *(__m256i *)&LocalClientGlobals->weaponPrevPrimary.weaponIdx = *(__m256i *)&LocalClientGlobals->weaponLatestPrimary.weaponIdx;
      v27 = *(double *)&LocalClientGlobals->weaponLatestPrimary.attachmentVariationIndices[21];
      *(__m256i *)&LocalClientGlobals->weaponLatestPrimary.weaponIdx = v21;
      *(_OWORD *)&LocalClientGlobals->weaponLatestPrimary.attachmentVariationIndices[5] = v22;
      *(_OWORD *)&LocalClientGlobals->weaponPrevPrimary.attachmentVariationIndices[5] = v25;
      *(double *)&LocalClientGlobals->weaponLatestPrimary.attachmentVariationIndices[21] = v23;
      *(double *)&LocalClientGlobals->weaponPrevPrimary.attachmentVariationIndices[21] = v27;
      *(_DWORD *)&LocalClientGlobals->weaponLatestPrimary.weaponCamo = v24;
      *(_DWORD *)&LocalClientGlobals->weaponPrevPrimary.weaponCamo = v26;
    }
    ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)v4);
    ModelForController = LUI_Model_GetModelForController(ControllerFromClient);
    ModelFromPath = LUI_Model_CreateModelFromPath(ModelForController, "cg.player.currentWeapon.shotCounter");
    LUI_Model_SetInt(ModelFromPath, 0);
    if ( !BG_HasUnderbarrelAmmo(&LocalClientGlobals->weaponSelect) )
      useAltMode = 0;
    LocalClientGlobals->weaponSelectInAlt = useAltMode;
    BG_ConvertWeaponToHexString(&LocalClientGlobals->weaponSelect, outHexString, 121);
    Com_Printf(17, "CG_SelectWeapon: cgameGlob->weaponSelect is set to %s. Alt mode is %d\n", outHexString, (unsigned int)LocalClientGlobals->weaponSelectInAlt);
    if ( v31 || !BG_IsAimDownSight(&LocalClientGlobals->weaponSelect, LocalClientGlobals->weaponSelectInAlt != 0) )
      CL_SetADS((LocalClientNum_t)v4, 0);
    return 1;
  }
  v10 = DVARBOOL_bg_highPriorityWeaponDebugPrint;
  if ( !DVARBOOL_bg_highPriorityWeaponDebugPrint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_highPriorityWeaponDebugPrint") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( !v10->current.enabled )
    return 0;
  v11 = BG_HighPriorityWeapon_Get(v8, &LocalClientGlobals->predictedPlayerState);
  if ( v11->weaponIdx )
  {
    szInternalName = BG_WeaponCompleteDef(v11, 0)->szInternalName;
    v15 = BG_WeaponCompleteDef(weapon, 0);
    Com_Printf(17, "HighPriorityDebug - CG_SelectWeapon: SelectWeapon for %s failed, CG_HighPriorityWeapon_IsWeaponSwitchAllowed returned false, highPriorityWeapon is %s\n", v15->szInternalName, szInternalName);
  }
  else
  {
    v12 = BG_WeaponCompleteDef(weapon, 0);
    Com_Printf(17, "HighPriorityDebug - CG_SelectWeapon: SelectWeapon for %s failed, CG_HighPriorityWeapon_IsWeaponSwitchAllowed returned false, and highPriorityWeapon is null.\n", v12->szInternalName);
  }
  return 0;
}

/*
==============
CG_SetADSAltSwitchGlobals
==============
*/
void CG_SetADSAltSwitchGlobals(LocalClientNum_t localClientNum, const playerState_s *ps, const WeaponHand *weapHand, const Weapon *weapon, const bool isAlternate, cg_t *cgameGlob)
{
  __int128 v6; 
  int weaponState; 
  bool v11; 
  double Weight; 
  unsigned int v13; 
  bool v14; 
  double v15; 
  bool v16; 
  bool v17; 
  bool v19; 
  int v20; 
  const WeaponAttachment *UnderbarrelAttachment; 
  bool adsAltSwitchIsMainToAlt; 
  float *p_fovInterpTimeSecMainToAlt; 
  float fovInterpTimeSecAltToMain; 
  float fovInterpDelaySecAltToMain; 
  AdsAltSwitch *adsAltSwitch; 
  float v28; 
  __int128 v29; 
  __int128 v30; 
  float v31; 
  __int128 v33; 
  CgWeaponMap *Instance; 
  double EffectiveFOVForWeapon; 
  bool cgameGloba; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8028, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weaponState = ps->weapState[0].weaponState;
  v11 = weaponState == 3 || weaponState == 10;
  Weight = XAnimGetWeight(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x14Au);
  v13 = 327;
  v14 = *(float *)&Weight > 0.0;
  v15 = XAnimGetWeight(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x147u);
  v16 = *(float *)&v15 > 0.0;
  v17 = weaponState && (v14 || *(float *)&v15 > 0.0 || v11);
  cgameGloba = cgameGlob->adsAltSwitchInProgress;
  if ( v17 )
  {
    v19 = cgameGlob->playerWeaponInfo.isAlternate;
    if ( v14 || *(float *)&v15 > 0.0 )
    {
      if ( v19 )
      {
        if ( *(float *)&v15 <= 0.0 )
          v13 = 330;
      }
      else if ( v14 )
      {
        v16 = 1;
        v13 = 330;
      }
      else
      {
        v16 = 0;
      }
      v14 = 1;
    }
    else
    {
      v20 = ps->weapState[0].weaponState;
      if ( v19 )
      {
        v16 = v20 == 3;
        if ( v20 != 3 )
          v13 = 330;
      }
      else
      {
        if ( v20 == 10 )
        {
          v16 = 1;
          v13 = 330;
        }
        else
        {
          v16 = 0;
        }
        v14 = 0;
      }
    }
    UnderbarrelAttachment = BG_GetUnderbarrelAttachment(weapon);
    if ( !UnderbarrelAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8124, ASSERT_TYPE_ASSERT, "(underBarrelAttachment)", (const char *)&queryFormat, "underBarrelAttachment") )
      __debugbreak();
    if ( !UnderbarrelAttachment->adsAltSwitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8125, ASSERT_TYPE_ASSERT, "(underBarrelAttachment->adsAltSwitch)", (const char *)&queryFormat, "underBarrelAttachment->adsAltSwitch") )
      __debugbreak();
    adsAltSwitchIsMainToAlt = cgameGlob->adsAltSwitchIsMainToAlt;
    if ( v16 )
    {
      cgameGlob->adsAltSwitchIsMainToAlt = 1;
      p_fovInterpTimeSecMainToAlt = &UnderbarrelAttachment->adsAltSwitch->fovInterpTimeSecMainToAlt;
      fovInterpTimeSecAltToMain = *p_fovInterpTimeSecMainToAlt;
      fovInterpDelaySecAltToMain = p_fovInterpTimeSecMainToAlt[1];
    }
    else
    {
      cgameGlob->adsAltSwitchIsMainToAlt = 0;
      adsAltSwitch = UnderbarrelAttachment->adsAltSwitch;
      fovInterpTimeSecAltToMain = adsAltSwitch->fovInterpTimeSecAltToMain;
      fovInterpDelaySecAltToMain = adsAltSwitch->fovInterpDelaySecAltToMain;
    }
    if ( v14 )
    {
      *(double *)&v6 = XAnimGetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v13);
      _XMM10 = v6;
    }
    else
    {
      _XMM10 = 0i64;
    }
    if ( v14 )
    {
      *(double *)&v6 = XAnimGetRate(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v13);
      v28 = *(float *)&v6;
      *(double *)&v6 = XAnimGetLength(weapHand->tree->anims, v13);
      v29 = v6;
      *(float *)&v29 = (float)(*(float *)&v6 * *(float *)&_XMM10) / v28;
      v30 = v29;
    }
    else
    {
      v30 = 0i64;
    }
    if ( *(float *)&v30 > fovInterpDelaySecAltToMain )
    {
      v33 = v30;
      *(float *)&v33 = *(float *)&v30 - fovInterpDelaySecAltToMain;
      _XMM0 = v33;
      __asm { vminss  xmm1, xmm0, xmm7 }
      if ( fovInterpTimeSecAltToMain > 0.0 )
        v31 = *(float *)&_XMM1 / fovInterpTimeSecAltToMain;
      else
        v31 = FLOAT_1_0;
    }
    else
    {
      v31 = 0.0;
    }
    cgameGlob->adsAltSwitchFOVFrac = v31;
    if ( !cgameGloba || adsAltSwitchIsMainToAlt != cgameGlob->adsAltSwitchIsMainToAlt )
    {
      Instance = CgWeaponMap::GetInstance(localClientNum);
      cgameGlob->adsAltSwitchCurrentWeaponIsDualFOV = BG_HasDualFOV(Instance, ps, weapon, !v16);
      cgameGlob->adsAltSwitchNextWeaponIsDualFOV = BG_HasDualFOV(Instance, ps, weapon, v16);
      EffectiveFOVForWeapon = CG_View_GetEffectiveFOVForWeapon(localClientNum, CG_FovSpace_Scene, weapon, !v16, 0, NULL);
      cgameGlob->adsAltSwitchBaseFOV = *(float *)&EffectiveFOVForWeapon;
    }
    _XMM0 = v16;
    __asm
    {
      vpcmpeqd xmm4, xmm0, xmm3
      vblendvps xmm0, xmm10, xmm5, xmm4; val
    }
    cgameGlob->adsAltSwitchInProgress = 1;
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, 0.0, 1.0);
    cgameGlob->altSwitchFrac = *(float *)&_XMM0;
  }
  else
  {
    *(_WORD *)&cgameGlob->adsAltSwitchNextWeaponIsDualFOV = 0;
    *(_QWORD *)&cgameGlob->adsAltSwitchBaseFOV = 0i64;
    cgameGlob->adsAltSwitchCurrentWeaponIsDualFOV = 0;
    cgameGlob->adsAltSwitchIsMainToAlt = 0;
    _XMM0 = BG_UsingAlternate(ps);
    __asm { vpcmpeqd xmm2, xmm0, xmm1 }
    _XMM1 = LODWORD(FLOAT_1_0);
    __asm { vblendvps xmm0, xmm1, xmm9, xmm2 }
    cgameGlob->altSwitchFrac = *(float *)&_XMM0;
  }
}

/*
==============
CG_SetViewModelPose
==============
*/
void CG_SetViewModelPose(const cg_t *cgameGlob, const bool sendingToRenderer, cpose_t *pose)
{
  const tmat33_t<vec3_t> *ViewModelTransform; 
  const dvar_t *v7; 
  __int128 v8; 
  __int128 v9; 
  __int128 v11; 
  void (__fastcall *v17)(const vec3_t *, vec4_t *); 
  vec3_t outOrg; 
  __int64 v19; 
  float v20; 
  float v21; 
  float v22; 

  v19 = -2i64;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14552, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !pose && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14553, ASSERT_TYPE_ASSERT, "(pose)", (const char *)&queryFormat, "pose") )
    __debugbreak();
  ViewModelTransform = (const tmat33_t<vec3_t> *)cg_t::GetViewModelTransform((cg_t *)cgameGlob);
  AxisToAngles(ViewModelTransform, &pose->angles);
  v7 = DVARBOOL_cg_enableViewModelMotionPrecisionFix;
  if ( !DVARBOOL_cg_enableViewModelMotionPrecisionFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableViewModelMotionPrecisionFix") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( sendingToRenderer && v7->current.enabled )
  {
    RefdefView_GetOrg(&cgameGlob->refdef.view, &outOrg);
    v8 = COERCE_UNSIGNED_INT64(cgameGlob->viewModelPlacementOffset.v[1] + outOrg.v[1] + cgameGlob->viewModelViewOffset.y);
    v9 = COERCE_UNSIGNED_INT64(cgameGlob->viewModelPlacementOffset.v[2] + outOrg.v[2] + cgameGlob->viewModelViewOffset.z);
    *((_QWORD *)&v11 + 1) = 0i64;
    *(double *)&v11 = (cgameGlob->viewModelPlacementOffset.v[0] + outOrg.v[0] + cgameGlob->viewModelViewOffset.x) * 4096.0;
    _XMM0 = v11;
    __asm { vcvttsd2si eax, xmm0 }
    v20 = _EAX;
    *((_QWORD *)&v11 + 1) = *((_QWORD *)&v8 + 1);
    *(double *)&v11 = *(double *)&v8 * 4096.0;
    _XMM1 = v11;
    __asm { vcvttsd2si eax, xmm1 }
    v21 = _EAX;
    *((_QWORD *)&v11 + 1) = *((_QWORD *)&v9 + 1);
    *(double *)&v11 = *(double *)&v9 * 4096.0;
    _XMM0 = v11;
    __asm { vcvttsd2si eax, xmm0 }
    v22 = _EAX;
    pose->isPosePrecise = 1;
    if ( !pose->origin.Set_origin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 494, ASSERT_TYPE_ASSERT, "(pose->origin.Set_origin)", (const char *)&queryFormat, "pose->origin.Set_origin") )
      __debugbreak();
    if ( !pose->isPosePrecise && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 495, ASSERT_TYPE_ASSERT, "(pose->isPosePrecise != 0)", (const char *)&queryFormat, "pose->isPosePrecise != 0") )
      __debugbreak();
    if ( pose->isEntityPose )
    {
      CG_Pose_ValidateSetEntityPoseOrigin(pose);
      pose->entOriginSet = 1;
      pose->hasStaleEntityPose = 1;
    }
    v17 = ObfuscateSetFunctionPointer_origin(pose->origin.Set_origin, pose);
    v17((const vec3_t *)&v20, &pose->origin.origin.origin);
    pose->actualOrigin.v[0] = v20;
    pose->actualOrigin.v[1] = v21;
    pose->actualOrigin.v[2] = v22;
    memset(&outOrg, 0, sizeof(outOrg));
  }
  else
  {
    pose->isPosePrecise = 0;
    CG_SetPoseOrigin(pose, ViewModelTransform[1].m);
  }
}

/*
==============
CG_SetupAndValidateConeVars
==============
*/
__int64 CG_SetupAndValidateConeVars(const LocalClientNum_t localClientNum, const centity_t *cent, MissileConeSoundVars *mcv)
{
  __int64 v5; 
  const Weapon *WeaponForEntity; 
  const WeaponDef *v7; 
  float missileConeSoundOriginOffset; 
  const char *name; 
  float missileConeSoundVolumescaleCoreSize; 
  bool missileConeSoundCrossfadeEnabled; 
  bool v12; 
  const char *WeaponName; 
  float crossfadeTopSize; 
  float crossfadeBottomSize; 
  const char *v16; 
  float pitchTopSize; 
  float pitchBottomSize; 
  const char *v19; 
  const char *v20; 
  unsigned __int8 v21; 
  const char *v22; 
  vec3_t outOrigin; 
  __int64 v25; 
  tmat33_t<vec3_t> axis; 
  char output[1024]; 

  v25 = -2i64;
  v5 = localClientNum;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21818, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21819, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( cent->nextState.eType != ET_MISSILE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21820, ASSERT_TYPE_ASSERT, "(cent->nextState.eType == ET_MISSILE)", (const char *)&queryFormat, "cent->nextState.eType == ET_MISSILE") )
    __debugbreak();
  if ( !mcv && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21821, ASSERT_TYPE_ASSERT, "(mcv)", (const char *)&queryFormat, "mcv") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  WeaponForEntity = BG_GetWeaponForEntity(CgWeaponMap::ms_instance[v5], &cent->nextState);
  v7 = BG_WeaponDef(WeaponForEntity, 0);
  if ( !v7->missileConeSoundEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21825, ASSERT_TYPE_ASSERT, "(weapDef->missileConeSoundEnabled)", (const char *)&queryFormat, "weapDef->missileConeSoundEnabled") )
    __debugbreak();
  AnglesToAxis(&cent->pose.angles, &axis);
  mcv->dir.v[0] = axis.m[0].v[0];
  mcv->dir.v[1] = axis.m[0].v[1];
  mcv->dir.v[2] = axis.m[0].v[2];
  CG_GetPoseOrigin(&cent->pose, &outOrigin);
  missileConeSoundOriginOffset = v7->missileConeSoundOriginOffset;
  mcv->start.v[0] = (float)(missileConeSoundOriginOffset * axis.m[0].v[0]) + outOrigin.v[0];
  mcv->start.v[1] = (float)(missileConeSoundOriginOffset * axis.m[0].v[1]) + outOrigin.v[1];
  mcv->start.v[2] = (float)(missileConeSoundOriginOffset * axis.m[0].v[2]) + outOrigin.v[2];
  SND_FindAlias(v7->missileConeSoundAlias.name);
  SND_FindAlias(v7->missileConeSoundAliasAtBase.name);
  mcv->alias = v7->missileConeSoundAlias.name;
  name = v7->missileConeSoundAliasAtBase.name;
  mcv->aliasAtBase = name;
  mcv->radiusAtTop = v7->missileConeSoundRadiusAtTop;
  mcv->radiusAtBase = v7->missileConeSoundRadiusAtBase;
  mcv->height = v7->missileConeSoundHeight;
  mcv->volumescaleAtCore = v7->missileConeSoundVolumescaleAtCore;
  mcv->volumescaleAtEdge = v7->missileConeSoundVolumescaleAtEdge;
  missileConeSoundVolumescaleCoreSize = v7->missileConeSoundVolumescaleCoreSize;
  mcv->volumescaleCoreSize = missileConeSoundVolumescaleCoreSize;
  mcv->pitchshiftEnabled = v7->missileConeSoundPitchshiftEnabled;
  mcv->pitchAtTop = v7->missileConeSoundPitchAtTop;
  mcv->pitchAtBottom = v7->missileConeSoundPitchAtBottom;
  mcv->pitchTopSize = v7->missileConeSoundPitchTopSize;
  mcv->pitchBottomSize = v7->missileConeSoundPitchBottomSize;
  missileConeSoundCrossfadeEnabled = v7->missileConeSoundCrossfadeEnabled;
  v12 = missileConeSoundCrossfadeEnabled;
  mcv->crossfadeEnabled = missileConeSoundCrossfadeEnabled;
  mcv->crossfadeTopSize = v7->missileConeSoundCrossfadeTopSize;
  mcv->crossfadeBottomSize = v7->missileConeSoundCrossfadeBottomSize;
  if ( missileConeSoundCrossfadeEnabled && !name )
  {
    WeaponName = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
    Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone crossfade settings.  Crossfade is enabled, but no second sound was given.\n", WeaponName);
    mcv->crossfadeEnabled = 0;
    missileConeSoundVolumescaleCoreSize = mcv->volumescaleCoreSize;
    v12 = 0;
  }
  if ( missileConeSoundVolumescaleCoreSize >= 0.0 )
  {
    if ( missileConeSoundVolumescaleCoreSize > 1.0 )
      mcv->volumescaleCoreSize = 1.0;
  }
  else
  {
    mcv->volumescaleCoreSize = 0.0;
  }
  if ( v12 )
  {
    crossfadeTopSize = mcv->crossfadeTopSize;
    if ( crossfadeTopSize < 0.0 )
    {
      mcv->crossfadeTopSize = 0.0;
      crossfadeTopSize = 0.0;
    }
    if ( crossfadeTopSize > 1.0 )
    {
      mcv->crossfadeTopSize = 1.0;
      crossfadeTopSize = FLOAT_1_0;
    }
    crossfadeBottomSize = mcv->crossfadeBottomSize;
    if ( crossfadeBottomSize < 0.0 )
    {
      mcv->crossfadeBottomSize = 0.0;
      crossfadeBottomSize = 0.0;
    }
    if ( crossfadeBottomSize > 1.0 )
    {
      mcv->crossfadeBottomSize = 1.0;
      crossfadeBottomSize = FLOAT_1_0;
    }
    if ( (float)(crossfadeBottomSize + crossfadeTopSize) > 1.0 )
    {
      v16 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
      Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone crossfade settings.  The top/bottom regions would overlap.\n", v16);
      mcv->crossfadeEnabled = 0;
      *(_QWORD *)&mcv->crossfadeTopSize = 0i64;
    }
  }
  if ( mcv->pitchshiftEnabled )
  {
    pitchTopSize = mcv->pitchTopSize;
    if ( pitchTopSize < 0.0 )
    {
      mcv->pitchTopSize = 0.0;
      pitchTopSize = 0.0;
    }
    if ( pitchTopSize > 1.0 )
    {
      mcv->pitchTopSize = 1.0;
      pitchTopSize = FLOAT_1_0;
    }
    pitchBottomSize = mcv->pitchBottomSize;
    if ( pitchBottomSize < 0.0 )
    {
      mcv->pitchBottomSize = 0.0;
      pitchBottomSize = 0.0;
    }
    if ( pitchBottomSize > 1.0 )
    {
      mcv->pitchBottomSize = 1.0;
      pitchBottomSize = FLOAT_1_0;
    }
    if ( (float)(pitchBottomSize + pitchTopSize) > 1.0 )
    {
      v19 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
      Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone pitch-shift settings.  The top/bottom regions would overlap.\n", v19);
      mcv->pitchshiftEnabled = 0;
      *(_QWORD *)&mcv->crossfadeTopSize = 0i64;
    }
  }
  if ( mcv->alias )
  {
    if ( mcv->height == 0.0 )
    {
      v22 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
      Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone height settings.  Zero height is invalid.\n", v22);
      v21 = 0;
    }
    else
    {
      v21 = 1;
    }
  }
  else
  {
    v20 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
    Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone height settings.  No sound is available to play.\n", v20);
    v21 = 0;
  }
  memset(&outOrigin, 0, sizeof(outOrigin));
  return v21;
}

/*
==============
CG_ShouldClearAnim
==============
*/
bool CG_ShouldClearAnim(LocalClientNum_t localClientNum, const playerState_s *ps, weapAnimFiles_t anim)
{
  cg_t *LocalClientGlobals; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2426, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  return (unsigned int)(anim - 175) > 1 && CG_CanModifyAnimWeight(ps, anim) && ((unsigned int)(anim - 15) > 0xC && (unsigned int)(anim - 123) > 0x27 && (unsigned int)(anim - 2) > 3 || !BG_Gesture_IsPlaying(ps, LocalClientGlobals->time, 0));
}

/*
==============
CG_ShouldTriggerOffhandShield
==============
*/
bool CG_ShouldTriggerOffhandShield(LocalClientNum_t localClientNum, int sourceEntityNum)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  int clientNum; 
  CgHandler *v7; 
  team_t team; 
  CgStatic *LocalClientStatics; 
  const cg_t *v10; 
  const characterInfo_t *CharacterInfo; 
  int v13; 
  int v14; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  Handler = CgHandler::getHandler(localClientNum);
  clientNum = LocalClientGlobals->clientNum;
  v7 = Handler;
  team = TEAM_ZERO;
  LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)Handler->m_localClientNum);
  v10 = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  CharacterInfo = CG_GetCharacterInfo(v10, clientNum);
  if ( CharacterInfo )
    team = CharacterInfo->team;
  v13 = 0;
  v14 = sourceEntityNum;
  v7->GetEntityTeam(v7, (team_t *)&v13, sourceEntityNum, (unsigned int *)&v14);
  return team == v13 && team;
}

/*
==============
CG_SmoothOutWeaponPos
==============
*/
void CG_SmoothOutWeaponPos(const int time, const float weaponPosFrac, WeaponPosFracAnimationData *const weaponPosFracAnimData, const bool isReloading, const bool isAdsUp)
{
  const dvar_t *v5; 
  int interpStartTime; 
  float v10; 
  double v11; 
  double v12; 

  v5 = DCONST_DVARMODEBOOL_adsPredictionSmoothingEnabled;
  if ( !DCONST_DVARMODEBOOL_adsPredictionSmoothingEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsPredictionSmoothingEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.enabled )
  {
    if ( weaponPosFracAnimData->lastWeaponPosFrac >= MIN_ADS_FRAC_FOR_CORRECTION && weaponPosFracAnimData->wasAdsUp && !weaponPosFracAnimData->interpStartTime && isReloading && !isAdsUp )
    {
      weaponPosFracAnimData->errorRate = weaponPosFracAnimData->lastWeaponPosFrac - weaponPosFrac;
      weaponPosFracAnimData->interpStartTime = time;
    }
    interpStartTime = weaponPosFracAnimData->interpStartTime;
    v10 = weaponPosFrac;
    if ( interpStartTime > 0 )
    {
      v11 = I_fclamp((float)(time - interpStartTime) / (float)ADS_FRAC_CATCH_UP_TIME, 0.0, 1.0);
      if ( *(float *)&v11 == 1.0 )
      {
        weaponPosFracAnimData->interpStartTime = 0;
      }
      else
      {
        v12 = I_fclamp((float)((float)(1.0 - *(float *)&v11) * weaponPosFracAnimData->errorRate) + weaponPosFrac, 0.0, 1.0);
        v10 = *(float *)&v12;
      }
    }
    weaponPosFracAnimData->lastWeaponPosFrac = weaponPosFrac;
    weaponPosFracAnimData->wasAdsUp = isAdsUp;
    weaponPosFracAnimData->correctedWeaponPosFrac = v10;
  }
  else
  {
    weaponPosFracAnimData->correctedWeaponPosFrac = weaponPosFrac;
  }
}

/*
==============
CG_SmoothOutWeaponPosFracForMispredictionErrors
==============
*/
void CG_SmoothOutWeaponPosFracForMispredictionErrors(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v3; 
  const Weapon *ViewmodelWeapon; 
  bool v5; 
  bool v6; 
  bool v7; 
  bool v8; 
  bool v9; 
  double v10; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8522, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v3 = CgWeaponMap::ms_instance[v1];
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8527, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(v3, &LocalClientGlobals->predictedPlayerState);
  v5 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
  v6 = (unsigned int)(LocalClientGlobals->predictedPlayerState.weapState[0].weaponState - 18) <= 3;
  v7 = v5;
  v8 = CG_Weapons_IsInAds((const LocalClientNum_t)v1, v3, &LocalClientGlobals->predictedPlayerState, ViewmodelWeapon, v5, WEAPON_HAND_DEFAULT);
  v9 = BG_ADSReloadEnabled(v3, &LocalClientGlobals->predictedPlayerState, ViewmodelWeapon, v7);
  CG_SmoothOutWeaponPos(LocalClientGlobals->time, LocalClientGlobals->predictedPlayerState.weapCommon.fWeaponPosFrac, &LocalClientGlobals->weaponPosFracAnimData, v6, v8);
  v10 = BG_WeaponADSFractionAffectedByReload(v3, &LocalClientGlobals->predictedPlayerState);
  if ( v9 )
    LocalClientGlobals->weaponPosFracNotReloadingAnimData.correctedWeaponPosFrac = *(float *)&v10;
  else
    CG_SmoothOutWeaponPos(LocalClientGlobals->time, *(const float *)&v10, &LocalClientGlobals->weaponPosFracNotReloadingAnimData, v6, v8);
}

/*
==============
CG_SndAutoSimEntLastBurst
==============
*/
void CG_SndAutoSimEntLastBurst(const centity_t *ent, const PlayerHandIndex hand)
{
  int *p_entNum; 
  __int64 v5; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22992, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  p_entNum = &s_snd_autosims[0].shot.entNum;
  v5 = 0i64;
  while ( !p_entNum[42] || *p_entNum != ent->nextState.number || p_entNum[23] != hand || p_entNum[45] != 2 )
  {
    v5 = (unsigned int)(v5 + 1);
    p_entNum += 48;
    if ( (unsigned int)v5 >= 0x40 )
      return;
  }
  s_snd_autosims[v5].shot.isLastBurst = 1;
}

/*
==============
CG_SndAutoSimReset
==============
*/
void CG_SndAutoSimReset(void)
{
  memset_0(s_snd_autosims, 0, sizeof(s_snd_autosims));
  s_autosim_time = Sys_Microseconds();
}

/*
==============
CG_SndKillAutoSimEnt
==============
*/
void CG_SndKillAutoSimEnt(centity_t *ent, bool bKillAggressively)
{
  int number; 
  int *p_used; 
  unsigned int i; 

  number = ent->nextState.number;
  p_used = &s_snd_autosims[0].used;
  for ( i = 0; i < 0x40; ++i )
  {
    if ( *p_used && *(p_used - 42) == number )
    {
      *((_BYTE *)p_used + 17) = 1;
      if ( bKillAggressively )
      {
        *p_used = 0;
        SND_StopAutoSim(i);
      }
    }
    p_used += 48;
  }
}

/*
==============
CG_SndKillAutoSimEntNum
==============
*/
void CG_SndKillAutoSimEntNum(int entityNum, bool bKillAggressively)
{
  int *p_used; 
  unsigned int i; 

  p_used = &s_snd_autosims[0].used;
  for ( i = 0; i < 0x40; ++i )
  {
    if ( *p_used && *(p_used - 42) == entityNum )
    {
      *((_BYTE *)p_used + 17) = 1;
      if ( bKillAggressively )
      {
        *p_used = 0;
        SND_StopAutoSim(i);
      }
    }
    p_used += 48;
  }
}

/*
==============
CG_SndPingAutoSim
==============
*/
void CG_SndPingAutoSim(LocalClientNum_t localClientNum, centity_t *cent, Weapon *weapon, const scr_string_t tagName, bool isPlayerView, bool isAlternate, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, bool isAlternatingFire, PlayerHandIndex hand, bool fireContinuously, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags)
{
  __int64 v16; 
  snd_autosim *v17; 
  unsigned int v18; 
  entityState_t *p_nextState; 
  bool *p_kill; 
  unsigned __int16 weaponIdx; 
  __int64 v22; 
  bool v23; 
  bool v24; 
  const WeaponCompleteDef *PointerToWeaponCompleteDefConst; 
  playerState_s *p_predictedPlayerState; 
  int shotCount; 
  bool v28; 
  const HyperBurstInfo *HyperBurstInfo; 
  unsigned __int8 v30; 
  unsigned int AllWeaponAttachments; 
  unsigned int v32; 
  WeaponAttachment **v33; 
  AttAmmoGeneral *ammogeneral; 
  bool v35; 
  snd_autosim *v36; 
  bool *p_isHyperBurst; 
  bool v38; 
  weapFireType_t fireType; 
  const HyperBurstInfo *v40; 
  bool v41; 
  const dvar_t *v42; 
  float v43; 
  float v44; 
  unsigned __int64 v45; 
  unsigned __int64 v46; 
  double v47; 
  float v48; 
  const WeaponSFXPackage *SfxPackage; 
  const SndWhizby *Whizby; 
  float speedOfSound; 
  int v52; 
  const centity_t *v53; 
  LocalClientNum_t v54; 
  CgWeaponSystem *WeaponSystem; 
  const centity_t *v56; 
  scr_string_t secondTagName; 
  PlayerHandIndex secondHand; 
  int index; 
  int fireTime; 
  snd_autosim *v63; 
  cpose_t *pose; 
  vec3_t outOrigin; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *v66; 
  vec3_t from; 
  unsigned __int64 v68; 
  int fireDelay; 
  __int64 v70; 
  WeaponAttachment *attachments[30]; 

  v70 = -2i64;
  pose = &cent->pose;
  v16 = localClientNum;
  v66 = (GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)pm_flags;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22711, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22712, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  v17 = NULL;
  v63 = NULL;
  index = -1;
  v18 = 0;
  p_nextState = &cent->nextState;
  p_kill = &s_snd_autosims[0].kill;
  while ( 1 )
  {
    if ( !*(_DWORD *)(p_kill - 17) )
    {
      if ( !v17 )
      {
        v17 = &s_snd_autosims[v18];
        index = v18;
      }
      goto LABEL_26;
    }
    if ( isAlternatingFire )
      break;
    if ( !*p_kill && *(_DWORD *)(p_kill - 185) == p_nextState->number && *(_WORD *)(p_kill - 181) == weapon->weaponIdx && *(_DWORD *)(p_kill - 97) == tagName && *(_DWORD *)(p_kill - 93) == hand && *(_DWORD *)(p_kill - 189) == (_DWORD)v16 )
    {
      v63 = &s_snd_autosims[v18];
      goto LABEL_41;
    }
LABEL_26:
    ++v18;
    p_kill += 192;
    if ( v18 >= 0x40 )
      goto LABEL_42;
  }
  if ( *p_kill )
    goto LABEL_26;
  if ( *(_DWORD *)(p_kill - 185) != p_nextState->number )
    goto LABEL_26;
  weaponIdx = weapon->weaponIdx;
  if ( *(_WORD *)(p_kill - 181) != weapon->weaponIdx || *(_DWORD *)(p_kill - 189) != (_DWORD)v16 || !*(p_kill - 75) )
    goto LABEL_26;
  v22 = v18;
  v63 = &s_snd_autosims[v22];
  v23 = s_snd_autosims[v22].shot.tagName == tagName && s_snd_autosims[v22].shot.hand == hand;
  v24 = s_snd_autosims[v22].shot.secondTagName == tagName && s_snd_autosims[v22].shot.secondHand == hand;
  if ( !v23 && !v24 )
  {
    PointerToWeaponCompleteDefConst = BG_GetPointerToWeaponCompleteDefConst(weaponIdx);
    if ( (s_snd_autosims[v22].shot.secondTagName || s_snd_autosims[v22].shot.secondHand != NUM_WEAPON_HANDS) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22747, ASSERT_TYPE_ASSERT, "((shot->secondTagName == ( static_cast< scr_string_t >( 0 ) ) && shot->secondHand == NUM_WEAPON_HANDS))", "%s\n\tEntity (%i) weapon (%s) configured to use turret alternating fire mode, but more than two muzzle tags were used.", "(shot->secondTagName == NULL_SCR_STRING && shot->secondHand == NUM_WEAPON_HANDS)", p_nextState->number, PointerToWeaponCompleteDefConst->szInternalName) )
      __debugbreak();
    s_snd_autosims[v22].shot.secondTagName = tagName;
    s_snd_autosims[v22].shot.secondHand = hand;
  }
LABEL_41:
  index = v18;
LABEL_42:
  p_predictedPlayerState = NULL;
  shotCount = 0;
  v28 = isPlayerView;
  if ( isPlayerView )
  {
    p_predictedPlayerState = &CG_GetLocalClientGlobals((const LocalClientNum_t)v16)->predictedPlayerState;
    shotCount = p_predictedPlayerState->weapState[hand].weaponShotCount;
  }
  if ( !CgWeaponMap::ms_instance[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  BG_GetFireTime(CgWeaponMap::ms_instance[v16], p_predictedPlayerState, weapon, isAlternate, 0, shotCount, &fireTime, &fireDelay);
  v68 = 1000 * fireTime;
  HyperBurstInfo = BG_GetHyperBurstInfo(weapon, isAlternate);
  if ( !HyperBurstInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22659, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
    __debugbreak();
  if ( HyperBurstInfo->enabled || (BG_WeaponDef(weapon, isAlternate)->fireType & 0xFFFFFFFD) == 0 )
  {
    v30 = 1;
  }
  else
  {
    v30 = 0;
    AllWeaponAttachments = BG_GetAllWeaponAttachments(weapon, (const WeaponAttachment **)attachments);
    v32 = 0;
    if ( AllWeaponAttachments )
    {
      v33 = attachments;
      while ( 1 )
      {
        if ( !*v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22674, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammogeneral = (*v33)->ammogeneral;
        if ( ammogeneral )
        {
          if ( (ammogeneral->fireType & 0xFFFFFFFD) == 0 )
            break;
        }
        ++v32;
        ++v33;
        v30 = 0;
        if ( v32 >= AllWeaponAttachments )
          goto LABEL_63;
      }
      v30 = 1;
    }
LABEL_63:
    LODWORD(v16) = localClientNum;
  }
  v35 = fireContinuously;
  v36 = v63;
  if ( v63 )
  {
    if ( !v63->used && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22795, ASSERT_TYPE_ASSERT, "(found_sim->used)", (const char *)&queryFormat, "found_sim->used") )
      __debugbreak();
    v17 = v36;
    p_isHyperBurst = &v36->isHyperBurst;
    if ( v36->isHyperBurst && !v36->processedHyperBurstRound )
    {
      v36->processedHyperBurstRound = 1;
      return;
    }
    v54 = localClientNum;
LABEL_116:
    if ( !*p_isHyperBurst || !v36 || v17->processedHyperBurstRound )
    {
      v17->lastPing = 0i64;
      v17->fireContinuously = v35;
      v17->fireTime = v68;
      ++v17->requestedShotCount;
      v17->shot.localClientNum = v54;
      v56 = (const centity_t *)pose;
      v17->shot.entNum = SLOWORD(pose[1].prevOrigin.prevOrigin.xyz.z);
      *(__m256i *)&v17->shot.weapon.weaponIdx = *(__m256i *)&weapon->weaponIdx;
      *(_OWORD *)&v17->shot.weapon.attachmentVariationIndices[5] = *(_OWORD *)&weapon->attachmentVariationIndices[5];
      *(double *)&v17->shot.weapon.attachmentVariationIndices[21] = *(double *)&weapon->attachmentVariationIndices[21];
      *(_DWORD *)&v17->shot.weapon.weaponCamo = *(_DWORD *)&weapon->weaponCamo;
      v17->shot.isPlayerView = v28;
      v17->shot.isAlternate = isAlternate;
      v17->shot.isPlayerHeli = isPlayerHeli;
      v17->shot.isDualWield = isDualWield;
      v17->shot.useLastFireSound = useLastFireSound;
      v17->shot.isAlternatingFire = isAlternatingFire;
      v17->shot.pm_flags = *v66;
      CG_FireWeaponSound_CalcOrigin(v54, v56, weapon, (const scr_string_t)v17->shot.tagName, v28, (const PlayerHandIndex)v17->shot.hand, &from);
      SndWeaponShotSetSecureOrigin(&from, &v17->shot.origin.origin);
      secondTagName = v17->shot.secondTagName;
      if ( secondTagName )
      {
        secondHand = v17->shot.secondHand;
        if ( secondHand != NUM_WEAPON_HANDS )
        {
          CG_FireWeaponSound_CalcOrigin(v54, v56, weapon, secondTagName, v28, secondHand, &from);
          SndWeaponShotSetSecureOrigin(&from, &v17->shot.secondShotOrigin.origin);
          v17->shot.secondShotOriginValid = 1;
        }
      }
      memset(&from, 0, sizeof(from));
    }
  }
  else if ( v17 )
  {
    if ( v17->used && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22809, ASSERT_TYPE_ASSERT, "(!free_sim->used)", (const char *)&queryFormat, "!free_sim->used") )
      __debugbreak();
    v17->fireType = BG_GetWeaponFireType(weapon, isAlternate);
    if ( isPlayerView || Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
    {
      fireType = v17->fireType;
      v38 = ((fireType - 1) & 0xFFFFFFFC) == 0 && fireType != WEAPON_FIRETYPE_BURST;
    }
    else
    {
      v38 = !fireContinuously;
    }
    v40 = BG_GetHyperBurstInfo(weapon, isAlternate);
    if ( !v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22825, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
      __debugbreak();
    if ( (!v38 || v40->enabled) && v68 < 0x493E0 && fireTime )
    {
      v41 = v17->fireType == WEAPON_FIRETYPE_FULLAUTO && !useLastFireSound;
      v42 = DCONST_DVARFLT_snd_autoSim_predictWindowMs;
      if ( !DCONST_DVARFLT_snd_autoSim_predictWindowMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_autoSim_predictWindowMs") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v42);
      v44 = v42->current.value * 1000.0;
      v43 = v44;
      v45 = 0i64;
      if ( v44 >= 9.223372e18 )
      {
        v43 = v44 - 9.223372e18;
        if ( (float)(v44 - 9.223372e18) < 9.223372e18 )
          v45 = 0x8000000000000000ui64;
      }
      v46 = 2 * (v45 + (unsigned int)(int)v43);
      if ( !v41 )
        v46 = 0i64;
      if ( isPlayerView || isPlayerHeli )
      {
        v48 = 0.0;
      }
      else
      {
        CG_GetPoseOrigin(pose, &outOrigin);
        v47 = SND_DistSqToNearestListener(&outOrigin);
        v48 = *(float *)&v47;
        SfxPackage = BG_GetSfxPackage(weapon, isAlternate);
        Whizby = SND_GetWhizby(SfxPackage);
        if ( Whizby )
          speedOfSound = Whizby->speedOfSound;
        else
          speedOfSound = 0.0;
        if ( speedOfSound > 0.0 )
          v46 += (int)(float)(fsqrt(*(float *)&v47) * (float)(1000000.0 / speedOfSound));
        memset(&outOrigin, 0, sizeof(outOrigin));
      }
      v17->time = 0i64;
      v17->nextStamp = v46;
      v17->distSq = v48;
      v17->used = 1;
      *(_QWORD *)&v17->shotCount = 0i64;
      v52 = s_snd_autosim_next_id++;
      v17->autoSimId = SND_CreateAutoSimId(index, v52);
      v17->countShots = v30;
      p_isHyperBurst = &v17->isHyperBurst;
      v17->isHyperBurst = v40->enabled;
      v17->processedHyperBurstRound = 0;
      v17->kill = 0;
      v17->shot.tagName = tagName;
      v17->shot.hand = hand;
      v17->shot.fireSecondTag = 0;
      v17->shot.secondTagName = 0;
      v17->shot.secondHand = NUM_WEAPON_HANDS;
      *(_WORD *)&v17->shot.isLastBurst = 0;
      v53 = (const centity_t *)pose;
      v54 = localClientNum;
      if ( BG_IsCharacterEntity((const entityState_t *)&pose[1].prevOrigin.prevOrigin.xyz.z) )
      {
        WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
        CG_GetPoseOrigin(&v53->pose, &outOrigin);
        if ( WeaponSystem->ShouldWeaponPing(WeaponSystem, v53, weapon, isAlternate, &outOrigin) )
          CG_SndPingCompass(localClientNum, v53, weapon, isAlternate, &outOrigin);
        memset(&outOrigin, 0, sizeof(outOrigin));
      }
      v35 = fireContinuously;
      v28 = isPlayerView;
      v36 = v63;
      goto LABEL_116;
    }
    CG_FireWeapSound((const LocalClientNum_t)v16, (centity_t *)pose, weapon, tagName, isPlayerView, isAlternate, isPlayerHeli, isDualWield, useLastFireSound, hand, -1, 0i64, 0.0, (const SndWeapShotCountId)v30, v66);
  }
  else
  {
    Com_Printf(9, "WARNING: ran out of automatic sims??? (max %d)\n", 64i64);
    CG_FireWeapSound((const LocalClientNum_t)v16, (centity_t *)pose, weapon, tagName, isPlayerView, isAlternate, isPlayerHeli, isDualWield, useLastFireSound, hand, -1, 0i64, 0.0, (const SndWeapShotCountId)v30, v66);
  }
}

/*
==============
CG_SndPingCompass
==============
*/
void CG_SndPingCompass(LocalClientNum_t localClientNum, const centity_t *cent, const Weapon *weapon, bool isAlternate, const vec3_t *origin)
{
  const dvar_t *v9; 
  const char *v10; 
  float value; 
  CgCompassSystem *CompassSystem; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18581, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18582, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( BG_IsSilenced(weapon, isAlternate) )
  {
    v9 = DCONST_DVARFLT_compassSilencedSoundPingDuration;
    if ( DCONST_DVARFLT_compassSilencedSoundPingDuration )
      goto LABEL_14;
    v10 = "compassSilencedSoundPingDuration";
  }
  else
  {
    v9 = DCONST_DVARMPSPFLT_compassSoundPingDuration;
    if ( DCONST_DVARMPSPFLT_compassSoundPingDuration )
      goto LABEL_14;
    v10 = "compassSoundPingDuration";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v10) )
    __debugbreak();
LABEL_14:
  Dvar_CheckFrontendServerThread(v9);
  value = v9->current.value;
  CompassSystem = CgCompassSystem::GetCompassSystem(localClientNum);
  CompassSystem->AddWeaponPingInfo(CompassSystem, cent, origin, (int)(float)(value * 1000.0));
}

/*
==============
CG_SndUpdateAutoSim
==============
*/
void CG_SndUpdateAutoSim(void)
{
  unsigned __int64 v0; 
  unsigned __int64 v1; 
  double TimeScale; 
  float v3; 
  float v4; 
  float v5; 
  float v6; 
  unsigned __int64 v7; 
  unsigned __int64 v8; 
  int i; 

  v0 = Sys_Microseconds();
  Sys_ProfBeginNamedEvent(0xFFFAEBD7, "CG_SndUpdateAutoSim");
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23030, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( cg_maxLocalClients )
  {
    v1 = s_autosim_time;
    if ( v0 < s_autosim_time )
      v1 = v0;
    s_autosim_time = v1;
    TimeScale = Com_GetTimeScale();
    v3 = (float)(__int64)(v0 - s_autosim_time);
    if ( (__int64)(v0 - s_autosim_time) < 0 )
    {
      v4 = (float)(__int64)(v0 - s_autosim_time);
      v3 = v4 + 1.8446744e19;
    }
    v6 = *(float *)&TimeScale * v3;
    v5 = v6;
    v7 = 0i64;
    if ( v6 >= 9.223372e18 )
    {
      v5 = v6 - 9.223372e18;
      if ( (float)(v6 - 9.223372e18) < 9.223372e18 )
        v7 = 0x8000000000000000ui64;
    }
    v8 = v7 + (unsigned int)(int)v5;
    s_autosim_time = v0;
    if ( !CL_Pause_IsGamePaused() )
    {
      for ( i = 0; i < 64; ++i )
        CG_SndUpdateSingleAutoSim(i, v8);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_SndUpdateSingleAutoSim
==============
*/
void CG_SndUpdateSingleAutoSim(int autosimIndex, unsigned __int64 dt)
{
  snd_autosim *v3; 
  const dvar_t *v4; 
  float v5; 
  float v6; 
  unsigned __int64 v7; 
  unsigned __int64 v8; 
  unsigned __int64 time; 
  unsigned __int64 nextStamp; 
  centity_t *Entity; 
  weapFireType_t WeaponFireType; 
  weapFireType_t v13; 
  int WeaponBurstCount; 
  SndWeapShotCountId shotCount; 
  unsigned int v16; 
  unsigned int v17; 
  char v18; 
  const vec3_t *p_origin; 
  bool useLastFireSound; 
  PlayerHandIndex hand; 
  unsigned __int64 fireTime; 
  unsigned __int64 v23; 
  vec3_t to; 

  v3 = &s_snd_autosims[autosimIndex];
  if ( v3->used )
  {
    v3->lastPing += dt;
    if ( v3->lastPing > 0x493E0 || v3->shot.isPlayerView && (unsigned int)(CG_GetLocalClientGlobals((const LocalClientNum_t)v3->shot.localClientNum)->predictedPlayerState.weapState[v3->shot.hand].weaponState - 18) <= 3 )
      v3->kill = 1;
    if ( v3->kill && v3->shotCount >= v3->requestedShotCount )
      goto LABEL_8;
    v3->time += dt;
    v4 = DCONST_DVARFLT_snd_autoSim_predictWindowMs;
    if ( !DCONST_DVARFLT_snd_autoSim_predictWindowMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_autoSim_predictWindowMs") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v4);
    v6 = v4->current.value * 1000.0;
    v5 = v6;
    v7 = 0i64;
    if ( v6 >= 9.223372e18 )
    {
      v5 = v6 - 9.223372e18;
      if ( (float)(v6 - 9.223372e18) < 9.223372e18 )
        v7 = 0x8000000000000000ui64;
    }
    v8 = v7 + (unsigned int)(int)v5;
    time = v3->time;
    nextStamp = v3->nextStamp;
    if ( time > nextStamp || nextStamp - time <= v8 )
    {
      Entity = CG_GetEntity((const LocalClientNum_t)v3->shot.localClientNum, v3->shot.entNum);
      WeaponFireType = BG_GetWeaponFireType(&v3->shot.weapon, v3->shot.isAlternate);
      v13 = WeaponFireType;
      if ( !v3->fireContinuously && WeaponFireType == WEAPON_FIRETYPE_BURST && v3->shotCount >= BG_GetWeaponBurstCount(&v3->shot.weapon, v3->shot.isAlternate) || v3->isHyperBurst && ((v13 - 1) & 0xFFFFFFFC) == 0 && v13 != WEAPON_FIRETYPE_BURST && v3->shotCount && (v3->shot.useLastFireSound || v3->processedHyperBurstRound) )
      {
LABEL_8:
        v3->used = 0;
        return;
      }
      if ( (Entity->flags & 1) != 0 )
      {
        WeaponBurstCount = 0;
        shotCount = SND_WEAP_SHOT_UNCOUNTED;
        if ( v3->countShots )
        {
          v16 = v3->shotCount;
          if ( v16 )
          {
            v17 = v16 - 1;
            if ( v17 )
            {
              if ( v17 == 1 )
                shotCount = SND_WEAP_SHOT_THIRD;
            }
            else
            {
              shotCount = SND_WEAP_SHOT_SECOND;
            }
          }
          else
          {
            shotCount = SND_WEAP_SHOT_FIRST;
          }
        }
        if ( v3->shot.fireSecondTag && v3->shot.secondShotOriginValid )
        {
          v18 = 1;
          if ( v3->shot.secondHand == NUM_WEAPON_HANDS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22599, ASSERT_TYPE_ASSERT, "(pShot->secondHand != NUM_WEAPON_HANDS)", (const char *)&queryFormat, "pShot->secondHand != NUM_WEAPON_HANDS") )
            __debugbreak();
          if ( !v3->shot.secondTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22600, ASSERT_TYPE_ASSERT, "(pShot->secondTagName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "pShot->secondTagName != NULL_SCR_STRING") )
            __debugbreak();
          if ( !v3->shot.secondShotOriginValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1411, ASSERT_TYPE_ASSERT, "(shot->secondShotOriginValid)", (const char *)&queryFormat, "shot->secondShotOriginValid") )
            __debugbreak();
          p_origin = &v3->shot.secondShotOrigin.origin;
        }
        else
        {
          v18 = 0;
          p_origin = &v3->shot.origin.origin;
        }
        SndWeaponShotGetSecureOrigin(p_origin, &to);
        useLastFireSound = v3->shot.useLastFireSound && v3->shotCount >= v3->requestedShotCount - 1;
        if ( v3->shot.isLastBurst && Dvar_GetBool_Internal_DebugName(DVARBOOL_killswitch_burst_fire_lastshot_enabled, "killswitch_burst_fire_lastshot_enabled") )
        {
          if ( v13 == WEAPON_FIRETYPE_BURST )
            WeaponBurstCount = BG_GetWeaponBurstCount(&v3->shot.weapon, v3->shot.isAlternate);
          if ( WeaponBurstCount <= (signed int)(v3->shotCount + 1) )
            useLastFireSound = 1;
        }
        if ( v18 )
          hand = v3->shot.secondHand;
        else
          hand = v3->shot.hand;
        CG_FireWeapSound_KnownOrigin((const LocalClientNum_t)v3->shot.localClientNum, Entity, &v3->shot.weapon, v3->shot.isPlayerView, v3->shot.isAlternate, v3->shot.isPlayerHeli, v3->shot.isDualWield, useLastFireSound, hand, v3->autoSimId, v3->nextStamp, v3->distSq, shotCount, &v3->shot.pm_flags, &to);
        if ( v3->shot.isAlternatingFire )
          v3->shot.fireSecondTag = !v3->shot.fireSecondTag;
        if ( useLastFireSound )
          v3->kill = 1;
        memset(&to, 0, sizeof(to));
      }
      fireTime = v3->fireTime;
      v23 = v3->time;
      do
        v3->nextStamp += fireTime;
      while ( v3->nextStamp < v23 && fireTime );
      ++v3->shotCount;
    }
  }
}

/*
==============
CG_SndUpdateSubmix
==============
*/
void CG_SndUpdateSubmix(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  bool v3; 
  const char *ActionCamSubmixName; 
  const char *v5; 
  char v6; 
  unsigned int v7; 
  char v8; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = !CL_IsRenderingSplitScreen() && CG_Utils_IsActionCamActive(localClientNum);
  if ( v3 != LocalClientGlobals->firstPersonHelmetSubmixActive )
  {
    ActionCamSubmixName = BG_GetActionCamSubmixName();
    v5 = ActionCamSubmixName;
    if ( ActionCamSubmixName && (v6 = *ActionCamSubmixName) != 0 )
    {
      v7 = 5381;
      do
      {
        ++v5;
        v8 = v6 | 0x20;
        if ( (unsigned int)(v6 - 65) >= 0x1A )
          v8 = v6;
        v7 = 65599 * v7 + v8;
        v6 = *v5;
      }
      while ( *v5 );
      if ( !v7 )
        v7 = 1;
    }
    else
    {
      v7 = 0;
    }
    if ( v3 )
    {
      SND_SubmixAddFromSource(SND_SUBMIX_TYPE_GAMECODE, v7, 0.0, 1.0);
      LocalClientGlobals->firstPersonHelmetSubmixActive = v3;
    }
    else
    {
      SND_SubmixClearFromSource(SND_SUBMIX_TYPE_GAMECODE, v7, 0.0);
      LocalClientGlobals->firstPersonHelmetSubmixActive = 0;
    }
  }
}

/*
==============
CG_StartSprintAdditive
==============
*/
void CG_StartSprintAdditive(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj, const Weapon *weapon, const WeaponHand *weaponHand, const PlayerHandIndex handIndex, const WeaponAnimNumber prevAnim, const weapAnimFiles_t prevAnimIndex, const WeaponAnimNumber anim, const weapAnimFiles_t animIndex)
{
  float v14; 
  float v15; 
  const WeaponHand *v16; 
  XAnim_s *v17; 
  signed int v18; 
  WeaponAnimNumber v19; 
  double v20; 
  char v21; 
  const XAnimTree *v22; 
  unsigned int v23; 
  unsigned int *v24; 
  double v25; 
  double v26; 
  char v27; 
  PlayerHandIndex v28; 
  Weapon *v29; 
  const XAnimTree *v30; 
  double GoalWeight; 
  float v32; 
  CgHandler *v33; 
  double Length; 
  const dvar_t *v35; 
  CgHandler *v36; 
  const XAnimTree *Tree; 
  double Weight; 
  double GoalTime; 
  float v40; 
  float v41; 
  double v42; 
  double Float_Internal_DebugName; 
  double v44; 
  double Rate; 
  CgHandler *Handler; 
  PlayerHandIndex v47; 
  float WeaponStateModifiedAnimRate; 
  CgHandler *v49; 
  XAnim_s *anims; 
  float blendInTime; 
  float blendOutTime; 
  Weapon *weapona; 

  weapona = (Weapon *)weapon;
  v14 = 0.0;
  v15 = FLOAT_1_0;
  blendOutTime = 0.0;
  blendInTime = 0.0;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8229, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8230, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v16 = weaponHand;
  if ( !weaponHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8231, ASSERT_TYPE_ASSERT, "(weaponHand)", (const char *)&queryFormat, "weaponHand") )
    __debugbreak();
  v17 = XAnimGetAnims(v16->tree);
  v18 = animIndex;
  v19 = anim;
  anims = v17;
  LODWORD(weaponHand) = GetAnimBlendTimes(localClientNum, weapon, ps, prevAnim, prevAnimIndex, anim, animIndex, &blendOutTime, &blendInTime);
  if ( BG_IsSuperSprinting(ps) )
    return;
  if ( v19 != WEAP_SPRINT_IN )
  {
    Tree = DObjGetTree(obj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8302, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu);
    if ( *(float *)&Weight <= 0.0 || (GoalTime = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu), *(float *)&GoalTime == 0.0) )
    {
      v40 = blendInTime;
      v41 = 0.0;
      v42 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
      if ( *(float *)&v42 > 0.0 )
      {
        Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
        v41 = *(float *)&Float_Internal_DebugName;
        v44 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
        v40 = *(float *)&v44;
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 1.0, v41, 1.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, 1.0, v40, 1.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
    }
    if ( (_DWORD)weaponHand )
    {
      Rate = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
      v15 = *(float *)&Rate;
    }
    if ( (unsigned int)(prevAnimIndex - 93) <= 6 )
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex, 0.0, blendOutTime, v15, (scr_string_t)0, 0, 0, LINEAR, NULL);
    Handler = CgHandler::getHandler(localClientNum);
    v47 = handIndex;
    if ( BG_ViewModelAnimExists(ps, (weapAnimFiles_t)v18, handIndex, Handler) )
    {
      WeaponStateModifiedAnimRate = 0.0;
      if ( v18 == 97 )
      {
        CG_Weapons_StoreSprintAnimLength(localClientNum, WEAP_ANIM_ADDITIVE_SPRINT_OUT, v47);
        WeaponStateModifiedAnimRate = CG_Weapons_GetWeaponStateModifiedAnimRate(localClientNum, ps, weapona, v47, anims, WEAP_ANIM_ADDITIVE_SPRINT_OUT);
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v18, 1.0, blendInTime, WeaponStateModifiedAnimRate, (scr_string_t)0, 1u, 1, LINEAR, NULL);
    }
    else
    {
      Com_PrintWarning(19, "CG_StartSprintAdditive(): additive Sprint LOOP/OUT animation not found.\n");
    }
    if ( v19 == WEAP_SPRINT_OUT )
    {
      v49 = CgHandler::getHandler(localClientNum);
      if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_OFFSET, v47, v49) )
      {
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, 0.0, blendInTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x63u, 0.0, blendInTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    return;
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Fu, 0.0, 0.0099999998, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x61u, 0.0, 0.0099999998, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  v20 = XAnimGetWeight(v16->tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu);
  if ( *(float *)&v20 == 1.0 )
  {
    LOBYTE(weaponHand) = 0;
  }
  else
  {
    v30 = v16->tree;
    LOBYTE(weaponHand) = 1;
    GoalWeight = XAnimGetGoalWeight(v30, 0, XANIM_SUBTREE_DEFAULT, 0xECu);
    if ( *(float *)&GoalWeight == 1.0 )
    {
      v21 = 1;
      goto LABEL_15;
    }
  }
  v21 = 0;
LABEL_15:
  v22 = v16->tree;
  if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8198, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  v23 = 0;
  v24 = (unsigned int *)&unk_1442DCC50;
  while ( 1 )
  {
    v25 = XAnimGetWeight(v22, 0, XANIM_SUBTREE_DEFAULT, *v24);
    if ( *(float *)&v25 > 0.0 )
    {
      v26 = XAnimGetGoalWeight(v22, 0, XANIM_SUBTREE_DEFAULT, *v24);
      if ( *(float *)&v26 == 0.0 )
        break;
    }
    ++v23;
    ++v24;
    if ( v23 >= 5 )
    {
      v27 = 0;
      goto LABEL_23;
    }
  }
  v27 = 1;
LABEL_23:
  v28 = handIndex;
  if ( v21 && v27 )
  {
    v29 = weapona;
  }
  else
  {
    v29 = weapona;
    if ( (_BYTE)weaponHand )
      CG_Weapons_StartWeaponAnim(localClientNum, weapona, handIndex, WEAP_IDLE, WEAP_ANIM_IDLE, prevAnim, prevAnimIndex, blendOutTime, 0);
  }
  CG_Weapons_StoreSprintAnimLength(localClientNum, WEAP_ANIM_ADDITIVE_SPRINT_IN, v28);
  v32 = CG_Weapons_GetWeaponStateModifiedAnimRate(localClientNum, ps, v29, v28, anims, WEAP_ANIM_ADDITIVE_SPRINT_IN);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, 1.0, blendInTime, 1.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
  v33 = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_IN, v28, v33) )
  {
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Eu, 1.0, blendInTime, v32, (scr_string_t)0, 1u, 1, LINEAR, NULL);
    if ( v32 == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8281, ASSERT_TYPE_ASSERT, "(rate)", (const char *)&queryFormat, "rate") )
      __debugbreak();
    Length = XAnimGetLength(anims, 0x5Eu);
    v14 = *(float *)&Length / v32;
  }
  else
  {
    Com_PrintWarning(19, "CG_StartSprintAdditive(): additive Sprint IN animation not found.\n");
  }
  v35 = DCONST_DVARBOOL_cg_viewmodelSprintOffset;
  if ( !DCONST_DVARBOOL_cg_viewmodelSprintOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelSprintOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v35);
  if ( v35->current.enabled )
  {
    v36 = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_OFFSET, v28, v36) )
    {
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, 1.0, v14, 1.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x63u, 1.0, v14, 1.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
    }
  }
}

/*
==============
CG_StopSprintAdditives
==============
*/
void CG_StopSprintAdditives(const playerState_s *ps, DObj *obj, const WeaponHand *weaponHand, const float blendOutTime)
{
  const XAnimTree *Tree; 
  double Weight; 
  double v9; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2264, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2265, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !weaponHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2266, ASSERT_TYPE_ASSERT, "(weaponHand)", (const char *)&queryFormat, "weaponHand") )
    __debugbreak();
  XAnimGetAnims(weaponHand->tree);
  Tree = DObjGetTree(obj);
  Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x5Fu);
  if ( *(float *)&Weight > 0.0 )
  {
    v9 = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x5Fu);
    blendOutTime = *(float *)&v9;
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, 0.0, blendOutTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Eu, 0.0, blendOutTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Fu, 0.0, blendOutTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x61u, 0.0, blendOutTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, 0.0, blendOutTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x63u, 0.0, blendOutTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
CG_TouchViewModel
==============
*/
void CG_TouchViewModel(const LocalClientNum_t localClientNum, const Weapon *r_weapon, bool isDefault, const playerState_s *ps)
{
  const BgWeaponMap **v6; 
  bool v9; 
  CgWeaponSystem *WeaponSystem; 
  const WeaponDef *v11; 
  int i; 
  const XModel *WeaponModels; 
  const XModel *rocketModel; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int8 *v16; 
  __int64 v17; 
  WeaponAttachment **v18; 
  const WeaponAttachment *v19; 
  const XModel *AttachmentModel; 
  __int64 isUsingDetonator; 
  unsigned int isUsingCensorshipWorldModel; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[localClientNum];
  if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v9 = BG_PlayerOrEntityDualWielding(*v6, ps, NULL, NULL);
  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12062, ASSERT_TYPE_ASSERT, "(r_weapon.weaponIdx != 0)", (const char *)&queryFormat, "r_weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  if ( r_weapon->weaponIdx >= BG_GetNumWeapons() )
  {
    isUsingCensorshipWorldModel = BG_GetNumWeapons();
    LODWORD(isUsingDetonator) = r_weapon->weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12063, ASSERT_TYPE_ASSERT, "(unsigned)( r_weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "r_weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  CG_GetLocalClientGlobals(localClientNum);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
  v11 = BG_WeaponDef(r_weapon, 0);
  BG_WeaponCompleteDef(r_weapon, 0);
  for ( i = 0; i < 2; ++i )
  {
    if ( v9 || !i )
    {
      WeaponModels = BG_GetWeaponModels((const PlayerHandIndex)i, r_weapon, 1, isDefault, v9, 0, 0);
      if ( WeaponModels )
        Stream_TouchXModel(WeaponModels, MIP3);
    }
  }
  rocketModel = v11->rocketModel;
  if ( rocketModel )
    Stream_TouchXModel(rocketModel, MIP3);
  WeaponSystem->TouchWeaponAttachModels(WeaponSystem);
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( AllWeaponAttachmentsWithIds )
  {
    v16 = attachmentIds;
    v17 = AllWeaponAttachmentsWithIds;
    v18 = attachments;
    do
    {
      v19 = *v18;
      if ( !*v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12093, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      AttachmentModel = BG_GetAttachmentModel(v19, r_weapon->attachmentVariationIndices[*v16], 1);
      if ( AttachmentModel )
        Stream_TouchXModel(AttachmentModel, MIP3);
      ++v18;
      ++v16;
      --v17;
    }
    while ( v17 );
  }
}

/*
==============
CG_UpdateHandViewmodels
==============
*/
void CG_UpdateHandViewmodels(LocalClientNum_t localClientNum, XModel *handModel)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  const Weapon *ViewmodelWeapon; 
  const Weapon *v6; 

  v2 = localClientNum;
  if ( !handModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12481, ASSERT_TYPE_ASSERT, "(handModel)", (const char *)&queryFormat, "handModel") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v2], &LocalClientGlobals->predictedPlayerState);
  v6 = ViewmodelWeapon;
  if ( ViewmodelWeapon->weaponIdx )
  {
    if ( LocalClientGlobals->playerWeaponInfo.handModel != handModel )
    {
      CG_Weapon_ChangeViewmodelDobj((LocalClientNum_t)v2, &LocalClientGlobals->predictedPlayerState, ViewmodelWeapon, handModel, 1, 0, 0, 1);
      CG_Gesture_ForceRestoreAnims((LocalClientNum_t)v2, &LocalClientGlobals->predictedPlayerState, v6);
    }
  }
}

/*
==============
CG_UpdateRecoilState
==============
*/
void CG_UpdateRecoilState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  unsigned int v4; 

  v2 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.pm_flags, ACTIVE, 0x10u) || BG_IsPlayerFireDisabledForHand(&LocalClientGlobals->predictedPlayerState, (const PlayerHandIndex)v2) )
    goto LABEL_8;
  v4 = LocalClientGlobals->predictedPlayerState.weapState[v2].weapAnim & 0xFFFFFF7F;
  if ( v4 == 3 )
  {
    if ( LocalClientGlobals->weaponRecoilTime[v2] <= 0 )
      LocalClientGlobals->weaponRecoilTime[v2] = LocalClientGlobals->time;
    return;
  }
  if ( v4 || LocalClientGlobals->weaponRecoilTime[v2] > 0 )
LABEL_8:
    LocalClientGlobals->weaponRecoilTime[v2] = 0;
}

/*
==============
CG_UpdateViewModelHidePartBits_EMP
==============
*/
void CG_UpdateViewModelHidePartBits_EMP(const LocalClientNum_t localClientNum, DObj *obj)
{
  cg_t *LocalClientGlobals; 
  ClientPlayerWeaponInfo *p_playerWeaponInfo; 
  unsigned __int8 inOutIndex[4]; 
  int modelIndex; 
  DObjPartBits partBits; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9565, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_playerWeaponInfo = &LocalClientGlobals->playerWeaponInfo;
  if ( LocalClientGlobals == (cg_t *)-98976i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9570, ASSERT_TYPE_SANITY, "( weapInfo )", (const char *)&queryFormat, "weapInfo") )
    __debugbreak();
  if ( p_playerWeaponInfo->hideReticle )
  {
    DObjGetHidePartBits(obj, &partBits);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_acog, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_red_dot, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_eotech_reticle, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_magnifier_eotech_reticle, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_tavor_scope, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_thermal_scope, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    DObjSetHidePartBits(obj, &partBits);
  }
}

/*
==============
CG_UpdateViewModelHidePartBits_NightVisionGoggles
==============
*/
void CG_UpdateViewModelHidePartBits_NightVisionGoggles(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  bool v6; 
  bool ShouldHideGoggles; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  int ModelIndex; 
  DObjPartBits *p_hidePartBits; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9687, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals == (cg_t *)-98976i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9690, ASSERT_TYPE_ASSERT, "(weapInfo)", (const char *)&queryFormat, "weapInfo") )
    __debugbreak();
  if ( LocalClientGlobals->playerWeaponInfo.gogglesModel )
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    v6 = BG_PlayerOrEntityDualWielding(Instance, &LocalClientGlobals->predictedPlayerState, NULL, NULL);
    if ( hand )
    {
      if ( hand == WEAPON_HAND_LEFT && !v6 )
        return;
    }
    else if ( v6 )
    {
      return;
    }
    ShouldHideGoggles = CG_NightVisionShouldHideGoggles(localClientNum, hand);
    if ( ShouldHideGoggles != LocalClientGlobals->playerWeaponInfo.gogglesAreHidden )
    {
      ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
      viewModelDObj = ViewModelHand->viewModelDObj;
      if ( ViewModelHand->viewModelDObj )
      {
        ModelIndex = DObjGetModelIndex(ViewModelHand->viewModelDObj, LocalClientGlobals->playerWeaponInfo.gogglesModel);
        p_hidePartBits = &viewModelDObj->hidePartBits;
        if ( ShouldHideGoggles )
        {
          BG_HideBone((const scr_string_t)scr_const.tag_accessory, viewModelDObj, p_hidePartBits, ModelIndex);
          LocalClientGlobals->playerWeaponInfo.gogglesAreHidden = 1;
        }
        else
        {
          BG_ShowBone((const scr_string_t)scr_const.tag_accessory, viewModelDObj, p_hidePartBits, ModelIndex);
          LocalClientGlobals->playerWeaponInfo.gogglesAreHidden = 0;
        }
      }
    }
  }
}

/*
==============
CG_UpdateViewModelPose
==============
*/
void CG_UpdateViewModelPose(const DObj *obj, LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  const tmat43_t<vec3_t> *ViewModelTransform; 
  vec3_t outOrigin; 

  if ( obj )
    DObjClearSkel(obj);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  CG_GetPoseOrigin(&LocalClientGlobals->viewModelPose, &outOrigin);
  CG_SetPrevPoseOrigin(&LocalClientGlobals->viewModelPose, &outOrigin);
  LocalClientGlobals->viewModelPose.prevAngles = LocalClientGlobals->viewModelPose.angles;
  CG_SetViewModelPose(LocalClientGlobals, 0, &LocalClientGlobals->viewModelPose);
  if ( obj )
  {
    ViewModelTransform = cg_t::GetViewModelTransform(LocalClientGlobals);
    XAnimBonePhysicsSetDObjMatrix(obj, &ViewModelTransform->m[3], &LocalClientGlobals->viewModelPose.angles);
  }
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_UpdateViewModelPoseForHand
==============
*/
void CG_UpdateViewModelPoseForHand(DObj *obj, LocalClientNum_t localClientNum, PlayerHandIndex hand, const bool sendingToRenderer)
{
  cg_t *LocalClientGlobals; 
  __int64 v9; 
  const vec3_t *v10; 
  const tmat43_t<vec3_t> *ViewModelTransform; 

  if ( obj )
    DObjClearSkel(obj);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v9 = 303328i64;
  if ( hand )
    v9 = 303616i64;
  v10 = (const vec3_t *)((char *)LocalClientGlobals + v9);
  CG_SetViewModelPose(LocalClientGlobals, sendingToRenderer, (cpose_t *)((char *)LocalClientGlobals + v9));
  if ( obj )
  {
    ViewModelTransform = cg_t::GetViewModelTransform(LocalClientGlobals);
    XAnimBonePhysicsSetDObjMatrix(obj, &ViewModelTransform->m[3], v10 + 6);
  }
  CG_WristWatch_CalcXAnimParameters(obj, localClientNum, &LocalClientGlobals->predictedPlayerState, 0x1Bu, 0x1Cu, 0x1Du, 0x23u);
}

/*
==============
CG_UpdateViewModelPreviousPositionForHand
==============
*/
void CG_UpdateViewModelPreviousPositionForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  __int64 v4; 
  cpose_t *v5; 
  vec3_t outOrigin; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v4 = 303328i64;
  if ( hand )
    v4 = 303616i64;
  v5 = (cpose_t *)((char *)LocalClientGlobals + v4);
  CG_GetPoseOrigin((const cpose_t *)((char *)LocalClientGlobals + v4), &outOrigin);
  CG_SetPrevPoseOrigin(v5, &outOrigin);
  v5->prevAngles.v[0] = v5->angles.v[0];
  v5->prevAngles.v[1] = v5->angles.v[1];
  v5->prevAngles.v[2] = v5->angles.v[2];
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_UpdateViewWeaponAnim
==============
*/
void CG_UpdateViewWeaponAnim(LocalClientNum_t localClientNum, double a2)
{
  __int64 v2; 
  __int64 v3; 
  CgWeaponMap *v4; 
  cg_t *LocalClientGlobals; 
  cg_t *v6; 
  const Weapon *ViewmodelWeapon; 
  bool v8; 
  bool v9; 
  bool HasLadderHand; 
  __int64 v11; 
  int v12; 
  __int64 v13; 
  char v14; 
  _QWORD *v15; 
  PlayerHandIndex v16; 
  bool tryClearOffset; 
  const dvar_t *v18; 
  cg_t *v19; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  __int64 v22; 
  int v23; 
  const char *BoneName; 
  DObjAnimMat *mat; 
  bool v26; 
  __int64 v27; 
  const Weapon *v28; 
  const playerState_s *v29; 
  DObj **v30; 
  PlayerHandIndex v31; 
  __int64 v32; 
  XAnimTree *v33; 
  char *WeaponName; 
  const char *v35; 
  cg_t *v36; 
  unsigned int v37; 
  bool v38; 
  int v39; 
  __int64 entity; 
  CgEntitySystem *v41; 
  unsigned int AudioEventList; 
  __int64 v43; 
  cg_t *v44; 
  CgSoundSystem *SoundSystem; 
  unsigned int *v46; 
  const tmat43_t<vec3_t> *ViewModelTransform; 
  int v48; 
  __int64 recreateAnimTrees; 
  __int64 refreshOverridesOnly; 
  bool outTryClearOffset; 
  DObj obj; 
  char buffer[4096]; 

  v2 = localClientNum;
  *(_QWORD *)&obj.ignoreCollision.array[2] = CG_GetLocalClientGlobals(localClientNum);
  v3 = *(_QWORD *)&obj.ignoreCollision.array[2];
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v2];
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  LocalClientGlobals->isJogging = CG_IsJogging((LocalClientNum_t)v2);
  if ( *(int *)(v3 + 20) < 7 )
    goto LABEL_13;
  if ( (unsigned int)v2 >= LODWORD(cl_maxLocalClients) )
  {
    LODWORD(recreateAnimTrees) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7686, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", recreateAnimTrees, cl_maxLocalClients) )
      __debugbreak();
  }
  v6 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7689, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  memset_0(&v6->scopeToggleInfo, 0, sizeof(v6->scopeToggleInfo));
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_RAISE|WEAPON_LADDER_AIM) )
  {
    ResetWeaponAnimTrees((LocalClientNum_t)v2, (const playerState_s *)(v3 + 8));
  }
  else
  {
LABEL_13:
    ViewmodelWeapon = BG_GetViewmodelWeapon(v4, (const playerState_s *)(v3 + 8));
    *(_QWORD *)&obj.ignoreCollision.array[4] = ViewmodelWeapon;
    if ( ViewmodelWeapon->weaponIdx )
    {
      Sys_ProfBeginNamedEvent(0xFFFFFFFF, "view anim - CG_RegisterWeapon");
      v8 = CG_RegisterWeapon((LocalClientNum_t)v2, (const playerState_s *)(v3 + 8), *(const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)(v3 + 98840), ViewmodelWeapon, (ClientPlayerWeaponInfo *)(v3 + 98976));
      LOBYTE(obj.tree) = v8;
      Sys_ProfEndNamedEvent();
      *(_DWORD *)(v3 + 98848) = BG_PlayerDualWieldingWeapon(v4, (const playerState_s *)(v3 + 8), ViewmodelWeapon);
      if ( *(_QWORD *)(v3 + 98976) )
      {
        v9 = v8 || memcmp_0((const void *)(v3 + 98778), ViewmodelWeapon, 0x3Cui64) || *(_DWORD *)(v3 + 98848) != BG_PlayerDualWieldingWeapon(v4, (const playerState_s *)(v3 + 8), ViewmodelWeapon);
        HasLadderHand = BG_HasLadderHand((const playerState_s *)(v3 + 8));
        if ( *(_DWORD *)(v3 + 98848) || HasLadderHand )
        {
          *(_DWORD *)&obj.entnum = 2;
          v11 = 1i64;
        }
        else
        {
          v11 = 0i64;
          *(_DWORD *)&obj.entnum = 1;
        }
        v12 = *(_DWORD *)(v3 + 896);
        v13 = v11 + 1;
        v14 = v9;
        if ( *(_DWORD *)(v3 + 98924) != v12 )
          v14 = 1;
        *(_DWORD *)(v3 + 98924) = v12;
        v15 = (_QWORD *)(v3 + 807496);
        *(_QWORD *)&obj.ignoreCollision.array[6] = v11 + 1;
        v16 = WEAPON_HAND_DEFAULT;
        *(_QWORD *)obj.ignoreCollision.array = v15;
        tryClearOffset = 1;
        *(XAnimTree **)((char *)&obj.tree + 4) = (XAnimTree *)(v11 + 1);
        do
        {
          v18 = DVARBOOL_cg_enableViewModelBoneAndAnimDump;
          if ( !DVARBOOL_cg_enableViewModelBoneAndAnimDump && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableViewModelBoneAndAnimDump") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v18);
          if ( v18->current.enabled )
          {
            v19 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
            ViewModelHand = cg_t::GetViewModelHand(v19, v16);
            if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2455, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
              __debugbreak();
            viewModelDObj = ViewModelHand->viewModelDObj;
            if ( viewModelDObj->skel.mat )
            {
              DObjDisplayAnimToBuffer(viewModelDObj, (const char *)&queryFormat.fmt + 3, buffer, 4096);
              Com_Printf(19, "%s\n", buffer);
              v22 = 0i64;
              v23 = 0;
              if ( viewModelDObj->numBones )
              {
                do
                {
                  BoneName = DObjGetBoneName(viewModelDObj, v23);
                  mat = viewModelDObj->skel.mat;
                  a2 = mat[v22].quat.v[2];
                  Com_Printf(19, "Bone[%d] %s: trans[%.2f, %.2f, %.2f] rot[%.2f, %.2f, %.2f, %.2f]\n", (unsigned int)v23, BoneName, mat[v22].trans.v[0], mat[v22].trans.v[1], mat[v22].trans.v[2], mat[v22].quat.v[0], mat[v22].quat.v[1], a2, mat[v22].quat.v[3]);
                  ++v22;
                  ++v23;
                }
                while ( v23 < viewModelDObj->numBones );
                v13 = *(__int64 *)((char *)&obj.tree + 4);
              }
              else
              {
                v13 = *(__int64 *)((char *)&obj.tree + 4);
              }
            }
            else
            {
              v13 = *(__int64 *)((char *)&obj.tree + 4);
            }
          }
          if ( (unsigned int)v16 >= NUM_WEAPON_HANDS )
          {
            LODWORD(refreshOverridesOnly) = 2;
            LODWORD(recreateAnimTrees) = v16;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
              __debugbreak();
          }
          v26 = *v15 == 0i64;
          outTryClearOffset = 1;
          if ( v26 )
            v14 = 1;
          v14 |= CG_UpdateViewmodelAttachments((LocalClientNum_t)v2, v16, &outTryClearOffset);
          if ( !outTryClearOffset )
            tryClearOffset = 0;
          ++v16;
          v15 += 5;
          *(XAnimTree **)((char *)&obj.tree + 4) = (XAnimTree *)--v13;
        }
        while ( v13 );
        v27 = *(_QWORD *)&obj.ignoreCollision.array[2];
        v28 = *(const Weapon **)&obj.ignoreCollision.array[4];
        v29 = (const playerState_s *)(*(_QWORD *)&obj.ignoreCollision.array[2] + 8i64);
        if ( (unsigned __int8)v14 | CG_Weapon_UpdateWeaponVisibility((const LocalClientNum_t)v2, (const playerState_s *)(*(_QWORD *)&obj.ignoreCollision.array[2] + 8i64), *(const Weapon **)&obj.ignoreCollision.array[4], 0) )
        {
          Sys_ProfBeginNamedEvent(0xFFFFFFFF, "view anim - CG_Weapon_ChangeViewmodelDobj");
          CG_Weapon_ChangeViewmodelDobj((LocalClientNum_t)v2, v29, v28, *(XModel **)(v27 + 98976), 0, (bool)obj.tree, 0, tryClearOffset);
          Sys_ProfEndNamedEvent();
        }
        Sys_ProfBeginNamedEvent(0xFFFFFFFF, "view anim - update hands");
        v30 = *(DObj ***)obj.ignoreCollision.array;
        v31 = WEAPON_HAND_DEFAULT;
        v32 = 98948i64;
        v33 = NULL;
        *(XAnimTree **)((char *)&obj.tree + 4) = NULL;
        do
        {
          if ( (unsigned int)v31 >= NUM_WEAPON_HANDS )
          {
            LODWORD(refreshOverridesOnly) = 2;
            LODWORD(recreateAnimTrees) = v31;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
              __debugbreak();
          }
          if ( *v30 )
          {
            v36 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
            if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&v36->predictedPlayerState.pm_flags, ACTIVE, 0x10u) || BG_IsPlayerFireDisabledForHand(&v36->predictedPlayerState, v31) )
            {
              *(_DWORD *)((char *)&v36->__vftable + v32) = 0;
            }
            else
            {
              v37 = *(int *)((_BYTE *)&v36->predictedPlayerState.weapState[0].weapAnim + (_QWORD)v33) & 0xFFFFFF7F;
              if ( v37 == 3 )
              {
                if ( *(int *)((char *)&v36->__vftable + v32) <= 0 )
                  *(_DWORD *)((char *)&v36->__vftable + v32) = v36->time;
              }
              else if ( v37 )
              {
                *(_DWORD *)((char *)&v36->__vftable + v32) = 0;
              }
              else if ( *(int *)((char *)&v36->__vftable + v32) > 0 )
              {
                *(_DWORD *)((char *)&v36->__vftable + v32) = 0;
              }
            }
            WeaponRunXModelAnims((LocalClientNum_t)v2, v29, v31);
            DObjResetClientNotifyList();
            LOBYTE(v39) = !BG_Ladder_IsActive(v29) || v31 == WEAPON_HAND_LEFT;
            DObjUpdateClientInfo(&obj, *(float *)&a2, v38, v39);
            entity = v29->vehicleState.entity;
            if ( (_DWORD)entity == 2047 )
              goto LABEL_88;
            if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
            {
              LODWORD(refreshOverridesOnly) = v2;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", refreshOverridesOnly) )
                __debugbreak();
            }
            if ( (unsigned int)v2 >= CgEntitySystem::ms_allocatedCount )
            {
              LODWORD(refreshOverridesOnly) = CgEntitySystem::ms_allocatedCount;
              LODWORD(recreateAnimTrees) = v2;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
                __debugbreak();
            }
            if ( !CgEntitySystem::ms_entitySystemArray[v2] )
            {
              LODWORD(refreshOverridesOnly) = v2;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", refreshOverridesOnly) )
                __debugbreak();
            }
            v41 = CgEntitySystem::ms_entitySystemArray[v2];
            if ( (unsigned int)entity >= 0x800 )
            {
              LODWORD(refreshOverridesOnly) = 2048;
              LODWORD(recreateAnimTrees) = entity;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
                __debugbreak();
            }
            if ( (v41->m_entities[entity].flags & 1) == 0 || !BG_IsVehicleEntity(&v41->m_entities[entity].nextState) )
            {
LABEL_88:
              CG_Weapons_ProcessWeaponNoteTracks((LocalClientNum_t)v2, v29, *v30, v31, (const XAnimNotifyHandle)obj.tree);
              AudioEventList = XAnimBonePhysicsGetAudioEventList(*v30, (XAnimBonePhysicsAudioEvent *)&obj.skel.partBits.anim.array[5], 3u);
              v43 = AudioEventList;
              if ( AudioEventList )
              {
                v44 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
                SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)v2);
                v46 = &obj.skel.partBits.anim.array[5];
                do
                {
                  ViewModelTransform = cg_t::GetViewModelTransform(v44);
                  MatrixTransformVector43((const vec3_t *)(v46 + 2), ViewModelTransform, (vec3_t *)&obj.locked);
                  CgSoundSystem::PlaySoundAliasByLookup(SoundSystem, v44->predictedPlayerState.clientNum, (const vec3_t *)&obj.locked, *(SndAliasLookup *)v46);
                  v46 += 6;
                  --v43;
                }
                while ( v43 );
                v30 = *(DObj ***)obj.ignoreCollision.array;
              }
              v33 = *(XAnimTree **)((char *)&obj.tree + 4);
            }
            CG_NightVisionProcessNoteTracks((LocalClientNum_t)v2, v29, *v30, v31);
            v28 = *(const Weapon **)&obj.ignoreCollision.array[4];
          }
          else
          {
            WeaponName = BG_GetWeaponName(v28, (char *)&obj.skel.partBits.skel.array[1], 0x400u);
            v35 = "left";
            if ( v31 == WEAPON_HAND_DEFAULT )
              v35 = "right";
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DF120, 615i64, (unsigned int)v2, WeaponName, v35);
          }
          v30 += 5;
          v33 = (XAnimTree *)((char *)v33 + 80);
          ++v31;
          *(_QWORD *)obj.ignoreCollision.array = v30;
          v32 += 4i64;
          *(XAnimTree **)((char *)&obj.tree + 4) = v33;
          --*(_QWORD *)&obj.ignoreCollision.array[6];
        }
        while ( *(_QWORD *)&obj.ignoreCollision.array[6] );
        v48 = *(_DWORD *)&obj.entnum;
        if ( *(_DWORD *)&obj.entnum < 2u )
        {
          do
            CG_Gesture_ShutdownSlots((LocalClientNum_t)v2, (const PlayerHandIndex)v48++);
          while ( v48 < 2 );
        }
        Sys_ProfEndNamedEvent();
      }
      else
      {
        CG_Weapon_ViewModelDobj_CleanUp((const LocalClientNum_t)v2);
      }
    }
  }
}

/*
==============
CG_UpdateViewmodelAttachments
==============
*/
char CG_UpdateViewmodelAttachments(LocalClientNum_t localClientNum, PlayerHandIndex hand, bool *outTryClearOffset)
{
  unsigned __int16 v3; 
  __int64 v4; 
  __int64 v6; 
  __int64 rocketModel; 
  cg_t *LocalClientGlobals; 
  CgWeaponSystem *WeaponSystem; 
  int v10; 
  int v11; 
  __int128 v12; 
  double v13; 
  WeaponDef **v14; 
  WeaponDef *v15; 
  playerState_s *p_predictedPlayerState; 
  bool v17; 
  const BgWeaponMap **v18; 
  Gesture *Gesture; 
  Gesture *v20; 
  bool IsPlaying; 
  bool v22; 
  playerState_s *v23; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  __int64 v26; 
  int ammoInClipBeforeReload; 
  CgHandler *Handler; 
  int v29; 
  bool IsEMPJammed; 
  __int64 gestureAnimType; 
  __int64 ammoInClip; 
  bool hasFastReloadOverride; 
  bool v35; 
  PlayerHandIndex handa; 
  __int64 v37; 
  XModel *nightVisionGoggles; 
  CgWeaponSystem *v39; 
  bool *v40; 
  __int64 v41; 
  Weapon r_weapon; 

  v4 = hand;
  handa = hand;
  v40 = outTryClearOffset;
  v6 = localClientNum;
  if ( !outTryClearOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11988, ASSERT_TYPE_ASSERT, "(outTryClearOffset)", (const char *)&queryFormat, "outTryClearOffset") )
    __debugbreak();
  nightVisionGoggles = NULL;
  rocketModel = 0i64;
  v37 = 0i64;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v6);
  v10 = *(_DWORD *)&LocalClientGlobals->playerWeaponInfo.weapon.weaponCamo;
  v11 = *(_DWORD *)&LocalClientGlobals->playerWeaponInfo.weapon.weaponIdx;
  v12 = *(_OWORD *)&LocalClientGlobals->playerWeaponInfo.weapon.attachmentVariationIndices[5];
  v13 = *(double *)&LocalClientGlobals->playerWeaponInfo.weapon.attachmentVariationIndices[21];
  v39 = WeaponSystem;
  *(_DWORD *)&r_weapon.weaponCamo = v10;
  *(_OWORD *)&r_weapon.attachmentVariationIndices[5] = v12;
  *(double *)&r_weapon.attachmentVariationIndices[21] = v13;
  if ( (unsigned __int16)v11 > bg_lastParsedWeaponIndex )
  {
    LODWORD(gestureAnimType) = (unsigned __int16)v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", gestureAnimType, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  v14 = &bg_weaponDefs[(unsigned __int16)v11];
  if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  v15 = *v14;
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(ammoInClip) = 2;
    LODWORD(gestureAnimType) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", gestureAnimType, ammoInClip) )
      __debugbreak();
  }
  *outTryClearOffset = 1;
  v41 = (__int64)LocalClientGlobals + 40 * v4;
  p_predictedPlayerState = &CG_GetLocalClientGlobals((const LocalClientNum_t)v6)->predictedPlayerState;
  v17 = BG_UsingAlternate(p_predictedPlayerState);
  v18 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v6];
  hasFastReloadOverride = BG_PlayerDualWielding(p_predictedPlayerState) == 1;
  if ( !*v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  r_weapon = *BG_GetViewmodelWeapon(*v18, p_predictedPlayerState);
  if ( v3 > bg_lastParsedWeaponIndex )
  {
    LODWORD(ammoInClip) = bg_lastParsedWeaponIndex;
    LODWORD(gestureAnimType) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", gestureAnimType, ammoInClip) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Gesture = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v17, hasFastReloadOverride, GESTUREANIMTYPE_NVG_ON);
  v20 = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v17, hasFastReloadOverride, GESTUREANIMTYPE_NVG_OFF);
  LOBYTE(Gesture) = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, Gesture, NULL, NULL);
  IsPlaying = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, v20, NULL, NULL);
  if ( (_BYTE)Gesture || IsPlaying )
    nightVisionGoggles = cgMedia.nightVisionGoggles;
  v22 = v39->UpdateWeaponAttachModels(v39) != 0;
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11925, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v15->rocketModel )
  {
    v23 = &CG_GetLocalClientGlobals((const LocalClientNum_t)v6)->predictedPlayerState;
    v35 = BG_UsingAlternate(v23);
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v6);
    CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, v23);
    if ( BG_GetAmmoInClip(v23, CurrentWeaponForPlayer, v35, (PlayerHandIndex)v4) || (v26 = v4, (unsigned int)(v23->weapState[v26].weaponState - 18) <= 3) && (ammoInClipBeforeReload = v23->weapState[v26].ammoInClipBeforeReload, hasFastReloadOverride = 0, Handler = CgHandler::getHandler((LocalClientNum_t)v6), v29 = BG_ReloadTime(v23, Handler, handa, CurrentWeaponForPlayer, v35, 0, ammoInClipBeforeReload, &hasFastReloadOverride) - v23->weapState[v26].weaponTime, v29 > BG_GetWeaponFieldTime(v23, CurrentWeaponForPlayer, 0, 0, 74i64)) )
      rocketModel = (__int64)v15->rocketModel;
    else
      rocketModel = v37;
  }
  if ( nightVisionGoggles != LocalClientGlobals->playerWeaponInfo.gogglesModel )
  {
    LocalClientGlobals->playerWeaponInfo.gogglesModel = nightVisionGoggles;
    v22 = 1;
    *v40 = 0;
  }
  if ( rocketModel != *(_QWORD *)(v41 + 807512) )
  {
    *(_QWORD *)(v41 + 807512) = rocketModel;
    v22 = 1;
  }
  IsEMPJammed = CG_View_IsEMPJammed((const LocalClientNum_t)v6);
  if ( IsEMPJammed == LocalClientGlobals->playerWeaponInfo.hideReticle )
    return v22;
  LocalClientGlobals->playerWeaponInfo.hideReticle = IsEMPJammed;
  return 1;
}

/*
==============
CG_UpdateWeaponViewmodels
==============
*/
void CG_UpdateWeaponViewmodels(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  playerState_s *p_predictedPlayerState; 
  CgWeaponMap *v4; 
  unsigned int i; 
  const Weapon *Weapon; 
  CgHandler *Handler; 
  const Weapon *ViewmodelWeapon; 
  bool v9; 
  const Weapon *OffhandGestureWeapon; 
  __m256i v11; 
  __int128 v12; 
  double v13; 
  int v14; 
  const Weapon *OffhandScriptWeapon; 
  int v16; 
  bool v17; 
  bool HasLadderHand; 
  char prevLadderHand; 
  char v20; 
  bool updated; 
  char v22; 
  char v23; 
  bool dualViewScopeRefreshDobj; 
  char v25; 
  bool v26; 
  char v27; 
  bool v28; 
  char v29; 
  char v30; 
  cg_t *v31; 
  char v32; 
  char v33; 
  CgWeaponSystem *WeaponSystem; 
  cg_t *v35; 
  char v36; 
  char v37; 
  char v38; 
  CgWeaponSystem *v39; 
  const centity_t *predictedPlayerEntity; 
  ClientChargeWeaponInfo *InfoStruct; 
  bool v42; 
  bool v43; 
  int weaponState; 
  cg_t *v45; 
  DObj *const *p_viewModelDObj; 
  int v47; 
  __int64 v48; 
  cg_t *v50; 
  __int64 v51; 
  bool v52; 
  DObj *v53; 
  const XModel *gestureWeapModel; 
  int ModelIndex; 
  scr_string_t v56; 
  DObjPartBits *p_hidePartBits; 
  char v58; 
  bool v59; 
  float fWeaponPosFrac; 
  bool v61; 
  CgHandler *v62; 
  CgHandler *v67; 
  bool v68; 
  const dvar_t *v69; 
  __int64 recreateAnimTrees; 
  __int64 refreshOverridesOnly; 
  bool refreshViewmodelMaterialOverride; 
  bool v76; 
  bool v77; 
  bool CanHybridToggle; 
  char v79; 
  Weapon *r_weapon; 
  cg_t *v81; 
  BgWeaponMap *weaponMap; 
  __m256i v83; 
  Weapon outAccessoryWeapon; 
  __m256i Buf2; 
  __int128 v86; 
  double v87; 
  int v88; 
  GfxScopeInfo settingOut; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v81 = LocalClientGlobals;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  refreshViewmodelMaterialOverride = LocalClientGlobals->refreshViewmodelMaterialOverride;
  if ( !CgWeaponMap::ms_instance[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v1];
  weaponMap = v4;
  for ( i = 0; i < 0xF; ++i )
  {
    if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon(v4, p_predictedPlayerState->weaponsEquipped[i]);
    if ( Weapon->weaponIdx )
      CG_TouchViewModel((const LocalClientNum_t)v1, Weapon, LocalClientGlobals->playerWeaponInfo.isWeaponDefault, p_predictedPlayerState);
  }
  Handler = CgHandler::getHandler((LocalClientNum_t)v1);
  if ( !CgWeaponMap::ms_instance[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  BG_UpdateWeaponAnimArrays(CgWeaponMap::ms_instance[v1], p_predictedPlayerState, Handler);
  ViewmodelWeapon = BG_GetViewmodelWeapon(v4, p_predictedPlayerState);
  memset(&outAccessoryWeapon, 0, 48);
  *(double *)&outAccessoryWeapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
  *(_DWORD *)&outAccessoryWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  r_weapon = (Weapon *)ViewmodelWeapon;
  if ( LocalClientGlobals->predictedPlayerState.accessoryIndex != 127 )
    BG_Accessory_GetWeapon(v4, p_predictedPlayerState, &outAccessoryWeapon);
  v9 = ViewmodelWeapon->weaponIdx && BG_UsingAlternate(p_predictedPlayerState) != LocalClientGlobals->playerWeaponInfo.isAlternate;
  OffhandGestureWeapon = BG_GetOffhandGestureWeapon(v4, p_predictedPlayerState);
  v11 = *(__m256i *)&OffhandGestureWeapon->weaponIdx;
  v12 = *(_OWORD *)&OffhandGestureWeapon->attachmentVariationIndices[5];
  v13 = *(double *)&OffhandGestureWeapon->attachmentVariationIndices[21];
  v14 = *(_DWORD *)&OffhandGestureWeapon->weaponCamo;
  v88 = v14;
  v83 = v11;
  Buf2 = v11;
  v86 = v12;
  v87 = v13;
  if ( !*(_WORD *)&NULL_WEAPON.attachmentVariationIndices[21] )
  {
    OffhandScriptWeapon = BG_GetOffhandScriptWeapon(v4, p_predictedPlayerState);
    v12 = *(_OWORD *)&OffhandScriptWeapon->attachmentVariationIndices[5];
    v13 = *(double *)&OffhandScriptWeapon->attachmentVariationIndices[21];
    v14 = *(_DWORD *)&OffhandScriptWeapon->weaponCamo;
    v83 = *(__m256i *)&OffhandScriptWeapon->weaponIdx;
    Buf2 = *(__m256i *)&OffhandScriptWeapon->weaponIdx;
    v86 = v12;
    v87 = v13;
    v88 = v14;
  }
  v16 = memcmp_0(&LocalClientGlobals->gestureWeapInfo, &Buf2, 0x3Cui64);
  *(__m256i *)&LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponIdx = v83;
  *(_OWORD *)&LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.attachmentVariationIndices[5] = v12;
  *(double *)&LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.attachmentVariationIndices[21] = v13;
  v17 = v16 != 0;
  *(_DWORD *)&LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponCamo = v14;
  v77 = v16 != 0;
  HasLadderHand = BG_HasLadderHand(p_predictedPlayerState);
  prevLadderHand = LocalClientGlobals->prevLadderHand;
  v20 = HasLadderHand;
  LocalClientGlobals->prevLadderHand = BG_HasLadderHand(p_predictedPlayerState);
  updated = CG_Weapon_UpdateWeaponVisibility((const LocalClientNum_t)v1, p_predictedPlayerState, r_weapon, 0);
  v22 = v9;
  if ( prevLadderHand != v20 )
    v22 = 1;
  v23 = v17 | v22 | updated;
  dualViewScopeRefreshDobj = LocalClientGlobals->dualViewScopeRefreshDobj;
  v79 = v23;
  v25 = dualViewScopeRefreshDobj | (memcmp_0(&LocalClientGlobals->playerWeaponInfo.weapon, r_weapon, 0x3Cui64) != 0);
  v26 = !memcmp_0(&LocalClientGlobals->playerWeaponInfo.weapon, r_weapon, 0x3Cui64) && LocalClientGlobals->playerWeaponInfo.meleeComboSeqIdx != LocalClientGlobals->predictedPlayerState.weapCommon.meleeComboSeqIdx;
  v27 = v26 | ViewModelScriptedStateChanged((LocalClientNum_t)v1, p_predictedPlayerState);
  v28 = CG_Skydive_GetViewmodelState((const LocalClientNum_t)v1) == LocalClientGlobals->playerWeaponInfo.skydiveViewmodelState;
  v29 = v79;
  if ( !v28 )
    v27 = 1;
  if ( LocalClientGlobals->predictedPlayerState.carryState.carryObjectIndex != LocalClientGlobals->playerWeaponInfo.carryObjectIndex )
    v29 = 1;
  v30 = v25 | v29 | v27;
  v31 = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  if ( memcmp_0(&outAccessoryWeapon, &v31->playerWeaponInfo.accessoryWeapon, 0x3Cui64) )
  {
    *(_WORD *)&v31->playerWeaponInfo.isAccessoryHidden = 257;
    v31->playerWeaponInfo.accessoryWeapon = outAccessoryWeapon;
    v30 = dualViewScopeRefreshDobj | 1;
  }
  v32 = 0;
  v33 = 0;
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v1);
  v35 = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  if ( !WeaponSystem->IsWeaponViewModelLoaded(WeaponSystem, &outAccessoryWeapon) )
  {
    if ( BG_HasDefaultViewModel(&outAccessoryWeapon) )
      v32 = 1;
    else
      v33 = 1;
  }
  if ( v33 == v35->playerWeaponInfo.isAccessoryHidden )
  {
    v36 = 0;
  }
  else
  {
    v35->playerWeaponInfo.isAccessoryHidden = v33;
    v36 = 1;
  }
  if ( v32 != v35->playerWeaponInfo.isAccessoryDefault )
  {
    v35->playerWeaponInfo.isAccessoryDefault = v32;
    v36 = 1;
  }
  v37 = v36;
  if ( v81->prevDualWielding != BG_PlayerDualWieldingWeapon(weaponMap, p_predictedPlayerState, r_weapon) )
    v37 = 1;
  v38 = v30 | v37;
  if ( v38 || refreshViewmodelMaterialOverride )
  {
    v39 = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v1);
    if ( !v39 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12352, ASSERT_TYPE_ASSERT, "(weaponSystem)", (const char *)&queryFormat, "weaponSystem") )
      __debugbreak();
    predictedPlayerEntity = v81->predictedPlayerEntity;
    InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(v39, predictedPlayerEntity->nextState.number);
    if ( InfoStruct && InfoStruct->currentWeapon.weaponIdx )
      CgWeaponSystem::ChargedWeaponClearViewModelFX(v39, predictedPlayerEntity);
    CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(v39, p_predictedPlayerState);
    CgWeaponSystem::OffhandWeaponVmFxStopAll(v39);
    v42 = refreshViewmodelMaterialOverride && !v38;
    CG_Weapon_ChangeViewmodelDobj((LocalClientNum_t)v1, p_predictedPlayerState, r_weapon, v81->playerWeaponInfo.handModel, 1, 0, v42, !v77);
    v81->refreshViewmodelMaterialOverride = 0;
    v81->dualViewScopeRefreshDobj = 0;
    v81->playerWeaponInfo.meleeComboSeqIdx = p_predictedPlayerState->weapCommon.meleeComboSeqIdx;
    v81->playerWeaponInfo.skydiveViewmodelState = CG_Skydive_GetViewmodelState((const LocalClientNum_t)v1);
    if ( r_weapon->weaponIdx )
    {
      v81->playerWeaponInfo.isAlternate = BG_UsingAlternate(p_predictedPlayerState);
      v81->playerWeaponInfo.carryObjectIndex = p_predictedPlayerState->carryState.carryObjectIndex;
    }
    else
    {
      v81->playerWeaponInfo.isAlternate = 0;
      *(__m256i *)&v81->prevViewmodelWeapon.weaponIdx = *(__m256i *)&r_weapon->weaponIdx;
      *(_OWORD *)&v81->prevViewmodelWeapon.attachmentVariationIndices[5] = *(_OWORD *)&r_weapon->attachmentVariationIndices[5];
      *(double *)&v81->prevViewmodelWeapon.attachmentVariationIndices[21] = *(double *)&r_weapon->attachmentVariationIndices[21];
      *(_DWORD *)&v81->prevViewmodelWeapon.weaponCamo = *(_DWORD *)&r_weapon->weaponCamo;
      v81->playerWeaponInfo.carryObjectIndex = 64;
    }
  }
  if ( (unsigned int)(v81->lastWeaponState - 2) > 2 || (unsigned int)(p_predictedPlayerState->weapState[0].weaponState - 2) <= 2 )
  {
    weaponState = p_predictedPlayerState->weapState[0].weaponState;
    if ( (unsigned int)(weaponState - 2) > 1 && weaponState != 4 )
      goto LABEL_70;
    v43 = !v81->playerWeaponInfo.isAlternate;
  }
  else
  {
    v43 = BG_UsingAlternate(p_predictedPlayerState);
  }
  CG_ProcessWeaponOnAltChange((const LocalClientNum_t)v1, v43);
  weaponState = p_predictedPlayerState->weapState[0].weaponState;
LABEL_70:
  v81->lastWeaponState = weaponState;
  v45 = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  if ( !v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9893, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_viewModelDObj = &v81->m_weaponHand[0].viewModelDObj;
  v47 = 0;
  v45->viewModelAnimScriptedInfo.lastScriptedAnimStartTime = p_predictedPlayerState->viewModelAnimScripted.animStartTime;
  v48 = -807496i64 - (_QWORD)v81;
  v45->viewModelAnimScriptedInfo.lastAnimIndex = p_predictedPlayerState->viewModelAnimScripted.animIndex;
  _XMM7 = 0i64;
  do
  {
    v50 = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
    if ( !v50 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11197, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( v50->gestureWeapInfo.offhandGestureWeapon.weaponIdx )
    {
      if ( (unsigned int)v47 >= 2 )
      {
        LODWORD(refreshOverridesOnly) = 2;
        LODWORD(recreateAnimTrees) = v47;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
          __debugbreak();
      }
      v51 = (__int64)v50->m_weaponHand + (_QWORD)p_viewModelDObj + v48;
      if ( !v51 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11205, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
        __debugbreak();
      if ( *(_QWORD *)(v51 + 8) )
      {
        if ( !CgWeaponMap::ms_instance[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
          __debugbreak();
        v52 = BG_PlayerOrEntityDualWielding(CgWeaponMap::ms_instance[v1], &v50->predictedPlayerState, NULL, NULL);
        if ( v47 )
        {
          if ( v47 == 1 && !v52 )
            goto LABEL_103;
        }
        else if ( v52 )
        {
          goto LABEL_103;
        }
        CG_OffhandGestureWeapon_SetVisibilityState((LocalClientNum_t)v1, (const PlayerHandIndex)v47);
        if ( v50->gestureWeapInfo.shouldBeVisible != v50->gestureWeapInfo.isGestureWeapVisible )
        {
          if ( (unsigned int)v47 >= 2 )
          {
            LODWORD(refreshOverridesOnly) = 2;
            LODWORD(recreateAnimTrees) = v47;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
              __debugbreak();
          }
          v53 = *(DObj **)v51;
          if ( v53 )
          {
            gestureWeapModel = v50->gestureWeapInfo.gestureWeapModel;
            if ( gestureWeapModel )
            {
              ModelIndex = DObjGetModelIndex(v53, gestureWeapModel);
              v56 = *v50->gestureWeapInfo.gestureWeapModel->boneNames;
              if ( v56 )
              {
                p_hidePartBits = &v53->hidePartBits;
                if ( v50->gestureWeapInfo.shouldBeVisible )
                {
                  BG_ShowBone(v56, v53, p_hidePartBits, ModelIndex);
                  v50->gestureWeapInfo.isGestureWeapVisible = 1;
                }
                else
                {
                  BG_HideBone(v56, v53, p_hidePartBits, ModelIndex);
                  v50->gestureWeapInfo.isGestureWeapVisible = 0;
                }
              }
            }
          }
        }
      }
    }
LABEL_103:
    CG_UpdateViewModelHidePartBits_NightVisionGoggles((LocalClientNum_t)v1, (const PlayerHandIndex)v47);
    if ( (unsigned int)v47 >= 2 )
    {
      LODWORD(refreshOverridesOnly) = 2;
      LODWORD(recreateAnimTrees) = v47;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
        __debugbreak();
    }
    if ( *p_viewModelDObj )
    {
      v58 = 1;
      if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x22u) || !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x11u) && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x1Bu) )
        v58 = 0;
      CanHybridToggle = BG_CanHybridToggle(p_predictedPlayerState, r_weapon, v58);
      v59 = BG_WeaponAttachmentAdsSmoothFade(r_weapon, v58);
      fWeaponPosFrac = p_predictedPlayerState->weapCommon.fWeaponPosFrac;
      v61 = v59;
      v62 = CgHandler::getHandler((LocalClientNum_t)v1);
      BG_GetScopeLensSettings(v62, p_predictedPlayerState, r_weapon, v58, fWeaponPosFrac, &v81->scopeToggleInfo.fractionInfo, &settingOut);
      *(float *)&_XMM0 = fWeaponPosFrac;
      if ( v61 )
      {
        fWeaponPosFrac = settingOut.scopeFadeInfo[0].fadeInFrac;
        _XMM0 = CanHybridToggle;
        __asm { vpcmpeqd xmm2, xmm0, xmm1 }
        _XMM1 = LODWORD(settingOut.scopeFadeInfo[1].fadeInFrac);
        __asm { vblendvps xmm0, xmm1, xmm6, xmm2; adsFrac }
      }
      BG_UpdateWeaponGlass(*(const float *)&_XMM0, *p_viewModelDObj, v61);
      CG_GameInterface_UpdateWeaponViewmodelHand((LocalClientNum_t)v1, (PlayerHandIndex)v47);
      if ( BG_CurrentWeaponSupportsDualFOV(weaponMap, p_predictedPlayerState) )
      {
        v67 = CgHandler::getHandler((LocalClientNum_t)v1);
        v68 = BG_PlayerUsesNVGHalfADS(p_predictedPlayerState, v67);
        v69 = DCONST_DVARBOOL_bg_debugSniperScene;
        v76 = v68;
        if ( !DCONST_DVARBOOL_bg_debugSniperScene && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_debugSniperScene") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v69);
        if ( v69->current.enabled )
        {
          BG_DebugSniperScene(r_weapon, v58, *p_viewModelDObj, fWeaponPosFrac);
        }
        else if ( v61 )
        {
          _XMM0 = v76;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm3, xmm7, xmm6, xmm2; adsFrac
          }
          BG_SmoothFadeSniperScene(r_weapon, v58, *p_viewModelDObj, *(float *)&_XMM3);
        }
        else if ( CG_View_IsUsingDualFOV((const LocalClientNum_t)v1) && v81->dualViewScope && !v76 )
        {
          BG_ShowSniperScene(r_weapon, v58, *p_viewModelDObj);
        }
        else
        {
          BG_HideSniperScene(r_weapon, *p_viewModelDObj);
        }
      }
    }
    v48 = -807496i64 - (_QWORD)v81;
    ++v47;
    p_viewModelDObj += 5;
  }
  while ( v47 < 2 );
}

/*
==============
CG_ValidateWeaponAnimGroupsUniqueness
==============
*/
void CG_ValidateWeaponAnimGroupsUniqueness(void)
{
  unsigned __int64 v0; 
  const WeapAnimGroup (*v1)[7]; 
  unsigned __int64 v2; 
  const WeapAnimGroup (*v3)[7]; 
  __int64 v4; 
  __int64 v5; 
  char v6[624]; 

  if ( !validationExecuted )
  {
    validationExecuted = 1;
    memset_0(v6, 0, 0x266ui64);
    v0 = 0i64;
    if ( g_weapAnimGroupCount )
    {
      v1 = g_weapAnimGroups;
      while ( 2 )
      {
        v2 = 0i64;
        v3 = v1;
        do
        {
          if ( !*(_DWORD *)v3 )
            break;
          if ( *(_DWORD *)v3 >= 0x266u )
          {
            LODWORD(v5) = 614;
            LODWORD(v4) = *(_DWORD *)v3;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2777, ASSERT_TYPE_ASSERT, "(unsigned)( groupEntry->animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "groupEntry->animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", v4, v5) )
              __debugbreak();
          }
          if ( v6[*(_DWORD *)v3] )
          {
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DB330, 603i64);
            return;
          }
          ++v2;
          v6[*(_DWORD *)v3] = 1;
          v3 = (const WeapAnimGroup (*)[7])((char *)v3 + 16);
        }
        while ( v2 < 7 );
        ++v0;
        ++v1;
        if ( v0 < g_weapAnimGroupCount )
          continue;
        break;
      }
    }
  }
}

/*
==============
CG_ViewWeaponCleanUp
==============
*/
void CG_ViewWeaponCleanUp(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  int v3; 
  ParticleSystemHandle *p_endEffect; 
  bool ShouldDeferLocalPlayerDraw; 
  ParticleSystemHandle v6; 
  __int64 v7; 
  __int64 v8; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15981, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15984, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v3 = 0;
  p_endEffect = &LocalClientGlobals->laserInfo[0].endEffect;
  ShouldDeferLocalPlayerDraw = CG_LaserShouldDeferLocalPlayerDraw();
  do
  {
    if ( ShouldDeferLocalPlayerDraw )
      *((_BYTE *)p_endEffect - 8) = CG_LaserDrawPlayerDeferredResult((LocalClientNum_t)v1, (const PlayerHandIndex)v3);
    if ( !*((_BYTE *)p_endEffect - 8) || LocalClientGlobals->predictedPlayerState.pm_type >= 7 )
    {
      if ( (unsigned int)v1 >= 2 )
      {
        LODWORD(v8) = 2;
        LODWORD(v7) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v7, v8) )
          __debugbreak();
      }
      v6 = *((_DWORD *)p_endEffect - 1);
      if ( v6 )
      {
        ParticleManager::KillSystem(&g_particleManager[v1], v6);
        *((_DWORD *)p_endEffect - 1) = 0;
      }
      if ( *p_endEffect )
      {
        ParticleManager::KillSystem(&g_particleManager[v1], *p_endEffect);
        *p_endEffect = PARTICLE_SYSTEM_INVALID_HANDLE;
      }
    }
    ++v3;
    p_endEffect += 3;
  }
  while ( v3 < 2 );
  CG_NightVisionValidateFXHandles(LocalClientGlobals);
  if ( LocalClientGlobals->nvgInfo.nightVisionAreaLightFx && (LocalClientGlobals->predictedPlayerState.pm_type >= 7 || !LocalClientGlobals->nvgInfo.nvgAreaLightFXProcessedThisFrame) )
  {
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v8) = 2;
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    ParticleManager::KillSystem(&g_particleManager[v1], LocalClientGlobals->nvgInfo.nightVisionAreaLightFx);
    LocalClientGlobals->nvgInfo.nightVisionAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
  if ( LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx && (LocalClientGlobals->predictedPlayerState.pm_type >= 7 || !LocalClientGlobals->nvgInfo.nvgAreaLightFXProcessedThisFrame) && !CG_NightVisionShouldDrawKillcamLightFX((LocalClientNum_t)v1) )
  {
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v8) = 2;
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    ParticleManager::KillSystem(&g_particleManager[v1], LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx);
    LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CG_ViewmodelShieldHitsProcess
==============
*/
void CG_ViewmodelShieldHitsProcess(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v3; 
  centity_t *Entity; 
  int v5; 
  ShieldHitDelayedEvent *delayedShieldHitEvents; 
  FXRegisteredDef *p_fxRiotShieldImpact; 
  const dvar_t *v8; 
  const char *Name; 
  unsigned __int8 markBoneIndex; 
  unsigned __int8 inOutIndex[4]; 
  int startMsec; 
  int modelIndex; 
  __int64 v14; 
  vec3_t resultNormal; 
  vec3_t halfSize; 
  vec3_t resultPos; 
  tmat33_t<vec3_t> left; 

  v14 = -2i64;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = LocalClientGlobals;
  if ( LocalClientGlobals->predictedPlayerState.pm_type < 7 )
  {
    Entity = CG_GetEntity(localClientNum, LocalClientGlobals->clientNum);
    if ( Entity && (Entity->flags & 1) != 0 )
    {
      Sys_ProfBeginNamedEvent(0xFF000000, "CG_ViewmodelShieldHitsProcess");
      if ( v3->delayedShieldHitEventsCount > 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20932, ASSERT_TYPE_ASSERT, "( 0 ) <= ( cgameGlob->delayedShieldHitEventsCount ) && ( cgameGlob->delayedShieldHitEventsCount ) <= ( 2 )", "cgameGlob->delayedShieldHitEventsCount not in [0, MAX_DELAYED_SHIELD_HIT_EVENTS]\n\t%i not in [%i, %i]", v3->delayedShieldHitEventsCount, 0i64, 2) )
        __debugbreak();
      v5 = 0;
      if ( v3->delayedShieldHitEventsCount > 0 )
      {
        delayedShieldHitEvents = v3->delayedShieldHitEvents;
        do
        {
          if ( CalcViewmodelHitPos(localClientNum, delayedShieldHitEvents->eventParm, &resultPos, &resultNormal) )
          {
            if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_LADDER_AIM) || (p_fxRiotShieldImpact = &cgMedia.fxRiotShieldDamagedImpact, !delayedShieldHitEvents->damaged) )
              p_fxRiotShieldImpact = &cgMedia.fxRiotShieldImpact;
            if ( p_fxRiotShieldImpact->m_particleSystemDef )
            {
              left.m[2] = resultNormal;
              AxisRandomAroundForward(&left.m[2], left.m, &left.m[1]);
              startMsec = CG_GetLocalClientGlobals(localClientNum)->time;
              v8 = DVARBOOL_cg_riotshield_decalfix_enable;
              if ( !DVARBOOL_cg_riotshield_decalfix_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_riotshield_decalfix_enable") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v8);
              if ( v8->current.enabled )
              {
                if ( R_DecalVolumesMarks_DebugEnabled() )
                {
                  halfSize.v[0] = FLOAT_1_0;
                  halfSize.v[1] = FLOAT_1_5;
                  halfSize.v[2] = FLOAT_2_0;
                  R_DecalVolumesMarks_DebugAdd(&resultPos, &halfSize, &left, &colorPink);
                  Name = FXRegisteredDef::GetName(p_fxRiotShieldImpact);
                  Com_Printf(21, "D+ CG mark viewmodel: vfx: %s\n", Name);
                }
                inOutIndex[0] = -2;
                DObjGetBoneIndexInternal_66(v3->m_weaponHand[0].viewModelDObj, scr_const.j_riotshield_offset, inOutIndex, &modelIndex);
                markBoneIndex = inOutIndex[0];
                if ( inOutIndex[0] == 0xFF )
                  markBoneIndex = -2;
                inOutIndex[0] = markBoneIndex;
                FX_PlayOrientedEffectWithMarkViewmodel(localClientNum, p_fxRiotShieldImpact, startMsec, &resultPos, &left, markBoneIndex, MARK_MATERIAL_OVERRIDE_NONE_2);
              }
              else
              {
                FX_PlayOrientedEffectWithMarkViewmodel(localClientNum, p_fxRiotShieldImpact, startMsec, &resultPos, &left, 0xFEu, MARK_MATERIAL_OVERRIDE_NONE_2);
              }
            }
          }
          ++v5;
          ++delayedShieldHitEvents;
        }
        while ( v5 < v3->delayedShieldHitEventsCount );
      }
      v3->delayedShieldHitEventsCount = 0;
      Sys_ProfEndNamedEvent();
    }
    else
    {
      v3->delayedShieldHitEventsCount = 0;
    }
  }
  else
  {
    LocalClientGlobals->delayedShieldHitEventsCount = 0;
  }
}

/*
==============
CG_WeaponAnimGroup_BlendIn
==============
*/
void CG_WeaponAnimGroup_BlendIn(const float blendInDuration, const weapAnimFiles_t animIndex, const PlayerHandIndex handIndex, const float animRate, cg_t *const cgameGlob)
{
  __int64 v7; 
  __int64 v9; 

  v7 = handIndex;
  if ( animRate <= 0.0 )
  {
    __asm { vxorpd  xmm2, xmm2, xmm2 }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2720, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animRate )", "%s < %s\n\t%g, %g", "0.0f", "animRate", *(double *)&_XMM2, animRate) )
      __debugbreak();
  }
  v9 = v7;
  cgameGlob->animGroupBlend[v9].animRate = animRate;
  cgameGlob->animGroupBlend[v9].animIndex = animIndex;
  cgameGlob->animGroupBlend[v9].startTimeMs = cgameGlob->time;
  cgameGlob->animGroupBlend[v7].durationMs = (int)(float)(blendInDuration * 1000.0);
}

/*
==============
CG_WeaponAnimGroup_CalcFireAnimWeights
==============
*/
void CG_WeaponAnimGroup_CalcFireAnimWeights(const cg_t *const cgameGlob, const XAnimTree *animTree, const WeapAnimGroup *const animGroup, const weapAnimFiles_t initialAnimIndex, const Weapon *weapon, const bool isAlternate, float *outWeights)
{
  playerState_s *p_predictedPlayerState; 
  CgHandler *Handler; 
  double v13; 
  float v14; 
  double v15; 
  int v16; 
  unsigned int v17; 
  weapAnimFiles_t AdsLastShotAnim; 
  XAnim_s *Anims; 
  int LengthMsec; 
  const XAnim_s *v21; 
  int v22; 
  unsigned __int64 i; 
  weapAnimFiles_t animIndex; 
  const dvar_t *v25; 
  const char *AnimName; 
  const char *v27; 
  __int64 v28; 
  char output[1024]; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2519, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !animGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2520, ASSERT_TYPE_ASSERT, "(animGroup)", (const char *)&queryFormat, "animGroup") )
    __debugbreak();
  if ( !outWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2521, ASSERT_TYPE_ASSERT, "(outWeights)", (const char *)&queryFormat, "outWeights") )
    __debugbreak();
  p_predictedPlayerState = &cgameGlob->predictedPlayerState;
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  v13 = I_fclamp(COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)(cgameGlob->weaponPosFracAnimData.correctedWeaponPosFrac - 1.0) * (float)(cgameGlob->weaponPosFracAnimData.correctedWeaponPosFrac - 1.0)) * (float)(cgameGlob->weaponPosFracAnimData.correctedWeaponPosFrac - 1.0)) ^ _xmm), 0.0, 1.0);
  v14 = *(float *)&v13;
  v15 = I_fclamp(1.0 - *(float *)&v13, 0.0, 1.0);
  v16 = 241;
  if ( initialAnimIndex == WEAP_ANIM_FIRE || initialAnimIndex == WEAP_ANIM_LASTSHOT )
  {
    v17 = initialAnimIndex;
    if ( initialAnimIndex == WEAP_ANIM_LASTSHOT )
      AdsLastShotAnim = BG_GetAdsLastShotAnim(p_predictedPlayerState, Handler);
    else
      AdsLastShotAnim = BG_GetAdsFireAnim(p_predictedPlayerState, Handler);
    initialAnimIndex = AdsLastShotAnim;
  }
  else
  {
    if ( (unsigned int)(initialAnimIndex - 348) > 1 )
      v16 = 239;
    v17 = v16;
  }
  if ( initialAnimIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2561, ASSERT_TYPE_ASSERT, "(adsAnim != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "adsAnim != WEAP_ANIM_ROOT") )
    __debugbreak();
  Anims = XAnimGetAnims(animTree);
  LengthMsec = -1;
  v21 = Anims;
  v22 = -1;
  for ( i = 0i64; i < 7; ++i )
  {
    animIndex = animGroup->animIndex;
    if ( animGroup->animIndex == WEAP_ANIM_ROOT )
      break;
    if ( animIndex == v17 )
    {
      outWeights[i] = v14;
      LengthMsec = XAnimGetLengthMsec(v21, v17);
    }
    else if ( animIndex == initialAnimIndex )
    {
      outWeights[i] = *(float *)&v15;
      v22 = XAnimGetLengthMsec(v21, initialAnimIndex);
    }
    else
    {
      outWeights[i] = 0.0;
    }
    ++animGroup;
  }
  v25 = DCONST_DVARBOOL_cg_validateAdsHipFireAnimTimes;
  if ( !DCONST_DVARBOOL_cg_validateAdsHipFireAnimTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_validateAdsHipFireAnimTimes") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v25);
  if ( v25->current.enabled && LengthMsec != v22 )
  {
    BG_GetWeaponNameComplete(weapon, isAlternate, output, 0x400u);
    AnimName = XAnimGetAnimName(v21, initialAnimIndex);
    v27 = XAnimGetAnimName(v21, v17);
    LODWORD(v28) = LengthMsec;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DAF80, 602i64, output, v27, v28, AnimName, LengthMsec);
  }
}

/*
==============
CG_WeaponAnimGroup_CalcHipAdsAnimWeights
==============
*/
void CG_WeaponAnimGroup_CalcHipAdsAnimWeights(const cg_t *const cgameGlob, const XAnimTree *animTree, const WeapAnimGroup *const animGroup, const weapAnimFiles_t initialAnimIndex, const Weapon *weapon, const bool isAlternate, const float hipWeight, const float adsWeight, float *outWeights)
{
  CgHandler *Handler; 
  int v12; 
  CgHandler *v13; 
  bool v14; 
  CgHandler *v15; 
  bool v16; 
  float v17; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2616, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !animGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2617, ASSERT_TYPE_ASSERT, "(animGroup)", (const char *)&queryFormat, "animGroup") )
    __debugbreak();
  if ( !outWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2618, ASSERT_TYPE_ASSERT, "(outWeights)", (const char *)&queryFormat, "outWeights") )
    __debugbreak();
  if ( animGroup->animIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2627, ASSERT_TYPE_ASSERT, "(animGroup[0].animIndex != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "animGroup[0].animIndex != WEAP_ANIM_ROOT") )
    __debugbreak();
  if ( animGroup[1].animIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2628, ASSERT_TYPE_ASSERT, "(animGroup[1].animIndex != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "animGroup[1].animIndex != WEAP_ANIM_ROOT") )
    __debugbreak();
  if ( animGroup[2].animIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2629, ASSERT_TYPE_ASSERT, "(animGroup[2].animIndex != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "animGroup[2].animIndex != WEAP_ANIM_ROOT") )
    __debugbreak();
  *outWeights = hipWeight;
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  v12 = BG_ViewModelAnimExists(&cgameGlob->predictedPlayerState, animGroup[1].animIndex, WEAPON_HAND_DEFAULT, Handler);
  v13 = CgHandler::getHandler(cgameGlob->localClientNum);
  v14 = BG_ViewModelAnimExists(&cgameGlob->predictedPlayerState, animGroup[2].animIndex, WEAPON_HAND_DEFAULT, v13) != 0;
  v15 = CgHandler::getHandler(cgameGlob->localClientNum);
  v16 = BG_PlayerUsesNVGHalfADS(&cgameGlob->predictedPlayerState, v15);
  if ( !v12 || v16 && v14 )
    v17 = 0.0;
  else
    v17 = adsWeight;
  outWeights[1] = v17;
  if ( v14 && (v16 || !v12) )
    outWeights[2] = adsWeight;
  else
    outWeights[2] = 0;
}

/*
==============
CG_WeaponAnimGroup_CalcWeights
==============
*/
void CG_WeaponAnimGroup_CalcWeights(const cg_t *const cgameGlob, const XAnimTree *animTree, const WeapAnimGroup *const animGroup, const weapAnimFiles_t initialAnimIndex, const Weapon *weapon, const bool isAlternate, float *outWeights)
{
  double v11; 
  float v12; 
  double v13; 
  __int64 localClientNum; 
  __int64 v15; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2645, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !animGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2646, ASSERT_TYPE_ASSERT, "(animGroup)", (const char *)&queryFormat, "animGroup") )
    __debugbreak();
  if ( !outWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2647, ASSERT_TYPE_ASSERT, "(outWeights)", (const char *)&queryFormat, "outWeights") )
    __debugbreak();
  *(_QWORD *)outWeights = 1065353216i64;
  *((_QWORD *)outWeights + 1) = 0i64;
  *((_QWORD *)outWeights + 2) = 0i64;
  outWeights[6] = 0.0;
  v11 = I_fclamp(1.0 - cgameGlob->weaponPosFracAnimData.correctedWeaponPosFrac, 0.0, 1.0);
  v12 = *(float *)&v11;
  v13 = I_fclamp(1.0 - *(float *)&v11, 0.0, 1.0);
  if ( g_weapAnimGroupCount != 14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2659, ASSERT_TYPE_ASSERT, "(g_weapAnimGroupCount == 14)", "%s\n\tMust update switch statement in CG_Weapons_GetAnimationGroupWeights.", "g_weapAnimGroupCount == 14") )
    __debugbreak();
  switch ( animGroup->animIndex )
  {
    case WEAP_ANIM_FIRE:
    case WEAP_ANIM_LASTSHOT:
    case WEAP_ANIM_ADS_FIRE:
    case WEAP_ANIM_ADS_FIRE_NVG:
    case WEAP_ANIM_ADS_LASTSHOT:
    case WEAP_ANIM_ADS_LASTSHOT_NVG:
      CG_WeaponAnimGroup_CalcFireAnimWeights(cgameGlob, animTree, animGroup, initialAnimIndex, weapon, isAlternate, outWeights);
      break;
    case WEAP_ANIM_RECHAMBER:
      if ( BG_RechamberWhileADS(weapon, isAlternate) )
        CG_WeaponAnimGroup_CalcHipAdsAnimWeights(cgameGlob, animTree, animGroup, initialAnimIndex, weapon, isAlternate, v12, *(const float *)&v13, outWeights);
      break;
    case WEAP_ANIM_ALT_MELEE_LAST:
    case WEAP_ANIM_RELOAD_EMPTY:
    case WEAP_ANIM_RELOAD_START:
    case WEAP_ANIM_RELOAD_START_TWO:
    case WEAP_ANIM_RELOAD_END:
    case WEAP_ANIM_RELOAD_END_RECHAMBER:
    case WEAP_ANIM_FAST_RELOAD_FIRST:
    case WEAP_ANIM_FAST_RELOAD_EMPTY:
    case WEAP_ANIM_FAST_RELOAD_START:
    case WEAP_ANIM_FAST_RELOAD_START_TWO:
    case WEAP_ANIM_FAST_RELOAD_END:
    case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER:
      localClientNum = cgameGlob->localClientNum;
      if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
        __debugbreak();
      if ( BG_ADSReloadEnabled(CgWeaponMap::ms_instance[localClientNum], &cgameGlob->predictedPlayerState, weapon, isAlternate) )
        CG_WeaponAnimGroup_CalcHipAdsAnimWeights(cgameGlob, animTree, animGroup, initialAnimIndex, weapon, isAlternate, v12, *(const float *)&v13, outWeights);
      break;
    default:
      LODWORD(v15) = animGroup->animIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2712, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CG_Weapons_GetAnimationGroupWeights: unrecognized anim group base %i", v15) )
        __debugbreak();
      break;
  }
}

/*
==============
CG_WeaponAnimGroup_Update
==============
*/
void CG_WeaponAnimGroup_Update(const weapAnimFiles_t animIndex, cg_t *const cgameGlob, const PlayerHandIndex handIndex, const Weapon *weapon, const bool isAlternate, XAnimTree *animTree, DObj *obj)
{
  const WeapAnimGroup (*v8)[7]; 
  const Weapon *v9; 
  PlayerHandIndex v10; 
  unsigned __int64 v13; 
  unsigned __int64 v14; 
  const WeapAnimGroup (*v15)[7]; 
  unsigned __int64 v16; 
  const WeapAnimGroup (*v17)[7]; 
  const WeapAnimGroup *v18; 
  int v19; 
  const WeapAnimGroup (*v20)[7]; 
  weapAnimFiles_t v21; 
  __int64 v22; 
  const XAnim_s *Anims; 
  int LengthMsec; 
  float animRate; 
  float v26; 
  float v28; 
  double v29; 
  float v30; 
  int durationMs; 
  float v32; 
  float v33; 
  unsigned __int64 i; 
  float v35; 
  double Weight; 
  __int64 goalTime; 
  float *outWeights; 
  float rate[10]; 
  char v42[624]; 
  __int128 v43; 

  v8 = g_weapAnimGroups;
  v9 = weapon;
  v10 = handIndex;
  if ( validationExecuted )
  {
    v13 = g_weapAnimGroupCount;
  }
  else
  {
    validationExecuted = 1;
    memset_0(v42, 0, 0x266ui64);
    v13 = g_weapAnimGroupCount;
    v14 = 0i64;
    if ( g_weapAnimGroupCount )
    {
      v15 = g_weapAnimGroups;
      while ( 2 )
      {
        v16 = 0i64;
        v17 = v15;
        do
        {
          if ( !*(_DWORD *)v17 )
            break;
          if ( *(_DWORD *)v17 >= 0x266u )
          {
            LODWORD(outWeights) = 614;
            LODWORD(goalTime) = *(_DWORD *)v17;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2777, ASSERT_TYPE_ASSERT, "(unsigned)( groupEntry->animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "groupEntry->animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", goalTime, outWeights) )
              __debugbreak();
          }
          if ( v42[*(_DWORD *)v17] )
          {
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DB330, 603i64);
            v13 = g_weapAnimGroupCount;
            goto LABEL_12;
          }
          ++v16;
          v42[*(_DWORD *)v17] = 1;
          v17 = (const WeapAnimGroup (*)[7])((char *)v17 + 16);
        }
        while ( v16 < 7 );
        v13 = g_weapAnimGroupCount;
        ++v14;
        ++v15;
        if ( v14 < g_weapAnimGroupCount )
          continue;
        break;
      }
LABEL_12:
      v10 = handIndex;
    }
    v9 = weapon;
  }
  v18 = NULL;
  if ( v13 )
  {
    do
    {
      v19 = 0;
      v20 = v8;
      while ( *(_DWORD *)v20 )
      {
        if ( *(_DWORD *)v20 == animIndex )
        {
          v18 = (const WeapAnimGroup *)v8;
          break;
        }
        ++v19;
        v20 = (const WeapAnimGroup (*)[7])((char *)v20 + 16);
        if ( v19 >= 7 )
          break;
      }
      ++v8;
      --v13;
    }
    while ( v13 );
    if ( v18 )
    {
      if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2730, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
        __debugbreak();
      v21 = v18->animIndex;
      if ( v18->animIndex != WEAP_ANIM_FIRE && v21 != WEAP_ANIM_LASTSHOT && (unsigned int)(v21 - 346) > 3 || BG_ShouldBlendFireAnims(v9, isAlternate) )
      {
        v22 = v10;
        if ( cgameGlob->animGroupBlend[v10].animIndex == animIndex )
        {
          v43 = _XMM7;
          Anims = XAnimGetAnims(animTree);
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2819, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          LengthMsec = XAnimGetLengthMsec(Anims, animIndex);
          animRate = cgameGlob->animGroupBlend[v22].animRate;
          v26 = (float)LengthMsec;
          __asm { vxorpd  xmm7, xmm7, xmm7 }
          if ( animRate <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2821, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animGroupBlend->animRate )", "%s < %s\n\t%g, %g", "0.0f", "animGroupBlend->animRate", *(double *)&_XMM7, animRate) )
            __debugbreak();
          v28 = v26 / cgameGlob->animGroupBlend[v22].animRate;
          if ( v28 <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2823, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animDurationMs )", "%s < %s\n\t%g, %g", "0.0f", "animDurationMs", *(double *)&_XMM7, v28) )
            __debugbreak();
          v29 = I_fclamp((float)(cgameGlob->time - cgameGlob->animGroupBlend[v22].startTimeMs) / v28, 0.0, 0.99900001);
          v30 = *(float *)&v29;
          CG_WeaponAnimGroup_CalcWeights(cgameGlob, animTree, v18, (const weapAnimFiles_t)cgameGlob->animGroupBlend[v22].animIndex, v9, isAlternate, rate);
          durationMs = cgameGlob->animGroupBlend[v22].durationMs;
          if ( durationMs > 0 )
          {
            v33 = (float)(cgameGlob->time - cgameGlob->animGroupBlend[v22].startTimeMs) / (float)durationMs;
            I_fclamp(v33, 0.001, 1.0);
            v32 = v33;
          }
          else
          {
            v32 = FLOAT_1_0;
          }
          for ( i = 0i64; i < 7; ++i )
          {
            if ( v18->animIndex == WEAP_ANIM_ROOT )
              break;
            v35 = v32 * rate[i];
            Weight = XAnimGetWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, v18->animIndex);
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v18->animIndex, v35, 0.0, cgameGlob->animGroupBlend[v22].animRate, (scr_string_t)0, v35 > 0.0, 0, LINEAR, NULL);
            if ( *(float *)&Weight <= 0.001 && v35 > 0.001 )
              XAnimSetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, v18->animIndex, v30);
            ++v18;
          }
        }
      }
    }
  }
}

/*
==============
CG_WeaponInspect
==============
*/
void CG_WeaponInspect(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  LocalClientGlobals->extraButtons |= 0x100000000000ui64;
}

/*
==============
CG_WeaponInspect_IsUIHidden
==============
*/
bool CG_WeaponInspect_IsUIHidden(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v2; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals->predictedPlayerState.weapState[0].weaponState != 78 )
    return 0;
  v2 = DCONST_DVARINT_bg_weapon_inspect_dof_off_time_ms;
  if ( !DCONST_DVARINT_bg_weapon_inspect_dof_off_time_ms && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_weapon_inspect_dof_off_time_ms") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  return LocalClientGlobals->predictedPlayerState.weapState[0].weaponTime - v2->current.integer > 0;
}

/*
==============
CG_Weapon_AddViewmodelAccessory
==============
*/
unsigned __int16 CG_Weapon_AddViewmodelAccessory(const LocalClientNum_t localClientNum, const PlayerHandIndex hand, bool isDualWield, const playerState_s *const ps, DObjModel *dobjModels, unsigned __int16 modelCount)
{
  unsigned int accessoryIndex; 
  const AccessoryDef *Def; 
  unsigned __int16 result; 
  CgWeaponMap *Instance; 
  cg_t *LocalClientGlobals; 
  const XModel *WeaponModels; 
  const DObjCamoParams *camoParams; 
  __int64 isUsingDetonator; 
  __int64 isUsingCensorshipWorldModel; 
  unsigned __int16 numModels; 
  DObjCamoParams outLocalParams; 
  Weapon outAccessoryWeapon; 

  numModels = modelCount;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10734, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(isUsingCensorshipWorldModel) = 2;
    LODWORD(isUsingDetonator) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10735, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10736, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10737, ASSERT_TYPE_ASSERT, "( dobjModels ) != ( nullptr )", "%s != %s\n\t%p, %p", "dobjModels", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( numModels >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModel) = 32;
    LODWORD(isUsingDetonator) = numModels;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10738, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  accessoryIndex = ps->accessoryIndex;
  if ( accessoryIndex >= 0x80 )
  {
    LODWORD(isUsingCensorshipWorldModel) = 128;
    LODWORD(isUsingDetonator) = ps->accessoryIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10742, ASSERT_TYPE_ASSERT, "(unsigned)( accessoryIndex ) < (unsigned)( (1<<7) )", "accessoryIndex doesn't index MAX_ACCESSORY_DEFS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  if ( accessoryIndex >= 0x7F )
    return numModels;
  Def = BG_Accessory_GetDef(accessoryIndex);
  if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10748, ASSERT_TYPE_ASSERT, "( accDef ) != ( nullptr )", "%s != %s\n\t%p, %p", "accDef", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( isDualWield )
  {
    if ( hand == WEAPON_HAND_LEFT )
    {
      if ( Def->VMAttachRightHand )
        return numModels;
    }
    else if ( hand == WEAPON_HAND_DEFAULT && !Def->VMAttachRightHand )
    {
      return numModels;
    }
  }
  Instance = CgWeaponMap::GetInstance(localClientNum);
  BG_Accessory_GetWeapon(Instance, ps, &outAccessoryWeapon);
  if ( !outAccessoryWeapon.weaponIdx )
    return numModels;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals->playerWeaponInfo.isAccessoryHidden )
    return numModels;
  if ( numModels >= 0x20u )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DE010, 5842i64);
  WeaponModels = BG_GetWeaponModels(hand, &outAccessoryWeapon, 1, LocalClientGlobals->playerWeaponInfo.isAccessoryDefault, isDualWield, 0, 0);
  if ( !WeaponModels )
    return numModels;
  camoParams = BG_Camo_GetWeaponDObjCamoParams(&outAccessoryWeapon, 1, &outLocalParams);
  DObjInitModel(WeaponModels, Def->VMAttachBone, 0, 0, camoParams, &dobjModels[numModels]);
  result = ++numModels;
  if ( !LocalClientGlobals->playerWeaponInfo.isAccessoryDefault )
  {
    BG_AddWeaponAttachmentModels(&outAccessoryWeapon, hand, isDualWield, 1, 0, 0, dobjModels, 0x20u, &numModels, NULL, camoParams);
    return numModels;
  }
  return result;
}

/*
==============
CG_Weapon_AddViewmodelHand
==============
*/
unsigned __int16 CG_Weapon_AddViewmodelHand(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, const Weapon *r_weapon, const bool isAlternate, DObjModel *dobjModels, unsigned __int16 modelCount, unsigned __int16 *weaponIndex)
{
  XModel *WeaponModels; 
  __int64 v10; 
  __int64 v11; 
  cg_t *LocalClientGlobals; 
  bool v13; 
  bool v14; 
  unsigned __int16 v15; 
  unsigned __int16 v16; 
  cg_t *v17; 
  const XModel **p_rocketModel; 
  const XModel *v19; 
  unsigned __int16 v20; 
  const SuitDef *SuitDef; 
  const XModel *skydive_parachuteViewModel; 
  __int64 isUsingDetonator; 
  __int64 isUsingDetonatora; 
  __int64 isUsingCensorshipWorldModel; 
  __int64 isUsingCensorshipWorldModela; 
  XAnimWeaponIKModelsContainer weaponIKModels; 

  WeaponModels = NULL;
  v10 = localClientNum;
  v11 = hand;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11433, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11434, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( modelCount >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModel) = 32;
    LODWORD(isUsingDetonator) = modelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11435, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v10);
  if ( !CgWeaponMap::ms_instance[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v13 = BG_PlayerOrEntityDualWielding(CgWeaponMap::ms_instance[v10], ps, NULL, NULL);
  v14 = BG_HasLadderHand(ps) && !v13 && (_DWORD)v11 == 1;
  CG_Weapon_UpdateWeaponVisibility((const LocalClientNum_t)v10, ps, r_weapon, isAlternate);
  XAnimWeaponIKModelsContainer::XAnimWeaponIKModelsContainer(&weaponIKModels);
  if ( !v14 )
    WeaponModels = BG_GetWeaponModels((const PlayerHandIndex)v11, r_weapon, 1, LocalClientGlobals->playerWeaponInfo.isWeaponDefault, v13, 0, 0);
  v15 = CG_Weapon_AddViewmodelWeapon((const LocalClientNum_t)v10, (const PlayerHandIndex)v11, v13, r_weapon, isAlternate, WeaponModels, dobjModels, modelCount, weaponIndex, &weaponIKModels);
  v16 = CG_Weapon_AddViewmodelAccessory((const LocalClientNum_t)v10, (const PlayerHandIndex)v11, v13, ps, dobjModels, v15);
  if ( (unsigned int)v10 >= 2 )
  {
    LODWORD(isUsingCensorshipWorldModela) = 2;
    LODWORD(isUsingDetonatora) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10811, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10812, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( v16 >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModela) = 32;
    LODWORD(isUsingDetonatora) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10813, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  v17 = CG_GetLocalClientGlobals((const LocalClientNum_t)v10);
  if ( (unsigned int)v11 >= 2 )
  {
    LODWORD(isUsingCensorshipWorldModela) = 2;
    LODWORD(isUsingDetonatora) = v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  p_rocketModel = (const XModel **)&v17->m_weaponHand[v11].rocketModel;
  v19 = *p_rocketModel;
  if ( *p_rocketModel )
  {
    if ( v16 >= 0x20u )
    {
      XModelGetName(*p_rocketModel);
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DE080, 610i64);
      v19 = *p_rocketModel;
    }
    DObjInitModel(v19, scr_const.tag_clip, 0, 0, NULL, &dobjModels[v16++]);
  }
  v20 = CG_Weapon_AddViewmodelOffhandGesture((const LocalClientNum_t)v10, (PlayerHandIndex)v11, dobjModels, v16);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10648, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10649, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( v20 >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModela) = 32;
    LODWORD(isUsingDetonatora) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10650, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  if ( CG_Skydive_GetViewmodelState((const LocalClientNum_t)LocalClientGlobals->localClientNum) == PhaseSpace )
  {
    SuitDef = BG_GetSuitDef(LocalClientGlobals->predictedPlayerState.suitIndex);
    if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10633, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    skydive_parachuteViewModel = SuitDef->skydive_parachuteViewModel;
    if ( skydive_parachuteViewModel )
    {
      if ( v20 >= 0x20u )
      {
        XModelGetName(skydive_parachuteViewModel);
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DDEC0, 5841i64);
      }
      DObjInitModel(skydive_parachuteViewModel, scr_const.tag_weapon, 0, 0, NULL, &dobjModels[v20++]);
      XAnimWeaponIKModelsContainer::Reset(&weaponIKModels);
      XAnimWeaponIKModelsContainer::AddXModel(&weaponIKModels, WEAPON_HAND_DEFAULT, skydive_parachuteViewModel);
    }
  }
  if ( isAlternate && BG_IsThrowingAxe(r_weapon) )
    return v20;
  else
    return CG_Weapon_AddViewmodelIK((const LocalClientNum_t)v10, (const PlayerHandIndex)v11, ps, r_weapon, &weaponIKModels, dobjModels, v20);
}

/*
==============
CG_Weapon_AddViewmodelHeldModels
==============
*/
void CG_Weapon_AddViewmodelHeldModels(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *r_weapon, const bool recreateAnimTrees, const bool preserveAnimState, const bool updateClientInfo, DObjModel *dobjModels, unsigned __int16 commonModelCount, bool refreshOverridesOnly)
{
  __int16 v9; 
  DObjModel *v10; 
  __int64 v11; 
  const Weapon *v12; 
  cg_t *v14; 
  const Weapon *AltWeapon; 
  __int128 v16; 
  int v17; 
  bool HasLadderHand; 
  bool v19; 
  WeaponHand *v20; 
  int v21; 
  bool v22; 
  bool v23; 
  __int64 i; 
  unsigned int v25; 
  double Weight; 
  const XAnimTree *tree; 
  double GoalWeight; 
  const XAnimTree *v29; 
  double GoalTime; 
  const XAnimTree *v31; 
  double Time; 
  unsigned __int16 v33; 
  unsigned __int16 v34; 
  DObj *v35; 
  unsigned __int16 v36; 
  signed __int64 v37; 
  char *v38; 
  unsigned __int64 j; 
  unsigned __int16 v40; 
  unsigned __int16 v41; 
  Material *v42; 
  Material *v43; 
  DObj *viewModelDObj; 
  float v45; 
  bool v46; 
  const dvar_t *v47; 
  cg_t *LocalClientGlobals; 
  DObj *v49; 
  DObjModel *v50; 
  __int64 modelCount; 
  bool v52; 
  bool v53; 
  bool HandAnimTree; 
  bool v55; 
  bool v56; 
  unsigned __int16 weaponIndex[2]; 
  PlayerHandIndex hand; 
  DObjModel *v60; 
  char obj[416]; 
  float outAnimTimes[4]; 
  float outAnimWeights[4]; 
  XAnimParts *outShieldXParts[4]; 
  float animGoalTimes[56]; 
  float animGoalWeights[56]; 
  float animTimes[56]; 
  float animWeights[56]; 

  v10 = dobjModels;
  v11 = localClientNum;
  v12 = r_weapon;
  *(_QWORD *)&obj[16] = r_weapon;
  *(_QWORD *)&obj[32] = ps;
  v60 = dobjModels;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11543, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11544, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11545, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( commonModelCount > 0x20u )
  {
    LODWORD(modelCount) = 32;
    LODWORD(v50) = commonModelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11546, ASSERT_TYPE_ASSERT, "( commonModelCount ) <= ( ( 32 ) )", "commonModelCount not in [0, DOBJ_MAX_CHARACTER_SUBMODELS]\n\t%u not in [0, %u]", v50, modelCount) )
      __debugbreak();
  }
  *(_QWORD *)&obj[8] = CG_GetLocalClientGlobals((const LocalClientNum_t)v11);
  v14 = *(cg_t **)&obj[8];
  v53 = BG_UsingAlternate(ps);
  if ( v53 )
    AltWeapon = BG_GetAltWeapon(v12);
  else
    AltWeapon = v12;
  *(__m256i *)&obj[200] = *(__m256i *)&AltWeapon->weaponIdx;
  *(_OWORD *)&obj[232] = *(_OWORD *)&AltWeapon->attachmentVariationIndices[5];
  *(_QWORD *)&obj[248] = *(_QWORD *)&AltWeapon->attachmentVariationIndices[21];
  *(_DWORD *)&obj[256] = *(_DWORD *)&AltWeapon->weaponCamo;
  if ( !v9 )
  {
    v16 = *(_OWORD *)&v12->attachmentVariationIndices[5];
    v17 = *(_DWORD *)&v12->weaponCamo;
    *(__m256i *)&obj[200] = *(__m256i *)&v12->weaponIdx;
    *(_QWORD *)&obj[248] = *(_QWORD *)&v12->attachmentVariationIndices[21];
    *(_OWORD *)&obj[232] = v16;
    *(_DWORD *)&obj[256] = v17;
  }
  if ( !CgWeaponMap::ms_instance[v11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v52 = BG_PlayerDualWieldingWeapon(CgWeaponMap::ms_instance[v11], ps, (const Weapon *)&obj[200]) != 0;
  HasLadderHand = BG_HasLadderHand(ps);
  v19 = refreshOverridesOnly;
  v20 = (WeaponHand *)(*(_QWORD *)&obj[8] + 807496i64);
  v56 = HasLadderHand;
  v21 = 0;
  *(_QWORD *)&obj[24] = *(_QWORD *)&obj[8] + 511988i64;
  hand = WEAPON_HAND_DEFAULT;
  *(_QWORD *)&obj[40] = -807496i64 - *(_QWORD *)&obj[8];
  v22 = 1;
  do
  {
    if ( !v22 )
    {
      LODWORD(modelCount) = 2;
      LODWORD(v50) = v21;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v50, modelCount) )
        __debugbreak();
    }
    if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11566, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    v23 = preserveAnimState && v20->tree;
    v55 = v23;
    HandAnimTree = 0;
    if ( v52 || v56 || !v21 )
    {
      if ( !v19 )
      {
        if ( v23 )
        {
          if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10054, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
            __debugbreak();
          for ( i = 0i64; i < 53; ++i )
          {
            v25 = s_persistentAnims[i];
            Weight = XAnimGetWeight(v20->tree, 0, XANIM_SUBTREE_DEFAULT, v25);
            tree = v20->tree;
            animWeights[i] = *(float *)&Weight;
            GoalWeight = XAnimGetGoalWeight(tree, 0, XANIM_SUBTREE_DEFAULT, v25);
            v29 = v20->tree;
            animGoalWeights[i] = *(float *)&GoalWeight;
            GoalTime = XAnimGetGoalTime(v29, 0, XANIM_SUBTREE_DEFAULT, v25);
            v31 = v20->tree;
            animGoalTimes[i] = *(float *)&GoalTime;
            Time = XAnimGetTime(v31, 0, XANIM_SUBTREE_DEFAULT, v25);
            animTimes[i] = *(float *)&Time;
          }
          v14 = *(cg_t **)&obj[8];
          v10 = v60;
          v19 = refreshOverridesOnly;
        }
        StoreShieldPersistentAnims(v20, outAnimWeights, outAnimTimes, (const XAnimParts **)outShieldXParts);
        if ( recreateAnimTrees )
          CG_Weapons_FreeAnimTreeHand((const LocalClientNum_t)v11, (const PlayerHandIndex)v21);
        HandAnimTree = CG_Weapon_CreateHandAnimTree(v14, (const PlayerHandIndex)v21, v12, v53, v52);
      }
      weaponIndex[0] = 255;
      v33 = CG_Weapon_AddViewmodelHand((const LocalClientNum_t)v11, *(const playerState_s **)&obj[32], (const PlayerHandIndex)v21, v12, v53, v10, commonModelCount, weaponIndex);
      v34 = v33;
      if ( v33 > 0x20u )
      {
        LODWORD(modelCount) = 32;
        LODWORD(v50) = v33;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11602, ASSERT_TYPE_ASSERT, "( handModelCount ) <= ( ( 32 ) )", "handModelCount not in [0, DOBJ_MAX_CHARACTER_SUBMODELS]\n\t%u not in [0, %u]", v50, modelCount) )
          __debugbreak();
      }
      if ( v19 && v20->viewModelDObj )
      {
        DObjFreeMaterialOverrides(v20->viewModelDObj);
        DObjFreeMaterialData(v20->viewModelDObj);
      }
      else
      {
        v35 = Com_ClientDObjCreate(v10, v34, v20->tree, v21 + 2048, (LocalClientNum_t)v11, 1, (unsigned int)(v21 != 0) + 2048);
        v36 = weaponIndex[0];
        v20->viewModelDObj = v35;
        CG_Weapon_SetViewmodelWeaponFade((const LocalClientNum_t)v11, (v21 != 0) + 2048, v36, v35);
      }
      DObjSetCamoMaterialOverride(v20->viewModelDObj, v10, v34);
      if ( (unsigned int)v11 >= 2 )
      {
        LODWORD(modelCount) = 2;
        LODWORD(v50) = v11;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19937, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v50, modelCount) )
          __debugbreak();
      }
      memset_0(&obj[48], 0, 0x98ui64);
      v37 = (char *)v12 - (char *)cg_defaultWeaponStickerMaterialIndices;
      v38 = &obj[136];
      for ( j = 0i64; j < 4; ++j )
      {
        v40 = *(unsigned __int16 *)((char *)&cg_defaultWeaponStickerMaterialIndices[j + 1] + v37);
        if ( v40 )
        {
          v41 = cg_defaultWeaponStickerMaterialIndices[j];
          if ( v41 )
          {
            v42 = CG_Draw_StickerMaterialHandleForIndex((LocalClientNum_t)v11, v41);
            v43 = CG_Draw_StickerMaterialHandleForIndex((LocalClientNum_t)v11, v40);
            if ( v42 )
            {
              if ( v43 )
              {
                *(_QWORD *)v38 = v42;
                *((_QWORD *)v38 + 1) = v43;
              }
            }
          }
        }
        v38 += 16;
      }
      viewModelDObj = v20->viewModelDObj;
      *(__m256i *)&obj[264] = *(__m256i *)&obj[48];
      *(__m256i *)&obj[296] = *(__m256i *)&obj[80];
      *(__m256i *)&obj[328] = *(__m256i *)&obj[112];
      *(__m256i *)&obj[360] = *(__m256i *)&obj[144];
      v45 = *(float *)&obj[192];
      *(_OWORD *)&obj[392] = *(_OWORD *)&obj[176];
      *(double *)&obj[408] = *(double *)&obj[192];
      DObjSetStickerMaterialOverrides(viewModelDObj, NULL, (const DObjStickerSlotList *)&obj[264]);
      v19 = refreshOverridesOnly;
      v21 = hand;
      if ( refreshOverridesOnly )
      {
        v14 = *(cg_t **)&obj[8];
      }
      else
      {
        if ( HandAnimTree )
        {
          CG_Weapon_InitHandAnimTree((const LocalClientNum_t)v11, *(const playerState_s **)&obj[32], v20, v55, animWeights, animTimes, animGoalWeights, animGoalTimes, outAnimWeights, outAnimTimes, (const XAnimParts **)outShieldXParts);
          if ( !v55 )
          {
            v47 = DVARBOOL_killswitch_viewmodel_locomotion_state_reset_enabled;
            if ( !DVARBOOL_killswitch_viewmodel_locomotion_state_reset_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_viewmodel_locomotion_state_reset_enabled") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v47);
            if ( v47->current.enabled )
              MovementAnimState::Reset(*(MovementAnimState **)&obj[24], (const LocalClientNum_t)v11, (const PlayerHandIndex)v21);
          }
        }
        v14 = *(cg_t **)&obj[8];
        if ( !*(_BYTE *)(*(_QWORD *)&obj[8] + 99178i64) && !*(_BYTE *)(*(_QWORD *)&obj[8] + 99179i64) )
        {
          LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v11);
          if ( (unsigned int)v21 >= 2 )
          {
            LODWORD(modelCount) = 2;
            LODWORD(v50) = v21;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v50, modelCount) )
              __debugbreak();
          }
          v49 = *(DObj **)((char *)&v20[20187].rocketModel + (_QWORD)LocalClientGlobals + *(_QWORD *)&obj[40]);
          BG_UpdateWeaponHidePartBitsForDObj(v49, (const Weapon *)&obj[200], 1, 0);
          CG_UpdateViewModelHidePartBits_EMP((const LocalClientNum_t)v11, v49);
          CG_UpdateViewModelHidePartBits_NightVisionGoggles((LocalClientNum_t)v11, (const PlayerHandIndex)v21);
          BG_UpdatedWeaponBones((const Weapon *)&obj[200], v20->viewModelDObj, 0);
        }
        if ( updateClientInfo )
          DObjUpdateClientInfo((DObj *)obj, v45, v46, 0);
        v19 = 0;
      }
      v12 = *(const Weapon **)&obj[16];
      v10 = v60;
    }
    else
    {
      CG_Weapons_FreeAnimTreeHand((const LocalClientNum_t)v11, (const PlayerHandIndex)v21);
      CG_Weapon_FreeViewModelDobjHand((const LocalClientNum_t)v11, (const PlayerHandIndex)v21);
    }
    *(_QWORD *)&obj[24] += 16i64;
    ++v21;
    ++v20;
    hand = v21;
    v22 = (unsigned int)v21 < 2;
  }
  while ( v21 < 2 );
}

/*
==============
CG_Weapon_AddViewmodelIK
==============
*/
__int64 CG_Weapon_AddViewmodelIK(const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps, const Weapon *r_weapon, const XAnimWeaponIKModelsContainer *weaponIKModels, DObjModel *dobjModels, unsigned __int16 modelCount)
{
  const dvar_t *v10; 
  bool v11; 
  __int128 v12; 
  int v13; 
  cg_t *LocalClientGlobals; 
  char v15; 
  const SuitDef *SuitDef; 
  bool v17; 
  Weapon weapon; 
  XAnimIKTagRequest tagRequest; 
  XAnimIKTagRequest result[2]; 

  if ( weaponIKModels )
  {
    v10 = DCONST_DVARBOOL_cg_viewmodelRoboticIK;
    if ( !DCONST_DVARBOOL_cg_viewmodelRoboticIK && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelRoboticIK") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    v11 = v10->current.enabled && BG_Suit_IsRoboticIKEnabled(ps->suitIndex);
    v12 = *(_OWORD *)&r_weapon->attachmentVariationIndices[5];
    v13 = *(_DWORD *)&r_weapon->weaponCamo;
    *(__m256i *)&weapon.weaponIdx = *(__m256i *)&r_weapon->weaponIdx;
    *(_QWORD *)&weapon.attachmentVariationIndices[21] = *(_QWORD *)&r_weapon->attachmentVariationIndices[21];
    *(_OWORD *)&weapon.attachmentVariationIndices[5] = v12;
    *(_DWORD *)&weapon.weaponCamo = v13;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( CG_Skydive_GetViewmodelState((const LocalClientNum_t)LocalClientGlobals->localClientNum) == PhaseSpace )
    {
      SuitDef = BG_GetSuitDef(LocalClientGlobals->predictedPlayerState.suitIndex);
      if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10633, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
        __debugbreak();
      if ( SuitDef->skydive_parachuteViewModel )
      {
        v15 = 1;
        memset(&weapon, 0, 48);
        *(double *)&weapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
        *(_DWORD *)&weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
      }
      else
      {
        v15 = 0;
      }
    }
    else
    {
      v15 = 0;
    }
    v17 = BG_UsingAlternate(ps);
    tagRequest = *XAnimIKSetupTagRequest(result, &weapon, v17, v11, 0, 0);
    if ( v15 || !BG_HasLadderHand(ps) )
    {
      if ( XAnimWeaponIKModelsContainer::GetXModelCount((XAnimWeaponIKModelsContainer *)weaponIKModels) > 0 )
      {
        memset_0(result, 0, sizeof(result));
        XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_LEFT_HAND, cg_tagIKTargetModelLeft, weaponIKModels, &tagRequest, dobjModels, &modelCount, (CharacterModelType (*)[32])result);
        XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_RIGHT_HAND, cg_tagIKTargetModelRight, weaponIKModels, &tagRequest, dobjModels, &modelCount, (CharacterModelType (*)[32])result);
      }
    }
    else
    {
      CG_Ladder_AttachIKMarkers(hand, localClientNum, weaponIKModels, &tagRequest, dobjModels, &modelCount);
    }
  }
  return modelCount;
}

/*
==============
CG_Weapon_AddViewmodelOffhandGesture
==============
*/
__int64 CG_Weapon_AddViewmodelOffhandGesture(const LocalClientNum_t localClientNum, PlayerHandIndex hand, DObjModel *dobjModels, unsigned __int16 modelCount)
{
  __int64 v4; 
  __int64 v8; 
  cg_t *LocalClientGlobals; 
  bool v10; 
  const WeaponDef *v11; 
  const XModel *gunXModel; 
  const char *Name; 
  DObjModel *outDObjModel; 
  __int64 v16; 

  v4 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11326, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11327, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( modelCount >= 0x20u )
  {
    LODWORD(v16) = 32;
    LODWORD(outDObjModel) = modelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11328, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", outDObjModel, v16) )
      __debugbreak();
  }
  v8 = v4;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v10 = BG_PlayerOrEntityDualWielding(CgWeaponMap::ms_instance[v8], &LocalClientGlobals->predictedPlayerState, NULL, NULL);
  if ( hand )
  {
    if ( hand == WEAPON_HAND_LEFT && !v10 )
      return modelCount;
  }
  else if ( v10 )
  {
    return modelCount;
  }
  LocalClientGlobals->gestureWeapInfo.gestureWeapModel = NULL;
  if ( LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponIdx )
  {
    v11 = BG_WeaponDef(&LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0);
    gunXModel = v11->gunXModel;
    if ( gunXModel )
    {
      if ( modelCount >= 0x20u )
      {
        Name = XModelGetName(gunXModel);
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DE1E0, 612i64, 32i64, Name);
      }
      if ( CgWeaponSystem::ms_allocatedType == WEAPONS_TYPE_NONE )
      {
        LODWORD(v16) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.h", 530, ASSERT_TYPE_ASSERT, "(ms_allocatedType != CgWeaponsType::WEAPONS_TYPE_NONE)", "%s\n\tTrying to access the weapon system for localClientNum %d but the weapon system type is not known\n", "ms_allocatedType != CgWeaponsType::WEAPONS_TYPE_NONE", v16) )
          __debugbreak();
      }
      if ( (unsigned int)v4 >= CgWeaponSystem::ms_allocatedCount )
      {
        LODWORD(v16) = CgWeaponSystem::ms_allocatedCount;
        LODWORD(outDObjModel) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.h", 531, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", outDObjModel, v16) )
          __debugbreak();
      }
      if ( !CgWeaponSystem::ms_weaponSystemArray[v8] )
      {
        LODWORD(v16) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.h", 532, ASSERT_TYPE_ASSERT, "(ms_weaponSystemArray[localClientNum])", "%s\n\tTrying to access unallocated weapon system for localClientNum %d\n", "ms_weaponSystemArray[localClientNum]", v16) )
          __debugbreak();
      }
      if ( !CgWeaponSystem::ms_weaponSystemArray[v8]->IsWeaponViewModelLoaded(CgWeaponSystem::ms_weaponSystemArray[v8], (const Weapon *)&LocalClientGlobals->gestureWeapInfo) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11353, ASSERT_TYPE_ASSERT, "(CgWeaponSystem::GetWeaponSystem( localClientNum )->IsWeaponViewModelLoaded( cgameGlob->gestureWeapInfo.offhandGestureWeapon ))", (const char *)&queryFormat, "CgWeaponSystem::GetWeaponSystem( localClientNum )->IsWeaponViewModelLoaded( cgameGlob->gestureWeapInfo.offhandGestureWeapon )") )
        __debugbreak();
      DObjInitModel(v11->gunXModel, scr_const.tag_accessory_left, 0, 0, NULL, &dobjModels[modelCount++]);
      LocalClientGlobals->gestureWeapInfo.gestureWeapModel = v11->gunXModel;
      LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible = 1;
    }
  }
  return modelCount;
}

/*
==============
CG_Weapon_AddViewmodelWeapon
==============
*/
__int64 CG_Weapon_AddViewmodelWeapon(const LocalClientNum_t localClientNum, const PlayerHandIndex hand, bool isDualWield, const Weapon *r_weapon, const bool isAlternate, XModel *weaponModel, DObjModel *dobjModels, unsigned __int16 modelCount, unsigned __int16 *weaponIndex, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  cg_t *LocalClientGlobals; 
  const char *WeaponName; 
  const DObjCamoParams *camoParams; 
  unsigned __int16 v16; 
  bool v17; 
  const dvar_t *v18; 
  DObjModel *outDObjModel; 
  DObjModel *v21; 
  unsigned __int16 numModels; 
  bool v23; 
  DObjCamoParams outLocalParams; 
  char output[1024]; 

  numModels = modelCount;
  v23 = isDualWield;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10679, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10680, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( numModels >= 0x20u )
  {
    LODWORD(v21) = 32;
    LODWORD(outDObjModel) = numModels;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10681, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", outDObjModel, v21) )
      __debugbreak();
  }
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(v21) = 2;
    LODWORD(outDObjModel) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10682, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", outDObjModel, v21) )
      __debugbreak();
  }
  if ( !outWeaponIKModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10683, ASSERT_TYPE_ASSERT, "(outWeaponIKModels)", (const char *)&queryFormat, "outWeaponIKModels") )
    __debugbreak();
  if ( weaponModel )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals->playerWeaponInfo.isWeaponHidden )
    {
      if ( !XAnimWeaponIKModelsContainer::AddXModel(outWeaponIKModels, hand, weaponModel) )
      {
        WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
        LODWORD(v21) = 12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10700, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", v21, WeaponName) )
          __debugbreak();
      }
      if ( numModels >= 0x20u )
      {
        XModelGetName(weaponModel);
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DDF40, 609i64);
      }
      camoParams = BG_Camo_GetWeaponDObjCamoParams(r_weapon, 1, &outLocalParams);
      DObjInitModel(weaponModel, scr_const.tag_weapon, 0, 0, camoParams, &dobjModels[numModels]);
      v16 = numModels;
      *weaponIndex = numModels;
      numModels = v16 + 1;
      v17 = !LocalClientGlobals->playerWeaponInfo.isWeaponDefault && !LocalClientGlobals->playerWeaponInfo.hideReticle && Dvar_GetBool_Internal_DebugName(DVARBOOL_cg_lui_scope_reticles, "cg_lui_scope_reticles");
      LocalClientGlobals->shouldShowLUIScopeReticle = v17;
      if ( !LocalClientGlobals->playerWeaponInfo.isWeaponDefault )
        goto LABEL_33;
      v18 = DVARBOOL_cg_weapAllowDefaultModelAttachments;
      if ( !DVARBOOL_cg_weapAllowDefaultModelAttachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapAllowDefaultModelAttachments") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v18);
      if ( v18->current.enabled )
LABEL_33:
        BG_AddWeaponAttachmentModels(r_weapon, hand, v23, 1, 0, 0, dobjModels, 0x20u, &numModels, outWeaponIKModels, camoParams);
    }
  }
  return numModels;
}

/*
==============
CG_Weapon_ChangeViewmodelDobj
==============
*/
void CG_Weapon_ChangeViewmodelDobj(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *r_weapon, XModel *newArms, bool updateClientInfo, bool recreateAnimTrees, bool refreshOverridesOnly, bool tryClearOffset)
{
  XAnimBonePhysicsStateBuffer *p_outStateBuffer; 
  LocalClientNum_t v11; 
  __int64 v12; 
  CgWeaponMap *Instance; 
  char v14; 
  const WeaponDef *v15; 
  int prevDualWielding; 
  int v17; 
  char isAlternate; 
  char v19; 
  Weapon *p_prevViewmodelWeapon; 
  bool v21; 
  ClientPlayerWeaponInfo *p_playerWeaponInfo; 
  bool v23; 
  cg_t *v24; 
  cg_t *v25; 
  playerState_s *v26; 
  int lastAnimIndex; 
  unsigned int animIndex; 
  cg_t *v29; 
  bool v30; 
  XModel *v31; 
  const Weapon *v32; 
  int v33; 
  cg_t *v34; 
  bool v35; 
  char v36; 
  XModel *hiddenViewArms; 
  bool v38; 
  int v39; 
  scr_string_t *v40; 
  XModel *v41; 
  XAnimBonePhysicsStateBuffer *v42; 
  void **v43; 
  DObjPartBits *p_dstParts; 
  WeaponHand *ViewModelHand; 
  void *SkelRecord; 
  int v47; 
  unsigned int NumModels; 
  LocalClientNum_t v49; 
  __int64 v50; 
  int i; 
  cg_t *v52; 
  unsigned __int16 v53; 
  XModel *gogglesModel; 
  const CarryObjectDef *PlayerCarryObjectDef; 
  unsigned __int16 commonModelCount; 
  bool v57; 
  playerState_s *v58; 
  bool v59; 
  scr_string_t *v60; 
  _DWORD *v61; 
  XAnimBonePhysicsStateBuffer *v62; 
  const DObj **p_viewModelDObj; 
  int v64; 
  void **v65; 
  bool v66; 
  int v67; 
  XModel *v68; 
  unsigned int v69; 
  const dvar_t *v70; 
  bool v71; 
  const dvar_t *v72; 
  void *skelRecord0; 
  cg_t *v74; 
  DObjModel *outDObjModel; 
  DObjModel *outDObjModela; 
  DObjModel *dobjModels; 
  unsigned int dobjModelsb; 
  DObjModel *dobjModelsa; 
  char v80; 
  bool v81; 
  char v82; 
  char v83; 
  bool v84; 
  bool v85; 
  int outModelIndex; 
  char v87; 
  unsigned int carryObjectIndex; 
  LocalClientNum_t localClientNuma; 
  void *Buf2; 
  XModel *model; 
  playerState_s *psa; 
  cg_t *LocalClientGlobals; 
  XAnimBonePhysicsStateBuffer *v94; 
  scr_string_t *v95; 
  XModel *handModel; 
  void *v97; 
  void *skelRecord1; 
  CgWeaponSystem *WeaponSystem; 
  DObjPartBits dstParts; 
  DObjPartBits srcParts1; 
  scr_string_t srcPartNames0[254]; 
  scr_string_t srcPartNames1[254]; 
  scr_string_t dstPartNames[508]; 
  DObjModel v105; 
  DObjModel v106; 
  XModel *srcModels0[254]; 
  XModel *srcModels1; 
  XModel *dstModels[508]; 
  XAnimBonePhysicsStateBuffer outStateBuffer; 

  model = newArms;
  p_outStateBuffer = &outStateBuffer;
  Buf2 = (void *)r_weapon;
  psa = (playerState_s *)ps;
  v11 = localClientNum;
  localClientNuma = localClientNum;
  v12 = 2i64;
  do
  {
    XAnimBonePhysicsStateBuffer::XAnimBonePhysicsStateBuffer(p_outStateBuffer++);
    --v12;
  }
  while ( v12 );
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11708, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( r_weapon->weaponIdx >= BG_GetNumWeapons() )
  {
    dobjModelsb = BG_GetNumWeapons();
    LODWORD(outDObjModel) = r_weapon->weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11709, ASSERT_TYPE_ASSERT, "(unsigned)( r_weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "r_weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", outDObjModel, dobjModelsb) )
      __debugbreak();
  }
  memset_0(srcModels0, 0, 0xFE0ui64);
  memset_0(dstModels, 0, sizeof(dstModels));
  if ( !r_weapon->weaponIdx )
    goto LABEL_129;
  LocalClientGlobals = CG_GetLocalClientGlobals(v11);
  Instance = CgWeaponMap::GetInstance(v11);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem(v11);
  v14 = BG_UsingAlternate(ps);
  v15 = BG_WeaponDef(r_weapon, v14);
  prevDualWielding = LocalClientGlobals->prevDualWielding;
  v95 = (scr_string_t *)v15;
  v80 = prevDualWielding != 0;
  v17 = BG_PlayerDualWieldingWeapon(Instance, ps, r_weapon);
  isAlternate = LocalClientGlobals->playerWeaponInfo.isAlternate;
  v19 = v17 != 0;
  v87 = v17 != 0;
  if ( prevDualWielding || v17 || (p_prevViewmodelWeapon = &LocalClientGlobals->prevViewmodelWeapon, memcmp_0(&LocalClientGlobals->prevViewmodelWeapon, Buf2, 0x3Cui64)) || isAlternate == v14 )
  {
    v82 = 0;
    p_prevViewmodelWeapon = &LocalClientGlobals->prevViewmodelWeapon;
  }
  else
  {
    v82 = 1;
  }
  v21 = BG_WeaponsDifferOnlyInVariantForInstantSwitch(psa, LocalClientGlobals->prevWeaponFlags, p_prevViewmodelWeapon, (const Weapon *)Buf2) && LocalClientGlobals->playerWeaponInfo.isAlternate == v14;
  p_playerWeaponInfo = &LocalClientGlobals->playerWeaponInfo;
  handModel = LocalClientGlobals->playerWeaponInfo.handModel;
  v23 = (!memcmp_0(p_prevViewmodelWeapon, Buf2, 0x3Cui64) || v21) && isAlternate == v14 && v80 == v19;
  outModelIndex = LocalClientGlobals->playerWeaponInfo.carryObjectIndex;
  carryObjectIndex = psa->carryState.carryObjectIndex;
  v85 = CG_Skydive_GetViewmodelState(localClientNuma) != LocalClientGlobals->playerWeaponInfo.skydiveViewmodelState;
  if ( !BG_WeaponIsDualWield((const Weapon *)Buf2) || (v83 = 1, *((_DWORD *)v95 + 997) != 1) )
    v83 = 0;
  v24 = CG_GetLocalClientGlobals(localClientNuma);
  v84 = !CG_View_IsUsingDualFOV(localClientNuma) || !v24->dualViewScope || BG_ShowViewModelInDualFOV((const Weapon *)Buf2, v14);
  v25 = CG_GetLocalClientGlobals(localClientNuma);
  if ( !v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9904, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v26 = psa;
  lastAnimIndex = v25->viewModelAnimScriptedInfo.lastAnimIndex;
  animIndex = psa->viewModelAnimScripted.animIndex;
  if ( tryClearOffset && !v83 && !v82 && !v21 && !refreshOverridesOnly )
  {
    v29 = LocalClientGlobals;
    *(_QWORD *)LocalClientGlobals->predictedViewState.weapMoveState.baseAngles.v = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseAngles.z = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseAnglesPivotStand.y = 0i64;
    *(_QWORD *)v29->predictedViewState.weapMoveState.baseAnglesPivotCrouch.v = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseAnglesPivotCrouch.z = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseOrigin.y = 0i64;
  }
  v30 = CG_RegisterWeapon(localClientNuma, v26, LocalClientGlobals->prevWeaponFlags, (const Weapon *)Buf2, p_playerWeaponInfo);
  v31 = model;
  if ( v30 || recreateAnimTrees || handModel != model )
    refreshOverridesOnly = 0;
  p_playerWeaponInfo->handModel = model;
  if ( !v31 )
  {
    v11 = localClientNuma;
LABEL_129:
    CG_Weapon_ViewModelDobj_CleanUp(v11);
    return;
  }
  v32 = (const Weapon *)Buf2;
  v33 = memcmp_0(p_prevViewmodelWeapon, Buf2, 0x3Cui64);
  v34 = LocalClientGlobals;
  v35 = !v33 && LocalClientGlobals->playerWeaponInfo.meleeComboSeqIdx != psa->weapCommon.meleeComboSeqIdx;
  if ( !v23 || v35 || recreateAnimTrees || lastAnimIndex != animIndex || v30 || outModelIndex != carryObjectIndex || v85 || (v36 = v80, v81 = 0, v36 != v87) )
    v81 = 1;
  hiddenViewArms = model;
  if ( !v84 )
    hiddenViewArms = cgMedia.hiddenViewArms;
  v38 = refreshOverridesOnly;
  model = hiddenViewArms;
  if ( refreshOverridesOnly )
  {
    v49 = localClientNuma;
    v50 = 0i64;
  }
  else
  {
    v39 = 0;
    v40 = srcPartNames0;
    v41 = (XModel *)srcModels0;
    carryObjectIndex = 0;
    v42 = &outStateBuffer;
    v95 = srcPartNames0;
    handModel = (XModel *)srcModels0;
    v43 = &v97;
    v94 = &outStateBuffer;
    p_dstParts = &dstParts;
    do
    {
      ViewModelHand = cg_t::GetViewModelHand(v34, (const PlayerHandIndex)v39);
      XAnimBonePhysicsSaveState(ViewModelHand->viewModelDObj, v42);
      if ( ViewModelHand->viewModelDObj )
      {
        SkelRecord = Com_GetSkelRecord(ViewModelHand->viewModelDObj);
        *v43 = SkelRecord;
        DObjTransferSkinningSkelRecordBits(p_dstParts, SkelRecord);
        v47 = 0;
        if ( DObjGetNumBones(ViewModelHand->viewModelDObj) > 0 )
        {
          do
          {
            *v40 = DObjGetBoneNameScriptStringAndModelIndex(ViewModelHand->viewModelDObj, v47, &outModelIndex);
            NumModels = DObjGetNumModels(ViewModelHand->viewModelDObj);
            if ( outModelIndex >= NumModels )
            {
              LODWORD(dobjModels) = DObjGetNumModels(ViewModelHand->viewModelDObj);
              LODWORD(outDObjModel) = outModelIndex;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11806, ASSERT_TYPE_ASSERT, "(unsigned)( boneModelIndex ) < (unsigned)( DObjGetNumModels( weapHand->viewModelDObj ) )", "boneModelIndex doesn't index DObjGetNumModels( weapHand->viewModelDObj )\n\t%i not in [0, %i)", outDObjModel, dobjModels) )
                __debugbreak();
            }
            v41->name = (const char *)DObjGetModel(ViewModelHand->viewModelDObj, outModelIndex);
            ++v47;
            ++v40;
            v41 = (XModel *)((char *)v41 + 8);
          }
          while ( v47 < DObjGetNumBones(ViewModelHand->viewModelDObj) );
          v39 = carryObjectIndex;
          v40 = v95;
          v41 = handModel;
        }
        v42 = v94;
      }
      else
      {
        *v43 = NULL;
        bitarray_simd<256,bitarray_traits_simd128<bitarray_memory_traits_simd128u>>::resetAllBits(p_dstParts);
      }
      v34 = LocalClientGlobals;
      ++v39;
      ++v42;
      carryObjectIndex = v39;
      v41 = (XModel *)((char *)v41 + 2032);
      v94 = v42;
      v40 += 254;
      handModel = v41;
      ++p_dstParts;
      v95 = v40;
      ++v43;
    }
    while ( v39 < 2 );
    v49 = localClientNuma;
    v50 = 0i64;
    for ( i = 0; i < 2; ++i )
      CG_Weapon_FreeViewModelDobjHand(v49, (const PlayerHandIndex)i);
    v32 = (const Weapon *)Buf2;
    v38 = 0;
    hiddenViewArms = model;
  }
  if ( !hiddenViewArms && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10553, ASSERT_TYPE_ASSERT, "(viewHands)", (const char *)&queryFormat, "viewHands") )
    __debugbreak();
  DObjInitModel(hiddenViewArms, (scr_string_t)0, 0, 0, NULL, &v105);
  v52 = LocalClientGlobals;
  v53 = 1;
  gogglesModel = LocalClientGlobals->playerWeaponInfo.gogglesModel;
  if ( gogglesModel )
  {
    DObjInitModel(gogglesModel, scr_const.tag_playerhelmet, 0, 0, NULL, &v106);
    v52->playerWeaponInfo.gogglesAreHidden = 0;
    v53 = 2;
  }
  if ( BG_CarryObject_IsActive(&v52->predictedPlayerState) )
  {
    PlayerCarryObjectDef = BG_GetPlayerCarryObjectDef(&v52->predictedPlayerState);
    if ( !PlayerCarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10599, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
      __debugbreak();
    if ( PlayerCarryObjectDef->carryViewModel )
      DObjInitModel(PlayerCarryObjectDef->carryViewModel, PlayerCarryObjectDef->attachTag, 0, 0, NULL, &v105 + v53++);
  }
  commonModelCount = WeaponSystem->GetWeaponAttachModels(WeaponSystem, v53, &v105);
  v57 = v82 || v85;
  v58 = psa;
  CG_Weapon_AddViewmodelHeldModels(v49, psa, v32, v81, v57, updateClientInfo, &v105, commonModelCount, v38);
  if ( !v38 )
  {
    v59 = BG_UsingAlternate(v58);
    CG_ProcessWeaponOnAltChange(v49, v59);
    carryObjectIndex = 0;
    v60 = NULL;
    model = (XModel *)dstModels;
    v95 = NULL;
    v61 = dstPartNames;
    psa = (playerState_s *)&dstParts;
    v62 = &outStateBuffer;
    Buf2 = dstPartNames;
    p_viewModelDObj = (const DObj **)&v52->m_weaponHand[0].viewModelDObj;
    v94 = &outStateBuffer;
    v64 = 0;
    v65 = &v97;
    v66 = 1;
    do
    {
      if ( !v66 )
      {
        LODWORD(dobjModelsa) = 2;
        LODWORD(outDObjModela) = v64;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", outDObjModela, dobjModelsa) )
          __debugbreak();
      }
      XAnimBonePhysicsRestoreState(*p_viewModelDObj, v62);
      if ( *p_viewModelDObj )
      {
        v67 = 0;
        if ( DObjGetNumBones(*p_viewModelDObj) > 0 )
        {
          v68 = model;
          do
          {
            *v61 = DObjGetBoneNameScriptStringAndModelIndex(*p_viewModelDObj, v67, &outModelIndex);
            v69 = DObjGetNumModels(*p_viewModelDObj);
            if ( outModelIndex >= v69 )
            {
              LODWORD(dobjModelsa) = DObjGetNumModels(*p_viewModelDObj);
              LODWORD(outDObjModela) = outModelIndex;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11856, ASSERT_TYPE_ASSERT, "(unsigned)( boneModelIndex ) < (unsigned)( DObjGetNumModels( weapHand->viewModelDObj ) )", "boneModelIndex doesn't index DObjGetNumModels( weapHand->viewModelDObj )\n\t%i not in [0, %i)", outDObjModela, dobjModelsa) )
                __debugbreak();
            }
            v68->name = (const char *)DObjGetModel(*p_viewModelDObj, outModelIndex);
            ++v67;
            ++v61;
            v68 = (XModel *)((char *)v68 + 8);
          }
          while ( v67 < DObjGetNumBones(*p_viewModelDObj) );
          v64 = carryObjectIndex;
          v60 = v95;
          v61 = Buf2;
        }
        v70 = DVARBOOL_cg_enableSkinningSkelRecordTransferAkimboFix;
        if ( !DVARBOOL_cg_enableSkinningSkelRecordTransferAkimboFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableSkinningSkelRecordTransferAkimboFix") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v70);
        v71 = !v70->current.enabled;
        v72 = DVARBOOL_cg_enableSkinningSkelRecordTransferFix;
        if ( v71 )
        {
          if ( !DVARBOOL_cg_enableSkinningSkelRecordTransferFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableSkinningSkelRecordTransferFix") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v72);
          DObjTransferAndMergeSkinningSkelRecords(*p_viewModelDObj, v72->current.enabled, &dstPartNames[v50], (const XModel **)((char *)dstModels + (_QWORD)v60), (const XModel **)srcModels0, (const XModel **)&srcModels1, srcPartNames0, srcPartNames1, &dstParts, &srcParts1, v97, skelRecord1);
        }
        else
        {
          skelRecord0 = *v65;
          if ( !DVARBOOL_cg_enableSkinningSkelRecordTransferFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableSkinningSkelRecordTransferFix") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v72);
          DObjTransferAndMergeSkinningSkelRecords(*p_viewModelDObj, v72->current.enabled, &dstPartNames[v50], (const XModel **)((char *)dstModels + (_QWORD)v60), (const XModel **)((char *)srcModels0 + (_QWORD)v60), NULL, &srcPartNames0[v50], NULL, (const DObjPartBits *)psa, NULL, skelRecord0, NULL);
          v61 = Buf2;
        }
        v62 = v94;
      }
      psa = (playerState_s *)((char *)psa + 32);
      model = (XModel *)((char *)model + 2032);
      ++v64;
      ++v62;
      carryObjectIndex = v64;
      v60 += 508;
      v94 = v62;
      v61 += 254;
      v95 = v60;
      v50 += 254i64;
      Buf2 = v61;
      p_viewModelDObj += 5;
      ++v65;
      v66 = (unsigned int)v64 < 2;
    }
    while ( v64 < 2 );
    v74 = LocalClientGlobals;
    if ( v83 && v81 )
    {
      if ( v97 && skelRecord1 )
      {
        if ( LocalClientGlobals->viewModelPose.skinCacheEntry.numSkinnedVerts == LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.numSkinnedVerts )
        {
          *(_OWORD *)&LocalClientGlobals->viewModelPose.skinCacheEntry.frameCount = *(_OWORD *)&LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.frameCount;
          *(double *)&v74->viewModelPose.skinCacheEntry.subdivCacheOffset = *(double *)&v74->viewModelPoseLeftHand.skinCacheEntry.subdivCacheOffset;
        }
      }
      else if ( LocalClientGlobals->viewModelPose.skinCacheEntry.numSkinnedVerts == LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.numSkinnedVerts )
      {
        *(_OWORD *)&LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.frameCount = *(_OWORD *)&LocalClientGlobals->viewModelPose.skinCacheEntry.frameCount;
        *(double *)&v74->viewModelPoseLeftHand.skinCacheEntry.subdivCacheOffset = *(double *)&v74->viewModelPose.skinCacheEntry.subdivCacheOffset;
      }
    }
  }
}

/*
==============
CG_Weapon_CreateHandAnimTree
==============
*/
char CG_Weapon_CreateHandAnimTree(cg_t *cgameGlob, const PlayerHandIndex hand, const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding)
{
  __int64 v5; 
  XAnimTree *tree; 
  const WeaponDef *v10; 
  XAnimOwner v11; 
  WeaponXAnim *p_animsTwoHanded; 
  const WeaponDef *v13; 
  WeaponAnimPackage *szXAnims; 
  const WeaponCompleteDef *v15; 
  XAnimTree *SmallTree; 
  XAnim_s *anims; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  v5 = hand;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10271, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( (unsigned int)v5 >= 2 )
  {
    LODWORD(v19) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10272, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v19, 2) )
      __debugbreak();
    LODWORD(v21) = 2;
    LODWORD(v20) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v20, v21) )
      __debugbreak();
  }
  if ( (cg_t *)((char *)cgameGlob + 40 * v5) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10275, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  tree = cgameGlob->m_weaponHand[v5].tree;
  if ( tree )
  {
    if ( !tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10313, ASSERT_TYPE_ASSERT, "(weapHand->tree->anims)", (const char *)&queryFormat, "weapHand->tree->anims") )
      __debugbreak();
    if ( !cgameGlob->m_weaponHand[v5].tree->anims->initialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10314, ASSERT_TYPE_ASSERT, "(weapHand->tree->anims->initialized)", (const char *)&queryFormat, "weapHand->tree->anims->initialized") )
      __debugbreak();
    anims = cgameGlob->m_weaponHand[v5].tree->anims;
    if ( !anims )
    {
      CrashReport_TriggerNow();
      anims = cgameGlob->m_weaponHand[v5].tree->anims;
    }
    if ( !anims->initialized )
      CrashReport_TriggerNow();
    return 0;
  }
  else
  {
    v10 = BG_WeaponDef(r_weapon, isAlternate);
    p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsTwoHanded;
    v13 = v10;
    if ( !cgameGlob->playerWeaponInfo.animsTwoHanded.xanim.size )
    {
      szXAnims = v10->szXAnims;
      if ( szXAnims && *((_QWORD *)szXAnims->anims + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10284, ASSERT_TYPE_ASSERT, "(weapDef->szXAnims == 0 || weapDef->szXAnims->anims[WEAP_ANIM_IDLE] == 0)", (const char *)&queryFormat, "weapDef->szXAnims == NULL || weapDef->szXAnims->anims[WEAP_ANIM_IDLE] == NULL") )
        __debugbreak();
      if ( v13->gunXModel && v13->handXModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10285, ASSERT_TYPE_ASSERT, "(!weapDef->gunXModel || !weapDef->handXModel)", (const char *)&queryFormat, "!weapDef->gunXModel || !weapDef->handXModel") )
        __debugbreak();
      v15 = BG_WeaponCompleteDef(r_weapon, isAlternate);
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DDA40, 605i64, v15->szInternalName);
    }
    if ( isDualWielding && BG_OneHandedViewModelAnimsValid(v13) )
    {
      if ( (_DWORD)v5 )
        p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsLeftHanded;
      else
        p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsRightHanded;
    }
    else if ( isAlternate )
    {
      p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsTwoHandedAltMode;
    }
    if ( !p_animsTwoHanded && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10302, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
      __debugbreak();
    if ( !p_animsTwoHanded->xanim.initialized )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10303, ASSERT_TYPE_ASSERT, "(anims->initialized)", (const char *)&queryFormat, "anims->initialized") )
        __debugbreak();
      if ( !p_animsTwoHanded->xanim.initialized )
        CrashReport_TriggerNow();
    }
    LOBYTE(v11) = 1;
    SmallTree = Com_XAnimCreateSmallTree(&p_animsTwoHanded->xanim, v11);
    if ( !SmallTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9552, ASSERT_TYPE_ASSERT, "(pAnimTree)", (const char *)&queryFormat, "pAnimTree") )
      __debugbreak();
    cgameGlob->m_weaponHand[v5].tree = SmallTree;
    if ( !SmallTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10307, ASSERT_TYPE_ASSERT, "(weapHand->tree)", (const char *)&queryFormat, "weapHand->tree") )
      __debugbreak();
    return 1;
  }
}

/*
==============
CG_Weapon_FreeViewModelDobj
==============
*/
void CG_Weapon_FreeViewModelDobj(const LocalClientNum_t localClientNum)
{
  int v1; 
  bool v2; 
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  __int64 v6; 
  __int64 v7; 

  v1 = 0;
  v2 = 1;
  v4 = 0i64;
  do
  {
    if ( !v2 )
    {
      LODWORD(v7) = 2;
      LODWORD(v6) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10224, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v7) = 2;
      LODWORD(v6) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( LocalClientGlobals->m_weaponHand[v4].viewModelDObj )
    {
      Com_SafeClientDObjFree(v1 + 2048, localClientNum);
      LocalClientGlobals->m_weaponHand[v4].viewModelDObj = NULL;
    }
    ++v1;
    ++v4;
    v2 = (unsigned int)v1 < 2;
  }
  while ( v1 < 2 );
}

/*
==============
CG_Weapon_FreeViewModelDobjHand
==============
*/
void CG_Weapon_FreeViewModelDobjHand(const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  int v4; 
  cg_t *LocalClientGlobals; 
  WeaponHand *v6; 
  __int64 v7; 
  __int64 v9; 
  int v10; 

  v2 = hand;
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    v10 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10224, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hand, v10) )
      __debugbreak();
  }
  v4 = v2 + 2048;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v2 >= 2 )
  {
    LODWORD(v9) = 2;
    LODWORD(v7) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v7, v9) )
      __debugbreak();
  }
  v6 = &LocalClientGlobals->m_weaponHand[v2];
  if ( v6->viewModelDObj )
  {
    Com_SafeClientDObjFree(v4, localClientNum);
    v6->viewModelDObj = NULL;
  }
}

/*
==============
CG_Weapon_GetRecoilAnims
==============
*/
void CG_Weapon_GetRecoilAnims(const LocalClientNum_t localClientNum, const playerState_s *const ps, weapAnimFiles_t *outRootAnim, weapAnimFiles_t *outRecoilAnim, bool *outIsAdditive)
{
  cg_t *LocalClientGlobals; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5970, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !outRootAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5971, ASSERT_TYPE_ASSERT, "(outRootAnim)", (const char *)&queryFormat, "outRootAnim") )
    __debugbreak();
  if ( !outRecoilAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5972, ASSERT_TYPE_ASSERT, "(outRecoilAnim)", (const char *)&queryFormat, "outRecoilAnim") )
    __debugbreak();
  if ( !outIsAdditive && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5973, ASSERT_TYPE_ASSERT, "(outIsAdditive)", (const char *)&queryFormat, "outIsAdditive") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5976, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( &LocalClientGlobals->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5977, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
    __debugbreak();
  p_m_weaponAnimArrays = &LocalClientGlobals->m_weaponAnimArrays;
  if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5980, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( BG_UsingAlternate(ps) )
    p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
  *outIsAdditive = 0;
  *outRootAnim = WEAP_ANIM_RECOIL;
  *outRecoilAnim = WEAP_ANIM_RECOIL;
  if ( p_m_weaponAnimArrays->normalAnimArray[176] )
  {
    *outIsAdditive = 1;
    *outRootAnim = WEAP_ANIM_ADDITIVE_RECOIL_ROOT;
    *outRecoilAnim = WEAP_ANIM_ADDITIVE_RECOIL;
  }
}

/*
==============
CG_Weapon_InitHandAnimTree
==============
*/
void CG_Weapon_InitHandAnimTree(const LocalClientNum_t localClientNum, const playerState_s *ps, WeaponHand *weapHand, const bool restoreAnimState, const float *animWeights, const float *animTimes, const float *animGoalWeights, const float *animGoalTimes, const float *shieldAnimWeights, const float *shieldAnimTimes, const XAnimParts **shieldXAnimParts)
{
  XAnimTree *tree; 
  CgHandler *Handler; 
  unsigned int AdsDownAnim; 
  DObj *objID; 

  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10326, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !animWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10327, ASSERT_TYPE_ASSERT, "(animWeights)", (const char *)&queryFormat, "animWeights") )
    __debugbreak();
  if ( !animTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10328, ASSERT_TYPE_ASSERT, "(animTimes)", (const char *)&queryFormat, "animTimes") )
    __debugbreak();
  if ( !animGoalWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10329, ASSERT_TYPE_ASSERT, "(animGoalWeights)", (const char *)&queryFormat, "animGoalWeights") )
    __debugbreak();
  if ( !animGoalTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10330, ASSERT_TYPE_ASSERT, "(animGoalTimes)", (const char *)&queryFormat, "animGoalTimes") )
    __debugbreak();
  tree = weapHand->tree;
  objID = weapHand->viewModelDObj;
  weapHand->iPrevAnim = -1;
  XAnimClearTreeGoalWeights(tree, 0, XANIM_SUBTREE_DEFAULT, 0, 0.0, 1, objID, LINEAR);
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 1u, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xEu, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 8u, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xAu, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xBu, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  Handler = CgHandler::getHandler(localClientNum);
  AdsDownAnim = BG_GetAdsDownAnim(ps, Handler);
  if ( weapHand->tree->anims->entries[AdsDownAnim].parts != *(XAnimParts **)&weapHand->tree->anims[40].numGameParameters )
  {
    XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, 1.0, 0.0, 0.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
    XAnimSetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, 1.0);
  }
  if ( restoreAnimState )
    RestorePersistentAnims(weapHand, animWeights, animTimes, animGoalWeights, animGoalTimes);
  RestoreShieldPersistentAnims(weapHand, shieldAnimWeights, shieldAnimTimes, shieldXAnimParts);
}

/*
==============
CG_Weapon_PlayADSSettleAnim
==============
*/
void CG_Weapon_PlayADSSettleAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, float weaponPosFrac, DObj *obj, PlayerHandIndex hand, float settleAnimWeight)
{
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  signed int AdsSettleAnim; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned int OtherAdsSettleAnim; 
  double GoalWeight; 
  float v18; 
  double Time; 
  float v20; 
  double v21; 
  double v22; 

  if ( CG_GameInterface_PlayADSSettleAnim(localClientNum, ps, weaponPosFrac, obj, hand, settleAnimWeight) )
    return;
  Handler = CgHandler::getHandler(localClientNum);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  AdsSettleAnim = BG_GetAdsSettleAnim(ps, hand, Handler);
  if ( !AdsSettleAnim )
    return;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, ps);
  if ( BG_PlayerDualWieldingWeapon(Instance, ps, CurrentWeaponForPlayer) )
    return;
  OtherAdsSettleAnim = BG_GetOtherAdsSettleAnim((const weapAnimFiles_t)AdsSettleAnim);
  if ( LocalClientGlobals->adsSettlePending )
  {
    if ( weaponPosFrac <= 0.0 )
    {
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA3u, 1.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsSettleAnim, settleAnimWeight, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
      if ( OtherAdsSettleAnim )
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsSettleAnim, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      LocalClientGlobals->adsSettlePending = 0;
      LocalClientGlobals->adsSettleMaxADSFraction = 0.0;
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if ( weaponPosFrac > 0.0 )
  {
LABEL_10:
    _XMM0 = LODWORD(LocalClientGlobals->adsSettleMaxADSFraction);
    __asm { vmaxss  xmm1, xmm0, xmm9 }
    LocalClientGlobals->adsSettleMaxADSFraction = *(float *)&_XMM1;
    LocalClientGlobals->adsSettlePending = 1;
  }
LABEL_11:
  GoalWeight = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xA3u);
  v18 = *(float *)&GoalWeight;
  Time = XAnimGetTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, AdsSettleAnim);
  v20 = *(float *)&Time;
  v21 = XAnimGetTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, OtherAdsSettleAnim);
  if ( v20 == 1.0 || *(float *)&v21 == 1.0 )
  {
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA3u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsSettleAnim, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsSettleAnim, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  else if ( v18 > 0.0 )
  {
    v22 = I_fclamp(1.0 - weaponPosFrac, 0.001, 1.0);
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA3u, *(float *)&v22, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
}

/*
==============
CG_Weapon_SetViewmodelWeaponFade
==============
*/
void CG_Weapon_SetViewmodelWeaponFade(const LocalClientNum_t localClientNum, const unsigned int entNum, const unsigned __int16 weaponIndex, DObj *weapHandDObj)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v9; 
  unsigned __int8 *modelEntityDataOffset; 
  unsigned __int8 numModels; 
  unsigned __int8 v12; 
  __int64 v13; 
  bool v14; 
  __int64 v15; 

  if ( !weapHandDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11475, ASSERT_TYPE_ASSERT, "( ( weapHandDObj != nullptr ) )", "( weapHandDObj ) = %p", NULL) )
    __debugbreak();
  if ( weaponIndex == 255 )
  {
    CG_WeaponFade_Init(localClientNum);
  }
  else
  {
    if ( weaponIndex > weapHandDObj->numModels )
    {
      LODWORD(v15) = weaponIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11484, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( weapHandDObj->numModels )", "weaponIndex not in [0, weapHandDObj->numModels]\n\t%u not in [0, %u]", v15, weapHandDObj->numModels) )
        __debugbreak();
    }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11487, ASSERT_TYPE_ASSERT, "( ( cgameGlob != nullptr ) )", "( cgameGlob ) = %p", NULL) )
      __debugbreak();
    if ( LocalClientGlobals->playerWeaponInfo.isWeaponDefault )
      CG_WeaponFade_InitFadedWeaponForEntity(localClientNum, entNum);
    else
      CG_WeaponFade_StartWeaponTransition(localClientNum, entNum);
    if ( CG_WeaponFade_IsWeaponFadedForEntity(localClientNum, entNum) )
    {
      if ( !weapHandDObj->materialData )
      {
        DObjAllocMaterialData(weapHandDObj);
        if ( !weapHandDObj->materialData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11506, ASSERT_TYPE_ASSERT, "( ( weapHandDObj->materialData != nullptr ) )", "( weapHandDObj->materialData ) = %p", NULL) )
          __debugbreak();
      }
      if ( !weapHandDObj->materialData->modelEntityDataOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11507, ASSERT_TYPE_ASSERT, "( ( weapHandDObj->materialData->modelEntityDataOffset != nullptr ) )", "( weapHandDObj->materialData->modelEntityDataOffset ) = %p", NULL) )
        __debugbreak();
      v9 = DCONST_DVARBOOL_cg_weaponFade_applyToViewmodel;
      modelEntityDataOffset = weapHandDObj->materialData->modelEntityDataOffset;
      if ( !DCONST_DVARBOOL_cg_weaponFade_applyToViewmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weaponFade_applyToViewmodel") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v9);
      numModels = weapHandDObj->numModels;
      if ( v9->current.enabled )
      {
        memset_0(modelEntityDataOffset, 0, numModels);
      }
      else
      {
        v12 = 0;
        if ( numModels )
        {
          do
          {
            v13 = v12;
            v14 = (unsigned __int16)v12++ != weaponIndex;
            modelEntityDataOffset[v13] = v14;
          }
          while ( v12 < weapHandDObj->numModels );
        }
      }
    }
  }
}

/*
==============
CG_Weapon_UpdateWeaponVisibility
==============
*/
char CG_Weapon_UpdateWeaponVisibility(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  const dvar_t *v4; 
  char v5; 
  char v6; 
  __int64 v9; 
  char enabled; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v12; 
  int weaponState; 
  unsigned __int64 v14; 
  __int64 v15; 
  bool v16; 
  const dvar_t *v17; 
  bool v18; 
  SkydiveViewmodelState ViewmodelState; 
  CgWeaponSystem *WeaponSystem; 
  const dvar_t *v21; 
  const dvar_t *v22; 
  float v23; 
  float v24; 
  double v25; 
  Material *whiteMaterial; 
  int fireDelay[4]; 
  int fireTime; 

  v4 = DCONST_DVARBOOL_cg_weapForceDefaultModel;
  v5 = 0;
  v6 = 0;
  v9 = localClientNum;
  if ( !DCONST_DVARBOOL_cg_weapForceDefaultModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapForceDefaultModel") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  enabled = v4->current.enabled;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v9);
  if ( !CgWeaponMap::ms_instance[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v12 = CgWeaponMap::ms_instance[v9];
  if ( BG_IsOffhandWeaponType(r_weapon, 0) )
  {
    weaponState = ps->weapState[0].weaponState;
    if ( weaponState == 16 || weaponState == 30 )
    {
      BG_GetFireTime(v12, ps, r_weapon, 0, 0, ps->weapState[0].weaponShotCount, &fireTime, fireDelay);
      if ( fireDelay[0] < fireTime )
        v6 = ps->weapState[0].weaponDelay == 0;
    }
  }
  if ( BG_HasLadderHand(ps) )
  {
    v14 = ps->weapState[0].weaponState;
    if ( (unsigned int)v14 <= 0x32 )
    {
      v15 = 0x6800000005020i64;
      if ( _bittest64(&v15, v14) )
      {
        v16 = BG_UsingAlternate(ps);
        if ( !BG_IsLadderWeapon(r_weapon, v16) )
          goto LABEL_21;
        v17 = DCONST_DVARMPBOOL_ladderEnableWeapon;
        if ( !DCONST_DVARMPBOOL_ladderEnableWeapon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableWeapon") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v17);
        if ( !v17->current.enabled || (v18 = BG_UsingAlternate(ps), !BG_GetAmmoInClip(ps, r_weapon, v18, WEAPON_HAND_DEFAULT)) )
LABEL_21:
          v6 = 1;
      }
    }
  }
  ViewmodelState = CG_Skydive_GetViewmodelState((const LocalClientNum_t)v9);
  if ( ViewmodelState )
  {
    if ( ViewmodelState == Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10460, ASSERT_TYPE_ASSERT, "(skydiveViewmodelState != SkydiveViewmodelState::Count)", (const char *)&queryFormat, "skydiveViewmodelState != SkydiveViewmodelState::Count") )
      __debugbreak();
    v6 = 1;
  }
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v9);
  if ( !WeaponSystem->IsWeaponViewModelLoaded(WeaponSystem, r_weapon) )
  {
    if ( BG_HasDefaultViewModel(r_weapon) )
      enabled = 1;
    else
      v6 = 1;
  }
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10362, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v21 = DVARBOOL_cg_weapOverrideDefaultModelMat;
  if ( !DVARBOOL_cg_weapOverrideDefaultModelMat && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapOverrideDefaultModelMat") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v21);
  if ( v21->current.enabled )
  {
    if ( enabled )
    {
      LocalClientGlobals->defaultViewmodelOverride.materialTargetType = Scriptable_MaterialOverrideType_Dissolve;
      LocalClientGlobals->defaultViewmodelOverride.targetMaterial = cgMedia.whiteMaterial;
      LocalClientGlobals->defaultViewmodelOverride.transitionIn = 0;
      LocalClientGlobals->defaultViewmodelOverride.transitionLerp = 1.0;
      LocalClientGlobals->defaultViewmodelMaterialTime = 0;
    }
    else if ( LocalClientGlobals->playerWeaponInfo.isWeaponDefault )
    {
      LocalClientGlobals->defaultViewmodelMaterialTime = LocalClientGlobals->time;
    }
    if ( LocalClientGlobals->defaultViewmodelMaterialTime )
    {
      v22 = DVARFLT_cg_weapOverrideDefaultModelTrans;
      if ( !DVARFLT_cg_weapOverrideDefaultModelTrans && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapOverrideDefaultModelTrans") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v22);
      v23 = v22->current.value * 1000.0;
      v24 = (float)(LocalClientGlobals->time - LocalClientGlobals->defaultViewmodelMaterialTime);
      LocalClientGlobals->refreshViewmodelMaterialOverride = 1;
      if ( v23 <= 0.0 || v24 >= v23 )
      {
        LocalClientGlobals->defaultViewmodelMaterialTime = 0;
        *(_QWORD *)&LocalClientGlobals->defaultViewmodelOverride.entityNum = 0i64;
        LocalClientGlobals->defaultViewmodelOverride.targetMaterial = NULL;
        *(_QWORD *)&LocalClientGlobals->defaultViewmodelOverride.transitionLerp = 0i64;
      }
      else
      {
        v25 = I_fclamp(v24 / v23, 0.0, 1.0);
        LocalClientGlobals->defaultViewmodelOverride.materialTargetType = Scriptable_MaterialOverrideType_Dissolve;
        whiteMaterial = cgMedia.whiteMaterial;
        LocalClientGlobals->defaultViewmodelOverride.transitionLerp = 1.0 - *(float *)&v25;
        LocalClientGlobals->defaultViewmodelOverride.targetMaterial = whiteMaterial;
        LocalClientGlobals->defaultViewmodelOverride.transitionIn = 0;
      }
    }
  }
  if ( v6 != LocalClientGlobals->playerWeaponInfo.isWeaponHidden )
  {
    LocalClientGlobals->playerWeaponInfo.isWeaponHidden = v6;
    v5 = 1;
  }
  if ( enabled == LocalClientGlobals->playerWeaponInfo.isWeaponDefault )
    return v5;
  LocalClientGlobals->playerWeaponInfo.isWeaponDefault = enabled;
  return 1;
}

/*
==============
CG_Weapon_ViewModelDobj_CleanUp
==============
*/
void CG_Weapon_ViewModelDobj_CleanUp(const LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  int v3; 
  XAnimTree **p_tree; 
  bool v5; 
  __int64 v6; 
  __int64 v7; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10253, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v3 = 0;
  p_tree = &LocalClientGlobals->m_weaponHand[0].tree;
  v5 = 1;
  do
  {
    if ( !v5 )
    {
      LODWORD(v7) = 2;
      LODWORD(v6) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( !*p_tree )
      CG_Weapon_FreeViewModelDobjHand(localClientNum, (const PlayerHandIndex)v3);
    ++v3;
    p_tree += 5;
    v5 = (unsigned int)v3 < 2;
  }
  while ( v3 < 2 );
}

/*
==============
CG_Weapons_ActionSlotTypeUsageAllowed
==============
*/
char CG_Weapons_ActionSlotTypeUsageAllowed(const cg_t *const cgameGlob, const ActionSlotType type)
{
  CgWeaponMap *Instance; 
  CgHandler *Handler; 
  unsigned __int64 weaponState; 
  __int64 v7; 
  bool v8; 
  bool v9; 
  unsigned int v10; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17990, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !cgameGlob->nextSnap || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x10u) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0xFu) )
    return 0;
  Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  if ( (unsigned int)(type - 4) > 2 )
  {
    weaponState = cgameGlob->predictedPlayerState.weapState[0].weaponState;
    v8 = 0;
    if ( (unsigned int)weaponState <= 0x32 )
    {
      v7 = 0x4000000001FBEi64;
      if ( _bittest64(&v7, weaponState) )
        v8 = 1;
    }
    v9 = (unsigned int)(weaponState - 22) <= 2;
    v10 = weaponState - 26;
    if ( (v8 || v9 || v10 <= 6) && !PM_Weapon_IsInInterruptibleState(Instance, &cgameGlob->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler) )
      return 0;
    if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xAu) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xEu) && type != ACTIONSLOTTYPE_NIGHTVISION || BG_Offhand_HasNonInterruptibleActiveOffhand(Instance, &cgameGlob->predictedPlayerState, cgameGlob->time) )
      return 0;
  }
  if ( type != ACTIONSLOTTYPE_TAUNT && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) && !PM_Weapon_IsInInterruptibleState(Instance, &cgameGlob->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler) || !BG_IsPlayer(&cgameGlob->predictedPlayerState) || cgameGlob->IsClientGamePaused((cg_t *)cgameGlob) || GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cgameGlob->predictedPlayerState.eFlags, ACTIVE, 0xBu) )
    return 0;
  if ( type > ACTIONSLOTTYPE_DONOTHING )
  {
    if ( type <= ACTIONSLOTTYPE_ALTWEAPONTOGGLE )
    {
      if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 6u) || BG_IsTurretActive(&cgameGlob->predictedPlayerState) || cgameGlob->predictedPlayerState.vehicleState.entity != 2047 || Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|WEAPON_LADDER_AIM) && (unsigned int)(cgameGlob->predictedPlayerState.weapState[0].weaponState - 28) <= 1 )
        return 0;
    }
    else if ( (unsigned int)(type - 4) <= 2 && !BG_IsPlayerZeroG(&cgameGlob->predictedPlayerState) )
    {
      return 0;
    }
  }
  return 1;
}

/*
==============
CG_Weapons_ActionSlotUsageAllowed
==============
*/
bool CG_Weapons_ActionSlotUsageAllowed(const cg_t *const cgameGlob, const int slot)
{
  __int64 v2; 
  ActionSlotType v4; 

  v2 = slot;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17971, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v4 = cgameGlob->predictedPlayerState.actionSlotType[v2];
  return ((_DWORD)v2 != 3 || !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 5u)) && CG_Weapons_ActionSlotTypeUsageAllowed(cgameGlob, v4);
}

/*
==============
CG_Weapons_BlendOutOfRelativeSkydiveAnim
==============
*/
void CG_Weapons_BlendOutOfRelativeSkydiveAnim(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const Weapon *weapon, const bool isAlternate, const bool isDualWielding, const int playerDualWieldingWeapon, const weapAnimFiles_t skydiveAnimIndex)
{
  XAnim_s *v13; 
  double GoalWeight; 
  __int64 goalTime; 
  float anims; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6428, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6429, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(goalTime) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6430, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  v13 = XAnimGetAnims(obj->tree);
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6433, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  GoalWeight = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, skydiveAnimIndex);
  if ( *(float *)&GoalWeight != 0.0 )
  {
    anims = CG_Weapons_GetWeaponAnimRate(localClientNum, ps, hand, weapon, isAlternate, isDualWielding, v13, skydiveAnimIndex, skydiveAnimIndex, playerDualWieldingWeapon);
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, skydiveAnimIndex, 0.0, BLEND_OUT_TIME, anims, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
}

/*
==============
CG_Weapons_BuildDObj
==============
*/
void CG_Weapons_BuildDObj(const PlayerHandIndex hand, const Weapon *r_weapon, const bool useViewModel, const bool useStowedModel, const bool useDefaultModel, const bool useDualWielding, scr_string_t attachBoneName, const unsigned int maxDObjModels, DObjModel *outDObjModels, unsigned __int16 *outModelIndex, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  PlayerHandIndex v13; 
  WeaponDef *weapDef; 
  scr_string_t tag_shield_back; 
  ClGameModeApplication *ActiveClientApplication; 
  const XModel *stowOffsetModel; 
  const XModel *WeaponModels; 
  const XModel *v19; 
  const char *WeaponName; 
  const DObjCamoParams *camoParams; 
  unsigned __int16 maxModels; 
  DObjModel *outDObjModel; 
  DObjModel *outDObjModela; 
  __int64 isUsingCensorshipWorldModel; 
  __int64 isUsingCensorshipWorldModela; 
  DObjCamoParams outLocalParams; 
  char output[1024]; 

  v13 = hand;
  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25817, ASSERT_TYPE_ASSERT, "(!BG_IsNullWeapon( r_weapon ))", (const char *)&queryFormat, "!BG_IsNullWeapon( r_weapon )") )
    __debugbreak();
  if ( !outDObjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25818, ASSERT_TYPE_ASSERT, "(outDObjModels)", (const char *)&queryFormat, "outDObjModels") )
    __debugbreak();
  if ( !outModelIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25819, ASSERT_TYPE_ASSERT, "(outModelIndex)", (const char *)&queryFormat, "outModelIndex") )
    __debugbreak();
  if ( *outModelIndex >= maxDObjModels )
  {
    LODWORD(outDObjModel) = *outModelIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25820, ASSERT_TYPE_ASSERT, "(unsigned)( *outModelIndex ) < (unsigned)( maxDObjModels )", "*outModelIndex doesn't index maxDObjModels\n\t%i not in [0, %i)", outDObjModel, maxDObjModels) )
      __debugbreak();
  }
  weapDef = BG_WeaponCompleteDef(r_weapon, 0)->weapDef;
  if ( !useStowedModel )
  {
    tag_shield_back = attachBoneName;
    goto LABEL_34;
  }
  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25792, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  tag_shield_back = attachBoneName;
  if ( weapDef->stowOffsetModel )
  {
    ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
    if ( ActiveClientApplication->IsModelLoaded(ActiveClientApplication, weapDef->stowOffsetModel) )
    {
      stowOffsetModel = weapDef->stowOffsetModel;
LABEL_22:
      if ( stowOffsetModel )
      {
        if ( *outModelIndex >= maxDObjModels )
        {
          LODWORD(isUsingCensorshipWorldModel) = maxDObjModels;
          LODWORD(outDObjModel) = *outModelIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25830, ASSERT_TYPE_ASSERT, "(unsigned)( *outModelIndex ) < (unsigned)( maxDObjModels )", "*outModelIndex doesn't index maxDObjModels\n\t%i not in [0, %i)", outDObjModel, isUsingCensorshipWorldModel) )
            __debugbreak();
        }
        DObjInitModel(stowOffsetModel, attachBoneName, 1, 0, NULL, &outDObjModels[*outModelIndex]);
        ++*outModelIndex;
      }
      v13 = hand;
      goto LABEL_28;
    }
    if ( weapDef->stowOffsetModel == weapDef->worldModel )
    {
      stowOffsetModel = weapDef->defaultWorldModel;
      goto LABEL_22;
    }
  }
LABEL_28:
  if ( BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_RIOTSHIELD )
  {
    tag_shield_back = scr_const.tag_shield_back;
  }
  else if ( weapDef->stowTag )
  {
    tag_shield_back = weapDef->stowTag;
  }
LABEL_34:
  WeaponModels = BG_GetWeaponModels(v13, r_weapon, useViewModel, useDefaultModel, useDualWielding, 0, 0);
  v19 = WeaponModels;
  if ( WeaponModels )
  {
    if ( outWeaponIKModels )
    {
      if ( !XAnimWeaponIKModelsContainer::AddXModel(outWeaponIKModels, hand, WeaponModels) )
      {
        WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
        LODWORD(isUsingCensorshipWorldModela) = 12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25859, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", isUsingCensorshipWorldModela, WeaponName) )
          __debugbreak();
      }
    }
    camoParams = BG_Camo_GetWeaponDObjCamoParams(r_weapon, useViewModel, &outLocalParams);
    if ( *outModelIndex >= maxDObjModels )
    {
      LODWORD(isUsingCensorshipWorldModela) = maxDObjModels;
      LODWORD(outDObjModela) = *outModelIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25866, ASSERT_TYPE_ASSERT, "(unsigned)( *outModelIndex ) < (unsigned)( maxDObjModels )", "*outModelIndex doesn't index maxDObjModels\n\t%i not in [0, %i)", outDObjModela, isUsingCensorshipWorldModela) )
        __debugbreak();
    }
    DObjInitModel(v19, tag_shield_back, 0, 0, camoParams, &outDObjModels[*outModelIndex]);
    ++*outModelIndex;
    if ( !useDefaultModel )
    {
      maxModels = truncate_cast<unsigned short,unsigned int>(maxDObjModels);
      BG_AddWeaponAttachmentModels(r_weapon, hand, useDualWielding, useViewModel, 1, 0, outDObjModels, maxModels, outModelIndex, outWeaponIKModels, camoParams);
    }
  }
}

/*
==============
CG_Weapons_BuildStickerSlotList
==============
*/
DObjStickerSlotList *CG_Weapons_BuildStickerSlotList(DObjStickerSlotList *result, const LocalClientNum_t localClientNum, const CharacterModelType *modelTypesToApply, const int modelTypesToApplyCount, const Weapon *weapon)
{
  unsigned __int64 v9; 
  unsigned int i; 
  __int64 v11; 
  DObjStickerSlot *slots; 
  unsigned __int16 v13; 
  unsigned __int16 v14; 
  Material *v15; 
  Material *v16; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19937, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  memset_0(result, 0, sizeof(DObjStickerSlotList));
  v9 = 0i64;
  result->modelTypeCount = modelTypesToApplyCount;
  if ( modelTypesToApplyCount )
  {
    if ( !modelTypesToApply && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19944, ASSERT_TYPE_ASSERT, "(modelTypesToApply)", (const char *)&queryFormat, "modelTypesToApply") )
      __debugbreak();
    for ( i = 0; i < result->modelTypeCount; result->modelTypeToApply[v11] = modelTypesToApply[v11] )
      v11 = i++;
  }
  slots = result->slots;
  do
  {
    v13 = weapon->stickerIndices[v9];
    if ( v13 )
    {
      v14 = cg_defaultWeaponStickerMaterialIndices[v9];
      if ( v14 )
      {
        v15 = CG_Draw_StickerMaterialHandleForIndex(localClientNum, v14);
        v16 = CG_Draw_StickerMaterialHandleForIndex(localClientNum, v13);
        if ( v15 )
        {
          if ( v16 )
          {
            slots->blankMaterial = v15;
            slots->overrideMaterial = v16;
          }
        }
      }
    }
    ++v9;
    ++slots;
  }
  while ( v9 < 4 );
  return result;
}

/*
==============
CG_Weapons_BulletTrace
==============
*/
bool CG_Weapons_BulletTrace(const LocalClientNum_t localClientNum, BulletFireParams *bp, const Weapon *weapon, bool isAlternate, const centity_t *attackerEnt, BulletTraceResults *br, int lastSurfaceType, const centity_t **outHitEnt, bool allowHitSelf)
{
  unsigned __int8 *priorityMap; 
  int IgnoreHitEntityCount; 
  unsigned __int16 EntityHitId; 
  unsigned __int16 v16; 
  centity_t *Entity; 
  float fraction; 
  float v19; 
  float v20; 
  float v21; 
  entityType_s eType; 
  int v23; 
  bool v24; 
  unsigned int v25; 
  bool v26; 
  int *skipEntities; 
  int *skipEntitiesa; 
  __int64 skipEntityCount; 

  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23200, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !attackerEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23201, ASSERT_TYPE_ASSERT, "(attackerEnt)", (const char *)&queryFormat, "attackerEnt") )
    __debugbreak();
  if ( !br && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23202, ASSERT_TYPE_ASSERT, "(br)", (const char *)&queryFormat, "br") )
    __debugbreak();
  if ( (unsigned int)lastSurfaceType >= 0x40 )
  {
    LODWORD(skipEntities) = lastSurfaceType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23203, ASSERT_TYPE_ASSERT, "(unsigned)( lastSurfaceType ) < (unsigned)( 64 )", "lastSurfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", skipEntities, 64) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "CG_Weapons_BulletTrace");
  PhysPerfTrack_BulletClientTraceCountAdd();
  priorityMap = BG_GetWeaponPriorityMap(weapon, isAlternate);
  IgnoreHitEntityCount = BG_GetIgnoreHitEntityCount(bp);
  PhysicsQuery_LegacyMPCGWeaponSimTrace((Physics_WorldId)(3 * localClientNum + 4), &br->trace, &bp->start, &bp->end, &bounds_origin, bp->ignoreHitEntityQueue, IgnoreHitEntityCount, 0, 41969969, 1, priorityMap, All, 1);
  EntityHitId = Trace_GetEntityHitId(&br->trace);
  if ( EntityHitId < 0x800u )
  {
    v16 = EntityHitId;
    if ( (unsigned __int16)(EntityHitId - 2046) > 1u )
    {
      Entity = CG_GetEntity(localClientNum, EntityHitId);
      goto LABEL_16;
    }
  }
  else
  {
    v16 = 2047;
  }
  Entity = NULL;
LABEL_16:
  fraction = br->trace.fraction;
  v19 = (float)((float)(bp->end.v[0] - bp->start.v[0]) * br->trace.fraction) + bp->start.v[0];
  br->hitPos.v[0] = v19;
  v20 = (float)((float)(bp->end.v[1] - bp->start.v[1]) * fraction) + bp->start.v[1];
  br->hitPos.v[1] = v20;
  v21 = (float)((float)(bp->end.v[2] - bp->start.v[2]) * fraction) + bp->start.v[2];
  br->hitPos.v[2] = v21;
  bp->travelDistance = fsqrt((float)((float)((float)(v20 - bp->start.v[1]) * (float)(v20 - bp->start.v[1])) + (float)((float)(v19 - bp->start.v[0]) * (float)(v19 - bp->start.v[0]))) + (float)((float)(v21 - bp->start.v[2]) * (float)(v21 - bp->start.v[2]))) + bp->travelDistance;
  if ( !Entity )
    goto LABEL_32;
  if ( br->trace.partGroup == 19 )
  {
    br->trace.surfaceFlags = 15204352;
  }
  else
  {
    if ( BG_IsCharacterEntity(&Entity->nextState) )
      goto LABEL_46;
    if ( Entity == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1983, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    eType = Entity->nextState.eType;
    if ( (unsigned __int16)eType <= ET_ACTOR_CORPSE )
    {
      v23 = 2359300;
      if ( _bittest(&v23, eType) )
      {
LABEL_46:
        if ( !br->trace.surfaceFlags )
          br->trace.surfaceFlags = Entity->nextState.surfType << 19;
      }
    }
  }
  if ( !allowHitSelf && v16 == attackerEnt->nextState.number )
    v24 = 1;
  else
LABEL_32:
    v24 = 0;
  br->ignoreHitEnt = v24;
  if ( outHitEnt )
    *outHitEnt = Entity;
  v25 = (br->trace.surfaceFlags >> 19) & 0x3F;
  v26 = (br->trace.surfaceFlags & 0x100) == 0;
  br->depthSurfaceType = v25;
  if ( v26 )
  {
    if ( !v25 )
    {
      if ( !lastSurfaceType )
        goto LABEL_43;
      br->depthSurfaceType = lastSurfaceType;
      v25 = lastSurfaceType;
    }
    if ( v25 >= 0x40 )
    {
      LODWORD(skipEntityCount) = 64;
      LODWORD(skipEntitiesa) = v25;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23265, ASSERT_TYPE_SANITY, "(unsigned)( br->depthSurfaceType ) < (unsigned)( 64 )", "br->depthSurfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", skipEntitiesa, skipEntityCount) )
        __debugbreak();
    }
  }
  else
  {
    br->depthSurfaceType = 0;
  }
LABEL_43:
  Sys_ProfEndNamedEvent();
  return br->trace.hitType != TRACE_HITTYPE_BEGIN;
}

/*
==============
CG_Weapons_CalculateMovement
==============
*/
void CG_Weapons_CalculateMovement(cg_t *cgameGlob, PlayerViewValues *viewValues, const tmat43_t<vec3_t> *viewTransform, vec3_t *outGunOffset, vec3_t *outGunAngles, vec3_t *outWeapOrigin, vec4_t *outWeapOrient)
{
  const dvar_t *v11; 
  bool enabled; 
  const tmat43_t<vec3_t> *p_dst; 
  float v14; 
  float v15; 
  float v16; 
  const dvar_t *v17; 
  int v18; 
  const dvar_t *v19; 
  float fWeaponPosFrac; 
  float v21; 
  float v22; 
  __int64 localClientNum; 
  const Weapon *ViewmodelWeapon; 
  bool v25; 
  float v26; 
  const dvar_t *v27; 
  float value; 
  const dvar_t *v29; 
  float v30; 
  const dvar_t *v31; 
  float v32; 
  const PlayerViewValues *v33; 
  const dvar_t *v34; 
  float v35; 
  const dvar_t *v36; 
  float v37; 
  const dvar_t *v38; 
  float v39; 
  float v40; 
  float v41; 
  CgWeaponMap *Instance; 
  const Weapon *v43; 
  bool v44; 
  unsigned int secureInt32_3_aab; 
  __int64 v46; 
  double WeaponOrOffhandAdsFrac; 
  const dvar_t *v48; 
  float altSwitchFrac; 
  bool v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  __int64 v55; 
  cg_t *LocalClientGlobals; 
  double v57; 
  const CameraDef *Def; 
  float FOVXOffset; 
  vec3_t *outWorldOffset; 
  vec3_t *v61; 
  vec3_t out; 
  vec3_t outAngles; 
  vec3_t offset; 
  vec3_t outLocalAngles; 
  vec3_t outLocalOffset; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> dst; 
  float v69; 
  float v70; 
  float v71; 

  *(_QWORD *)outLocalOffset.v = viewValues;
  v11 = DVARBOOL_cg_enableViewModelMotionPrecisionFix;
  if ( !DVARBOOL_cg_enableViewModelMotionPrecisionFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableViewModelMotionPrecisionFix") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  enabled = v11->current.enabled;
  MatrixCopy33((const tmat33_t<vec3_t> *)viewTransform, &dst);
  v69 = 0.0;
  v70 = 0.0;
  v71 = 0.0;
  p_dst = (const tmat43_t<vec3_t> *)&dst;
  if ( !enabled )
    p_dst = viewTransform;
  if ( enabled )
  {
    v14 = viewTransform->m[3].v[0];
    v15 = viewTransform->m[3].v[1];
    v16 = viewTransform->m[3].v[2];
  }
  else
  {
    v14 = 0.0;
    v15 = 0.0;
    v16 = 0.0;
  }
  MatrixTransformVector43(&viewValues->weapMoveOrigin, p_dst, &out);
  v17 = DCONST_DVARBOOL_cg_viewmodelAnimatedJumps;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedJumps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedJumps") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v17);
  if ( !v17->current.enabled )
  {
    v18 = cgameGlob->time - cgameGlob->landTime;
    v19 = DCONST_DVARMPBOOL_cg_viewmotion_spring_enable;
    if ( !DCONST_DVARMPBOOL_cg_viewmotion_spring_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmotion_spring_enable") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v19);
    if ( v19->current.enabled )
      fWeaponPosFrac = cgameGlob->fWeaponPosFrac;
    else
      fWeaponPosFrac = FLOAT_1_0;
    v21 = (float)(cgameGlob->landChange * 0.25) * fWeaponPosFrac;
    if ( v18 < 150 )
    {
      v22 = (float)((float)v18 * v21) * 0.0066666668;
LABEL_23:
      out.v[2] = v22 + out.v[2];
      goto LABEL_24;
    }
    if ( v18 < 450 )
    {
      v22 = (float)((float)(450 - v18) * v21) * 0.0033333334;
      goto LABEL_23;
    }
  }
LABEL_24:
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13660, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  localClientNum = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[localClientNum], &cgameGlob->predictedPlayerState);
  v25 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
  if ( !BG_IsAimDownSight(ViewmodelWeapon, v25) || (v26 = cgameGlob->predictedPlayerState.weapCommon.fWeaponPosFrac, v26 == 0.0) )
  {
    outGunOffset->v[2] = 0.0;
    *(_QWORD *)outGunOffset->v = 0i64;
  }
  else
  {
    outGunOffset->v[0] = (float)(out.v[0] - p_dst->m[3].v[0]) * v26;
    outGunOffset->v[1] = (float)(out.v[1] - p_dst->m[3].v[1]) * v26;
    outGunOffset->v[2] = (float)(out.v[2] - p_dst->m[3].v[2]) * v26;
  }
  CG_CalculateWeaponMovement_FovCompensation(cgameGlob, &out);
  v27 = DVARFLT_cg_gun_x;
  if ( !DVARFLT_cg_gun_x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_x") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v27);
  value = v27->current.value;
  out.v[0] = (float)(value * p_dst->m[0].v[0]) + out.v[0];
  out.v[1] = (float)(value * p_dst->m[0].v[1]) + out.v[1];
  out.v[2] = (float)(value * p_dst->m[0].v[2]) + out.v[2];
  v29 = DVARFLT_cg_gun_y;
  if ( !DVARFLT_cg_gun_y && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_y") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v29);
  v30 = v29->current.value;
  out.v[0] = (float)(v30 * p_dst->m[1].v[0]) + out.v[0];
  out.v[1] = (float)(v30 * p_dst->m[1].v[1]) + out.v[1];
  out.v[2] = (float)(v30 * p_dst->m[1].v[2]) + out.v[2];
  v31 = DVARFLT_cg_gun_z;
  if ( !DVARFLT_cg_gun_z && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_z") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v31);
  v32 = v31->current.value;
  out.v[0] = (float)(v32 * p_dst->m[2].v[0]) + out.v[0];
  out.v[1] = (float)(v32 * p_dst->m[2].v[1]) + out.v[1];
  out.v[2] = (float)(v32 * p_dst->m[2].v[2]) + out.v[2];
  v33 = *(const PlayerViewValues **)outLocalOffset.v;
  outAngles = *(vec3_t *)(*(_QWORD *)outLocalOffset.v + 24i64);
  v34 = DVARFLT_cg_gun_pitch;
  if ( !DVARFLT_cg_gun_pitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_pitch") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v34);
  v35 = v34->current.value;
  v36 = DVARFLT_cg_gun_yaw;
  if ( !DVARFLT_cg_gun_yaw && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_yaw") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v36);
  v37 = v36->current.value;
  v38 = DVARFLT_cg_gun_roll;
  if ( !DVARFLT_cg_gun_roll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_roll") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v38);
  v39 = v35 + outAngles.v[0];
  outAngles.v[0] = v39;
  v40 = v37 + outAngles.v[1];
  outAngles.v[1] = v40;
  v41 = outAngles.v[2] + v38->current.value;
  outAngles.v[2] = v41;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_LADDER_AIM) )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    v43 = BG_GetViewmodelWeapon(Instance, &cgameGlob->predictedPlayerState);
    v44 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
    if ( !BG_IsAimDownSight(v43, v44) )
    {
      if ( !cgameGlob->kickAngles.initialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\anticheat\\security_obfuscation_integer.h", 221, ASSERT_TYPE_ASSERT, "(initialized)", (const char *)&queryFormat, "initialized") )
        __debugbreak();
      secureInt32_3_aab = cgameGlob->kickAngles.secureInt32_3_aab;
      LODWORD(offset.v[0]) = cgameGlob->kickAngles.data[0] ^ ((((_DWORD)cgameGlob + 302524) ^ secureInt32_3_aab) * ((((_DWORD)cgameGlob + 302524) ^ secureInt32_3_aab) + 2));
      LODWORD(offset.v[1]) = cgameGlob->kickAngles.data[1] ^ ((((_DWORD)cgameGlob + 302528) ^ secureInt32_3_aab) * ((((_DWORD)cgameGlob + 302528) ^ secureInt32_3_aab) + 2));
      LODWORD(offset.v[2]) = ((((_DWORD)cgameGlob + 302532) ^ secureInt32_3_aab) * ((((_DWORD)cgameGlob + 302532) ^ secureInt32_3_aab) + 2)) ^ cgameGlob->kickAngles.data[2];
      outAngles.v[0] = v39 - offset.v[0];
      outAngles.v[1] = v40 - offset.v[1];
      outAngles.v[2] = v41 - offset.v[2];
      memset(&offset, 0, sizeof(offset));
      v33 = *(const PlayerViewValues **)outLocalOffset.v;
    }
  }
  CG_CalculateWeaponMovement_ProceduralAdsMovement(cgameGlob, p_dst, &out, &outAngles);
  v46 = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[v46] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  outLocalAngles = v33->weapMoveAnglesCategorized[14];
  WeaponOrOffhandAdsFrac = BG_GetWeaponOrOffhandAdsFrac(CgWeaponMap::ms_instance[v46], &cgameGlob->predictedPlayerState);
  CG_ViewMotion_GetSpringOffset(&cgameGlob->predictedPlayerState, *(const float *)&WeaponOrOffhandAdsFrac, &cgameGlob->viewmodelSpring, &cgameGlob->predictedPlayerState.viewangles, &outLocalOffset, &offset);
  out.v[0] = out.v[0] + offset.v[0];
  out.v[1] = out.v[1] + offset.v[1];
  out.v[2] = out.v[2] + offset.v[2];
  CG_ViewMotion_LocalOffsetToLocalAngles(&cgameGlob->predictedPlayerState, &cgameGlob->viewmodelSpring, &outLocalOffset, &outLocalAngles);
  outAngles.v[0] = outAngles.v[0] + outLocalAngles.v[0];
  outAngles.v[1] = outAngles.v[1] + outLocalAngles.v[1];
  outAngles.v[2] = outAngles.v[2] + outLocalAngles.v[2];
  CG_CalculateWeaponMovement_CalcAngles(cgameGlob, v33, &out, &outAngles, &outLocalAngles, *(const float *)&dword_147FA82D0, outGunAngles, outWeapOrigin, outWeapOrient);
  v48 = DVARBOOL_cg_enableAdsAlignOffset;
  if ( !DVARBOOL_cg_enableAdsAlignOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableAdsAlignOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v48);
  if ( v48->current.enabled )
  {
    altSwitchFrac = cgameGlob->altSwitchFrac;
    if ( altSwitchFrac <= 0.0 )
    {
      v50 = altSwitchFrac < 1.0;
    }
    else
    {
      v50 = altSwitchFrac < 1.0;
      if ( altSwitchFrac < 1.0 )
      {
        CG_CalculateWeaponMovement_GetAdsOffset(cgameGlob, outWeapOrient, 0, &offset);
        CG_CalculateWeaponMovement_GetAdsOffset(cgameGlob, outWeapOrient, 1, &outAngles);
        v51 = cgameGlob->altSwitchFrac;
        v52 = (float)((float)(outAngles.v[0] - offset.v[0]) * v51) + offset.v[0];
        v53 = (float)((float)(outAngles.v[1] - offset.v[1]) * v51) + offset.v[1];
        v54 = (float)((float)(outAngles.v[2] - offset.v[2]) * v51) + offset.v[2];
LABEL_70:
        outWeapOrigin->v[0] = v52 + outWeapOrigin->v[0];
        outWeapOrigin->v[1] = v53 + outWeapOrigin->v[1];
        outWeapOrigin->v[2] = v54 + outWeapOrigin->v[2];
        goto LABEL_71;
      }
    }
    CG_CalculateWeaponMovement_GetAdsOffset(cgameGlob, outWeapOrient, !v50, &offset);
    v54 = offset.v[2];
    v53 = offset.v[1];
    v52 = offset.v[0];
    goto LABEL_70;
  }
LABEL_71:
  v55 = cgameGlob->localClientNum;
  if ( (unsigned int)v55 >= 2 )
  {
    LODWORD(v61) = 2;
    LODWORD(outWorldOffset) = cgameGlob->localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13985, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", outWorldOffset, v61) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v55);
  if ( !CgWeaponMap::ms_instance[v55] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v57 = BG_GetWeaponOrOffhandAdsFrac(CgWeaponMap::ms_instance[v55], &LocalClientGlobals->predictedPlayerState);
  if ( *(float *)&v57 > 0.0 )
  {
    Def = CG_Camera_Active_TryGetDef((LocalClientNum_t)v55);
    if ( !Def || Def->profile || !Def->firstPerson.disableFOVWeaponOffset )
    {
      FOVXOffset = CG_CalculateWeaponMovement_GetFOVXOffset(LocalClientGlobals);
      QuatToAxis(outWeapOrient, &axis);
      outWeapOrigin->v[0] = (float)(FOVXOffset * axis.m[0].v[0]) + outWeapOrigin->v[0];
      outWeapOrigin->v[1] = (float)(FOVXOffset * axis.m[0].v[1]) + outWeapOrigin->v[1];
      outWeapOrigin->v[2] = (float)(FOVXOffset * axis.m[0].v[2]) + outWeapOrigin->v[2];
    }
  }
  cgameGlob->viewModelPlacementOffset = *outWeapOrigin;
  outWeapOrigin->v[0] = v14 + outWeapOrigin->v[0];
  outWeapOrigin->v[1] = v15 + outWeapOrigin->v[1];
  outWeapOrigin->v[2] = v16 + outWeapOrigin->v[2];
}

/*
==============
CG_Weapons_CheckForGestureForcedBlendOuts
==============
*/
void CG_Weapons_CheckForGestureForcedBlendOuts(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex handIndex, const Weapon *r_weapon)
{
  GestureWeaponAnimBlendOutInfo *v6; 
  GestureWeaponAnimBlendOutInfo *outBlendOutInfo; 

  if ( handIndex == WEAPON_HAND_DEFAULT )
  {
    outBlendOutInfo = NULL;
    if ( CG_Gesture_ShouldBlendOutOfAnim(localClientNum, ps, WEAPON_HAND_DEFAULT, (const GestureWeaponAnimBlendOutInfo **)&outBlendOutInfo) )
    {
      v6 = outBlendOutInfo;
      if ( !outBlendOutInfo )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8681, ASSERT_TYPE_ASSERT, "(blendOutInfo)", (const char *)&queryFormat, "blendOutInfo") )
          __debugbreak();
        v6 = outBlendOutInfo;
      }
      CG_Weapons_StartWeaponAnim(localClientNum, r_weapon, WEAPON_HAND_DEFAULT, (const WeaponAnimNumber)v6->animToBlendIn, (const weapAnimFiles_t)v6->animIndexToBlendIn, (const WeaponAnimNumber)v6->animToBlendOut, (const weapAnimFiles_t)v6->animIndexToBlendOut, v6->transitionTime, 0);
    }
  }
}

/*
==============
CG_Weapons_ClearAutoComplete
==============
*/
void CG_Weapons_ClearAutoComplete(void)
{
  Cmd_ClearAutoComplete("give");
  Cmd_ClearAutoComplete("take");
}

/*
==============
CG_Weapons_CreatePhysicsForWeapon
==============
*/
void CG_Weapons_CreatePhysicsForWeapon(LocalClientNum_t localClientNum, const DObj *obj, const Weapon *weapon)
{
  unsigned __int16 v5; 
  __int64 v6; 
  CG_PhysicsObject *v7; 
  __int32 v8; 
  __int32 v9; 
  __int64 v10; 
  unsigned int v11; 
  const XModel *InstanceDetailModel; 
  int v13; 
  const XModel *model; 
  centity_t *Entity; 
  CG_PhysicsObject *v16; 
  unsigned __int16 v17; 
  vec3_t outOrigin; 
  __int64 v19; 
  vec3_t angles; 
  vec4_t quat; 

  v19 = -2i64;
  if ( weapon->weaponIdx )
  {
    if ( BG_IsRiotShield(weapon, 0) )
    {
      v5 = 0;
      if ( obj->numModels )
      {
        while ( 1 )
        {
          v6 = v5;
          if ( BG_Weapons_IsRiotShieldModel(obj->models[v5]) )
            break;
          if ( ++v5 >= obj->numModels )
            return;
        }
        v7 = CG_PhysicsObject_Get((unsigned int)obj->entnum - 1, localClientNum);
        v8 = 3 * localClientNum + 4;
        v9 = 3 * localClientNum + 2;
        v10 = 3 * localClientNum;
        v11 = v7->physicsInstances[v10 + 4];
        if ( v11 != -1 )
        {
          InstanceDetailModel = Physics_GetInstanceDetailModel((Physics_WorldId)v8, v11);
          if ( InstanceDetailModel )
          {
            if ( BG_Weapons_IsRiotShieldModel(InstanceDetailModel) )
            {
              CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
              CG_PhysicsObject_DestroyDetailBoneMapping((Physics_WorldId)v8, v7);
              Physics_DestroyInstance((Physics_WorldId)v8, v7->physicsInstances[v10 + 4], 0);
              v7->physicsInstances[v10 + 4] = -1;
              CG_PhysicsObject_DestroyDetailBoneMapping((Physics_WorldId)v9, v7);
              Physics_DestroyInstance((Physics_WorldId)v9, v7->physicsInstances[v10 + 2], 0);
              v7->physicsInstances[v10 + 2] = -1;
              CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
            }
          }
        }
        v13 = obj->entnum - 1;
        model = obj->models[v6];
        CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
        Entity = CG_GetEntity(localClientNum, v13);
        v16 = CG_PhysicsObject_Get(v13, localClientNum);
        CG_GetPoseOrigin(&Entity->pose, &outOrigin);
        angles = Entity->pose.angles;
        AnglesToQuat(&angles, &quat);
        LOBYTE(Entity) = !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->nextState.lerp.eFlags, ACTIVE, 1u);
        v17 = truncate_cast<unsigned short,int>(v13);
        LODWORD(Entity) = Physics_MakeRef(Physics_RefSystem_CEntities, Physics_RelationshipSystem_None, (unsigned __int8)Entity, v17);
        CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)v9, v16, (const int)Entity, obj, model, &outOrigin, &quat);
        CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)v8, v16, (const int)Entity, obj, model, &outOrigin, &quat);
        CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
        memset(&outOrigin, 0, sizeof(outOrigin));
      }
    }
  }
}

/*
==============
CG_Weapons_CreateRiotShieldModel
==============
*/
void CG_Weapons_CreateRiotShieldModel(const Physics_WorldId worldId, CG_PhysicsObject *physicsObj, const int physicsRef, const DObj *obj, const XModel *model, const vec3_t *position, const vec4_t *orientation)
{
  __int64 v7; 

  v7 = worldId;
  if ( physicsObj->physicsInstances[worldId] != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25934, ASSERT_TYPE_ASSERT, "(physicsObj->physicsInstances[worldId] == 0xFFFFFFFF)", (const char *)&queryFormat, "physicsObj->physicsInstances[worldId] == PHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  physicsObj->physicsInstances[v7] = Physics_InstantiateDetailModel((Physics_WorldId)v7, model, physicsRef, position, orientation, 0, 1, 0, 0);
  CG_PhysicsObject_CreateDetailBoneMapping((Physics_WorldId)v7, physicsObj, obj, model->physicsAsset);
}

/*
==============
CG_Weapons_CreateRiotShieldPhysics
==============
*/
void CG_Weapons_CreateRiotShieldPhysics(LocalClientNum_t localClientNum, const DObj *obj, const XModel *model, int entityNum)
{
  centity_t *Entity; 
  CG_PhysicsObject *v9; 
  unsigned __int16 v10; 
  int Ref; 
  vec3_t outOrigin; 
  __int64 v13; 
  vec3_t angles; 
  vec4_t quat; 

  v13 = -2i64;
  CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
  Entity = CG_GetEntity(localClientNum, entityNum);
  v9 = CG_PhysicsObject_Get(entityNum, localClientNum);
  CG_GetPoseOrigin(&Entity->pose, &outOrigin);
  angles = Entity->pose.angles;
  AnglesToQuat(&angles, &quat);
  LOBYTE(Entity) = !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->nextState.lerp.eFlags, ACTIVE, 1u);
  v10 = truncate_cast<unsigned short,int>(entityNum);
  Ref = Physics_MakeRef(Physics_RefSystem_CEntities, Physics_RelationshipSystem_None, (unsigned __int8)Entity, v10);
  CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)(3 * localClientNum + 2), v9, Ref, obj, model, &outOrigin, &quat);
  CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)(3 * localClientNum + 4), v9, Ref, obj, model, &outOrigin, &quat);
  CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_Weapons_CreateWeaponPhysics
==============
*/
void CG_Weapons_CreateWeaponPhysics(LocalClientNum_t localClientNum, int clientNum)
{
  CgStatic *LocalClientStatics; 
  characterInfo_t *CharacterInfo; 
  const DObj *ClientDObj; 
  const DObj *v7; 

  LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
  if ( LocalClientStatics->HasCharacterInfo(LocalClientStatics, clientNum) )
  {
    CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, clientNum);
    if ( CharacterInfo->createWeaponPhysics )
    {
      ClientDObj = Com_GetClientDObj(clientNum, localClientNum);
      v7 = ClientDObj;
      if ( ClientDObj )
      {
        CG_Weapons_CreatePhysicsForWeapon(localClientNum, ClientDObj, &CharacterInfo->dobjHeldWeapon);
        CG_Weapons_CreatePhysicsForWeapon(localClientNum, v7, &CharacterInfo->dobjStowedWeapon);
      }
      CharacterInfo->createWeaponPhysics = 0;
    }
  }
}

/*
==============
CG_Weapons_CurrentWeaponCanAltToggle
==============
*/
bool CG_Weapons_CurrentWeaponCanAltToggle(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  bool v3; 
  const BgWeaponMap **v4; 
  const Weapon *CurrentWeaponForPlayer; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = CgWeaponMap::ms_instance[v1] == NULL;
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v1];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(*v4, &LocalClientGlobals->predictedPlayerState);
  return !BG_IsThrowingAxe(CurrentWeaponForPlayer) && BG_HasUnderbarrelAmmo(CurrentWeaponForPlayer) && !BG_UseLeftTriggerAltFireMode(CurrentWeaponForPlayer);
}

/*
==============
CG_Weapons_CurrentWeaponCanHoldBreath
==============
*/
bool CG_Weapons_CurrentWeaponCanHoldBreath(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  bool v3; 
  const BgWeaponMap **v4; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = CgWeaponMap::ms_instance[v1] == NULL;
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v1];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  return BG_HasHoldBreathAbility(*v4, &LocalClientGlobals->predictedPlayerState) != 0;
}

/*
==============
CG_Weapons_CurrentWeaponCanHybridToggle
==============
*/
bool CG_Weapons_CurrentWeaponCanHybridToggle(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  bool v3; 
  const BgWeaponMap **v4; 
  const playerState_s *p_predictedPlayerState; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = CgWeaponMap::ms_instance[v1] == NULL;
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v1];
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(*v4, p_predictedPlayerState);
  v7 = BG_UsingAlternate(p_predictedPlayerState);
  return BG_CanHybridToggle(p_predictedPlayerState, CurrentWeaponForPlayer, v7);
}

/*
==============
CG_Weapons_DestroyRiotShieldPhysics
==============
*/
void CG_Weapons_DestroyRiotShieldPhysics(LocalClientNum_t localClientNum, int entityNum)
{
  CG_PhysicsObject *v3; 
  __int32 v4; 
  CG_PhysicsObject *v5; 
  __int64 v6; 
  __int32 v7; 
  Physics_WorldId v8; 
  unsigned int v9; 
  const XModel *InstanceDetailModel; 

  v3 = CG_PhysicsObject_Get(entityNum, localClientNum);
  v4 = 3 * localClientNum;
  v5 = v3;
  v6 = 3 * localClientNum;
  v7 = 3 * localClientNum + 4;
  v8 = v4 + 2;
  v9 = v3->physicsInstances[v4 + 4];
  if ( v9 != -1 )
  {
    InstanceDetailModel = Physics_GetInstanceDetailModel((Physics_WorldId)v7, v9);
    if ( InstanceDetailModel )
    {
      if ( BG_Weapons_IsRiotShieldModel(InstanceDetailModel) )
      {
        CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
        CG_PhysicsObject_DestroyDetailBoneMapping((Physics_WorldId)v7, v5);
        Physics_DestroyInstance((Physics_WorldId)v7, v5->physicsInstances[v6 + 4], 0);
        v5->physicsInstances[v6 + 4] = -1;
        CG_PhysicsObject_DestroyDetailBoneMapping(v8, v5);
        Physics_DestroyInstance(v8, v5->physicsInstances[v6 + 2], 0);
        v5->physicsInstances[v6 + 2] = -1;
        CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
      }
    }
  }
}

/*
==============
CG_Weapons_DevWeaponReport
==============
*/
void CG_Weapons_DevWeaponReport(void)
{
  unsigned int numLootVariants; 
  unsigned int numAltReticles; 
  unsigned int numReticles; 
  unsigned int v3; 
  cg_t *LocalClientGlobals; 
  Material **v5; 
  int *p_crosshairClientNum; 
  int *v7; 
  unsigned int v8; 
  const char **v9; 
  __int64 v10; 
  const WeaponCompleteDef *PointerToWeaponCompleteDefConst; 
  AttachmentList *attachments; 
  __int64 v13; 
  __int64 v14; 
  const char **v15; 
  unsigned int attachmentCount; 
  unsigned int v17; 
  unsigned int numModelVariations; 
  __int64 v19; 
  __int64 v20; 
  WeaponAttachment *v21; 
  unsigned int v22; 
  unsigned int CamoCount; 
  const Camo *Camo; 
  const char *v25; 
  unsigned int v26; 
  unsigned int v27; 
  unsigned int v28; 
  unsigned int v29; 
  unsigned int v30; 
  __int64 v31; 
  unsigned int v32; 
  unsigned int v33; 
  unsigned int v34; 
  unsigned int v35; 
  unsigned int v36; 
  const char **v37; 
  __int64 *v38; 
  __int64 v39; 
  unsigned int v40; 
  __int64 v41; 
  int *v42; 
  __int64 v43; 
  unsigned int v44; 
  char *fmt; 
  unsigned int v46; 
  unsigned int v47; 
  unsigned int NumWeapons; 
  unsigned int v49; 
  const char **v50; 
  __int64 v51; 
  __int64 v52[8]; 
  int v53[32]; 

  memset(v52, 0, 56);
  memset_0(v53, 0, 0x74ui64);
  numLootVariants = 0;
  numAltReticles = 0;
  numReticles = 0;
  Com_Printf(16, "(-- begin weapon report --)\n");
  if ( BG_WeaponSetup_Initialized() )
  {
    NumWeapons = BG_GetNumWeapons();
    v3 = NumWeapons;
    LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    v5 = &LocalClientGlobals->serverStickerMaterialCache[1];
    p_crosshairClientNum = &LocalClientGlobals->crosshairClientNum;
    v7 = (int *)v5;
    if ( v5 != (Material **)p_crosshairClientNum )
    {
      do
      {
        if ( !*(_QWORD *)v7 )
          break;
        v7 += 2;
      }
      while ( v7 != p_crosshairClientNum );
    }
    v49 = truncate_cast<unsigned int,__int64>(((char *)v7 - (char *)v5) >> 3);
    Com_Printf(16, "Weapons:\n");
    v8 = 0;
    v9 = ATT_SLOT_NAMES;
    v46 = 0;
    v10 = 14i64;
    if ( NumWeapons )
    {
      do
      {
        PointerToWeaponCompleteDefConst = BG_GetPointerToWeaponCompleteDefConst(v8);
        if ( !PointerToWeaponCompleteDefConst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26157, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
          __debugbreak();
        Com_Printf(16, "* '%s'\n", PointerToWeaponCompleteDefConst->szInternalName);
        if ( PointerToWeaponCompleteDefConst->numLootVariants > numLootVariants )
          numLootVariants = PointerToWeaponCompleteDefConst->numLootVariants;
        v47 = numLootVariants;
        Com_Printf(16, "  %u loot variants\n");
        attachments = PointerToWeaponCompleteDefConst->attachments;
        v50 = ATT_SLOT_NAMES;
        v13 = 14i64;
        v14 = 0i64;
        v51 = 14i64;
        v15 = ATT_SLOT_NAMES;
        do
        {
          Com_Printf(16, "  '%s'\n", *v15);
          attachmentCount = attachments->attachmentCount;
          v17 = *(_DWORD *)((char *)v52 + v14 * 4);
          if ( attachments->attachmentCount > v17 )
            v17 = attachments->attachmentCount;
          *(_DWORD *)((char *)v52 + v14 * 4) = v17;
          if ( attachmentCount )
          {
            numModelVariations = v53[v14];
            v19 = 0i64;
            v20 = attachmentCount;
            do
            {
              v21 = attachments->attachments[v19];
              Com_Printf(16, "    '%s'\n", v21->szInternalName);
              if ( v21->numModelVariations > numModelVariations )
                numModelVariations = v21->numModelVariations;
              Com_Printf(16, "      %u variants\n");
              if ( v21->numReticles > numReticles )
                numReticles = v21->numReticles;
              Com_Printf(16, "      %u alt reticles\n");
              if ( v21->numAltReticles > numAltReticles )
                numAltReticles = v21->numAltReticles;
              Com_Printf(16, "      %u alt reticles\n");
              ++v19;
              --v20;
            }
            while ( v20 );
            v15 = v50;
            v13 = v51;
            v53[v14] = numModelVariations;
          }
          ++v15;
          ++attachments;
          ++v14;
          v50 = v15;
          v51 = --v13;
        }
        while ( v13 );
        v3 = NumWeapons;
        numLootVariants = v47;
        v8 = v46 + 1;
        v46 = v8;
      }
      while ( v8 < NumWeapons );
      v9 = ATT_SLOT_NAMES;
      v10 = 14i64;
    }
    Com_Printf(16, "\n");
    Com_Printf(16, "Camos:\n");
    v22 = 0;
    CamoCount = BG_Camo_GetCamoCount();
    if ( CamoCount )
    {
      do
      {
        Camo = BG_Camo_GetCamo(v22);
        v25 = SL_ConvertToString(Camo->internalName);
        Com_Printf(16, "  '%s'\n", v25);
        ++v22;
      }
      while ( v22 < CamoCount );
    }
    Com_Printf(16, "\n");
    if ( v3 )
      v26 = 32 - __lzcnt(v3 - 1);
    else
      v26 = 0;
    Com_Printf(16, "# Weapons: %u (bits needed: %u)\n", NumWeapons, v26);
    if ( CamoCount )
      v27 = 32 - __lzcnt(CamoCount - 1);
    else
      v27 = 0;
    Com_Printf(16, "# Camos: %u (bits needed: %u)\n", CamoCount, v27);
    v28 = v27 + v26;
    if ( v49 )
      v29 = 32 - __lzcnt(v49 - 1);
    else
      v29 = 0;
    Com_Printf(16, "# Stickers: %u (bits needed: %u x 4)\n", v49, v29);
    v30 = v28 + 4 * v29;
    if ( numLootVariants )
      v31 = 32 - __lzcnt(numLootVariants - 1);
    else
      v31 = 0i64;
    Com_Printf(16, "Max Loot Variants: %u (bits needed: %u)\n", numLootVariants, v31);
    v32 = numLootVariants + v30;
    if ( numReticles )
      v33 = 32 - __lzcnt(numReticles - 1);
    else
      v33 = 0;
    Com_Printf(16, "Max Reticles: %u (bits needed: %u)\n", numReticles, v33);
    v34 = v33 + v32;
    if ( numAltReticles )
      v35 = 32 - __lzcnt(numAltReticles - 1);
    else
      v35 = 0;
    Com_Printf(16, "Max Alt Reticles: %u (bits needed: %u)\n", numAltReticles, v35);
    v36 = v35 + v34;
    Com_Printf(16, "Max Attachments:\n");
    v37 = ATT_SLOT_NAMES;
    v38 = v52;
    do
    {
      v39 = *(unsigned int *)v38;
      if ( (_DWORD)v39 )
        v40 = 32 - __lzcnt(v39 - 1);
      else
        v40 = 0;
      LODWORD(fmt) = v40;
      v36 += v40;
      Com_Printf(16, "  %s: %u (bits needed: %u)\n", *v37, v39, fmt);
      v38 = (__int64 *)((char *)v38 + 4);
      ++v37;
      --v10;
    }
    while ( v10 );
    Com_Printf(16, "Max Variations:\n");
    v41 = 29i64;
    v42 = v53;
    do
    {
      v43 = (unsigned int)*v42;
      if ( (_DWORD)v43 )
        v44 = 32 - __lzcnt(v43 - 1);
      else
        v44 = 0;
      LODWORD(fmt) = v44;
      v36 += v44;
      Com_Printf(16, "  %s: %u (bits needed: %u)\n", *v9, v43, fmt);
      ++v42;
      ++v9;
      --v41;
    }
    while ( v41 );
    Com_Printf(16, "\n");
    Com_Printf(16, "Total bits needed for Weapon representation: %u\n", v36);
  }
  else
  {
    Com_PrintError(16, "ERROR: BG_WeaponSetup not initialized.\n");
  }
  Com_Printf(16, "(-- end weapon report --)\n");
}

/*
==============
CG_Weapons_EntityHasShield
==============
*/
bool CG_Weapons_EntityHasShield(const LocalClientNum_t localClientNum, const centity_t *const cent)
{
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  const SuitDef *SuitDef; 
  DObj *ClientDObj; 
  unsigned int characterCollBoundsType; 
  __int64 v10; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26009, ASSERT_TYPE_ASSERT, "(cent != nullptr)", (const char *)&queryFormat, "cent != nullptr") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 )
    return 0;
  if ( BG_IsPlayerOrAgentEntity(&cent->nextState) )
  {
    LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
    CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, cent->nextState.clientNum);
    if ( CharacterInfo->offhandShieldDeployed )
      return 1;
    SuitDef = BG_GetSuitDef(CharacterInfo->suitIndex);
    if ( SuitDef )
    {
      if ( SuitDef->suitAnimType == ANIM_SUIT_C8 )
        return 1;
    }
  }
  if ( cent == (const centity_t *const)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1928, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( ((cent->nextState.eType - 19) & 0xFFFD) != 0 )
    return 0;
  ClientDObj = Com_GetClientDObj(cent->nextState.number, localClientNum);
  if ( !ClientDObj )
    return 0;
  characterCollBoundsType = (*ClientDObj->models)->characterCollBoundsType;
  if ( characterCollBoundsType >= 0xA )
  {
    LODWORD(v10) = (*ClientDObj->models)->characterCollBoundsType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26038, ASSERT_TYPE_ASSERT, "(unsigned)( collBoundsType ) < (unsigned)( XModelCharCollBoundsType::CharCollBoundsType_Num )", "collBoundsType doesn't index XModelCharCollBoundsType::CharCollBoundsType_Num\n\t%i not in [0, %i)", v10, 10) )
      __debugbreak();
  }
  return characterCollBoundsType == 3;
}

/*
==============
CG_Weapons_FastADSTransitionOverride
==============
*/
void CG_Weapons_FastADSTransitionOverride(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex, const Weapon *weapon, const bool isAlternate, const bool isAiming, const bool isInterruptible, int *outWeapAnim, int *outWeapAnimToggle)
{
  __int64 v9; 
  cg_t *LocalClientGlobals; 
  __int64 v14; 
  CgWeaponMap *v15; 
  double v16; 
  bool v17; 
  __int64 v18; 
  char v19; 
  __int64 v20; 
  int weaponState; 
  bool v22; 
  bool v23; 
  bool v24; 
  bool v25; 

  v9 = handIndex;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8382, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !outWeapAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8383, ASSERT_TYPE_ASSERT, "(outWeapAnim)", (const char *)&queryFormat, "outWeapAnim") )
    __debugbreak();
  if ( !outWeapAnimToggle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8384, ASSERT_TYPE_ASSERT, "(outWeapAnimToggle)", (const char *)&queryFormat, "outWeapAnimToggle") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v14 = LocalClientGlobals->localClientNum;
  if ( !CgWeaponMap::ms_instance[v14] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v15 = CgWeaponMap::ms_instance[v14];
  v16 = BG_WeaponADSFractionAffectedByReload(v15, ps);
  v17 = *(float *)&v16 > 0.0 && *outWeapAnim != 55;
  if ( BG_ADSReloadEnabled(v15, ps, weapon, isAlternate) || (v18 = v9, (unsigned int)(ps->weapState[v9].weaponState - 18) > 3) || CG_Weapons_IsReloadActive(localClientNum, ps, (PlayerHandIndex)v9, weapon, isAlternate, isInterruptible) )
  {
    v19 = 0;
    v18 = v9;
  }
  else
  {
    v19 = 1;
  }
  v20 = v18;
  weaponState = ps->weapState[v18].weaponState;
  v22 = (unsigned int)(weaponState - 1) <= 4 && isInterruptible;
  v23 = (unsigned int)(weaponState - 22) <= 2 && isInterruptible;
  v24 = v19 || v22 || weaponState == 36 || v23;
  v25 = weaponState == 16 && BG_IsADSFireOnly(weapon, isAlternate) && ps->weapState[v20].weaponDelay > 0;
  if ( isAiming && v17 )
  {
    if ( !v24 )
      goto LABEL_48;
    if ( !v25 )
    {
      *outWeapAnim = 1;
      *outWeapAnimToggle = 1;
      LocalClientGlobals->fastADSTransActive = 1;
      return;
    }
  }
  if ( v24 && LocalClientGlobals->fastADSTransActive )
    goto LABEL_50;
LABEL_48:
  if ( LocalClientGlobals->fastADSTransActive && v25 )
  {
LABEL_50:
    *outWeapAnim = 1;
    *outWeapAnimToggle = 1;
    return;
  }
  if ( !v24 )
    LocalClientGlobals->fastADSTransActive = 0;
}

/*
==============
CG_Weapons_FreeAnimTreeHand
==============
*/
void CG_Weapons_FreeAnimTreeHand(const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  __int64 v5; 
  XAnimTree *v6; 
  __int64 v7; 
  __int64 v8; 

  v2 = hand;
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10203, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hand, 2) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v2 >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v7) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  v5 = (__int64)&LocalClientGlobals->m_weaponHand[v2];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10207, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  v6 = *(XAnimTree **)(v5 + 8);
  if ( v6 )
  {
    Com_XAnimFreeSmallTree(v6);
    *(_QWORD *)(v5 + 8) = 0i64;
  }
  if ( *(_QWORD *)v5 )
    DObjSetTree(*(DObj **)v5, NULL);
}

/*
==============
CG_Weapons_GetAnxietyWeight
==============
*/
float CG_Weapons_GetAnxietyWeight(const cg_t *const cgameGlob, const playerState_s *const ps, const XAnimTree *animTree, const float goalWeight)
{
  int m_skydiveAutodeployOffset; 
  float v8; 
  float v9; 
  __int128 v10; 
  float v11; 
  double v16; 
  double v17; 

  if ( !cgameGlob->m_skydiveAutodeployOffsetIsValid || (m_skydiveAutodeployOffset = cgameGlob->m_skydiveAutodeployOffset, v8 = ps->origin.v[2], v10 = 0i64, *(float *)&v10 = (float)m_skydiveAutodeployOffset, v9 = *(float *)&v10, v8 < *(float *)&v10) )
  {
    v16 = XAnimGetGoalWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, 0xCDu);
    return *(float *)&v16;
  }
  if ( v8 > 0.0 )
    goto LABEL_7;
  if ( m_skydiveAutodeployOffset < 0 )
  {
    v11 = (float)(0.2 / *(float *)&v10) * v8;
    goto LABEL_13;
  }
  if ( v8 >= 0.0 )
  {
LABEL_7:
    if ( m_skydiveAutodeployOffset <= 0 )
    {
      *(float *)&v10 = *(float *)&v10 * -6.0;
      _XMM7 = v10;
      if ( (float)(v9 * -6.0) < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6010, ASSERT_TYPE_ASSERT, "(shift >= 0)", (const char *)&queryFormat, "shift >= 0") )
        __debugbreak();
      *(float *)&v10 = *(float *)&v10 + ps->origin.v[2];
      _XMM0 = v10;
      __asm
      {
        vcmpeqss xmm0, xmm0, xmm6
        vblendvps xmm3, xmm7, xmm1, xmm0
      }
      v11 = (float)((float)(_mm_cvtepi32_ps((__m128i)(unsigned int)cgameGlob->m_skydiveAutodeployOffset).m128_f32[0] + *(float *)&_XMM3) * 5.0) / (float)(*(float *)&_XMM3 + ps->origin.v[2]);
      goto LABEL_13;
    }
  }
  v11 = (float)(*(float *)&v10 * 5.0) / v8;
LABEL_13:
  if ( v11 < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6023, ASSERT_TYPE_ASSERT, "(heightFactor >= 0)", (const char *)&queryFormat, "heightFactor >= 0") )
    __debugbreak();
  if ( v11 >= 0.25 )
  {
    v17 = I_fclamp(v11, 0.30000001, 1.0);
    *(float *)&v17 = powf_0(2.7179999, *(float *)&v17 * 5.0999999);
    v16 = I_fclamp((float)(*(float *)&v17 * 0.085042447) * goalWeight, 0.0, 1.0);
  }
  else
  {
    LODWORD(v16) = 0;
  }
  return *(float *)&v16;
}

/*
==============
CG_Weapons_GetEntityHitId
==============
*/
unsigned __int16 CG_Weapons_GetEntityHitId(const trace_t *trace)
{
  unsigned __int16 result; 

  result = Trace_GetEntityHitId(trace);
  if ( result >= 0x800u )
    return 2047;
  return result;
}

/*
==============
CG_Weapons_GetLootVariantDisplayName
==============
*/
const char *CG_Weapons_GetLootVariantDisplayName(const Weapon *weapon, unsigned int lootVariantIndex)
{
  const WeaponCompleteDef *v4; 
  const char *szLootTable; 
  const char *ColumnValueForRow; 
  const char *result; 
  const dvar_t *v8; 
  const dvar_t *v9; 
  __int64 v10; 
  __int64 v11; 
  StringTable *tablePtr; 

  v4 = BG_WeaponCompleteDef(weapon, 0);
  if ( lootVariantIndex >= v4->numLootVariants && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22297, ASSERT_TYPE_ASSERT, "(unsigned)( lootVariantIndex ) < (unsigned)( weapCompleteDef->numLootVariants )", "lootVariantIndex doesn't index weapCompleteDef->numLootVariants\n\t%i not in [0, %i)", lootVariantIndex, v4->numLootVariants) )
    __debugbreak();
  szLootTable = v4->szLootTable;
  if ( (!szLootTable || !*szLootTable) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22298, ASSERT_TYPE_ASSERT, "(weapCompleteDef->szLootTable && weapCompleteDef->szLootTable[0])", (const char *)&queryFormat, "weapCompleteDef->szLootTable && weapCompleteDef->szLootTable[0]") )
    __debugbreak();
  StringTable_GetAsset(v4->szLootTable, (const StringTable **)&tablePtr);
  if ( !tablePtr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22301, ASSERT_TYPE_ASSERT, "(lootTable)", (const char *)&queryFormat, "lootTable") )
    __debugbreak();
  if ( lootVariantIndex >= StringTable_GetRowCount(tablePtr) )
  {
    LODWORD(v11) = StringTable_GetRowCount(tablePtr);
    LODWORD(v10) = lootVariantIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22302, ASSERT_TYPE_ASSERT, "(unsigned)( lootVariantIndex ) < (unsigned)( StringTable_GetRowCount( lootTable ) )", "lootVariantIndex doesn't index StringTable_GetRowCount( lootTable )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  ColumnValueForRow = StringTable_GetColumnValueForRow(tablePtr, lootVariantIndex, 17);
  if ( !ColumnValueForRow && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22305, ASSERT_TYPE_ASSERT, "(displayName)", (const char *)&queryFormat, "displayName") )
    __debugbreak();
  if ( !*ColumnValueForRow )
    return 0i64;
  result = SEH_StringEd_GetString(ColumnValueForRow);
  if ( !result )
  {
    v8 = DCONST_DVARBOOL_loc_warnings;
    if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    if ( v8->current.enabled )
    {
      v9 = DCONST_DVARBOOL_loc_warningsAsErrors;
      if ( !DCONST_DVARBOOL_loc_warningsAsErrors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warningsAsErrors") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v9);
      if ( v9->current.enabled )
        Com_Error_impl(ERR_LOCALIZATION, (const ObfuscateErrorText)&stru_1442E1080, 619i64, weapon->weaponIdx, ColumnValueForRow);
      else
        Com_PrintWarning(17, "WARNING: Weapon %d: Could not translate loot variant name \"%s\"\n", weapon->weaponIdx, ColumnValueForRow);
    }
    return ColumnValueForRow;
  }
  return result;
}

/*
==============
CG_Weapons_GetSFXImpactType
==============
*/
__int64 CG_Weapons_GetSFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  WeaponSFXPackage *SfxPackage; 
  int fxImpactType[6]; 

  SfxPackage = BG_GetSfxPackage(inWeapon, isAlternate);
  fxImpactType[0] = CG_Main_RegisteredImpactTypeToImpactType(UNKNOWN);
  if ( SfxPackage )
    fxImpactType[0] = SfxPackage->sfxImpactType;
  CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, fxImpactType);
  return (unsigned int)fxImpactType[0];
}

/*
==============
CG_Weapons_GetSFXWhizbyType
==============
*/
WeaponSFXPackage *CG_Weapons_GetSFXWhizbyType(const Weapon *inWeapon, bool isAlternate)
{
  WeaponSFXPackage *result; 

  result = BG_GetSfxPackage(inWeapon, isAlternate);
  if ( result )
    return (WeaponSFXPackage *)result->whizbyType;
  return result;
}

/*
==============
CG_Weapons_GetScriptableHitId
==============
*/

unsigned int __fastcall CG_Weapons_GetScriptableHitId(const trace_t *trace)
{
  return Trace_GetScriptableHitId(trace);
}

/*
==============
CG_Weapons_GetStowedOffsetModel
==============
*/
XModel *CG_Weapons_GetStowedOffsetModel(const WeaponDef *weapDef)
{
  ClGameModeApplication *ActiveClientApplication; 

  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25792, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( !weapDef->stowOffsetModel )
    return 0i64;
  ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
  if ( ActiveClientApplication->IsModelLoaded(ActiveClientApplication, weapDef->stowOffsetModel) )
    return weapDef->stowOffsetModel;
  if ( weapDef->stowOffsetModel == weapDef->worldModel )
    return weapDef->defaultWorldModel;
  else
    return 0i64;
}

/*
==============
CG_Weapons_GetVFXImpactType
==============
*/
__int64 CG_Weapons_GetVFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  const WeaponCompleteDef *v8; 
  unsigned int WeaponAttachments; 
  unsigned int v10; 
  unsigned int v11; 
  WeaponAttachment **v12; 
  int *p_vfxImpactType; 
  int fxImpactType[4]; 
  WeaponAttachment *attachments[30]; 

  v8 = BG_WeaponCompleteDef(inWeapon, isAlternate);
  WeaponAttachments = BG_GetWeaponAttachments(inWeapon, isAlternate, (const WeaponAttachment **)attachments);
  v10 = 0;
  fxImpactType[0] = v8->vfxImpactType;
  v11 = WeaponAttachments;
  if ( WeaponAttachments )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19919, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      p_vfxImpactType = &(*v12)->impact->vfxImpactType;
      if ( p_vfxImpactType )
        break;
      ++v10;
      ++v12;
      if ( v10 >= v11 )
        goto LABEL_10;
    }
    fxImpactType[0] = *p_vfxImpactType;
  }
LABEL_10:
  CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, fxImpactType);
  return (unsigned int)fxImpactType[0];
}

/*
==============
CG_Weapons_GetVMRelativeAnimIndex
==============
*/
__int64 CG_Weapons_GetVMRelativeAnimIndex(int ordinalIndex, bool isPostShipEnabled)
{
  unsigned int v4; 
  unsigned int v5; 
  int v6; 
  int v7; 
  __int64 v9; 
  __int64 v11; 
  int v12; 

  v4 = 16 * (isPostShipEnabled + 11);
  if ( ordinalIndex >= v4 )
  {
    v12 = 16 * (isPostShipEnabled + 11);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2907, ASSERT_TYPE_ASSERT, "(unsigned)( ordinalIndex ) < (unsigned)( CG_Weapons_GetVMRelativeAnimCount( isPostShipEnabled ) )", "ordinalIndex doesn't index CG_Weapons_GetVMRelativeAnimCount( isPostShipEnabled )\n\t%i not in [0, %i)", ordinalIndex, v12) )
      __debugbreak();
  }
  if ( ordinalIndex < 169 )
  {
    v5 = ordinalIndex + 236;
    goto LABEL_11;
  }
  v6 = ordinalIndex - 169;
  if ( v6 < 7 )
  {
    v5 = v6 + 398;
    goto LABEL_11;
  }
  v7 = v6 - 7;
  if ( isPostShipEnabled )
  {
    if ( v7 < 16 )
    {
      v5 = v7 + 432;
LABEL_11:
      if ( v5 - 236 > 0xA8 && v5 - 432 > 0xF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2890, ASSERT_TYPE_ASSERT, "(isValidViewmodelAnimIndex)", (const char *)&queryFormat, "isValidViewmodelAnimIndex") )
        __debugbreak();
      return v5;
    }
    v7 -= 16;
  }
  LODWORD(v11) = v4;
  LODWORD(v9) = v7;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2939, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Encountered unexpected viewmodel animation index %i (count %i).", v9, v11) )
    __debugbreak();
  return 236i64;
}

/*
==============
CG_Weapons_GetVehicleViewOrigin
==============
*/
char CG_Weapons_GetVehicleViewOrigin(const LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *outOrigin)
{
  centity_t *Entity; 
  vec3_t outAngles; 

  if ( ps->vehicleState.entity == 2047 || BG_IsTurretActiveFlags(&ps->eFlags) )
    return 0;
  Entity = CG_GetEntity(localClientNum, ps->vehicleState.entity);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15016, ASSERT_TYPE_ASSERT, "(vehicleEnt)", (const char *)&queryFormat, "vehicleEnt") )
    __debugbreak();
  if ( (Entity->flags & 1) == 0 || !BG_IsVehicleEntity(&Entity->nextState) )
    return 0;
  CG_VehicleCam_GetVehiclePosition(localClientNum, Entity, outOrigin, &outAngles);
  return 1;
}

/*
==============
CG_Weapons_GetVisibilityBoneIndex
==============
*/
__int64 CG_Weapons_GetVisibilityBoneIndex(const DObj *obj, const characterInfo_t *ci, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand, bool *outUseWeaponTag)
{
  bool *v10; 
  __int64 v11; 
  const WeaponDef *v12; 
  scr_string_t AttachBone; 
  bool v14; 
  CharacterModelType modelTypesToSearch[2]; 
  TagPair result; 
  unsigned __int8 inOutIndex; 
  scr_string_t outTagName; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23092, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23093, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v10 = outUseWeaponTag;
  if ( !outUseWeaponTag && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23094, ASSERT_TYPE_ASSERT, "(outUseWeaponTag)", (const char *)&queryFormat, "outUseWeaponTag") )
    __debugbreak();
  *v10 = 0;
  inOutIndex = -2;
  outTagName = 0;
  modelTypesToSearch[0] = CHAR_MODEL_WEAPON_HELD;
  modelTypesToSearch[1] = CHAR_MODEL_WEAPON_HELD_LEFT;
  BG_GetWeaponFlashTagname(&result, &ci->dobjHeldWeapon, 0, 0);
  if ( TagPair::GetTagNameAndBoneIndexForCharacter(&result, obj, ci, modelTypesToSearch, 2, &outTagName, &inOutIndex) )
  {
    LOBYTE(v11) = inOutIndex;
    if ( inOutIndex <= 0xFDu )
    {
      *v10 = 1;
      return (unsigned __int8)v11;
    }
  }
  if ( BG_IsThrowingAxe(r_weapon) || BG_IsMeleeOnlyAxe(r_weapon, isAlternate) )
  {
    inOutIndex = -2;
    v14 = DObjGetBoneIndexInternal_66(obj, scr_const.tag_weapon_right, &inOutIndex, (int *)&outUseWeaponTag) == 0;
    v11 = inOutIndex;
    if ( !v14 )
      return v11;
  }
  else
  {
    inOutIndex = -2;
    v12 = BG_WeaponDef(r_weapon, isAlternate);
    AttachBone = BG_Weapons_GetAttachBone(ci, v12->weapType, r_weapon, isAlternate, hand);
    if ( DObjGetBoneIndexInternal_66(obj, AttachBone, &inOutIndex, (int *)&outUseWeaponTag) )
      return inOutIndex;
  }
  return 254i64;
}

/*
==============
CG_Weapons_GetWeaponAnimRate
==============
*/
float CG_Weapons_GetWeaponAnimRate(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate, bool isDualWielding, XAnim_s *anims, weapAnimFiles_t animIndex_desiredTime, weapAnimFiles_t animIndex_actual, int oneHanded)
{
  __int64 v14; 
  char v15; 
  int ammoInClipBeforeReload; 
  CgHandler *Handler; 
  ReloadType v18; 
  CgHandler *v19; 
  ReloadType ReloadType; 
  CgHandler *v21; 
  int v22; 
  CgHandler *v23; 
  int v24; 
  CgHandler *v25; 
  int v26; 
  CgHandler *v27; 
  int weaponState; 
  cg_t *LocalClientGlobals; 
  int sprintInAnimLength; 
  cg_t *v31; 
  int sprintOutAnimLength; 
  CgWeaponMap *Instance; 
  bool IsMeleeAnimFatal; 
  const XAnimParts *v35; 
  int v36; 
  char *v37; 
  const char *name; 
  XAnim_s *v40; 
  unsigned int v41; 
  int LengthMsec; 
  float v43; 
  const XAnimParts *Parts; 
  char *WeaponName; 
  float v46; 
  bool *v48; 
  __int64 ammoInClip; 
  bool *hasFastReloadOverride; 
  int time; 
  bool v52[4]; 
  unsigned int animIndex; 
  int outShellEjectTime; 
  XAnim_s *v55; 
  int outMeleeDamageTime; 
  char output[1024]; 

  v14 = hand;
  v55 = anims;
  animIndex = animIndex_actual;
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1705, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  if ( (unsigned int)animIndex_desiredTime >= NUM_WEAP_VIEWMODEL_ANIMS )
  {
    LODWORD(v48) = animIndex_desiredTime;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1706, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex_desiredTime ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex_desiredTime doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v48, 608) )
      __debugbreak();
  }
  if ( (unsigned int)animIndex_actual >= NUM_WEAP_VIEWMODEL_ANIMS )
  {
    LODWORD(ammoInClip) = 608;
    LODWORD(v48) = animIndex_actual;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1707, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex_actual ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex_actual doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v48, ammoInClip) )
      __debugbreak();
  }
  if ( (unsigned int)v14 >= 2 )
  {
    LODWORD(ammoInClip) = 2;
    LODWORD(v48) = v14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v48, ammoInClip) )
      __debugbreak();
  }
  BG_WeaponDef(weapon, isAlternate);
  if ( oneHanded && animIndex_desiredTime == WEAP_ANIM_RECHAMBER )
  {
    v15 = 1;
    time = BG_RechamberTimeOneHanded(ps, weapon, isAlternate, isDualWielding);
  }
  else
  {
    switch ( animIndex_desiredTime )
    {
      case WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_JOG_TO_WALK:
      case WEAP_ANIM_VIEWMODEL_BLENDSPACE_START:
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_CYCLE|NUM_WEAP_ANIMS_ROOT|WEAP_ANIM_RELOAD_MULTIPLE_4:
        time = BG_LadderClimbRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ADDITIVE_SPRINT_IN:
      case WEAP_ANIM_SPRINT_IN:
        if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_movementAnimProto, "movementAnimProto") && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1946, ASSERT_TYPE_ASSERT, "(!Dvar_GetBool_Internal_DebugName( DCONST_DVARMPBOOL_movementAnimProto, \"movementAnimProto\" ))", (const char *)&queryFormat, "!DconstMP_GetBool( movementAnimProto )") )
          __debugbreak();
        LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
        if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1949, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
          __debugbreak();
        sprintInAnimLength = LocalClientGlobals->sprintAnimData.sprintInAnimLength;
        if ( !sprintInAnimLength )
        {
          CG_Weapons_StoreSprintAnimLength(localClientNum, animIndex_desiredTime, (const PlayerHandIndex)v14);
          sprintInAnimLength = LocalClientGlobals->sprintAnimData.sprintInAnimLength;
        }
        time = sprintInAnimLength;
        goto LABEL_96;
      case WEAP_ANIM_ADDITIVE_SPRINT_LOOP:
      case WEAP_ANIM_SPRINT_LOOP:
        time = BG_SprintLoopTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ADDITIVE_SPRINT_OUT:
      case WEAP_ANIM_SPRINT_IN_CANCEL:
      case WEAP_ANIM_SPRINT_OUT:
        if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_movementAnimProto, "movementAnimProto") && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1968, ASSERT_TYPE_ASSERT, "(!Dvar_GetBool_Internal_DebugName( DCONST_DVARMPBOOL_movementAnimProto, \"movementAnimProto\" ))", (const char *)&queryFormat, "!DconstMP_GetBool( movementAnimProto )") )
          __debugbreak();
        v31 = CG_GetLocalClientGlobals(localClientNum);
        if ( !v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1971, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
          __debugbreak();
        sprintOutAnimLength = v31->sprintAnimData.sprintOutAnimLength;
        if ( !sprintOutAnimLength )
        {
          CG_Weapons_StoreSprintAnimLength(localClientNum, animIndex_desiredTime, (const PlayerHandIndex)v14);
          sprintOutAnimLength = v31->sprintAnimData.sprintOutAnimLength;
        }
        time = sprintOutAnimLength;
        goto LABEL_96;
      case WEAP_ANIM_PRE_FIRE:
        time = BG_PreFireTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_HOLD_FIRE:
        time = BG_GetWeaponFieldTime(ps, weapon, isAlternate, isDualWielding, 16i64);
        goto LABEL_96;
      case WEAP_ANIM_GRENADE_PRIME:
        BG_GetGrenadePrimeTime(ps, weapon, isAlternate, &time);
        goto LABEL_96;
      case WEAP_ANIM_GRENADE_PRIME_READY_TO_THROW:
        BG_GetGrenadePrimeReadyToThrowTime(ps, weapon, isAlternate, &time);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_RELATIVE_FIRST:
        time = BG_SkydiveFreefallRaiseTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE:
        time = BG_SkydiveOpenParachuteTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE:
        time = BG_SkydiveQuickOpenParachuteTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_STILL_LAND:
        time = BG_SkydiveParachuteStillLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_SOFT_LAND:
        time = BG_SkydiveParachuteSlowSoftLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_HARD_LAND:
        time = BG_SkydiveParachuteSlowHardLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_FAST_LAND:
        time = BG_SkydiveParachuteFastLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_MID_AIR_DETACH:
        time = BG_SkydiveParachuteMidAirDetachTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN:
        time = BG_SkydiveSuperDiveInTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT:
        time = BG_SkydiveSuperDiveOutTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH:
        time = BG_SkydiveParachuteDetachTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_ALT_MELEE_LAST:
      case WEAP_ANIM_RELOAD_ADS:
      case WEAP_ANIM_RELOAD_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_FIRST:
      case WEAP_ANIM_FAST_RELOAD_ADS:
      case WEAP_ANIM_FAST_RELOAD_ADS_NVG:
        ammoInClipBeforeReload = ps->weapState[v14].ammoInClipBeforeReload;
        v52[0] = 0;
        Handler = CgHandler::getHandler(localClientNum);
        time = BG_ReloadTime(ps, Handler, (const PlayerHandIndex)v14, weapon, isAlternate, isDualWielding, ammoInClipBeforeReload, v52);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_EMPTY:
      case WEAP_ANIM_RELOAD_EMPTY_ADS:
      case WEAP_ANIM_RELOAD_EMPTY_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_EMPTY:
      case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS:
      case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS_NVG:
        v52[0] = 0;
        ReloadType = BG_GetReloadType(weapon, isAlternate);
        v21 = CgHandler::getHandler(localClientNum);
        if ( ReloadType == RELOAD_TYPE_MULTIPLE_PERCENTAGE )
          time = BG_ReloadMultipleTimePercentageBased(ps, v21, (const PlayerHandIndex)v14, weapon, isAlternate, v52);
        else
          time = BG_ReloadEmptyTime(ps, v21, (const PlayerHandIndex)v14, weapon, isAlternate, isDualWielding, v52);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_START:
      case WEAP_ANIM_RELOAD_START_ADS:
      case WEAP_ANIM_RELOAD_START_ADS_NVG:
      case WEAP_ANIM_RELOAD_START_TWO:
      case WEAP_ANIM_RELOAD_START_TWO_ADS:
      case WEAP_ANIM_RELOAD_START_TWO_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_START:
      case WEAP_ANIM_FAST_RELOAD_START_ADS:
      case WEAP_ANIM_FAST_RELOAD_START_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_START_TWO:
      case WEAP_ANIM_FAST_RELOAD_START_TWO_ADS:
      case WEAP_ANIM_FAST_RELOAD_START_TWO_ADS_NVG:
        v22 = ps->weapState[v14].ammoInClipBeforeReload;
        v52[0] = 0;
        v23 = CgHandler::getHandler(localClientNum);
        time = BG_ReloadStartTime(ps, v23, (const PlayerHandIndex)v14, weapon, isAlternate, isDualWielding, v22, v52);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_END:
      case WEAP_ANIM_RELOAD_END_ADS:
      case WEAP_ANIM_RELOAD_END_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_END:
      case WEAP_ANIM_FAST_RELOAD_END_ADS:
      case WEAP_ANIM_FAST_RELOAD_END_ADS_NVG:
        v24 = ps->weapState[v14].ammoInClipBeforeReload;
        v52[0] = 0;
        v25 = CgHandler::getHandler(localClientNum);
        time = BG_ReloadEndTime(ps, v25, (const PlayerHandIndex)v14, weapon, isAlternate, isDualWielding, v24, v52);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_END_RECHAMBER:
      case WEAP_ANIM_RELOAD_END_RECHAMBER_ADS:
      case WEAP_ANIM_RELOAD_END_RECHAMBER_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER:
      case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER_ADS:
      case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER_ADS_NVG:
        v26 = ps->weapState[v14].ammoInClipBeforeReload;
        v52[0] = 0;
        outShellEjectTime = 0;
        v27 = CgHandler::getHandler(localClientNum);
        time = BG_ReloadEndRechamberTime(ps, v27, (const PlayerHandIndex)v14, weapon, isAlternate, isDualWielding, v26, &outShellEjectTime, v52);
        goto LABEL_96;
      case WEAP_ANIM_RAISE:
        time = BG_RaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_FIRST_RAISE:
        time = BG_FirstRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BREACH_RAISE:
        time = BG_BreachRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_DROP:
        time = BG_DropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_RAISE:
        time = BG_AltRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_RAISE_ADS:
        time = BG_AltRaiseADSTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_RAISE_AKIMBO:
        time = BG_AltRaiseAkimboTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_DROP:
        time = BG_AltDropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_DROP_ADS:
        time = BG_AltDropADSTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_DROP_AKIMBO:
        time = BG_AltDropAkimboTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_QUICK_RAISE:
        if ( ps->weapState[v14].weaponState == 6 )
          goto LABEL_41;
        time = BG_QuickRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_QUICK_DROP:
        weaponState = ps->weapState[v14].weaponState;
        if ( weaponState == 44 )
        {
          time = BG_Ladder_MantleDropTime(ps);
        }
        else if ( weaponState == 6 )
        {
LABEL_46:
          time = BG_LadderAimDropTime(ps, weapon, isAlternate, isDualWielding);
        }
        else
        {
          time = BG_QuickDropTime(ps, weapon, isAlternate, isDualWielding);
        }
        goto LABEL_96;
      case WEAP_ANIM_EMPTY_RAISE:
        time = BG_EmptyRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_EMPTY_DROP:
        time = BG_EmptyDropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_STUNNED_START:
        time = BG_StunnedTimeBegin(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_STUNNED_LOOP:
        time = BG_StunnedTimeLoop(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_STUNNED_END:
        time = BG_StunnedTimeEnd(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_FRONT:
        time = BG_BlastFrontTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_RIGHT:
        time = BG_BlastRightTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_BACK:
        time = BG_BlastBackTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_LEFT:
        time = BG_BlastLeftTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_CHARGE_IN:
      case WEAP_ANIM_ADS_CHARGE_IN:
        time = BG_ChargeWeaponInTime(ps, animIndex_desiredTime, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_CHARGE_LOOP:
      case WEAP_ANIM_ADS_CHARGE_LOOP:
        time = BG_ChargeWeaponLoopTime(ps, animIndex_desiredTime, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_CHARGE_OUT:
      case WEAP_ANIM_ADS_CHARGE_OUT:
        if ( BG_WeaponCharge_GetType(weapon, isAlternate) == PTRDIFF )
          return FLOAT_1_0;
        time = BG_ChargeWeaponOutTime(ps, animIndex_desiredTime, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_MULTIPLE_FIRST:
      case WEAP_ANIM_RELOAD_MULTIPLE_2:
      case WEAP_ANIM_RELOAD_MULTIPLE_3:
      case WEAP_ANIM_RELOAD_MULTIPLE_4:
      case WEAP_ANIM_RELOAD_MULTIPLE_5:
      case WEAP_ANIM_RELOAD_MULTIPLE_6:
      case WEAP_ANIM_RELOAD_MULTIPLE_7:
      case WEAP_ANIM_RELOAD_MULTIPLE_8:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_FIRST:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_2:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_3:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_4:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_5:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_6:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_7:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_8:
        v52[0] = 0;
        v18 = BG_GetReloadType(weapon, isAlternate);
        v19 = CgHandler::getHandler(localClientNum);
        if ( v18 == RELOAD_TYPE_MULTIPLE_BULLET )
          time = BG_ReloadMultipleTimeBulletBased(ps, v19, (const PlayerHandIndex)v14, weapon, isAlternate, v52);
        else
          time = BG_ReloadMultipleTimePercentageBased(ps, v19, (const PlayerHandIndex)v14, weapon, isAlternate, v52);
        goto LABEL_96;
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|WEAP_ANIM_RELOAD_MULTIPLE_4:
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|WEAP_ANIM_ROOT_START|WEAP_ANIM_RELOAD_MULTIPLE_4:
        time = BG_LadderClimbDropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|NUM_ADDITIVE_SKYDIVE_CHILDREN|WEAP_ANIM_RELOAD_MULTIPLE_4:
LABEL_41:
        time = BG_LadderAimRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|WEAP_ANIM_ROOT_START|NUM_ADDITIVE_SKYDIVE_CHILDREN|WEAP_ANIM_RELOAD_MULTIPLE_4:
        goto LABEL_46;
      default:
        if ( !BG_IsMeleeAnim(animIndex_desiredTime) )
          return FLOAT_1_0;
        Instance = CgWeaponMap::GetInstance(localClientNum);
        IsMeleeAnimFatal = BG_IsMeleeAnimFatal(animIndex_desiredTime);
        BG_GetMeleeTime(Instance, ps, isAlternate, isDualWielding, IsMeleeAnimFatal, &time, &outMeleeDamageTime, &outShellEjectTime);
LABEL_96:
        v15 = 0;
        break;
    }
  }
  if ( time > 0 )
  {
    v40 = v55;
    v41 = animIndex;
    if ( XAnimBlendSpace_IsBlendspaceNode(v55, animIndex) )
      LengthMsec = XAnimBlendSpace_GetLengthMsec(v40, v41);
    else
      LengthMsec = XAnimGetLengthMsec(v40, v41);
    v43 = (float)LengthMsec;
    if ( v43 > 0.0 )
    {
      v46 = v43 / (float)time;
      if ( v46 <= 0.0 )
      {
        __asm { vxorpd  xmm1, xmm1, xmm1 }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2125, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( rate )", "%s < %s\n\t%g, %g", "0.0f", "rate", *(double *)&_XMM1, v46) )
          __debugbreak();
      }
      return v46;
    }
    else
    {
      Parts = XAnimGetParts(v40, v41);
      if ( !Parts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2117, ASSERT_TYPE_ASSERT, "( parts ) != ( nullptr )", "%s != %s\n\t%p, %p", "parts", "nullptr", NULL, NULL) )
        __debugbreak();
      WeaponName = BG_GetWeaponName(weapon, output, 0x400u);
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DAD20, 601i64, Parts->name, WeaponName, v43);
      return 0.0;
    }
  }
  else
  {
    v35 = XAnimGetParts(v55, animIndex_desiredTime);
    if ( !v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2090, ASSERT_TYPE_ASSERT, "( parts ) != ( nullptr )", "%s != %s\n\t%p, %p", "parts", "nullptr", NULL, NULL) )
      __debugbreak();
    v36 = time;
    v37 = BG_GetWeaponName(weapon, output, 0x400u);
    name = "rechamberTimeOneHanded";
    if ( !v15 )
      name = v35->name;
    LODWORD(hasFastReloadOverride) = animIndex;
    LODWORD(ammoInClip) = animIndex_desiredTime;
    LODWORD(v48) = v36;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DAC80, 600i64, name, v37, v48, ammoInClip, hasFastReloadOverride);
    return 0.0;
  }
}

/*
==============
CG_Weapons_GetWeaponForName
==============
*/
Weapon *CG_Weapons_GetWeaponForName(Weapon *result, const char *weaponName)
{
  BG_Weapons_GetFullWeaponForName(weaponName, result, BG_FindBaseWeaponForName);
  return result;
}

/*
==============
CG_Weapons_GetWeaponStateModifiedAnimRate
==============
*/
float CG_Weapons_GetWeaponStateModifiedAnimRate(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, PlayerHandIndex hand, XAnim_s *anims, weapAnimFiles_t animIndex)
{
  __int64 v7; 
  __int64 v9; 
  bool HasUnderbarrelAmmo; 
  CgWeaponMap *v11; 
  Weapon *AltWeapon; 
  weapAnimFiles_t animIndex_desiredTime; 
  int oneHanded; 
  float WeaponAnimRate; 
  __int64 v16; 
  float v17; 
  unsigned __int64 weaponState; 
  __int64 v19; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *p_weapFlags; 
  bool v21; 
  bool HasPerk; 
  char v23; 
  bool v24; 
  int v25; 
  bool v26; 
  double Float_Internal_DebugName; 
  double v28; 
  float v29; 
  CgWeaponMap *Instance; 
  int v31; 
  bool v32; 
  bool v33; 
  CgHandler *v34; 
  double v35; 
  double v36; 
  CgHandler *Handler; 
  bool IsUsingFastReloadStateTimer; 
  double ReloadTimeScale; 
  bool isDualWielding; 
  Weapon r_weapon; 

  v7 = hand;
  v9 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2162, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2163, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  HasUnderbarrelAmmo = BG_UsingAlternate(ps);
  if ( HasUnderbarrelAmmo )
    HasUnderbarrelAmmo = BG_HasUnderbarrelAmmo(weapon);
  if ( !CgWeaponMap::ms_instance[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v11 = CgWeaponMap::ms_instance[v9];
  isDualWielding = BG_PlayerDualWieldingWeapon(v11, ps, weapon) == 1;
  if ( HasUnderbarrelAmmo )
    AltWeapon = (Weapon *)BG_GetAltWeapon(weapon);
  else
    AltWeapon = (Weapon *)weapon;
  r_weapon = *AltWeapon;
  if ( animIndex != WEAP_ANIM_EMPTY_DROP || (animIndex_desiredTime = WEAP_ANIM_QUICK_DROP, ps->weapState[v7].weaponState != 8) )
    animIndex_desiredTime = animIndex;
  oneHanded = BG_PlayerDualWieldingWeapon(v11, ps, &r_weapon);
  WeaponAnimRate = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v9, ps, (const PlayerHandIndex)v7, &r_weapon, HasUnderbarrelAmmo, isDualWielding, anims, animIndex_desiredTime, animIndex, oneHanded);
  v16 = v7;
  v17 = WeaponAnimRate;
  weaponState = ps->weapState[v7].weaponState;
  if ( (unsigned int)weaponState <= 0x32 && (v19 = 0x4000000001FBEi64, _bittest64(&v19, weaponState)) )
  {
    p_weapFlags = &ps->weapCommon.weapFlags;
    if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x15u) )
    {
      v21 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x29u);
      HasPerk = BG_HasPerk(&ps->perks, 0x2Bu);
      if ( v21 || HasPerk )
      {
        v23 = 1;
        goto LABEL_26;
      }
    }
  }
  else
  {
    p_weapFlags = &ps->weapCommon.weapFlags;
  }
  v23 = 0;
LABEL_26:
  v24 = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x16u);
  v25 = ps->weapState[v16].weaponState;
  v26 = v24;
  if ( (unsigned int)(v25 - 18) <= 3 )
  {
    Handler = CgHandler::getHandler((LocalClientNum_t)v9);
    IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, Handler, hand, &r_weapon, HasUnderbarrelAmmo, isDualWielding);
    ReloadTimeScale = BG_GetReloadTimeScale(v11, ps, weapon, HasUnderbarrelAmmo, ps->weapState[v16].ammoInClipBeforeReload, IsUsingFastReloadStateTimer);
    if ( *(float *)&ReloadTimeScale <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2193, ASSERT_TYPE_ASSERT, "(reloadTimeScale > 0.0f)", (const char *)&queryFormat, "reloadTimeScale > 0.0f") )
      __debugbreak();
    return v17 / *(float *)&ReloadTimeScale;
  }
  else
  {
    if ( v25 == 36 && BG_HasPerk(&ps->perks, 0x13u) )
    {
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_sprintRecoveryMultiplierVisual, "perk_sprintRecoveryMultiplierVisual");
      if ( *(float *)&Float_Internal_DebugName != 0.0 )
      {
        v28 = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_sprintRecoveryMultiplierVisual, "perk_sprintRecoveryMultiplierVisual");
        return v17 / *(float *)&v28;
      }
      return FLOAT_1000_0;
    }
    if ( (unsigned int)(ps->weapState[v16].weaponState - 26) <= 6 )
    {
      Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v9);
      if ( BG_UseFastOffhand(ps, Instance) )
      {
        v28 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_perk_fastOffhandMultiplier, "perk_fastOffhandMultiplier");
        if ( *(float *)&v28 == 0.0 )
          return FLOAT_1000_0;
        return v17 / *(float *)&v28;
      }
    }
    if ( v23 || (v29 = WeaponAnimRate, v26) )
    {
      v31 = ps->weapState[v16].weaponState;
      v32 = (unsigned int)(v31 - 1) <= 4;
      v33 = (unsigned int)(v31 - 7) <= 5 || v31 == 50;
      v29 = WeaponAnimRate;
      v34 = CgHandler::getHandler((LocalClientNum_t)v9);
      if ( !BG_UseQuickSwitchAnims(ps, weapon, HasUnderbarrelAmmo, isDualWielding, v34, v32) )
      {
        v35 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_perk_weapSwapMultiplier, "perk_weapSwapMultiplier");
        if ( *(float *)&v35 == 0.0 )
          v29 = FLOAT_1000_0;
        else
          v29 = v17 / *(float *)&v35;
      }
      if ( v26 && v33 )
      {
        v36 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_player_meleeOverrideQuickDropScale, "player_meleeOverrideQuickDropScale");
        if ( *(float *)&v36 == 0.0 )
          return FLOAT_1000_0;
      }
      else
      {
        if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x29u) )
          return v29;
        v36 = Dvar_GetFloat_Internal_DebugName(DVARFLT_bg_quickWeaponSwitchSpeedScaleSP, "bg_quickWeaponSwitchSpeedScaleSP");
        if ( *(float *)&v36 == 0.0 )
          return FLOAT_1000_0;
      }
      return v29 / *(float *)&v36;
    }
  }
  return v29;
}

/*
==============
CG_Weapons_GetWeaponViewRoughOriginIfValid
==============
*/
char CG_Weapons_GetWeaponViewRoughOriginIfValid(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *result)
{
  __int16 linkEnt; 
  centity_t *Entity; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23141, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (ps->linkFlags.m_flags[0] & 4) == 0 )
    return 0;
  linkEnt = ps->linkEnt;
  if ( linkEnt == 2047 )
    return 0;
  Entity = CG_GetEntity(localClientNum, linkEnt);
  if ( (Entity->flags & 1) == 0 )
    return 0;
  CG_GetPoseOrigin(&Entity->pose, result);
  return 1;
}

/*
==============
CG_Weapons_HoldBreathInit
==============
*/
void CG_Weapons_HoldBreathInit(cg_t *cgameGlob)
{
  cgameGlob->holdBreathTime = -1;
  *(_QWORD *)&cgameGlob->holdBreathDelay = 0i64;
}

/*
==============
CG_Weapons_HybridScopeUpdate
==============
*/
void CG_Weapons_HybridScopeUpdate(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate)
{
  __int64 v5; 
  cg_t *LocalClientGlobals; 
  DObj **p_viewModelDObj; 
  __m256i *p_scopeToggleInfo; 
  DObj *v11; 
  XAnim_s *Anims; 
  __int64 v13; 
  char v14; 
  char CanHybridToggle; 
  bool v16; 
  bool v17; 
  const XAnimTree *Tree; 
  double Weight; 
  float v20; 
  double v21; 
  int weaponState; 
  bool v23; 
  const Weapon *v24; 
  const playerState_s *v25; 
  LocalClientNum_t v26; 
  const XAnimTree *v27; 
  double v28; 
  float v29; 
  double Time; 
  const XAnimTree *v31; 
  double v32; 
  float v33; 
  double v34; 
  char *fmt; 
  ClientScopeToggleInfo *scopeToggleInfo; 
  XAnim_s *scopeToggleInfoa; 
  ClientScopeToggleInfo *v38; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool hybridScope; 
  CgWeaponMap *weaponMap; 
  CgHandler *weaponMapa; 

  v5 = localClientNum;
  if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7697, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, cl_maxLocalClients) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7698, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v5);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7701, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_viewModelDObj = &LocalClientGlobals->m_weaponHand[0].viewModelDObj;
  p_scopeToggleInfo = (__m256i *)&LocalClientGlobals->scopeToggleInfo;
  if ( LocalClientGlobals == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7706, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  v11 = *p_viewModelDObj;
  if ( !*p_viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7709, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Anims = XAnimGetAnims(LocalClientGlobals->m_weaponHand[0].tree);
  if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7712, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  v13 = v5;
  if ( !CgWeaponMap::ms_instance[v5] )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    v13 = v5;
  }
  weaponMap = CgWeaponMap::ms_instance[v13];
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7715, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, weapon);
  if ( !EquippedWeaponStateConst || BG_Skydive_IsSkydiving(ps) )
  {
    memset_0(&LocalClientGlobals->scopeToggleInfo, 0, sizeof(LocalClientGlobals->scopeToggleInfo));
  }
  else
  {
    weaponMapa = CgHandler::getHandler((LocalClientNum_t)v5);
    if ( !weaponMapa && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7726, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
      __debugbreak();
    v14 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) || LocalClientGlobals->inKillCam;
    if ( memcmp_0(p_scopeToggleInfo, weapon, 0x3Cui64) || p_scopeToggleInfo[2].m256i_i8[8] != isAlternate || p_scopeToggleInfo[2].m256i_i8[9] != v14 )
    {
      memset_0(p_scopeToggleInfo, 0, 0x50ui64);
      p_scopeToggleInfo[2].m256i_i8[11] = BG_ViewModelAnimExists(ps, WEAP_ANIM_SCOPE_TOGGLE_ON, WEAPON_HAND_DEFAULT, weaponMapa) != 0;
      p_scopeToggleInfo[2].m256i_i8[12] = BG_ViewModelAnimExists(ps, WEAP_ANIM_SCOPE_TOGGLE_OFF, WEAPON_HAND_DEFAULT, weaponMapa) != 0;
    }
    *p_scopeToggleInfo = *(__m256i *)&weapon->weaponIdx;
    *(_OWORD *)p_scopeToggleInfo[1].m256i_i8 = *(_OWORD *)&weapon->attachmentVariationIndices[5];
    p_scopeToggleInfo[1].m256i_i64[2] = *(__int64 *)&weapon->attachmentVariationIndices[21];
    p_scopeToggleInfo[1].m256i_i32[6] = *(_DWORD *)&weapon->weaponCamo;
    p_scopeToggleInfo[2].m256i_i8[8] = isAlternate;
    p_scopeToggleInfo[2].m256i_i8[9] = v14;
    CanHybridToggle = BG_CanHybridToggle(ps, weapon, 0);
    if ( BG_HasUnderbarrelAmmo(weapon) )
      CanHybridToggle |= BG_CanHybridToggle(ps, weapon, 1);
    hybridScope = EquippedWeaponStateConst->hybridScope;
    if ( CanHybridToggle )
      CG_Weapons_HybridScopeUpdate_CalcScopeFraction((const LocalClientNum_t)v5, ps, weapon, isAlternate, EquippedWeaponStateConst->hybridScope, (ClientScopeToggleInfo *)p_scopeToggleInfo);
    v16 = p_scopeToggleInfo[2].m256i_i8[11] == 0;
    p_scopeToggleInfo[2].m256i_i8[10] = 1;
    v17 = !v16 && p_scopeToggleInfo[2].m256i_i8[12];
    if ( CanHybridToggle && v17 )
    {
      Tree = DObjGetTree(v11);
      if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7775, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
        __debugbreak();
      Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
      v20 = *(float *)&Weight;
      v21 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
      if ( v20 <= 0.0 && *(float *)&v21 <= 0.0 )
        p_scopeToggleInfo[1].m256i_i32[7] = 0;
      switch ( p_scopeToggleInfo[1].m256i_i32[7] )
      {
        case 0:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7603, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7604, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7605, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          weaponState = ps->weapState[0].weaponState;
          if ( weaponState == 76 )
            goto LABEL_79;
          if ( weaponState == 77 )
            goto LABEL_109;
          v23 = isAlternate;
          v38 = (ClientScopeToggleInfo *)p_scopeToggleInfo;
          v24 = weapon;
          scopeToggleInfoa = Anims;
          v25 = ps;
          fmt = (char *)v11;
          v26 = (int)v5;
          if ( !hybridScope )
            goto LABEL_128;
          goto LABEL_68;
        case 1:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7543, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7544, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7545, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          if ( ps->weapState[0].weaponState == 76 )
          {
LABEL_79:
            CG_Weapons_ScopeToggleState_ToggleOn_Enter((const LocalClientNum_t)v5, ps, weapon, isAlternate, v11, Anims, (ClientScopeToggleInfo *)p_scopeToggleInfo);
            p_scopeToggleInfo[1].m256i_i32[7] = 2;
          }
          else if ( hybridScope )
          {
LABEL_68:
            CG_Weapons_ScopeToggleState_Scope2InPosition_Enter((const LocalClientNum_t)v5, ps, weapon, isAlternate, v11, Anims, (ClientScopeToggleInfo *)p_scopeToggleInfo);
            p_scopeToggleInfo[1].m256i_i32[7] = 4;
          }
          break;
        case 2:
          CG_Weapons_ScopeToggleState_ToggleOn_Update((const LocalClientNum_t)v5, ps, weapon, isAlternate, v11, Anims, (ClientScopeToggleInfo *)p_scopeToggleInfo);
          return;
        case 3:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7336, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7337, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7338, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          v27 = DObjGetTree(v11);
          if ( !v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7341, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
            __debugbreak();
          v28 = XAnimGetWeight(v27, 0, XANIM_SUBTREE_DEFAULT, 0x103u);
          v29 = *(float *)&v28;
          Time = XAnimGetTime(v27, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
          if ( v29 == 0.001 && *(float *)&Time >= 1.0 )
            goto LABEL_68;
          return;
        case 4:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7581, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7582, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7583, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          if ( ps->weapState[0].weaponState == 77 )
          {
LABEL_109:
            CG_Weapons_ScopeToggleState_ToggleOff_Enter((const LocalClientNum_t)v5, ps, weapon, isAlternate, v11, Anims, (ClientScopeToggleInfo *)p_scopeToggleInfo);
            p_scopeToggleInfo[1].m256i_i32[7] = 5;
          }
          else if ( !hybridScope )
          {
LABEL_127:
            v38 = (ClientScopeToggleInfo *)p_scopeToggleInfo;
            v23 = isAlternate;
            scopeToggleInfoa = Anims;
            v24 = weapon;
            fmt = (char *)v11;
            v25 = ps;
            v26 = (int)v5;
LABEL_128:
            CG_Weapons_ScopeToggleState_Scope1InPosition_Enter(v26, v25, v24, v23, (DObj *)fmt, scopeToggleInfoa, v38);
            p_scopeToggleInfo[1].m256i_i32[7] = 1;
          }
          break;
        case 5:
          CG_Weapons_ScopeToggleState_ToggleOff_Update((const LocalClientNum_t)v5, ps, weapon, isAlternate, v11, Anims, (ClientScopeToggleInfo *)p_scopeToggleInfo);
          return;
        case 6:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7444, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7445, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7446, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          v31 = DObjGetTree(v11);
          if ( !v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7449, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
            __debugbreak();
          v32 = XAnimGetWeight(v31, 0, XANIM_SUBTREE_DEFAULT, 0x103u);
          v33 = *(float *)&v32;
          v34 = XAnimGetTime(v31, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
          if ( v33 == 0.001 && *(float *)&v34 >= 1.0 )
            goto LABEL_127;
          return;
        default:
          LODWORD(scopeToggleInfo) = p_scopeToggleInfo[1].m256i_i32[7];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7824, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled state %d in CG_Weapons_PlayScopeToggleAnimations", scopeToggleInfo) )
            __debugbreak();
          return;
      }
    }
    else
    {
      XAnimSetGoalWeight(v11, 0, XANIM_SUBTREE_DEFAULT, 0x103u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      if ( p_scopeToggleInfo[2].m256i_i8[11] )
        XAnimSetGoalWeight(v11, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      if ( p_scopeToggleInfo[2].m256i_i8[12] )
        XAnimSetGoalWeight(v11, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
}

/*
==============
CG_Weapons_HybridScopeUpdate_CalcScopeFraction
==============
*/
void CG_Weapons_HybridScopeUpdate_CalcScopeFraction(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const bool scope2IsActive, ClientScopeToggleInfo *scopeToggleInfo)
{
  int weaponState; 
  bool v15; 
  bool v16; 
  int v17; 
  int v18; 
  cg_t *LocalClientGlobals; 
  float fraction; 
  float v21; 
  __int128 fraction_low; 
  __int128 v26; 

  if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7634, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, cl_maxLocalClients) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7635, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( scopeToggleInfo->initialized )
  {
    weaponState = ps->weapState[0].weaponState;
    v15 = weaponState == 76 || weaponState != 77 && scope2IsActive;
    scopeToggleInfo->fractionInfo.increasing = v15;
    v16 = BG_PlayerDualWielding(ps) == 1;
    if ( scopeToggleInfo->fractionInfo.increasing )
      v17 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v16);
    else
      v17 = BG_ScopeToggleOffTime(ps, weapon, isAlternate, v16);
    v18 = v17;
    if ( v17 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7665, ASSERT_TYPE_ASSERT, "( scopeToggleTime ) > ( 0 )", "%s > %s\n\t%i, %i", "scopeToggleTime", "0", v17, 0i64) )
      __debugbreak();
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7668, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    fraction = scopeToggleInfo->fractionInfo.fraction;
    v21 = (float)LocalClientGlobals->frametime / (float)v18;
    if ( scopeToggleInfo->fractionInfo.increasing )
    {
      fraction_low = LODWORD(scopeToggleInfo->fractionInfo.fraction);
      *(float *)&fraction_low = fraction + v21;
      _XMM0 = fraction_low;
      __asm { vminss  xmm1, xmm0, cs:__real@3f800000 }
    }
    else
    {
      v26 = LODWORD(scopeToggleInfo->fractionInfo.fraction);
      *(float *)&v26 = fraction - v21;
      _XMM1 = v26;
      __asm { vmaxss  xmm1, xmm1, xmm0 }
    }
    scopeToggleInfo->fractionInfo.fraction = *(float *)&_XMM1;
  }
  else
  {
    _XMM0 = scope2IsActive;
    __asm { vpcmpeqd xmm3, xmm0, xmm1 }
    _XMM1 = LODWORD(FLOAT_1_0);
    __asm { vblendvps xmm0, xmm1, xmm2, xmm3 }
    scopeToggleInfo->fractionInfo.fraction = *(float *)&_XMM0;
  }
}

/*
==============
CG_Weapons_Init
==============
*/
void CG_Weapons_Init(LocalClientNum_t localClientNum, bool isFirstInitizingClient)
{
  ClConfigStrings *ClConfigStrings; 
  unsigned __int16 *v4; 
  const char *const *v5; 
  __int64 v6; 
  unsigned int v7; 
  unsigned __int16 v8; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1555, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( isFirstInitizingClient )
  {
    cg_tagIKTargetModelLeft = R_RegisterModel("tag_ik_target_left");
    cg_tagIKTargetModelRight = R_RegisterModel("tag_ik_target_right");
    CG_Gesture_Init();
  }
  ClConfigStrings = ClConfigStrings::GetClConfigStrings();
  v4 = cg_defaultWeaponStickerMaterialIndices;
  v5 = DEFAULT_STICKER_SLOT_MATERIAL_NAMES_0;
  v6 = 4i64;
  do
  {
    v7 = ClConfigStrings->GetStickerMaterialIndex(ClConfigStrings, *v5);
    v8 = v7;
    if ( v7 > 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)v7, "unsigned", v7) )
      __debugbreak();
    *v4 = v8;
    ++v5;
    ++v4;
    --v6;
  }
  while ( v6 );
}

/*
==============
CG_Weapons_IsAiming
==============
*/
bool CG_Weapons_IsAiming(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  return GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u) && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 1u) && BG_IsAimDownSight(r_weapon, isAlternate) && (BG_PlayerLastWeaponHand(weaponMap, ps) == WEAPON_HAND_DEFAULT || BG_HasLadderHand(ps));
}

/*
==============
CG_Weapons_IsBulletWeapon
==============
*/
_BOOL8 CG_Weapons_IsBulletWeapon(const Weapon *weapon, bool isAlternate)
{
  return BG_GetWeaponType(weapon, isAlternate) == WEAPTYPE_BULLET;
}

/*
==============
CG_Weapons_IsInAds
==============
*/
bool CG_Weapons_IsInAds(const LocalClientNum_t localClientNum, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const PlayerHandIndex handIndex)
{
  CgHandler *Handler; 
  bool isInterruptible; 
  bool result; 

  result = 0;
  if ( CG_Weapons_IsAiming(weaponMap, ps, r_weapon, isAlternate) )
  {
    if ( (unsigned int)(ps->weapState[handIndex].weaponState - 18) > 1 )
      return 1;
    Handler = CgHandler::getHandler(localClientNum);
    isInterruptible = PM_Weapon_IsInInterruptibleState(weaponMap, ps, handIndex, Handler);
    if ( !CG_Weapons_IsReloadActive(localClientNum, ps, handIndex, r_weapon, isAlternate, isInterruptible) )
      return 1;
  }
  return result;
}

/*
==============
CG_Weapons_IsPlayerSprinting
==============
*/
bool CG_Weapons_IsPlayerSprinting(const characterInfo_t *ci, const centity_t *cent)
{
  entityState_t *p_nextState; 
  unsigned int Animset; 
  unsigned int Anim; 
  bool v7; 
  SuitAnimType SuitAnimIndex; 
  int LegsAnimation; 
  bool result; 

  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26052, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  result = 0;
  if ( !ci->usingAnimState )
  {
    p_nextState = &cent->nextState;
    if ( PlayerASM_IsEnabled() )
    {
      Animset = BG_PlayerASM_GetAnimset(p_nextState);
      Anim = BG_PlayerASM_GetAnim(p_nextState, MOVEMENT);
      v7 = BG_PlayerASM_IsSprintAlias(Anim, Animset) == 0;
    }
    else
    {
      SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(p_nextState);
      LegsAnimation = BG_AnimationMP_GetLegsAnimation(p_nextState);
      v7 = !BG_IsSprintAnim(LegsAnimation, SuitAnimIndex);
    }
    if ( !v7 )
      return 1;
  }
  return result;
}

/*
==============
CG_Weapons_IsReloadActive
==============
*/
bool CG_Weapons_IsReloadActive(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex, const Weapon *weapon, const bool isAlternate, const bool isInterruptible)
{
  __int64 v6; 
  __int64 v8; 
  bool v10; 
  const BgWeaponMap **v11; 
  const BgWeaponMap *v12; 
  ReloadType ReloadType; 

  v6 = handIndex;
  v8 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8362, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = CgWeaponMap::ms_instance[v8] == NULL;
  v11 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v8];
  if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v12 = *v11;
  ReloadType = BG_GetReloadType(weapon, isAlternate);
  if ( ReloadType != RELOAD_TYPE_SEGMENTED && isInterruptible )
    return 0;
  if ( ReloadType == RELOAD_TYPE_SEGMENTED && (unsigned int)(ps->weapState[v6].weaponState - 20) > 1 )
    return 1;
  return ps->weapState[v6].weaponTime - BG_ADSReloadTransTime(v12, ps, weapon, isAlternate) > 0;
}

/*
==============
CG_Weapons_LoadViewModelDObj
==============
*/
void CG_Weapons_LoadViewModelDObj(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const PlayerHandIndex weaponHand)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  __int64 v9; 
  ClConfigStrings *ClConfigStrings; 
  const char *v11; 
  const char *v12; 
  XModel *handXModel; 
  bool v14; 
  __int64 recreateAnimTrees; 

  v4 = weaponHand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13453, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13454, ASSERT_TYPE_ASSERT, "(weapon.weaponIdx != 0)", (const char *)&queryFormat, "weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(recreateAnimTrees) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, 2) )
      __debugbreak();
  }
  v9 = (__int64)&LocalClientGlobals->m_weaponHand[v4];
  if ( !*(_DWORD *)(v9 + 32) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13459, ASSERT_TYPE_ASSERT, "(weapHand->hasAnimTree)", (const char *)&queryFormat, "weapHand->hasAnimTree") )
    __debugbreak();
  if ( !*(_QWORD *)v9 )
  {
    if ( ps->viewmodelIndex <= 0 )
    {
      v14 = BG_UsingAlternate(ps);
      handXModel = BG_WeaponDef(weapon, v14)->handXModel;
    }
    else
    {
      ClConfigStrings = ClConfigStrings::GetClConfigStrings();
      v11 = ClConfigStrings->GetModelString(ClConfigStrings, ps->viewmodelIndex);
      v12 = v11;
      if ( (!v11 || !*v11) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13468, ASSERT_TYPE_ASSERT, "(handModelName && handModelName[0])", (const char *)&queryFormat, "handModelName && handModelName[0]") )
        __debugbreak();
      handXModel = R_RegisterModel(v12);
    }
    CG_Weapon_ChangeViewmodelDobj(localClientNum, ps, weapon, handXModel, 1, 1, 0, 1);
    if ( *(_QWORD *)v9 )
      CG_Gesture_ClearEmptyAnimNodes(*(DObj **)v9);
  }
}

/*
==============
CG_Weapons_PlayAdditiveViewModelAnims
==============
*/
void CG_Weapons_PlayAdditiveViewModelAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v8; 
  const dvar_t *v9; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 

  PlayAdditiveHipIdleAnim(localClientNum, ps, hand, weapon);
  v8 = DCONST_DVARBOOL_cg_viewmodelAdsAnims;
  if ( !DCONST_DVARBOOL_cg_viewmodelAdsAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdsAnims") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    PlayAdditiveADSAnim(localClientNum, ps, hand, weapon);
    PlayAdditiveSwimDragAnims(localClientNum, ps, hand, weapon);
    PlaySwimForwardAnims(localClientNum, ps, hand, weapon);
  }
  CG_GameInterface_PlayAdditiveADSCoverAnims(localClientNum, ps, hand, weapon);
  v9 = DCONST_DVARBOOL_cg_viewmodelAnimatedJumps;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedJumps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedJumps") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4281, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    PlayAdditiveJumpAnim(LocalClientGlobals, ps, hand, ViewModelHand->viewModelDObj);
    PlayAdditiveJumpLandAnim(LocalClientGlobals, ps, hand, ViewModelHand->viewModelDObj);
  }
  PlayAdditiveCrawlAnims(localClientNum, ps, hand, weapon);
  PlayAdditiveProneDropAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveWalkAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveJogAnim(localClientNum, ps, hand, weapon);
  PlayProtoMovementAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveFingerPoseAnims(localClientNum, ps, hand, weapon);
  PlayAdditiveMagazineBulletAnims(localClientNum, ps, hand, weapon);
  PlayAdditiveCosmeticLoopAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveEmptyAnim(localClientNum, ps, hand, weapon);
  PlayAdvancedSwayAnim(localClientNum, ps, hand, weapon);
}

/*
==============
CG_Weapons_PlayDemeanorOffsetAnims
==============
*/
void CG_Weapons_PlayDemeanorOffsetAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v7; 
  cg_t *LocalClientGlobals; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  double GoalWeight; 
  CgHandler *Handler; 
  bool v13; 
  int weaponState; 
  double v15; 
  float v16; 
  unsigned int CurrentSlot; 
  unsigned int v19; 
  LocalClientNum_t v20; 
  GestureSlotInfo *Info; 
  float v22; 
  float v23; 
  float v24; 
  double Weight; 
  float v26; 
  double v27; 
  CgHandler *v28; 
  double v29; 
  float v30; 
  double v31; 
  float v32; 
  __int64 goalTime; 
  __int64 rate; 
  bool v36; 
  bool v37; 

  v7 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v7 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v7, 2) )
    __debugbreak();
  viewModelDObj = LocalClientGlobals->m_weaponHand[v7].viewModelDObj;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8567, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8568, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(viewModelDObj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8571, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8572, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
    __debugbreak();
  GoalWeight = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x79u);
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_DEMEANOR_OFFSET_SAFE, (PlayerHandIndex)v7, Handler) )
  {
    v37 = BG_Gesture_FindSlotUsingBlendToLoop(ps) != 2;
    v36 = BG_Gesture_GetAvailableSlotCount(ps) == 0;
    v13 = BG_Demeanor_IsPlaying(ps) && BG_Demeanor_GetTargetState(ps) != DEMEANOR_STATE_RELAXED;
    weaponState = ps->weapState[v7].weaponState;
    if ( (v13 || v37) && weaponState != 9 )
    {
      v15 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xEu);
      v16 = *(float *)&v15;
      *(double *)&_XMM0 = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xEu);
      if ( v13 && v36 && !v37 )
      {
        __asm { vmaxss  xmm10, xmm0, xmm11 }
        CurrentSlot = BG_Demeanor_GetCurrentSlot(ps);
        v19 = CurrentSlot;
        if ( CurrentSlot >= 2 )
        {
          LODWORD(rate) = 2;
          LODWORD(goalTime) = CurrentSlot;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8609, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( 2 )", "slot doesn't index GESTURE_NUM_SLOTS\n\t%i not in [0, %i)", goalTime, rate) )
            __debugbreak();
        }
        v20 = localClientNum;
        Info = CG_Gesture_GetInfo(localClientNum, v19, (PlayerHandIndex)v7);
        if ( !Info && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8612, ASSERT_TYPE_ASSERT, "(info)", (const char *)&queryFormat, "info") )
          __debugbreak();
        v22 = FLOAT_1_0;
        v23 = 1.0 - Info->mainTreeWeight;
        I_fclamp(v23, 0.0, 1.0);
        v24 = v23;
      }
      else
      {
        Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x79u);
        v22 = FLOAT_1_0;
        v26 = *(float *)&Weight;
        v27 = I_fclamp(1.0 - v16, 0.0, 1.0);
        v20 = localClientNum;
        v24 = 1.0 - v16;
        *(float *)&_XMM10 = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)&v27 - v26) & _xmm) * 0.25;
        if ( weaponState == 2 )
          *(float *)&_XMM10 = (float)ps->weapState[v7].weaponTime * 0.001;
      }
      if ( (unsigned int)(ps->weapState[v7].weaponState - 34) <= 2 )
      {
        v28 = CgHandler::getHandler(v20);
        if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_OFFSET, (PlayerHandIndex)v7, v28) )
        {
          v29 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x62u);
          v30 = *(float *)&v29;
          if ( *(float *)&v29 != 0.0 )
          {
            v31 = I_fclamp(v22 - v24, 0.0, v22);
            XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, *(float *)&v31 * v30, 0.050000001, v22, (scr_string_t)0, 0, 0, LINEAR, NULL);
          }
        }
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x79u, v24, *(float *)&_XMM10, v22, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x7Au, v22, 0.0, v22, (scr_string_t)0, 0, 1, LINEAR, NULL);
    }
    else if ( *(float *)&GoalWeight > 0.0 )
    {
      v32 = FLOAT_0_050000001;
      if ( weaponState == 9 )
      {
        v32 = (float)ps->weapState[v7].weaponTime * 0.001;
      }
      else if ( BG_Demeanor_GetTargetState(ps) == DEMEANOR_STATE_NORMAL )
      {
        v32 = *(float *)&GoalWeight * 0.25;
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x79u, 0.0, v32, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x7Au, 0.0, v32, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
  else if ( *(float *)&GoalWeight > 0.0 )
  {
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x79u, 0.0, 0.050000001, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x7Au, 0.0, 0.050000001, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
}

/*
==============
CG_Weapons_PlaySkydiveAnims
==============
*/
void CG_Weapons_PlaySkydiveAnims(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v9; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v11; 
  int oneHanded; 
  XAnimTree *tree; 
  double GoalWeight; 
  double v15; 
  float v16; 
  float WeaponAnimRate; 
  unsigned int v18; 
  float v19; 
  double v20; 
  float v21; 
  double Weight; 
  float v23; 
  double Time; 
  float v25; 
  double v26; 
  float v27; 
  double Float_Internal_DebugName; 
  double v29; 
  float v30; 
  float v31; 
  double v32; 
  float WeaponAnimTimeRemaining; 
  const dvar_t *v34; 
  float v35; 
  float v36; 
  double v37; 
  float AnxietyWeight; 
  double v39; 
  float v40; 
  double v41; 
  XAnimTree *v42; 
  double v43; 
  double v44; 
  double v45; 
  double v46; 
  double v47; 
  float v48; 
  double v49; 
  XAnimTree *v50; 
  double v51; 
  float v52; 
  double v53; 
  float v54; 
  double v55; 
  signed int animIndex_actual; 
  double v57; 
  double v58; 
  float v59; 
  float v60; 
  __int64 goalTime; 
  float animsa; 
  float anims; 
  float animsb; 
  float animsc; 
  float animsd; 
  XAnimTree *animTree; 
  XAnimTree *animTreea; 
  bool v69; 
  bool v70; 
  bool IsSuperDiveActive; 
  signed int animIndex_desiredTime; 
  XAnim_s *v73; 

  v4 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6446, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6447, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(goalTime) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6448, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v9 = CgWeaponMap::ms_instance[v4];
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v9, ps);
  v70 = BG_UsingAlternate(ps);
  v11 = v70;
  v69 = BG_PlayerDualWieldingWeapon(v9, ps, CurrentWeaponForPlayer) == 1;
  oneHanded = BG_PlayerDualWieldingWeapon(v9, ps, CurrentWeaponForPlayer);
  v73 = XAnimGetAnims(obj->tree);
  if ( !v73 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6474, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  switch ( ps->weapState[0].weaponState )
  {
    case '@':
      tree = obj->tree;
      if ( ps->weapState[0].weaponTime <= (int)(float)(BLEND_TO_FREEFALL_IDLE_TIME * 1000.0) )
      {
        GoalWeight = XAnimGetGoalWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0xF6u);
        if ( *(float *)&GoalWeight != 1.0 )
        {
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(LocalClientGlobals, ps, hand, obj, 1, (float)ps->weapState[0].weaponTime * 0.001);
          animsa = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v70, v69, v73, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, oneHanded);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF5u, 0.0, (float)ps->weapState[0].weaponTime * 0.001, animsa, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        break;
      }
      v15 = XAnimGetGoalWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0xF5u);
      v16 = FLOAT_1_0;
      if ( *(float *)&v15 == 1.0 )
        break;
      WeaponAnimRate = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v70, v69, v73, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, oneHanded);
      v18 = 245;
      anims = WeaponAnimRate;
      v19 = BLEND_TO_FREEFALL_RAISE_TIME;
      goto LABEL_79;
    case 'A':
      v20 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
      v21 = *(float *)&v20;
      Weight = XAnimGetWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
      v23 = *(float *)&Weight;
      Time = XAnimGetTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
      v25 = *(float *)&Time;
      v26 = XAnimGetWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x101u);
      IsSuperDiveActive = CG_Skydive_IsSuperDiveActive((const LocalClientNum_t)v4);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v11, v69, oneHanded, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v11, v69, oneHanded, WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v11, v69, oneHanded, WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v11, v69, oneHanded, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH);
      if ( !IsSuperDiveActive )
        goto LABEL_28;
      if ( *(float *)&v26 <= 0.0 && v21 != 1.0 )
      {
        v27 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, oneHanded);
        Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_cg_skydive_super_dive_in_blend_in_time, "cg_skydive_super_dive_in_blend_in_time");
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, 1.0, *(float *)&Float_Internal_DebugName, v27, (scr_string_t)0, 1u, 0, LINEAR, NULL);
        v29 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_cg_skydive_super_dive_in_blend_in_time, "cg_skydive_super_dive_in_blend_in_time");
        CG_Weapons_PlaySkydiveAnims_FreefallIdle(LocalClientGlobals, ps, hand, obj, 0, *(const float *)&v29);
        break;
      }
      if ( IsSuperDiveActive )
        goto LABEL_32;
LABEL_28:
      if ( *(float *)&v26 == 0.0 && v23 == 1.0 && v25 == 1.0 )
      {
        v30 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, oneHanded);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, 0.0, 0.0, v30, (scr_string_t)0, 0, 0, LINEAR, NULL);
        v31 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, oneHanded);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, 1.0, 0.0, v31, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      }
      else
      {
LABEL_32:
        animTree = obj->tree;
        v32 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x101u);
        if ( *(float *)&v32 == 0.0 )
          goto LABEL_85;
        WeaponAnimTimeRemaining = CG_GetWeaponAnimTimeRemaining(animTree, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
        v34 = DCONST_DVARFLT_cg_skydive_super_dive_out_blend_out_time;
        animTreea = (XAnimTree *)DCONST_DVARFLT_cg_skydive_super_dive_out_blend_out_time;
        if ( !DCONST_DVARFLT_cg_skydive_super_dive_out_blend_out_time )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_super_dive_out_blend_out_time") )
            __debugbreak();
          v34 = (const dvar_t *)animTreea;
        }
        Dvar_CheckFrontendServerThread(v34);
        if ( WeaponAnimTimeRemaining > *(float *)&animTreea->parameterValues )
        {
LABEL_85:
          if ( IsSuperDiveActive || (v37 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xF6u), *(float *)&v37 == 1.0) )
          {
            AnxietyWeight = CG_Weapons_GetAnxietyWeight(LocalClientGlobals, ps, obj->tree, 1.0);
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCDu, AnxietyWeight, BLEND_TO_FREEFALL_RAISE_TIME, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
            v39 = XAnimGetWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC6u);
            v40 = *(float *)&v39;
            if ( *(float *)&v39 > 0.0 )
            {
              v41 = XAnimGetGoalTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC6u);
              XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCCu, v40 * LocalClientGlobals->skydiveClientState.animState.velAnimWeight, *(float *)&v41, LocalClientGlobals->skydiveClientState.animState.velAnimPlayRate, (scr_string_t)0, 0, 0, LINEAR, NULL);
            }
          }
          else
          {
            CG_Weapons_PlaySkydiveAnims_FreefallIdle(LocalClientGlobals, ps, hand, obj, 1, BLEND_TO_FREEFALL_IDLE_UNEXPECTED);
          }
        }
        else
        {
          v35 = CG_GetWeaponAnimTimeRemaining(obj->tree, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
          if ( v35 < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6544, ASSERT_TYPE_ASSERT, "(timeRemaining >= 0.0f)", (const char *)&queryFormat, "timeRemaining >= 0.0f") )
            __debugbreak();
          v36 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, oneHanded);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, 0.0, v35, v36, (scr_string_t)0, 0, 0, LINEAR, NULL);
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(LocalClientGlobals, ps, hand, obj, 1, v35);
        }
      }
      break;
    case 'B':
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
      animIndex_desiredTime = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x34u) + 248;
      v42 = obj->tree;
      if ( ps->weapState[0].weaponTime > (int)(float)(BLEND_TO_PARACHUTE_IDLE_TIME * 1000.0) )
      {
        v44 = XAnimGetGoalWeight(v42, 0, XANIM_SUBTREE_DEFAULT, 0xF6u);
        if ( *(float *)&v44 != 0.0 )
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(LocalClientGlobals, ps, hand, obj, 0, BLEND_OUT_FREEFALL_IDLE_TIME);
        v45 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
        if ( *(float *)&v45 != 0.0 )
        {
          animsc = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, oneHanded);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, 0.0, BLEND_OUT_FREEFALL_IDLE_TIME, animsc, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        v46 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x101u);
        if ( *(float *)&v46 != 0.0 )
        {
          animsd = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, oneHanded);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, 0.0, BLEND_OUT_FREEFALL_IDLE_TIME, animsd, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        v47 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, animIndex_desiredTime);
        v16 = FLOAT_1_0;
        if ( *(float *)&v47 != 1.0 )
        {
          v48 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, (weapAnimFiles_t)animIndex_desiredTime, (weapAnimFiles_t)animIndex_desiredTime, oneHanded);
          v18 = animIndex_desiredTime;
          anims = v48;
          v19 = BLEND_OUT_FREEFALL_IDLE_TIME;
          goto LABEL_79;
        }
      }
      else
      {
        v43 = XAnimGetGoalWeight(v42, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
        if ( *(float *)&v43 != 1.0 )
        {
          CG_Weapons_PlaySkydiveAnims_ParachuteIdle(LocalClientGlobals, ps, hand, obj, 1, (float)ps->weapState[0].weaponTime * 0.001);
          animsb = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v11, v69, v73, (weapAnimFiles_t)animIndex_desiredTime, (weapAnimFiles_t)animIndex_desiredTime, oneHanded);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, animIndex_desiredTime, 0.0, (float)ps->weapState[0].weaponTime * 0.001, animsb, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      break;
    case 'C':
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v4, ps, hand, obj, CurrentWeaponForPlayer, v70, v69, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
      CG_Weapons_PlaySkydiveAnims_ParachuteIdle(LocalClientGlobals, ps, hand, obj, 1, (float)ps->weapState[0].weaponTime * 0.001);
      break;
    case 'D':
      animIndex_actual = 251;
      goto LABEL_75;
    case 'E':
      animIndex_actual = 252;
      goto LABEL_75;
    case 'F':
      animIndex_actual = 253;
      goto LABEL_75;
    case 'G':
      animIndex_actual = 254;
      goto LABEL_75;
    case 'H':
      animIndex_actual = 255;
LABEL_75:
      v57 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
      if ( *(float *)&v57 != 0.0 )
        CG_Weapons_PlaySkydiveAnims_ParachuteIdle(LocalClientGlobals, ps, hand, obj, 0, BLEND_OUT_PARACHUTE_IDLE_TIME);
      v58 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, animIndex_actual);
      v16 = FLOAT_1_0;
      if ( *(float *)&v58 == 1.0 )
        break;
      v59 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v70, v69, v73, (weapAnimFiles_t)animIndex_actual, (weapAnimFiles_t)animIndex_actual, oneHanded);
      v18 = animIndex_actual;
      anims = v59;
      v19 = BLEND_OUT_PARACHUTE_IDLE_TIME;
      goto LABEL_79;
    case 'J':
      v49 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
      if ( *(float *)&v49 != 0.0 )
        CG_Weapons_PlaySkydiveAnims_ParachuteIdle(LocalClientGlobals, ps, hand, obj, 0, BLEND_OUT_PARACHUTE_IDLE_TIME);
      if ( (ps->skydivePlayerState.flagsExtra[0] & 0x10) != 0 )
        goto LABEL_68;
      v50 = obj->tree;
      if ( ps->weapState[0].weaponTime > (int)(float)(BLEND_TO_FREEFALL_IDLE_CUT_TIME * 1000.0) )
      {
        v53 = XAnimGetGoalWeight(v50, 0, XANIM_SUBTREE_DEFAULT, 0x102u);
        v16 = FLOAT_1_0;
        if ( *(float *)&v53 != 1.0 )
        {
          v54 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v70, v69, v73, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, oneHanded);
          v18 = 258;
          anims = v54;
          v19 = BLEND_TO_FREEFALL_RAISE_TIME;
LABEL_79:
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v18, v16, v19, anims, (scr_string_t)0, 1u, 0, LINEAR, NULL);
        }
      }
      else
      {
        v51 = XAnimGetGoalWeight(v50, 0, XANIM_SUBTREE_DEFAULT, 0xF6u);
        if ( *(float *)&v51 != 1.0 )
        {
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(LocalClientGlobals, ps, hand, obj, 1, (float)ps->weapState[0].weaponTime * 0.001);
          v52 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v4, ps, hand, CurrentWeaponForPlayer, v70, v69, v73, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, oneHanded);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x102u, 0.0, (float)ps->weapState[0].weaponTime * 0.001, v52, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      break;
    case 'K':
      v55 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
      if ( *(float *)&v55 != 0.0 )
        CG_Weapons_PlaySkydiveAnims_ParachuteIdle(LocalClientGlobals, ps, hand, obj, 0, BLEND_OUT_PARACHUTE_IDLE_TIME);
LABEL_68:
      CG_Weapons_PlaySkydiveAnims_WeaponRaiseDetach((const LocalClientNum_t)v4, LocalClientGlobals, ps, hand, obj, BLEND_TO_WEAPON_RAISE_TIME, WEAP_ANIM_SKYDIVE_PARACHUTE_MID_AIR_DETACH);
      break;
    default:
      CG_Weapons_ResetSkydiveAnimationParameters((const LocalClientNum_t)v4, ps, obj);
      CG_Weapons_ResetSkydiveAnimationParameters((const LocalClientNum_t)v4, ps, obj);
      if ( !LocalClientGlobals->skydiveClientState.animState.blendedOutOfSkydiveAnims )
      {
        v60 = BLEND_OUT_ALL_TIME;
        LocalClientGlobals->skydiveClientState.animState.blendedOutOfSkydiveAnims = 1;
        CG_Weapons_PlaySkydiveAnims_BlendOutAll(LocalClientGlobals, ps, hand, obj, v60);
      }
      return;
  }
  LocalClientGlobals->skydiveClientState.animState.blendedOutOfSkydiveAnims = 0;
  CG_Weapons_SetSkydiveAnimationParameters((const LocalClientNum_t)LocalClientGlobals->localClientNum, ps, obj);
}

/*
==============
CG_Weapons_PlaySkydiveAnims_BlendOutAll
==============
*/
void CG_Weapons_PlaySkydiveAnims_BlendOutAll(const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const float goalTime)
{
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF5u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF6u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF7u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF8u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF9u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFAu, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFBu, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFCu, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFDu, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFEu, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFFu, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x102u, 0.0, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC5u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC6u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC8u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCEu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC9u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD2u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCAu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD6u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCBu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xDAu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCCu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCDu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC7u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE1u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE7u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE2u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE8u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE3u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE9u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE4u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEAu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE6u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE5u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEBu, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
CG_Weapons_PlaySkydiveAnims_FreefallIdle
==============
*/
void CG_Weapons_PlaySkydiveAnims_FreefallIdle(const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const bool blendIn, const float goalTime)
{
  double GoalWeight; 
  float v14; 
  float value; 
  float v16; 
  float v17; 
  float AnxietyWeight; 
  const dvar_t *v19; 
  const dvar_t *v20; 
  const dvar_t *v21; 
  const dvar_t *v22; 
  const dvar_t *v23; 
  const dvar_t *v24; 

  _XMM7 = LODWORD(FLOAT_1_0);
  _XMM0 = blendIn;
  __asm
  {
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm6, xmm7, xmm9, xmm2
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC6u, *(float *)&_XMM6, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  if ( blendIn )
  {
    GoalWeight = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC5u);
    if ( *(float *)&GoalWeight != 1.0 )
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC5u, 1.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF6u, *(float *)&_XMM6, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF7u, *(float *)&_XMM6, goalTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  v14 = *(float *)&_XMM6 * cgameGlob->skydiveClientState.animState.velAnimWeight;
  value = *(float *)&_XMM6;
  v16 = *(float *)&_XMM6;
  v17 = *(float *)&_XMM6;
  AnxietyWeight = CG_Weapons_GetAnxietyWeight(cgameGlob, ps, obj->tree, *(const float *)&_XMM6);
  v19 = DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides;
  if ( !DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_enable_debugAnimOverrides") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v19);
  if ( v19->current.enabled )
  {
    v20 = DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_throttleAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v20);
    LODWORD(_XMM6) = v20->current.integer;
    v21 = DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_strafeAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v21);
    value = v21->current.value;
    v22 = DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_yawAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v22);
    v16 = v22->current.value;
    v23 = DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_pitchAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v23);
    v17 = v23->current.value;
    v24 = DCONST_DVARFLT_cg_skydive_debug_velAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v24);
    v14 = v24->current.value;
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC8u, *(float *)&_XMM6, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCEu, *(float *)&_XMM6, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC9u, value, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD2u, value, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCAu, v16, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD6u, v16, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCBu, v17, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xDAu, v17, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCCu, v14, goalTime, cgameGlob->skydiveClientState.animState.velAnimPlayRate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCDu, AnxietyWeight, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
CG_Weapons_PlaySkydiveAnims_ParachuteIdle
==============
*/
void CG_Weapons_PlaySkydiveAnims_ParachuteIdle(const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const bool blendIn, const float goalTime)
{
  double GoalWeight; 
  const dvar_t *v13; 
  float v14; 
  float value; 
  float v16; 
  float v17; 
  float v18; 
  const dvar_t *v19; 
  const dvar_t *v20; 
  const dvar_t *v21; 
  const dvar_t *v22; 
  const dvar_t *v23; 
  const dvar_t *v24; 

  _XMM7 = LODWORD(FLOAT_1_0);
  _XMM0 = blendIn;
  __asm
  {
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm6, xmm7, xmm9, xmm2
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC7u, *(float *)&_XMM6, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  if ( blendIn )
  {
    GoalWeight = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC5u);
    if ( *(float *)&GoalWeight != 1.0 )
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC5u, 1.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFAu, *(float *)&_XMM6, goalTime, 0.0, (scr_string_t)0, blendIn, 0, LINEAR, NULL);
  v13 = DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides;
  v14 = *(float *)&_XMM6 * cgameGlob->skydiveClientState.animState.velAnimWeight;
  value = *(float *)&_XMM6;
  v16 = *(float *)&_XMM6;
  v17 = *(float *)&_XMM6;
  v18 = *(float *)&_XMM6;
  if ( !DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_enable_debugAnimOverrides") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v13);
  if ( v13->current.enabled )
  {
    v19 = DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_throttleAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v19);
    LODWORD(_XMM6) = v19->current.integer;
    v20 = DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_strafeAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v20);
    value = v20->current.value;
    v21 = DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_yawAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v21);
    v16 = v21->current.value;
    v22 = DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_pitchAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v22);
    v17 = v22->current.value;
    v23 = DCONST_DVARFLT_cg_skydive_debug_velAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v23);
    v14 = v23->current.value;
    v24 = DCONST_DVARFLT_cg_skydive_debug_lookAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_lookAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_lookAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v24);
    v18 = v24->current.value;
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE1u, *(float *)&_XMM6, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE7u, *(float *)&_XMM6, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE2u, value, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE8u, value, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE3u, v16, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE9u, v16, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE4u, v17, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEAu, v17, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE6u, v14, goalTime, cgameGlob->skydiveClientState.animState.velAnimPlayRate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE5u, v18, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEBu, v18, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
CG_Weapons_PlaySkydiveAnims_WeaponRaiseDetach
==============
*/
void CG_Weapons_PlaySkydiveAnims_WeaponRaiseDetach(const LocalClientNum_t localClientNum, cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const float goalTime, const weapAnimFiles_t anim)
{
  __int64 v7; 
  CgWeaponMap *v10; 
  const Weapon *CurrentWeaponForPlayer; 
  XAnim_s *v12; 
  int weaponTime; 
  double GoalWeight; 
  double v15; 
  float WeaponAnimRate; 
  CgSoundSystem *SoundSystem; 
  float anims; 
  int oneHanded; 
  bool isDualWielding; 
  bool v21; 

  v7 = localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v10 = CgWeaponMap::ms_instance[v7];
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v10, ps);
  v21 = BG_UsingAlternate(ps);
  isDualWielding = BG_PlayerDualWieldingWeapon(v10, ps, CurrentWeaponForPlayer) == 1;
  oneHanded = BG_PlayerDualWieldingWeapon(v10, ps, CurrentWeaponForPlayer);
  v12 = XAnimGetAnims(obj->tree);
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6339, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  weaponTime = ps->weapState[0].weaponTime;
  GoalWeight = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, anim);
  if ( weaponTime >= (int)(float)(goalTime * 1000.0) )
  {
    if ( *(float *)&GoalWeight == 0.0 )
    {
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFBu, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFCu, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFDu, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFEu, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    v15 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, anim);
    if ( *(float *)&v15 < 1.0 )
    {
      WeaponAnimRate = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v7, ps, hand, CurrentWeaponForPlayer, v21, isDualWielding, v12, anim, anim, oneHanded);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, anim, 1.0, goalTime, WeaponAnimRate, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)v7);
      CgSoundSystem::PlayClientSoundAlias(SoundSystem, cgMedia.skydiveParachuteDetach);
    }
  }
  else if ( *(float *)&GoalWeight > 0.0 )
  {
    anims = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v7, ps, hand, CurrentWeaponForPlayer, v21, isDualWielding, v12, anim, anim, oneHanded);
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, anim, 0.0049999999, goalTime, anims, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
}

/*
==============
CG_Weapons_PlayerWeaponSlotHasWeaponsWithAmmo
==============
*/
char CG_Weapons_PlayerWeaponSlotHasWeaponsWithAmmo(const LocalClientNum_t localClientNum, const playerState_s *ps, const WeaponSlot slot)
{
  unsigned __int16 v3; 
  __int64 v4; 
  bool v7; 
  BgWeaponMap **v8; 
  BgWeaponMap *v9; 
  int v10; 
  int EquippedWeaponIndex; 
  __int64 p_slot; 
  unsigned __int16 weaponIdx; 
  WeaponDef **v14; 
  __int64 v16; 
  __int64 v17; 
  Weapon r_weapon; 

  v4 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16410, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v7 = CgWeaponMap::ms_instance[v4] == NULL;
  v8 = &CgWeaponMap::ms_instance[v4];
  if ( v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v9 = *v8;
  v10 = 0;
  while ( 1 )
  {
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    r_weapon = *BgWeaponMap::GetWeapon(v9, ps->weaponsEquipped[v10]);
    r_weapon.weaponIdx = v3;
    if ( v3 )
    {
      if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1089, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1090, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( r_weapon.weaponIdx && (EquippedWeaponIndex = BG_GetEquippedWeaponIndex(v9, ps, &r_weapon), EquippedWeaponIndex >= 0) )
        p_slot = (__int64)&ps->weapEquippedData[EquippedWeaponIndex].slot;
      else
        p_slot = 12i64;
      weaponIdx = r_weapon.weaponIdx;
      if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v17) = bg_lastParsedWeaponIndex;
        LODWORD(v16) = r_weapon.weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v16, v17) )
          __debugbreak();
      }
      v7 = bg_weaponDefs[weaponIdx] == NULL;
      v14 = &bg_weaponDefs[weaponIdx];
      if ( v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      if ( (*v14)->inventoryType == WEAPINVENTORY_PRIMARY && *(_DWORD *)p_slot == slot && BG_WeaponAmmo(v9, ps, &r_weapon, 0) )
        break;
    }
    if ( (unsigned int)++v10 >= 0xF )
      return 0;
  }
  return 1;
}

/*
==============
CG_Weapons_PrecacheMedia
==============
*/
void CG_Weapons_PrecacheMedia(void)
{
  unsigned int v0; 
  unsigned __int16 weaponIdx; 
  unsigned int NumWeapons; 
  __int64 v3; 
  WeaponCompleteDef *v4; 
  bool v5; 
  WeaponDef **v6; 
  WeaponDef *v7; 
  GfxImage *v8; 
  GfxImage *v9; 
  unsigned __int16 v10; 
  Material **v11; 
  unsigned int v12; 
  DB_AssetEntryFlags *p_m_headEntries; 
  DB_AssetEntryPool *AssetEntryPool; 
  unsigned int v15; 
  unsigned int assetCount; 
  char *v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  GetAllXAssetFunctor functor; 
  Weapon r_weapon; 
  char v23[24896]; 

  v0 = 0;
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  weaponIdx = 0;
  NumWeapons = BG_GetNumWeapons();
  memset(&r_weapon, 0, 48);
  r_weapon.weaponIdx = 0;
  *(double *)&r_weapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
  if ( NumWeapons )
  {
    do
    {
      v3 = weaponIdx;
      if ( weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v20) = bg_lastParsedWeaponIndex;
        LODWORD(v19) = weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v19, v20) )
          __debugbreak();
        weaponIdx = r_weapon.weaponIdx;
      }
      if ( !bg_weaponCompleteDefs[v3] )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
          __debugbreak();
        weaponIdx = r_weapon.weaponIdx;
      }
      v4 = bg_weaponCompleteDefs[v3];
      if ( weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v20) = bg_lastParsedWeaponIndex;
        LODWORD(v19) = weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v19, v20) )
          __debugbreak();
      }
      v5 = bg_weaponDefs[weaponIdx] == NULL;
      v6 = &bg_weaponDefs[weaponIdx];
      if ( v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      v7 = *v6;
      v8 = BG_HudIcon(&r_weapon, 0);
      v9 = BG_PickUpIcon(&r_weapon, 0);
      v10 = r_weapon.weaponIdx;
      v11 = &cgMedia.objectiveMaterials[r_weapon.weaponIdx - 552];
      if ( v9 )
      {
        *v11 = (Material *)v9;
      }
      else if ( v8 )
      {
        *v11 = (Material *)v8;
      }
      else
      {
        *v11 = NULL;
      }
      if ( v10 && !*v11 && v7->inventoryType == WEAPINVENTORY_PRIMARY && v7->weapClass <= WEAPCLASS_ROCKETLAUNCHER )
      {
        Com_PrintWarning(17, "Weapon '%s' has no hint icon\n", v4->szInternalName);
        v10 = r_weapon.weaponIdx;
      }
      weaponIdx = v10 + 1;
      r_weapon.weaponIdx = weaponIdx;
    }
    while ( weaponIdx < NumWeapons );
  }
  functor.type = ASSET_TYPE_ATTACHMENT;
  functor.assets = (XAssetHeader *)v23;
  functor.assetCount = 0;
  functor.maxCount = 3112;
  DB_LockHashRead();
  v12 = 0;
  p_m_headEntries = &s_assetManager.table.m_headEntries;
  AssetEntryPool = DB_GetAssetEntryPool();
  v15 = 0;
  do
  {
    DB_AssetEntryPool::MutableForEachInBlock<GetAllXAssetFunctor>(AssetEntryPool, &s_assetManager.table.m_headEntries, p_m_headEntries->m_flags.m_data[0], v15, &functor);
    v15 += 64;
    ++v12;
    p_m_headEntries = (DB_AssetEntryFlags *)((char *)p_m_headEntries + 8);
  }
  while ( v12 < 0x1768 );
  DB_UnlockHashRead();
  assetCount = functor.assetCount;
  if ( functor.assetCount )
  {
    v17 = v23;
    do
    {
      v18 = *(_QWORD *)v17;
      v17 += 8;
      *(_DWORD *)(v18 + 896) = v0++;
    }
    while ( v0 < assetCount );
  }
}

/*
==============
CG_Weapons_PrintWeaponShootingAngles
==============
*/
void CG_Weapons_PrintWeaponShootingAngles(const cg_t *const cgameGlob, const vec3_t *baseGunAngles, const vec3_t *localGunAngles, const vec3_t *resultGunAngles)
{
  const dvar_t *v4; 
  unsigned int commandTime; 
  CgWeaponMap *Instance; 
  double v11; 
  unsigned int v12; 
  WeaponMovementState *p_weapMoveState; 
  unsigned int v14; 
  __int64 v15; 
  __int64 weaponIdx_low; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  int v21; 
  ViewMovementState *p_viewMoveState; 
  __int64 v23; 
  __int64 fLastIdleFactor_low; 
  unsigned int v25; 
  unsigned int v26; 
  unsigned int v27; 
  int v28; 
  int v29; 
  int v30; 
  char *fmt; 

  v4 = DVARINT_bg_shootingAnglesLog;
  if ( !DVARINT_bg_shootingAnglesLog && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_shootingAnglesLog") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.integer == 1 )
  {
    commandTime = cgameGlob->predictedPlayerState.commandTime;
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    v11 = BG_WeaponADSFractionAffectedByReload(Instance, &cgameGlob->predictedPlayerState);
    v12 = -1;
    p_weapMoveState = &cgameGlob->predictedViewState.weapMoveState;
    v14 = -1;
    v15 = 376i64;
    do
    {
      weaponIdx_low = LOBYTE(p_weapMoveState->weapon.weaponIdx);
      p_weapMoveState = (WeaponMovementState *)((char *)p_weapMoveState + 5);
      v17 = (v14 >> 8) ^ g_crc32Table[weaponIdx_low ^ (unsigned __int8)v14];
      v18 = (v17 >> 8) ^ g_crc32Table[p_weapMoveState[-1].recoilNeedsToCrossCenter ^ (unsigned __int64)(unsigned __int8)v17];
      v19 = (v18 >> 8) ^ g_crc32Table[*((unsigned __int8 *)&p_weapMoveState[-1].recoilNeedsToCrossCenter + 1) ^ (unsigned __int64)(unsigned __int8)v18];
      v20 = (v19 >> 8) ^ g_crc32Table[*((unsigned __int8 *)&p_weapMoveState[-1].recoilNeedsToCrossCenter + 2) ^ (unsigned __int64)(unsigned __int8)v19];
      v14 = (v20 >> 8) ^ g_crc32Table[*((unsigned __int8 *)&p_weapMoveState[-1].recoilNeedsToCrossCenter + 3) ^ (unsigned __int64)(unsigned __int8)v20];
      --v15;
    }
    while ( v15 );
    v21 = ~v14;
    p_viewMoveState = &cgameGlob->predictedViewState.viewMoveState;
    v23 = 418i64;
    do
    {
      fLastIdleFactor_low = LOBYTE(p_viewMoveState->fLastIdleFactor);
      p_viewMoveState = (ViewMovementState *)((char *)p_viewMoveState + 4);
      v25 = (v12 >> 8) ^ g_crc32Table[fLastIdleFactor_low ^ (unsigned __int8)v12];
      v26 = (v25 >> 8) ^ g_crc32Table[BYTE1(p_viewMoveState[-1].idleMotionCache.idleMotion2Spline.lastEvN) ^ (unsigned __int64)(unsigned __int8)v25];
      v27 = (v26 >> 8) ^ g_crc32Table[BYTE2(p_viewMoveState[-1].idleMotionCache.idleMotion2Spline.lastEvN) ^ (unsigned __int64)(unsigned __int8)v26];
      v12 = (v27 >> 8) ^ g_crc32Table[HIBYTE(p_viewMoveState[-1].idleMotionCache.idleMotion2Spline.lastEvN) ^ (unsigned __int64)(unsigned __int8)v27];
      --v23;
    }
    while ( v23 );
    v28 = cgameGlob->savedPlayerState.commandTime;
    v29 = ~v12;
    if ( v28 )
      v30 = cgameGlob->predictedPlayerState.commandTime - v28;
    else
      v30 = 0;
    LODWORD(fmt) = v30;
    Com_Printf(17, "C->  Time:%d  CmdTime:%d  EX:%d  CA:[%f %f %f]  WA:[%f %f %f]  SA:[%f %f %f]  VA:[%f %f %f]  DA:[%f %f %f]  VMA:[%f %f %f]  VI:%f  WI:%f  VS:%d  WS:%d  IT1:%d  IT2:%d  ADST:%d  ADS:%f  ADSr:%f\n", (unsigned int)cgameGlob->time, commandTime, fmt, baseGunAngles->v[0], baseGunAngles->v[1], baseGunAngles->v[2], resultGunAngles->v[0], resultGunAngles->v[1], resultGunAngles->v[2], localGunAngles->v[0], localGunAngles->v[1], localGunAngles->v[2], cgameGlob->predictedPlayerState.viewangles.v[0], cgameGlob->predictedPlayerState.viewangles.v[1], cgameGlob->predictedPlayerState.viewangles.v[2], cgameGlob->predictedPlayerState.delta_angles.v[0], cgameGlob->predictedPlayerState.delta_angles.v[1], cgameGlob->predictedPlayerState.delta_angles.v[2], cgameGlob->playerViewValues.viewMoveAngles.v[0], cgameGlob->playerViewValues.viewMoveAngles.v[1], cgameGlob->playerViewValues.viewMoveAngles.v[2], cgameGlob->predictedViewState.viewMoveState.fLastIdleFactor, cgameGlob->predictedViewState.weapMoveState.fLastIdleFactor, v29, v21, cgameGlob->predictedPlayerState.weapCommon.weaponIdleTime, cgameGlob->predictedPlayerState.weapCommon.weaponIdleTime2, cgameGlob->predictedPlayerState.weapCommon.adsStartTime, cgameGlob->predictedPlayerState.weapCommon.fWeaponPosFrac, *(float *)&v11);
  }
}

/*
==============
CG_Weapons_ProcessWeaponNoteTracks
==============
*/
void CG_Weapons_ProcessWeaponNoteTracks(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState, DObj *dObj, const PlayerHandIndex hand, const XAnimNotifyHandle dobjNotifyHandle)
{
  __int16 v5; 
  __int64 v6; 
  WeaponDef *v9; 
  XAnimNotify *v10; 
  const char *v11; 
  const char *v12; 
  __int64 v13; 
  int v14; 
  __int64 v15; 
  int v16; 
  int v17; 
  int v18; 
  const dvar_t *v19; 
  const playerState_s *v20; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *p_weapFlags; 
  bool v22; 
  const SuitDef *SuitDef; 
  __int64 weaponIdx; 
  WeaponCompleteDef *v25; 
  __int64 v26; 
  __int64 numNotetrackSuitEntries; 
  NoteTrackToSuitSoundEntry *notetrackSuitEntries; 
  const scr_string_t *notetrackSoundMapKeys; 
  __int64 v30; 
  WeaponCompleteDef *v31; 
  scr_string_t *v32; 
  scr_string_t *notetrackSoundMapValues; 
  unsigned int numNotetrackSoundMappings; 
  scr_string_t LowercaseString; 
  __int64 i; 
  scr_string_t v37; 
  scr_string_t v38; 
  const char *v39; 
  const playerState_s *v40; 
  bool v41; 
  scr_string_t v42; 
  scr_string_t v43; 
  FxCombinedDef v44; 
  FxCombinedDef *notetrackFXMapValues; 
  char *notetrackFXMapTagValues; 
  char *notetrackFXMapKeys; 
  scr_string_t v48; 
  int v49; 
  signed __int64 v50; 
  int v51; 
  scr_string_t v52; 
  int clientNum; 
  const char *v54; 
  int v55; 
  char *j; 
  char v57; 
  char *k; 
  char v59; 
  __int64 isViewmodel; 
  __int64 isMayhem; 
  unsigned int isMayhema; 
  unsigned int numMappings; 
  scr_string_t searchedNoteName[2]; 
  int entNum; 
  const playerState_s *v66; 
  scr_string_t *values; 
  scr_string_t *keys; 
  XAnimNotify *notify; 
  cg_t *LocalClientGlobals; 
  DObj *dObja; 
  WeaponDef *v72; 
  Weapon r_weapon; 
  char s0; 
  char note; 

  v6 = localClientNum;
  dObja = dObj;
  v66 = predictedPlayerState;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  r_weapon = *BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v6], predictedPlayerState);
  if ( v5 )
  {
    if ( r_weapon.weaponIdx >= BG_GetNumWeapons() )
    {
      isMayhema = BG_GetNumWeapons();
      LODWORD(isViewmodel) = r_weapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13407, ASSERT_TYPE_ASSERT, "(unsigned)( weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", isViewmodel, isMayhema) )
        __debugbreak();
    }
    BG_UsingAlternate(predictedPlayerState);
    if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
    {
      LODWORD(isMayhem) = bg_lastParsedWeaponIndex;
      LODWORD(isViewmodel) = r_weapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", isViewmodel, isMayhem) )
        __debugbreak();
    }
    if ( !bg_weaponDefs[r_weapon.weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    v9 = bg_weaponDefs[r_weapon.weaponIdx];
    v72 = v9;
    entNum = hand + 2048;
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
    notify = (XAnimNotify *)DObjGetClientNotifyFirst(dobjNotifyHandle);
    v10 = notify;
    if ( notify )
    {
      v11 = "end";
      do
      {
        v12 = SL_ConvertToString(v10->noteName);
        v13 = 0x7FFFFFFFi64;
        if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        do
        {
          v14 = (unsigned __int8)v11[v12 - "end"];
          v15 = v13;
          v16 = *(unsigned __int8 *)v11++;
          --v13;
          if ( !v15 )
            break;
          if ( v14 != v16 )
          {
            v17 = v14 + 32;
            if ( (unsigned int)(v14 - 65) > 0x19 )
              v17 = v14;
            v14 = v17;
            v18 = v16 + 32;
            if ( (unsigned int)(v16 - 65) > 0x19 )
              v18 = v16;
            if ( v14 != v18 )
            {
              v19 = DVARBOOL_viewModelDebugNotetracks;
              if ( !DVARBOOL_viewModelDebugNotetracks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "viewModelDebugNotetracks") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v19);
              if ( v19->current.enabled )
                Com_Printf(14, "Viewmodel note at %.2f - \"%s\"\n", v10->timeFrac, v12);
              Sys_ProfBeginNamedEvent(0xFF44CCFF, "PlayNoteMappedSoundAliases");
              v20 = v66;
              p_weapFlags = &v66->weapCommon.weapFlags;
              v22 = v66 && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v66->weapCommon.weapFlags, ACTIVE, 0x22u) && v20 && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x11u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x1Bu));
              searchedNoteName[0] = SL_FindLowercaseString(v12);
              if ( searchedNoteName[0] )
              {
                numMappings = 0;
                if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12539, ASSERT_TYPE_ASSERT, "(predictedPlayerState)", (const char *)&queryFormat, "predictedPlayerState") )
                  __debugbreak();
                SuitDef = BG_GetSuitDef(v20->suitIndex);
                if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12543, ASSERT_TYPE_ASSERT, "(suit)", (const char *)&queryFormat, "suit") )
                  __debugbreak();
                weaponIdx = r_weapon.weaponIdx;
                if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
                {
                  LODWORD(isMayhem) = bg_lastParsedWeaponIndex;
                  LODWORD(isViewmodel) = r_weapon.weaponIdx;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", isViewmodel, isMayhem) )
                    __debugbreak();
                }
                if ( !bg_weaponCompleteDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
                  __debugbreak();
                v25 = bg_weaponCompleteDefs[weaponIdx];
                v26 = 0i64;
                numNotetrackSuitEntries = (int)v25->numNotetrackSuitEntries;
                if ( (int)numNotetrackSuitEntries > 0 )
                {
                  notetrackSuitEntries = v25->notetrackSuitEntries;
                  while ( notetrackSuitEntries->suitAnimState != SuitDef->suitAnimType )
                  {
                    ++v26;
                    ++notetrackSuitEntries;
                    if ( v26 >= numNotetrackSuitEntries )
                      goto LABEL_61;
                  }
                  if ( notetrackSuitEntries->numSoundMappings )
                  {
                    notetrackSoundMapKeys = notetrackSuitEntries->notetrackSoundMapKeys;
                    if ( *notetrackSoundMapKeys )
                      PlayMappedSoundAlias((LocalClientNum_t)v6, notetrackSuitEntries->numSoundMappings, notetrackSoundMapKeys, notetrackSuitEntries->notetrackSoundMapValues, searchedNoteName);
                  }
                }
LABEL_61:
                if ( BG_GetNotetrackOverrides(&r_weapon, v22, &numMappings, (const scr_string_t **)&keys, (const scr_string_t **)&values) )
                {
                  numNotetrackSoundMappings = numMappings;
                  notetrackSoundMapValues = values;
                  v32 = keys;
                }
                else
                {
                  v30 = r_weapon.weaponIdx;
                  if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
                  {
                    LODWORD(isMayhem) = bg_lastParsedWeaponIndex;
                    LODWORD(isViewmodel) = r_weapon.weaponIdx;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", isViewmodel, isMayhem) )
                      __debugbreak();
                  }
                  if ( !bg_weaponCompleteDefs[v30] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
                    __debugbreak();
                  v31 = bg_weaponCompleteDefs[v30];
                  v32 = v31->notetrackSoundMapKeys;
                  keys = v32;
                  notetrackSoundMapValues = v31->notetrackSoundMapValues;
                  values = notetrackSoundMapValues;
                  numNotetrackSoundMappings = v31->numNotetrackSoundMappings;
                  numMappings = numNotetrackSoundMappings;
                }
                if ( numNotetrackSoundMappings && *v32 )
                  PlayMappedSoundAlias((LocalClientNum_t)v6, numNotetrackSoundMappings, v32, notetrackSoundMapValues, searchedNoteName);
              }
              Sys_ProfEndNamedEvent();
              if ( v9->weapClass == WEAPCLASS_TURRET )
              {
                if ( SL_FindLowercaseString(v12) )
                  CG_Rumble_PlayOnClientSafeByName((LocalClientNum_t)v6, v12);
              }
              else if ( *v9->notetrackRumbleMapKeys )
              {
                LowercaseString = SL_FindLowercaseString(v12);
                if ( LowercaseString )
                {
                  for ( i = 0i64; i < 16; ++i )
                  {
                    v37 = v9->notetrackRumbleMapKeys[i];
                    if ( !v37 )
                      break;
                    v38 = v9->notetrackRumbleMapValues[i];
                    if ( v38 )
                    {
                      if ( v37 == LowercaseString )
                      {
                        v39 = SL_ConvertToString(v38);
                        if ( v39 )
                          CG_Rumble_PlayOnClientSafeByName((LocalClientNum_t)v6, v39);
                      }
                    }
                  }
                }
              }
              v40 = v66;
              v41 = v66 && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x22u) && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x11u) || v40 && GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x1Bu));
              v42 = SL_FindLowercaseString(v12);
              v43 = v42;
              if ( v42 && (v42 == scr_const.mag_eject || v42 == scr_const.mag_eject_left) )
              {
                v44.particleSystemDef = BG_ViewMagEjectEffect(&r_weapon, v41).particleSystemDef;
                if ( v44.particleSystemDef )
                {
                  *(FxCombinedDef *)searchedNoteName = v44;
                  CG_PlayBoltedEffect((LocalClientNum_t)v6, (const FXRegisteredDef *)searchedNoteName, (v43 != scr_const.mag_eject) + 2048, scr_const.tag_clip);
                }
              }
              notetrackFXMapValues = v9->notetrackFXMapValues;
              notetrackFXMapTagValues = (char *)v9->notetrackFXMapTagValues;
              notetrackFXMapKeys = (char *)v9->notetrackFXMapKeys;
              *(_QWORD *)searchedNoteName = 0i64;
              if ( !notetrackFXMapKeys && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12653, ASSERT_TYPE_ASSERT, "(fxMapKeys)", (const char *)&queryFormat, "fxMapKeys") )
                __debugbreak();
              if ( !notetrackFXMapTagValues && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12654, ASSERT_TYPE_ASSERT, "(fxBoneNames)", (const char *)&queryFormat, "fxBoneNames") )
                __debugbreak();
              if ( !notetrackFXMapValues && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12655, ASSERT_TYPE_ASSERT, "(fxHandles)", (const char *)&queryFormat, "fxHandles") )
                __debugbreak();
              if ( *(_DWORD *)notetrackFXMapKeys )
              {
                v48 = SL_FindLowercaseString(v12);
                if ( v48 )
                {
                  v49 = 0;
                  v50 = notetrackFXMapKeys - notetrackFXMapTagValues;
                  do
                  {
                    v51 = *(_DWORD *)&notetrackFXMapTagValues[v50];
                    if ( !v51 )
                      break;
                    v52 = *(_DWORD *)notetrackFXMapTagValues;
                    if ( *(_DWORD *)notetrackFXMapTagValues && notetrackFXMapValues->particleSystemDef && v51 == v48 )
                    {
                      *(FxCombinedDef *)searchedNoteName = (FxCombinedDef)notetrackFXMapValues->particleSystemDef;
                      CG_PlayBoltedEffect((LocalClientNum_t)v6, (const FXRegisteredDef *)searchedNoteName, 2048, v52);
                    }
                    ++v49;
                    notetrackFXMapTagValues += 4;
                    ++notetrackFXMapValues;
                  }
                  while ( v49 < 16 );
                }
              }
              v10 = notify;
              CG_Utils_ProcessNotetracks((LocalClientNum_t)v6, entNum, dObja, &LocalClientGlobals->viewModelPose, notify, 1, 0, 0, 0, 1);
              s0 = 0;
              note = 0;
              clientNum = v66->clientNum;
              if ( ScriptableCl_IsScriptableEntityByNum((const LocalClientNum_t)v6, clientNum) )
              {
                v54 = SL_ConvertToString(v10->noteName);
                v55 = j_sscanf(v54, "%[^','],%s", &s0, &note);
                for ( j = &s0; ; ++j )
                {
                  v57 = *j;
                  if ( (unsigned __int8)*j < 9u || (unsigned __int8)v57 > 0x20u || !v57 )
                    break;
                }
                if ( v55 == 2 && !I_stricmp(j, "vm_scriptable") )
                {
                  for ( k = &note; ; ++k )
                  {
                    v59 = *k;
                    if ( (unsigned __int8)*k < 9u || (unsigned __int8)v59 > 0x20u )
                      break;
                    if ( !v59 )
                      goto LABEL_130;
                  }
                  if ( v59 )
                    ScriptableCl_AnimNotetrackEvent((const LocalClientNum_t)v6, clientNum, k);
                }
              }
LABEL_130:
              CG_Ladder_ProccessNotetracks((LocalClientNum_t)v6, v10->noteName);
              v9 = v72;
              break;
            }
          }
        }
        while ( v14 );
        notify = (XAnimNotify *)DObjGetClientNotifyNext(v10);
        v10 = notify;
        v11 = "end";
      }
      while ( notify );
    }
  }
}

/*
==============
CG_Weapons_RebuildWeaponsArray
==============
*/
void CG_Weapons_RebuildWeaponsArray(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v3; 
  CgWeaponMap *Instance; 
  CgHandler *Handler; 
  const Weapon *ViewmodelWeapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = LocalClientGlobals;
  if ( LocalClientGlobals->inKillCam )
  {
    Com_PrintWarning(1, "Unable to update weapon anim arrays for client %d due to MyChanges because the client is in KillCam", (unsigned int)LocalClientGlobals->predictedPlayerState.clientNum);
  }
  else
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    if ( Instance )
    {
      Handler = CgHandler::getHandler(localClientNum);
      PM_BuildWeaponAnimArrays(Instance, &v3->predictedPlayerState, Handler);
      ViewmodelWeapon = BG_GetViewmodelWeapon(Instance, &v3->predictedPlayerState);
      CG_CreateWeaponViewModelXAnimDefs(localClientNum, &v3->predictedPlayerState, ViewmodelWeapon, &v3->playerWeaponInfo);
      CG_Weapon_ChangeViewmodelDobj(localClientNum, &v3->predictedPlayerState, ViewmodelWeapon, v3->playerWeaponInfo.handModel, 0, 1, 0, 1);
    }
    else
    {
      Com_PrintWarning(1, "Unable to update weapon anim arrays for client %d due to WeaponMap not being initialized.", (unsigned int)v3->predictedPlayerState.clientNum);
    }
  }
}

/*
==============
CG_Weapons_ResetSkydiveAnimationParameters
==============
*/
void CG_Weapons_ResetSkydiveAnimationParameters(const LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  *(_QWORD *)&LocalClientGlobals->skydiveClientState.animState.throttle = 0i64;
  *(_QWORD *)&LocalClientGlobals->skydiveClientState.animState.yaw = 0i64;
  *(_QWORD *)&LocalClientGlobals->skydiveClientState.animState.normalizedSpeed = 0i64;
  *(_QWORD *)&LocalClientGlobals->skydiveClientState.animState.velAnimPlayRate = 0i64;
  XAnimSetFloatGameParameterByIndex(obj, 0x1Eu, 0.0);
  XAnimSetFloatGameParameterByIndex(obj, 0x1Fu, LocalClientGlobals->skydiveClientState.animState.strafe);
  XAnimSetFloatGameParameterByIndex(obj, 0x20u, LocalClientGlobals->skydiveClientState.animState.yaw);
  XAnimSetFloatGameParameterByIndex(obj, 0x21u, LocalClientGlobals->skydiveClientState.animState.pitch);
  XAnimSetFloatGameParameterByIndex(obj, 0x22u, 0.0);
}

/*
==============
CG_Weapons_ScopeIsOverlayed
==============
*/
bool CG_Weapons_ScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  const cg_t *LocalClientGlobals; 

  if ( CG_PlayerUsingScopedTurret(localClientNum) )
    return 1;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  return CG_GetWeapReticleZoom(LocalClientGlobals, NULL);
}

/*
==============
CG_Weapons_ScopeToggleState_BlendIntoIdle
==============
*/
void CG_Weapons_ScopeToggleState_BlendIntoIdle(const playerState_s *ps, DObj *obj, const float blendInTime)
{
  XAnimTree *Tree; 
  const dvar_t *v6; 
  const XAnimTree *v7; 
  bool enabled; 
  int v9; 
  int v10; 
  unsigned int VMRelativeAnimIndex; 
  unsigned int v12; 
  weapAnimFiles_t *v13; 
  double Weight; 
  double GoalWeight; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7290, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7291, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7251, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  v6 = DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled;
  v7 = Tree;
  if ( !DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_post_ship_relative_anim_fix_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  enabled = v6->current.enabled;
  v9 = 176;
  if ( enabled )
    v9 = 192;
  v10 = 0;
  while ( 2 )
  {
    VMRelativeAnimIndex = CG_Weapons_GetVMRelativeAnimIndex(v10, enabled);
    v12 = VMRelativeAnimIndex;
    v13 = ignoredAnims;
    while ( *v13 != VMRelativeAnimIndex )
    {
      if ( (__int64)++v13 >= (__int64)&unk_147FA82B8 )
      {
        Weight = XAnimGetWeight(v7, 0, XANIM_SUBTREE_DEFAULT, VMRelativeAnimIndex);
        if ( *(float *)&Weight > 0.0 )
          return;
        GoalWeight = XAnimGetGoalWeight(v7, 0, XANIM_SUBTREE_DEFAULT, v12);
        if ( *(float *)&GoalWeight > 0.0 )
          return;
        break;
      }
    }
    if ( ++v10 < v9 )
      continue;
    break;
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 1.0, blendInTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
CG_Weapons_ScopeToggleState_BlendOutRelativeAnims
==============
*/
void CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(const playerState_s *ps, DObj *obj, const float blendOutTime)
{
  const XAnimTree *Tree; 
  unsigned __int64 i; 
  unsigned int v6; 
  double Weight; 
  float v8; 
  double GoalWeight; 
  double GoalTime; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7207, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7208, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7211, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  for ( i = 0i64; i < 3; ++i )
  {
    v6 = arrRelativeAnims[i];
    Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v6);
    v8 = *(float *)&Weight;
    GoalWeight = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v6);
    if ( v8 > 0.0 )
    {
      if ( *(float *)&GoalWeight > 0.0 || (GoalTime = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, v6), *(float *)&GoalTime > blendOutTime) )
      {
LABEL_16:
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v6, 0.0, blendOutTime, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        continue;
      }
    }
    else if ( *(float *)&GoalWeight > 0.0 )
    {
      goto LABEL_16;
    }
  }
}

/*
==============
CG_Weapons_ScopeToggleState_Scope1InPosition_Enter
==============
*/
void CG_Weapons_ScopeToggleState_Scope1InPosition_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, bool isAlternate, DObj *obj, XAnim_s *anims, ClientScopeToggleInfo *scopeToggleInfo)
{
  XAnimTree *Tree; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7527, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7528, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7529, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7532, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, 0.001, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 1.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 1.0);
}

/*
==============
CG_Weapons_ScopeToggleState_Scope2InPosition_Enter
==============
*/
void CG_Weapons_ScopeToggleState_Scope2InPosition_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, bool isAlternate, DObj *obj, XAnim_s *anims)
{
  XAnimTree *Tree; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7565, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7566, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7567, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7570, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, 0.001, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 1.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 1.0);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOffSettle_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOffSettle_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  const dvar_t *v9; 
  float goalTime; 
  bool v11; 
  int LengthMsec; 
  int v13; 
  int v14; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7419, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7420, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7421, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  v9 = DCONST_DVARFLT_cg_toggleScopeBlendOutTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  goalTime = v9->current.value;
  v11 = BG_PlayerDualWielding(ps) == 1;
  LengthMsec = XAnimGetLengthMsec(anims, 0x105u);
  v13 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v11);
  v14 = v13;
  if ( v13 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7429, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v13, 0i64) )
    __debugbreak();
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, 0.001, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 0.001, goalTime, (float)LengthMsec / (float)v14, (scr_string_t)0, 0, 0, LINEAR, NULL);
  CG_Weapons_ScopeToggleState_BlendIntoIdle(ps, obj, goalTime);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOff_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOff_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  const XAnimTree *Tree; 
  const dvar_t *v10; 
  float goalTime; 
  bool v12; 
  int LengthMsec; 
  int v14; 
  int v15; 
  double rate; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7464, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7465, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7466, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7469, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  v10 = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  goalTime = v10->current.value;
  v12 = BG_PlayerDualWielding(ps) == 1;
  LengthMsec = XAnimGetLengthMsec(anims, 0x105u);
  v14 = BG_ScopeToggleOffTime(ps, weapon, isAlternate, v12);
  v15 = v14;
  if ( v14 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7477, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v14, 0i64) )
    __debugbreak();
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, 1.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 1.0, goalTime, (float)LengthMsec / (float)v15, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  rate = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 0.0, goalTime, *(float *)&rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, goalTime);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOff_Update
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOff_Update(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims, ClientScopeToggleInfo *scopeToggleInfo)
{
  const XAnimTree *Tree; 
  double Time; 
  const dvar_t *v13; 
  const dvar_t *v14; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7492, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7493, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7494, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7497, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( ps->weapState[0].weaponState == 76 )
  {
    CG_Weapons_ScopeToggleState_ToggleOn_Enter(localClientNum, ps, weapon, isAlternate, obj, anims, scopeToggleInfo);
    *(_DWORD *)scopeToggleInfo->state = 2;
  }
  else
  {
    Time = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
    v13 = DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime;
    if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutStartAnimNormalizedTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    if ( *(float *)&Time < v13->current.value )
    {
      v14 = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
      if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v14);
      CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, v14->current.value);
    }
    else
    {
      CG_Weapons_ScopeToggleState_ToggleOffSettle_Enter(localClientNum, ps, weapon, isAlternate, obj, anims);
      *(_DWORD *)scopeToggleInfo->state = 6;
    }
  }
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOnSettle_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOnSettle_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  const dvar_t *v9; 
  float goalTime; 
  bool v11; 
  int LengthMsec; 
  int v13; 
  int v14; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7311, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7312, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7313, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  v9 = DCONST_DVARFLT_cg_toggleScopeBlendOutTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  goalTime = v9->current.value;
  v11 = BG_PlayerDualWielding(ps) == 1;
  LengthMsec = XAnimGetLengthMsec(anims, 0x104u);
  v13 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v11);
  v14 = v13;
  if ( v13 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7321, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v13, 0i64) )
    __debugbreak();
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, 0.001, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 0.001, goalTime, (float)LengthMsec / (float)v14, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  CG_Weapons_ScopeToggleState_BlendIntoIdle(ps, obj, goalTime);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOn_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOn_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  const XAnimTree *Tree; 
  const dvar_t *v10; 
  float goalTime; 
  bool v12; 
  int LengthMsec; 
  int v14; 
  int v15; 
  double rate; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7356, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7357, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7358, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7361, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  v10 = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  goalTime = v10->current.value;
  v12 = BG_PlayerDualWielding(ps) == 1;
  LengthMsec = XAnimGetLengthMsec(anims, 0x104u);
  v14 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v12);
  v15 = v14;
  if ( v14 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7369, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v14, 0i64) )
    __debugbreak();
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, 1.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, 1.0, goalTime, (float)LengthMsec / (float)v15, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  rate = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, 0.0, goalTime, *(float *)&rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, goalTime);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOn_Update
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOn_Update(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims, ClientScopeToggleInfo *scopeToggleInfo)
{
  const XAnimTree *Tree; 
  double Time; 
  const dvar_t *v13; 
  const dvar_t *v14; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7384, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7385, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7386, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7389, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( ps->weapState[0].weaponState == 77 )
  {
    CG_Weapons_ScopeToggleState_ToggleOff_Enter(localClientNum, ps, weapon, isAlternate, obj, anims);
    *(_DWORD *)scopeToggleInfo->state = 5;
  }
  else
  {
    Time = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
    v13 = DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime;
    if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutStartAnimNormalizedTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    if ( *(float *)&Time < v13->current.value )
    {
      v14 = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
      if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v14);
      CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, v14->current.value);
    }
    else
    {
      CG_Weapons_ScopeToggleState_ToggleOnSettle_Enter(localClientNum, ps, weapon, isAlternate, obj, anims);
      *(_DWORD *)scopeToggleInfo->state = 3;
    }
  }
}

/*
==============
CG_Weapons_SetSkydiveAnimationParameters
==============
*/
void CG_Weapons_SetSkydiveAnimationParameters(const LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj)
{
  cg_t *LocalClientGlobals; 
  const SuitDef *SuitDef; 
  float skydive_canopyAnimTrackSpeedThrottle; 
  float skydive_canopyAnimTrackSpeedStrafe; 
  float skydive_canopyAnimTrackSpeedYaw; 
  float skydive_canopyAnimTrackSpeedPitch; 
  float skydive_canopyAnimMinWeight; 
  float skydive_canopyAnimMaxWeight; 
  float skydive_canopyAnimMinPlayRate; 
  float skydive_canopyAnimMaxPlayRate; 
  float skydive_canopyAnimSpeedForMinWeight; 
  float skydive_canopyAnimSpeedForMaxWeight; 
  float v18; 
  float v19; 
  float v20; 
  double v21; 
  float throttle; 
  double v23; 
  float yaw; 
  double v25; 
  float pitch; 
  double v27; 
  float v28; 
  float v31; 
  float v33; 
  float v35; 
  const dvar_t *v36; 
  const dvar_t *v37; 
  const dvar_t *v38; 
  const dvar_t *v39; 
  const dvar_t *v40; 
  const dvar_t *v41; 
  const dvar_t *v42; 
  const dvar_t *v43; 
  __int64 v44; 
  vec2_t StickCartesianCoords; 
  vec2_t v46; 

  StickCartesianCoords = BG_GetStickCartesianCoords(ps->lastInput.rightmove, ps->lastInput.forwardmove);
  v46 = BG_GetStickCartesianCoords(ps->lastInput.yawmove, ps->lastInput.pitchmove);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  SuitDef = BG_GetSuitDef(ps->suitIndex);
  if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6071, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  switch ( ps->skydivePlayerState.state[0] )
  {
    case 1:
    case 5:
    case 6:
      goto $LN7_306;
    case 2:
    case 3:
    case 4:
      skydive_canopyAnimTrackSpeedThrottle = SuitDef->skydive_canopyAnimTrackSpeedThrottle;
      skydive_canopyAnimTrackSpeedStrafe = SuitDef->skydive_canopyAnimTrackSpeedStrafe;
      skydive_canopyAnimTrackSpeedYaw = SuitDef->skydive_canopyAnimTrackSpeedYaw;
      skydive_canopyAnimTrackSpeedPitch = SuitDef->skydive_canopyAnimTrackSpeedPitch;
      skydive_canopyAnimMinWeight = SuitDef->skydive_canopyAnimMinWeight;
      skydive_canopyAnimMaxWeight = SuitDef->skydive_canopyAnimMaxWeight;
      skydive_canopyAnimMinPlayRate = SuitDef->skydive_canopyAnimMinPlayRate;
      skydive_canopyAnimMaxPlayRate = SuitDef->skydive_canopyAnimMaxPlayRate;
      skydive_canopyAnimSpeedForMinWeight = SuitDef->skydive_canopyAnimSpeedForMinWeight;
      skydive_canopyAnimSpeedForMaxWeight = SuitDef->skydive_canopyAnimSpeedForMaxWeight;
      break;
    default:
      LODWORD(v44) = (unsigned __int8)ps->skydivePlayerState.state[0];
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6118, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled skydive state %d while retrieving suit field values.", v44) )
        __debugbreak();
$LN7_306:
      skydive_canopyAnimSpeedForMaxWeight = SuitDef->skydive_freefallAnimSpeedForMaxWeight;
      skydive_canopyAnimSpeedForMinWeight = SuitDef->skydive_freefallAnimSpeedForMinWeight;
      skydive_canopyAnimMaxPlayRate = SuitDef->skydive_freefallAnimMaxPlayRate;
      skydive_canopyAnimMinPlayRate = SuitDef->skydive_freefallAnimMinPlayRate;
      skydive_canopyAnimMaxWeight = SuitDef->skydive_freefallAnimMaxWeight;
      skydive_canopyAnimMinWeight = SuitDef->skydive_freefallAnimMinWeight;
      skydive_canopyAnimTrackSpeedPitch = SuitDef->skydive_freefallAnimTrackSpeedPitch;
      skydive_canopyAnimTrackSpeedYaw = SuitDef->skydive_freefallAnimTrackSpeedYaw;
      skydive_canopyAnimTrackSpeedStrafe = SuitDef->skydive_freefallAnimTrackSpeedStrafe;
      skydive_canopyAnimTrackSpeedThrottle = SuitDef->skydive_freefallAnimTrackSpeedThrottle;
      break;
  }
  v18 = skydive_canopyAnimSpeedForMaxWeight * 39.369999;
  v19 = skydive_canopyAnimSpeedForMinWeight * 39.369999;
  v20 = (float)LocalClientGlobals->frametime * 0.001;
  v21 = DiffTrack(StickCartesianCoords.v[0], LocalClientGlobals->skydiveClientState.animState.strafe, skydive_canopyAnimTrackSpeedStrafe, v20);
  throttle = LocalClientGlobals->skydiveClientState.animState.throttle;
  LocalClientGlobals->skydiveClientState.animState.strafe = *(float *)&v21;
  v23 = DiffTrack(StickCartesianCoords.v[1], throttle, skydive_canopyAnimTrackSpeedThrottle, v20);
  yaw = LocalClientGlobals->skydiveClientState.animState.yaw;
  LocalClientGlobals->skydiveClientState.animState.throttle = *(float *)&v23;
  v25 = DiffTrack(v46.v[0], yaw, skydive_canopyAnimTrackSpeedYaw, v20);
  pitch = LocalClientGlobals->skydiveClientState.animState.pitch;
  LocalClientGlobals->skydiveClientState.animState.yaw = *(float *)&v25;
  v27 = DiffTrack(v46.v[1], pitch, skydive_canopyAnimTrackSpeedPitch, v20);
  v28 = LocalClientGlobals->skydiveClientState.animState.throttle;
  LocalClientGlobals->skydiveClientState.animState.pitch = *(float *)&v27;
  XAnimSetFloatGameParameterByIndex(obj, 0x1Eu, v28);
  XAnimSetFloatGameParameterByIndex(obj, 0x1Fu, LocalClientGlobals->skydiveClientState.animState.strafe);
  XAnimSetFloatGameParameterByIndex(obj, 0x20u, LocalClientGlobals->skydiveClientState.animState.yaw);
  XAnimSetFloatGameParameterByIndex(obj, 0x21u, LocalClientGlobals->skydiveClientState.animState.pitch);
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm2, 1 }
  v31 = (float)((float)(ps->viewangles.v[0] * 0.0027777778) - *(float *)&_XMM4) * 360.0;
  *((_QWORD *)&_XMM0 + 1) = 0i64;
  *(double *)&_XMM0 = I_fclamp(v31, -90.0, 90.0);
  XAnimSetFloatGameParameterByIndex(obj, 0x22u, v31);
  v33 = 0.0;
  if ( v19 < 0.0 )
  {
    __asm { vxorpd  xmm0, xmm0, xmm0 }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6147, ASSERT_TYPE_ASSERT, "( animSpeedForMinWeight ) >= ( 0.0f )", "%s >= %s\n\t%g, %g", "animSpeedForMinWeight", "0.0f", v19, *(double *)&_XMM0) )
      __debugbreak();
  }
  if ( v19 >= v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6148, ASSERT_TYPE_ASSERT, "( animSpeedForMinWeight ) < ( animSpeedForMaxWeight )", "%s < %s\n\t%g, %g", "animSpeedForMinWeight", "animSpeedForMaxWeight", v19, v18) )
    __debugbreak();
  v35 = fsqrt((float)((float)(ps->velocity.v[0] * ps->velocity.v[0]) + (float)(ps->velocity.v[1] * ps->velocity.v[1])) + (float)(ps->velocity.v[2] * ps->velocity.v[2]));
  I_fclamp(v35, v19, v18);
  if ( v19 > v18 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 826, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%g, %g", v19, v18) )
    __debugbreak();
  if ( v35 < v19 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 827, ASSERT_TYPE_SANITY, "( dist ) >= ( min )", "dist >= min\n\t%g, %g", v35, v19) )
    __debugbreak();
  if ( v35 > v18 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 828, ASSERT_TYPE_SANITY, "( dist ) <= ( max )", "dist <= max\n\t%g, %g", v35, v18) )
    __debugbreak();
  if ( (float)(v18 - v19) > 0.000001 )
    v33 = (float)(v35 - v19) / (float)(v18 - v19);
  LocalClientGlobals->skydiveClientState.animState.normalizedSpeed = v33;
  if ( skydive_canopyAnimMinWeight >= skydive_canopyAnimMaxWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6152, ASSERT_TYPE_ASSERT, "( velAnimMinWeight ) < ( velAnimMaxWeight )", "%s < %s\n\t%g, %g", "velAnimMinWeight", "velAnimMaxWeight", skydive_canopyAnimMinWeight, skydive_canopyAnimMaxWeight) )
    __debugbreak();
  LocalClientGlobals->skydiveClientState.animState.velAnimWeight = (float)((float)(1.0 - LocalClientGlobals->skydiveClientState.animState.normalizedSpeed) * skydive_canopyAnimMinWeight) + (float)(LocalClientGlobals->skydiveClientState.animState.normalizedSpeed * skydive_canopyAnimMaxWeight);
  if ( skydive_canopyAnimMinPlayRate >= skydive_canopyAnimMaxPlayRate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6155, ASSERT_TYPE_ASSERT, "( velAnimMinPlayRate ) < ( velAnimMaxPlayRate )", "%s < %s\n\t%g, %g", "velAnimMinPlayRate", "velAnimMaxPlayRate", skydive_canopyAnimMinPlayRate, skydive_canopyAnimMaxPlayRate) )
    __debugbreak();
  LocalClientGlobals->skydiveClientState.animState.velAnimPlayRate = (float)((float)(1.0 - LocalClientGlobals->skydiveClientState.animState.normalizedSpeed) * skydive_canopyAnimMinPlayRate) + (float)(LocalClientGlobals->skydiveClientState.animState.normalizedSpeed * skydive_canopyAnimMaxPlayRate);
  v36 = DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides;
  if ( !DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_enable_debugAnimOverrides") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v36);
  if ( v36->current.enabled )
  {
    v37 = DCONST_DVARFLT_cg_skydive_debug_paramInputThrottle;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputThrottle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputThrottle") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v37);
    XAnimSetFloatGameParameterByIndex(obj, 0x1Eu, v37->current.value);
    v38 = DCONST_DVARFLT_cg_skydive_debug_paramInputStrafe;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputStrafe && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputStrafe") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v38);
    XAnimSetFloatGameParameterByIndex(obj, 0x1Fu, v38->current.value);
    v39 = DCONST_DVARFLT_cg_skydive_debug_paramInputYaw;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputYaw && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputYaw") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v39);
    XAnimSetFloatGameParameterByIndex(obj, 0x20u, v39->current.value);
    v40 = DCONST_DVARFLT_cg_skydive_debug_paramInputPitch;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputPitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputPitch") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v40);
    XAnimSetFloatGameParameterByIndex(obj, 0x21u, v40->current.value);
    v41 = DCONST_DVARFLT_cg_skydive_debug_paramCameraPitch;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramCameraPitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramCameraPitch") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v41);
    XAnimSetFloatGameParameterByIndex(obj, 0x22u, v41->current.value);
    v42 = DCONST_DVARFLT_cg_skydive_debug_velAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v42);
    LODWORD(LocalClientGlobals->skydiveClientState.animState.velAnimWeight) = v42->current.integer;
    v43 = DCONST_DVARFLT_cg_skydive_debug_velAnimPlayRate;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimPlayRate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimPlayRate") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v43);
    LODWORD(LocalClientGlobals->skydiveClientState.animState.velAnimPlayRate) = v43->current.integer;
  }
}

/*
==============
CG_Weapons_SetupAutoComplete
==============
*/
void CG_Weapons_SetupAutoComplete(void)
{
  unsigned int v0; 
  unsigned __int16 v1; 
  unsigned int NumWeapons; 
  const char **v3; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 

  v0 = 5;
  s_weapon_nameParamList[0] = "all";
  s_weapon_nameParamList[1] = "allammo";
  s_weapon_nameParamList[2] = "weapons";
  s_weapon_nameParamList[3] = "ammo";
  s_weapon_nameParamList[4] = "health";
  v1 = 1;
  NumWeapons = BG_GetNumWeapons();
  if ( NumWeapons > 1 )
  {
    v3 = &s_weapon_nameParamList[5];
    while ( 1 )
    {
      v4 = v1;
      if ( v1 > bg_lastParsedWeaponIndex )
      {
        LODWORD(v6) = bg_lastParsedWeaponIndex;
        LODWORD(v5) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v5, v6) )
          __debugbreak();
      }
      if ( !bg_weaponCompleteDefs[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
        __debugbreak();
      if ( v0 >= 0x22B )
        break;
      ++v1;
      ++v0;
      *v3++ = bg_weaponCompleteDefs[v4]->szInternalName;
      if ( v1 >= NumWeapons )
        goto LABEL_13;
    }
    Com_PrintError(14, "CG_Weapons_SetupAutoComplete: Ran out of space for auto-complete\n");
  }
LABEL_13:
  Cmd_SetAutoCompleteList("give", s_weapon_nameParamList, v0);
  Cmd_SetAutoCompleteList("take", s_weapon_nameParamList, 5u);
}

/*
==============
CG_Weapons_ShouldSimulateBulletFire
==============
*/
bool CG_Weapons_ShouldSimulateBulletFire(const LocalClientNum_t localClientNum, BulletFireParams *bp, const centity_t *inflictorEnt, const bool isBeamTracer)
{
  const dvar_t *v4; 
  cg_t *LocalClientGlobals; 
  float v10; 
  double Float_Internal_DebugName; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  __int128 v19; 
  __int128 v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  double v26; 
  float v27; 
  double v28; 
  float v29; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  float v41; 
  float v42; 
  float v43; 
  float v44; 
  float v45; 
  float v46; 
  vec3_t forward; 
  vec3_t point; 
  vec3_t dst; 
  vec3_t up; 

  v4 = DVARBOOL_cg_cullBullets;
  if ( !DVARBOOL_cg_cullBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_cullBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, ACTIVE, 1u) && (LocalClientGlobals->predictedPlayerState.linkFlags.m_flags[0] & 4) == 0 && (!GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.eFlags, ACTIVE, 7u) || LocalClientGlobals->predictedPlayerState.viewlocked_entNum != inflictorEnt->nextState.number) )
    {
      if ( LocalClientGlobals->predictedPlayerState.vehicleState.entity == 2047 )
      {
        *(_QWORD *)point.v = *(_QWORD *)LocalClientGlobals->predictedPlayerState.origin.v;
        v10 = LocalClientGlobals->predictedPlayerState.origin.v[2];
      }
      else
      {
        *(_QWORD *)point.v = *(_QWORD *)LocalClientGlobals->predictedPlayerState.vehicleState.origin.v;
        v10 = LocalClientGlobals->predictedPlayerState.vehicleState.origin.v[2];
      }
      point.v[2] = v10;
      AngleVectors(&LocalClientGlobals->refdefViewAngles, &forward, NULL, &up);
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_cg_cullBulletAngle, "cg_cullBulletAngle");
      RotatePointAroundVector(&dst, &up, &forward, 90.0 - *(float *)&Float_Internal_DebugName);
      v12 = bp->start.v[0];
      v13 = bp->start.v[1];
      v14 = v12 - point.v[0];
      v15 = (float)((float)((float)(dst.v[0] * forward.v[0]) + (float)(dst.v[1] * forward.v[1])) + (float)(dst.v[2] * forward.v[2])) * 2.0;
      v16 = v15 * forward.v[2];
      v17 = bp->end.v[2];
      v18 = v17 - point.v[2];
      v45 = (float)(v15 * forward.v[0]) - dst.v[0];
      *(float *)&Float_Internal_DebugName = v15 * forward.v[1];
      v19 = LODWORD(bp->end.v[1]);
      v20 = v19;
      *(float *)&v20 = *(float *)&v19 - point.v[1];
      v21 = v13 - point.v[1];
      v44 = *(float *)&Float_Internal_DebugName - dst.v[1];
      v22 = bp->start.v[2];
      v23 = v22 - point.v[2];
      v46 = v16 - dst.v[2];
      *(float *)&Float_Internal_DebugName = bp->end.v[0];
      v24 = *(float *)&Float_Internal_DebugName - point.v[0];
      if ( v12 == *(float *)&Float_Internal_DebugName && v13 == *(float *)&v19 && v22 == v17 )
        return 0;
      v26 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cg_minCullBulletDist, "cg_minCullBulletDist");
      v27 = *(float *)&v26;
      v28 = PointToLineSegmentDistSq(&point, &bp->start, &bp->end);
      if ( *(float *)&v28 > (float)(v27 * v27) )
      {
        v29 = *(float *)&v20 - v21;
        *(float *)&v20 = fsqrt((float)((float)(v29 * v29) + (float)((float)(v24 - v14) * (float)(v24 - v14))) + (float)((float)(v18 - v23) * (float)(v18 - v23)));
        _XMM11 = v20;
        __asm
        {
          vcmpless xmm0, xmm11, cs:__real@80000000
          vblendvps xmm0, xmm11, xmm1, xmm0
        }
        v33 = (float)(v24 - v14) * (float)(1.0 / *(float *)&_XMM0);
        v34 = (float)(v18 - v23) * (float)(1.0 / *(float *)&_XMM0);
        v35 = v29 * (float)(1.0 / *(float *)&_XMM0);
        v36 = (float)((float)(dst.v[0] * v14) + (float)(dst.v[1] * v21)) + (float)(dst.v[2] * v23);
        if ( v36 <= 0.0 )
        {
          v37 = (float)((float)(dst.v[1] * v35) + (float)(dst.v[0] * v33)) + (float)(dst.v[2] * v34);
          if ( COERCE_FLOAT(LODWORD(v37) & _xmm) >= 0.001 )
          {
            LODWORD(v38) = COERCE_UNSIGNED_INT(v36 / v37) ^ _xmm;
            if ( v38 >= 0.0 && v38 <= *(float *)&_XMM11 )
            {
              v39 = (float)(v38 * v35) + v21;
              if ( !isBeamTracer )
                return (float)((float)((float)((float)((float)(v38 * v33) + v14) * forward.v[0]) + (float)(v39 * forward.v[1])) + (float)((float)((float)(v38 * v34) + v23) * forward.v[2])) > 0.0;
              return 1;
            }
          }
          return 0;
        }
        if ( (float)((float)((float)(v21 * v44) + (float)(v14 * v45)) + (float)(v23 * v46)) <= 0.0 )
        {
          v41 = (float)((float)(v44 * v35) + (float)(v45 * v33)) + (float)(v46 * v34);
          if ( COERCE_FLOAT(LODWORD(v41) & _xmm) >= 0.001 )
          {
            LODWORD(v42) = COERCE_UNSIGNED_INT((float)((float)((float)(v21 * v44) + (float)(v14 * v45)) + (float)(v23 * v46)) / v41) ^ _xmm;
            if ( v42 >= 0.0 && v42 <= *(float *)&_XMM11 )
            {
              v43 = (float)(v42 * v35) + v21;
              if ( !isBeamTracer )
                return (float)((float)((float)((float)((float)(v42 * v33) + v14) * forward.v[0]) + (float)(v43 * forward.v[1])) + (float)((float)((float)(v42 * v34) + v23) * forward.v[2])) > 0.0;
              return 1;
            }
          }
          return 0;
        }
      }
    }
  }
  return 1;
}

/*
==============
CG_Weapons_SimulateBulletFire_EndPos
==============
*/
void CG_Weapons_SimulateBulletFire_EndPos(unsigned int *randSeed, const float spreadInner, const float spreadOuter, const vec3_t *start, vec3_t *end, vec3_t *dir, const float angleMin, const float angleMax, const vec3_t *forwardDir, const vec3_t *rightDir, const vec3_t *upDir, const float maxRange)
{
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 
  double v22; 
  double v23; 
  double v24; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  const vec3_t *v30; 
  float v31; 
  float v32; 
  float v33; 
  const vec3_t *v34; 
  float v35; 
  float v36; 
  float v37; 
  const vec3_t *v38; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  float v43; 
  __int128 v44; 
  float v45; 
  float v46; 
  float v50; 

  if ( (LODWORD(spreadInner) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23404, ASSERT_TYPE_SANITY, "( !IS_NAN( spreadInner ) )", (const char *)&queryFormat, "!IS_NAN( spreadInner )") )
    __debugbreak();
  if ( (LODWORD(spreadOuter) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23405, ASSERT_TYPE_SANITY, "( !IS_NAN( spreadOuter ) )", (const char *)&queryFormat, "!IS_NAN( spreadOuter )") )
    __debugbreak();
  v14 = tanf_0(spreadInner * 0.017453292);
  v15 = maxRange;
  v16 = v14 * maxRange;
  v17 = tanf_0(spreadOuter * 0.017453292);
  maxRange = v16;
  v19 = v17 * v15;
  v18 = v17 * v15;
  if ( (LODWORD(v16) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23410, ASSERT_TYPE_SANITY, "( !IS_NAN( aimOffsetMin ) )", (const char *)&queryFormat, "!IS_NAN( aimOffsetMin )") )
    __debugbreak();
  maxRange = v17 * v15;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23411, ASSERT_TYPE_SANITY, "( !IS_NAN( aimOffsetMax ) )", (const char *)&queryFormat, "!IS_NAN( aimOffsetMax )") )
    __debugbreak();
  v20 = angleMin;
  v21 = angleMax;
  if ( angleMin > angleMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23280, ASSERT_TYPE_ASSERT, "( angleMin ) <= ( angleMax )", "%s <= %s\n\t%g, %g", "angleMin", "angleMax", angleMin, angleMax) )
    __debugbreak();
  v22 = BG_random(randSeed);
  v23 = AngleNormalize360((float)(*(float *)&v22 * (float)(v21 - v20)) + v20);
  FastSinCos(*(float *)&v23 * 0.017453292, (float *)&angleMin, (float *)&maxRange);
  v24 = BG_random(randSeed);
  v25 = (float)((float)((float)(v18 - v16) * maxRange) * *(float *)&v24) + (float)(v16 * maxRange);
  v26 = (float)((float)(v19 - v16) * angleMin) * *(float *)&v24;
  v27 = v16 * angleMin;
  maxRange = v25;
  v29 = v26 + (float)(v16 * angleMin);
  v28 = v29;
  if ( (LODWORD(v25) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23420, ASSERT_TYPE_SANITY, "( !IS_NAN( right ) )", (const char *)&queryFormat, "!IS_NAN( right )") )
    __debugbreak();
  maxRange = v26 + v27;
  if ( (LODWORD(v29) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23421, ASSERT_TYPE_SANITY, "( !IS_NAN( up ) )", (const char *)&queryFormat, "!IS_NAN( up )") )
    __debugbreak();
  v30 = forwardDir;
  v31 = (float)(v15 * forwardDir->v[0]) + start->v[0];
  end->v[0] = v31;
  v32 = (float)(v15 * v30->v[1]) + start->v[1];
  end->v[1] = v32;
  v33 = (float)(v15 * v30->v[2]) + start->v[2];
  maxRange = v31;
  end->v[2] = v33;
  if ( (LODWORD(v31) & 0x7F800000) == 2139095040 || (maxRange = v32, (LODWORD(v32) & 0x7F800000) == 2139095040) || (maxRange = v33, (LODWORD(v33) & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23425, ASSERT_TYPE_SANITY, "( !IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] )") )
      __debugbreak();
  }
  v34 = rightDir;
  v35 = (float)(v25 * rightDir->v[0]) + end->v[0];
  end->v[0] = v35;
  v36 = (float)(v25 * v34->v[1]) + end->v[1];
  end->v[1] = v36;
  v37 = (float)(v25 * v34->v[2]) + end->v[2];
  v38 = upDir;
  end->v[2] = v37;
  v39 = (float)(v28 * v38->v[0]) + v35;
  end->v[0] = v39;
  v40 = (float)(v28 * v38->v[1]) + v36;
  end->v[1] = v40;
  v41 = v28 * v38->v[2];
  maxRange = v39;
  v42 = v41 + v37;
  end->v[2] = v42;
  if ( (LODWORD(v39) & 0x7F800000) == 2139095040 || (maxRange = v40, (LODWORD(v40) & 0x7F800000) == 2139095040) || (maxRange = v42, (LODWORD(v42) & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23430, ASSERT_TYPE_SANITY, "( !IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] )") )
      __debugbreak();
  }
  v44 = LODWORD(end->v[0]);
  v43 = end->v[0] - start->v[0];
  dir->v[0] = v43;
  v45 = end->v[1] - start->v[1];
  dir->v[1] = v45;
  v46 = end->v[2] - start->v[2];
  *(float *)&v44 = fsqrt((float)((float)(v43 * v43) + (float)(v45 * v45)) + (float)(v46 * v46));
  _XMM4 = v44;
  __asm
  {
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm1, xmm0
  }
  dir->v[0] = (float)(1.0 / *(float *)&_XMM0) * v43;
  v50 = v45 * (float)(1.0 / *(float *)&_XMM0);
  dir->v[1] = v50;
  dir->v[2] = v46 * (float)(1.0 / *(float *)&_XMM0);
  maxRange = dir->v[0];
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 || (maxRange = v45 * (float)(1.0 / *(float *)&_XMM0), (LODWORD(v50) & 0x7F800000) == 2139095040) || (maxRange = v46 * (float)(1.0 / *(float *)&_XMM0), (LODWORD(maxRange) & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23435, ASSERT_TYPE_SANITY, "( !IS_NAN( ( dir )[0] ) && !IS_NAN( ( dir )[1] ) && !IS_NAN( ( dir )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( dir )[0] ) && !IS_NAN( ( dir )[1] ) && !IS_NAN( ( dir )[2] )") )
      __debugbreak();
  }
}

/*
==============
CG_Weapons_SimulateBulletFire_FakeTrace
==============
*/
bool CG_Weapons_SimulateBulletFire_FakeTrace(const LocalClientNum_t localClientNum, const BulletFireParams *bp, const centity_t *knownHitClientEntity, BulletTraceResults *outResults)
{
  entityState_t *p_nextState; 
  entityType_s eType; 
  float v9; 
  float v10; 
  float v11; 
  float v12; 
  float v13; 
  double v14; 
  bool result; 
  vec3_t outOrigin; 
  __int64 v17; 

  v17 = -2i64;
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23470, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !outResults && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23471, ASSERT_TYPE_ASSERT, "(outResults)", (const char *)&queryFormat, "outResults") )
    __debugbreak();
  if ( !knownHitClientEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23472, ASSERT_TYPE_ASSERT, "(knownHitClientEntity)", (const char *)&queryFormat, "knownHitClientEntity") )
    __debugbreak();
  if ( (knownHitClientEntity->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23473, ASSERT_TYPE_ASSERT, "(CENextValid( knownHitClientEntity ))", (const char *)&queryFormat, "CENextValid( knownHitClientEntity )") )
    __debugbreak();
  p_nextState = &knownHitClientEntity->nextState;
  if ( knownHitClientEntity == (const centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1921, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  eType = knownHitClientEntity->nextState.eType;
  if ( (((eType - 1) & 0xFFED) != 0 || eType == ET_ITEM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23474, ASSERT_TYPE_ASSERT, "(BG_IsCharacterEntity( &knownHitClientEntity->nextState ))", (const char *)&queryFormat, "BG_IsCharacterEntity( &knownHitClientEntity->nextState )") )
    __debugbreak();
  if ( p_nextState->number != knownHitClientEntity->nextState.clientNum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23475, ASSERT_TYPE_ASSERT, "( knownHitClientEntity->nextState.number ) == ( knownHitClientEntity->nextState.clientNum )", "%s == %s\n\t%i, %i", "knownHitClientEntity->nextState.number", "knownHitClientEntity->nextState.clientNum", p_nextState->number, knownHitClientEntity->nextState.clientNum) )
    __debugbreak();
  memset_0(outResults, 0, sizeof(BulletTraceResults));
  CG_GetPoseOrigin(&knownHitClientEntity->pose, &outOrigin);
  v9 = bp->end.v[0] - bp->start.v[0];
  v10 = bp->end.v[1] - bp->start.v[1];
  v11 = bp->end.v[2] - bp->start.v[2];
  v12 = (float)((float)(v10 * v10) + (float)(v9 * v9)) + (float)(v11 * v11);
  if ( v12 <= 0.0000010000001 )
  {
    outResults->trace.fraction = 0.0;
    v13 = 0.0;
  }
  else
  {
    v13 = (float)((float)((float)(v10 * (float)(outOrigin.v[1] - bp->start.v[1])) + (float)(v9 * (float)(outOrigin.v[0] - bp->start.v[0]))) + (float)(v11 * (float)(outOrigin.v[2] - bp->start.v[2]))) / v12;
    outResults->trace.fraction = v13;
  }
  v14 = I_fclamp(v13, 0.0, 1.0);
  outResults->trace.fraction = *(float *)&v14;
  outResults->hitPos.v[0] = (float)((float)(bp->end.v[0] - bp->start.v[0]) * *(float *)&v14) + bp->start.v[0];
  outResults->hitPos.v[1] = (float)((float)(bp->end.v[1] - bp->start.v[1]) * *(float *)&v14) + bp->start.v[1];
  outResults->hitPos.v[2] = (float)((float)(bp->end.v[2] - bp->start.v[2]) * *(float *)&v14) + bp->start.v[2];
  outResults->trace.normal.v[0] = COERCE_FLOAT(LODWORD(bp->dir.v[0]) ^ _xmm);
  outResults->trace.normal.v[1] = COERCE_FLOAT(LODWORD(bp->dir.v[1]) ^ _xmm);
  outResults->trace.normal.v[2] = COERCE_FLOAT(LODWORD(bp->dir.v[2]) ^ _xmm);
  outResults->trace.surfaceFlags = knownHitClientEntity->nextState.surfType << 19;
  outResults->trace.contents = 1;
  outResults->trace.hitType = TRACE_HITTYPE_ENTITY;
  outResults->trace.hitId = (unsigned __int16)p_nextState->number;
  outResults->depthSurfaceType = knownHitClientEntity->nextState.surfType;
  outResults->hitClientNum = knownHitClientEntity->nextState.clientNum;
  outResults->ignoreHitEnt = 0;
  result = 1;
  memset(&outOrigin, 0, sizeof(outOrigin));
  return result;
}

/*
==============
CG_Weapons_SimulateBulletFire_GetKnownHitClientEntity
==============
*/
centity_t *CG_Weapons_SimulateBulletFire_GetKnownHitClientEntity(const LocalClientNum_t localClientNum, const int knownHitClientNum)
{
  centity_t *Entity; 
  centity_t *v5; 
  entityState_t *p_nextState; 
  __int16 eType; 
  __int64 v9; 
  __int64 v10; 
  unsigned int m_characterCount; 

  if ( knownHitClientNum == -1 )
    return 0i64;
  if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
    __debugbreak();
  if ( knownHitClientNum >= ComCharacterLimits::ms_gameData.m_characterCount )
  {
    if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
      __debugbreak();
    m_characterCount = ComCharacterLimits::ms_gameData.m_characterCount;
    LODWORD(v9) = knownHitClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23447, ASSERT_TYPE_ASSERT, "(unsigned)( knownHitClientNum ) < (unsigned)( ComCharacterLimits::GetCharacterMaxCount() )", "knownHitClientNum doesn't index ComCharacterLimits::GetCharacterMaxCount()\n\t%i not in [0, %i)", v9, m_characterCount) )
      __debugbreak();
  }
  Entity = CG_GetEntity(localClientNum, knownHitClientNum);
  v5 = Entity;
  if ( (Entity->flags & 1) == 0 )
    return 0i64;
  p_nextState = &Entity->nextState;
  if ( Entity == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1921, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  eType = p_nextState->eType;
  if ( (((eType - 1) & 0xFFED) != 0 || eType == 3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23454, ASSERT_TYPE_SANITY, "( BG_IsCharacterEntity( &knownHitClientEntity->nextState ) )", (const char *)&queryFormat, "BG_IsCharacterEntity( &knownHitClientEntity->nextState )") )
    __debugbreak();
  if ( p_nextState->number != knownHitClientNum )
  {
    LODWORD(v10) = knownHitClientNum;
    LODWORD(v9) = p_nextState->number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23455, ASSERT_TYPE_SANITY, "( knownHitClientEntity->nextState.number ) == ( knownHitClientNum )", "knownHitClientEntity->nextState.number == knownHitClientNum\n\t%i, %i", v9, v10) )
      __debugbreak();
  }
  if ( v5->nextState.clientNum != knownHitClientNum )
  {
    LODWORD(v10) = knownHitClientNum;
    LODWORD(v9) = v5->nextState.clientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23456, ASSERT_TYPE_SANITY, "( knownHitClientEntity->nextState.clientNum ) == ( knownHitClientNum )", "knownHitClientEntity->nextState.clientNum == knownHitClientNum\n\t%i, %i", v9, v10) )
      __debugbreak();
  }
  return v5;
}

/*
==============
CG_Weapons_StartWeaponAnim
==============
*/
void CG_Weapons_StartWeaponAnim(LocalClientNum_t localClientNum, const Weapon *weapon, PlayerHandIndex hand, const WeaponAnimNumber anim, const weapAnimFiles_t animIndex, const WeaponAnimNumber prevAnim, const weapAnimFiles_t prevAnimIndex, float transitionTime, bool forceTransitionTime)
{
  __int128 v10; 
  __int128 v11; 
  __int128 v12; 
  __int64 v15; 
  cg_t *LocalClientGlobals; 
  const dvar_t *v17; 
  cg_t *v18; 
  const playerState_s *p_predictedPlayerState; 
  DObj *viewModelDObj; 
  XAnim_s *Anims; 
  float WeaponStateModifiedAnimRate; 
  float v23; 
  DObj *v25; 
  DObj *v26; 
  weapAnimFiles_t v27; 
  const XAnimTree *Tree; 
  const dvar_t *v29; 
  double Rate; 
  float v31; 
  bool CanModifyAnimWeight; 
  DObj *v33; 
  double Weight; 
  bool v35; 
  int v36; 
  int v37; 
  weapAnimFiles_t VMRelativeAnimIndex; 
  unsigned int v39; 
  bool ShouldClearAnim; 
  DObj *v41; 
  unsigned __int64 v42; 
  unsigned int *v43; 
  float v44; 
  const WeapAnimGroup (*v45)[7]; 
  int v46; 
  const WeapAnimGroup (*v47)[7]; 
  unsigned __int64 i; 
  bool v49; 
  int v50; 
  DObj *v51; 
  int j; 
  weapAnimFiles_t v53; 
  signed int v54; 
  __int64 v55; 
  int v56; 
  float *blendOutTime; 
  float blendInTime; 
  float v59; 
  DObj *obj; 
  cg_t *cgameGlob; 
  WeaponHand *weaponHand; 
  __int128 v63; 
  __int128 v64; 
  __int128 v65; 
  bool enabled; 

  v15 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v17 = DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled;
  cgameGlob = LocalClientGlobals;
  v18 = LocalClientGlobals;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_post_ship_relative_anim_fix_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v17);
  enabled = v17->current.enabled;
  if ( (unsigned int)(animIndex - 236) > 0xA8 && (unsigned int)(animIndex - 432) > 0xF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2890, ASSERT_TYPE_ASSERT, "(isValidViewmodelAnimIndex)", (const char *)&queryFormat, "isValidViewmodelAnimIndex") )
    __debugbreak();
  if ( (unsigned int)v15 >= 2 )
  {
    LODWORD(blendOutTime) = 2;
    LODWORD(v55) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v55, blendOutTime) )
      __debugbreak();
  }
  viewModelDObj = v18->m_weaponHand[v15].viewModelDObj;
  weaponHand = &v18->m_weaponHand[v15];
  obj = viewModelDObj;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2975, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Anims = XAnimGetAnims(v18->m_weaponHand[v15].tree);
  if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2978, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  WeaponStateModifiedAnimRate = CG_Weapons_GetWeaponStateModifiedAnimRate(localClientNum, p_predictedPlayerState, weapon, (PlayerHandIndex)v15, Anims, animIndex);
  v23 = WeaponStateModifiedAnimRate;
  if ( WeaponStateModifiedAnimRate <= 0.0 )
  {
    __asm { vxorpd  xmm2, xmm2, xmm2 }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2981, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( rate )", "%s < %s\n\t%g, %g", "0.0f", "rate", *(double *)&_XMM2, WeaponStateModifiedAnimRate) )
      __debugbreak();
  }
  v25 = obj;
  v56 = v18->playerWeaponInfo.meleeStartTime[v15];
  v26 = obj;
  v18->playerWeaponInfo.meleeStartTime[v15] = v18->predictedPlayerState.meleeStartTime;
  v27 = prevAnimIndex;
  if ( !WeaponAnimBlendMeleeMisprediction(p_predictedPlayerState, v26, animIndex, WeaponStateModifiedAnimRate, prevAnimIndex, v56) )
  {
    CG_Weapons_StoreSprintAnimLength(localClientNum, animIndex, (const PlayerHandIndex)v15);
    Tree = DObjGetTree(v25);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2993, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    v65 = v10;
    v64 = v11;
    v59 = 0.0;
    blendInTime = 0.0;
    v63 = v12;
    if ( !CG_GetFastADSBlendTimes(localClientNum, p_predictedPlayerState, weapon, anim, prevAnim, &blendInTime, &v59) )
    {
      if ( !p_predictedPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2330, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->pm_flags, ACTIVE, 5u) && anim == WEAP_FORCE_IDLE && (unsigned int)prevAnim > WEAP_FORCE_IDLE )
      {
        v29 = DCONST_DVARFLT_cg_mantleQuickBlendTime;
        if ( !DCONST_DVARFLT_cg_mantleQuickBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_mantleQuickBlendTime") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v29);
        blendInTime = v29->current.value;
        v59 = blendInTime;
      }
      else if ( !GetAnimBlendTimes(localClientNum, weapon, p_predictedPlayerState, prevAnim, prevAnimIndex, anim, animIndex, &v59, &blendInTime) )
      {
        goto LABEL_69;
      }
    }
    if ( !forceTransitionTime )
    {
      Rate = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
      v31 = *(float *)&Rate;
      CanModifyAnimWeight = CG_CanModifyAnimWeight(p_predictedPlayerState, prevAnimIndex);
      v33 = obj;
      if ( CanModifyAnimWeight )
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex, 0.0, v59, *(float *)&Rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      if ( animIndex != WEAP_ANIM_IDLE || blendInTime <= 0.0 || (Weight = XAnimGetWeight(weaponHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu), *(float *)&Weight != 1.0) )
      {
        if ( CG_CanModifyAnimWeight(p_predictedPlayerState, animIndex) )
          XAnimSetGoalWeight(v33, 0, XANIM_SUBTREE_DEFAULT, animIndex, 1.0, blendInTime, v23, (scr_string_t)0, 1u, 1, LINEAR, NULL);
        CG_WeaponAnimGroup_BlendIn(blendInTime, animIndex, (const PlayerHandIndex)v15, v23, cgameGlob);
      }
      v35 = enabled;
      v36 = 176;
      v37 = 0;
      if ( enabled )
        v36 = 192;
      do
      {
        VMRelativeAnimIndex = (unsigned int)CG_Weapons_GetVMRelativeAnimIndex(v37, v35);
        v39 = VMRelativeAnimIndex;
        if ( VMRelativeAnimIndex == prevAnimIndex || VMRelativeAnimIndex == animIndex )
        {
          v41 = obj;
        }
        else
        {
          ShouldClearAnim = CG_ShouldClearAnim(localClientNum, p_predictedPlayerState, VMRelativeAnimIndex);
          v41 = obj;
          if ( ShouldClearAnim )
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v39, 0.0, transitionTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        v35 = enabled;
        ++v37;
      }
      while ( v37 < v36 );
      v42 = g_weapAnimGroupCount;
      v43 = NULL;
      v44 = v59;
      if ( g_weapAnimGroupCount )
      {
        v45 = g_weapAnimGroups;
        do
        {
          v46 = 0;
          v47 = v45;
          while ( *(_DWORD *)v47 )
          {
            if ( *(_DWORD *)v47 == prevAnimIndex )
            {
              v43 = (unsigned int *)v45;
              break;
            }
            ++v46;
            v47 = (const WeapAnimGroup (*)[7])((char *)v47 + 16);
            if ( v46 >= 7 )
              break;
          }
          ++v45;
          --v42;
        }
        while ( v42 );
        if ( v43 )
        {
          for ( i = 0i64; i < 7; ++i )
          {
            if ( !*v43 )
              break;
            if ( CG_ShouldClearAnim(localClientNum, p_predictedPlayerState, (weapAnimFiles_t)*v43) )
              XAnimSetGoalWeight(v41, 0, XANIM_SUBTREE_DEFAULT, *v43, 0.0, v44, v31, (scr_string_t)0, 0, 0, LINEAR, NULL);
            v43 += 4;
          }
        }
      }
      goto LABEL_80;
    }
LABEL_69:
    v49 = enabled;
    v50 = 176;
    v51 = obj;
    if ( enabled )
      v50 = 192;
    for ( j = 0; j < v50; ++j )
    {
      v53 = (unsigned int)CG_Weapons_GetVMRelativeAnimIndex(j, v49);
      v54 = v53;
      if ( animIndex == v53 )
      {
        if ( CG_CanModifyAnimWeight(p_predictedPlayerState, v53) )
          XAnimSetGoalWeight(v51, 0, XANIM_SUBTREE_DEFAULT, v54, 1.0, transitionTime, WeaponStateModifiedAnimRate, (scr_string_t)0, 1u, 1, LINEAR, NULL);
        CG_WeaponAnimGroup_BlendIn(transitionTime, (const weapAnimFiles_t)v54, (const PlayerHandIndex)v15, WeaponStateModifiedAnimRate, cgameGlob);
      }
      else if ( CG_ShouldClearAnim(localClientNum, p_predictedPlayerState, v53) )
      {
        XAnimSetGoalWeight(v51, 0, XANIM_SUBTREE_DEFAULT, v54, 0.0, transitionTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      v49 = enabled;
    }
    v27 = prevAnimIndex;
LABEL_80:
    if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    if ( BG_IsSprintAdditive(CgWeaponMap::ms_instance[localClientNum], p_predictedPlayerState) && (unsigned int)(v27 - 93) <= 6 )
      CG_StopSprintAdditives(p_predictedPlayerState, obj, weaponHand, v59);
  }
}

/*
==============
CG_Weapons_StoreSprintAnimLength
==============
*/
void CG_Weapons_StoreSprintAnimLength(LocalClientNum_t localClientNum, const weapAnimFiles_t animIndex, const PlayerHandIndex hand)
{
  const dvar_t *v3; 
  __int64 v5; 
  bool v7; 
  bool v8; 
  cg_t *LocalClientGlobals; 
  cg_t *v10; 
  playerState_s *p_predictedPlayerState; 
  int weaponTime; 

  v3 = DCONST_DVARMPBOOL_movementAnimProto;
  v5 = hand;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( !v3->current.enabled )
  {
    v7 = animIndex == WEAP_ANIM_SPRINT_IN || animIndex == WEAP_ANIM_ADDITIVE_SPRINT_IN;
    v8 = animIndex == WEAP_ANIM_SPRINT_OUT || animIndex == WEAP_ANIM_SPRINT_IN_CANCEL || animIndex == WEAP_ANIM_ADDITIVE_SPRINT_OUT;
    if ( v7 || v8 )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
      if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2307, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
        __debugbreak();
      v10 = CG_GetLocalClientGlobals(localClientNum);
      p_predictedPlayerState = &v10->predictedPlayerState;
      if ( v10 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2310, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      weaponTime = p_predictedPlayerState->weapState[v5].weaponTime;
      if ( weaponTime <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2314, ASSERT_TYPE_ASSERT, "(0 < weaponTime)", "%s\n\tCG_Weapons_StoreSprintAnimLength(): remaining weaponTime must be greater than 0.", "0 < weaponTime") )
        __debugbreak();
      if ( weaponTime < 1 )
        weaponTime = 1;
      if ( v7 )
        LocalClientGlobals->sprintAnimData.sprintInAnimLength = weaponTime;
      else
        LocalClientGlobals->sprintAnimData.sprintOutAnimLength = weaponTime;
    }
  }
}

/*
==============
CG_Weapons_ThermalScopeIsOverlayed
==============
*/
bool CG_Weapons_ThermalScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  const cg_t *LocalClientGlobals; 
  cg_t *v3; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  bool outIsAlternate; 
  Weapon r_weapon; 

  if ( !CG_PlayerUsingScopedTurret(localClientNum) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !CG_GetWeapReticleZoom(LocalClientGlobals, NULL) )
      return 0;
  }
  v3 = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &v3->predictedPlayerState;
  if ( v3 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  r_weapon = *BG_GetViewmodelOrOffhandADSWeapon(Instance, p_predictedPlayerState, &outIsAlternate);
  return BG_IsThermalEnabled(Instance, &r_weapon, p_predictedPlayerState);
}

/*
==============
CG_Weapons_ToggleEquip
==============
*/
void CG_Weapons_ToggleEquip(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  bool equipSelectInAlt; 
  int v5; 
  bool isCurrentValid; 
  bool isOtherValid; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  CG_Weapons_ToggleEquip_IsOffhandValid(localClientNum, &isCurrentValid, &isOtherValid);
  if ( !isCurrentValid || isOtherValid )
  {
    if ( !BG_IsSpectating(&LocalClientGlobals->predictedPlayerState) )
      LocalClientGlobals->equipSelectInAlt = !LocalClientGlobals->equipSelectInAlt;
  }
  else
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    equipSelectInAlt = LocalClientGlobals->equipSelectInAlt;
    v5 = 2;
    if ( !equipSelectInAlt )
      v5 = 9;
    if ( LocalClientGlobals->invalidCmdHintType != v5 )
    {
      LocalClientGlobals->invalidCmdHintTime = LocalClientGlobals->time;
      LocalClientGlobals->invalidCmdHintType = v5;
    }
    LocalClientGlobals->invalidCmdHintWeapon = *BG_GetFirstEquippedOffhandBySlot(Instance, &LocalClientGlobals->predictedPlayerState, (const OffhandSlot)(!equipSelectInAlt + 1));
  }
}

/*
==============
CG_Weapons_ToggleEquip_IsOffhandValid
==============
*/
void CG_Weapons_ToggleEquip_IsOffhandValid(LocalClientNum_t localClientNum, bool *isCurrentValid, bool *isOtherValid)
{
  __int64 v3; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap **v8; 
  bool equipSelectInAlt; 
  const BgWeaponMap *v10; 
  const Weapon *OffHandWeaponForSlot; 
  const Weapon *v12; 
  bool v13; 

  v3 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  v8 = &CgWeaponMap::ms_instance[v3];
  if ( !*v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  equipSelectInAlt = LocalClientGlobals->equipSelectInAlt;
  v10 = *v8;
  OffHandWeaponForSlot = PM_Weapon_GetOffHandWeaponForSlot(v10, p_predictedPlayerState, (OffhandSlot)(equipSelectInAlt + 1));
  v12 = PM_Weapon_GetOffHandWeaponForSlot(v10, p_predictedPlayerState, (OffhandSlot)(!equipSelectInAlt + 1));
  v13 = OffHandWeaponForSlot->weaponIdx && PM_Weapon_OffHandHasAmmo(p_predictedPlayerState, v10, OffHandWeaponForSlot);
  *isCurrentValid = v13;
  *isOtherValid = v12->weaponIdx && PM_Weapon_OffHandHasAmmo(p_predictedPlayerState, v10, v12);
}

/*
==============
CG_Weapons_ToggleEquip_OnOffhandEnd
==============
*/
void CG_Weapons_ToggleEquip_OnOffhandEnd(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  bool isCurrentValid; 
  bool isOtherValid; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  CG_Weapons_ToggleEquip_IsOffhandValid(localClientNum, &isCurrentValid, &isOtherValid);
  if ( !isCurrentValid && isOtherValid )
    LocalClientGlobals->equipSelectInAlt = !LocalClientGlobals->equipSelectInAlt;
}

/*
==============
CG_Weapons_ToggleWeaponAltMode
==============
*/
char CG_Weapons_ToggleWeaponAltMode(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  __int64 v3; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals->predictedPlayerState.weapState[0].weaponState <= 0x32u )
  {
    v3 = 0x4000000001FBCi64;
    if ( _bittest64(&v3, LocalClientGlobals->predictedPlayerState.weapState[0].weaponState) )
      return 0;
  }
  if ( BG_Skydive_IsSkydiving(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  if ( !LocalClientGlobals->IsClientValid(LocalClientGlobals) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xAu) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xEu) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &LocalClientGlobals->predictedPlayerState);
  if ( BG_UseLeftTriggerAltFireMode(CurrentWeaponForPlayer) || BG_WeaponDef(CurrentWeaponForPlayer, 0)->inventoryType == WEAPINVENTORY_EXCLUSIVE )
    return 0;
  if ( !BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState) && (!CurrentWeaponForPlayer->weaponIdx || !BG_ActiveUnderbarrel(CurrentWeaponForPlayer)) && !BG_GetAltWeapon(CurrentWeaponForPlayer)->weaponIdx )
    return 0;
  CG_SelectWeapon(localClientNum, &LocalClientGlobals->weaponSelect, LocalClientGlobals->weaponSelectInAlt == 0);
  return 1;
}

/*
==============
CG_Weapons_UpdateSprintAnim
==============
*/
void CG_Weapons_UpdateSprintAnim(LocalClientNum_t localClientNum, const Weapon *weapon, PlayerHandIndex hand, weapAnimFiles_t animIndex)
{
  const dvar_t *v4; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  CgHandler *Handler; 
  CgHandler *v14; 
  CgHandler *v15; 
  double BobCycleAnimTime; 

  v4 = DCONST_DVARBOOL_cg_viewmodelAdditiveSprint;
  if ( !DCONST_DVARBOOL_cg_viewmodelAdditiveSprint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdditiveSprint") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3191, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
    if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3193, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3195, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3197, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( Tree && !BG_IsSuperSprinting(p_predictedPlayerState) && (animIndex == WEAP_ANIM_ADDITIVE_SPRINT_LOOP || animIndex == WEAP_ANIM_SPRINT_LOOP) )
    {
      Handler = CgHandler::getHandler(localClientNum);
      if ( !BG_ViewModelAnimExists(p_predictedPlayerState, WEAP_ANIM_ADDITIVE_SPRINT_IN, hand, Handler) || XAnimHasFinished(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x5Eu) )
      {
        v14 = CgHandler::getHandler(localClientNum);
        if ( !BG_ViewModelAnimExists(p_predictedPlayerState, WEAP_ANIM_SPRINT_IN, hand, v14) || XAnimHasFinished(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x151u) )
        {
          v15 = CgHandler::getHandler(localClientNum);
          if ( BG_ViewModelAnimExists(p_predictedPlayerState, animIndex, hand, v15) )
          {
            BobCycleAnimTime = BG_GetBobCycleAnimTime((const int (*)[2])p_predictedPlayerState->packedBobCycle);
            XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, animIndex, *(float *)&BobCycleAnimTime);
            XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, animIndex, 0.0);
          }
        }
      }
    }
  }
}

/*
==============
CG_Weapons_UpdateSuperSprintAnim
==============
*/
void CG_Weapons_UpdateSuperSprintAnim(LocalClientNum_t localClientNum, const Weapon *weapon, PlayerHandIndex hand, weapAnimFiles_t animIndex)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  const WeaponHand *v8; 
  DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  const dvar_t *v11; 
  const dvar_t *v12; 
  signed int v13; 
  double Float_Internal_DebugName; 
  double Weight; 
  double v16; 
  double v17; 
  double v18; 
  signed int v19; 
  double v20; 
  double v21; 
  double v22; 
  double v23; 
  __int64 prevAnim; 

  v4 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3083, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3086, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(prevAnim) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", prevAnim, 2) )
      __debugbreak();
  }
  v8 = &LocalClientGlobals->m_weaponHand[v4];
  if ( (cg_t *)((char *)LocalClientGlobals + 40 * v4) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3089, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  viewModelDObj = v8->viewModelDObj;
  if ( !v8->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3092, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(viewModelDObj);
  if ( Tree )
  {
    v11 = DCONST_DVARMPBOOL_movementAnimProto;
    if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    if ( !v11->current.enabled )
    {
      v12 = DCONST_DVARMPBOOL_superSprintEnable;
      if ( !DCONST_DVARMPBOOL_superSprintEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "superSprintEnable") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v12);
      if ( v12->current.enabled )
      {
        v13 = p_predictedPlayerState->weapState[v4].weapAnim & 0xFFFFFF7F;
        if ( BG_IsSuperSprinting(p_predictedPlayerState) )
        {
          if ( (unsigned int)(animIndex - 93) <= 6 || ((v13 - 32) & 0xFFFFFFFC) == 0 && v13 != 33 )
          {
            Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendOutSprintTime, "superSprintBlendOutSprintTime");
            CG_StopSprintAdditives(p_predictedPlayerState, viewModelDObj, v8, *(const float *)&Float_Internal_DebugName);
            Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
            if ( *(float *)&Weight <= 0.0 )
            {
              v16 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
              CG_Weapons_StartWeaponAnim(localClientNum, weapon, (PlayerHandIndex)v4, WEAP_SPRINT_LOOP, WEAP_ANIM_SUPER_SPRINT_LOOP, WEAP_IDLE, WEAP_ANIM_IDLE, *(float *)&v16, 0);
            }
          }
          return;
        }
        v17 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
        if ( *(float *)&v17 <= 0.0 )
          return;
        v18 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x154u, 0.0, *(float *)&v18, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        if ( animIndex == WEAP_ANIM_ADDITIVE_SPRINT_LOOP )
        {
          CG_StartSprintAdditive(localClientNum, p_predictedPlayerState, viewModelDObj, weapon, v8, (const PlayerHandIndex)v4, WEAP_SPRINT_LOOP, WEAP_ANIM_SUPER_SPRINT_LOOP, WEAP_SPRINT_LOOP, WEAP_ANIM_ADDITIVE_SPRINT_LOOP);
          return;
        }
        if ( ((v13 - 32) & 0xFFFFFFFC) != 0 || v13 == 33 )
        {
          v23 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
          CG_Weapons_StartWeaponAnim(localClientNum, weapon, (PlayerHandIndex)v4, WEAP_IDLE, WEAP_ANIM_IDLE, WEAP_SPRINT_LOOP, WEAP_ANIM_SUPER_SPRINT_LOOP, *(float *)&v23, 1);
          return;
        }
        switch ( v13 )
        {
          case ' ':
            v19 = 337;
            v20 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x151u);
            if ( *(float *)&v20 == 0.0 )
            {
LABEL_44:
              v22 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
              CG_Weapons_StartWeaponAnim(localClientNum, weapon, (PlayerHandIndex)v4, (const WeaponAnimNumber)v13, (const weapAnimFiles_t)v19, (const WeaponAnimNumber)v13, WEAP_ANIM_SUPER_SPRINT_LOOP, *(float *)&v22, 1);
              return;
            }
            v19 = 338;
            break;
          case '"':
            v19 = 339;
            break;
          case '#':
            v19 = 341;
            break;
          default:
            return;
        }
        v21 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v19);
        if ( *(float *)&v21 != 0.0 )
          return;
        goto LABEL_44;
      }
    }
  }
}

/*
==============
CalcDistanceFactors
==============
*/
char CalcDistanceFactors(const vec3_t *listenerOrigin, const MissileConeSoundVars *mcv, float *result_line, float *result_missile)
{
  __int128 v9; 
  float v11; 
  float v12; 
  char result; 
  float result_projectedDistanceFromStart; 
  vec3_t result_projectedPoint; 

  if ( !mcv && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21947, ASSERT_TYPE_ASSERT, "(mcv)", (const char *)&queryFormat, "mcv") )
    __debugbreak();
  if ( mcv->height == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21948, ASSERT_TYPE_ASSERT, "(mcv->height != 0)", (const char *)&queryFormat, "mcv->height != 0") )
    __debugbreak();
  if ( !result_line && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21949, ASSERT_TYPE_ASSERT, "(result_line)", (const char *)&queryFormat, "result_line") )
    __debugbreak();
  if ( !result_missile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21950, ASSERT_TYPE_ASSERT, "(result_missile)", (const char *)&queryFormat, "result_missile") )
    __debugbreak();
  ProjectPointOntoVectorDir(listenerOrigin, &mcv->start, &mcv->dir, &result_projectedPoint, &result_projectedDistanceFromStart);
  v9 = LODWORD(result_projectedDistanceFromStart);
  *(float *)&v9 = result_projectedDistanceFromStart / mcv->height;
  _XMM1 = v9;
  if ( *(float *)&v9 < 0.0 )
    goto LABEL_19;
  __asm { vminss  xmm7, xmm1, xmm8 }
  v11 = (float)((float)(mcv->radiusAtBase - mcv->radiusAtTop) * *(float *)&_XMM7) + mcv->radiusAtTop;
  if ( v11 == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21965, ASSERT_TYPE_ASSERT, "(maxLineDist != 0.f)", (const char *)&queryFormat, "maxLineDist != 0.f") )
    __debugbreak();
  v12 = fsqrt((float)((float)((float)(result_projectedPoint.v[1] - listenerOrigin->v[1]) * (float)(result_projectedPoint.v[1] - listenerOrigin->v[1])) + (float)((float)(result_projectedPoint.v[0] - listenerOrigin->v[0]) * (float)(result_projectedPoint.v[0] - listenerOrigin->v[0]))) + (float)((float)(result_projectedPoint.v[2] - listenerOrigin->v[2]) * (float)(result_projectedPoint.v[2] - listenerOrigin->v[2]))) * (float)(1.0 / v11);
  if ( v12 > 1.0 )
  {
LABEL_19:
    result = 0;
    *result_line = 0.0;
    *result_missile = 0.0;
  }
  else
  {
    *result_line = v12;
    *result_missile = *(float *)&_XMM7;
    return 1;
  }
  return result;
}

/*
==============
MovementAnimState::CalcOffsetTransitionParams
==============
*/
void MovementAnimState::CalcOffsetTransitionParams(MovementAnimState *this, const LocalClientNum_t localClientNum, const XAnimTree *const animTree, const XAnimParts *const *const animArray, const MovementAnimState::State prev, const MovementAnimState::State next, const weapAnimFiles_t prevAnim, weapAnimFiles_t *outNextAnim, float *outBlendTime, float *outPrevRate, float *outNextRate)
{
  MovementAnimState::State v12; 
  __int64 v17; 
  cg_t *LocalClientGlobals; 
  weapAnimFiles_t OffsetAnimation; 
  weapAnimFiles_t *v20; 
  float *v21; 
  float *v22; 
  float v23; 
  float *v24; 
  unsigned int v25; 
  unsigned int v26; 
  __int64 v27; 
  const XAnimParts *v28; 
  double LengthFromParts; 
  const dvar_t *v31; 
  __int64 v32; 
  double Rate; 
  const XAnimParts *v34; 
  const dvar_t *v35; 
  float *outTransDurationSec; 
  float *outCycleTransDurationSec; 
  __int64 v40; 
  __int64 v41; 

  v12 = prev;
  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5362, ASSERT_TYPE_ASSERT, "( animTree ) != ( nullptr )", "%s != %s\n\t%p, %p", "animTree", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !animArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5363, ASSERT_TYPE_ASSERT, "( animArray ) != ( nullptr )", "%s != %s\n\t%p, %p", "animArray", "nullptr", NULL, NULL) )
    __debugbreak();
  v17 = next;
  if ( next == -1 )
  {
    LODWORD(v41) = next;
    LODWORD(v40) = next;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5364, ASSERT_TYPE_ASSERT, "( static_cast<int>( next ) ) != ( static_cast<int>( State::NONE ) )", "%s != %s\n\t%i, %i", "static_cast<int>( next )", "static_cast<int>( State::NONE )", v40, v41) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  *(float *)&prev = 0.0;
  MovementAnimState::GetTransitionDuration(this, localClientNum, &LocalClientGlobals->predictedPlayerState, v12, (const MovementAnimState::State)v17, (float *)&prev, (float *)&next);
  OffsetAnimation = MovementAnimState::GetOffsetAnimation(this, (const MovementAnimState::State)v17);
  v20 = outNextAnim;
  v21 = outBlendTime;
  v22 = outNextRate;
  v23 = *(float *)&prev;
  *outNextAnim = OffsetAnimation;
  v24 = outPrevRate;
  *v21 = v23;
  *v24 = 1.0;
  *v22 = 1.0;
  if ( v12 != -1 || (_DWORD)v17 )
  {
    if ( v12 == (_DWORD)v17 )
    {
      LODWORD(v41) = v17;
      LODWORD(v40) = v12;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5725, ASSERT_TYPE_ASSERT, "( static_cast<int>( prevState ) ) != ( static_cast<int>( nextState ) )", "%s != %s\n\t%i, %i", "static_cast<int>( prevState )", "static_cast<int>( nextState )", v40, v41) )
        __debugbreak();
    }
    if ( v12 != -1 || (v25 = 0, (_DWORD)v17) )
    {
      v26 = 0;
      if ( v12 != -1 )
        v26 = v12;
      if ( (_DWORD)v17 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5750, ASSERT_TYPE_ASSERT, "(nextState != State::NONE)", (const char *)&queryFormat, "nextState != State::NONE") )
        __debugbreak();
      if ( v26 >= 4 )
      {
        LODWORD(outCycleTransDurationSec) = 4;
        LODWORD(outTransDurationSec) = v26;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5751, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( prevState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions ) ) + 0 ) )", "static_cast<int>( prevState ) doesn't index ARRAY_COUNT( s_transitions )\n\t%i not in [0, %i)", outTransDurationSec, outCycleTransDurationSec) )
          __debugbreak();
      }
      v25 = v26;
      if ( (unsigned int)v17 >= 4 )
      {
        LODWORD(outCycleTransDurationSec) = 4;
        LODWORD(outTransDurationSec) = v17;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5752, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( nextState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions[0] ) ) + 0 ) )", "static_cast<int>( nextState ) doesn't index ARRAY_COUNT( s_transitions[0] )\n\t%i not in [0, %i)", outTransDurationSec, outCycleTransDurationSec) )
          __debugbreak();
      }
      v22 = outNextRate;
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5734, ASSERT_TYPE_ASSERT, "(nextState != State::WALK)", (const char *)&queryFormat, "nextState != State::WALK") )
    {
      __debugbreak();
    }
    v27 = s_transitions[v25][v17];
    if ( !(_DWORD)v27 )
    {
      LODWORD(v40) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5754, ASSERT_TYPE_ASSERT, "( static_cast<int>( transitionAnim ) ) != ( 0 )", "%s != %s\n\t%i, %i", "static_cast<int>( transitionAnim )", "0", v40, 0i64) )
        __debugbreak();
    }
    v28 = animArray[v27];
    if ( v28 )
    {
      *v20 = v27;
      LengthFromParts = XAnimGetLengthFromParts(v28);
      if ( v23 <= 0.0 )
      {
        __asm { vxorpd  xmm2, xmm2, xmm2 }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5399, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( transDurationSec )", "%s < %s\n\t%g, %g", "0.0f", "transDurationSec", *(double *)&_XMM2, v23) )
          __debugbreak();
      }
      *v22 = *(float *)&LengthFromParts / v23;
      v31 = DCONST_DVARMPFLT_movementAnimProto_TransitionBlendTime;
      if ( !DCONST_DVARMPFLT_movementAnimProto_TransitionBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_TransitionBlendTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v31);
      *v21 = v31->current.value;
    }
    v32 = prevAnim;
    if ( (unsigned int)(prevAnim - 50) <= 0xB && animArray[prevAnim] )
    {
      Rate = XAnimGetRate(animTree, 0, XANIM_SUBTREE_DEFAULT, prevAnim);
      *outPrevRate = *(float *)&Rate;
      v34 = animArray[v32];
      if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5413, ASSERT_TYPE_ASSERT, "( prevParts ) != ( nullptr )", "%s != %s\n\t%p, %p", "prevParts", "nullptr", NULL, NULL) )
        __debugbreak();
      XAnimGetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, v32);
      XAnimGetLengthFromParts(v34);
      v35 = DCONST_DVARMPFLT_movementAnimProto_TransitionToTransitionBlendTime;
      if ( !DCONST_DVARMPFLT_movementAnimProto_TransitionToTransitionBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_TransitionToTransitionBlendTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v35);
      _XMM0 = v35->current.unsignedInt;
      __asm { vminss  xmm1, xmm0, xmm6 }
      *v21 = *(float *)&_XMM1;
    }
  }
  else
  {
    *v21 = 0.0;
    if ( (unsigned int)(*v20 - 50) <= 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5384, ASSERT_TYPE_ASSERT, "(!IsOffsetAnimationTransition( outNextAnim ))", (const char *)&queryFormat, "!IsOffsetAnimationTransition( outNextAnim )") )
      __debugbreak();
  }
}

/*
==============
CalcSwimDragFriction
==============
*/
void CalcSwimDragFriction(DObj *obj, LocalClientNum_t localClientNum, const playerState_s *ps, const vec3_t (*viewAxis)[3])
{
  const dvar_t *v4; 
  float value; 
  const dvar_t *v9; 
  float v10; 
  const dvar_t *v11; 
  float v12; 
  cg_t *LocalClientGlobals; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 
  double v22; 
  float v23; 
  float v24; 
  float v25; 
  vec3_t outLookAtPos; 

  v4 = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  value = v4->current.value;
  v9 = DCONST_DVARFLT_player_swimDragHandFrictionMin;
  if ( !DCONST_DVARFLT_player_swimDragHandFrictionMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandFrictionMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  v10 = v9->current.value;
  v11 = DCONST_DVARFLT_player_swimDragHandFrictionMax;
  v25 = v10;
  if ( !DCONST_DVARFLT_player_swimDragHandFrictionMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandFrictionMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  v12 = v11->current.value;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3511, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  CalcSwimDragLookAtPosition(ps, viewAxis, &outLookAtPos);
  if ( 1.0 == ps->weapCommon.fWeaponPosFrac )
  {
    v14 = outLookAtPos.v[1];
    LocalClientGlobals->lastDragPosition.v[0] = outLookAtPos.v[0];
    LocalClientGlobals->lastDragPosition.v[2] = outLookAtPos.v[2];
    LocalClientGlobals->lastDragPosition.v[1] = v14;
  }
  else
  {
    v15 = outLookAtPos.v[0];
    v16 = outLookAtPos.v[1];
    v17 = outLookAtPos.v[2];
    v18 = LocalClientGlobals->lastDragPosition.v[0] - outLookAtPos.v[0];
    v19 = LocalClientGlobals->lastDragPosition.v[1] - outLookAtPos.v[1];
    v20 = LocalClientGlobals->lastDragPosition.v[2] - outLookAtPos.v[2];
    v21 = fsqrt((float)((float)(v19 * v19) + (float)(v18 * v18)) + (float)(v20 * v20));
    if ( value <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3526, ASSERT_TYPE_ASSERT, "( FORWARDOFFSET ) > ( 0.0f )", "%s > %s\n\t%g, %g", "FORWARDOFFSET", "0.0f", value, 0.0) )
      __debugbreak();
    v22 = I_fclamp(v21 / value, 0.0, 1.0);
    v23 = (float)((float)((float)((float)(1.0 - *(float *)&v22) * v25) + (float)(*(float *)&v22 * v12)) * _mm_cvtepi32_ps((__m128i)(unsigned int)LocalClientGlobals->frametime).m128_f32[0]) * 0.001;
    if ( (float)(v21 - v23) <= 0.0 )
    {
      LocalClientGlobals->lastDragPosition.v[0] = v15;
      LocalClientGlobals->lastDragPosition.v[1] = v16;
      LocalClientGlobals->lastDragPosition.v[2] = v17;
    }
    else
    {
      v24 = (float)(v21 - v23) / v21;
      LocalClientGlobals->lastDragPosition.v[0] = (float)(v18 * v24) + v15;
      LocalClientGlobals->lastDragPosition.v[2] = (float)(v20 * v24) + v17;
      LocalClientGlobals->lastDragPosition.v[1] = (float)(v19 * v24) + v16;
    }
  }
}

/*
==============
CalcSwimDragLookAtPosition
==============
*/
void CalcSwimDragLookAtPosition(const playerState_s *ps, const vec3_t (*viewAxis)[3], vec3_t *outLookAtPos)
{
  const dvar_t *v3; 
  float value; 

  v3 = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  value = v3->current.value;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3297, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  outLookAtPos->v[0] = (float)(value * (*viewAxis)[2].v[0]) + ps->origin.v[0];
  outLookAtPos->v[1] = (float)(value * (*viewAxis)[2].v[1]) + ps->origin.v[1];
  outLookAtPos->v[2] = (float)(value * (*viewAxis)[2].v[2]) + ps->origin.v[2];
}

/*
==============
CalcSwimDragWeights
==============
*/
void CalcSwimDragWeights(DObj *obj, LocalClientNum_t localClientNum, const playerState_s *ps, const vec3_t (*viewAxis)[3], float *dragWeights)
{
  const dvar_t *v5; 
  float value; 
  cg_t *LocalClientGlobals; 
  float v12; 
  float v14; 
  __int128 v15; 
  float v17; 
  __int128 v18; 
  float v19; 
  __m128 v20; 
  float v21; 
  float v22; 
  float v23; 
  const XAnimTree *Tree; 
  vec3_t outLookAtPos; 
  AdditiveEaseInfo easeInfoArray; 
  int v29; 
  float v30; 
  float v31; 
  int v32; 
  float v33; 
  float v34; 
  int v35; 
  float v36; 
  float v37; 
  int v38; 
  float v39; 
  float v40; 
  int v41; 
  float v42; 
  float v43; 
  int v44; 
  float v45; 
  float v46; 
  int v47; 
  float v48; 
  float v49; 
  int v50; 
  float v51; 
  float v52; 
  int v53; 
  float v54; 
  float v55; 
  int v56; 
  float v57; 
  float v58; 
  int v59; 
  float v60; 
  float v61; 
  int v62; 
  float v63; 
  float v64; 
  int v65; 
  float v66; 
  float v67; 
  int v68; 
  float v69; 
  float v70; 
  int v71; 
  float v72; 
  float v73; 
  int v74; 
  float v75; 
  float v76; 
  int v77; 
  float v78; 
  float v79; 
  int v80; 
  float v81; 
  float v82; 
  int v83; 
  float v84; 
  float v85; 
  int v86; 
  float v87; 
  float v88; 

  v5 = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  easeInfoArray.animIndex = WEAP_ANIM_SPRINT_IN;
  v29 = 339;
  v32 = 341;
  v35 = 338;
  v38 = 286;
  v41 = 287;
  v44 = 288;
  v47 = 289;
  v50 = 290;
  v53 = 291;
  v56 = 304;
  v59 = 305;
  v62 = 306;
  v65 = 307;
  v68 = 308;
  v71 = 309;
  v74 = 326;
  v77 = 327;
  v80 = 328;
  v83 = 31;
  v86 = 32;
  value = v5->current.value;
  v40 = FLOAT_0_80000001;
  v43 = FLOAT_0_80000001;
  v46 = FLOAT_0_80000001;
  v49 = FLOAT_0_80000001;
  v52 = FLOAT_0_80000001;
  v55 = FLOAT_0_80000001;
  v58 = FLOAT_0_80000001;
  v61 = FLOAT_0_80000001;
  v64 = FLOAT_0_80000001;
  v67 = FLOAT_0_80000001;
  v70 = FLOAT_0_80000001;
  v73 = FLOAT_0_80000001;
  v84 = FLOAT_0_25;
  v87 = FLOAT_0_25;
  easeInfoArray.easeOutTime = FLOAT_0_34999999;
  easeInfoArray.easeInTime = FLOAT_1_0;
  v30 = 0.0;
  v31 = FLOAT_1_0;
  v33 = 0.0;
  v34 = FLOAT_1_0;
  v36 = 0.0;
  v37 = FLOAT_0_34999999;
  v39 = FLOAT_0_1;
  v42 = FLOAT_0_1;
  v45 = FLOAT_0_1;
  v48 = FLOAT_0_1;
  v51 = FLOAT_0_1;
  v54 = FLOAT_0_1;
  v57 = FLOAT_0_34999999;
  v60 = FLOAT_0_34999999;
  v63 = FLOAT_0_34999999;
  v66 = FLOAT_0_34999999;
  v69 = FLOAT_0_34999999;
  v72 = FLOAT_0_34999999;
  v75 = 0.0;
  v76 = FLOAT_0_1;
  v78 = 0.0;
  v79 = FLOAT_0_1;
  v81 = 0.0;
  v82 = FLOAT_0_1;
  v85 = FLOAT_1_0;
  v88 = FLOAT_1_0;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3443, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  CalcSwimDragLookAtPosition(ps, viewAxis, &outLookAtPos);
  v12 = LocalClientGlobals->lastDragPosition.v[0] - outLookAtPos.v[0];
  _XMM0 = LODWORD(LocalClientGlobals->lastDragPosition.v[2]);
  v14 = *(float *)&_XMM0 - outLookAtPos.v[2];
  v15 = LODWORD(LocalClientGlobals->lastDragPosition.v[1]);
  *(float *)&v15 = LocalClientGlobals->lastDragPosition.v[1] - outLookAtPos.v[1];
  if ( value <= 0.0 )
  {
    __asm { vxorpd  xmm0, xmm0, xmm0 }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3450, ASSERT_TYPE_ASSERT, "( FORWARDOFFSET ) > ( 0.0f )", "%s > %s\n\t%g, %g", "FORWARDOFFSET", "0.0f", value, *(double *)&_XMM0) )
      __debugbreak();
  }
  v17 = (float)((float)(*(float *)&v15 * (*viewAxis)[0].v[1]) + (float)(v12 * (*viewAxis)[0].v[0])) + (float)(v14 * (*viewAxis)[0].v[2]);
  *(float *)&v15 = (float)((float)((float)(*(float *)&v15 * (*viewAxis)[1].v[1]) + (float)(v12 * (*viewAxis)[1].v[0])) + (float)(v14 * (*viewAxis)[1].v[2])) * (float)(1.0 / value);
  v18 = v15;
  v19 = v17 * (float)(1.0 / value);
  I_fclamp(v19, -1.0, 1.0);
  v20.m128_u64[1] = *((_QWORD *)&v18 + 1);
  *(double *)v20.m128_u64 = I_fclamp(*(float *)&v18, -1.0, 1.0);
  if ( v19 < 0.0 )
  {
    v21 = 0.0;
    LODWORD(v22) = LODWORD(v19) ^ _xmm;
  }
  else
  {
    v21 = v19;
    v22 = 0.0;
  }
  dragWeights[3] = v22;
  dragWeights[1] = v21;
  if ( v20.m128_f32[0] < 0.0 )
  {
    LODWORD(v23) = v18 ^ _xmm;
    v20 = 0i64;
  }
  else
  {
    v23 = 0.0;
  }
  *dragWeights = v20.m128_f32[0];
  dragWeights[2] = v23;
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3480, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  v20.m128_f32[0] = GetAdditiveAnimMax(Tree, ps, &easeInfoArray, 21);
  _XMM6 = _mm_shuffle_ps(v20, v20, 0);
  if ( v20.m128_f32[0] < 1.0 )
  {
    if ( v20.m128_f32[0] < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3485, ASSERT_TYPE_ASSERT, "( ( blendFraction >= 0.0f ) )", "( blendFraction ) = %g", v20.m128_f32[0]) )
      __debugbreak();
    __asm { vminps  xmm1, xmm6, xmmword ptr [rdi] }
    *(_OWORD *)dragWeights = _XMM1;
  }
}

/*
==============
CalcViewmodelHitPos
==============
*/
char CalcViewmodelHitPos(const LocalClientNum_t localClientNum, unsigned int eventParm, vec3_t *resultPos, vec3_t *resultNormal)
{
  unsigned __int8 v6; 
  cg_t *LocalClientGlobals; 
  const DObj *viewModelDObj; 
  float v10; 
  float v11; 
  float v12; 
  __int32 v17; 
  const centity_t *Entity; 
  unsigned int DetailPhysicsInstanceId; 
  unsigned int RigidBodyID; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  unsigned __int8 *WeaponPriorityMap; 
  float v23; 
  float v24; 
  float v25; 
  double RaycastHitFraction; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  bool resultHitFront; 
  Physics_RaycastExtendedData extendedData; 
  vec3_t start; 
  vec3_t end; 
  vec3_t result; 

  v6 = eventParm;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  viewModelDObj = LocalClientGlobals->m_weaponHand[0].viewModelDObj;
  if ( !viewModelDObj || (DObjGetContents(viewModelDObj) & 0x2806931) == 0 )
    return 0;
  BG_ShieldHitDecode(v6, &result, &resultHitFront);
  v10 = (float)((float)((float)(result.v[1] * LocalClientGlobals->refdef.view.axis.m[1].v[0]) + (float)(result.v[0] * LocalClientGlobals->refdef.view.axis.m[0].v[0])) + (float)(result.v[2] * LocalClientGlobals->refdef.view.axis.m[2].v[0])) + LocalClientGlobals->refdef.viewOffset.v[0];
  v11 = (float)((float)((float)(result.v[0] * LocalClientGlobals->refdef.view.axis.m[0].v[1]) + (float)(result.v[1] * LocalClientGlobals->refdef.view.axis.m[1].v[1])) + (float)(result.v[2] * LocalClientGlobals->refdef.view.axis.m[2].v[1])) + LocalClientGlobals->refdef.viewOffset.v[1];
  v12 = (float)((float)((float)(result.v[0] * LocalClientGlobals->refdef.view.axis.m[0].v[2]) + (float)(result.v[1] * LocalClientGlobals->refdef.view.axis.m[1].v[2])) + (float)(result.v[2] * LocalClientGlobals->refdef.view.axis.m[2].v[2])) + LocalClientGlobals->refdef.viewOffset.v[2];
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|WEAPON_LADDER_AIM) )
  {
    _XMM0 = resultHitFront;
    __asm { vpcmpeqd xmm3, xmm0, xmm1 }
    _XMM1 = LODWORD(FLOAT_100_0);
    __asm { vblendvps xmm4, xmm1, xmm2, xmm3 }
  }
  else
  {
    *(float *)&_XMM4 = FLOAT_100_0;
  }
  start.v[0] = (float)(*(float *)&_XMM4 * LocalClientGlobals->refdef.view.axis.m[0].v[0]) + v10;
  start.v[1] = (float)(*(float *)&_XMM4 * LocalClientGlobals->refdef.view.axis.m[0].v[1]) + v11;
  start.v[2] = (float)(*(float *)&_XMM4 * LocalClientGlobals->refdef.view.axis.m[0].v[2]) + v12;
  end.v[0] = (float)(COERCE_FLOAT(_XMM4 ^ _xmm) * LocalClientGlobals->refdef.view.axis.m[0].v[0]) + v10;
  end.v[1] = (float)(COERCE_FLOAT(_XMM4 ^ _xmm) * LocalClientGlobals->refdef.view.axis.m[0].v[1]) + v11;
  end.v[2] = (float)(COERCE_FLOAT(_XMM4 ^ _xmm) * LocalClientGlobals->refdef.view.axis.m[0].v[2]) + v12;
  v17 = 3 * localClientNum + 4;
  Entity = CG_GetEntity(localClientNum, LocalClientGlobals->clientNum);
  DetailPhysicsInstanceId = CG_PhysicsCharacterProxy_GetDetailPhysicsInstanceId(localClientNum, Entity);
  if ( DetailPhysicsInstanceId == -1 )
    return 0;
  RigidBodyID = Physics_GetRigidBodyID((const Physics_WorldId)v17, DetailPhysicsInstanceId, 0);
  if ( (RigidBodyID & 0xFFFFFF) == 0xFFFFFF )
    return 0;
  ClosestResult = PhysicsQuery_GetClosestResult((Physics_WorldId)v17);
  HavokPhysics_CollisionQueryResult::Reset(ClosestResult, 1);
  WeaponPriorityMap = BG_GetWeaponPriorityMap(&NULL_WEAPON, 0);
  Physics_AddDetailTrace(ClosestResult, WeaponPriorityMap);
  extendedData.ignoreBodies = NULL;
  extendedData.phaseSelection = All;
  extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
  extendedData.collisionBuffer = 0.0;
  *(_WORD *)&extendedData.collectInsideHits = 256;
  extendedData.contents = 41969969;
  extendedData.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_DETAIL;
  Physics_Raycast((Physics_WorldId)v17, RigidBodyID, &start, &end, &extendedData, ClosestResult);
  if ( !HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
    return 0;
  HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(ClosestResult, 0, resultNormal);
  v23 = end.v[1];
  resultPos->v[0] = end.v[0] - start.v[0];
  v24 = v23 - start.v[1];
  v25 = end.v[2];
  resultPos->v[1] = v24;
  resultPos->v[2] = v25 - start.v[2];
  RaycastHitFraction = HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(ClosestResult, 0);
  v27 = (float)(*(float *)&RaycastHitFraction * resultPos->v[2]) + start.v[2];
  v28 = (float)(*(float *)&RaycastHitFraction * resultPos->v[0]) + start.v[0];
  v29 = (float)(*(float *)&RaycastHitFraction * resultPos->v[1]) + start.v[1];
  v30 = MY_TWEAK_FORWARD;
  resultPos->v[2] = v27;
  resultPos->v[0] = v28;
  resultPos->v[1] = v29;
  resultPos->v[0] = (float)(v30 * resultNormal->v[0]) + v28;
  resultPos->v[1] = (float)(v30 * resultNormal->v[1]) + v29;
  resultPos->v[2] = (float)(v30 * resultNormal->v[2]) + v27;
  return 1;
}

/*
==============
CgWeaponSystem::CalculateTagOffset
==============
*/
char CgWeaponSystem::CalculateTagOffset(CgWeaponSystem *this, const int entNum, scr_string_t tagName, const vec3_t *worldPos, vec3_t *outTagOffset)
{
  centity_t *Entity; 
  const DObj *ClientDObj; 
  const DObj *v11; 
  int v14; 
  unsigned __int8 inOutIndex[4]; 
  int modelIndex; 
  tmat43_t<vec3_t> outTagMat; 

  if ( (unsigned int)entNum >= 0x800 )
  {
    v14 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24009, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, v14) )
      __debugbreak();
  }
  *(_QWORD *)outTagOffset->v = 0i64;
  outTagOffset->v[2] = 0.0;
  Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, entNum);
  if ( (Entity->flags & 1) == 0 )
    return 0;
  ClientDObj = Com_GetClientDObj(entNum, this->m_localClientNum);
  v11 = ClientDObj;
  if ( !ClientDObj )
    return 0;
  inOutIndex[0] = -2;
  if ( !DObjGetBoneIndexInternal_66(ClientDObj, tagName, inOutIndex, &modelIndex) || !CG_DObjGetWorldBoneMatrix(&Entity->pose, v11, inOutIndex[0], (tmat33_t<vec3_t> *)&outTagMat, &outTagMat.m[3]) )
    return 0;
  MatrixTransposeTransformVector43(worldPos, &outTagMat, outTagOffset);
  return 1;
}

/*
==============
CgWeaponSystem::ChargeWeaponOnRespawn
==============
*/
void CgWeaponSystem::ChargeWeaponOnRespawn(CgWeaponSystem *this, const playerState_s *ps)
{
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v5; 
  const RumbleInfo *rumble; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17265, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  v5 = InfoStruct;
  if ( InfoStruct )
  {
    rumble = InfoStruct->soundRumbleInfo[0].rumble;
    if ( rumble )
    {
      if ( CG_Rumble_IsActive(this->m_localClientNum, ps->clientNum, rumble) )
        CgWeaponSystem::ChargedWeaponStopRumble(this, v5->soundRumbleInfo);
      else
        v5->soundRumbleInfo[0].rumble = NULL;
    }
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17269, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
  {
    __debugbreak();
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride
==============
*/
void CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps)
{
  ClientChargeWeaponInfo *InfoStruct; 
  __int64 m_localClientNum; 
  int WeaponHandForViewWeapon; 
  int *weaponChargeAmountOverride; 
  __int64 i; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17171, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17175, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  InfoStruct->weaponChargeAmountLerpStartTime = 0;
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  WeaponHandForViewWeapon = BG_PlayerLastWeaponHandForViewWeapon(CgWeaponMap::ms_instance[m_localClientNum], ps);
  if ( WeaponHandForViewWeapon >= 0 )
  {
    weaponChargeAmountOverride = InfoStruct->weaponChargeAmountOverride;
    for ( i = WeaponHandForViewWeapon + 1i64; i; --i )
      *weaponChargeAmountOverride++ = 0;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponClearViewModelFX
==============
*/
void CgWeaponSystem::ChargedWeaponClearViewModelFX(CgWeaponSystem *this, const centity_t *cent)
{
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v4; 
  unsigned int i; 
  scr_string_t MeterBoneName; 
  FXRegisteredDef fxDef; 

  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  v4 = InfoStruct;
  if ( InfoStruct && InfoStruct->fxSlotsPlaying > 0 )
  {
    fxDef.m_particleSystemDef = InfoStruct->fxTypePlaying.m_particleSystemDef;
    if ( fxDef.m_particleSystemDef )
    {
      for ( i = 0; i < BG_WeaponCharge_GetMeterBoneMaxCount(); ++i )
      {
        MeterBoneName = BG_WeaponCharge_GetMeterBoneName(i);
        CG_KillBoltedEffects(this->m_localClientNum, &fxDef, 2048, MeterBoneName);
      }
    }
    v4->fxSlotsPlaying = 0;
    v4->fxTypePlaying.m_particleSystemDef = NULL;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponGetChargeAmount
==============
*/
__int64 CgWeaponSystem::ChargedWeaponGetChargeAmount(CgWeaponSystem *this, const playerState_s *ps, const PlayerHandIndex hand)
{
  __int64 v3; 
  ClientChargeWeaponInfo *InfoStruct; 
  __int64 result; 
  __int64 v8; 

  v3 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17498, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v3 >= 2 )
  {
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17499, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v8, 2) )
      __debugbreak();
  }
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17503, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  result = (unsigned int)InfoStruct->weaponChargeAmountOverride[v3];
  if ( (int)result <= 0 )
    return (unsigned int)ps->weapState[v3].weaponChargeAmount;
  return result;
}

/*
==============
CgWeaponSystem::ChargedWeaponGetInfoStruct
==============
*/
ClientChargeWeaponInfo *CgWeaponSystem::ChargedWeaponGetInfoStruct(CgWeaponSystem *this, const int entNum)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 

  v2 = entNum;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17517, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( ((int)v2 < 0 || (unsigned int)v2 >= 0xF8) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17519, ASSERT_TYPE_ASSERT, "(( entNum >= 0 ) && ( entNum < ( sizeof( *array_counter( cgameGlob->chargeWeaponInfo ) ) + 0 ) ))", (const char *)&queryFormat, "( entNum >= 0 ) && ( entNum < ARRAY_COUNT( cgameGlob->chargeWeaponInfo ) )") )
    __debugbreak();
  return &LocalClientGlobals->chargeWeaponInfo[v2];
}

/*
==============
CgWeaponSystem::ChargedWeaponOnBeginCharging
==============
*/
void CgWeaponSystem::ChargedWeaponOnBeginCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  const char *name; 
  CgSoundSystem *SoundSystem; 
  const char *v14; 
  int number; 
  CgSoundSystem *v16; 
  const RumbleInfo *Rumble; 
  cg_t *LocalClientGlobals; 
  int isPlayerViewa; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17072, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &cent->nextState;
  if ( cent == (const centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17074, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  CgWeaponSystem::ChargedWeaponUpdateWeaponType(this, cent, weapon, isAlternate, isPlayerView);
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeDownSound);
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeMaxSound);
  if ( soundRumbleInfo->lastState == CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_DOWN )
  {
    name = BG_WeaponCharge_GetChargeDownToUpSound(weapon, isAlternate, isPlayerView).name;
    isPlayerViewa = p_nextState->number;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, isPlayerViewa, (SndAliasLookup)name);
    soundRumbleInfo->chargeDownToUpSound.name = name;
  }
  v14 = BG_WeaponCharge_GetChargeUpSound(weapon, isAlternate, isPlayerView).name;
  number = p_nextState->number;
  v16 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::PlayEntitySoundAliasByLookup(v16, number, (SndAliasLookup)v14);
  soundRumbleInfo->chargeUpSound.name = v14;
  if ( ps )
  {
    if ( !CG_Rumble_ShouldNotRumble(this->m_localClientNum) && !soundRumbleInfo->rumble )
    {
      Rumble = BG_WeaponCharge_GetRumble(weapon, isAlternate);
      if ( Rumble )
      {
        LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
        if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17409, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
          __debugbreak();
        CG_Rumble_PlayDeferred(this->m_localClientNum, Rumble, RUMBLELOOP_LOOP_NOENTFLAG, RUMBLESOURCE_ENTITY, LocalClientGlobals->predictedPlayerState.clientNum, NULL, 1.0, 0);
        soundRumbleInfo->rumble = Rumble;
      }
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponOnEmptyCharge
==============
*/
void CgWeaponSystem::ChargedWeaponOnEmptyCharge(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  CgSoundSystem *SoundSystem; 
  const char *name; 
  const char *v12; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17138, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &cent->nextState;
  if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17142, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( BG_WeaponCharge_GetType(weapon, isAlternate) == PTRDIFF )
  {
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17148, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::StopSoundAlias(SoundSystem, p_nextState->number, soundRumbleInfo->chargeUpSound);
    name = soundRumbleInfo->chargeDownToUpSound.name;
    soundRumbleInfo->chargeUpSound.name = NULL;
    CgSoundSystem::StopSoundAlias(SoundSystem, p_nextState->number, (SndAliasLookup)name);
    v12 = soundRumbleInfo->chargeMaxSound.name;
    soundRumbleInfo->chargeDownToUpSound.name = NULL;
    CgSoundSystem::StopSoundAlias(SoundSystem, p_nextState->number, (SndAliasLookup)v12);
    soundRumbleInfo->chargeMaxSound.name = NULL;
    CgWeaponSystem::ChargedWeaponStopRumble(this, soundRumbleInfo);
  }
  else
  {
    CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(this, p_nextState->number, soundRumbleInfo);
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponOnMaxCharge
==============
*/
void CgWeaponSystem::ChargedWeaponOnMaxCharge(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  const char *name; 
  int number; 
  CgSoundSystem *SoundSystem; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17117, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( BG_WeaponCharge_GetType(weapon, isAlternate) == LONG_LONG )
  {
    p_nextState = &cent->nextState;
    if ( cent == (const centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17127, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeUpSound);
    CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeDownSound);
    name = BG_WeaponCharge_GetChargeMaxSound(weapon, isAlternate, isPlayerView).name;
    number = p_nextState->number;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, number, (SndAliasLookup)name);
    soundRumbleInfo->chargeMaxSound.name = name;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponOnStopCharging
==============
*/
void CgWeaponSystem::ChargedWeaponOnStopCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  const char *name; 
  CgSoundSystem *SoundSystem; 
  const char *v14; 
  int number; 
  CgSoundSystem *v16; 
  int soundRumbleInfoa; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17095, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &cent->nextState;
  if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17097, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeUpSound);
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeMaxSound);
  if ( soundRumbleInfo->lastState == CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_UP )
  {
    name = BG_WeaponCharge_GetChargeUpToDownSound(weapon, isAlternate, isPlayerView).name;
    soundRumbleInfoa = p_nextState->number;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, soundRumbleInfoa, (SndAliasLookup)name);
    soundRumbleInfo->chargeUpToDownSound.name = name;
  }
  v14 = BG_WeaponCharge_GetChargeDownSound(weapon, isAlternate, isPlayerView).name;
  number = p_nextState->number;
  v16 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::PlayEntitySoundAliasByLookup(v16, number, (SndAliasLookup)v14);
  soundRumbleInfo->chargeDownSound.name = v14;
  if ( ps )
    CgWeaponSystem::ChargedWeaponStopRumble(this, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::ChargedWeaponPlaySound
==============
*/
SndAliasLookup CgWeaponSystem::ChargedWeaponPlaySound(CgWeaponSystem *this, char *entNum, SndAliasLookup sndAliasLookup, SndAliasLookup a4)
{
  int name; 
  CgSoundSystem *SoundSystem; 
  SndAliasLookup result; 

  name = (int)sndAliasLookup.name;
  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, name, a4);
  result.name = entNum;
  *(SndAliasLookup *)entNum = a4;
  return result;
}

/*
==============
CgWeaponSystem::ChargedWeaponSetChargeAmountOverride
==============
*/
void CgWeaponSystem::ChargedWeaponSetChargeAmountOverride(CgWeaponSystem *this, const centity_t *cent, const PlayerHandIndex hand, const int chargeAmount)
{
  __int64 v4; 
  ClientChargeWeaponInfo *InfoStruct; 

  v4 = hand;
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17485, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hand, 2) )
    __debugbreak();
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17489, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  InfoStruct->weaponChargeAmountAtTimeOfFire[v4] = chargeAmount;
  InfoStruct->weaponChargeAmountOverride[v4] = chargeAmount;
}

/*
==============
CgWeaponSystem::ChargedWeaponStartRumble
==============
*/
void CgWeaponSystem::ChargedWeaponStartRumble(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  const RumbleInfo *Rumble; 
  cg_t *LocalClientGlobals; 

  if ( !soundRumbleInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17396, ASSERT_TYPE_ASSERT, "(soundRumbleInfo)", (const char *)&queryFormat, "soundRumbleInfo") )
    __debugbreak();
  if ( !CG_Rumble_ShouldNotRumble(this->m_localClientNum) && !soundRumbleInfo->rumble )
  {
    Rumble = BG_WeaponCharge_GetRumble(weapon, isAlternate);
    if ( Rumble )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
      if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17409, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
        __debugbreak();
      CG_Rumble_PlayDeferred(this->m_localClientNum, Rumble, RUMBLELOOP_LOOP_NOENTFLAG, RUMBLESOURCE_ENTITY, LocalClientGlobals->predictedPlayerState.clientNum, NULL, 1.0, 0);
      soundRumbleInfo->rumble = Rumble;
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllEffects
==============
*/
void CgWeaponSystem::ChargedWeaponStopAllEffects(CgWeaponSystem *this, const centity_t *cent)
{
  ClientChargeWeaponInfo *InfoStruct; 

  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  if ( InfoStruct )
  {
    if ( InfoStruct->currentWeapon.weaponIdx )
      CgWeaponSystem::ChargedWeaponClearViewModelFX(this, cent);
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble
==============
*/
void CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(CgWeaponSystem *this, const int entNum, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  CgSoundSystem *SoundSystem; 
  const char *name; 
  const char *v8; 
  const char *v9; 
  const char *v10; 

  if ( !soundRumbleInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16824, ASSERT_TYPE_ASSERT, "(soundRumbleInfo)", (const char *)&queryFormat, "soundRumbleInfo") )
    __debugbreak();
  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16827, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, soundRumbleInfo->chargeUpSound);
  name = soundRumbleInfo->chargeDownSound.name;
  soundRumbleInfo->chargeUpSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)name);
  v8 = soundRumbleInfo->chargeUpToDownSound.name;
  soundRumbleInfo->chargeDownSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)v8);
  v9 = soundRumbleInfo->chargeDownToUpSound.name;
  soundRumbleInfo->chargeUpToDownSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)v9);
  v10 = soundRumbleInfo->chargeMaxSound.name;
  soundRumbleInfo->chargeDownToUpSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)v10);
  soundRumbleInfo->chargeUpSound.name = NULL;
  CgWeaponSystem::ChargedWeaponStopRumble(this, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopRumble
==============
*/
void CgWeaponSystem::ChargedWeaponStopRumble(CgWeaponSystem *this, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  cg_t *LocalClientGlobals; 

  if ( !soundRumbleInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17421, ASSERT_TYPE_ASSERT, "(soundRumbleInfo)", (const char *)&queryFormat, "soundRumbleInfo") )
    __debugbreak();
  if ( !CG_Rumble_ShouldNotRumble(this->m_localClientNum) && soundRumbleInfo->rumble )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17431, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    CG_Rumble_StopDeferred(this->m_localClientNum, soundRumbleInfo->rumble, LocalClientGlobals->predictedPlayerState.clientNum);
    soundRumbleInfo->rumble = NULL;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponStopSound
==============
*/
void CgWeaponSystem::ChargedWeaponStopSound(CgWeaponSystem *this, const int entNum, SndAliasLookup *sndAliasLookup)
{
  CgSoundSystem *SoundSystem; 

  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17063, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)sndAliasLookup->name);
  sndAliasLookup->name = NULL;
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdate
==============
*/
void CgWeaponSystem::ChargedWeaponUpdate(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel, int bDrawGun)
{
  cg_t *LocalClientGlobals; 
  entityState_t *p_nextState; 
  int number; 
  CgWeaponMap *Instance; 
  bool v14; 
  ClientChargeWeaponInfo *v15; 
  ClientChargeWeaponInfo *v16; 
  int clientNum; 
  ClientChargeWeaponInfo *InfoStruct; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  p_nextState = &cent->nextState;
  number = cent->nextState.number;
  clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
  if ( clientNum != number || bViewModel || (ps = &LocalClientGlobals->predictedPlayerState, LocalClientGlobals->renderingThirdPerson) || (Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)this->m_localClientNum), BG_IsThirdPersonMode(Instance, ps)) )
  {
    if ( ps )
    {
      v14 = ps->pm_type >= 7;
    }
    else
    {
      if ( cent == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2004, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
        __debugbreak();
      v14 = GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cent->nextState.lerp.eFlags, ACTIVE, 0x11u);
    }
    CgWeaponSystem::ChargedWeaponUpdateWeaponType(this, cent, weapon, isAlternate, bViewModel);
    InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, p_nextState->number);
    if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17024, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
      __debugbreak();
    if ( clientNum == number && ps )
    {
      v15 = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16975, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
        __debugbreak();
      *(double *)&v15->prevWeapHands[0].weaponChargeAmount = *(double *)&v15->weapHands[0].weaponChargeAmount;
      v15->weapHands[0].weaponChargeAmount = ps->weapState[0].weaponChargeAmount;
      v15->weapHands[1].weaponChargeAmount = ps->weapState[1].weaponChargeAmount;
    }
    CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound(this, ps, cent, weapon, isAlternate, bViewModel);
    if ( bViewModel )
    {
      if ( !v14 && InfoStruct->currentWeapon.weaponIdx && bDrawGun )
      {
        if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17042, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        CgWeaponSystem::ChargedWeaponUpdateViewModelFX(this, ps, cent, weapon, isAlternate);
      }
      else
      {
        CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(this, ps);
        v16 = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, p_nextState->number);
        if ( v16 && v16->currentWeapon.weaponIdx )
          CgWeaponSystem::ChargedWeaponClearViewModelFX(this, cent);
      }
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer(CgWeaponSystem *this, const playerState_s *ps)
{
  ClientChargeWeaponInfo *InfoStruct; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16971, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16975, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  *(double *)&InfoStruct->prevWeapHands[0].weaponChargeAmount = *(double *)&InfoStruct->weapHands[0].weaponChargeAmount;
  InfoStruct->weapHands[0].weaponChargeAmount = ps->weapState[0].weaponChargeAmount;
  InfoStruct->weapHands[1].weaponChargeAmount = ps->weapState[1].weaponChargeAmount;
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot(CgWeaponSystem *this, const int entityNum, const CharacterChargedWeaponInfo *characterChargedWeaponInfo)
{
  ClientChargeWeaponInfo *InfoStruct; 

  if ( !characterChargedWeaponInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16945, ASSERT_TYPE_ASSERT, "(characterChargedWeaponInfo)", (const char *)&queryFormat, "characterChargedWeaponInfo") )
    __debugbreak();
  if ( CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->predictedPlayerState.clientNum != entityNum )
  {
    InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, entityNum);
    if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16957, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
      __debugbreak();
    *(double *)&InfoStruct->prevWeapHands[0].weaponChargeAmount = *(double *)&InfoStruct->weapHands[0].weaponChargeAmount;
    InfoStruct->weapHands[0].weaponChargeAmount = characterChargedWeaponInfo->weaponChargeAmount[0];
    InfoStruct->weapHands[1].weaponChargeAmount = characterChargedWeaponInfo->weaponChargeAmount[1];
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate)
{
  __int64 v7; 
  ClientChargeWeaponInfo *InfoStruct; 
  __int64 v10; 
  cg_t *LocalClientGlobals; 
  cg_t *v12; 
  CgWeaponMap *Instance; 
  int v14; 
  int FireWeaponAnim; 
  CgHandler *Handler; 
  bool v17; 
  weapAnimFiles_t v18; 
  CgHandler *v19; 
  int FireAnimTime; 
  int v21; 
  double EmptyCooldown; 
  int v23; 
  int v24; 
  int v25; 
  unsigned int shotCount; 
  PlayerHandIndex fireTime; 
  int v28; 
  int fireDelay; 
  bool v30; 

  v7 = hand;
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17190, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  v10 = v7;
  if ( ps->weapState[v7].weaponState == 16 || !InfoStruct->weaponChargeAmountOverride[v7] )
  {
    InfoStruct->weaponChargeAmountLerpStartTime = 0;
  }
  else
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    v12 = LocalClientGlobals;
    if ( !InfoStruct->weaponChargeAmountLerpStartTime )
      InfoStruct->weaponChargeAmountLerpStartTime = LocalClientGlobals->time;
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)this->m_localClientNum);
    v14 = BG_PlayerDualWielding(ps);
    shotCount = ps->weapState[v7].weaponShotCount;
    v30 = v14 != 0;
    BG_GetFireTime(Instance, ps, weapon, isAlternate, v14 != 0, shotCount, &v28, &fireDelay);
    if ( PM_WeaponClipEmpty(Instance, ps, (PlayerHandIndex)v7) )
    {
      FireWeaponAnim = PM_Weapon_GetFireWeaponAnim(Instance, ps, (PlayerHandIndex)v7);
      Handler = CgHandler::getHandler(this->m_localClientNum);
      fireTime = (int)v7;
      v17 = isAlternate;
      v18 = BG_MapWeaponAnimStateToAnimIndex(Instance, ps, FireWeaponAnim, 0, weapon, isAlternate, fireTime, Handler);
      v19 = CgHandler::getHandler(this->m_localClientNum);
      FireAnimTime = BG_GetFireAnimTime(weapon, v17, v30, ps, v19, v18);
      v21 = v28;
      if ( FireAnimTime )
        v21 = FireAnimTime;
      v28 = v21;
    }
    else
    {
      v17 = isAlternate;
    }
    EmptyCooldown = BG_WeaponCharge_GetEmptyCooldown(weapon, v17);
    v23 = (int)(float)(*(float *)&EmptyCooldown * 1000.0) - v28;
    if ( (float)v23 <= 0.0 )
      v23 = 300;
    v24 = v23 - I_clamp(v12->time - InfoStruct->weaponChargeAmountLerpStartTime, 0, v23);
    if ( v24 > 0 )
    {
      v25 = (int)(float)((float)((float)v24 / (float)v23) * (float)InfoStruct->weaponChargeAmountAtTimeOfFire[v10]);
      InfoStruct->weaponChargeAmountOverride[v10] = v25;
      if ( !v25 )
        InfoStruct->weaponChargeAmountAtTimeOfFire[v10] = 0;
    }
    else
    {
      InfoStruct->weaponChargeAmountAtTimeOfFire[v10] = 0;
      InfoStruct->weaponChargeAmountOverride[v10] = 0;
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel)
{
  const Weapon *v6; 
  centity_t *v7; 
  entityState_t *p_nextState; 
  ClientChargeWeaponInfo *InfoStruct; 
  bool v11; 
  bool IsChargeShotWeapon; 
  __int64 v13; 
  int v14; 
  ClientChargeWeaponSoundRumbleInfo *v15; 
  int weaponChargeAmount; 
  int v17; 
  int lastState; 
  const char *name; 
  int number; 
  CgSoundSystem *SoundSystem; 
  CgSoundSystem *v22; 
  bool v23; 
  const char *v24; 
  int v25; 
  CgSoundSystem *v26; 
  const char *v27; 
  int v28; 
  CgSoundSystem *v29; 
  __int16 eType; 
  __int64 m_localClientNum; 
  CgCompassSystem *v32; 
  void (__fastcall *FunctionPointer_origin)(const vec4_t *, vec3_t *); 
  __int128 v37; 
  __int64 isPlayerView; 
  ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo; 
  bool v49; 
  __int64 v50; 
  ClientChargeWeaponInfo *v51; 
  vec3_t origin; 

  v6 = weapon;
  v7 = cent;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16850, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &v7->nextState;
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, v7->nextState.number);
  v51 = InfoStruct;
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16854, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  v11 = isAlternate;
  IsChargeShotWeapon = BG_IsChargeShotWeapon(v6, isAlternate);
  v49 = IsChargeShotWeapon;
  v13 = 0i64;
  v50 = 0i64;
  v14 = bViewModel;
  do
  {
    v15 = &InfoStruct->soundRumbleInfo[v13];
    if ( !IsChargeShotWeapon )
    {
      CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(this, p_nextState->number, &InfoStruct->soundRumbleInfo[v13]);
      v15->lastState = CHARGE_WEAPON_SOUND_RUMBLE_STATE_NONE;
      goto LABEL_56;
    }
    weaponChargeAmount = InfoStruct->prevWeapHands[v13].weaponChargeAmount;
    v17 = InfoStruct->weapHands[v13].weaponChargeAmount;
    if ( v17 == 4095 )
    {
      lastState = 4;
      if ( BG_WeaponCharge_GetType(v6, v11) == LONG_LONG )
      {
        if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17127, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
          __debugbreak();
        CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v15->chargeUpSound);
        CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v15->chargeDownSound);
        name = BG_WeaponCharge_GetChargeMaxSound(v6, v11, bViewModel != 0).name;
        number = p_nextState->number;
        SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
        if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
          __debugbreak();
        CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, number, (SndAliasLookup)name);
        v15->chargeMaxSound.name = name;
        v7 = cent;
        v6 = weapon;
        v11 = isAlternate;
      }
      goto LABEL_60;
    }
    if ( !v17 )
    {
      lastState = 3;
      if ( v15->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_EMPTY )
      {
        if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17142, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
          __debugbreak();
        if ( BG_WeaponCharge_GetType(v6, v11) == PTRDIFF )
        {
          v22 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
          if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17148, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
            __debugbreak();
          CgSoundSystem::StopSoundAlias(v22, p_nextState->number, v15->chargeUpSound);
          v15->chargeUpSound.name = NULL;
          CgSoundSystem::StopSoundAlias(v22, p_nextState->number, v15->chargeDownToUpSound);
          v15->chargeDownToUpSound.name = NULL;
          CgSoundSystem::StopSoundAlias(v22, p_nextState->number, v15->chargeMaxSound);
          v15->chargeMaxSound.name = NULL;
          CgWeaponSystem::ChargedWeaponStopRumble(this, v15);
        }
        else
        {
          CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(this, p_nextState->number, v15);
        }
        v14 = bViewModel;
      }
      if ( v14 && !v13 && !v51->weaponChargeAmountOverride[0] )
        CgWeaponSystem::ChargedWeaponClearViewModelFX(this, v7);
      goto LABEL_55;
    }
    if ( v17 > weaponChargeAmount )
    {
      lastState = 1;
      if ( v15->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_UP )
        CgWeaponSystem::ChargedWeaponOnBeginCharging(this, ps, v7, v6, v11, v14 != 0, v15);
LABEL_60:
      if ( !BG_WeaponCharge_GetHudReveal(v6, v11) )
        goto LABEL_55;
      if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1921, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
        __debugbreak();
      eType = p_nextState->eType;
      if ( (((eType - 1) & 0xFFED) != 0 || eType == 3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16930, ASSERT_TYPE_ASSERT, "(BG_IsCharacterEntity( &cent->nextState ))", (const char *)&queryFormat, "BG_IsCharacterEntity( &cent->nextState )") )
        __debugbreak();
      m_localClientNum = this->m_localClientNum;
      if ( !(_BYTE)CgCompassSystem::ms_allocatedType )
      {
        LODWORD(soundRumbleInfo) = this->m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 575, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type is not known\n", "ms_allocatedType != GameModeType::NONE", soundRumbleInfo) )
          __debugbreak();
      }
      if ( (unsigned int)m_localClientNum >= CgCompassSystem::ms_allocatedCount )
      {
        LODWORD(soundRumbleInfo) = CgCompassSystem::ms_allocatedCount;
        LODWORD(isPlayerView) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 576, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", isPlayerView, soundRumbleInfo) )
          __debugbreak();
      }
      if ( !CgCompassSystem::ms_compassSystemArray[m_localClientNum] )
      {
        LODWORD(soundRumbleInfo) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 577, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", soundRumbleInfo) )
          __debugbreak();
      }
      v32 = CgCompassSystem::ms_compassSystemArray[m_localClientNum];
      if ( !v7->pose.origin.Get_origin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 380, ASSERT_TYPE_ASSERT, "(pose->origin.Get_origin)", (const char *)&queryFormat, "pose->origin.Get_origin") )
        __debugbreak();
      FunctionPointer_origin = ObfuscateGetFunctionPointer_origin(v7->pose.origin.Get_origin, &v7->pose);
      FunctionPointer_origin(&v7->pose.origin.origin.origin, &origin);
      if ( v7->pose.isPosePrecise )
      {
        _XMM0 = LODWORD(origin.v[0]);
        __asm { vcvtdq2pd xmm0, xmm0 }
        *((_QWORD *)&v37 + 1) = *((_QWORD *)&_XMM0 + 1);
        *(double *)&v37 = *(double *)&_XMM0 * 0.000244140625;
        _XMM1 = v37;
        __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
        origin.v[0] = *(float *)&_XMM2;
        _XMM0 = LODWORD(origin.v[1]);
        __asm { vcvtdq2pd xmm0, xmm0 }
        *((_QWORD *)&v37 + 1) = *((_QWORD *)&_XMM0 + 1);
        *(double *)&v37 = *(double *)&_XMM0 * 0.000244140625;
        _XMM1 = v37;
        __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
        origin.v[1] = *(float *)&_XMM2;
        _XMM0 = LODWORD(origin.v[2]);
        __asm { vcvtdq2pd xmm0, xmm0 }
        *((_QWORD *)&v37 + 1) = *((_QWORD *)&_XMM0 + 1);
        *(double *)&v37 = *(double *)&_XMM0 * 0.000244140625;
        _XMM1 = v37;
        __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
        origin.v[2] = *(float *)&_XMM2;
      }
      CgCompassSystem::AddContinuousPingInfo(v32, v7, &origin);
      memset(&origin, 0, sizeof(origin));
      goto LABEL_54;
    }
    if ( v17 >= weaponChargeAmount )
    {
      lastState = v15->lastState;
      if ( v15->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_MAX && lastState != 1 )
        goto LABEL_55;
      goto LABEL_60;
    }
    lastState = 2;
    if ( v15->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_DOWN )
    {
      v23 = v14 != 0;
      if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17097, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
        __debugbreak();
      CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v15->chargeUpSound);
      CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v15->chargeMaxSound);
      if ( v15->lastState == CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_UP )
      {
        v24 = BG_WeaponCharge_GetChargeUpToDownSound(v6, v11, v23).name;
        v25 = p_nextState->number;
        v26 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
        if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
          __debugbreak();
        CgSoundSystem::PlayEntitySoundAliasByLookup(v26, v25, (SndAliasLookup)v24);
        v15->chargeUpToDownSound.name = v24;
        v6 = weapon;
        v11 = isAlternate;
      }
      v27 = BG_WeaponCharge_GetChargeDownSound(v6, v11, v23).name;
      v28 = p_nextState->number;
      v29 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
      if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
        __debugbreak();
      CgSoundSystem::PlayEntitySoundAliasByLookup(v29, v28, (SndAliasLookup)v27);
      v15->chargeDownSound.name = v27;
      if ( ps )
        CgWeaponSystem::ChargedWeaponStopRumble(this, v15);
      v13 = v50;
LABEL_54:
      v11 = isAlternate;
    }
LABEL_55:
    v15->lastState = lastState;
    v7 = cent;
    v6 = weapon;
    InfoStruct = v51;
LABEL_56:
    v50 = ++v13;
    v14 = bViewModel;
    IsChargeShotWeapon = v49;
  }
  while ( v13 < 2 );
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateViewModelFX
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateViewModelFX(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate)
{
  bool v9; 
  FxCombinedDef v10; 
  unsigned int MeterBoneCount; 
  cg_t *LocalClientGlobals; 
  WeaponHand *m_weaponHand; 
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v15; 
  int weaponChargeAmount; 
  int v17; 
  signed int fxSlotsPlaying; 
  int v19; 
  scr_string_t MeterBoneName; 
  unsigned int v21; 
  scr_string_t v22; 
  const ParticleSystemDef *m_particleSystemDef; 
  __int64 v24; 
  __int64 v25; 
  FXRegisteredDef fxDef; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17293, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17294, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  v9 = isAlternate;
  v10.particleSystemDef = BG_WeaponCharge_GetMeterEffect(weapon, isAlternate).particleSystemDef;
  if ( v10.particleSystemDef )
  {
    fxDef.m_particleSystemDef = v10.particleSystemDef;
    MeterBoneCount = BG_WeaponCharge_GetMeterBoneCount(weapon, v9);
    if ( MeterBoneCount )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
      if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17311, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
        __debugbreak();
      m_weaponHand = LocalClientGlobals->m_weaponHand;
      if ( !m_weaponHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17316, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
        __debugbreak();
      if ( m_weaponHand->viewModelDObj )
      {
        InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
        if ( InfoStruct )
        {
          CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride(this, ps, cent, WEAPON_HAND_DEFAULT, weapon, v9);
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17498, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          v15 = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
          if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17503, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
            __debugbreak();
          weaponChargeAmount = v15->weaponChargeAmountOverride[0];
          if ( weaponChargeAmount <= 0 )
            weaponChargeAmount = ps->weapState[0].weaponChargeAmount;
          v17 = BG_WeaponCharge_CalcNumTagsUsed(weapon, v9, weaponChargeAmount);
          fxSlotsPlaying = InfoStruct->fxSlotsPlaying;
          v19 = v17;
          if ( fxSlotsPlaying < v17 )
          {
            do
            {
              if ( fxSlotsPlaying >= MeterBoneCount )
              {
                LODWORD(v25) = MeterBoneCount;
                LODWORD(v24) = fxSlotsPlaying;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17337, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( tagCount )", "i doesn't index tagCount\n\t%i not in [0, %i)", v24, v25) )
                  __debugbreak();
              }
              if ( InfoStruct->fxSlotsPlaying >= (signed int)MeterBoneCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17338, ASSERT_TYPE_ASSERT, "(chargeWeapInfo->fxSlotsPlaying < tagCount)", (const char *)&queryFormat, "chargeWeapInfo->fxSlotsPlaying < tagCount") )
                __debugbreak();
              ++InfoStruct->fxSlotsPlaying;
              MeterBoneName = BG_WeaponCharge_GetMeterBoneName(fxSlotsPlaying);
              CG_PlayBoltedEffect(this->m_localClientNum, &fxDef, 2048, MeterBoneName);
              ++fxSlotsPlaying;
            }
            while ( fxSlotsPlaying < v19 );
            fxSlotsPlaying = InfoStruct->fxSlotsPlaying;
          }
          v21 = fxSlotsPlaying - 1;
          if ( fxSlotsPlaying - 1 >= v19 )
          {
            do
            {
              if ( v21 >= MeterBoneCount )
              {
                LODWORD(v25) = MeterBoneCount;
                LODWORD(v24) = v21;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17346, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( tagCount )", "i doesn't index tagCount\n\t%i not in [0, %i)", v24, v25) )
                  __debugbreak();
              }
              if ( InfoStruct->fxSlotsPlaying <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17347, ASSERT_TYPE_ASSERT, "(chargeWeapInfo->fxSlotsPlaying > 0)", (const char *)&queryFormat, "chargeWeapInfo->fxSlotsPlaying > 0") )
                __debugbreak();
              --InfoStruct->fxSlotsPlaying;
              v22 = BG_WeaponCharge_GetMeterBoneName(v21);
              CG_KillBoltedEffects(this->m_localClientNum, &fxDef, 2048, v22);
              --v21;
            }
            while ( (int)v21 >= v19 );
            fxSlotsPlaying = InfoStruct->fxSlotsPlaying;
          }
          m_particleSystemDef = NULL;
          if ( fxSlotsPlaying > 0 )
            m_particleSystemDef = fxDef.m_particleSystemDef;
          InfoStruct->fxTypePlaying.m_particleSystemDef = m_particleSystemDef;
        }
      }
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateWeaponType
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateWeaponType(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate)
{
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v9; 
  ClientChargeWeaponInfo *v10; 

  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  v9 = InfoStruct;
  if ( InfoStruct && (memcmp_0(&InfoStruct->currentWeapon, weapon, 0x3Cui64) || v9->currentWeaponIsAlt != isAlternate) )
  {
    if ( BG_WeaponCharge_GetType(weapon, isAlternate) )
    {
      *(__m256i *)&v9->currentWeapon.weaponIdx = *(__m256i *)&weapon->weaponIdx;
      *(_OWORD *)&v9->currentWeapon.attachmentVariationIndices[5] = *(_OWORD *)&weapon->attachmentVariationIndices[5];
      *(double *)&v9->currentWeapon.attachmentVariationIndices[21] = *(double *)&weapon->attachmentVariationIndices[21];
      *(_DWORD *)&v9->currentWeapon.weaponCamo = *(_DWORD *)&weapon->weaponCamo;
      v9->currentWeaponIsAlt = isAlternate;
      v10 = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
      if ( v10 )
      {
        if ( v10->currentWeapon.weaponIdx )
          CgWeaponSystem::ChargedWeaponClearViewModelFX(this, cent);
      }
    }
    else
    {
      v9->currentWeapon = NULL_WEAPON;
      v9->currentWeaponIsAlt = 0;
    }
  }
}

/*
==============
CgWeaponSystem::ClaimBulletId
==============
*/
__int64 CgWeaponSystem::ClaimBulletId(CgWeaponSystem *this)
{
  __int64 result; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25541, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  result = (unsigned int)this->m_nextBulletId;
  this->m_nextBulletId = result + 1;
  return result;
}

/*
==============
ClampDragPositionToLookAtPlane
==============
*/
void ClampDragPositionToLookAtPlane(LocalClientNum_t localClientNum, const playerState_s *ps, const vec3_t (*viewAxis)[3])
{
  const dvar_t *v3; 
  float value; 
  cg_t *LocalClientGlobals; 
  float v9; 
  float v10; 
  __int128 v11; 
  float v12; 
  bool v14; 
  float v17; 
  float v18; 
  float v19; 
  vec3_t outLookAtPos; 

  v3 = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  value = v3->current.value;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3312, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  CalcSwimDragLookAtPosition(ps, viewAxis, &outLookAtPos);
  v9 = LocalClientGlobals->lastDragPosition.v[0] - outLookAtPos.v[0];
  v11 = LODWORD(LocalClientGlobals->lastDragPosition.v[1]);
  v10 = LocalClientGlobals->lastDragPosition.v[1] - outLookAtPos.v[1];
  v12 = LocalClientGlobals->lastDragPosition.v[2] - outLookAtPos.v[2];
  *(float *)&v11 = fsqrt((float)((float)(v10 * v10) + (float)(v9 * v9)) + (float)(v12 * v12));
  _XMM3 = v11;
  v14 = *(float *)&v11 <= value;
  __asm
  {
    vcmpless xmm0, xmm3, cs:__real@80000000
    vblendvps xmm0, xmm3, xmm1, xmm0
  }
  v17 = 1.0 / *(float *)&_XMM0;
  if ( !v14 )
  {
    v9 = (float)(v17 * v9) * value;
    v12 = (float)(v17 * v12) * value;
    v10 = (float)(v17 * v10) * value;
    *(float *)&_XMM3 = value;
  }
  if ( *(float *)&_XMM3 >= 0.001 )
  {
    v18 = (float)((float)(v9 * (*viewAxis)[0].v[0]) + (float)(v10 * (*viewAxis)[0].v[1])) + (float)(v12 * (*viewAxis)[0].v[2]);
    v19 = (float)((float)(v10 * (*viewAxis)[1].v[1]) + (float)(v9 * (*viewAxis)[1].v[0])) + (float)(v12 * (*viewAxis)[1].v[2]);
    LocalClientGlobals->lastDragPosition.v[0] = (float)((float)(v18 * (*viewAxis)[0].v[0]) + outLookAtPos.v[0]) + (float)(v19 * (*viewAxis)[1].v[0]);
    LocalClientGlobals->lastDragPosition.v[1] = (float)((float)(v18 * (*viewAxis)[0].v[1]) + outLookAtPos.v[1]) + (float)(v19 * (*viewAxis)[1].v[1]);
    LocalClientGlobals->lastDragPosition.v[2] = (float)((float)(v18 * (*viewAxis)[0].v[2]) + outLookAtPos.v[2]) + (float)(v19 * (*viewAxis)[1].v[2]);
  }
}

/*
==============
CgWeaponSystem::ClientViewLockedOnTurret
==============
*/
_BOOL8 CgWeaponSystem::ClientViewLockedOnTurret(CgWeaponSystem *this, int entnum)
{
  cg_t *LocalClientGlobals; 
  playerState_s *p_predictedPlayerState; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) && p_predictedPlayerState->viewlocked_entNum == entnum;
}

/*
==============
CgWeaponSystem::CullBulletHitEffect
==============
*/
__int64 CgWeaponSystem::CullBulletHitEffect(CgWeaponSystem *this, int eventType, const vec3_t *position, const vec3_t *up, int sourceEntityNum, int targetEntityNum, unsigned int impactFlags)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v11; 
  float v13; 
  float v14; 
  __int128 v15; 
  float v16; 
  float v20; 
  float v21; 
  float v22; 
  centity_t *Entity; 
  const entityState_t *p_nextState; 
  float v25; 
  const dvar_t *v26; 
  unsigned int prevViewIndex; 
  const dvar_t *v28; 
  float value; 
  unsigned int v30; 
  vec3_t outOrg; 
  __int64 v32; 
  Bounds bounds; 

  v32 = -2i64;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20464, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v11 = DVARBOOL_cg_weapHitCullEnable;
  if ( !DVARBOOL_cg_weapHitCullEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapHitCullEnable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  if ( !v11->current.enabled || LocalClientGlobals->predictedPlayerState.clientNum == sourceEntityNum )
    return 0i64;
  RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
  v13 = position->v[0] - outOrg.v[0];
  v15 = LODWORD(position->v[1]);
  v14 = position->v[1] - outOrg.v[1];
  v16 = position->v[2] - outOrg.v[2];
  *(float *)&v15 = fsqrt((float)((float)(v14 * v14) + (float)(v13 * v13)) + (float)(v16 * v16));
  _XMM1 = v15;
  __asm
  {
    vcmpless xmm0, xmm1, cs:__real@80000000
    vblendvps xmm1, xmm1, xmm2, xmm0
  }
  v20 = v13 * (float)(1.0 / *(float *)&_XMM1);
  v21 = v14 * (float)(1.0 / *(float *)&_XMM1);
  v22 = v16 * (float)(1.0 / *(float *)&_XMM1);
  if ( (impactFlags & 0x100) == 0 )
  {
    if ( (unsigned int)targetEntityNum >= 0x7FE || (Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, targetEntityNum), (Entity->flags & 1) != 0) && (p_nextState = &Entity->nextState, !BG_IsCharacterEntity(&Entity->nextState)) && !BG_IsPlayerOrAgentCorpseEntity(p_nextState) )
    {
      v25 = (float)((float)(v21 * up->v[1]) + (float)(v20 * up->v[0])) + (float)(v22 * up->v[2]);
      v26 = DVARFLT_cg_weapHitCullAngle;
      if ( !DVARFLT_cg_weapHitCullAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapHitCullAngle") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v26);
      if ( v25 >= cosf_0(v26->current.value * 0.017453292) )
        goto LABEL_24;
    }
  }
  prevViewIndex = LocalClientGlobals->prevViewIndex;
  if ( CL_IsRenderingSplitScreen() )
    goto LABEL_25;
  v28 = DVARFLT_cg_weapHitCullRadius;
  if ( !DVARFLT_cg_weapHitCullRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapHitCullRadius") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v28);
  value = v28->current.value;
  *(_QWORD *)bounds.midPoint.v = *(_QWORD *)position->v;
  bounds.midPoint.v[2] = position->v[2];
  bounds.halfSize.v[0] = value;
  bounds.halfSize.v[1] = value;
  bounds.halfSize.v[2] = value;
  if ( R_Umbra_IsBoxVisible(&bounds, 0, prevViewIndex, 0) )
LABEL_25:
    v30 = 0;
  else
LABEL_24:
    v30 = 1;
  memset(&outOrg, 0, sizeof(outOrg));
  return v30;
}

/*
==============
CycleWeapPrimary
==============
*/
char CycleWeapPrimary(LocalClientNum_t localClientNum, int cycleSlot, int cycleForward, int bIgnoreEmpty, int bIgnoreStanceUnusable, int forceWrapAround)
{
  __int16 v6; 
  int v7; 
  int v8; 
  LocalClientNum_t v9; 
  cg_t *LocalClientGlobals; 
  cg_t *v11; 
  const playerState_s *p_predictedPlayerState; 
  const WeaponDef *v13; 
  CgWeaponMap *Instance; 
  int weaponState; 
  unsigned int AllWeaponAttachments; 
  bool shareAmmoWithAlt; 
  unsigned int v18; 
  WeaponAttachment **v19; 
  WeaponAttachment *v20; 
  Weapon *p_weaponSelect; 
  int inAltMode; 
  LocalClientNum_t v23; 
  const PlayerEquippedWeaponState *EquippedWeaponState; 
  weapInventoryType_t inventoryType; 
  bool v27; 
  int EquippedWeaponIndex; 
  int v29; 
  int v30; 
  char v31; 
  WeaponSlot EquippedSlot; 
  const Weapon *p_weaponPrevPrimary; 
  WeaponSlot v34; 
  WeaponSlot v35; 
  const PlayerEquippedWeaponState *v36; 
  LocalClientNum_t v37; 
  bool v38; 
  unsigned int v39; 
  unsigned int v40; 
  int v41; 
  Weapon *EquippedWeaponForPlayer; 
  bool IsWeaponUsableInState; 
  int v44; 
  const WeaponDef *v45; 
  const PlayerEquippedWeaponState *v46; 
  __int64 v47; 
  __int64 v48; 
  bool v49; 
  WeaponSlot v51; 
  int v54; 
  int v56; 
  weapInventoryType_t v57; 
  Weapon *weapon; 
  Weapon r_weapon; 
  WeaponAttachment *attachments[30]; 

  v7 = cycleForward;
  v8 = cycleSlot;
  v9 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v11 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return 0;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !BG_IsPlayer(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  if ( p_predictedPlayerState->pm_type >= 7 )
    return 0;
  r_weapon = v11->weaponSelect;
  weapon = &v11->weaponSelect;
  v13 = BG_WeaponDef(&r_weapon, 0);
  if ( BG_GetNumWeapons() < 2 )
    return 0;
  Instance = CgWeaponMap::GetInstance(v9);
  if ( r_weapon.weaponIdx )
  {
    if ( BG_UsingAlternate(p_predictedPlayerState) )
    {
      weaponState = p_predictedPlayerState->weapState[0].weaponState;
      if ( (unsigned int)(weaponState - 7) > 5 && weaponState != 50 && (!BG_PWF_UseAlternateAsOffhand(p_predictedPlayerState) || !BG_HasUnderbarrelShotgun(&r_weapon)) && !v13->altModeSameWeapon )
      {
        AllWeaponAttachments = BG_GetAllWeaponAttachments(&r_weapon, (const WeaponAttachment **)attachments);
        shareAmmoWithAlt = attachments[0] == NULL;
        v18 = 0;
        if ( AllWeaponAttachments )
        {
          v19 = attachments;
          do
          {
            if ( shareAmmoWithAlt )
              goto LABEL_24;
            if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17614, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
              __debugbreak();
            v20 = *v19;
            ++v18;
            ++v19;
            shareAmmoWithAlt = v20->shareAmmoWithAlt;
          }
          while ( v18 < AllWeaponAttachments );
          v9 = localClientNum;
        }
        if ( !shareAmmoWithAlt )
        {
          p_weaponSelect = &v11->weaponSelect;
          inAltMode = 0;
          v23 = v9;
LABEL_22:
          CG_SelectWeapon(v23, p_weaponSelect, inAltMode);
          return 1;
        }
LABEL_24:
        v7 = cycleForward;
        v8 = cycleSlot;
      }
    }
  }
  if ( (v13->inventoryType & 0xFFFFFFFB) != 0 && v11->weaponLatestPrimary.weaponIdx && BG_PlayerHasWeapon(Instance, p_predictedPlayerState, &v11->weaponLatestPrimary) )
  {
    EquippedWeaponState = BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, &v11->weaponLatestPrimary);
    if ( EquippedWeaponState )
    {
      p_weaponSelect = &v11->weaponLatestPrimary;
      v23 = localClientNum;
      inAltMode = EquippedWeaponState->inAltMode;
    }
    else
    {
      v23 = localClientNum;
      p_weaponSelect = &v11->weaponLatestPrimary;
      inAltMode = 0;
    }
    goto LABEL_22;
  }
  inventoryType = v13->inventoryType;
  v27 = v7 == 0;
  EquippedWeaponIndex = 0;
  v57 = inventoryType;
  v29 = -1;
  if ( !v27 )
    v29 = 1;
  v54 = v29;
  v30 = 4;
  if ( inventoryType != WEAPINVENTORY_EXCLUSIVE )
    v30 = 0;
  v56 = v30;
  if ( r_weapon.weaponIdx )
  {
    v31 = 0;
    EquippedWeaponIndex = BG_GetEquippedWeaponIndex(Instance, p_predictedPlayerState, &r_weapon);
    if ( EquippedWeaponIndex < 0 )
      EquippedWeaponIndex = 0;
    if ( (unsigned int)EquippedWeaponIndex >= 0xF )
    {
      LODWORD(v47) = EquippedWeaponIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17655, ASSERT_TYPE_ASSERT, "(unsigned)( startIndex ) < (unsigned)( 15 )", "startIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v47, 15) )
        __debugbreak();
    }
  }
  else
  {
    v31 = 1;
  }
  if ( inventoryType == WEAPINVENTORY_EXCLUSIVE )
  {
    v35 = WEAPON_SLOT_NONE;
  }
  else
  {
    EquippedSlot = BG_PlayerWeaponGetEquippedSlot(Instance, p_predictedPlayerState, &r_weapon);
    if ( EquippedSlot )
      v51 = BG_PlayerWeaponGetCycleSlot(EquippedSlot, v8);
    else
      v51 = WEAPON_SLOT_PRIMARY;
    if ( v8 && (p_weaponPrevPrimary = &v11->weaponPrevPrimary, v11->weaponPrevPrimary.weaponIdx) )
    {
      v34 = BG_PlayerWeaponGetEquippedSlot(Instance, p_predictedPlayerState, &v11->weaponPrevPrimary);
      v35 = v51;
      if ( v34 == v51 && BG_PlayerHasWeapon(Instance, p_predictedPlayerState, p_weaponPrevPrimary) )
      {
        v36 = BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, p_weaponPrevPrimary);
        if ( v36 )
          LOBYTE(v36) = v36->inAltMode;
        v37 = localClientNum;
        if ( CG_SelectWeapon(localClientNum, p_weaponPrevPrimary, (unsigned __int8)v36) )
          return 1;
        goto LABEL_57;
      }
    }
    else
    {
      v35 = v51;
    }
  }
  v37 = localClientNum;
LABEL_57:
  v38 = CL_Input_IsGamepadEnabled(v37) || forceWrapAround || GamerProfile_GetWeaponSwitchWrapAround(v37);
  v49 = v38;
  v39 = EquippedWeaponIndex;
  while ( 1 )
  {
    v40 = v39;
    if ( !v31 )
      break;
    v31 = 0;
    v39 = 0;
LABEL_73:
    EquippedWeaponForPlayer = (Weapon *)BG_GetEquippedWeaponForPlayer(Instance, p_predictedPlayerState, v39);
    v38 = v49;
    r_weapon = *EquippedWeaponForPlayer;
    if ( v6 )
    {
      if ( !bIgnoreStanceUnusable || (IsWeaponUsableInState = BG_IsWeaponUsableInState(p_predictedPlayerState, &r_weapon), v38 = v49, IsWeaponUsableInState) )
      {
        if ( !bIgnoreEmpty || (v44 = BG_WeaponAmmo(Instance, p_predictedPlayerState, &r_weapon, 0), v38 = v49, v44) )
        {
          v45 = BG_WeaponDef(&r_weapon, 0);
          v38 = v49;
          if ( v45->inventoryType == v56 )
          {
            v46 = BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, &r_weapon);
            if ( v57 == WEAPINVENTORY_EXCLUSIVE || (v38 = v49, v46->slot == v35) )
            {
              p_weaponSelect = &r_weapon;
              if ( v46 )
                inAltMode = v46->inAltMode;
              else
                inAltMode = 0;
              v23 = v37;
              goto LABEL_22;
            }
          }
        }
      }
    }
  }
  if ( v38 || v39 + v54 <= 0xE )
  {
    v41 = 14;
    if ( cycleForward )
      v41 = 16;
    v39 = (int)(v40 + v41) % 15;
    if ( v39 >= 0xF )
    {
      LODWORD(v48) = 15;
      LODWORD(v47) = v39;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17712, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v47, v48) )
        __debugbreak();
    }
    if ( v39 != EquippedWeaponIndex )
      goto LABEL_73;
  }
  if ( !BG_PlayerHasWeapon(Instance, p_predictedPlayerState, weapon) )
  {
    memset(&r_weapon, 0, 48);
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
    *(double *)&r_weapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
    CG_SelectWeapon(v37, &r_weapon, 0);
  }
  return 0;
}

/*
==============
CgWeaponSystem::DebugDrawBulletHitLocation
==============
*/
void CgWeaponSystem::DebugDrawBulletHitLocation(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  __int64 m_localClientNum; 
  CgWeaponMap *v4; 
  const playerState_s *p_predictedPlayerState; 
  const Weapon *CurrentWeaponForPlayer; 
  bool isAlternate; 
  centity_t *Entity; 
  float v9; 
  CgBallistics *System; 
  double Bullet; 
  unsigned __int8 *priorityMap; 
  char v13; 
  double v14; 
  float v15; 
  ClientFov *ViewFovBySpace; 
  double v17; 
  double v18; 
  float v19; 
  int surfaceFlags; 
  const char *v21; 
  float v22; 
  double v23; 
  char *fmt; 
  int r_weapon; 
  __int64 v26; 
  TagPair result; 
  __int64 v28; 
  vec3_t point; 
  ClientFov v30; 
  vec3_t end; 
  vec3_t start; 
  float v33; 
  float v34; 
  float v35; 
  char v36[24]; 
  trace_t results; 
  char dest[1024]; 

  v28 = -2i64;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[m_localClientNum];
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v4, p_predictedPlayerState);
  isAlternate = BG_UsingAlternate(p_predictedPlayerState);
  if ( BG_GetWeaponType(CurrentWeaponForPlayer, isAlternate) == WEAPTYPE_BULLET )
  {
    Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, p_predictedPlayerState->clientNum);
    BG_GetWeaponFlashTagname(&result, CurrentWeaponForPlayer, isAlternate, 0);
    v9 = 0.0;
    *(float *)&v26 = 0.0;
    LOBYTE(r_weapon) = 1;
    if ( ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _BYTE, _DWORD, _BYTE, _QWORD, _QWORD, _QWORD, _QWORD))this->SimulateBulletFire_Orientation)(this, Entity, CurrentWeaponForPlayer, isAlternate, result, r_weapon, 1, WEAPON_HAND_DEFAULT, 1, NULL, (orientation_t *)&start, (float *)&v26, (vec3_t *)v36) )
    {
      System = CgBallistics::GetSystem((const LocalClientNum_t)this->m_localClientNum);
      Bullet = BG_GetBulletRange<CgBallisticInstance>(v4, System, p_predictedPlayerState, &Entity->nextState, &p_predictedPlayerState->perks, CurrentWeaponForPlayer, isAlternate);
      end.v[0] = (float)(*(float *)&Bullet * v33) + start.v[0];
      end.v[1] = (float)(*(float *)&Bullet * v34) + start.v[1];
      end.v[2] = (float)(*(float *)&Bullet * v35) + start.v[2];
      priorityMap = BG_GetWeaponPriorityMap(CurrentWeaponForPlayer, isAlternate);
      PhysicsQuery_LegacyMPCGWeaponSimTrace((Physics_WorldId)(3 * this->m_localClientNum + 4), &results, &start, &end, &bounds_origin, &p_predictedPlayerState->clientNum, 1, 0, 41969969, 1, priorityMap, NormalSpace, 1);
      v13 = 0;
      if ( results.allsolid && results.startsolid )
      {
        point = start;
      }
      else if ( results.fraction >= 1.0 || (results.surfaceFlags & 4) != 0 )
      {
        v9 = *(float *)&Bullet;
        point = end;
      }
      else
      {
        v13 = 1;
        v9 = results.fraction * *(float *)&Bullet;
        point.v[0] = (float)((float)(results.fraction * *(float *)&Bullet) * v33) + start.v[0];
        point.v[1] = (float)((float)(results.fraction * *(float *)&Bullet) * v34) + start.v[1];
        point.v[2] = (float)((float)(results.fraction * *(float *)&Bullet) * v35) + start.v[2];
      }
      if ( dword_1512FDF2C > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
      {
        j__Init_thread_header(&dword_1512FDF2C);
        if ( dword_1512FDF2C == -1 )
        {
          v23 = BG_MaxBulletRange();
          DEBUG_FONT_SIZE_MAX_DISTANCE = *(float *)&v23;
          j__Init_thread_footer(&dword_1512FDF2C);
        }
      }
      v14 = I_fclamp(v9, DEBUG_FONT_SIZE_MIN_DISTANCE, DEBUG_FONT_SIZE_MAX_DISTANCE);
      v15 = (float)(*(float *)&v14 - DEBUG_FONT_SIZE_MIN_DISTANCE) / (float)(DEBUG_FONT_SIZE_MAX_DISTANCE - DEBUG_FONT_SIZE_MIN_DISTANCE);
      ViewFovBySpace = CG_GetViewFovBySpace(&v30, (const LocalClientNum_t)this->m_localClientNum, CG_FovSpace_Scene, 0);
      v17 = *(double *)&ViewFovBySpace->finalFov;
      v30.baseFovAdjustment = ViewFovBySpace->baseFovAdjustment;
      *(double *)&v30.finalFov = v17;
      v18 = I_fclamp(*(float *)&v17, DEBUG_FONT_SIZE_NARROW_FOV, DEBUG_FONT_SIZE_WIDE_FOV);
      v19 = (float)(*(float *)&v18 - DEBUG_FONT_SIZE_NARROW_FOV) / (float)(DEBUG_FONT_SIZE_WIDE_FOV - DEBUG_FONT_SIZE_NARROW_FOV);
      surfaceFlags = 0;
      if ( v13 )
        surfaceFlags = results.surfaceFlags;
      v21 = "no";
      if ( v13 )
        v21 = "yes";
      LODWORD(fmt) = surfaceFlags;
      Com_sprintf(dest, 0x400ui64, "hit geo: %s surf flags: %d dist: %.4f spread: %.4f", v21, fmt, v9, *(float *)&v26);
      CG_DebugStarWithText(&point, &colorGreen, &colorWhite, dest, (float)((float)((float)(1.0 - v15) * DEBUG_FONT_SIZE_MIN) + (float)(v15 * DEBUG_FONT_SIZE_MAX)) * v19, 0);
      if ( *(float *)&v26 > 0.000001 )
      {
        LODWORD(v30.finalFov) = LODWORD(v33) ^ _xmm;
        LODWORD(v30.baseFov) = LODWORD(v34) ^ _xmm;
        LODWORD(v30.baseFovAdjustment) = LODWORD(v35) ^ _xmm;
        v22 = tanf_0(*(float *)&v26 * 0.017453292);
        CG_DebugCircle(&point, v22 * v9, (const vec3_t *)&v30, &colorBlue, 0, 0);
      }
    }
  }
}

/*
==============
DebugDrawMissileProjectedSound
==============
*/
void DebugDrawMissileProjectedSound(const MissileConeSoundVars *mcv)
{
  float height; 
  float v2; 
  float v3; 
  float v4; 
  float v5; 
  float v6; 
  float v7; 
  float v8; 
  float v9; 
  float v10; 
  bool v12; 
  float radiusAtTop; 
  float v14; 
  float v15; 
  float v16; 
  float radiusAtBase; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  __int128 v23; 
  float pitchTopSize; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float crossfadeTopSize; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  float v43; 
  vec3_t *v44; 
  int v45; 
  vec3_t *v46; 
  vec3_t *v47; 
  vec3_t *v48; 
  float i; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  float v57; 
  float v58; 
  vec3_t *v59; 
  vec3_t *v60; 
  __int128 v61; 
  vec3_t start; 
  vec3_t v63; 
  vec3_t v64; 
  vec3_t dst; 
  vec3_t end; 
  vec3_t point; 
  vec3_t v68; 
  vec3_t v69; 
  vec3_t v70; 
  vec3_t v71; 
  vec3_t v72; 
  vec3_t v73; 
  vec3_t v74; 
  vec3_t v75; 

  height = mcv->height;
  v2 = height * mcv->dir.v[1];
  v64.v[0] = (float)(height * mcv->dir.v[0]) + mcv->start.v[0];
  v3 = v2 + mcv->start.v[1];
  v4 = height * mcv->dir.v[2];
  v5 = height + MY_BEYONDDRAW_DIST;
  v6 = v5 * mcv->dir.v[1];
  v64.v[1] = v3;
  v7 = v4 + mcv->start.v[2];
  v8 = v5 * mcv->dir.v[0];
  v64.v[2] = v7;
  v9 = v8 + mcv->start.v[0];
  v10 = v6 + mcv->start.v[1];
  end.v[0] = v9;
  end.v[2] = (float)(v5 * mcv->dir.v[2]) + mcv->start.v[2];
  end.v[1] = v10;
  CG_DebugLine(&mcv->start, &end, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
  PerpendicularVector(&mcv->dir, &dst);
  v12 = !mcv->pitchshiftEnabled;
  radiusAtTop = mcv->radiusAtTop;
  v14 = dst.v[0];
  v15 = dst.v[1];
  v16 = dst.v[2];
  radiusAtBase = mcv->radiusAtBase;
  point.v[0] = dst.v[0] * radiusAtTop;
  point.v[2] = dst.v[2] * radiusAtTop;
  v18 = dst.v[1] * radiusAtTop;
  v19 = radiusAtTop * mcv->volumescaleCoreSize;
  point.v[1] = v18;
  v68.v[0] = dst.v[0] * v19;
  v20 = dst.v[2] * v19;
  v21 = dst.v[1] * v19;
  v22 = radiusAtBase * mcv->volumescaleCoreSize;
  v68.v[2] = v20;
  v68.v[1] = v21;
  v69.v[0] = dst.v[0] * radiusAtBase;
  v69.v[1] = dst.v[1] * radiusAtBase;
  v69.v[2] = dst.v[2] * radiusAtBase;
  v70.v[0] = dst.v[0] * v22;
  v70.v[1] = dst.v[1] * v22;
  v70.v[2] = dst.v[2] * v22;
  v23 = 0i64;
  if ( !v12 )
  {
    pitchTopSize = mcv->pitchTopSize;
    if ( pitchTopSize != 0.0 || mcv->pitchBottomSize != 0.0 )
    {
      v25 = (float)(dst.v[0] * MY_ALTLINEOFFSET) + mcv->start.v[0];
      v26 = (float)(dst.v[2] * MY_ALTLINEOFFSET) + mcv->start.v[2];
      v27 = (float)(dst.v[1] * MY_ALTLINEOFFSET) + mcv->start.v[1];
      v28 = pitchTopSize * mcv->height;
      v29 = v28 * mcv->dir.v[1];
      v63.v[0] = (float)(v28 * mcv->dir.v[0]) + v25;
      v30 = v29 + v27;
      v31 = v28 * mcv->dir.v[2];
      v63.v[1] = v30;
      v32 = (float)(1.0 - mcv->pitchBottomSize) * mcv->height;
      v33 = v32 * mcv->dir.v[1];
      v63.v[2] = v31 + v26;
      start.v[0] = (float)(v32 * mcv->dir.v[0]) + v25;
      start.v[2] = (float)(v32 * mcv->dir.v[2]) + v26;
      start.v[1] = v33 + v27;
      CG_DebugLine(&start, &v63, &MY_COLOR_PITCH, MY_DEPTHTEST, MY_DURATION);
      v14 = dst.v[0];
      v16 = dst.v[2];
      v15 = dst.v[1];
    }
  }
  if ( mcv->crossfadeEnabled )
  {
    crossfadeTopSize = mcv->crossfadeTopSize;
    if ( crossfadeTopSize != 0.0 || mcv->crossfadeBottomSize != 0.0 )
    {
      v35 = (float)(v14 * COERCE_FLOAT(LODWORD(MY_ALTLINEOFFSET) ^ _xmm)) + mcv->start.v[0];
      v36 = (float)(v16 * COERCE_FLOAT(LODWORD(MY_ALTLINEOFFSET) ^ _xmm)) + mcv->start.v[2];
      v37 = (float)(v15 * COERCE_FLOAT(LODWORD(MY_ALTLINEOFFSET) ^ _xmm)) + mcv->start.v[1];
      v38 = crossfadeTopSize * mcv->height;
      v39 = v38 * mcv->dir.v[1];
      v63.v[0] = (float)(v38 * mcv->dir.v[0]) + v35;
      v40 = v39 + v37;
      v41 = v38 * mcv->dir.v[2];
      v63.v[1] = v40;
      v42 = (float)(1.0 - mcv->crossfadeBottomSize) * mcv->height;
      v43 = v42 * mcv->dir.v[1];
      v63.v[2] = v41 + v36;
      start.v[0] = (float)(v42 * mcv->dir.v[0]) + v35;
      start.v[2] = (float)(v42 * mcv->dir.v[2]) + v36;
      start.v[1] = v43 + v37;
      CG_DebugLine(&start, &v63, &MY_COLOR_CROSSFADE, MY_DEPTHTEST, MY_DURATION);
    }
  }
  v44 = &v72;
  v45 = 0;
  v46 = &v73;
  v47 = &v74;
  v48 = &v75;
  for ( i = 360.0 / (float)MY_STEPS; v45 <= MY_STEPS; v23 = v61 )
  {
    RotatePointAroundVector(v44, &mcv->dir, &point, *(float *)&v23);
    v50 = v44->v[1];
    v44->v[0] = v44->v[0] + mcv->start.v[0];
    v51 = v50 + mcv->start.v[1];
    v52 = mcv->start.v[2];
    v44->v[1] = v51;
    v44->v[2] = v52 + v44->v[2];
    RotatePointAroundVector(&start, &mcv->dir, &v68, *(float *)&v23);
    v53 = start.v[1] + mcv->start.v[1];
    start.v[0] = start.v[0] + mcv->start.v[0];
    start.v[2] = start.v[2] + mcv->start.v[2];
    start.v[1] = v53;
    CG_DebugLine(&mcv->start, &start, &MY_COLOR_INNER, MY_DEPTHTEST, MY_DURATION);
    CG_DebugLine(&start, v44, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
    RotatePointAroundVector(v47, &mcv->dir, &v69, *(float *)&v23);
    v54 = v64.v[1];
    v47->v[0] = v64.v[0] + v47->v[0];
    v55 = v54 + v47->v[1];
    v56 = v64.v[2];
    v47->v[1] = v55;
    v47->v[2] = v56 + v47->v[2];
    RotatePointAroundVector(&v63, &mcv->dir, &v70, *(float *)&v23);
    v63.v[0] = v63.v[0] + v64.v[0];
    v63.v[2] = v63.v[2] + v64.v[2];
    v63.v[1] = v63.v[1] + v64.v[1];
    CG_DebugLine(&v64, &v63, &MY_COLOR_INNER, MY_DEPTHTEST, MY_DURATION);
    CG_DebugLine(&v63, v47, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
    CG_DebugLine(v44, v47, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
    v57 = (float)(MY_BEYONDDRAW_DIST * mcv->dir.v[1]) + v47->v[1];
    v71.v[0] = (float)(MY_BEYONDDRAW_DIST * mcv->dir.v[0]) + v47->v[0];
    v58 = MY_BEYONDDRAW_DIST * mcv->dir.v[2];
    v71.v[1] = v57;
    v71.v[2] = v58 + v47->v[2];
    CG_DebugLine(v47, &v71, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
    if ( v45 )
    {
      CG_DebugLine(v44, v46, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
      CG_DebugLine(v47, v48, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
    }
    v59 = v44;
    ++v45;
    v44 = v46;
    v46 = v59;
    v60 = v47;
    v47 = v48;
    v48 = v60;
    v61 = v23;
    *(float *)&v61 = *(float *)&v23 + i;
  }
}

/*
==============
DevPrintAnimTree
==============
*/
void DevPrintAnimTree(const LocalClientNum_t localClientNum, const XAnimTree *animTree, const playerState_s *ps, __int64 hand, const Weapon *weapon)
{
  __int64 v6; 
  int v8; 
  int v9; 
  __int64 v10; 
  XAnimParts *parts; 
  const char *name; 
  CgHandler *Handler; 
  __int64 v14; 
  int i; 
  const char *v16; 
  const char **v17; 
  const char *v18; 
  bool v19; 
  const WeaponDef *v20; 
  int v21; 
  __int64 v22; 
  const char **p_name; 
  const char *v24; 
  const BgWeaponMap **v25; 
  unsigned __int16 weaponIdx; 
  WeaponDef *v27; 
  __int64 v28; 
  const char **v29; 
  const char *v30; 
  __int64 v31; 
  Weapon Buf2; 
  char output[1024]; 

  v6 = localClientNum;
  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3758, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !animTree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3759, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
    __debugbreak();
  Com_Printf(19, "DevPrintAnimTree: dumping animTree parts\n", ps, hand);
  v8 = 0;
  v9 = 0;
  v10 = 0i64;
  do
  {
    if ( animTree->anims->entries[v10].numAnims )
    {
      name = "<animParent>";
    }
    else
    {
      parts = animTree->anims->entries[v10].parts;
      if ( !parts || (name = parts->name) == NULL || !*name )
        name = "<empty>";
    }
    Com_Printf(19, "%d: %s\n", (unsigned int)v9++, name);
    ++v10;
  }
  while ( v9 < 608 );
  Handler = CgHandler::getHandler((LocalClientNum_t)v6);
  v14 = (__int64)Handler->PlayerWeaponAnimsConst(Handler, ps);
  if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3788, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  Com_Printf(19, "DevPrintAnimTree: dumping cached anims\n");
  for ( i = 0; i < 608; ++i )
  {
    if ( *(_QWORD *)v14 )
      v16 = **(const char ***)v14;
    else
      v16 = "<empty>";
    v17 = *(const char ***)(v14 + 4976);
    if ( v17 )
      v18 = *v17;
    else
      v18 = "<empty>";
    Com_Printf(19, "%d: %s, %s\n", (unsigned int)i, v16, v18);
    v14 += 8i64;
  }
  BG_GetWeaponName(weapon, output, 0x400u);
  Com_Printf(19, "DevPrintAnimTree: dumping szXAnims for %s\n", output);
  v19 = BG_UsingAlternate(ps);
  v20 = BG_WeaponDef(weapon, v19);
  if ( v20->szXAnims )
  {
    v21 = 0;
    v22 = 0i64;
    do
    {
      p_name = &v20->szXAnims->anims[v22]->name;
      if ( p_name )
        v24 = *p_name;
      else
        v24 = "<empty>";
      Com_Printf(19, "%d: %s\n", (unsigned int)v21++, v24);
      ++v22;
    }
    while ( v21 < 608 );
  }
  v25 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v6];
  if ( !*v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  Buf2 = *BG_GetViewmodelWeapon(*v25, ps);
  if ( memcmp_0(weapon, &Buf2, 0x3Cui64) )
  {
    BG_GetWeaponName(&Buf2, output, 0x400u);
    Com_Printf(19, "DevPrintAnimTree: dumping viewmodelWeapon szXAnims for %s\n", output);
    BG_UsingAlternate(ps);
    weaponIdx = Buf2.weaponIdx;
    if ( Buf2.weaponIdx > bg_lastParsedWeaponIndex )
    {
      LODWORD(v31) = Buf2.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v31, bg_lastParsedWeaponIndex) )
        __debugbreak();
    }
    if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    v27 = bg_weaponDefs[weaponIdx];
    if ( v27->szXAnims )
    {
      v28 = 0i64;
      do
      {
        v29 = &v27->szXAnims->anims[v28]->name;
        if ( v29 )
          v30 = *v29;
        else
          v30 = "<empty>";
        Com_Printf(19, "%d: %s\n", (unsigned int)v8++, v30);
        ++v28;
      }
      while ( v8 < 608 );
    }
  }
}

/*
==============
CgWeaponSystem::DrawDebugBulletLines
==============
*/
void CgWeaponSystem::DrawDebugBulletLines(CgWeaponSystem *this)
{
  volatile int v2; 
  int v3; 
  const dvar_t *v4; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25527, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  v2 = 0;
  if ( this->m_numBulletDebugLines <= 0 )
  {
    this->m_numBulletDebugLines = 0;
  }
  else
  {
    v3 = 0;
    do
    {
      v4 = DCONST_DVARINT_cg_debugBulletsDrawDuration;
      if ( !DCONST_DVARINT_cg_debugBulletsDrawDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBulletsDrawDuration") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v4);
      CG_DebugLine(&this->m_bulletDebugPoints[v3], &this->m_bulletDebugPoints[v3 + 1], &colorBlue, 0, v4->current.integer);
      ++v2;
      v3 += 2;
    }
    while ( v2 < this->m_numBulletDebugLines );
    this->m_numBulletDebugLines = 0;
  }
}

/*
==============
CgWeaponSystem::DrawFriendOrFoeTargetBoxes
==============
*/
void CgWeaponSystem::DrawFriendOrFoeTargetBoxes(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  centity_t *Entity; 
  centity_t *v4; 
  Material *material; 
  int IconDims; 
  float w; 
  float h; 
  float v9; 
  float v10; 
  float y; 
  float x; 
  __int64 v13; 
  vec4_t outOrigin; 

  v13 = -2i64;
  if ( !CG_IsCinematicCameraActive(this->m_localClientNum) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.eFlags, ACTIVE, 0xCu) )
    {
      Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, LocalClientGlobals->predictedPlayerState.clientNum);
      v4 = Entity;
      if ( (Entity->flags & 1) != 0 && BG_IsCharacterEntity(&Entity->nextState) )
      {
        material = cgMedia.FOFTargetBox_Self;
        if ( (v4->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21592, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
          __debugbreak();
        if ( BG_IsCharacterEntity(&v4->nextState) )
        {
          CG_GetPoseOrigin(&v4->pose, (vec3_t *)&outOrigin);
          IconDims = CgWeaponSystem::GetIconDims(this, (const vec3_t *)&outOrigin, &x, &y, &w, &h);
          memset(&outOrigin, 0, 0xCui64);
          if ( IconDims )
          {
            v9 = h;
            v10 = w;
            w = y;
            h = x;
            if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21619, ASSERT_TYPE_ASSERT, "(icon)", (const char *)&queryFormat, "icon") )
              __debugbreak();
            outOrigin.v[0] = colorWhite.v[0];
            outOrigin.v[1] = colorWhite.v[1];
            outOrigin.v[2] = colorWhite.v[2];
            outOrigin.v[3] = FLOAT_1_0;
            ScrPlace_HiResApplyRect(&h, &w, &v10, &v9);
            CL_DrawStretchPicPhysical(h, w, v10, v9, 0.0, 0.0, 1.0, 1.0, &outOrigin, material);
          }
        }
      }
    }
  }
}

/*
==============
CgWeaponSystem::DrawTargetBox
==============
*/
void CgWeaponSystem::DrawTargetBox(CgWeaponSystem *this, float x, float y, float w, float h, Material *icon, float alpha)
{
  Material *material; 
  float wa; 
  float ya; 
  float xa; 
  vec4_t color; 

  material = icon;
  xa = x;
  ya = y;
  wa = w;
  if ( !icon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21619, ASSERT_TYPE_ASSERT, "(icon)", (const char *)&queryFormat, "icon") )
    __debugbreak();
  color.v[0] = colorWhite.v[0];
  color.v[1] = colorWhite.v[1];
  color.v[2] = colorWhite.v[2];
  color.v[3] = alpha;
  ScrPlace_HiResApplyRect(&xa, &ya, &wa, &h);
  CL_DrawStretchPicPhysical(xa, ya, wa, h, 0.0, 0.0, 1.0, 1.0, &color, material);
}

/*
==============
GetAdditiveAnimMax
==============
*/
float GetAdditiveAnimMax(const XAnimTree *animTree, const playerState_s *ps, const AdditiveEaseInfo *easeInfoArray, const int numEaseInfo)
{
  __int64 v6; 
  __int64 v10; 
  float *p_easeOutTime; 
  unsigned int v12; 
  double Weight; 

  v6 = numEaseInfo;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3378, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3379, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !easeInfoArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3380, ASSERT_TYPE_ASSERT, "(easeInfoArray)", (const char *)&queryFormat, "easeInfoArray") )
    __debugbreak();
  if ( (int)v6 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3381, ASSERT_TYPE_ASSERT, "(numEaseInfo >= 0)", (const char *)&queryFormat, "numEaseInfo >= 0") )
    __debugbreak();
  _XMM0 = LODWORD(ps->weapCommon.fWeaponPosFrac);
  *(float *)&_XMM6 = FLOAT_1_0;
  if ( *(float *)&_XMM0 > 0.0 )
    LODWORD(_XMM6) = GetAdditiveAnimMax_EaseInOut(*(const float *)&_XMM0, 0.80000001, 1.0);
  v10 = v6;
  if ( (int)v6 > 0 )
  {
    p_easeOutTime = &easeInfoArray->easeOutTime;
    do
    {
      v12 = *((_DWORD *)p_easeOutTime - 1);
      Weight = XAnimGetWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, v12);
      if ( *(float *)&Weight > 0.0 )
      {
        *(double *)&_XMM0 = XAnimGetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, v12);
        *(float *)&_XMM0 = GetAdditiveAnimMax_EaseInOut(*(const float *)&_XMM0, *p_easeOutTime, p_easeOutTime[1]);
        __asm { vminss  xmm6, xmm0, xmm6 }
      }
      p_easeOutTime += 3;
      --v10;
    }
    while ( v10 );
  }
  return *(float *)&_XMM6;
}

/*
==============
GetAdditiveAnimMax_EaseInOut
==============
*/
float GetAdditiveAnimMax_EaseInOut(const float lerpTime, const float easeOutTime, const float easeInTime)
{
  __asm { vxorpd  xmm11, xmm11, xmm11 }
  if ( (easeOutTime < 0.0 || easeOutTime > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3341, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( easeOutTime ) && ( easeOutTime ) <= ( 1.0f )", "easeOutTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", easeOutTime, *(double *)&_XMM11, DOUBLE_1_0) )
    __debugbreak();
  if ( (easeInTime < 0.0 || easeInTime > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3342, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( easeInTime ) && ( easeInTime ) <= ( 1.0f )", "easeInTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", easeInTime, *(double *)&_XMM11, DOUBLE_1_0) )
    __debugbreak();
  if ( easeOutTime > easeInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3343, ASSERT_TYPE_ASSERT, "( easeOutTime ) <= ( easeInTime )", "%s <= %s\n\t%g, %g", "easeOutTime", "easeInTime", easeOutTime, easeInTime) )
    __debugbreak();
  if ( lerpTime >= easeOutTime )
  {
    if ( lerpTime <= easeInTime )
      return 0.0;
    if ( easeInTime < 1.0 )
      return (float)(lerpTime - easeInTime) / (float)(1.0 - easeInTime);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3357, ASSERT_TYPE_ASSERT, "( easeInTime ) < ( 1.0f )", "%s < %s\n\t%g, %g", "easeInTime", "1.0f", easeInTime, DOUBLE_1_0) )
      __debugbreak();
    if ( easeInTime >= 1.0 )
      return 0.0;
    else
      return (float)(lerpTime - easeInTime) / (float)(1.0 - easeInTime);
  }
  else
  {
    if ( easeOutTime > 0.0 )
      return (float)(easeOutTime - lerpTime) / easeOutTime;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3348, ASSERT_TYPE_ASSERT, "( easeOutTime ) > ( 0.0f )", "%s > %s\n\t%g, %g", "easeOutTime", "0.0f", easeOutTime, *(double *)&_XMM11) )
      __debugbreak();
    if ( easeOutTime > 0.0 )
      return (float)(easeOutTime - lerpTime) / easeOutTime;
    else
      return FLOAT_1_0;
  }
}

/*
==============
GetAnimBlendTimes
==============
*/
__int64 GetAnimBlendTimes(const LocalClientNum_t localClientNum, const Weapon *r_weapon, const playerState_s *const ps, const WeaponAnimNumber blendOutAnim, const unsigned int blendOutAnimIndex, const WeaponAnimNumber blendInAnim, const unsigned int blendInAnimIndex, float *blendOutTime, float *blendInTime)
{
  const dvar_t *v9; 
  const AnimStateBlendTimes *v14; 
  unsigned int v15; 
  unsigned int i; 
  weapAnimFiles_t *p_animBlendIn; 
  const dvar_t *v18; 
  float value; 
  void (__fastcall *blendFunc)(const LocalClientNum_t, const Weapon *, const playerState_s *const, const WeaponAnimNumber, const unsigned int, const WeaponAnimNumber, const unsigned int, float *, float *); 
  __int64 v22; 
  __int64 v23; 

  v9 = DCONST_DVARBOOL_cg_viewmodelAnimBlending;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimBlending && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimBlending") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( !v9->current.enabled )
    return 0i64;
  if ( !blendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1502, ASSERT_TYPE_ASSERT, "(blendOutTime)", (const char *)&queryFormat, "blendOutTime") )
    __debugbreak();
  if ( !blendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1503, ASSERT_TYPE_ASSERT, "(blendInTime)", (const char *)&queryFormat, "blendInTime") )
    __debugbreak();
  if ( blendOutAnimIndex >= 0x260 )
  {
    LODWORD(v23) = 608;
    LODWORD(v22) = blendOutAnimIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1504, ASSERT_TYPE_ASSERT, "(unsigned)( blendOutAnimIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "blendOutAnimIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v22, v23) )
      __debugbreak();
  }
  if ( blendInAnimIndex >= 0x260 )
  {
    LODWORD(v23) = 608;
    LODWORD(v22) = blendInAnimIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1505, ASSERT_TYPE_ASSERT, "(unsigned)( blendInAnimIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "blendInAnimIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v22, v23) )
      __debugbreak();
  }
  v14 = s_blendAnimStates;
  v15 = 0;
  for ( i = 0; i < 0xB5; ++i )
  {
    if ( v14->animBlendOut == blendOutAnim && v14->animBlendIn == blendInAnim )
    {
      blendFunc = v14->blendFunc;
      if ( blendFunc )
      {
        blendFunc(localClientNum, r_weapon, ps, blendOutAnim, blendOutAnimIndex, blendInAnim, blendInAnimIndex, blendOutTime, blendInTime);
      }
      else
      {
        *blendOutTime = v14->animBlendTimeOut;
        *blendInTime = v14->animBlendTimeIn;
      }
      return 1i64;
    }
    ++v14;
  }
  p_animBlendIn = &s_blendAnims[0].animBlendIn;
  do
  {
    if ( *((_DWORD *)p_animBlendIn - 1) == blendOutAnimIndex && *p_animBlendIn == blendInAnimIndex )
    {
      *blendOutTime = s_blendAnims[v15].animBlendTimeOut;
      *blendInTime = s_blendAnims[v15].animBlendTimeIn;
      return 1i64;
    }
    ++v15;
    p_animBlendIn += 4;
  }
  while ( v15 < 0x14 );
  if ( blendInAnimIndex - 262 > 0x17 || blendOutAnimIndex - 262 > 0x17 )
    return 0i64;
  v18 = DCONST_DVARFLT_cg_viewmodelMeleeAnimBlendTimeSec;
  if ( !DCONST_DVARFLT_cg_viewmodelMeleeAnimBlendTimeSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelMeleeAnimBlendTimeSec") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v18);
  value = v18->current.value;
  *blendOutTime = value;
  *blendInTime = value;
  return 1i64;
}

/*
==============
MovementAnimState::GetCycleAnimation
==============
*/
__int64 MovementAnimState::GetCycleAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  __int32 v3; 
  __int32 v4; 

  if ( state == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5781, ASSERT_TYPE_ASSERT, "(state != State::NONE)", (const char *)&queryFormat, "state != State::NONE") )
    __debugbreak();
  if ( state )
  {
    v3 = state - 1;
    if ( !v3 )
      return 64i64;
    v4 = v3 - 1;
    if ( !v4 )
      return 65i64;
    if ( v4 == 1 )
      return 66i64;
  }
  return 63i64;
}

/*
==============
CAssistTarget::GetEntNum
==============
*/
__int64 CAssistTarget::GetEntNum(CAssistTarget *this)
{
  const centity_t *m_target; 

  m_target = this->m_target;
  if ( m_target )
    return (unsigned int)m_target->nextState.number;
  else
    return 2047i64;
}

/*
==============
MovementAnimState::GetGoalState
==============
*/
__int64 MovementAnimState::GetGoalState(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  bool IsSuperSprinting; 
  bool v6; 
  bool IsJogging; 

  if ( MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
    return 0i64;
  IsSuperSprinting = BG_IsSuperSprinting(ps);
  v6 = !IsSuperSprinting && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u);
  IsJogging = CG_IsJogging(localClientNum);
  if ( IsSuperSprinting )
    return 3i64;
  if ( v6 )
    return 2i64;
  return IsJogging;
}

/*
==============
CgWeaponSystem::GetIconDims
==============
*/
__int64 CgWeaponSystem::GetIconDims(CgWeaponSystem *this, const vec3_t *targetPos, float *x, float *y, float *w, float *h)
{
  bool v10; 
  ScreenPlacement *v11; 
  float v12; 
  LocalClientNum_t m_localClientNum; 
  const dvar_t *v14; 
  float v15; 
  float v16; 
  float value; 
  const dvar_t *v18; 
  float v19; 
  float v20; 
  const dvar_t *v21; 
  float v22; 
  double v23; 
  float v24; 
  __int64 result; 
  vec2_t v26; 
  vec2_t outScreenPos; 
  vec3_t worldPos; 

  if ( !x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21529, ASSERT_TYPE_ASSERT, "(x)", (const char *)&queryFormat, "x") )
    __debugbreak();
  if ( !y && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21530, ASSERT_TYPE_ASSERT, "(y)", (const char *)&queryFormat, "y") )
    __debugbreak();
  if ( !w && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21531, ASSERT_TYPE_ASSERT, "(w)", (const char *)&queryFormat, "w") )
    __debugbreak();
  if ( !h && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21532, ASSERT_TYPE_ASSERT, "(h)", (const char *)&queryFormat, "h") )
    __debugbreak();
  if ( activeScreenPlacementMode )
  {
    if ( activeScreenPlacementMode == SCRMODE_DISPLAY )
    {
      v11 = &scrPlaceViewDisplay[this->m_localClientNum];
      goto LABEL_20;
    }
    if ( activeScreenPlacementMode == SCRMODE_INVALID )
      v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\screen_placement.h", 127, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "ScrPlace_GetActivePlacement() called when outside of a valid render loop.");
    else
      v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\screen_placement.h", 130, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unsupported activeScreenPlacementMode");
    if ( v10 )
      __debugbreak();
  }
  v11 = &scrPlaceFull;
LABEL_20:
  if ( CG_WorldPosToScreenPosReal(this->m_localClientNum, v11, targetPos, &outScreenPos) && (v12 = targetPos->v[1], m_localClientNum = this->m_localClientNum, worldPos.v[0] = targetPos->v[0], worldPos.v[2] = targetPos->v[2] + 60.0, worldPos.v[1] = v12, CG_WorldPosToScreenPosReal(m_localClientNum, v11, &worldPos, &v26)) )
  {
    v14 = DVARFLT_FoFIconMinSize;
    v15 = (float)(outScreenPos.v[0] + v26.v[0]) * 0.5;
    v16 = (float)(outScreenPos.v[1] + v26.v[1]) * 0.5;
    if ( !DVARFLT_FoFIconMinSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "FoFIconMinSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    value = v14->current.value;
    v18 = DVARFLT_FoFIconMaxSize;
    v19 = value * v11->scaleVirtualToReal.v[0];
    if ( !DVARFLT_FoFIconMaxSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "FoFIconMaxSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v18);
    v20 = v18->current.value * v11->scaleVirtualToReal.v[0];
    v21 = DVARFLT_FoFIconScale;
    v22 = fsqrt((float)((float)(v26.v[1] - outScreenPos.v[1]) * (float)(v26.v[1] - outScreenPos.v[1])) + (float)((float)(v26.v[0] - outScreenPos.v[0]) * (float)(v26.v[0] - outScreenPos.v[0])));
    if ( !DVARFLT_FoFIconScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "FoFIconScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v21);
    v23 = I_fclamp(v22 * v21->current.value, v19, v20);
    v24 = *(float *)&v23 * cls.vidConfig.aspectRatioDisplayPixel;
    result = 1i64;
    *w = *(float *)&v23;
    *h = v24;
    *x = v15 - (float)(*(float *)&v23 * 0.5);
    *y = v16 - (float)(v24 * 0.5);
  }
  else
  {
    result = 0i64;
    *x = 0.0;
    *y = 0.0;
    *w = 0.0;
    *h = 0.0;
  }
  return result;
}

/*
==============
CgWeaponSystem::GetIconDimsForPlayer
==============
*/
__int64 CgWeaponSystem::GetIconDimsForPlayer(CgWeaponSystem *this, const centity_t *cent, float *x, float *y, float *w, float *h, bool forceCheck)
{
  __int64 result; 
  unsigned int IconDims; 
  vec3_t outOrigin; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21591, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent", -2i64) )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21592, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( !x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21593, ASSERT_TYPE_ASSERT, "(x)", (const char *)&queryFormat, "x") )
    __debugbreak();
  if ( !y && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21594, ASSERT_TYPE_ASSERT, "(y)", (const char *)&queryFormat, "y") )
    __debugbreak();
  if ( !w && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21595, ASSERT_TYPE_ASSERT, "(w)", (const char *)&queryFormat, "w") )
    __debugbreak();
  if ( !h && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21596, ASSERT_TYPE_ASSERT, "(h)", (const char *)&queryFormat, "h") )
    __debugbreak();
  if ( BG_IsCharacterEntity(&cent->nextState) || forceCheck )
  {
    CG_GetPoseOrigin(&cent->pose, &outOrigin);
    IconDims = CgWeaponSystem::GetIconDims(this, &outOrigin, x, y, w, h);
    memset(&outOrigin, 0, sizeof(outOrigin));
    return IconDims;
  }
  else
  {
    result = 0i64;
    *x = 0.0;
    *y = 0.0;
    *w = 0.0;
    *h = 0.0;
  }
  return result;
}

/*
==============
MovementAnimState::GetOffsetAnimation
==============
*/
__int64 MovementAnimState::GetOffsetAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  __int32 v3; 
  __int32 v4; 

  if ( state == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5762, ASSERT_TYPE_ASSERT, "(state != State::NONE)", (const char *)&queryFormat, "state != State::NONE") )
    __debugbreak();
  if ( state )
  {
    v3 = state - 1;
    if ( !v3 )
      return 47i64;
    v4 = v3 - 1;
    if ( !v4 )
      return 48i64;
    if ( v4 == 1 )
      return 49i64;
  }
  return 46i64;
}

/*
==============
CAssistTarget::GetTarget
==============
*/
const centity_t *CAssistTarget::GetTarget(CAssistTarget *this)
{
  return this->m_target;
}

/*
==============
CgWeaponSystem::GetTargetEvaluator
==============
*/
CConeTargetEvaluator *CgWeaponSystem::GetTargetEvaluator(targetAssistType_t assistType)
{
  if ( assistType == TARGET_ASSISTTYPPE_CONE )
    return &CgWeaponSystem::ms_coneTargetEvaluator;
  else
    return 0i64;
}

/*
==============
MovementAnimState::GetTransitionAnimation
==============
*/
__int64 MovementAnimState::GetTransitionAnimation(MovementAnimState *this, MovementAnimState::State prevState, const MovementAnimState::State nextState)
{
  __int64 v3; 
  MovementAnimState::State v5; 
  bool v6; 
  MovementAnimState::State v7; 
  weapAnimFiles_t v8; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 

  v3 = nextState;
  if ( prevState == nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5725, ASSERT_TYPE_ASSERT, "( static_cast<int>( prevState ) ) != ( static_cast<int>( nextState ) )", "%s != %s\n\t%i, %i", "static_cast<int>( prevState )", "static_cast<int>( nextState )", prevState, nextState) )
    __debugbreak();
  if ( prevState == -1 )
  {
    v5 = NONE;
    if ( !(_DWORD)v3 )
    {
      v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5734, ASSERT_TYPE_ASSERT, "(nextState != State::WALK)", (const char *)&queryFormat, "nextState != State::WALK");
      goto LABEL_17;
    }
  }
  v7 = NONE;
  if ( prevState != -1 )
    v7 = prevState;
  if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5750, ASSERT_TYPE_ASSERT, "(nextState != State::NONE)", (const char *)&queryFormat, "nextState != State::NONE") )
    __debugbreak();
  if ( (unsigned int)v7 >= LONG_LONG )
  {
    LODWORD(v11) = 4;
    LODWORD(v10) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5751, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( prevState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions ) ) + 0 ) )", "static_cast<int>( prevState ) doesn't index ARRAY_COUNT( s_transitions )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  v5 = v7;
  if ( (unsigned int)v3 >= 4 )
  {
    LODWORD(v11) = 4;
    LODWORD(v10) = v3;
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5752, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( nextState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions[0] ) ) + 0 ) )", "static_cast<int>( nextState ) doesn't index ARRAY_COUNT( s_transitions[0] )\n\t%i not in [0, %i)", v10, v11);
LABEL_17:
    if ( v6 )
      __debugbreak();
  }
  v8 = s_transitions[v5][v3];
  if ( v8 == WEAP_ANIM_ROOT )
  {
    LODWORD(v12) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5754, ASSERT_TYPE_ASSERT, "( static_cast<int>( transitionAnim ) ) != ( 0 )", "%s != %s\n\t%i, %i", "static_cast<int>( transitionAnim )", "0", v12, 0i64) )
      __debugbreak();
  }
  return (unsigned int)v8;
}

/*
==============
MovementAnimState::GetTransitionDuration
==============
*/
void MovementAnimState::GetTransitionDuration(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  __int64 v7; 
  const Weapon *ViewmodelWeapon; 
  bool v11; 
  bool v12; 
  float value; 
  const dvar_t *v14; 
  __int32 v15; 
  int v16; 
  double Float_Internal_DebugName; 
  int v18; 
  float v19; 
  int v20; 
  __int64 v21; 
  __int64 v22; 

  v7 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5644, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5645, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !outTransDurationSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5646, ASSERT_TYPE_ASSERT, "(outTransDurationSec)", (const char *)&queryFormat, "outTransDurationSec") )
    __debugbreak();
  if ( !outCycleTransDurationSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5647, ASSERT_TYPE_ASSERT, "(outCycleTransDurationSec)", (const char *)&queryFormat, "outCycleTransDurationSec") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v7], ps);
  v11 = BG_UsingAlternate(ps);
  v12 = BG_PlayerDualWielding(ps) != 0;
  if ( prevState == -1 && nextState == NONE )
  {
    *outTransDurationSec = 0.0;
    value = 0.0;
    goto LABEL_54;
  }
  if ( nextState < prevState )
  {
    if ( (unsigned int)v7 >= 2 )
    {
      LODWORD(v22) = 2;
      LODWORD(v21) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5615, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5616, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( MovementAnimState::PlayerActionForcesWalk((const LocalClientNum_t)v7, ps) )
    {
      if ( prevState == HALF_HALF )
      {
        v14 = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint;
        if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_QuickTransOutSprint") )
          __debugbreak();
LABEL_31:
        Dvar_CheckFrontendServerThread(v14);
        value = v14->current.value;
LABEL_53:
        *outTransDurationSec = value;
        goto LABEL_54;
      }
      if ( prevState == LONG )
      {
        v14 = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint;
        if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_QuickTransOutSuperSprint") )
          __debugbreak();
        goto LABEL_31;
      }
    }
    v15 = prevState - 2;
    if ( !v15 )
    {
      v19 = (float)BG_MoveTransitionTime(ps, ViewmodelWeapon, v11, v12, MOVE_TRANS_DOWNFROM_SPRINT);
      value = ScaleSprintOutTime((const LocalClientNum_t)v7, v19 * 0.001);
      goto LABEL_53;
    }
    if ( v15 == 1 )
    {
      v16 = BG_MoveTransitionTime(ps, ViewmodelWeapon, v11, v12, MOVE_TRANS_DOWNFROM_SUPERSPRINT);
      *outTransDurationSec = ScaleSprintOutTime((const LocalClientNum_t)v7, (float)v16 * 0.001);
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARMPFLT_movementAnimProto_DownFromSuperSprintCycleBlendScale, "movementAnimProto_DownFromSuperSprintCycleBlendScale");
      v18 = BG_MoveTransitionTime(ps, ViewmodelWeapon, v11, v12, MOVE_TRANS_DOWNFROM_SUPERSPRINT);
      value = ScaleSprintOutTime((const LocalClientNum_t)v7, (float)((float)v18 * 0.001) * *(float *)&Float_Internal_DebugName);
      goto LABEL_54;
    }
  }
  switch ( nextState )
  {
    case NONE:
      v20 = BG_MoveTransitionTime(ps, ViewmodelWeapon, v11, v12, MOVE_TRANS_TO_WALK);
      goto LABEL_52;
    case HALF:
      v20 = BG_MoveTransitionTime(ps, ViewmodelWeapon, v11, v12, MOVE_TRANS_TO_JOG);
      goto LABEL_52;
    case HALF_HALF:
      v20 = BG_MoveTransitionTime(ps, ViewmodelWeapon, v11, v12, MOVE_TRANS_TO_SPRINT);
      goto LABEL_52;
    case LONG:
      v20 = BG_MoveTransitionTime(ps, ViewmodelWeapon, v11, v12, MOVE_TRANS_TO_SUPERSPRINT);
LABEL_52:
      value = (float)v20 * 0.001;
      goto LABEL_53;
  }
  LODWORD(v21) = nextState;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5715, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "GetTransDuration(): Encountered unexpected nextState %i", v21) )
    __debugbreak();
  value = FLOAT_0_0099999998;
  *outTransDurationSec = 0.0099999998;
LABEL_54:
  *outCycleTransDurationSec = value;
}

/*
==============
HandleExclusiveAkimboSwitchAnimPlay
==============
*/
char HandleExclusiveAkimboSwitchAnimPlay(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v5; 
  cg_t *LocalClientGlobals; 
  const DObj **p_viewModelDObj; 
  const XAnimTree *tree; 
  double Weight; 
  double v10; 
  bool v11; 
  int weaponState; 
  unsigned __int16 i; 
  XAnimInfo *AnimInfo; 
  unsigned __int16 animIndex; 
  double v16; 
  double rate; 
  __int64 goalTime; 

  v5 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5919, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( (unsigned int)v5 >= 2 )
  {
    LODWORD(goalTime) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  p_viewModelDObj = (const DObj **)&LocalClientGlobals->m_weaponHand[v5].viewModelDObj;
  if ( (cg_t *)((char *)LocalClientGlobals + 40 * v5) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5922, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  tree = LocalClientGlobals->m_weaponHand[v5].tree;
  if ( !tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5925, ASSERT_TYPE_ASSERT, "(tree)", (const char *)&queryFormat, "tree") )
    __debugbreak();
  Weight = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0x14Bu);
  v11 = 1;
  if ( *(float *)&Weight <= 0.0 )
  {
    v10 = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0x148u);
    if ( *(float *)&v10 <= 0.0 )
      v11 = 0;
  }
  weaponState = ps->weapState[0].weaponState;
  if ( weaponState != 11 && weaponState != 4 || !v11 || ps->weapCommon.fWeaponPosFrac != 0.0 )
    return 0;
  if ( !tree->children && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5938, ASSERT_TYPE_ASSERT, "(tree->children)", (const char *)&queryFormat, "tree->children") )
    __debugbreak();
  for ( i = GetAnimInfo(tree->children)->children; i; i = AnimInfo->next )
  {
    AnimInfo = GetAnimInfo(i);
    animIndex = AnimInfo->animIndex;
    if ( animIndex != 331 && animIndex != 328 && animIndex != 14 )
    {
      v16 = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, animIndex);
      if ( *(float *)&v16 > 0.0 )
      {
        rate = XAnimGetRate(tree, 0, XANIM_SUBTREE_DEFAULT, AnimInfo->animIndex);
        XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, AnimInfo->animIndex, 0.0, 0.15000001, *(float *)&rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
  }
  return 1;
}

/*
==============
HoldBreathUpdate
==============
*/
void HoldBreathUpdate(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  int holdBreathDelay; 
  CgSoundSystem *SoundSystem; 
  const dvar_t *v5; 
  float v6; 
  double v7; 
  bool v8; 
  const dvar_t *v9; 
  const dvar_t *v10; 
  int holdBreathTime; 
  double Float_Internal_DebugName; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  holdBreathDelay = LocalClientGlobals->holdBreathDelay;
  if ( holdBreathDelay > 0 )
    LocalClientGlobals->holdBreathDelay = holdBreathDelay - LocalClientGlobals->frametime;
  SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 2u) )
  {
    v5 = DVARFLT_player_breath_snd_lerp;
    v6 = (float)LocalClientGlobals->frametime * 0.001;
    if ( !DVARFLT_player_breath_snd_lerp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_snd_lerp") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    v7 = DiffTrack(1.0, LocalClientGlobals->holdBreathFrac, v5->current.value, v6);
    LocalClientGlobals->holdBreathFrac = *(float *)&v7;
    CG_SND_PlayerBreathsHold(localClientNum);
    if ( LocalClientGlobals->holdBreathTime >= 0 )
    {
      if ( LocalClientGlobals->breathHoldState == BREATH_HOLD_HOLDING )
        CgSoundSystem::PlayClientSoundAlias(SoundSystem, cgMedia.playerHeartBeatSound);
    }
    else
    {
      v8 = LocalClientGlobals->holdBreathDelay <= 0;
      LocalClientGlobals->holdBreathTime = 0;
      if ( v8 )
      {
        v9 = DVARFLT_player_breath_snd_delay;
        if ( !DVARFLT_player_breath_snd_delay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_snd_delay") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v9);
        LocalClientGlobals->holdBreathDelay = (int)(float)(v9->current.value * 1000.0);
        v10 = DVARFLT_player_breath_snd_lerp;
        if ( !DVARFLT_player_breath_snd_lerp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_snd_lerp") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v10);
        CG_SetAudioOverride(localClientNum, "hold_breath", CTAUD_OVERRIDE_HOLDBREATH, v10->current.value, 2047);
      }
    }
    LocalClientGlobals->holdBreathTime += LocalClientGlobals->frametime;
  }
  else
  {
    holdBreathTime = LocalClientGlobals->holdBreathTime;
    if ( holdBreathTime >= 0 )
    {
      LocalClientGlobals->holdBreathTime = LocalClientGlobals->frametime + holdBreathTime;
      if ( LocalClientGlobals->holdBreathTime <= BG_HoldBreathMaxTime(&LocalClientGlobals->predictedPlayerState) )
      {
        if ( LocalClientGlobals->holdBreathDelay <= 0 )
        {
          Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_player_breath_snd_delay, "player_breath_snd_delay");
          LocalClientGlobals->holdBreathDelay = (int)(float)(*(float *)&Float_Internal_DebugName * 1000.0);
        }
      }
      else
      {
        CG_SND_PlayerBreathsGasp(localClientNum);
      }
    }
    LocalClientGlobals->holdBreathTime = -1;
    LocalClientGlobals->holdBreathFrac = 0.0;
    CG_ClearAudioOverride(localClientNum, CTAUD_OVERRIDE_HOLDBREATH, 0.0);
  }
}

/*
==============
IsAdditiveCrawlEnabled
==============
*/
_BOOL8 IsAdditiveCrawlEnabled(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand)
{
  const dvar_t *v3; 
  CgHandler *Handler; 
  CgHandler *v8; 
  _BOOL8 result; 

  v3 = DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedCrawl") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  result = 0;
  if ( v3->current.enabled )
  {
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_CRAWL_IN, hand, Handler) )
    {
      v8 = CgHandler::getHandler(localClientNum);
      if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_CRAWL_LOOP, hand, v8) )
        return 1;
    }
  }
  return result;
}

/*
==============
MovementAnimState::IsOffsetAnimationTransition
==============
*/
bool MovementAnimState::IsOffsetAnimationTransition(MovementAnimState *this, const weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 50) <= 0xB;
}

/*
==============
CgWeaponSystem::IsPlayerWeaponLaserOn
==============
*/
bool CgWeaponSystem::IsPlayerWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  return this->IsWeaponLaserOn(this, r_weapon, &LocalClientGlobals->predictedPlayerState, NULL) || this->IsLaserFlagOn(this, &LocalClientGlobals->predictedPlayerState) || CG_LaserForceOnEnabled();
}

/*
==============
CgWeaponSystem::IsWeaponLaserOn
==============
*/
bool CgWeaponSystem::IsWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon, const playerState_s *ps, const centity_t *cent)
{
  bool inAltWeaponMode; 
  cg_t *LocalClientGlobals; 
  const cg_t *v10; 
  bool v11; 
  double Float_Internal_DebugName; 
  bool v13; 
  double v14; 
  bool result; 
  entityState_t *p_nextState; 
  bool v17; 
  const characterInfo_t *CharacterInfo; 
  unsigned int Animset; 
  unsigned int Anim; 
  bool v21; 
  SuitAnimType SuitAnimIndex; 
  int LegsAnimation; 
  int usingNVG; 
  bool IsAdsEntity; 
  LaserSettings outLaserSettings; 

  if ( ps )
    inAltWeaponMode = BG_UsingAlternate(ps);
  else
    inAltWeaponMode = cent->nextState.inAltWeaponMode;
  BG_GetWeaponLaserSettings(r_weapon, inAltWeaponMode, &outLaserSettings);
  if ( !outLaserSettings.forceLaserOn )
    return 0;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v10 = LocalClientGlobals;
  if ( ps && ps == &LocalClientGlobals->predictedPlayerState )
  {
    if ( !BG_IsEMPJammed(ps) && (unsigned int)(ps->weapState[0].weaponState - 34) > 2 )
    {
      v11 = CG_LookingThroughNightVision((const LocalClientNum_t)this->m_localClientNum);
      Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_laserAdsFraction, "laserAdsFraction");
      v13 = *(float *)&Float_Internal_DebugName <= ps->weapCommon.fWeaponPosFrac;
      v14 = Dvar_GetFloat_Internal_DebugName(DVARFLT_laserHipFraction, "laserHipFraction");
      if ( v11 )
      {
        if ( v13 )
          return outLaserSettings.localPlayerNVGADSLaserEnabled;
        if ( *(float *)&v14 >= ps->weapCommon.fWeaponPosFrac && outLaserSettings.localPlayerNVGHipLaserEnabled )
          return 1;
      }
      else
      {
        if ( v13 )
          return outLaserSettings.localPlayerADSLaserEnabled;
        if ( *(float *)&v14 >= ps->weapCommon.fWeaponPosFrac && outLaserSettings.localPlayerHipLaserEnabled )
          return 1;
      }
    }
    return 0;
  }
  if ( (cent->nextState.lerp.u.player.playerFlags & 0x200) != 0 )
    return 0;
  p_nextState = &cent->nextState;
  v17 = CG_LookingThroughNightVision((const LocalClientNum_t)this->m_localClientNum);
  if ( !BG_IsPlayerOrAgentEntity(&cent->nextState) )
    return outLaserSettings.remotePlayerHipLaserEnabled;
  CharacterInfo = CG_GetCharacterInfo(v10, p_nextState->number);
  if ( !CharacterInfo )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25621, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26052, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
  }
  if ( !CharacterInfo->usingAnimState )
  {
    if ( PlayerASM_IsEnabled() )
    {
      Animset = BG_PlayerASM_GetAnimset(p_nextState);
      Anim = BG_PlayerASM_GetAnim(p_nextState, MOVEMENT);
      v21 = BG_PlayerASM_IsSprintAlias(Anim, Animset) == 0;
    }
    else
    {
      SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(p_nextState);
      LegsAnimation = BG_AnimationMP_GetLegsAnimation(p_nextState);
      v21 = !BG_IsSprintAnim(LegsAnimation, SuitAnimIndex);
    }
    if ( !v21 )
      return 0;
  }
  usingNVG = CharacterInfo->usingNVG;
  IsAdsEntity = BG_IsAdsEntity(p_nextState);
  if ( usingNVG != 1 || !v17 )
  {
    if ( IsAdsEntity )
      return outLaserSettings.remotePlayerADSLaserEnabled;
    return outLaserSettings.remotePlayerHipLaserEnabled;
  }
  result = outLaserSettings.remotePlayerNVGHipLaserEnabled;
  if ( IsAdsEntity )
    return outLaserSettings.remotePlayerNVGADSLaserEnabled;
  return result;
}

/*
==============
NormalizeForMinMax
==============
*/
float NormalizeForMinMax(float original, float min, float max)
{
  if ( min > max && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21984, ASSERT_TYPE_ASSERT, "(min <= max)", (const char *)&queryFormat, "min <= max") )
    __debugbreak();
  if ( original < min )
    return 0.0;
  if ( original > max )
    return FLOAT_1_0;
  if ( min == max )
    return 0.0;
  else
    return (float)(original - min) / (float)(max - min);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxStopAll
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxStopAll(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  ParticleManager *ParticleManager; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16755, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  CgWeaponSystem::OffhandWeaponVmFxValidate(this);
  if ( LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle )
  {
    ParticleManager = ParticleManager::GetParticleManager(this->m_localClientNum);
    ParticleManager::KillSystem(ParticleManager, LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle);
    LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxTryStart
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxTryStart(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16721, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef && !LocalClientGlobals->offhandWeaponVmFxInfo.isWeaponHidden && BG_IsOffhandWeaponType(&LocalClientGlobals->offhandWeaponVmFxInfo.weapon, LocalClientGlobals->offhandWeaponVmFxInfo.currentWeaponIsAlt) )
  {
    CgWeaponSystem::OffhandWeaponVmFxValidate(this);
    if ( LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle == PARTICLE_SYSTEM_INVALID_HANDLE )
      LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle = CG_PlayBoltedEffect(this->m_localClientNum, &LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef, 2048, scr_const.tag_fx);
  }
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxUpdate
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxUpdate(CgWeaponSystem *this, const Weapon *currWeap, bool isAlternate)
{
  cg_t *LocalClientGlobals; 
  DObj *ClientDObj; 
  unsigned __int8 numBones; 
  const XModel *FirstModel; 
  FxCombinedDef v10; 
  cg_t *v11; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16775, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  ClientDObj = Com_GetClientDObj(2048, this->m_localClientNum);
  numBones = 0;
  FirstModel = NULL;
  if ( ClientDObj )
  {
    numBones = ClientDObj->numBones;
    FirstModel = DObjGetFirstModel(ClientDObj);
  }
  if ( memcmp_0(&LocalClientGlobals->offhandWeaponVmFxInfo, currWeap, 0x3Cui64) || isAlternate != LocalClientGlobals->offhandWeaponVmFxInfo.currentWeaponIsAlt || numBones != LocalClientGlobals->offhandWeaponVmFxInfo.viewModelBoneCount || FirstModel != LocalClientGlobals->offhandWeaponVmFxInfo.handModel || LocalClientGlobals->playerWeaponInfo.isWeaponHidden != LocalClientGlobals->offhandWeaponVmFxInfo.isWeaponHidden )
  {
    CgWeaponSystem::OffhandWeaponVmFxStopAll(this);
    *(__m256i *)&LocalClientGlobals->offhandWeaponVmFxInfo.weapon.weaponIdx = *(__m256i *)&currWeap->weaponIdx;
    *(_OWORD *)&LocalClientGlobals->offhandWeaponVmFxInfo.weapon.attachmentVariationIndices[5] = *(_OWORD *)&currWeap->attachmentVariationIndices[5];
    *(double *)&LocalClientGlobals->offhandWeaponVmFxInfo.weapon.attachmentVariationIndices[21] = *(double *)&currWeap->attachmentVariationIndices[21];
    *(_DWORD *)&LocalClientGlobals->offhandWeaponVmFxInfo.weapon.weaponCamo = *(_DWORD *)&currWeap->weaponCamo;
    LocalClientGlobals->offhandWeaponVmFxInfo.currentWeaponIsAlt = isAlternate;
    LocalClientGlobals->offhandWeaponVmFxInfo.viewModelBoneCount = numBones;
    LocalClientGlobals->offhandWeaponVmFxInfo.handModel = FirstModel;
    LocalClientGlobals->offhandWeaponVmFxInfo.isWeaponHidden = LocalClientGlobals->playerWeaponInfo.isWeaponHidden;
    LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef = NULL;
    v10.particleSystemDef = BG_VMProjBodyEffect(currWeap, isAlternate).particleSystemDef;
    if ( v10.particleSystemDef )
      LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef = v10.particleSystemDef;
  }
  v11 = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16721, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( v11->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef && !v11->offhandWeaponVmFxInfo.isWeaponHidden && BG_IsOffhandWeaponType(&v11->offhandWeaponVmFxInfo.weapon, v11->offhandWeaponVmFxInfo.currentWeaponIsAlt) )
  {
    CgWeaponSystem::OffhandWeaponVmFxValidate(this);
    if ( v11->offhandWeaponVmFxInfo.currentFxHandle == PARTICLE_SYSTEM_INVALID_HANDLE )
      v11->offhandWeaponVmFxInfo.currentFxHandle = CG_PlayBoltedEffect(this->m_localClientNum, &v11->offhandWeaponVmFxInfo.fxRegDef, 2048, scr_const.tag_fx);
  }
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxValidate
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxValidate(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  ParticleSystemHandle currentFxHandle; 
  __int64 v4; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16706, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  currentFxHandle = LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle;
  if ( currentFxHandle )
  {
    v4 = ((__int64)(int)this->m_localClientNum << 12) + (currentFxHandle & 0xFFF);
    if ( g_particleSystemsGeneration[v4].__all32 != currentFxHandle || g_particleSystems[0][v4] < (ParticleSystem *)0x1000 )
      LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CgWeaponSystem::OutOfAmmoChange
==============
*/
void CgWeaponSystem::OutOfAmmoChange(CgWeaponSystem *this, bool clipOnly)
{
  bool IsGamepadEnabled; 
  LocalClientNum_t m_localClientNum; 
  bool AutoWeaponSwitchGamepad; 
  cg_t *LocalClientGlobals; 
  cg_t *v8; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned __int16 weaponIdx; 
  bool v12; 
  const PlayerEquippedWeaponState *EquippedWeaponState; 
  const WeaponDef *v14; 
  const PlayerEquippedWeaponState *v15; 
  int v16; 
  unsigned __int8 ActiveGameMode; 
  WeaponSlot CurrentWeaponSlot; 
  WeaponSlot CycleSlot; 
  int v20; 
  unsigned __int16 v21; 

  IsGamepadEnabled = CL_Input_IsGamepadEnabled(this->m_localClientNum);
  m_localClientNum = this->m_localClientNum;
  if ( IsGamepadEnabled )
    AutoWeaponSwitchGamepad = GamerProfile_GetAutoWeaponSwitchGamepad(m_localClientNum);
  else
    AutoWeaponSwitchGamepad = GamerProfile_GetAutoWeaponSwitchKeyboard(m_localClientNum);
  if ( !AutoWeaponSwitchGamepad )
    return;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v8 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return;
  if ( LocalClientGlobals->demoType )
    return;
  if ( CG_View_IsKillCamView((const LocalClientNum_t)this->m_localClientNum) )
    return;
  if ( v8->predictedPlayerState.pm_type >= 7 )
    return;
  Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)this->m_localClientNum);
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v8->predictedPlayerState.weapCommon.weapFlags, GameModeFlagValues::ms_spValue, 0x37u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v8->predictedPlayerState.weapCommon.weapFlags, GameModeFlagValues::ms_mpValue, 0x39u) )
    return;
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &v8->predictedPlayerState);
  weaponIdx = CurrentWeaponForPlayer->weaponIdx;
  v21 = CurrentWeaponForPlayer->weaponIdx;
  v12 = CurrentWeaponForPlayer->weaponIdx && BG_UsingAlternate(&v8->predictedPlayerState);
  if ( !weaponIdx && v8->weaponLatestPrimary.weaponIdx && BG_PlayerHasWeapon(Instance, &v8->predictedPlayerState, &v8->weaponLatestPrimary) )
  {
    EquippedWeaponState = BG_GetEquippedWeaponState(Instance, &v8->predictedPlayerState, &v8->weaponLatestPrimary);
    if ( EquippedWeaponState )
      LOBYTE(EquippedWeaponState) = EquippedWeaponState->inAltMode;
    CG_SelectWeapon(this->m_localClientNum, &v8->weaponLatestPrimary, (unsigned __int8)EquippedWeaponState);
    return;
  }
  v14 = BG_WeaponDef(CurrentWeaponForPlayer, v12);
  if ( !BG_IsThrowingAxe(CurrentWeaponForPlayer) || BG_IsRemoveWeaponOnEmpty(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer, v12) )
  {
    if ( v14->cancelAutoHolsterWhenEmpty || v21 && BG_Offhand_HasActiveOffhand(&v8->predictedPlayerState) && !BG_AllowWeaponSwitchWhileHoldingGrenade(CurrentWeaponForPlayer, v12) )
      return;
    if ( BG_PlayerDualWieldingWeapon(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer) && (!BG_WeaponBothClipEmpty(Instance, &v8->predictedPlayerState) || BG_WeaponWillHaveEnoughAmmoToFireAfterAutoReload(Instance, &v8->predictedPlayerState)) )
      goto LABEL_48;
    if ( v12 && BG_WeaponAmmo(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer, v12) )
      goto LABEL_34;
    if ( !CycleWeapPrimary(this->m_localClientNum, 0, 1, 1, 0, 1) )
    {
      if ( v12 )
      {
LABEL_34:
        v15 = BG_GetEquippedWeaponState(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer);
        if ( v15 )
          CG_SelectWeapon(this->m_localClientNum, CurrentWeaponForPlayer, v15->inAltMode);
        else
          CG_SelectWeapon(this->m_localClientNum, CurrentWeaponForPlayer, 0);
        goto LABEL_48;
      }
      if ( clipOnly && CycleWeapPrimary(this->m_localClientNum, 0, 1, 0, 0, 1) )
      {
        if ( v14->inventoryType == WEAPINVENTORY_ALTMODE )
          return;
        v16 = v8->time + 1500;
LABEL_52:
        v8->weaponForcedSelectTime = v16;
        return;
      }
      if ( !Dvar_GetBool_Internal_DebugName(DVARBOOL_cg_autoSwitchToHeavyWeapon, "cg_autoSwitchToHeavyWeapon") )
      {
        ActiveGameMode = Com_GameMode_GetActiveGameMode();
        if ( BG_GameInterface_GameModeIsMP((GameModeType)ActiveGameMode) )
          return;
      }
      CurrentWeaponSlot = CG_GetCurrentWeaponSlot(this->m_localClientNum);
      if ( CurrentWeaponSlot == WEAPON_SLOT_NONE )
        return;
      CycleSlot = BG_PlayerWeaponGetCycleSlot(CurrentWeaponSlot, 1);
      if ( !CG_Weapons_PlayerWeaponSlotHasWeaponsWithAmmo((const LocalClientNum_t)this->m_localClientNum, &v8->predictedPlayerState, CycleSlot) || !CycleWeapPrimary(this->m_localClientNum, 1, 1, 0, 0, 1) )
        return;
    }
LABEL_48:
    if ( v14->inventoryType == WEAPINVENTORY_ALTMODE )
      return;
    v20 = 750;
    if ( clipOnly )
      v20 = 1500;
    v16 = v8->time + v20;
    goto LABEL_52;
  }
  if ( !v12 )
    CG_SelectWeapon(this->m_localClientNum, CurrentWeaponForPlayer, 1);
}

/*
==============
PlayADSAnim
==============
*/

void __fastcall PlayADSAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, const bool isADSWeapon, double weaponPosFrac, DObj *obj, const int weaponAnim, PlayerHandIndex hand)
{
  __int128 v7; 
  PlayerHandIndex v8; 
  cg_t *LocalClientGlobals; 
  bool v14; 
  bool adsAltSwitchInProgress; 
  const dvar_t *v16; 
  unsigned int v19; 
  CgWeaponMap *Instance; 
  const Weapon *ViewmodelWeapon; 
  float v22; 
  __int128 v23; 
  float v28; 
  float v29; 
  __int128 v30; 
  double v31; 
  __int128 v33; 
  double v34; 
  bool fWeaponPosFracIn; 
  unsigned int notifyType; 
  BgHandler *v37; 
  int v38; 
  int v39; 
  bool v41; 
  unsigned int OtherAdsUpAnim; 
  signed int AdsDownAnim; 
  unsigned int OtherAdsDownAnim; 
  float v52; 
  unsigned int v53; 
  unsigned int v54; 
  char v55; 
  bool v56; 
  bool v57; 
  unsigned int v61; 
  XAnimTree *v62; 
  float v63; 
  float v64; 
  double v65; 
  double v66; 
  bool v67; 
  bool v68; 
  bool outIsFinishedAccel; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 
  BgHandler *pmoveHandler; 
  XAnimTree *tree; 

  v8 = hand;
  _XMM10 = *(_OWORD *)&weaponPosFrac;
  if ( CG_GameInterface_PlayADSAnim(localClientNum, ps, isADSWeapon, *(float *)&weaponPosFrac, obj, weaponAnim, hand) )
    return;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6826, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6827, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  tree = DObjGetTree(obj);
  if ( !tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6830, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  pmoveHandler = CgHandler::getHandler(localClientNum);
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6833, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v14 = BG_UsingAlternate(ps);
  adsAltSwitchInProgress = LocalClientGlobals->adsAltSwitchInProgress;
  v16 = DCONST_DVARBOOL_cg_viewmodelAdsUpDown;
  v67 = adsAltSwitchInProgress;
  if ( !DCONST_DVARBOOL_cg_viewmodelAdsUpDown && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdsUpDown") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v16);
  _XMM8 = LODWORD(FLOAT_1_0);
  if ( !v16->current.enabled || weaponAnim == 55 || hand == WEAPON_HAND_LEFT && BG_HasLadderHand(ps) )
  {
LABEL_35:
    v19 = 0;
    _XMM11 = 0i64;
    goto LABEL_36;
  }
  if ( isADSWeapon )
  {
    if ( !v67 )
    {
      Instance = CgWeaponMap::GetInstance(localClientNum);
      ViewmodelWeapon = BG_GetViewmodelWeapon(Instance, ps);
      *(double *)&v7 = BG_GetADSVelocityScale(Instance, ps, ViewmodelWeapon, v14);
      v22 = *(float *)&v7;
      BG_GetADSTransTimes(Instance, ps, ViewmodelWeapon, v14, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
      v23 = v7;
      *(float *)&v23 = (float)(*(float *)&v7 * 1000.0) * outAdsTransInSpeedMs;
      _XMM4 = v23;
      _XMM0 = ps->weapCommon.fWeaponPosFracIn;
      __asm
      {
        vpcmpeqd xmm2, xmm0, xmm1
        vblendvps xmm0, xmm4, xmm3, xmm2
      }
      outAdsTransInSpeedMs = (float)(v22 * 1000.0) * outAdsTransInSpeedMs;
      outAdsTransOutSpeedMs = (float)(v22 * -1000.0) * outAdsTransOutSpeedMs;
      *(double *)&_XMM0 = BG_GetADSFracCurrentVelocity(Instance, ps, ViewmodelWeapon, v14, *(float *)&_XMM0, &outIsFinishedAccel);
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, outAdsTransOutSpeedMs, outAdsTransInSpeedMs);
      v28 = outAdsTransOutSpeedMs;
      v29 = outAdsTransInSpeedMs;
      if ( outAdsTransOutSpeedMs >= outAdsTransInSpeedMs )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6887, ASSERT_TYPE_ASSERT, "( adsOutVelocity ) < ( adsInVelocity )", "%s < %s\n\t%g, %g", "adsOutVelocity", "adsInVelocity", outAdsTransOutSpeedMs, outAdsTransInSpeedMs) )
          __debugbreak();
        v29 = outAdsTransInSpeedMs;
        v28 = outAdsTransOutSpeedMs;
      }
      v30 = _XMM0;
      *(float *)&v30 = (float)(*(float *)&_XMM0 - v28) / (float)(v29 - v28);
      v31 = I_fclamp(*(float *)&v30, 0.0, 1.0);
      _XMM9 = v30;
      v33 = LODWORD(FLOAT_1_0);
      *(float *)&v33 = 1.0 - *(float *)&v31;
      v34 = I_fclamp(1.0 - *(float *)&v31, 0.0, 1.0);
      fWeaponPosFracIn = ps->weapCommon.fWeaponPosFracIn;
      v19 = 1;
      _XMM11 = v33;
      if ( !fWeaponPosFracIn || (notifyType = 1, *(float *)&_XMM9 <= 0.0) )
        notifyType = 0;
      if ( fWeaponPosFracIn || *(float *)&v34 <= 0.0 )
        v19 = 0;
      v8 = hand;
      CG_Weapon_PlayADSSettleAnim(localClientNum, ps, *(float *)&_XMM10, obj, hand, *(float *)&v34);
      goto LABEL_37;
    }
    goto LABEL_35;
  }
  _XMM10 = 0i64;
  _XMM11 = LODWORD(FLOAT_1_0);
  v19 = 1;
LABEL_36:
  _XMM9 = 0i64;
  notifyType = 0;
LABEL_37:
  v37 = pmoveHandler;
  v38 = BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_ADS_UP, v8, pmoveHandler);
  v68 = v38 != 0;
  v39 = v38;
  __asm { vcmpless xmm0, xmm10, xmm7 }
  v41 = BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_ADS_DOWN, v8, v37) != 0;
  outIsFinishedAccel = v41;
  __asm { vblendvps xmm0, xmm8, xmm7, xmm0 }
  outAdsTransOutSpeedMs = *(float *)&_XMM0;
  if ( v39 )
  {
    _XMM0 = v41;
    __asm
    {
      vpcmpeqd xmm2, xmm0, xmm1
      vblendvps xmm12, xmm9, xmm8, xmm2
    }
  }
  else
  {
    LODWORD(_XMM12) = 0;
  }
  _XMM0 = v41;
  __asm
  {
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm6, xmm11, xmm7, xmm2
  }
  outAdsTransInSpeedMs = COERCE_FLOAT(BG_GetAdsUpAnim(ps, v37));
  OtherAdsUpAnim = BG_GetOtherAdsUpAnim(SLODWORD(outAdsTransInSpeedMs));
  AdsDownAnim = BG_GetAdsDownAnim(ps, v37);
  OtherAdsDownAnim = BG_GetOtherAdsDownAnim((const weapAnimFiles_t)AdsDownAnim);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsUpAnim, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsDownAnim, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  v52 = outAdsTransInSpeedMs;
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, LODWORD(outAdsTransInSpeedMs), *(float *)&_XMM9, 0.0, 0.0, (scr_string_t)0, notifyType, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, *(float *)&_XMM11, 0.0, 0.0, (scr_string_t)0, v19, 0, LINEAR, NULL);
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x1Eu, outAdsTransOutSpeedMs, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  v53 = 0;
  if ( *(float *)&_XMM12 > 0.0 )
    v53 = notifyType;
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x1Fu, *(float *)&_XMM12, 0.0, 0.0, (scr_string_t)0, v53, 0, LINEAR, NULL);
  v54 = 0;
  if ( *(float *)&_XMM6 > 0.0 )
    v54 = v19;
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x20u, *(float *)&_XMM6, 0.0, 0.0, (scr_string_t)0, v54, 0, LINEAR, NULL);
  v55 = ps->skydivePlayerState.state[0];
  v56 = *(float *)&_XMM9 == 0.0 && *(float *)&_XMM11 == 0.0;
  v57 = v55 == 5 && (*(float *)&_XMM9 == 0.0 || v56);
  _XMM0 = v57;
  __asm
  {
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm0, xmm8, xmm7, xmm2
  }
  outAdsTransInSpeedMs = *(float *)&_XMM0;
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM10, 0.0, 1.0);
  v61 = LODWORD(v52);
  v62 = tree;
  XAnimSetTime(tree, 0, XANIM_SUBTREE_DEFAULT, v61, *(float *)&_XMM0);
  v63 = 1.0 - *(float *)&_XMM10;
  *(double *)&_XMM0 = I_fclamp(1.0 - *(float *)&_XMM10, 0.0, 1.0);
  XAnimSetTime(v62, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, *(float *)&_XMM0);
  if ( v68 )
  {
    if ( v55 == 5 )
    {
      I_fclamp(v63, 0.0, 1.0);
      v64 = 1.0 - *(float *)&_XMM10;
    }
    else
    {
      v64 = 0.0;
    }
    v65 = I_fclamp(*(float *)&_XMM10, 0.0, 1.0);
    XAnimSetTime(v62, 0, XANIM_SUBTREE_DEFAULT, 0x1Fu, *(float *)&v65);
  }
  else
  {
    v64 = outAdsTransInSpeedMs;
  }
  if ( outIsFinishedAccel )
  {
    if ( v55 == 5 )
    {
      I_fclamp(*(float *)&_XMM10, 0.0, 1.0);
      v64 = *(float *)&_XMM10;
    }
    else
    {
      v64 = 0.0;
    }
    v66 = I_fclamp(v63, 0.0, 1.0);
    XAnimSetTime(v62, 0, XANIM_SUBTREE_DEFAULT, 0x20u, *(float *)&v66);
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x1B0u, v64, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
PlayAdditiveADSAnim
==============
*/
void PlayAdditiveADSAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  XAnimTree *Tree; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4015, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_ADS_UP, hand, Handler) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4025, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4028, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4031, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4032, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && BG_IsSwimWeapon(weapon) )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4039, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING )") )
        __debugbreak();
      _XMM0 = LODWORD(ps->weapCommon.fAdditivePosFrac);
      __asm { vmaxss  xmm1, xmm0, dword ptr [rbx+730h] }
      if ( *(float *)&_XMM1 >= 0.001 )
      {
        XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 0.0);
        XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 0.0);
        BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_SPRINT_OUT, WEAP_ANIM_IDLE, 0.050000001, 0.050000001);
        BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_SPRINT_IN_CANCEL, WEAP_ANIM_IDLE, 0.050000001, 0.050000001);
        BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_ALT_RAISE, WEAP_ANIM_IDLE, 0.1, 0.1);
        BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_ALT_RAISE_ADS, WEAP_ANIM_IDLE, 0.1, 0.1);
        BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_ALT_RAISE_AKIMBO, WEAP_ANIM_IDLE, 0.1, 0.1);
        BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_FIRST_RAISE, WEAP_ANIM_IDLE, 0.2, 0.2);
      }
    }
  }
}

/*
==============
PlayAdditiveCosmeticLoopAnim
==============
*/
void PlayAdditiveCosmeticLoopAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v7; 
  CgWeaponMap *v8; 
  cg_t *LocalClientGlobals; 
  int v10; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 

  v7 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4513, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[v7];
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4517, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4519, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v10 = BG_PlayerDualWieldingWeapon(v8, ps, weapon);
  if ( BG_IsAnimInWeaponPackages(weapon, 0, v10 == 1, ps->weapCommon.meleeComboSeqIdx, WEAP_ANIM_ADDITIVE_COSMETIC) )
  {
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4530, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4532, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB1u, 1.0, 1.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB2u, 1.0, 1.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
}

/*
==============
PlayAdditiveCrawlAnims
==============
*/
void PlayAdditiveCrawlAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v4; 
  __int64 v7; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  CgHandler *Handler; 
  const snapshot_t *snap; 
  const snapshot_t *nextSnap; 
  float *v14; 
  float *v15; 
  float v16; 
  float v17; 
  float v18; 
  const dvar_t *v19; 
  const dvar_t *v20; 
  float v25; 
  CgWeaponMap *Instance; 
  const Weapon *ViewmodelWeapon; 
  bool v28; 
  float v29; 
  __int128 v31; 
  float outAdsTransInSpeedMs; 
  float outAdsTransOutSpeedMs[3]; 

  v4 = DCONST_DVARINT_cg_crawlBlendTime;
  v7 = hand;
  if ( !DCONST_DVARINT_cg_crawlBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4915, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( IsAdditiveCrawlEnabled(localClientNum, ps, (PlayerHandIndex)v7) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v7);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4925, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    Handler = CgHandler::getHandler(localClientNum);
    if ( !BG_ShouldPlayAdditiveCrawlAnim(ps, (const PlayerHandIndex)v7, Handler) )
      goto LABEL_50;
    if ( !BG_IsSpectating(ps) )
      goto LABEL_23;
    snap = LocalClientGlobals->snap;
    if ( !snap )
      goto LABEL_23;
    nextSnap = LocalClientGlobals->nextSnap;
    if ( !nextSnap || snap == nextSnap )
      goto LABEL_23;
    v14 = (float *)snap->GetPlayerState(snap, (const LocalClientNum_t)localClientNum);
    v15 = (float *)nextSnap->GetPlayerState(nextSnap, (const LocalClientNum_t)localClientNum);
    if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4941, ASSERT_TYPE_ASSERT, "(prevPs)", (const char *)&queryFormat, "prevPs") )
      __debugbreak();
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4942, ASSERT_TYPE_ASSERT, "(nextPs)", (const char *)&queryFormat, "nextPs") )
      __debugbreak();
    v16 = v15[12] - v14[12];
    v17 = v15[13] - v14[13];
    v18 = v15[14] - v14[14];
    if ( (float)((float)((float)(v17 * v17) + (float)(v16 * v16)) + (float)(v18 * v18)) < 0.001 )
    {
LABEL_50:
      if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&ps->eFlags, ACTIVE, 0xAu) )
      {
        v19 = DCONST_DVARINT_cg_crawlBlendOutTimeFiring;
        if ( !DCONST_DVARINT_cg_crawlBlendOutTimeFiring && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendOutTimeFiring") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v19);
      }
      if ( BG_PWF_UseAlternateAsOffhand(ps) )
      {
        if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4963, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
          __debugbreak();
        v20 = DCONST_DVARINT_cg_crawlBlendOutTimeFiring;
        if ( !DCONST_DVARINT_cg_crawlBlendOutTimeFiring && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendOutTimeFiring") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v20);
      }
      _XMM7 = 0i64;
      _XMM0 = (unsigned int)(ps->weapState[v7].weaponState - 22);
      __asm
      {
        vpcmpgtq xmm2, xmm0, xmm1
        vblendvps xmm6, xmm7, xmm6, xmm2
      }
      v25 = (float)(LocalClientGlobals->time - LocalClientGlobals->lastProneCrawlInputTime) * 0.001;
      outAdsTransInSpeedMs = *(float *)&_XMM6;
      if ( v25 >= *(float *)&_XMM6 )
      {
        LODWORD(_XMM6) = 0;
      }
      else if ( ps->weapCommon.fWeaponPosFrac > 0.0 )
      {
        Instance = CgWeaponMap::GetInstance(localClientNum);
        ViewmodelWeapon = BG_GetViewmodelWeapon(Instance, ps);
        v28 = BG_UsingAlternate(ps);
        BG_GetADSTransTimes(Instance, ps, ViewmodelWeapon, v28, &outAdsTransInSpeedMs, outAdsTransOutSpeedMs);
        v29 = outAdsTransInSpeedMs;
        if ( outAdsTransInSpeedMs <= 0.0 )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4982, ASSERT_TYPE_ASSERT, "( ( adsTransInTime > 0.0f ) )", "( adsTransInTime ) = %g", outAdsTransInSpeedMs) )
            __debugbreak();
          v29 = outAdsTransInSpeedMs;
        }
        v31 = LODWORD(FLOAT_0_001);
        *(float *)&v31 = 0.001 / v29;
        _XMM0 = v31;
        __asm { vminss  xmm6, xmm0, xmm6 }
      }
      LocalClientGlobals->firstProneCrawlLoopTime = -1;
      if ( v25 >= *(float *)&_XMM6 )
      {
        LocalClientGlobals->prevProneForwardAnimTime = -1.0;
        LocalClientGlobals->prevProneLeftRightAnimTime = 0.0;
      }
      UpdateAdditiveCrawlBlend(LocalClientGlobals->frametime, 0.0, &LocalClientGlobals->crawlForwardBlend);
      UpdateAdditiveCrawlBlend(LocalClientGlobals->frametime, 0.0, &LocalClientGlobals->crawlRightBlend);
      StopAdditiveCrawlAnims(localClientNum, ps, viewModelDObj, (const PlayerHandIndex)v7, *(const float *)&_XMM6);
    }
    else
    {
LABEL_23:
      LocalClientGlobals->lastProneCrawlInputTime = LocalClientGlobals->time;
      UpdateAdditiveCrawlAnims(localClientNum, ps, viewModelDObj, (const PlayerHandIndex)v7);
    }
  }
}

/*
==============
PlayAdditiveEmptyAnim
==============
*/
void PlayAdditiveEmptyAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v4; 
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  bool v13; 
  const char *v14; 
  bool v15; 
  double v16; 
  double GoalWeight; 

  v4 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3906, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_EMPTY, (PlayerHandIndex)v4, Handler) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v4);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3914, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3917, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3920, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3921, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    if ( !Tree->anims[30].entries[0].parts )
    {
      v13 = BG_UsingAlternate(ps);
      v14 = "false";
      if ( v13 )
        v14 = "true";
      Com_PrintError(19, "PlayAdditiveEmptyAnim: missing anim parts for WEAP_ANIM_ADDITIVE_EMPTY on hand: %d, isAlternate: %s\n", (unsigned int)v4, v14);
      DevPrintAnimTree(localClientNum, Tree, ps, (unsigned int)v4, weapon);
    }
    v15 = BG_UsingAlternate(ps);
    if ( BG_GetAmmoInClip(ps, weapon, v15, (PlayerHandIndex)v4) || (unsigned int)(ps->weapState[v4].weaponState - 18) <= 3 )
    {
      GoalWeight = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xB3u);
      if ( *(float *)&GoalWeight != 0.0 )
      {
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB3u, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB4u, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
      }
    }
    else
    {
      v16 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xB3u);
      if ( *(float *)&v16 != 1.0 )
      {
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB3u, 1.0, 0.050000001, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB4u, 1.0, 0.050000001, 1.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      }
    }
  }
}

/*
==============
PlayAdditiveFingerPoseAnims
==============
*/
void PlayAdditiveFingerPoseAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v6; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  double GoalWeight; 
  float v10; 
  double v11; 
  float v12; 
  unsigned __int64 weaponState; 
  __int64 v14; 
  bool v15; 
  bool IsSkydiving; 
  const dvar_t *v17; 
  bool v18; 
  const dvar_t *v19; 
  const XAnimInfo *AnimInfo; 
  CgHandler *Handler; 
  double v22; 
  float v23; 
  __int128 goalTime; 
  CgHandler *v27; 
  double v28; 
  float outAnimWeights[2]; 
  unsigned __int64 v30; 
  cg_t *LocalClientGlobals; 
  __int64 outWeights; 

  v6 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v6 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, 2) )
    __debugbreak();
  viewModelDObj = LocalClientGlobals->m_weaponHand[v6].viewModelDObj;
  v30 = 5 * v6;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4599, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4600, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(viewModelDObj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4603, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4604, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
    __debugbreak();
  GoalWeight = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x75u);
  v10 = *(float *)&GoalWeight;
  v11 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x77u);
  v12 = *(float *)&v11;
  weaponState = ps->weapState[v6].weaponState;
  v15 = 0;
  if ( (unsigned int)weaponState <= 0x2F )
  {
    v14 = 0x800000001020i64;
    if ( _bittest64(&v14, weaponState) )
      v15 = 1;
  }
  IsSkydiving = BG_Skydive_IsSkydiving(ps);
  v17 = DCONST_DVARBOOL_xanim_finger_pose_disable;
  v18 = IsSkydiving;
  if ( !DCONST_DVARBOOL_xanim_finger_pose_disable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "xanim_finger_pose_disable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v17);
  if ( v17->current.enabled )
    goto LABEL_42;
  v19 = DCONST_DVARBOOL_cg_viewmodelFingerPoses;
  if ( !DCONST_DVARBOOL_cg_viewmodelFingerPoses && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelFingerPoses") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v19);
  if ( !v19->current.enabled || v15 || v18 )
  {
LABEL_42:
    if ( v10 > 0.0 )
    {
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x75u, 0.0, 0.1, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x76u, 0.0, 0.1, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    if ( *(float *)&v11 > 0.0 )
    {
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x77u, 0.0, 0.1, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x78u, 0.0, 0.1, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
  else
  {
    if ( Tree->children )
    {
      outWeights = 0i64;
      *(_QWORD *)outAnimWeights = 0i64;
      AnimInfo = GetAnimInfo(Tree->children);
      BG_CalcFingerPoseWeights(AnimInfo, (float *)&outWeights, outAnimWeights);
    }
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_FINGER_POSE_LEFT, (PlayerHandIndex)v6, Handler) )
    {
      v22 = I_fclamp(*(float *)&outWeights, 0.0, 1.0);
      v23 = *(float *)&v22;
      if ( v10 != *(float *)&v22 )
      {
        goalTime = LODWORD(FLOAT_0_1);
        if ( v10 == 0.0 && *(float *)&v22 >= 0.99900001 )
        {
          _XMM0 = (unsigned int)LocalClientGlobals->m_weaponHand[v30 / 5].animPlayingAtBeginFrame;
          __asm
          {
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm9, xmm9, xmm1, xmm2
          }
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x75u, v23, *(float *)&goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x76u, v23, *(float *)&goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    v27 = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_FINGER_POSE_RIGHT, (PlayerHandIndex)v6, v27) )
    {
      v28 = I_fclamp(*((float *)&outWeights + 1), 0.0, 1.0);
      if ( v12 != *(float *)&v28 )
      {
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x77u, *(float *)&v28, 0.1, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x78u, *(float *)&v28, 0.1, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
  }
}

/*
==============
PlayAdditiveHipIdleAnim
==============
*/
void PlayAdditiveHipIdleAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v4; 
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  bool v13; 
  const char *v14; 
  const dvar_t *v15; 
  unsigned __int64 weaponState; 
  __int64 v17; 
  const dvar_t *v18; 
  cg_t *v19; 
  bool v20; 
  double GoalWeight; 

  v4 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3962, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_HIP_IDLE, (PlayerHandIndex)v4, Handler) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v4);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3970, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3973, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3976, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3977, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    if ( !*(_QWORD *)&Tree->anims[5].lodDistances[2] )
    {
      v13 = BG_UsingAlternate(ps);
      v14 = "false";
      if ( v13 )
        v14 = "true";
      Com_PrintError(19, "PlayAdditiveADSAnim: missing anim parts for WEAP_ANIM_ADDITIVE_HIP_IDLE on hand: %d, isAlternate: %s\n", (unsigned int)v4, v14);
      DevPrintAnimTree(localClientNum, Tree, ps, (unsigned int)v4, weapon);
    }
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3857, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v15 = DCONST_DVARBOOL_cg_viewmodelActiveIdle;
    if ( !DCONST_DVARBOOL_cg_viewmodelActiveIdle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelActiveIdle") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v15);
    if ( !v15->current.enabled )
      goto LABEL_39;
    weaponState = ps->weapState[v4].weaponState;
    if ( (unsigned int)weaponState > 0x3B )
      goto LABEL_39;
    v17 = 0xC01000000000001i64;
    if ( !_bittest64(&v17, weaponState) )
      goto LABEL_39;
    v18 = DCONST_DVARBOOL_adsCover_enabled;
    if ( !DCONST_DVARBOOL_adsCover_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsCover_enabled") )
      __debugbreak();
    if ( (Dvar_CheckFrontendServerThread(v18), v18->current.enabled) && BG_ContextMount_CanMount(&ps->mountState) || (v19 = CG_GetLocalClientGlobals(localClientNum), BG_Gesture_IsPlaying(ps, v19->time, 0)) || CG_IsJogging(localClientNum) || BG_Demeanor_IsPlaying(ps) )
LABEL_39:
      v20 = 0;
    else
      v20 = ps->weapCommon.fWeaponPosFrac < 0.001;
    GoalWeight = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x1Cu);
    if ( v20 )
    {
      if ( *(float *)&GoalWeight != 1.0 )
      {
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1Cu, 1.0, 0.2, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1Du, 1.0, 0.2, 1.0, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      }
    }
    else if ( *(float *)&GoalWeight != 0.0 )
    {
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1Cu, 0.0, 0.2, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1Du, 0.0, 0.2, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
    }
  }
}

/*
==============
PlayAdditiveJogAnim
==============
*/
void PlayAdditiveJogAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v4; 
  const dvar_t *v7; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  double GoalWeight; 
  const dvar_t *v12; 
  const dvar_t *v13; 
  float goalTime; 
  double BobCycleAnimTime; 
  double Float_Internal_DebugName; 
  float v17; 
  unsigned int v18; 
  const dvar_t *v19; 
  const char *v20; 
  double v21; 

  v4 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5143, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v7 = DCONST_DVARMPBOOL_movementAnimProto;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v4);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5153, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    GoalWeight = XAnimGetGoalWeight(ViewModelHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x69u);
    if ( CG_IsJogging(localClientNum) )
    {
      v12 = DCONST_DVARBOOL_cg_viewmodelAdditiveJog;
      if ( !DCONST_DVARBOOL_cg_viewmodelAdditiveJog && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdditiveJog") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v12);
      if ( v12->current.enabled )
      {
        v13 = DCONST_DVARFLT_jogBlendTime;
        if ( !DCONST_DVARFLT_jogBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "jogBlendTime") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v13);
        goalTime = v13->current.value;
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x69u, 1.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x6Au, 1.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        BobCycleAnimTime = BG_GetBobCycleAnimTime((const int (*)[2])ps->packedBobCycle);
        XAnimSetTime(ViewModelHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Au, *(float *)&BobCycleAnimTime);
        return;
      }
    }
    if ( CG_IsJogging(localClientNum) || *(float *)&GoalWeight == 0.0 )
      return;
    Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_jogBlendTime, "jogBlendTime");
    v17 = *(float *)&Float_Internal_DebugName;
    v18 = ps->weapState[v4].weapAnim & 0xFFFFFF7F;
    if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u) || ps->weapCommon.fWeaponPosFrac > 0.001 )
    {
      v19 = DCONST_DVARFLT_jogAdsBlendTime;
      v20 = "jogAdsBlendTime";
    }
    else
    {
      if ( v18 != 3 )
      {
LABEL_28:
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x69u, 0.0, v17, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x6Au, 0.0, v17, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        return;
      }
      v19 = DCONST_DVARFLT_jogFireBlendTime;
      v20 = "jogFireBlendTime";
    }
    v21 = Dvar_GetFloat_Internal_DebugName(v19, v20);
    v17 = *(float *)&v21;
    goto LABEL_28;
  }
}

/*
==============
PlayAdditiveJumpAnim
==============
*/
void PlayAdditiveJumpAnim(const cg_t *cgameGlob, const playerState_s *ps, PlayerHandIndex hand, DObj *obj)
{
  CgHandler *Handler; 
  int landTime; 
  int time; 
  XAnimTree *Tree; 
  float v12; 
  float v13; 
  bool v14; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 
  bool v16; 
  bool v17; 
  double v18; 
  double v19; 
  double v20; 
  double Weight; 
  double v22; 
  double v23; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4066, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4067, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4068, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_JUMP, hand, Handler) )
  {
    landTime = cgameGlob->landTime;
    time = cgameGlob->time;
    Tree = DObjGetTree(obj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4096, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4097, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    v13 = (float)((float)(1.0 - ps->weapCommon.fWeaponPosFrac) * 0.80000001) + 0.2;
    v12 = v13;
    if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u) )
      v12 = v13 + 1.0;
    v14 = Jump_JumpedThisFrame(ps, ps->serverTime);
    p_pm_flags = &ps->pm_flags;
    v16 = v14;
    v17 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(p_pm_flags, ACTIVE, 5u);
    if ( !v16 )
    {
      if ( v17 )
      {
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, 0.0, 0.050000001, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, 0.0, 0.050000001, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x45u, 0.0, 0.050000001, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        return;
      }
      if ( landTime == time )
        goto LABEL_33;
      Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
      if ( *(float *)&Weight <= 0.0 )
      {
        v22 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x45u);
        if ( *(float *)&v22 <= 0.0 )
          return;
      }
      v23 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
      if ( *(float *)&v23 >= 1.0 )
      {
LABEL_33:
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      else
      {
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, v12, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, v12, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x45u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      return;
    }
    v18 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
    if ( *(float *)&v18 == 0.0 )
    {
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, v12, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, v12, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
    }
    v19 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x47u);
    if ( *(float *)&v19 > 0.0 )
    {
      v20 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x47u);
      if ( *(float *)&v20 < 1.0 )
      {
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x46u, 0.0, 0.25, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x47u, 0.0, 0.25, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
  }
}

/*
==============
PlayAdditiveJumpLandAnim
==============
*/
void PlayAdditiveJumpLandAnim(const cg_t *cgameGlob, const playerState_s *ps, PlayerHandIndex hand, DObj *obj)
{
  CgHandler *Handler; 
  XAnimTree *Tree; 
  float v10; 
  float distanceZ; 
  double v12; 
  float v13; 
  const dvar_t *v14; 
  float v15; 
  float value; 
  const dvar_t *v17; 
  double v18; 
  double Weight; 
  double Time; 
  double v21; 
  characterAnimData_s animDistances; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4215, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4216, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4217, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_JUMP_LAND, hand, Handler) )
  {
    Tree = DObjGetTree(obj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4223, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4224, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    if ( cgameGlob->landTime == cgameGlob->time )
    {
      v10 = cgameGlob->landChange * -0.041666668;
LABEL_28:
      v12 = I_fclamp(v10, 0.0, 1.0);
      v13 = *(float *)&v12 * 2.0;
      *(float *)&v12 = ps->weapCommon.fWeaponPosFrac;
      v14 = DCONST_DVARFLT_cg_viewmodelLandDipMin;
      v15 = (float)(v13 + 0.25) - (float)(*(float *)&v12 * 0.5);
      if ( !DCONST_DVARFLT_cg_viewmodelLandDipMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelLandDipMin") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v14);
      value = v14->current.value;
      v17 = DCONST_DVARFLT_cg_viewmodelLandDipMax;
      if ( !DCONST_DVARFLT_cg_viewmodelLandDipMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelLandDipMax") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v17);
      v18 = I_fclamp(v15, value, v17->current.value);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x46u, *(float *)&v18, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x47u, v15, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
      Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
      if ( *(float *)&Weight > 0.0 )
      {
        Time = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
        if ( *(float *)&Time < 1.0 )
        {
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, 0.0, 0.25, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, 0.0, 0.25, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      return;
    }
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4177, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( (cgameGlob->lastMantleflags & 0x40) == 0 && (ps->mantleState.flags & 0x40) != 0 )
    {
      Mantle_UnpackAnimData(&ps->mantleState.compressedAnimData, &animDistances);
      if ( (ps->mantleState.flags & 1) != 0 )
        distanceZ = animDistances.distanceZ;
      else
        distanceZ = animDistances.distanceZ * 0.125;
      v10 = (float)BG_GetViewDip(ps, distanceZ) * 0.041666668;
      goto LABEL_28;
    }
    v21 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x47u);
    if ( *(float *)&v21 == 1.0 )
    {
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x46u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x47u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
}

/*
==============
PlayAdditiveMagazineBulletAnims
==============
*/
void PlayAdditiveMagazineBulletAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int128 v4; 
  __int64 handIndex; 
  __int64 v7; 
  bool v9; 
  CgWeaponMap *v10; 
  int v11; 
  cg_t *LocalClientGlobals; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  cg_t *v15; 
  int v16; 
  CgHandler *pmoveHandler; 
  double NotetrackTime; 
  float v19; 
  const dvar_t *v20; 
  double v21; 
  float v22; 
  float v23; 
  double WeaponAnimTime; 
  int ClipSize; 
  signed int ammoInClipBeforeReload; 
  float v27; 
  double v29; 
  float v30; 
  int v31; 
  const ClipAmmo *ClipAmmoPtrConst; 
  float v33; 
  bool bIsAlternate; 
  signed int animFile; 
  int weaponDelay; 
  XAnimTree *tree; 
  DObj *obj; 
  AmmoStore result; 
  AmmoStore r_clipIndex; 
  __int128 v42; 

  handIndex = hand;
  v7 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4420, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  bIsAlternate = BG_UsingAlternate(ps);
  v9 = bIsAlternate;
  if ( !CgWeaponMap::ms_instance[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v10 = CgWeaponMap::ms_instance[v7];
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4425, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v11 = BG_PlayerDualWieldingWeapon(v10, ps, weapon);
  if ( BG_IsAnimInWeaponPackages(weapon, bIsAlternate, v11 == 1, ps->weapCommon.meleeComboSeqIdx, WEAP_ANIM_ADDITIVE_MAGAZINE_BULLETS) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4434, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)handIndex);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4436, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    obj = (DObj *)viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4438, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    tree = DObjGetTree(viewModelDObj);
    if ( !tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4440, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    v15 = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4409, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    v42 = v4;
    v16 = v15->predictedPlayerState.weapState[handIndex].weapAnim & 0xFFFFFF7F;
    if ( (unsigned int)(v16 - 16) > 5 )
      goto LABEL_42;
    pmoveHandler = CgHandler::getHandler((LocalClientNum_t)v7);
    animFile = BG_MapWeaponAnimStateToAnimIndex(v10, ps, v16, 0, weapon, bIsAlternate, (PlayerHandIndex)handIndex, pmoveHandler);
    NotetrackTime = XAnimGetNotetrackTime(tree->anims, animFile, scr_const.show_full_magazine);
    v19 = *(float *)&NotetrackTime;
    v20 = DVARBOOL_killswitch_show_full_magazine_suppress_ammo_add_enabled;
    weaponDelay = ps->weapState[handIndex].weaponDelay;
    if ( !DVARBOOL_killswitch_show_full_magazine_suppress_ammo_add_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_show_full_magazine_suppress_ammo_add_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v20);
    if ( *(float *)&NotetrackTime != -1.0 )
    {
      if ( v20->current.enabled )
      {
        WeaponAnimTime = CG_GetWeaponAnimTime((LocalClientNum_t)v7, (PlayerHandIndex)handIndex, (weapAnimFiles_t)animFile);
        v9 = bIsAlternate;
        ClipSize = BG_GetClipSize(ps, weapon, bIsAlternate);
        if ( v19 > *(float *)&WeaponAnimTime )
          ammoInClipBeforeReload = ps->weapState[handIndex].ammoInClipBeforeReload;
        else
          ammoInClipBeforeReload = BG_WeaponAmmo(v10, ps, weapon, bIsAlternate);
        v22 = (float)ammoInClipBeforeReload;
        v23 = (float)ClipSize;
        goto LABEL_39;
      }
      if ( weaponDelay > 0 )
      {
        v21 = CG_GetWeaponAnimTime((LocalClientNum_t)v7, (PlayerHandIndex)handIndex, (weapAnimFiles_t)animFile);
        v9 = bIsAlternate;
        if ( *(float *)&v21 <= v19 )
          goto LABEL_42;
        v22 = (float)BG_WeaponAmmo(v10, ps, weapon, bIsAlternate);
        v23 = (float)BG_GetClipSize(ps, weapon, bIsAlternate);
LABEL_39:
        v27 = 1.0 - (float)(v22 / v23);
        _XMM2 = LODWORD(FLOAT_1_0);
        v29 = I_fclamp(v27, 0.0, 1.0);
        v30 = v27;
        if ( *(float *)&v29 != -1.0 )
        {
LABEL_45:
          if ( v30 < 0.0 || v30 > 1.0 )
          {
            __asm { vxorpd  xmm2, xmm2, xmm2 }
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4504, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( magazineAnimTime ) && ( magazineAnimTime ) <= ( 1.0f )", "magazineAnimTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", v30, *(double *)&_XMM2, DOUBLE_1_0) )
              __debugbreak();
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA8u, 1.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA9u, 1.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetTime(tree, 0, XANIM_SUBTREE_DEFAULT, 0xA9u, v30);
          return;
        }
LABEL_42:
        v31 = BG_GetClipSize(ps, weapon, v9);
        r_clipIndex = *BG_AmmoStoreForWeapon(&result, weapon, v9);
        ClipAmmoPtrConst = BG_GetClipAmmoPtrConst(ps, &r_clipIndex);
        if ( ClipAmmoPtrConst )
          LODWORD(ClipAmmoPtrConst) = ClipAmmoPtrConst->ammoCount[handIndex];
        v33 = 1.0 - (float)((float)(int)ClipAmmoPtrConst / (float)v31);
        _XMM2 = LODWORD(FLOAT_1_0);
        I_fclamp(v33, 0.0, 1.0);
        v30 = v33;
        goto LABEL_45;
      }
    }
    v9 = bIsAlternate;
    goto LABEL_42;
  }
}

/*
==============
PlayAdditiveProneDropAnim
==============
*/
void PlayAdditiveProneDropAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v7; 
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  const SuitDef *SuitDef; 
  CgWeaponMap *Instance; 
  int ViewHeightLerpTime; 
  int v16; 
  double Time; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4300, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v7 = DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedCrawl") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( v7->current.enabled )
  {
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_PRONE_DROP, hand, Handler) )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
      ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
      if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4312, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
        __debugbreak();
      viewModelDObj = ViewModelHand->viewModelDObj;
      if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4315, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
        __debugbreak();
      Tree = DObjGetTree(viewModelDObj);
      SuitDef = BG_GetSuitDef(ps->suitIndex);
      if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4319, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
        __debugbreak();
      Instance = CgWeaponMap::GetInstance(localClientNum);
      if ( ps->viewHeightLerpTarget != BG_Suit_GetProneViewHeight(SuitDef) || BG_UsingSniperScope(Instance, ps) || ps->viewHeightLerpTime <= 0 || (ViewHeightLerpTime = PM_GetViewHeightLerpTime(ps, ps->viewHeightLerpTarget, 1), v16 = ps->viewHeightLerpTime, 100 * (ps->serverTime - LocalClientGlobals->frametime - v16) / ViewHeightLerpTime >= 45) || 100 * (ps->serverTime - v16) / ViewHeightLerpTime < 45 )
      {
        Time = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x74u);
        if ( *(float *)&Time == 1.0 )
        {
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x73u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x74u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
        }
      }
      else
      {
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x73u, 1.0, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x74u, 1.0, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
      }
    }
  }
}

/*
==============
PlayAdditiveSwimDragAnims
==============
*/
void PlayAdditiveSwimDragAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v8; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  weapAnimFiles_t *v12; 
  CgHandler *Handler; 
  float dragWeights[2]; 
  __int64 v15; 
  vec3_t right[3]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3556, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v8 = DCONST_DVARBOOL_player_swimDragHandEnabled;
  if ( !DCONST_DVARBOOL_player_swimDragHandEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3563, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3566, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( LocalClientGlobals->frametime )
    {
      if ( BG_UsingAlternate(ps) && BG_IsSwimWeapon(weapon) )
      {
        if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3577, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING )") )
          __debugbreak();
        if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3267, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        v12 = (weapAnimFiles_t *)s_dragAnims;
        while ( 1 )
        {
          Handler = CgHandler::getHandler(localClientNum);
          if ( BG_ViewModelAnimExists(ps, *v12, hand, Handler) )
            break;
          if ( (__int64)++v12 >= (__int64)&unk_1442D8DA8 )
            return;
        }
        AngleVectors(&ps->viewangles, &right[2], right, &right[1]);
        if ( LocalClientGlobals->lastDragPosition.v[0] == 0.0 && LocalClientGlobals->lastDragPosition.v[1] == 0.0 && LocalClientGlobals->lastDragPosition.v[2] == 0.0 )
        {
          CalcSwimDragLookAtPosition(ps, (const vec3_t (*)[3])right, &LocalClientGlobals->lastDragPosition);
          *(_QWORD *)dragWeights = 0i64;
          v15 = 0i64;
          SetSwimDragGoalWeights(localClientNum, viewModelDObj, ps, hand, weapon, dragWeights);
        }
        else
        {
          CalcSwimDragFriction(viewModelDObj, localClientNum, ps, (const vec3_t (*)[3])right);
          ClampDragPositionToLookAtPlane(localClientNum, ps, (const vec3_t (*)[3])right);
          CalcSwimDragWeights(viewModelDObj, localClientNum, ps, (const vec3_t (*)[3])right, dragWeights);
          SetSwimDragGoalWeights(localClientNum, viewModelDObj, ps, hand, weapon, dragWeights);
        }
      }
      else
      {
        *(_QWORD *)LocalClientGlobals->lastDragPosition.v = 0i64;
        LocalClientGlobals->lastDragPosition.v[2] = 0.0;
      }
    }
  }
}

/*
==============
PlayAdditiveWalkAnim
==============
*/
void PlayAdditiveWalkAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v4; 
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  XAnimTree *Tree; 
  unsigned int v11; 
  weapAnimFiles_t v12; 
  float goalTime; 
  double Weight; 
  CgHandler *Handler; 
  const dvar_t *v16; 
  const dvar_t *v17; 
  CgWeaponMap *Instance; 
  double v19; 
  __int128 v22; 
  __int128 v25; 
  float v31; 
  bool v32; 
  float v33; 
  bool v34; 
  CgHandler *v35; 
  float v36; 
  double v37; 
  weapAnimFiles_t v38; 
  double BobCycleAnimTime; 
  float *v40; 
  unsigned int i; 
  weapAnimFiles_t v42; 
  weapAnimFiles_t outWalkAnimGroup; 
  float outBlendWeights[6]; 
  bool outAnimMissing; 

  v4 = DCONST_DVARMPBOOL_movementAnimProto;
  v6 = localClientNum;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( !v4->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5031, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    Tree = DObjGetTree(ViewModelHand->viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5034, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5035, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    v11 = 73;
    v12 = WEAP_ANIM_ADDITIVE_WALK_START;
    if ( BG_CanSprintFire(ps) && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u) )
      v12 = WEAP_ANIM_ADDITIVE_GUNGHO_SPRINT;
    if ( Com_GameMode_SupportsFeature(WEAPON_SPRINT_DROP|0x80) && BG_Gesture_GetWalkAnimOverride(ps, &outWalkAnimGroup, NULL) )
      v12 = outWalkAnimGroup;
    LocalClientGlobals->prevWalkGroup = v12;
    goalTime = 0.0;
    do
    {
      if ( v11 - (v11 - 73) % 5 != v12 )
      {
        Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v11);
        if ( *(float *)&Weight > 0.0 )
        {
          goalTime = FLOAT_0_15000001;
          XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v11, 0.0, 0.15000001, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      ++v11;
    }
    while ( v11 < 0x5D );
    Handler = CgHandler::getHandler((LocalClientNum_t)v6);
    if ( !CgWeaponMap::ms_instance[v6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    if ( !BG_ShouldPlayAdditiveWalkAnim(CgWeaponMap::ms_instance[v6], ps, Handler) )
      goto LABEL_53;
    v16 = DCONST_DVARBOOL_cg_viewmodelAdditiveWalk;
    if ( !DCONST_DVARBOOL_cg_viewmodelAdditiveWalk && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdditiveWalk") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
    if ( v16->current.enabled )
    {
      v17 = DCONST_DVARBOOL_adsReloadUseAdditiveWalk;
      if ( !DCONST_DVARBOOL_adsReloadUseAdditiveWalk && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsReloadUseAdditiveWalk") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v17);
      if ( v17->current.enabled )
      {
        Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v6);
        v19 = BG_WeaponADSFractionAffectedByReload(Instance, ps);
      }
      else
      {
        *(float *)&v19 = ps->weapCommon.fWeaponPosFrac;
      }
      if ( ADDITIVE_WALK_STOP_ADS_FRACTION > 0.001 )
      {
        v22 = LODWORD(ADDITIVE_WALK_STOP_ADS_FRACTION);
        *(float *)&v22 = ADDITIVE_WALK_STOP_ADS_FRACTION - *(float *)&v19;
        _XMM0 = v22;
        __asm { vminss  xmm1, xmm0, xmm2 }
        v25 = _XMM1;
        *(float *)&v25 = *(float *)&_XMM1 / ADDITIVE_WALK_STOP_ADS_FRACTION;
        _XMM2 = v25;
        __asm
        {
          vmaxss  xmm0, xmm2, xmm6
          vminss  xmm9, xmm0, xmm7
        }
      }
      else
      {
        LODWORD(_XMM9) = 0;
      }
      _XMM0 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 1u);
      __asm { vpcmpeqd xmm2, xmm0, xmm1 }
      _XMM1 = LODWORD(FLOAT_0_5);
      __asm { vblendvps xmm0, xmm1, xmm7, xmm2 }
      v31 = *(float *)&_XMM0 * *(float *)&_XMM9;
      *(double *)&_XMM0 = BG_CalcViewspeedBobRatio(ps->viewangles.v[1], LocalClientGlobals->weaponAdditiveWalkPrevYaw, ps, LocalClientGlobals->frametime);
      v32 = *(float *)&_XMM0 < ADDITIVE_WALK_MINIMUM_TURN_RATIO;
      v33 = (float)LocalClientGlobals->frametime * 0.001;
      LocalClientGlobals->weaponAdditiveWalkPrevYaw = ps->viewangles.v[1];
      v34 = !v32;
      v35 = CgHandler::getHandler((LocalClientNum_t)v6);
      if ( !BG_PlayerIsLinkedOrNotMoving(ps, LocalClientGlobals->time, v35) || v34 )
        v36 = (float)(v33 / ADDITIVE_WALK_BLEND_IN_TIME) + LocalClientGlobals->weaponAdditiveWalkBlendRate;
      else
        v36 = LocalClientGlobals->weaponAdditiveWalkBlendRate - (float)(v33 / ADDITIVE_WALK_BLEND_OUT_TIME);
      LocalClientGlobals->weaponAdditiveWalkBlendRate = v36;
      v37 = I_fclamp(v36, 0.0, 1.0);
      LocalClientGlobals->weaponAdditiveWalkBlendRate = *(float *)&v37;
      if ( *(float *)&v37 == 0.0 )
      {
        XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        v38 = v12 + 5;
        if ( !__OFSUB__(v12, v12 + 5) )
        {
          do
            XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v12++, 0.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          while ( v12 < v38 );
        }
      }
      else
      {
        BobCycleAnimTime = BG_GetBobCycleAnimTime((const int (*)[2])ps->packedBobCycle);
        CG_CalcSlopeAnimBlendWeights(LocalClientGlobals, v12, outBlendWeights, &outAnimMissing);
        XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, v31 * LocalClientGlobals->weaponAdditiveWalkBlendRate, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        v40 = outBlendWeights;
        for ( i = 0; i < 5; ++i )
        {
          XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, i + v12, *(float *)&_XMM9 * *v40, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, i + v12, *(float *)&BobCycleAnimTime);
          ++v40;
        }
      }
    }
    else
    {
LABEL_53:
      XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, 0.0, 0.050000001, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      v42 = v12 + 5;
      if ( !__OFSUB__(v12, v12 + 5) )
      {
        do
          XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v12++, 0.0, 0.050000001, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        while ( v12 < v42 );
      }
      LocalClientGlobals->weaponAdditiveWalkBlendRate = 0.0;
    }
  }
}

/*
==============
PlayAdvancedSwayAnim
==============
*/
void PlayAdvancedSwayAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  double GoalWeight; 
  __int64 goalTime; 
  __int64 rate; 
  vec2_t outBsParams; 

  v4 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4541, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(goalTime) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4542, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(rate) = 2;
    LODWORD(goalTime) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, rate) )
      __debugbreak();
  }
  viewModelDObj = LocalClientGlobals->m_weaponHand[v4].viewModelDObj;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4548, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  AdvancedSwayState::GetBlendspaceParams(&LocalClientGlobals->vmMotionState, &outBsParams);
  XAnimSetFloatGameParameterByIndex(viewModelDObj, 8u, outBsParams.v[0]);
  XAnimSetFloatGameParameterByIndex(viewModelDObj, 9u, outBsParams.v[1]);
  Tree = DObjGetTree(viewModelDObj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4558, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  GoalWeight = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x18Du);
  if ( *(float *)&GoalWeight > 0.0 && XAnimIsCustomNodeByName(Tree->anims, 0x18Du, scr_const.xanimBlendSpace2D) && *(float *)&GoalWeight != 1.0 )
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x18Du, 1.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
PlayMappedSoundAlias
==============
*/
char PlayMappedSoundAlias(LocalClientNum_t localClientNum, unsigned int numMappings, const scr_string_t *keys, const scr_string_t *values, const scr_string_t *searchedNoteName)
{
  unsigned int v9; 
  signed __int64 v10; 
  int v11; 
  const char *v12; 
  CgSoundSystem *SoundSystem; 

  if ( !keys && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12503, ASSERT_TYPE_ASSERT, "(keys)", (const char *)&queryFormat, "keys") )
    __debugbreak();
  if ( !values && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12504, ASSERT_TYPE_ASSERT, "(values)", (const char *)&queryFormat, "values") )
    __debugbreak();
  v9 = 0;
  if ( numMappings )
  {
    v10 = (char *)keys - (char *)values;
    do
    {
      v11 = *(const scr_string_t *)((char *)values + v10);
      if ( !v11 )
        break;
      if ( *values )
      {
        if ( v11 == *searchedNoteName )
        {
          v12 = SL_ConvertToString((scr_string_t)*values);
          if ( v12 )
          {
            SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
            CgSoundSystem::PlayClientSoundAliasByName2(SoundSystem, v12);
            return 1;
          }
        }
      }
      ++v9;
      ++values;
    }
    while ( v9 < numMappings );
  }
  return 0;
}

/*
==============
PlayProtoMovementAnim
==============
*/
void PlayProtoMovementAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v4; 
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  XAnimTree *Tree; 
  MovementAnimState::State v12; 
  float updated; 
  MovementAnimState *v14; 
  bool IsSuperSprinting; 
  bool v16; 
  bool IsJogging; 
  double BobCycleAnimTime; 
  unsigned int i; 

  v4 = DCONST_DVARMPBOOL_movementAnimProto;
  v6 = hand;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v6);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5844, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    Tree = DObjGetTree(ViewModelHand->viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5847, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5848, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    v12 = NONE;
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x69u, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    updated = UpdateMovementAnimWeightRoot(localClientNum, ps, (PlayerHandIndex)v6, weapon);
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Du, updated, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x3Eu, updated, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    v14 = &LocalClientGlobals->animMoveState[v6];
    if ( updated > 0.0 )
    {
      if ( !LocalClientGlobals->animMoveState[v6].m_isInitialized )
        MovementAnimState::Reset(&LocalClientGlobals->animMoveState[v6], localClientNum, (const PlayerHandIndex)v6);
      if ( v14->m_goal == -1 )
        MovementAnimState::UpdateInternal(&LocalClientGlobals->animMoveState[v6], localClientNum, (const PlayerHandIndex)v6, ps, NONE);
      if ( !MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
      {
        IsSuperSprinting = BG_IsSuperSprinting(ps);
        v16 = !IsSuperSprinting && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u);
        IsJogging = CG_IsJogging(localClientNum);
        if ( IsSuperSprinting )
        {
          v12 = LONG;
        }
        else if ( v16 )
        {
          v12 = HALF_HALF;
        }
        else
        {
          LOBYTE(v12) = IsJogging;
        }
      }
      MovementAnimState::UpdateInternal(v14, localClientNum, (const PlayerHandIndex)v6, ps, v12);
    }
    else
    {
      MovementAnimState::Reset(&LocalClientGlobals->animMoveState[v6], localClientNum, (const PlayerHandIndex)v6);
    }
    BobCycleAnimTime = BG_GetBobCycleAnimTime((const int (*)[2])ps->packedBobCycle);
    for ( i = 63; i <= 0x42; ++i )
      XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, i, *(float *)&BobCycleAnimTime);
  }
}

/*
==============
CgWeaponSystem::PlayPullbackSound
==============
*/
void CgWeaponSystem::PlayPullbackSound(CgWeaponSystem *this, const int entNum, const bool isPlayerView, const Weapon *r_weapon, const bool isAlternate)
{
  __int64 v5; 
  unsigned int id; 
  cg_t *LocalClientGlobals; 
  unsigned int lastPullbackId; 
  CgSoundSystem *SoundSystem; 
  const SndAliasList *WeaponSoundWithFallback; 
  const SndAliasList *v14; 
  cg_t *v15; 
  __int64 v16; 
  __int64 v17; 

  v5 = entNum;
  id = 0;
  if ( entNum < cls.maxClients )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25077, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( (unsigned __int64)cls.maxClients > 0xC8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25079, ASSERT_TYPE_ASSERT, "( ( sizeof( *array_counter( cgameGlob->soundPlaybackCache.clients ) ) + 0 ) ) >= ( cls.maxClients )", "%s >= %s\n\t%i, %i", "ARRAY_COUNT( cgameGlob->soundPlaybackCache.clients )", "cls.maxClients", 200, cls.maxClients) )
      __debugbreak();
    lastPullbackId = LocalClientGlobals->soundPlaybackCache.clients[v5].lastPullbackId;
    if ( lastPullbackId )
      SND_StopSoundAliasAndSecondariesByAliasId(lastPullbackId, this->m_localClientNum, v5);
    LocalClientGlobals->soundPlaybackCache.clients[v5].lastPullbackId = 0;
  }
  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25098, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  WeaponSoundWithFallback = BG_GetWeaponSoundWithFallback(r_weapon, isAlternate, 8i64 * isPlayerView + 48);
  v14 = WeaponSoundWithFallback;
  if ( WeaponSoundWithFallback && CgSoundSystem::PlayEntitySoundAlias(SoundSystem, v5, WeaponSoundWithFallback) )
    id = v14->id;
  if ( (int)v5 < cls.maxClients )
  {
    v15 = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25114, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( (unsigned __int64)cls.maxClients > 0xC8 )
    {
      LODWORD(v17) = cls.maxClients;
      LODWORD(v16) = 200;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25116, ASSERT_TYPE_ASSERT, "( ( sizeof( *array_counter( cgameGlob->soundPlaybackCache.clients ) ) + 0 ) ) >= ( cls.maxClients )", "%s >= %s\n\t%i, %i", "ARRAY_COUNT( cgameGlob->soundPlaybackCache.clients )", "cls.maxClients", v16, v17) )
        __debugbreak();
    }
    v15->soundPlaybackCache.clients[v5].lastPullbackId = id;
  }
}

/*
==============
PlayRecoilAnim
==============
*/
void PlayRecoilAnim(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, PlayerHandIndex hand, weapAnimFiles_t animIndex)
{
  __int64 v5; 
  cg_t *LocalClientGlobals; 
  const DObj *viewModelDObj; 
  __int64 v10; 
  cg_t *v11; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 
  unsigned int v13; 
  char v14; 
  unsigned int v15; 
  double Weight; 
  bool v17; 
  bool IsDualWield; 
  const WeaponCompleteDef *v19; 
  int weaponShotCount; 
  CgWeaponMap *Instance; 
  int v22; 
  float v23; 
  const char *AnimDebugName; 
  XAnimTree *Tree; 
  double v26; 
  int fireTime; 
  int fireDelay; 
  __int64 v29; 
  unsigned int v31; 
  char v33; 

  v5 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v5 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v5, 2) )
    __debugbreak();
  v29 = v5;
  viewModelDObj = LocalClientGlobals->m_weaponHand[v5].viewModelDObj;
  v10 = v5;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6977, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !CG_HasRecoilAnim(localClientNum, ps, (PlayerHandIndex)v5) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6978, ASSERT_TYPE_ASSERT, "(CG_HasRecoilAnim( localClientNum, ps, hand ))", (const char *)&queryFormat, "CG_HasRecoilAnim( localClientNum, ps, hand )") )
    __debugbreak();
  if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x10u) && !BG_IsPlayerFireDisabledForHand(ps, (const PlayerHandIndex)v5) )
  {
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5970, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v11 = CG_GetLocalClientGlobals(localClientNum);
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5976, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( &v11->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5977, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
      __debugbreak();
    p_m_weaponAnimArrays = &v11->m_weaponAnimArrays;
    if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5980, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
      __debugbreak();
    if ( BG_UsingAlternate(ps) )
      p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
    v13 = 412;
    v33 = 0;
    v14 = 0;
    v31 = 412;
    v15 = 412;
    if ( p_m_weaponAnimArrays->normalAnimArray[176] )
    {
      v13 = 176;
      v33 = 1;
      v31 = 176;
      v14 = 1;
      v15 = 175;
    }
    if ( animIndex == WEAP_ANIM_RECOIL )
    {
      if ( LocalClientGlobals->weaponRecoilTime[v10] > 0 )
      {
        v17 = BG_UsingAlternate(ps);
        IsDualWield = BG_WeaponIsDualWield(weapon);
        v19 = BG_WeaponCompleteDef(weapon, v17);
        weaponShotCount = ps->weapState[v29].weaponShotCount;
        Instance = CgWeaponMap::GetInstance(localClientNum);
        BG_GetFireTime(Instance, ps, weapon, v17, IsDualWield, weaponShotCount, &fireTime, &fireDelay);
        v22 = fireDelay + fireTime * v19->iClipSize;
        if ( v22 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7011, ASSERT_TYPE_ASSERT, "(totalTime > 0)", (const char *)&queryFormat, "totalTime > 0") )
          __debugbreak();
        v23 = (float)(LocalClientGlobals->time - LocalClientGlobals->weaponRecoilTime[v29]) / (float)v22;
        I_fclamp(v23, 0.0, 1.0);
        if ( XAnimIsLooped(viewModelDObj->tree->anims, v31) )
        {
          AnimDebugName = XAnimGetAnimDebugName(viewModelDObj->tree->anims, v31);
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7015, ASSERT_TYPE_ASSERT, "(!XAnimIsLooped( obj->tree->anims, recoilAnim ))", "%s\n\tRecoil anims cannot be looping. Animation '%s'.", "!XAnimIsLooped( obj->tree->anims, recoilAnim )", AnimDebugName) )
            __debugbreak();
        }
        if ( v23 > 0.0 )
        {
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v15, 1.0, 0.15000001, 0.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
          if ( v33 )
            XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v31, 1.0, 0.0, 0.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
          Tree = DObjGetTree(viewModelDObj);
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, v31, v23);
        }
      }
      else
      {
        Weight = XAnimGetWeight(LocalClientGlobals->m_weaponHand[v10].tree, 0, XANIM_SUBTREE_DEFAULT, v15);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v15, 0.0, *(float *)&Weight * 0.15000001, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    else if ( animIndex == WEAP_ANIM_RECOIL_SETTLE )
    {
      v26 = XAnimGetWeight(LocalClientGlobals->m_weaponHand[v10].tree, 0, XANIM_SUBTREE_DEFAULT, v15);
      if ( *(float *)&v26 > 0.001 )
        LocalClientGlobals->weaponRecoilTime[v10] = -1;
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v15, 0.0, *(float *)&v26 * 0.15000001, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      if ( v14 && *(float *)&v26 == 0.0 )
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v13, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimGetWeight(LocalClientGlobals->m_weaponHand[v10].tree, 0, XANIM_SUBTREE_DEFAULT, v15);
      if ( LocalClientGlobals->weaponRecoilTime[v10] == -1 )
      {
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x175u, 1.0, 0.02, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xEFu, 0.0, 0.02, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xF1u, 0.0, 0.02, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        LocalClientGlobals->weaponRecoilTime[v10] = 0;
      }
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7061, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "PlayRecoilAnim passed unsupported weapon anim index.") )
    {
      __debugbreak();
    }
  }
}

/*
==============
PlaySwimForwardAnims
==============
*/
void PlaySwimForwardAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v4; 
  float value; 
  const dvar_t *v10; 
  float v11; 
  const dvar_t *v12; 
  float v13; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  float v19; 
  __int128 v21; 
  CgHandler *Handler; 
  CgHandler *v23; 
  float v24; 
  __int128 v25; 
  CgHandler *v37; 
  double Weight; 
  double v39; 
  vec3_t forward; 
  AdditiveEaseInfo easeInfoArray; 
  int v42; 
  float v43; 
  float v44; 
  int v45; 
  float v46; 
  float v47; 
  int v48; 
  float v49; 
  float v50; 
  int v51; 
  float v52; 
  float v53; 
  int v54; 
  float v55; 
  float v56; 
  int v57; 
  float v58; 
  float v59; 
  int v60; 
  float v61; 
  float v62; 
  int v63; 
  float v64; 
  float v65; 
  int v66; 
  float v67; 
  float v68; 
  int v69; 
  float v70; 
  float v71; 
  int v72; 
  float v73; 
  float v74; 
  int v75; 
  float v76; 
  float v77; 
  int v78; 
  float v79; 
  float v80; 
  int v81; 
  float v82; 
  float v83; 
  int v84; 
  float v85; 
  float v86; 
  int v87; 
  float v88; 
  float v89; 
  int v90; 
  float v91; 
  float v92; 

  v4 = DCONST_DVARMPFLT_player_swimSpeed;
  if ( !DCONST_DVARMPFLT_player_swimSpeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimSpeed") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  value = v4->current.value;
  v10 = DCONST_DVARFLT_player_swimForwardAnimCatchupMin;
  if ( !DCONST_DVARFLT_player_swimForwardAnimCatchupMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimForwardAnimCatchupMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  v11 = v10->current.value;
  v12 = DCONST_DVARFLT_player_swimForwardAnimCatchupMax;
  if ( !DCONST_DVARFLT_player_swimForwardAnimCatchupMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimForwardAnimCatchupMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  v13 = v12->current.value;
  easeInfoArray.easeOutTime = FLOAT_0_34999999;
  v47 = FLOAT_0_34999999;
  v49 = FLOAT_0_34999999;
  v50 = FLOAT_0_80000001;
  v52 = FLOAT_0_34999999;
  v53 = FLOAT_0_80000001;
  v55 = FLOAT_0_34999999;
  v56 = FLOAT_0_80000001;
  v58 = FLOAT_0_34999999;
  v59 = FLOAT_0_80000001;
  v61 = FLOAT_0_34999999;
  v62 = FLOAT_0_80000001;
  v64 = FLOAT_0_34999999;
  v65 = FLOAT_0_80000001;
  v67 = FLOAT_0_34999999;
  v68 = FLOAT_0_80000001;
  v70 = FLOAT_0_34999999;
  v71 = FLOAT_0_80000001;
  v73 = FLOAT_0_34999999;
  v74 = FLOAT_0_80000001;
  v76 = FLOAT_0_34999999;
  v77 = FLOAT_0_80000001;
  v79 = FLOAT_0_34999999;
  v80 = FLOAT_0_80000001;
  v82 = FLOAT_0_34999999;
  v83 = FLOAT_0_80000001;
  _XMM10 = 0i64;
  easeInfoArray.animIndex = WEAP_ANIM_SPRINT_IN;
  v85 = FLOAT_0_2;
  v86 = FLOAT_0_44999999;
  v88 = FLOAT_0_2;
  v89 = FLOAT_0_44999999;
  v91 = FLOAT_0_2;
  v92 = FLOAT_0_44999999;
  easeInfoArray.easeInTime = FLOAT_1_0;
  v43 = 0.0;
  v44 = FLOAT_1_0;
  v46 = 0.0;
  v42 = 339;
  v45 = 338;
  v48 = 286;
  v51 = 287;
  v54 = 288;
  v57 = 289;
  v60 = 290;
  v63 = 291;
  v66 = 304;
  v69 = 305;
  v72 = 306;
  v75 = 307;
  v78 = 308;
  v81 = 309;
  v84 = 329;
  v87 = 330;
  v90 = 331;
  if ( BG_IsSwimWeapon(weapon) )
  {
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3648, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3649, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING )") )
      __debugbreak();
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3653, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3655, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3658, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    AngleVectors(&ps->viewangles, &forward, NULL, NULL);
    v21 = LODWORD(forward.v[1]);
    v19 = (float)((float)(forward.v[1] * ps->velocity.v[1]) + (float)(forward.v[0] * ps->velocity.v[0])) + (float)(forward.v[2] * ps->velocity.v[2]);
    *(float *)&v21 = v19 - LocalClientGlobals->lastForwardSpeed;
    _XMM6 = v21;
    LocalClientGlobals->lastForwardSpeed = v19;
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SWIM_FORWARD, hand, Handler) )
    {
      v23 = CgHandler::getHandler(localClientNum);
      if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SWIM_BACKWARD, hand, v23) )
      {
        if ( value <= 0.0 )
        {
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x29u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Au, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Bu, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Cu, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        else
        {
          LODWORD(v24) = v21 & _xmm;
          if ( COERCE_FLOAT(v21 & _xmm) > 0.001 )
          {
            v25 = LODWORD(FLOAT_1_0);
            *(float *)&v25 = (float)((float)((float)((float)(1.0 - COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)&_XMM6 / value) & _xmm)) * v11) + (float)(v13 * COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)&_XMM6 / value) & _xmm))) * _mm_cvtepi32_ps((__m128i)(unsigned int)LocalClientGlobals->frametime).m128_f32[0]) * 0.001;
            _XMM4 = v25;
            __asm
            {
              vcmpltss xmm0, xmm6, xmm10
              vblendvps xmm2, xmm4, xmm1, xmm0
            }
            if ( v24 > COERCE_FLOAT(_XMM2 & _xmm) )
              LocalClientGlobals->lastForwardSpeed = v19 - (float)(*(float *)&_XMM6 - *(float *)&_XMM2);
          }
          *((_QWORD *)&_XMM0 + 1) = 0i64;
          *(double *)&_XMM0 = I_fclamp(LocalClientGlobals->lastForwardSpeed / value, -1.0, 1.0);
          __asm { vmaxss  xmm7, xmm0, xmm10 }
          *(float *)&_XMM0 = GetAdditiveAnimMax(Tree, ps, &easeInfoArray, 18);
          __asm
          {
            vminss  xmm8, xmm0, xmm7
            vminss  xmm9, xmm0, xmm6
            vcmpneqss xmm0, xmm8, xmm10
            vblendvps xmm6, xmm10, xmm11, xmm0
            vcmpneqss xmm0, xmm9, xmm10
            vblendvps xmm7, xmm10, xmm11, xmm0
          }
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x29u, *(float *)&_XMM6, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Au, *(float *)&_XMM6, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Bu, *(float *)&_XMM7, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Cu, *(float *)&_XMM7, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x2Au, *(float *)&_XMM8);
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x2Cu, *(float *)&_XMM9);
        }
      }
    }
    v37 = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_SWIM_LOOP, hand, v37) )
    {
      if ( value <= 0.0 )
      {
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x176u, 0.0, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      else
      {
        Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x176u);
        if ( *(float *)&Weight > 0.0 )
        {
          if ( ps->weapCommon.fWeaponPosFrac == 0.0 && ps->weapCommon.fAdditivePosFrac == 0.0 )
          {
            v39 = I_fclamp(v19 / value, 0.0, 1.0);
            XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x176u, (float)(*(float *)&v39 + 1.0) * 0.5);
          }
          else
          {
            XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x176u, 0.0);
            XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x176u, 0.0);
          }
        }
      }
    }
  }
}

/*
==============
MovementAnimState::PlayerActionForcesWalk
==============
*/
bool MovementAnimState::PlayerActionForcesWalk(const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  __int64 v2; 
  const BgWeaponMap **v4; 
  const BgWeaponMap *v5; 
  CgHandler *Handler; 
  PlayerHandIndex v7; 
  int WeaponHand; 
  __int64 v9; 
  __int64 v10; 
  int *p_weaponState; 
  __int64 v12; 
  unsigned __int64 v13; 
  __int64 v14; 

  v2 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5560, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5561, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v5 = *v4;
  Handler = CgHandler::getHandler((LocalClientNum_t)v2);
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v7 = WEAPON_HAND_DEFAULT;
  WeaponHand = BG_PlayerLastWeaponHand(*v4, ps);
  v9 = WeaponHand;
  if ( WeaponHand >= 0 )
  {
    v10 = 0i64;
    p_weaponState = &ps->weapState[0].weaponState;
    v12 = 0x40F0000001F80i64;
    do
    {
      v13 = *p_weaponState;
      if ( (unsigned int)v13 <= 0x32 )
      {
        if ( _bittest64(&v12, v13) )
          return 1;
      }
      if ( !PM_Weapon_IsInInterruptibleState(v5, ps, v7, Handler) && (unsigned int)v13 <= 0x20 )
      {
        v14 = 0x1FDC0003Ei64;
        if ( _bittest64(&v14, v13) )
          return 1;
      }
      ++v7;
      ++v10;
      p_weaponState += 20;
      v12 = 0x40F0000001F80i64;
    }
    while ( v10 <= v9 );
  }
  return BG_Offhand_HasActiveOffhand(ps);
}

/*
==============
CgWeaponSystem::ProcessDeferredTracer
==============
*/
void CgWeaponSystem::ProcessDeferredTracer(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  int v3; 
  scr_string_t *p_sourcePrimaryTagName; 
  __int64 localClientNum; 
  CgWeaponMap *v6; 
  __int64 v7; 
  const DObj *viewModelDObj; 
  unsigned int clientNum; 
  LocalClientNum_t m_localClientNum; 
  unsigned int v11; 
  unsigned int v12; 
  int entnum; 
  cg_t_vtbl *v14; 
  const characterInfo_t *CharacterInfo; 
  bool TagNameAndBoneIndexForCharacter; 
  const char *v17; 
  const cpose_t *Pose; 
  const char *v19; 
  scr_string_t *outTagName; 
  unsigned __int8 *outBoneIndex; 
  unsigned __int8 v22[4]; 
  scr_string_t stringValue; 
  TagPair v24; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outTagMat; 
  CharacterModelType modelTypesToSearch[4]; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( LocalClientGlobals->delayedSpawnTracerEventsCount > 0x10u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16630, ASSERT_TYPE_ASSERT, "( 0 ) <= ( cgameGlob->delayedSpawnTracerEventsCount ) && ( cgameGlob->delayedSpawnTracerEventsCount ) <= ( 16 )", "cgameGlob->delayedSpawnTracerEventsCount not in [0, MAX_DELAYED_SPAWN_TRACER_EVENTS]\n\t%i not in [%i, %i]", LocalClientGlobals->delayedSpawnTracerEventsCount, 0i64, 16) )
    __debugbreak();
  v3 = 0;
  if ( LocalClientGlobals->delayedSpawnTracerEventsCount > 0 )
  {
    p_sourcePrimaryTagName = &LocalClientGlobals->delayedSpawnTracerEvents[0].sourcePrimaryTagName;
    do
    {
      TagPair::TagPair(&v24, *p_sourcePrimaryTagName, p_sourcePrimaryTagName[1]);
      localClientNum = LocalClientGlobals->localClientNum;
      if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
        __debugbreak();
      v6 = CgWeaponMap::ms_instance[localClientNum];
      if ( LocalClientGlobals->renderingThirdPerson || BG_IsThirdPersonMode(CgWeaponMap::ms_instance[localClientNum], &LocalClientGlobals->predictedPlayerState) )
      {
        clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
        m_localClientNum = this->m_localClientNum;
        if ( clientNum > 0x9E4 )
        {
          LODWORD(outBoneIndex) = LocalClientGlobals->predictedPlayerState.clientNum;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 55, ASSERT_TYPE_ASSERT, "( ( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) ) )", "%s\n\t( handle ) = %i", "( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) )", outBoneIndex) )
            __debugbreak();
        }
        if ( (unsigned int)m_localClientNum >= LOCAL_CLIENT_COUNT )
        {
          LODWORD(outBoneIndex) = 2;
          LODWORD(outTagName) = m_localClientNum;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 58, ASSERT_TYPE_ASSERT, "(unsigned)( localClientIndex ) < (unsigned)( (2) )", "localClientIndex doesn't index MAX_DOBJ_CLIENTS\n\t%i not in [0, %i)", outTagName, outBoneIndex) )
            __debugbreak();
        }
        v11 = 2533 * m_localClientNum + clientNum;
        if ( v11 >= 0x13CA )
        {
          LODWORD(outBoneIndex) = v11;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 62, ASSERT_TYPE_ASSERT, "( ( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) ) )", "%s\n\t( handle ) = %i", "( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) )", outBoneIndex) )
            __debugbreak();
        }
        v12 = clientObjMap[v11];
        if ( v12 )
        {
          if ( v12 >= (unsigned int)s_objCount )
          {
            LODWORD(outBoneIndex) = v12;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 64, ASSERT_TYPE_ASSERT, "( ( !objIndex || ( (unsigned)objIndex < s_objCount ) ) )", "%s\n\t( objIndex ) = %i", "( !objIndex || ( (unsigned)objIndex < s_objCount ) )", outBoneIndex) )
              __debugbreak();
          }
          viewModelDObj = (const DObj *)s_objBuf[v12];
        }
        else
        {
          viewModelDObj = NULL;
        }
      }
      else
      {
        v7 = *((int *)p_sourcePrimaryTagName + 21);
        if ( (unsigned int)v7 >= 2 )
        {
          LODWORD(outBoneIndex) = 2;
          SLODWORD(outTagName) = p_sourcePrimaryTagName[21];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", outTagName, outBoneIndex) )
            __debugbreak();
        }
        viewModelDObj = LocalClientGlobals->m_weaponHand[v7].viewModelDObj;
      }
      if ( viewModelDObj )
      {
        entnum = viewModelDObj->entnum;
        v14 = LocalClientGlobals->__vftable;
        v22[0] = -2;
        stringValue = 0;
        if ( v14->HasCharacterInfo(LocalClientGlobals, entnum - 1) && (CharacterInfo = CG_GetCharacterInfo(LocalClientGlobals, entnum - 1)) != NULL )
        {
          modelTypesToSearch[0] = CHAR_MODEL_WEAPON_HELD;
          modelTypesToSearch[1] = CHAR_MODEL_WEAPON_HELD_LEFT;
          modelTypesToSearch[2] = CHAR_MODEL_WEAPON_EXECUTION;
          TagNameAndBoneIndexForCharacter = TagPair::GetTagNameAndBoneIndexForCharacter(&v24, viewModelDObj, CharacterInfo, modelTypesToSearch, 3, &stringValue, v22);
        }
        else
        {
          TagNameAndBoneIndexForCharacter = TagPair::GetTagNameAndBoneIndex(&v24, viewModelDObj, &stringValue, v22);
        }
        if ( TagNameAndBoneIndexForCharacter )
        {
          if ( LocalClientGlobals->renderingThirdPerson || BG_IsThirdPersonMode(v6, &LocalClientGlobals->predictedPlayerState) )
            Pose = CG_GetPose(this->m_localClientNum, LocalClientGlobals->predictedPlayerState.clientNum);
          else
            Pose = &LocalClientGlobals->viewModelPose;
          if ( CG_DObjGetWorldBoneMatrix(Pose, viewModelDObj, v22[0], &outTagMat, &outOrigin) )
          {
            Tracer_Spawn(this->m_localClientNum, *((_DWORD *)p_sourcePrimaryTagName - 2), (const bitarray<64> *)p_sourcePrimaryTagName + 11, &outOrigin, (const vec3_t *)(p_sourcePrimaryTagName + 2), *((_DWORD *)p_sourcePrimaryTagName - 1), (const Weapon *)(p_sourcePrimaryTagName + 5), *((_BYTE *)p_sourcePrimaryTagName + 80), 0);
          }
          else
          {
            v19 = SL_ConvertToString(stringValue);
            Com_PrintWarning(14, "CgWeaponSystem::ProcessDeferredTracer unable to calc orientation for bone %s.\n", v19);
          }
        }
        else
        {
          v17 = SL_ConvertToString(stringValue);
          Com_PrintWarning(14, "CgWeaponSystem::ProcessDeferredTracer unable find bone %s\n", v17);
        }
      }
      ++v3;
      p_sourcePrimaryTagName += 26;
    }
    while ( v3 < LocalClientGlobals->delayedSpawnTracerEventsCount );
  }
  LocalClientGlobals->delayedSpawnTracerEventsCount = 0;
}

/*
==============
MovementAnimState::Reset
==============
*/
void MovementAnimState::Reset(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  signed int v4; 
  signed int v5; 
  cg_t *LocalClientGlobals; 
  const WeaponHand *ViewModelHand; 
  const DObj **p_viewModelDObj; 

  this->m_goal = -1;
  v4 = 46;
  v5 = 63;
  this->m_offsetAnim = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_START;
  this->m_cycleAnim = WEAP_ANIM_ADDITIVE_MOVE_CYCLE_START;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals )
  {
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    p_viewModelDObj = (const DObj **)&ViewModelHand->viewModelDObj;
    if ( ViewModelHand && ViewModelHand->viewModelDObj && DObjGetTree(ViewModelHand->viewModelDObj) )
    {
      do
        XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v4++, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      while ( v4 <= 61 );
      do
        XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v5++, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      while ( v5 <= 66 );
      this->m_isInitialized = 1;
    }
    else
    {
      this->m_isInitialized = 1;
    }
  }
  else
  {
    this->m_isInitialized = 1;
  }
}

/*
==============
ResetWeaponAnimTrees
==============
*/

void __fastcall ResetWeaponAnimTrees(LocalClientNum_t localClientNum, const playerState_s *ps, double a3)
{
  __int128 v3; 
  __int64 v4; 
  WeaponHand *m_weaponHand; 
  CgWeaponMap *v7; 
  DObj *viewModelDObj; 
  XAnimTree *Tree; 
  PlayerHandIndex v10; 
  int WeaponHandForViewWeapon; 
  __int64 v12; 
  __int64 forceBlendTime; 
  void *objID; 
  Weapon weapon; 
  __int128 v16; 

  v4 = localClientNum;
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_RAISE|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9045, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_ANIM_TREE_RESET ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_ANIM_TREE_RESET )") )
    __debugbreak();
  m_weaponHand = CG_GetLocalClientGlobals((const LocalClientNum_t)v4)->m_weaponHand;
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v7 = CgWeaponMap::ms_instance[v4];
  weapon = *BG_GetCurrentWeaponForPlayer(v7, ps);
  if ( LOWORD(a3) || ps->pm_type >= 7 )
  {
    viewModelDObj = m_weaponHand->viewModelDObj;
    if ( m_weaponHand->viewModelDObj )
    {
      v16 = v3;
      Tree = DObjGetTree(viewModelDObj);
      if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9061, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
        __debugbreak();
      XAnimClearTreeGoalWeights(Tree, 0, XANIM_SUBTREE_DEFAULT, 0, 0.0, 1, viewModelDObj, LINEAR);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 1u, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xEu, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 8u, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xAu, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xBu, 1.0, 0.0, 1.0, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      v10 = WEAPON_HAND_DEFAULT;
      WeaponHandForViewWeapon = BG_PlayerLastWeaponHandForViewWeapon(v7, ps);
      if ( WeaponHandForViewWeapon >= 0 )
      {
        v12 = WeaponHandForViewWeapon + 1i64;
        do
        {
          if ( (unsigned int)v10 >= NUM_WEAPON_HANDS )
          {
            LODWORD(objID) = 2;
            LODWORD(forceBlendTime) = v10;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", forceBlendTime, objID) )
              __debugbreak();
          }
          if ( m_weaponHand->viewModelDObj )
          {
            if ( PM_WeaponClipEmpty(v7, ps, v10) )
              CG_Weapons_StartWeaponAnim((LocalClientNum_t)v4, &weapon, v10, WEAP_IDLE, WEAP_ANIM_EMPTY_IDLE, WEAP_IDLE, WEAP_ANIM_EMPTY_IDLE, 0.0, 0);
            else
              CG_Weapons_StartWeaponAnim((LocalClientNum_t)v4, &weapon, v10, WEAP_IDLE, WEAP_ANIM_IDLE, WEAP_IDLE, WEAP_ANIM_IDLE, 0.0, 0);
          }
          ++v10;
          ++m_weaponHand;
          --v12;
        }
        while ( v12 );
      }
    }
  }
}

/*
==============
RestorePersistentAnims
==============
*/
void RestorePersistentAnims(WeaponHand *weapHand, const float *animWeights, const float *animTimes, const float *animGoalWeights, const float *animGoalTimes)
{
  signed __int64 v9; 
  signed __int64 v10; 
  signed __int64 v11; 
  signed __int64 v12; 
  __int64 v13; 
  unsigned int v14; 
  float v15; 

  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10078, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !animWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10079, ASSERT_TYPE_ASSERT, "(animWeights)", (const char *)&queryFormat, "animWeights") )
    __debugbreak();
  if ( !animTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10080, ASSERT_TYPE_ASSERT, "(animTimes)", (const char *)&queryFormat, "animTimes") )
    __debugbreak();
  v9 = (char *)s_persistentAnims - (char *)animWeights;
  v10 = (char *)animGoalTimes - (char *)animWeights;
  v11 = (char *)animGoalWeights - (char *)animWeights;
  v12 = (char *)animTimes - (char *)animWeights;
  v13 = 53i64;
  do
  {
    v14 = *(_DWORD *)((char *)animWeights + v9);
    v15 = *animWeights;
    if ( v14 - 245 > 0xD )
    {
      if ( v15 <= 0.0 )
        goto LABEL_20;
      XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v14, v15, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    else
    {
      if ( v15 <= 0.0 && *(const float *)((char *)animWeights + v11) <= 0.0 )
        goto LABEL_20;
      XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v14, v15, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v14, *(const float *)((char *)animWeights + v11), *(const float *)((char *)animWeights + v10), 0.0, (scr_string_t)0, *(const float *)((char *)animWeights + v11) > 0.0, 0, LINEAR, NULL);
    }
    if ( *(const float *)((char *)animWeights + v12) > 0.0 )
    {
      if ( XAnimIsLeafNode(weapHand->tree->anims, v14) )
        XAnimSetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v14, *(const float *)((char *)animWeights + v12));
    }
LABEL_20:
    ++animWeights;
    --v13;
  }
  while ( v13 );
}

/*
==============
RestoreShieldPersistentAnims
==============
*/
void RestoreShieldPersistentAnims(WeaponHand *weapHand, const float *animWeights, const float *animTimes, const XAnimParts **shieldXAnimParts)
{
  const XAnim_s *Anims; 
  signed __int64 v9; 
  unsigned int *v10; 
  signed __int64 v11; 
  float *v12; 
  const XAnimParts *Parts; 

  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10166, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !animWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10167, ASSERT_TYPE_ASSERT, "(animWeights)", (const char *)&queryFormat, "animWeights") )
    __debugbreak();
  if ( !animTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10168, ASSERT_TYPE_ASSERT, "(animTimes)", (const char *)&queryFormat, "animTimes") )
    __debugbreak();
  if ( !shieldXAnimParts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10169, ASSERT_TYPE_ASSERT, "(shieldXAnimParts)", (const char *)&queryFormat, "shieldXAnimParts") )
    __debugbreak();
  Anims = XAnimGetAnims(weapHand->tree);
  if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10172, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  v9 = (char *)animWeights - (char *)animTimes;
  v10 = (unsigned int *)s_shieldPersistentAnims;
  v11 = (char *)animTimes - (char *)s_shieldPersistentAnims;
  do
  {
    v12 = (float *)((char *)v10 + v11);
    if ( *(float *)((char *)v10 + v11 + v9) > 0.0 )
    {
      Parts = XAnimGetParts(Anims, *v10);
      if ( Parts )
      {
        if ( Parts == *shieldXAnimParts )
        {
          XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, *v10, *(float *)((char *)v12 + v9), 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          if ( *v12 > 0.0 )
          {
            if ( XAnimIsLeafNode(weapHand->tree->anims, *v10) )
            {
              if ( !XAnimIsLooped(Anims, *v10) || *v12 < 1.0 )
                XAnimSetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, *v10, *v12);
              XAnimSetAnimRate(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, *v10, 1.0);
            }
          }
        }
      }
    }
    ++shieldXAnimParts;
    ++v10;
  }
  while ( (__int64)v10 < (__int64)&unk_1442D8E94 );
}

/*
==============
ScaleSprintOutTime
==============
*/
float ScaleSprintOutTime(const LocalClientNum_t localClientNum, float sprintOutTime)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *v5; 
  const Weapon *ViewmodelWeapon; 
  bool v7; 
  double SprintOutTimeScale; 

  v2 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5545, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v5 = CgWeaponMap::ms_instance[v2];
  ViewmodelWeapon = BG_GetViewmodelWeapon(v5, p_predictedPlayerState);
  v7 = BG_UsingAlternate(p_predictedPlayerState);
  SprintOutTimeScale = BG_GetSprintOutTimeScale(v5, p_predictedPlayerState, ViewmodelWeapon, v7);
  return *(float *)&SprintOutTimeScale * sprintOutTime;
}

/*
==============
SetSwimDragGoalWeights
==============
*/
void SetSwimDragGoalWeights(LocalClientNum_t localClientNum, DObj *obj, const playerState_s *ps, const PlayerHandIndex hand, const Weapon *weapon, const float *dragWeights)
{
  float *v6; 
  signed __int64 v8; 
  __int64 v12; 
  CgHandler *Handler; 

  v6 = (float *)dragWeights;
  v8 = (char *)s_dragAnims - (char *)dragWeights;
  v12 = 4i64;
  do
  {
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, *(weapAnimFiles_t *)((char *)v6 + v8), hand, Handler) )
    {
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, *(_DWORD *)((char *)v6 + (char *)s_dragAnimRoots - (char *)dragWeights), *v6, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, *(_DWORD *)((char *)v6 + v8), *v6, 0.0, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    ++v6;
    --v12;
  }
  while ( v12 );
}

/*
==============
CAssistTarget::SetTarget
==============
*/
void CAssistTarget::SetTarget(CAssistTarget *this, const centity_t *target)
{
  this->m_target = target;
}

/*
==============
MovementAnimState::ShouldApplyQuickDescendTransition
==============
*/
char MovementAnimState::ShouldApplyQuickDescendTransition(const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  const dvar_t *v10; 
  const char *v11; 
  float value; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5615, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5616, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( nextState >= prevState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5617, ASSERT_TYPE_ASSERT, "( static_cast<int>( nextState ) ) < ( static_cast<int>( prevState ) )", "%s < %s\n\t%i, %i", "static_cast<int>( nextState )", "static_cast<int>( prevState )", nextState, prevState) )
    __debugbreak();
  if ( MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
  {
    if ( prevState == HALF_HALF )
    {
      v10 = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint;
      if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint )
      {
        v11 = "movementAnimProto_QuickTransOutSprint";
        goto LABEL_14;
      }
      goto LABEL_16;
    }
    if ( prevState == LONG )
    {
      v10 = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint;
      if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint )
      {
        v11 = "movementAnimProto_QuickTransOutSuperSprint";
LABEL_14:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v11) )
          __debugbreak();
      }
LABEL_16:
      Dvar_CheckFrontendServerThread(v10);
      value = v10->current.value;
      *outTransDurationSec = value;
      *outCycleTransDurationSec = value;
      return 1;
    }
  }
  return 0;
}

/*
==============
CgWeaponSystem::ShouldSpawnTracer
==============
*/
bool CgWeaponSystem::ShouldSpawnTracer(CgWeaponSystem *this, const int attackerEntNum, const bitarray<64> *r_perks, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate, const bool isMainBulletSimulation)
{
  cg_t *LocalClientGlobals; 
  CgStatic *LocalClientStatics; 
  centity_t *Entity; 
  entityState_t *p_nextState; 
  characterInfo_t *CharacterInfo; 
  bool result; 
  int v18; 

  if ( (unsigned int)attackerEntNum >= 0x800 )
  {
    v18 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19540, ASSERT_TYPE_ASSERT, "(unsigned)( attackerEntNum ) < (unsigned)( ( 2048 ) )", "attackerEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", attackerEntNum, v18) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  result = !BG_IsBeamStyleTracer(weapon, isAlternate) && (!CG_PlayerUsingScopedTurret(this->m_localClientNum) || LocalClientGlobals->predictedPlayerState.viewlocked_entNum != attackerEntNum) && (!isMainBulletSimulation || LocalClientGlobals->predictedPlayerState.clientNum == attackerEntNum || (LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)LocalClientGlobals->localClientNum), Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, attackerEntNum), (Entity->flags & 1) == 0) || (p_nextState = &Entity->nextState, !BG_IsCharacterEntity(&Entity->nextState)) || (CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, p_nextState->number)) == NULL || !CharacterInfo->doNotSimulateTracers) && Tracer_ShouldDraw((const LocalClientNum_t)this->m_localClientNum, r_perks, hand, weapon, isAlternate, attackerEntNum) != 0;
  return result;
}

/*
==============
CgWeaponSystem::ShouldSpawnTracerFromEvent
==============
*/
bool CgWeaponSystem::ShouldSpawnTracerFromEvent(CgWeaponSystem *this, const int eventId, const centity_t *hitEventEnt, const int attackerEntNum, const bitarray<64> *r_attackerPerks, const Weapon *weapon, bool isAlternate)
{
  cg_t *LocalClientGlobals; 
  centity_t *Entity; 
  cg_t *v13; 
  __int64 attackerEntNuma; 
  __int64 v16; 

  if ( (unsigned int)attackerEntNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19598, ASSERT_TYPE_ASSERT, "(unsigned)( attackerEntNum ) < (unsigned)( ( 2048 ) )", "attackerEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", attackerEntNum, 2048) )
    __debugbreak();
  if ( (unsigned int)(eventId - 211) <= 3 )
  {
    if ( !hitEventEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19606, ASSERT_TYPE_ASSERT, "(hitEventEnt)", (const char *)&queryFormat, "hitEventEnt") )
      __debugbreak();
    if ( (LOBYTE(hitEventEnt->nextState.lerp.u.vehicle.bodyPitch) & 1) == 0 )
      return 0;
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, attackerEntNum);
  if ( (Entity->flags & 1) != 0 && BG_IsPlayerOrAgentEntity(&Entity->nextState) && CG_IsPlayerEntityNumber(&LocalClientGlobals->predictedPlayerState, attackerEntNum) )
    return 0;
  if ( BG_GetPenetrateType(weapon, isAlternate) == PENETRATE_TYPE_RICOCHET )
    return 0;
  if ( (unsigned int)attackerEntNum >= 0x800 )
  {
    LODWORD(v16) = 2048;
    LODWORD(attackerEntNuma) = attackerEntNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19540, ASSERT_TYPE_ASSERT, "(unsigned)( attackerEntNum ) < (unsigned)( ( 2048 ) )", "attackerEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", attackerEntNuma, v16) )
      __debugbreak();
  }
  v13 = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  return !BG_IsBeamStyleTracer(weapon, isAlternate) && (!CG_PlayerUsingScopedTurret(this->m_localClientNum) || v13->predictedPlayerState.viewlocked_entNum != attackerEntNum) && Tracer_ShouldDraw((const LocalClientNum_t)this->m_localClientNum, r_attackerPerks, WEAPON_HAND_DEFAULT, weapon, isAlternate, attackerEntNum) != 0;
}

/*
==============
CgWeaponSystem::ShouldWeaponPing
==============
*/
_BOOL8 CgWeaponSystem::ShouldWeaponPing(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, const bool isAlternate, const vec3_t *origin)
{
  cg_t *LocalClientGlobals; 
  float v10; 
  const dvar_t *v11; 
  bool v12; 
  vec3_t outOrg; 
  __int64 v14; 

  v14 = -2i64;
  if ( BG_IsOffhandWeaponType(weapon, isAlternate) )
    return 0i64;
  if ( !BG_IsSilenced(weapon, isAlternate) )
    return 1i64;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
  v10 = (float)((float)((float)(outOrg.v[1] - origin->v[1]) * (float)(outOrg.v[1] - origin->v[1])) + (float)((float)(outOrg.v[0] - origin->v[0]) * (float)(outOrg.v[0] - origin->v[0]))) + (float)((float)(outOrg.v[2] - origin->v[2]) * (float)(outOrg.v[2] - origin->v[2]));
  v11 = DCONST_DVARFLT_cg_silencedWeaponPingRangeSquared;
  if ( !DCONST_DVARFLT_cg_silencedWeaponPingRangeSquared && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_silencedWeaponPingRangeSquared") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  v12 = v10 < v11->current.value;
  memset(&outOrg, 0, sizeof(outOrg));
  return v12;
}

/*
==============
CgWeaponSystem::SimulateBulletFire
==============
*/
void CgWeaponSystem::SimulateBulletFire(CgWeaponSystem *this, int eventId, centity_t *inflictorEnt, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const TagPair tagPair, bool isPlayerView, bool isPlayerWeaponView, PlayerHandIndex hand, const int fireSequenceIndex, const CgEventLodData *optionalEventLod, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  signed __int64 v13; 
  void *v14; 
  const CgEventLodData *v17; 
  const CgFireEventHighPrecisionData *v18; 
  entityType_s eType; 
  cg_t *LocalClientGlobals; 
  __int64 m_localClientNum; 
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  bitarray<64> *v24; 
  playerState_s *p_predictedPlayerState; 
  bool (__fastcall *SimulateBulletFire_Orientation)(CgWeaponSystem *, centity_t *, const Weapon *, bool, const TagPair, bool, bool, PlayerHandIndex, const bool, const CgFireEventHighPrecisionData *, orientation_t *, float *, vec3_t *); 
  bool v27; 
  centity_t *v28; 
  int time; 
  cg_t *v30; 
  DebugBulletFireInfoEntry *v31; 
  DebugBulletFireInfoLog *v32; 
  double v33; 
  const centity_t *v34; 
  bool v35; 
  Weapon *v36; 
  bool IsBeamWeapon; 
  bool IsKillCamView; 
  bool ShouldSpread; 
  int v40; 
  CgBallistics *System; 
  playerState_s *v42; 
  double Bullet; 
  float v44; 
  const snapshot_t *nextSnap; 
  int serverTime; 
  float *v; 
  const dvar_t *v48; 
  bool v49; 
  float v50; 
  bool v51; 
  double v52; 
  Weapon *v53; 
  bool v54; 
  bool HasCustomBulletTargetLogic; 
  targetAssistType_t TargetAssistType; 
  Weapon *v57; 
  targetAssistBehavior_t TargetAssistBehavior; 
  centity_t *v59; 
  int v60; 
  bool v61; 
  int v62; 
  int v63; 
  int v64; 
  unsigned __int64 v65; 
  const centity_t **p_m_target; 
  centity_t *v67; 
  PlayerHandIndex v68; 
  const centity_t **v69; 
  ConeTargetHitResults *p_m_hitResults; 
  __int64 v71; 
  const dvar_t *v72; 
  char *fmt; 
  int v74; 
  Weapon *v75; 
  bool ShouldPerformEvent; 
  __int64 v77; 
  const CgFireEventHighPrecisionData *v78; 
  int v79; 
  bool v80; 
  bool v81; 
  bool v82; 
  bool v83; 
  bool v84; 
  unsigned int pHoldrand; 
  float outAngle; 
  float v87; 
  float spreadMaxOut; 
  int v89; 
  Weapon *weapona; 
  centity_t *ownerEnt; 
  float spreadMinOut; 
  float angleMinOut; 
  float angleMaxOut; 
  playerState_s *ps; 
  cg_t *v96; 
  entityState_t *entState; 
  int v98; 
  BgWeaponMap *weaponMap; 
  int v100; 
  BGSpreadSetting v101; 
  __int64 v102; 
  SimulateBulletFirePelletData pelletData; 
  bitarray<64> perks; 
  __m256i v105; 
  __int128 v106; 
  vec3_t v107; 
  ntl::fixed_array<CAssistTarget,20> ptr; 

  v14 = alloca(v13);
  v102 = -2i64;
  v98 = knownHitClientNum;
  ownerEnt = inflictorEnt;
  v100 = eventId;
  weapona = (Weapon *)weapon;
  v17 = optionalEventLod;
  v18 = highPrecisionFireData;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFire");
  PhysPerfTrack_BulletClientTimeStart();
  PhysPerfTrack_BulletClientEventCountAdd();
  if ( !inflictorEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23571, ASSERT_TYPE_ASSERT, "(inflictorEnt)", (const char *)&queryFormat, "inflictorEnt") )
    __debugbreak();
  BG_WeaponDef(weapon, isAlternate);
  if ( BG_GetWeaponType(weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23575, ASSERT_TYPE_ASSERT, "(CG_Weapons_IsBulletWeapon( weapon, isAlternate ))", (const char *)&queryFormat, "CG_Weapons_IsBulletWeapon( weapon, isAlternate )") )
    __debugbreak();
  eType = inflictorEnt->nextState.eType;
  if ( eType >= ET_EVENTS && eType != (ET_PRIMARY_LIGHT|0x40) )
    goto LABEL_16;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v96 = LocalClientGlobals;
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  weaponMap = CgWeaponMap::ms_instance[m_localClientNum];
  if ( (inflictorEnt->flags & 1) != 0 && BG_IsCharacterEntity(&inflictorEnt->nextState) )
  {
    LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
    CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, inflictorEnt->nextState.number);
    v24 = (bitarray<64> *)CharacterInfo;
    if ( CharacterInfo && !CharacterInfo->infoValid )
    {
LABEL_16:
      PhysPerfTrack_BulletClientTimeStop();
      Sys_ProfEndNamedEvent();
      return;
    }
  }
  else
  {
    v24 = NULL;
  }
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !isPlayerWeaponView )
    p_predictedPlayerState = NULL;
  ps = p_predictedPlayerState;
  SimulateBulletFire_Orientation = this->SimulateBulletFire_Orientation;
  v78 = v18;
  ShouldPerformEvent = CG_EventLod_ShouldPerformEvent((const LocalClientNum_t)this->m_localClientNum, CG_EVENT_LOD_TYPE_FIRE_WEAPON_EXACT_MUZZLE_POINT, v17);
  v27 = isPlayerView;
  LOBYTE(v74) = isPlayerView;
  v28 = ownerEnt;
  if ( !((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _BYTE, _DWORD, _BYTE, _QWORD, _QWORD, _QWORD, _QWORD))SimulateBulletFire_Orientation)(this, ownerEnt, weapon, isAlternate, tagPair, v74, isPlayerWeaponView, hand, ShouldPerformEvent, v78, (orientation_t *)&v105, &v87, &v107) )
    goto LABEL_16;
  time = LocalClientGlobals->time;
  entState = &v28->nextState;
  if ( CG_DebugBulletFireLog_ShouldLog(v28->nextState.number) )
  {
    v30 = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    v31 = NULL;
    if ( s_debugBulletFireInfoLog.entryCount == 50 )
    {
      v31 = &s_debugBulletFireInfoLog.entries[49];
    }
    else
    {
      v32 = &s_debugBulletFireInfoLog;
      while ( v32->entries[0].isUsed )
      {
        v32 = (DebugBulletFireInfoLog *)((char *)v32 + 160);
        if ( (__int64)v32 >= (__int64)&s_debugBulletFireInfoLog.entryCount )
          goto LABEL_29;
      }
      ++s_debugBulletFireInfoLog.entryCount;
      v31 = (DebugBulletFireInfoEntry *)v32;
    }
LABEL_29:
    v31->isUsed = 1;
    v31->serverTime = time;
    v31->clientGunPitch = v30->gunAngles.v[0];
    v31->clientGunYaw = v30->gunAngles.v[1];
    v31->clientViewAngles.v[0] = v30->predictedPlayerState.viewangles.v[0];
    v31->clientViewAngles.v[1] = v30->predictedPlayerState.viewangles.v[1];
    v31->clientViewAngles.v[2] = v30->predictedPlayerState.viewangles.v[2];
    v31->clientDeltaAngles.v[0] = v30->predictedPlayerState.delta_angles.v[0];
    v31->clientDeltaAngles.v[1] = v30->predictedPlayerState.delta_angles.v[1];
    v31->clientDeltaAngles.v[2] = v30->predictedPlayerState.delta_angles.v[2];
    v31->clientAdsStartTime = v30->predictedPlayerState.weapCommon.adsStartTime;
    v31->clientAdsFraction = v30->predictedPlayerState.weapCommon.fWeaponPosFrac;
    if ( !CgWeaponMap::ms_instance[0] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    v33 = BG_WeaponADSFractionAffectedByReload(CgWeaponMap::ms_instance[0], &v30->predictedPlayerState);
    v31->clientAdsFractionNotReloading = *(float *)&v33;
    v31->clientIdleTimer1 = v30->predictedPlayerState.weapCommon.weaponIdleTime;
    v31->clientIdleTimer2 = v30->predictedPlayerState.weapCommon.weaponIdleTime2;
    *(_OWORD *)v31->clientBulletOrigin.v = *(_OWORD *)v105.m256i_i8;
    v31->clientBulletDir.v[1] = *(float *)&v105.m256i_i32[4];
    v31->clientBulletDir.v[2] = *(float *)&v105.m256i_i32[5];
    v31->serverBulletEntryAdded = 0;
    v34 = NULL;
    *(_QWORD *)v31->serverBulletOrigin.v = 0i64;
    *(_QWORD *)&v31->serverBulletOrigin.z = 0i64;
    *(_QWORD *)&v31->serverBulletDir.y = 0i64;
    std::_Sort_unchecked<DebugBulletFireInfoEntry *,bool (*)(DebugBulletFireInfoEntry &,DebugBulletFireInfoEntry &)>(s_debugBulletFireInfoLog.entries, (DebugBulletFireInfoEntry *)&s_debugBulletFireInfoLog.entryCount, 50i64, CG_DebugBulletFireLog_Sorter);
    Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    v27 = isPlayerView;
    v28 = ownerEnt;
  }
  else
  {
    v34 = NULL;
  }
  if ( v24 )
    perks = v24[347];
  else
    perks = 0i64;
  v35 = isAlternate;
  v36 = weapona;
  IsBeamWeapon = BG_IsBeamWeapon(weapona, isAlternate);
  IsKillCamView = CG_View_IsKillCamView((const LocalClientNum_t)this->m_localClientNum);
  if ( IsBeamWeapon && (IsKillCamView || !v27) )
    v34 = CG_BeamEntity_GetByOwner((const LocalClientNum_t)this->m_localClientNum, v28);
  ShouldSpread = BG_WeaponBulletFire_ShouldSpread(perks, v36, isAlternate);
  if ( ShouldSpread || IsBeamWeapon )
    v40 = BG_ShotCount(v36, isAlternate);
  else
    v40 = 1;
  System = CgBallistics::GetSystem((const LocalClientNum_t)this->m_localClientNum);
  v75 = v36;
  v42 = ps;
  Bullet = BG_GetBulletRange<CgBallisticInstance>(weaponMap, System, ps, entState, &perks, v75, isAlternate);
  v44 = *(float *)&Bullet;
  nextSnap = v96->nextSnap;
  if ( nextSnap )
    serverTime = nextSnap->serverTime;
  else
    serverTime = Sys_Milliseconds();
  if ( v42 )
    serverTime = v42->serverTime;
  if ( v42 )
  {
    v = v42->viewangles.v;
    pHoldrand = BG_srand_timeangles(serverTime + (hand != WEAPON_HAND_DEFAULT ? 0xA : 0), &v42->viewangles);
    v48 = DCONST_DVARBOOL_bg_aimSpreadDebugLog;
    if ( !DCONST_DVARBOOL_bg_aimSpreadDebugLog && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_aimSpreadDebugLog") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v48);
    v49 = !v48->current.enabled;
    v42 = ps;
    if ( !v49 )
    {
      LODWORD(v77) = pHoldrand;
      LODWORD(fmt) = ps->commandTime;
      Com_Printf(17, "C: SimulateBulletFire: Spread: %f Server Time: %d  Command Time: %d View Angles:[%f %f %f] Rand Seed: %u\n", v87, (unsigned int)ps->serverTime, fmt, *v, ps->viewangles.v[1], ps->viewangles.v[2], v77);
    }
    v35 = isAlternate;
  }
  else
  {
    pHoldrand = serverTime + (hand != WEAPON_HAND_DEFAULT ? 0xA : 0);
    BG_srand(&pHoldrand);
  }
  angleMinOut = 0.0;
  angleMaxOut = FLOAT_360_0;
  spreadMinOut = 0.0;
  v50 = v87;
  spreadMaxOut = v87;
  v51 = ShouldSpread && v40 > 1 && v87 > 0.0;
  v80 = v51;
  memset(&v101, 0, sizeof(v101));
  if ( v51 )
  {
    v52 = BG_random(&pHoldrand);
    BGSpreadSetting::Init(&v101, *(float *)&v52 * 360.0, v40, 0.0, v50);
  }
  v53 = weapona;
  LODWORD(weaponMap) = BG_WeaponBulletFire_GetMethodOfDeath(perks, weapona, v35);
  v54 = isPlayerView && BG_IsTargetAssistActive(v42, entState, v53, v35);
  `eh vector constructor iterator'(&ptr, 0x350ui64, 0x14ui64, (void (__fastcall *)(void *))CAssistTarget::CAssistTarget, (void (__fastcall *)(void *))CAssistTarget::~CAssistTarget);
  HasCustomBulletTargetLogic = BG_GameInterface_HasCustomBulletTargetLogic(ps);
  if ( v54 )
  {
    TargetAssistType = BG_GetTargetAssistType(v53, isAlternate);
    v57 = (Weapon *)&CgWeaponSystem::ms_coneTargetEvaluator;
    if ( TargetAssistType != TARGET_ASSISTTYPPE_CONE )
      v57 = NULL;
    weapona = v57;
  }
  else
  {
    weapona = NULL;
  }
  if ( v54 )
    TargetAssistBehavior = BG_GetTargetAssistBehavior(v53, isAlternate);
  else
    TargetAssistBehavior = TARGET_ASSISTBEHAVE_DEFAULT;
  v83 = TargetAssistBehavior == TARGET_ASSISTBEHAVE_DIRECT_DAMAGE;
  v82 = TargetAssistBehavior == TARGET_ASSISTBEHAVE_TARGET_ONLY;
  v84 = TargetAssistBehavior == TARGET_ASSISTBEHAVE_BEAM;
  v89 = 0;
  v81 = 0;
  if ( weapona && !HasCustomBulletTargetLogic )
  {
    Sys_ProfBeginNamedEvent(0xFF44CCFF, "Target Evaluator");
    if ( v34 )
    {
      v59 = ownerEnt;
      v60 = CG_BeamEntity_BuildTargetArray((const LocalClientNum_t)this->m_localClientNum, ownerEnt, v34, v96->time, &ptr);
      v81 = 1;
      v61 = isAlternate;
    }
    else
    {
      BG_GetTargetAssistAngleRange(v53, isAlternate, spreadMaxOut, v44, &outAngle, (float *)&entState);
      v62 = v40;
      if ( TargetAssistBehavior == TARGET_ASSISTBEHAVE_DIRECT_DAMAGE )
        v62 = 20;
      LOBYTE(v79) = IsBeamWeapon;
      v59 = ownerEnt;
      v60 = (**(__int64 (__fastcall ***)(Weapon *, _QWORD, Weapon *, bool, centity_t *, __m256i *, char *, _DWORD, _DWORD, int, int, const unsigned int, int, char, ntl::fixed_array<CAssistTarget,20> *))&weapona->weaponIdx)(weapona, (unsigned int)this->m_localClientNum, v53, isAlternate, ownerEnt, &v105, &v105.m256i_i8[12], (_DWORD)entState, LODWORD(outAngle), v62, v79, HITLOC_MASK_ALL, v96->time, 1, &ptr);
      v61 = isAlternate;
    }
    v63 = v60;
    v89 = v60;
    if ( BG_IsBeamStyleTracer(v53, v61) )
      CG_LocalEntity_BeamTargetsUpdate((const LocalClientNum_t)this->m_localClientNum, v59, v63, &ptr);
    Sys_ProfEndNamedEvent();
  }
  v64 = 0;
  v96 = (cg_t *)v40;
  if ( v40 > 0 )
  {
    v65 = 0i64;
    p_m_target = &ptr.m_data[0].m_target;
    v67 = ownerEnt;
    do
    {
      PhysPerfTrack_BulletClientPelletCountAdd();
      LODWORD(outAngle) = v64 + pHoldrand;
      BG_srand((unsigned int *)&outAngle);
      if ( v80 )
        BGSpreadSetting::CalculateSpread(&v101, v64, &spreadMinOut, &spreadMaxOut, &angleMinOut, &angleMaxOut);
      ConeTargetInfo::ConeTargetInfo(&pelletData.assistTarget);
      pelletData.assistTarget.__vftable = (CAssistTarget_vtbl *)&CAssistTarget::`vftable';
      pelletData.assistTarget.m_target = NULL;
      if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25541, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
        __debugbreak();
      pelletData.bulletId = this->m_nextBulletId;
      this->m_nextBulletId = pelletData.bulletId + 1;
      pelletData.shotIndex = v64;
      pelletData.inflictorEnt = v67;
      pelletData.knownHitClientNum = v98;
      pelletData.weapon = *v53;
      pelletData.isAlternate = isAlternate;
      pelletData.primaryTagName = TagPair::GetPrimaryTagName((TagPair *)&tagPair);
      pelletData.fallbackTagName = TagPair::GetFallbackTagName((TagPair *)&tagPair);
      *(float *)&pelletData.randSeed = outAngle;
      pelletData.isPlayerWeaponView = isPlayerWeaponView;
      pelletData.bulletRange = v44;
      *(__m256i *)pelletData.orient.origin.v = v105;
      *(_OWORD *)&pelletData.orient.axis.row1.z = v106;
      pelletData.meansOfDeath = (int)weaponMap;
      pelletData.attackerPerks = perks;
      v68 = hand;
      pelletData.hand = hand;
      pelletData.aimSpreadAmount = v87;
      pelletData.spreadMin = spreadMinOut;
      pelletData.spreadMax = spreadMaxOut;
      pelletData.angleMin = angleMinOut;
      pelletData.angleMax = angleMaxOut;
      pelletData.distributePellets = v80;
      pelletData.ignoreTargetEvaluation = v81;
      pelletData.targetEvaluator = (CTargetEvaluator *)weapona;
      pelletData.targetCount = v89;
      pelletData.targetAssistOnlyTargets = v82;
      pelletData.targetAssistDirectDamage = v83;
      pelletData.targetAssistBeam = v84;
      if ( v65 >= 0x14 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\array\\fixed_array.h", 87, ASSERT_TYPE_ASSERT, "( index < size() )", (const char *)&queryFormat, "index < size()") )
          __debugbreak();
        v68 = hand;
      }
      v69 = p_m_target - 104;
      p_m_hitResults = &pelletData.assistTarget.m_hitResults;
      v71 = 6i64;
      do
      {
        *(__m256i *)p_m_hitResults->hits[0].tagWorldPos.v = *(__m256i *)v69;
        *(__m256i *)&p_m_hitResults->hits[0].tagWorldRot.row1.z = *((__m256i *)v69 + 1);
        *(__m256i *)&p_m_hitResults->hits[0].priority = *((__m256i *)v69 + 2);
        *(_OWORD *)&p_m_hitResults->hits[1].tagWorldRot.row1.y = *((_OWORD *)v69 + 6);
        p_m_hitResults = (ConeTargetHitResults *)((char *)p_m_hitResults + 128);
        *(_OWORD *)&p_m_hitResults[-1].hits[11].priority = *((_OWORD *)v69 + 7);
        v69 += 16;
        --v71;
      }
      while ( v71 );
      *(__m256i *)p_m_hitResults->hits[0].tagWorldPos.v = *(__m256i *)v69;
      *(_OWORD *)&p_m_hitResults->hits[0].tagWorldRot.row1.z = *((_OWORD *)v69 + 2);
      *(_QWORD *)&p_m_hitResults->hits[0].tagName = v69[6];
      p_m_hitResults->hits[0].modelIndex = *((_DWORD *)v69 + 14);
      pelletData.assistTarget.m_target = *p_m_target;
      pelletData.tracerStart = v107;
      pelletData.shouldSpawnTracer = CgWeaponSystem::ShouldSpawnTracer(this, v67->nextState.number, &perks, v68, v53, isAlternate, 1);
      v72 = DCONST_DVARBOOL_bg_ballisticsDoClientImpactFx;
      if ( !DCONST_DVARBOOL_bg_ballisticsDoClientImpactFx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsDoClientImpactFx") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v72);
      if ( v72->current.enabled || (pelletData.shouldPredictCharacterImpacts = 0, v100 == 41) )
        pelletData.shouldPredictCharacterImpacts = 1;
      pelletData.localClientNum = this->m_localClientNum;
      CG_GameInterface_SetSimulateBulletFirePelletData(pelletData.localClientNum, &pelletData, ps);
      if ( !CgSimBulletFirePellet_AreWorkersEnabled() || !CgSimBulletFirePellet_TryToPrepareWorker(this->m_localClientNum, &pelletData) )
        CgWeaponSystem::SimulateBulletFirePellet(this, &pelletData, 0);
      pelletData.assistTarget.__vftable = (CAssistTarget_vtbl *)&CAssistTarget::`vftable';
      ConeTargetInfo::~ConeTargetInfo(&pelletData.assistTarget);
      ++v64;
      ++v65;
      p_m_target += 106;
    }
    while ( (__int64)v65 < (__int64)v96 );
  }
  PhysPerfTrack_BulletClientTimeStop();
  Sys_ProfEndNamedEvent();
  `eh vector destructor iterator'(&ptr, 0x350ui64, 0x14ui64, (void (__fastcall *)(void *))CAssistTarget::~CAssistTarget);
}

/*
==============
CgWeaponSystem::SimulateBulletFirePellet
==============
*/
void CgWeaponSystem::SimulateBulletFirePellet(CgWeaponSystem *this, SimulateBulletFirePelletData *pelletFireData, bool shouldDeferEvents)
{
  centity_t *v5; 
  Weapon *p_weapon; 
  bool isAlternate; 
  scr_string_t fallbackTagName; 
  scr_string_t primaryTagName; 
  CAssistTarget *p_assistTarget; 
  LocalClientNum_t localClientNum; 
  float bulletRange; 
  float aimSpreadAmount; 
  float spreadMin; 
  float spreadMax; 
  float angleMin; 
  float angleMax; 
  const playerState_s *v18; 
  int v19; 
  unsigned __int16 *p_linkedEnt; 
  int v21; 
  __int64 m_localClientNum; 
  double ADSDamageRangeScale; 
  float v24; 
  __int64 p_perks; 
  const dvar_t *v26; 
  float value; 
  const dvar_t *v28; 
  float v29; 
  bool v30; 
  bool v31; 
  double FireAtMaxDamageMultiplier; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  int v39; 
  char v40; 
  char v41; 
  ConeTargetHitResults *HitResults; 
  ConeTargetHitResults *v43; 
  LocalClientNum_t v44; 
  CgBallistics *System; 
  centity_t *v46; 
  bool v47; 
  bool IsBeamStyleTracer; 
  bool ShouldSimulateBulletFire; 
  ConeTargetHitResults *v50; 
  ConeTargetHitResults *v51; 
  ConeTargetHitResults *v52; 
  ConeTargetHitInfo *FirstVisibleHit; 
  int v54; 
  scr_string_t tagName; 
  LocalClientNum_t v56; 
  unsigned int v57; 
  centity_t *Entity; 
  LocalClientNum_t v59; 
  centity_t *v60; 
  const DObj *ClientDObj; 
  const DObj *v62; 
  centity_t *owner; 
  bitarray<64> *r_attackerPerks; 
  bool v65; 
  unsigned __int8 inOutIndex; 
  bool targetAssistBeam; 
  bool isPlayerWeaponView; 
  bool v69; 
  bool targetAssistDirectDamage; 
  bool targetAssistOnlyTargets; 
  bool shouldPredictCharacterImpacts; 
  bool ignoreTargetEvaluation; 
  int targetCount; 
  scr_string_t autoTargetedEntTag; 
  int shotIndex; 
  PlayerHandIndex hand; 
  int autoTargetedEntNum; 
  int bulletId; 
  unsigned int randSeed; 
  int modelIndex; 
  centity_t *inflictorEnt; 
  TagPair tagPair; 
  CTargetEvaluator *targetEvaluator; 
  vec3_t *start; 
  vec3_t bulletEndPos; 
  vec3_t out; 
  BulletFireParams outBP; 
  tmat43_t<vec3_t> outTagMat; 

  v69 = shouldDeferEvents;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFirePellet");
  if ( !pelletFireData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24051, ASSERT_TYPE_ASSERT, "(pelletFireData)", (const char *)&queryFormat, "pelletFireData") )
    __debugbreak();
  v5 = pelletFireData->inflictorEnt;
  p_weapon = &pelletFireData->weapon;
  isAlternate = pelletFireData->isAlternate;
  fallbackTagName = pelletFireData->fallbackTagName;
  primaryTagName = pelletFireData->primaryTagName;
  bulletId = pelletFireData->bulletId;
  shotIndex = pelletFireData->shotIndex;
  modelIndex = pelletFireData->knownHitClientNum;
  inflictorEnt = v5;
  v65 = isAlternate;
  TagPair::TagPair(&tagPair, primaryTagName, fallbackTagName);
  p_assistTarget = &pelletFireData->assistTarget;
  localClientNum = pelletFireData->localClientNum;
  bulletRange = pelletFireData->bulletRange;
  aimSpreadAmount = pelletFireData->aimSpreadAmount;
  spreadMin = pelletFireData->spreadMin;
  spreadMax = pelletFireData->spreadMax;
  angleMin = pelletFireData->angleMin;
  angleMax = pelletFireData->angleMax;
  randSeed = pelletFireData->randSeed;
  isPlayerWeaponView = pelletFireData->isPlayerWeaponView;
  autoTargetedEntTag = pelletFireData->meansOfDeath;
  *(_QWORD *)out.v = &pelletFireData->attackerPerks;
  hand = pelletFireData->hand;
  ignoreTargetEvaluation = pelletFireData->ignoreTargetEvaluation;
  targetEvaluator = pelletFireData->targetEvaluator;
  targetCount = pelletFireData->targetCount;
  targetAssistOnlyTargets = pelletFireData->targetAssistOnlyTargets;
  targetAssistDirectDamage = pelletFireData->targetAssistDirectDamage;
  targetAssistBeam = pelletFireData->targetAssistBeam;
  start = &pelletFireData->tracerStart;
  inOutIndex = pelletFireData->shouldSpawnTracer;
  shouldPredictCharacterImpacts = pelletFireData->shouldPredictCharacterImpacts;
  if ( this->m_localClientNum != localClientNum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24101, ASSERT_TYPE_ASSERT, "(m_localClientNum == pelletFireData->localClientNum)", "%s\n\tLocalClientNum mismatch between worker data (%i) and worker thread (%i).", "m_localClientNum == pelletFireData->localClientNum", localClientNum, this->m_localClientNum) )
    __debugbreak();
  *(_QWORD *)bulletEndPos.v = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v18 = (const playerState_s *)(*(_QWORD *)bulletEndPos.v + 8i64);
  if ( !isPlayerWeaponView )
    v18 = NULL;
  memset_0(&outBP, 0, sizeof(outBP));
  outBP.weaponEntIndex = 2046;
  outBP.ignoreHitEntCount = 0;
  BG_AddIgnoreEntToBP(&outBP, v5->nextState.number);
  if ( v18 && v18->numViewLinkedEnts > 0 )
  {
    v19 = 0;
    p_linkedEnt = &v18->viewLinkedEntityData[0].linkedEnt;
    do
    {
      BG_AddIgnoreEntToBP(&outBP, *p_linkedEnt);
      ++v19;
      p_linkedEnt += 16;
    }
    while ( v19 < v18->numViewLinkedEnts );
    isAlternate = v65;
    v5 = inflictorEnt;
  }
  if ( v5->nextState.eType == ET_TURRET )
  {
    v21 = v5->nextState.lerp.u.anonymous.data[6];
    if ( v21 != 2047 )
      BG_AddIgnoreEntToBP(&outBP, v21);
  }
  CG_GameInterface_SimulateBulletFirePellet_AddIgnoreEnts(pelletFireData, v18, &outBP);
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ADSDamageRangeScale = BG_GetADSDamageRangeScale(CgWeaponMap::ms_instance[m_localClientNum], v18, &pelletFireData->weapon, isAlternate);
  v24 = *(float *)&ADSDamageRangeScale;
  if ( !v18 )
  {
    p_perks = 4464i64;
    goto LABEL_27;
  }
  p_perks = (__int64)&v18->perks;
  if ( !BG_HasPerk(&v18->perks, 0x18u) )
  {
LABEL_27:
    value = FLOAT_1_0;
    goto LABEL_28;
  }
  v26 = DCONST_DVARFLT_perk_longerRangeScale;
  if ( !DCONST_DVARFLT_perk_longerRangeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_longerRangeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v26);
  value = v26->current.value;
LABEL_28:
  if ( v18 && BG_HasPerk((const bitarray<64> *)p_perks, 0x1Cu) )
  {
    v28 = DVARFLT_perk_bulletPenetrationMultiplier;
    if ( !DVARFLT_perk_bulletPenetrationMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_bulletPenetrationMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v28);
    v29 = v28->current.value;
  }
  else
  {
    v29 = FLOAT_1_0;
  }
  if ( v18 )
  {
    v30 = v18->weapState[hand].weaponFiredAtMaxCharge == 0;
    v31 = v65;
    if ( !v30 && BG_IsChargeShotWeapon(&pelletFireData->weapon, v65) )
    {
      FireAtMaxDamageMultiplier = BG_WeaponCharge_GetFireAtMaxDamageMultiplier(&pelletFireData->weapon, v65);
      v33 = *(float *)&FireAtMaxDamageMultiplier;
      goto LABEL_41;
    }
  }
  else
  {
    v31 = v65;
  }
  v33 = FLOAT_1_0;
LABEL_41:
  v34 = pelletFireData->orient.origin.v[0];
  outBP.rangeScale = value * v24;
  outBP.dir.v[0] = pelletFireData->orient.axis.m[0].v[0];
  v35 = pelletFireData->orient.axis.m[0].v[2];
  outBP.chargedDamageMultiplier = v33;
  v36 = pelletFireData->orient.axis.m[0].v[1];
  outBP.dir.v[2] = v35;
  v37 = pelletFireData->orient.origin.v[2];
  outBP.penetrationMultiplier = v29;
  outBP.dir.v[1] = v36;
  v38 = pelletFireData->orient.origin.v[1];
  outBP.methodOfDeath = autoTargetedEntTag;
  outBP.start.v[0] = v34;
  outBP.initialPos.v[0] = v34;
  autoTargetedEntNum = 2047;
  autoTargetedEntTag = 0;
  outBP.start.v[2] = v37;
  outBP.initialPos.v[2] = v37;
  outBP.damageMultiplier = FLOAT_1_0;
  outBP.start.v[1] = v38;
  outBP.initialPos.v[1] = v38;
  outBP.travelDistance = 0.0;
  v30 = !CG_GameInterface_CalcBulletEndPos(pelletFireData, &outBP.start, bulletRange, &outBP.dir, &outBP.end);
  v39 = targetCount;
  if ( !v30 )
    goto LABEL_77;
  v40 = targetAssistDirectDamage;
  v41 = targetAssistBeam;
  if ( shotIndex < targetCount && !targetAssistDirectDamage && !targetAssistBeam )
  {
    if ( !targetEvaluator )
    {
LABEL_75:
      CG_Weapons_SimulateBulletFire_EndPos(&randSeed, spreadMin, spreadMax, &outBP.start, &outBP.end, &outBP.dir, angleMin, angleMax, pelletFireData->orient.axis.m, &pelletFireData->orient.axis.m[1], &pelletFireData->orient.axis.m[2], bulletRange);
      goto LABEL_76;
    }
    if ( ignoreTargetEvaluation || targetEvaluator->EvaluateTarget(targetEvaluator, this->m_localClientNum, &pelletFireData->assistTarget, &outBP.start, COERCE_FLOAT(LODWORD(bulletRange)), &outBP.end, &outBP.dir) )
    {
      HitResults = ConeTargetInfo::GetHitResults(&pelletFireData->assistTarget);
      if ( !ConeTargetHitResults::GetFirstVisibleHit(HitResults) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24186, ASSERT_TYPE_ASSERT, "(assistTarget->GetHitResults().GetFirstVisibleHit())", (const char *)&queryFormat, "assistTarget->GetHitResults().GetFirstVisibleHit()") )
        __debugbreak();
      autoTargetedEntNum = p_assistTarget->GetEntNum(&pelletFireData->assistTarget);
      v43 = ConeTargetInfo::GetHitResults(&pelletFireData->assistTarget);
      autoTargetedEntTag = ConeTargetHitResults::GetFirstVisibleHit(v43)->tagName;
LABEL_52:
      if ( targetAssistOnlyTargets && shotIndex && shotIndex >= targetCount )
        goto LABEL_103;
LABEL_55:
      v44 = this->m_localClientNum;
      outBP.damageMultiplier = FLOAT_1_0;
      System = CgBallistics::GetSystem(v44);
      if ( !System && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24284, ASSERT_TYPE_ASSERT, "(ballisticSystem)", (const char *)&queryFormat, "ballisticSystem") )
        __debugbreak();
      v46 = inflictorEnt;
      v47 = System->ShouldFireBallisticBullet(System, &pelletFireData->weapon, v31, inflictorEnt->nextState.number);
      IsBeamStyleTracer = BG_IsBeamStyleTracer(&pelletFireData->weapon, v31);
      ShouldSimulateBulletFire = CG_Weapons_ShouldSimulateBulletFire((const LocalClientNum_t)this->m_localClientNum, &outBP, v46, IsBeamStyleTracer);
      if ( isPlayerWeaponView || ShouldSimulateBulletFire )
      {
        if ( BG_WeaponBulletFire_ShouldRicochet(pelletFireData->attackerPerks, &pelletFireData->weapon, v31) )
        {
          if ( v47 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24293, ASSERT_TYPE_ASSERT, "(!fireBallistic)", "%s\n\tBallistic trajectory cannot be enabled for richocet penetration type!", "!fireBallistic") )
            __debugbreak();
          CgWeaponSystem::SimulateBulletFire_Ricochet(this, &outBP, bulletId, &pelletFireData->weapon, v31, v46, *(const bitarray<64> **)out.v, isPlayerWeaponView, hand, tagPair, bulletRange, 0, inOutIndex, v69);
        }
        else if ( v47 )
        {
          if ( autoTargetedEntNum != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24313, ASSERT_TYPE_ASSERT, "(autoTargetedEntNum == ENTITYNUM_NONE)", "%s\n\tBallistic trajectory cannot be enabled for weapons with target assist!", "autoTargetedEntNum == ENTITYNUM_NONE") )
            __debugbreak();
          CgBallistics::FireBallistics(System, bulletId, &pelletFireData->weapon, v31, isPlayerWeaponView, inOutIndex, hand, randSeed, &outBP, &pelletFireData->orient.axis.m[1], &pelletFireData->orient.axis.m[2], v46->nextState.number, &pelletFireData->attackerPerks, &pelletFireData->tracerStart, &tagPair, *(_DWORD *)(*(_QWORD *)bulletEndPos.v + 26092i64), shouldPredictCharacterImpacts);
        }
        else
        {
          CgWeaponSystem::SimulateBulletFire_DoBulletPathSim(this, &outBP, bulletId, &pelletFireData->weapon, v31, v46, &pelletFireData->attackerPerks, modelIndex, autoTargetedEntNum, autoTargetedEntTag, &pelletFireData->tracerStart, aimSpreadAmount, isPlayerWeaponView, hand, tagPair, shotIndex, inOutIndex, 1, v69, shouldPredictCharacterImpacts, &bulletEndPos);
        }
      }
      goto LABEL_103;
    }
    v39 = targetCount;
    v40 = targetAssistDirectDamage;
    v41 = targetAssistBeam;
  }
  if ( !targetEvaluator || !v40 && !targetAssistOnlyTargets && !v41 )
    goto LABEL_75;
  outBP.end.v[0] = (float)(bulletRange * outBP.dir.v[0]) + outBP.start.v[0];
  outBP.end.v[1] = (float)(bulletRange * outBP.dir.v[1]) + outBP.start.v[1];
  outBP.end.v[2] = (float)(bulletRange * outBP.dir.v[2]) + outBP.start.v[2];
  if ( shotIndex >= v39 )
    goto LABEL_77;
  v50 = ConeTargetInfo::GetHitResults(&pelletFireData->assistTarget);
  if ( !ConeTargetHitResults::GetFirstVisibleHit(v50) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24198, ASSERT_TYPE_ASSERT, "(assistTarget->GetHitResults().GetFirstVisibleHit())", (const char *)&queryFormat, "assistTarget->GetHitResults().GetFirstVisibleHit()") )
    __debugbreak();
  autoTargetedEntNum = p_assistTarget->GetEntNum(&pelletFireData->assistTarget);
  v51 = ConeTargetInfo::GetHitResults(&pelletFireData->assistTarget);
  autoTargetedEntTag = ConeTargetHitResults::GetFirstVisibleHit(v51)->tagName;
LABEL_76:
  v39 = targetCount;
LABEL_77:
  if ( !targetAssistBeam )
    goto LABEL_52;
  if ( shotIndex && !v39 )
    goto LABEL_103;
  if ( v39 <= 0 )
    goto LABEL_55;
  if ( shotIndex < v39 && BG_IsBeamStyleTracer(&pelletFireData->weapon, v31) )
  {
    v52 = ConeTargetInfo::GetHitResults(&pelletFireData->assistTarget);
    FirstVisibleHit = ConeTargetHitResults::GetFirstVisibleHit(v52);
    if ( !FirstVisibleHit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24247, ASSERT_TYPE_ASSERT, "(coneTargetHitInfo)", (const char *)&queryFormat, "coneTargetHitInfo") )
      __debugbreak();
    v54 = p_assistTarget->GetEntNum(&pelletFireData->assistTarget);
    tagName = FirstVisibleHit->tagName;
    v56 = this->m_localClientNum;
    v57 = v54;
    bulletEndPos = FirstVisibleHit->tagWorldPos;
    Entity = CG_GetEntity(v56, v54);
    if ( (Entity->flags & 1) != 0 )
      CgWeaponSystem::SimulateImpactEffectForBeamWeapons(this, inflictorEnt->nextState.number, p_weapon, v65, Entity, &outBP, &bulletEndPos, v69, &bulletEndPos);
    if ( v57 >= 0x800 )
    {
      LODWORD(r_attackerPerks) = 2048;
      LODWORD(owner) = v57;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24009, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", owner, r_attackerPerks) )
        __debugbreak();
    }
    v59 = this->m_localClientNum;
    out.v[0] = 0.0;
    out.v[1] = 0.0;
    out.v[2] = 0.0;
    v60 = CG_GetEntity(v59, v57);
    if ( (v60->flags & 1) != 0 )
    {
      ClientDObj = Com_GetClientDObj(v57, this->m_localClientNum);
      v62 = ClientDObj;
      if ( ClientDObj )
      {
        inOutIndex = -2;
        if ( DObjGetBoneIndexInternal_66(ClientDObj, tagName, &inOutIndex, &modelIndex) )
        {
          if ( CG_DObjGetWorldBoneMatrix(&v60->pose, v62, inOutIndex, (tmat33_t<vec3_t> *)&outTagMat, &outTagMat.m[3]) )
            MatrixTransposeTransformVector43(&bulletEndPos, &outTagMat, &out);
        }
      }
    }
    CgWeaponSystem::TryCG_TrackingLaserBeamAdd(this, v69, (const LocalClientNum_t)this->m_localClientNum, start, &outBP.end, inflictorEnt, p_weapon, v65, shotIndex, v57, tagName, &out, aimSpreadAmount);
  }
LABEL_103:
  Sys_ProfEndNamedEvent();
}

/*
==============
CgWeaponSystem::SimulateBulletFire_DoBulletPathSim
==============
*/
char CgWeaponSystem::SimulateBulletFire_DoBulletPathSim(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, const int knownHitClientNum, const int autoTargetedEntNum, const scr_string_t autoTargetedEntTag, const vec3_t *tracerStart, float aimSpreadAmount, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, const int shotIndex, bool shouldSpawnTracer, bool shouldSpawnExitTracers, bool shouldDeferEvents, bool forceClientSideImpactFx, vec3_t *outLastBulletPos)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v25; 
  cg_t *v26; 
  bool v27; 
  bool v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float v34; 
  float v35; 
  const dvar_t *v36; 
  bool v37; 
  const dvar_t *v38; 
  const centity_t *KnownHitClientEntity; 
  LocalClientNum_t m_localClientNum; 
  bool v41; 
  bool v42; 
  unsigned __int16 EntityHitId; 
  unsigned int ScriptableHitId; 
  const dvar_t *v45; 
  vec3_t *p_hitPos; 
  double TracerSpeed; 
  float travelDistance; 
  LocalClientNum_t v49; 
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 
  centity_t *v51; 
  unsigned int v52; 
  entityType_s eType; 
  const char *EntityTypeName; 
  int v55; 
  int v57; 
  int surfaceFlags; 
  float v59; 
  const entityState_t *v60; 
  unsigned __int16 v61; 
  int v62; 
  float v63; 
  float v64; 
  char v65; 
  bool v66; 
  double SurfacePenetrationDepth; 
  const dvar_t *v69; 
  float v70; 
  __int128 v71; 
  float v72; 
  bool IsBeamStyleTracer; 
  bool v74; 
  const dvar_t *v75; 
  bool v76; 
  vec3_t *p_end; 
  bool (__fastcall *CheckFirePenetrateStop)(CgWeaponSystem *, const centity_t *, const centity_t *, bool); 
  centity_t *Entity; 
  float v80; 
  float v81; 
  float v82; 
  bool v84; 
  bool v85; 
  bool IsHitSurfaceTransparent; 
  int v87; 
  float v88; 
  float v89; 
  float v90; 
  double Float_Internal_DebugName; 
  int v92; 
  unsigned __int16 v93; 
  unsigned int v94; 
  unsigned __int16 v95; 
  float v96; 
  float v97; 
  float v98; 
  __int128 v99; 
  __int128 v100; 
  __int128 v101; 
  __int128 v103; 
  __int128 v105; 
  double v106; 
  __int128 v108; 
  float damageMultiplier; 
  float v110; 
  float v111; 
  float v112; 
  double v113; 
  const cg_t *v114; 
  int v115; 
  int v116; 
  unsigned int meansOfDeath; 
  int v118; 
  unsigned int v119; 
  unsigned __int16 v120; 
  meansOfDeath_t methodOfDeath; 
  unsigned __int16 v122; 
  unsigned __int16 v123; 
  float v124; 
  bool isBallistics; 
  bool fmt; 
  int br; 
  bool v128; 
  unsigned __int8 v129; 
  bool v130; 
  bool v131; 
  unsigned __int16 v132; 
  bool v133; 
  int entityIndex; 
  unsigned __int16 entityIndexa; 
  int triggerTime; 
  int triggerTimea; 
  unsigned int targetScriptableIndex; 
  unsigned int targetScriptableIndexa; 
  cg_t *cgameGlob; 
  float v142; 
  unsigned int impactEffects; 
  unsigned int v144; 
  vec3_t tagOffset; 
  vec3_t initialBulletPos; 
  BulletTraceResults outResults; 
  BulletTraceResults trace; 
  BulletFireParams v149; 

  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFire_Internal");
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v25 = DCONST_DVARBOOL_cg_debugBullets;
  cgameGlob = LocalClientGlobals;
  v26 = LocalClientGlobals;
  if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v25);
  if ( v25->current.enabled && bp->isBallistics )
    Com_Printf(14, "CgWeaponSystem::SimulateBulletFire_DoBulletPathSim: Client Time: %d Ballistics Time: %d\n", (unsigned int)v26->time, (unsigned int)bp->ballisticsTickStartTime);
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24378, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !inflictorEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24379, ASSERT_TYPE_ASSERT, "(inflictorEnt)", (const char *)&queryFormat, "inflictorEnt") )
    __debugbreak();
  v27 = isAlternate;
  if ( BG_GetWeaponType(weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24380, ASSERT_TYPE_ASSERT, "(CG_Weapons_IsBulletWeapon( weapon, isAlternate ))", (const char *)&queryFormat, "CG_Weapons_IsBulletWeapon( weapon, isAlternate )") )
    __debugbreak();
  v28 = !bp->isBallistics;
  v29 = bp->start.v[0];
  v30 = bp->start.v[2];
  v31 = bp->end.v[0] - v29;
  v32 = bp->end.v[2];
  initialBulletPos.v[1] = bp->start.v[1];
  initialBulletPos.v[0] = v29;
  v33 = (float)(bp->end.v[1] - initialBulletPos.v[1]) * (float)(bp->end.v[1] - initialBulletPos.v[1]);
  initialBulletPos.v[2] = v30;
  v35 = fsqrt((float)(v33 + (float)(v31 * v31)) + (float)((float)(v32 - v30) * (float)(v32 - v30)));
  v34 = v35;
  if ( v28 )
  {
    v131 = shouldDeferEvents;
  }
  else
  {
    v36 = DCONST_DVARBOOL_bg_ballisticsSyncImpactFx;
    if ( !DCONST_DVARBOOL_bg_ballisticsSyncImpactFx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSyncImpactFx") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v36);
    v28 = !v36->current.enabled;
    v37 = 1;
    v38 = DCONST_DVARINT_bg_ballisticsSimTimeStepMs;
    if ( v28 )
      v37 = shouldDeferEvents;
    v131 = v37;
    if ( !DCONST_DVARINT_bg_ballisticsSimTimeStepMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSimTimeStepMs") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v38);
    bp->ballisticsTickEndTime = v38->current.integer + bp->ballisticsTickStartTime;
  }
  KnownHitClientEntity = CG_Weapons_SimulateBulletFire_GetKnownHitClientEntity((const LocalClientNum_t)this->m_localClientNum, knownHitClientNum);
  m_localClientNum = this->m_localClientNum;
  if ( KnownHitClientEntity )
    v41 = CG_Weapons_SimulateBulletFire_FakeTrace(m_localClientNum, bp, KnownHitClientEntity, &outResults);
  else
    v41 = CG_Weapons_BulletTrace(m_localClientNum, bp, weapon, isAlternate, inflictorEnt, &outResults, 0, NULL, 0);
  v128 = v41;
  v42 = v41;
  EntityHitId = Trace_GetEntityHitId(&outResults.trace);
  if ( EntityHitId >= 0x800u )
    EntityHitId = 2047;
  v132 = EntityHitId;
  ScriptableHitId = Trace_GetScriptableHitId(&outResults.trace);
  v45 = DCONST_DVARBOOL_cg_debugBullets;
  targetScriptableIndex = ScriptableHitId;
  if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v45);
  if ( v45->current.enabled )
  {
    p_hitPos = &outResults.hitPos;
    if ( !v42 )
      p_hitPos = &bp->end;
    CgWeaponSystem::AddDebugBulletLine(this, &bp->start, p_hitPos);
  }
  CG_SND_VerifyTracerAndWhizbySpeeds(*r_attackerPerks, weapon, isAlternate);
  TracerSpeed = CG_GetTracerSpeed(*r_attackerPerks, weapon, isAlternate);
  v142 = *(float *)&TracerSpeed;
  if ( *(float *)&TracerSpeed <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24431, ASSERT_TYPE_ASSERT, "(tracerSpeed > 0.0f)", (const char *)&queryFormat, "tracerSpeed > 0.0f") )
    __debugbreak();
  travelDistance = 0.0;
  if ( shouldSpawnTracer )
  {
    CgWeaponSystem::TrySpawnTracer(this, bulletId, v131, isPlayerWeaponView, inflictorEnt->nextState.number, r_attackerPerks, hand, tagPair, tracerStart, &outResults.hitPos, weapon, isAlternate, 0);
    travelDistance = bp->travelDistance;
  }
  if ( !BG_IsBeamStyleTracer(weapon, isAlternate) )
    goto LABEL_53;
  v49 = this->m_localClientNum;
  if ( autoTargetedEntNum != 2047 )
  {
    *(_QWORD *)&tagOffset.y = 0i64;
    tagOffset.v[0] = 0.0;
    CgWeaponSystem::TryCG_TrackingLaserBeamAdd(this, v131, v49, tracerStart, &outResults.hitPos, inflictorEnt, weapon, isAlternate, shotIndex, autoTargetedEntNum, autoTargetedEntTag, &tagOffset, aimSpreadAmount);
LABEL_53:
    v51 = inflictorEnt;
    goto LABEL_54;
  }
  if ( v131 )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_LaserAdd;
      QueueEntry->event.hitEffect.sourceEntityNum = v49;
      QueueEntry->event.trackingLaserAdd.start = *tracerStart;
      QueueEntry->event.trackingLaserAdd.end = outResults.hitPos;
      QueueEntry->event.laserAdd.owner = inflictorEnt;
      *(__m256i *)&QueueEntry->event.spawnTracer.tracerStart.z = *(__m256i *)&weapon->weaponIdx;
      *(_OWORD *)&QueueEntry->event.spawnTracer.r_weapon.weaponAttachments[2] = *(_OWORD *)&weapon->attachmentVariationIndices[5];
      *(double *)&QueueEntry->event.spawnTracer.r_weapon.attachmentVariationIndices[5] = *(double *)&weapon->attachmentVariationIndices[21];
      QueueEntry->event.hitEffect.startPos.v[1] = *(float *)&weapon->weaponCamo;
      QueueEntry->event.trackingLaserAdd.weapon.attachmentVariationIndices[25] = isAlternate;
      QueueEntry->valid = 1;
    }
    goto LABEL_53;
  }
  CG_LaserBeamAdd(v49, tracerStart, &outResults.hitPos, inflictorEnt, weapon, isAlternate, 0);
  v51 = inflictorEnt;
  if ( !inflictorEnt )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25250, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
      __debugbreak();
    goto LABEL_53;
  }
LABEL_54:
  if ( v128 && bp->methodOfDeath == MOD_EXPLOSIVE_BULLET )
  {
    v52 = 1;
    if ( !BG_IsCharacterEntity(&v51->nextState) )
    {
      eType = inflictorEnt->nextState.eType;
      if ( eType != ET_HELICOPTER )
      {
        EntityTypeName = BG_GetEntityTypeName(eType);
        Com_PrintWarning(17, "WARNING: Explosive bullets fired by unsupported entity '%i' of type '%s'.\n", (unsigned int)inflictorEnt->nextState.number, EntityTypeName);
      }
    }
  }
  else
  {
    v52 = 0;
  }
  br = bp->ballisticsTickStartTime;
  fmt = bp->isBallistics;
  if ( !v128 )
  {
    v55 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, v35, &bp->end, fmt, br);
    *outLastBulletPos = bp->end;
    CgWeaponSystem::TrySimulateBulletFire_MissEffect(this, v55, v131, inflictorEnt->nextState.number, weapon, isAlternate, &bp->initialPos, &bp->start, &outResults.hitPos, (outResults.trace.surfaceFlags >> 19) & 0x3F);
    Sys_ProfEndNamedEvent();
    return 1;
  }
  v57 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, v35, &outResults.hitPos, fmt, br);
  triggerTime = v57;
  if ( bp->isBallistics )
    bp->ballisticsTickEndTime = v57;
  surfaceFlags = outResults.trace.surfaceFlags;
  v59 = outResults.hitPos.v[1];
  outLastBulletPos->v[0] = outResults.hitPos.v[0];
  outLastBulletPos->v[2] = outResults.hitPos.v[2];
  outLastBulletPos->v[1] = v59;
  *(_QWORD *)tagOffset.v = &inflictorEnt->nextState;
  CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v57, v131, inflictorEnt->nextState.number, v132, targetScriptableIndex, knownHitClientNum, weapon, isAlternate, &bp->initialPos, &bp->start, &outResults.hitPos, &outResults.trace.normal, (surfaceFlags >> 19) & 0x3F, bp->methodOfDeath, 0, outResults.trace.contents, forceClientSideImpactFx);
  CgWeaponSystem::TryBulletScriptableImpact(this, triggerTime, v131, (__int16)**(_WORD **)tagOffset.v, v132, weapon, isAlternate, (const meansOfDeath_t)bp->methodOfDeath, &bp->start, &outResults.hitPos, (const scr_string_t)outResults.trace.partName);
  if ( !outResults.trace.startsolid )
  {
    v60 = *(const entityState_t **)tagOffset.v;
    if ( knownHitClientNum != -1 )
      Com_PrintWarning(17, "WARNING: Possible Client/Server Perk desync - Received HITCLIENT fire event from entity '%i' but the bullet did not explode as expected (%i).\n", (unsigned int)(__int16)**(_WORD **)tagOffset.v, v52);
    v61 = Trace_GetEntityHitId(&outResults.trace);
    if ( v61 >= 0x800u )
      v61 = 2047;
    entityIndex = v61;
    v62 = _xmm;
    v63 = FLOAT_0_0099999998;
    v64 = FLOAT_1000_0;
    targetScriptableIndexa = 0;
    v65 = 1;
    v66 = BG_GetPenetrateType(weapon, isAlternate) == PENETRATE_TYPE_MAXIMUM;
    v133 = v66;
    while ( 1 )
    {
      *(float *)&_XMM7 = FLOAT_3_4028235e38;
      if ( !v66 )
      {
        SurfacePenetrationDepth = BG_GetSurfacePenetrationDepth(weapon, v27, outResults.depthSurfaceType);
        LODWORD(_XMM7) = LODWORD(SurfacePenetrationDepth);
        if ( BG_IsCharacterEntity(v60) && BG_HasPerk(r_attackerPerks, 0x1Cu) )
        {
          v69 = DVARFLT_perk_bulletPenetrationMultiplier;
          if ( !DVARFLT_perk_bulletPenetrationMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_bulletPenetrationMultiplier") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v69);
          *(float *)&_XMM7 = *(float *)&SurfacePenetrationDepth * v69->current.value;
        }
        if ( *(float *)&_XMM7 <= 0.0 )
          goto LABEL_152;
      }
      v70 = outResults.hitPos.v[0];
      v71 = LODWORD(outResults.hitPos.v[1]);
      v72 = outResults.hitPos.v[2];
      if ( !BG_AdvanceTrace(bp, &outResults.trace, &outResults.hitPos, 0.13500001) )
        goto LABEL_152;
      IsBeamStyleTracer = BG_IsBeamStyleTracer(weapon, v27);
      if ( !CG_Weapons_ShouldSimulateBulletFire((const LocalClientNum_t)this->m_localClientNum, bp, inflictorEnt, IsBeamStyleTracer) )
        goto LABEL_152;
      if ( !v65 || (v129 = 1, (outResults.trace.contents & 0x10) == 0) )
        v129 = 0;
      v74 = CG_Weapons_BulletTrace((const LocalClientNum_t)this->m_localClientNum, bp, weapon, v27, inflictorEnt, &outResults, outResults.depthSurfaceType, NULL, 0);
      v75 = DCONST_DVARBOOL_cg_debugBullets;
      v76 = v74;
      v130 = v74;
      if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v75);
      if ( v75->current.enabled )
      {
        p_end = &outResults.hitPos;
        if ( !v76 )
          p_end = &bp->end;
        CgWeaponSystem::AddDebugBulletLine(this, &bp->start, p_end);
      }
      CheckFirePenetrateStop = this->CheckFirePenetrateStop;
      Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, entityIndex);
      if ( CheckFirePenetrateStop(this, inflictorEnt, Entity, v129) )
      {
LABEL_152:
        Sys_ProfEndNamedEvent();
        return 0;
      }
      v149 = *bp;
      BG_RemoveIgnoreEntFromBP(&v149, entityIndex);
      v80 = bp->dir.v[0];
      v81 = bp->dir.v[1];
      v82 = bp->dir.v[2];
      LODWORD(v149.dir.v[0]) = LODWORD(v80) ^ v62;
      LODWORD(v149.dir.v[1]) = LODWORD(v81) ^ v62;
      v149.start.v[0] = bp->end.v[0];
      v149.start.v[2] = bp->end.v[2];
      *(__m256i *)&trace.trace.fraction = *(__m256i *)&outResults.trace.fraction;
      LODWORD(v149.dir.v[2]) = LODWORD(v82) ^ v62;
      v149.start.v[1] = bp->end.v[1];
      v149.end.v[1] = *(float *)&v71 - (float)(v81 * v63);
      *(__m256i *)&trace.trace.contents = *(__m256i *)&outResults.trace.contents;
      *(_OWORD *)trace.hitPos.v = *(_OWORD *)outResults.hitPos.v;
      v149.end.v[0] = v70 - (float)(v80 * v63);
      v149.end.v[2] = v72 - (float)(v82 * v63);
      *(__m256i *)&trace.trace.allsolid = *(__m256i *)&outResults.trace.allsolid;
      __asm { vextractf128 xmm0, ymm3, 1 }
      *(double *)&trace.depthSurfaceType = *(double *)&outResults.depthSurfaceType;
      LODWORD(trace.trace.normal.v[0]) = _XMM0 ^ v62;
      LODWORD(trace.trace.normal.v[2]) = LODWORD(outResults.trace.normal.v[2]) ^ v62;
      LODWORD(trace.trace.normal.v[1]) = LODWORD(outResults.trace.normal.v[1]) ^ v62;
      if ( v76 )
        BG_AdvanceTrace(&v149, &trace.trace, &trace.hitPos, v63);
      v84 = CG_Weapons_BulletTrace((const LocalClientNum_t)this->m_localClientNum, &v149, weapon, v27, inflictorEnt, &trace, trace.depthSurfaceType, NULL, 0);
      v85 = v84 && trace.trace.allsolid || outResults.trace.startsolid && trace.trace.startsolid;
      triggerTimea = BG_IsHitSurfaceTransparent(&outResults.trace) ? 0x100 : 0;
      IsHitSurfaceTransparent = BG_IsHitSurfaceTransparent(&trace.trace);
      v87 = 4;
      if ( IsHitSurfaceTransparent )
        v87 = 260;
      impactEffects = v87;
      if ( v84 || v85 )
        break;
      if ( v130 && !outResults.trace.allsolid )
      {
        v88 = v70 - outResults.hitPos.v[0];
        v89 = *(float *)&v71 - outResults.hitPos.v[1];
        v90 = v72 - outResults.hitPos.v[2];
        Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bullet_penetrationMinFxDist, "bullet_penetrationMinFxDist");
        if ( (float)((float)((float)(v89 * v89) + (float)(v88 * v88)) + (float)(v90 * v90)) > (float)(*(float *)&Float_Internal_DebugName * *(float *)&Float_Internal_DebugName) )
        {
          v92 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, v34, &outResults.hitPos, bp->isBallistics, bp->ballisticsTickStartTime);
          v93 = Trace_GetEntityHitId(&outResults.trace);
          if ( v93 >= 0x800u )
            v93 = 2047;
          v94 = Trace_GetScriptableHitId(&outResults.trace);
          CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v92, v131, (__int16)**(_WORD **)tagOffset.v, v93, v94, knownHitClientNum, weapon, v27, &bp->initialPos, &bp->start, &outResults.hitPos, &outResults.trace.normal, (outResults.trace.surfaceFlags >> 19) & 0x3F, bp->methodOfDeath, triggerTimea, outResults.trace.contents, forceClientSideImpactFx);
          CgWeaponSystem::TryBulletScriptableImpact(this, v92, v131, (__int16)**(_WORD **)tagOffset.v, v93, weapon, v27, (const meansOfDeath_t)bp->methodOfDeath, &bp->start, &outResults.hitPos, (const scr_string_t)outResults.trace.partName);
          if ( shouldSpawnTracer && shouldSpawnExitTracers )
          {
            CgWeaponSystem::TrySpawnTracer(this, bulletId, v131, 0, (__int16)**(_WORD **)tagOffset.v, r_attackerPerks, hand, tagPair, &bp->start, &outResults.hitPos, weapon, v27, (int)(float)((float)(travelDistance / v142) * v64));
            travelDistance = bp->travelDistance;
          }
        }
LABEL_141:
        v62 = _xmm;
        v63 = FLOAT_0_0099999998;
      }
      v123 = Trace_GetEntityHitId(&outResults.trace);
      if ( v123 >= 0x800u )
        v123 = 2047;
      entityIndex = v123;
      if ( !v130 )
      {
        *outLastBulletPos = bp->end;
        if ( bp->isBallistics )
          bp->ballisticsTickEndTime = bp->ballisticsTickStartTime + Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_bg_ballisticsSimTimeStepMs, "bg_ballisticsSimTimeStepMs");
        goto LABEL_148;
      }
      v124 = outResults.hitPos.v[1];
      outLastBulletPos->v[0] = outResults.hitPos.v[0];
      outLastBulletPos->v[2] = outResults.hitPos.v[2];
      outLastBulletPos->v[1] = v124;
      isBallistics = bp->isBallistics;
      if ( isBallistics )
        bp->ballisticsTickEndTime = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, v34, &outResults.hitPos, isBallistics, bp->ballisticsTickStartTime);
      v60 = *(const entityState_t **)tagOffset.v;
      v65 = v129;
      v66 = v133;
      if ( (int)++targetScriptableIndexa >= 5 )
        goto LABEL_148;
    }
    v95 = Trace_GetEntityHitId(&trace.trace);
    if ( v95 >= 0x800u )
      v95 = 2047;
    entityIndexa = v95;
    v144 = Trace_GetScriptableHitId(&trace.trace);
    v96 = trace.hitPos.v[2];
    v97 = trace.hitPos.v[1];
    v98 = trace.hitPos.v[0];
    if ( v85 )
    {
      v99 = LODWORD(v149.end.v[1]);
      *(float *)&v99 = (float)((float)((float)(v149.end.v[1] - v149.start.v[1]) * (float)(v149.end.v[1] - v149.start.v[1])) + (float)((float)(v149.end.v[0] - v149.start.v[0]) * (float)(v149.end.v[0] - v149.start.v[0]))) + (float)((float)(v149.end.v[2] - v149.start.v[2]) * (float)(v149.end.v[2] - v149.start.v[2]));
      v100 = v99;
    }
    else
    {
      v101 = v71;
      *(float *)&v101 = (float)((float)((float)(*(float *)&v71 - trace.hitPos.v[1]) * (float)(*(float *)&v71 - trace.hitPos.v[1])) + (float)((float)(v70 - trace.hitPos.v[0]) * (float)(v70 - trace.hitPos.v[0]))) + (float)((float)(v72 - trace.hitPos.v[2]) * (float)(v72 - trace.hitPos.v[2]));
      v100 = v101;
    }
    v103 = v100;
    *(float *)&v103 = fsqrt(*(float *)&v100);
    _XMM0 = v103;
    __asm { vmaxss  xmm10, xmm0, cs:__real@3f800000 }
    if ( v133 )
    {
      damageMultiplier = bp->damageMultiplier;
    }
    else
    {
      if ( v84 )
      {
        if ( BG_HasPerk(r_attackerPerks, 0x1Cu) )
        {
          *(double *)&_XMM0 = BG_GetSurfacePenetrationDepth(weapon, v27, trace.depthSurfaceType);
          v105 = _XMM0;
          v106 = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_bulletPenetrationMultiplier, "perk_bulletPenetrationMultiplier");
          v108 = v105;
          *(float *)&v108 = *(float *)&v105 * *(float *)&v106;
          _XMM1 = v108;
          __asm { vminss  xmm7, xmm1, xmm7 }
        }
        else
        {
          *(double *)&_XMM0 = BG_GetSurfacePenetrationDepth(weapon, v27, trace.depthSurfaceType);
          __asm { vminss  xmm7, xmm0, xmm7 }
        }
        if ( *(float *)&_XMM7 <= 0.0 )
          goto LABEL_152;
        v96 = trace.hitPos.v[2];
        v97 = trace.hitPos.v[1];
        v98 = trace.hitPos.v[0];
      }
      damageMultiplier = bp->damageMultiplier - (float)(*(float *)&_XMM10 / *(float *)&_XMM7);
      bp->damageMultiplier = damageMultiplier;
    }
    if ( damageMultiplier <= 0.0 )
      goto LABEL_152;
    if ( v85 )
      goto LABEL_140;
    v110 = v98 - outResults.hitPos.v[0];
    v111 = v97 - outResults.hitPos.v[1];
    v112 = v96 - outResults.hitPos.v[2];
    v113 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bullet_penetrationMinFxDist, "bullet_penetrationMinFxDist");
    if ( (float)((float)((float)(v111 * v111) + (float)(v110 * v110)) + (float)(v112 * v112)) <= (float)(*(float *)&v113 * *(float *)&v113) )
      goto LABEL_140;
    if ( v130 && (outResults.trace.surfaceFlags & 4) != 0 )
    {
      v114 = cgameGlob;
    }
    else
    {
      v114 = cgameGlob;
      v115 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, v34, &trace.hitPos, bp->isBallistics, bp->ballisticsTickStartTime);
      CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v115, v131, (__int16)**(_WORD **)tagOffset.v, entityIndexa, v144, knownHitClientNum, weapon, v27, &bp->initialPos, &v149.start, &trace.hitPos, &bp->dir, (trace.trace.surfaceFlags >> 19) & 0x3F, bp->methodOfDeath, impactEffects, trace.trace.contents, forceClientSideImpactFx);
    }
    if ( !v130 )
    {
LABEL_140:
      v64 = FLOAT_1000_0;
    }
    else
    {
      v116 = CG_CalcBallisticBulletEffectTime(v114, &initialBulletPos, v34, &outResults.hitPos, bp->isBallistics, bp->ballisticsTickStartTime);
      meansOfDeath = bp->methodOfDeath;
      v118 = v116;
      v119 = Trace_GetScriptableHitId(&outResults.trace);
      v120 = Trace_GetEntityHitId(&outResults.trace);
      if ( v120 >= 0x800u )
        v120 = 2047;
      CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v118, v131, (__int16)**(_WORD **)tagOffset.v, v120, v119, knownHitClientNum, weapon, isAlternate, &bp->initialPos, &bp->start, &outResults.hitPos, &outResults.trace.normal, (outResults.trace.surfaceFlags >> 19) & 0x3F, meansOfDeath, triggerTimea, outResults.trace.contents, forceClientSideImpactFx);
      methodOfDeath = bp->methodOfDeath;
      v122 = Trace_GetEntityHitId(&outResults.trace);
      if ( v122 >= 0x800u )
        v122 = 2047;
      CgWeaponSystem::TryBulletScriptableImpact(this, v118, v131, (__int16)**(_WORD **)tagOffset.v, v122, weapon, isAlternate, methodOfDeath, &bp->start, &outResults.hitPos, (const scr_string_t)outResults.trace.partName);
      v64 = FLOAT_1000_0;
      v27 = isAlternate;
      if ( shouldSpawnTracer && shouldSpawnExitTracers )
      {
        CgWeaponSystem::TrySpawnTracer(this, bulletId, v131, 0, (__int16)**(_WORD **)tagOffset.v, r_attackerPerks, hand, tagPair, &bp->start, &outResults.hitPos, weapon, isAlternate, (int)(float)((float)(travelDistance / v142) * 1000.0));
        travelDistance = bp->travelDistance;
      }
    }
    goto LABEL_141;
  }
LABEL_148:
  Sys_ProfEndNamedEvent();
  return 1;
}

/*
==============
CgWeaponSystem::SimulateBulletFire_HitEffect
==============
*/
void CgWeaponSystem::SimulateBulletFire_HitEffect(CgWeaponSystem *this, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  cg_t *LocalClientGlobals; 
  int ClientHitEvent; 
  int v22; 
  LocalClientNum_t m_localClientNum; 
  CgWeaponSystem *WeaponSystem; 
  int fmt; 
  int event; 

  if ( meansOfDeath >= 0x19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23527, ASSERT_TYPE_ASSERT, "(unsigned)( meansOfDeath ) < (unsigned)( MOD_NUM )", "meansOfDeath doesn't index MOD_NUM\n\t%i not in [0, %i)", meansOfDeath, 25) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23530, ASSERT_TYPE_SANITY, "( cgameGlob )", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( knownHitClientNum == LocalClientGlobals->predictedPlayerState.clientNum )
    ClientHitEvent = BG_WeaponBulletFire_GetClientHitEvent(meansOfDeath, 0);
  else
    ClientHitEvent = BG_WeaponBulletFire_GetHitEvent(meansOfDeath, 0);
  v22 = ClientHitEvent;
  if ( forceClientSideHandling || !this->SimulateBulletFire_UseEventBasedHitEffect(this, sourceEntityNum, targetEntityNum, ClientHitEvent) )
  {
    if ( knownHitClientNum == LocalClientGlobals->predictedPlayerState.clientNum )
    {
      m_localClientNum = this->m_localClientNum;
      if ( sourceEntityNum < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20697, ASSERT_TYPE_ASSERT, "(sourceEntityNum >= 0)", (const char *)&queryFormat, "sourceEntityNum >= 0") )
        __debugbreak();
      if ( sourceEntityNum == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20698, ASSERT_TYPE_ASSERT, "(sourceEntityNum != ENTITYNUM_NONE)", (const char *)&queryFormat, "sourceEntityNum != ENTITYNUM_NONE") )
        __debugbreak();
      if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20699, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
        __debugbreak();
      Sys_ProfBeginNamedEvent(0xFF008080, "CG_BulletHitClientEvent");
      BulletHitClientEventSound(m_localClientNum, sourceEntityNum, weapon, isAlternate, position, surfType, v22, impactEffects, SND_HIT_ARMOR_TYPE_NONE);
      if ( (impactEffects & 4) == 0 )
      {
        WeaponSystem = CgWeaponSystem::GetWeaponSystem(m_localClientNum);
        WeaponSystem->BulletTrajectoryEffects(WeaponSystem, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, v22);
      }
      CG_Rumble_PlayOnPositionByName(m_localClientNum, "damage_bullet", startPos);
      Sys_ProfEndNamedEvent();
    }
    else
    {
      LOBYTE(event) = isAlternate;
      LOBYTE(fmt) = -2;
      this->BulletHitEvent(this, sourceEntityNum, targetEntityNum, targetScriptableIndex, fmt, weapon, event, initialShootingPos, startPos, position, normal, surfType, v22, impactEffects, hitContents, 0, (const scr_string_t)0, forceClientSideHandling, -1, SND_HIT_ARMOR_TYPE_NONE, SND_HITMARKER_TYPE_STANDARD, NULL);
    }
  }
}

/*
==============
CgWeaponSystem::SimulateBulletFire_MissEffect
==============
*/
void CgWeaponSystem::SimulateBulletFire_MissEffect(CgWeaponSystem *this, __int64 sourceEntityNum, const Weapon *weapon, _BOOL8 isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  this->BulletTrajectoryEffects(this, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, 93);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_Ricochet
==============
*/
void CgWeaponSystem::SimulateBulletFire_Ricochet(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, float bulletRange, int ricochetCount, bool shouldSpawnTracer, bool shouldDeferEvents)
{
  CgWeaponSystem *v14; 
  const Weapon *v15; 
  bool v17; 
  bitarray<64> v18; 
  float v19; 
  float v20; 
  double TracerSpeed; 
  float v22; 
  int v23; 
  float travelDistance; 
  unsigned __int16 EntityHitId; 
  unsigned int ScriptableHitId; 
  const dvar_t *v27; 
  vec3_t *p_hitPos; 
  unsigned __int16 partGroup; 
  centity_t *v30; 
  CgHandler *Handler; 
  int number; 
  CgStatic *LocalClientStatics; 
  const cg_t *LocalClientGlobals; 
  const characterInfo_t *CharacterInfo; 
  team_t v36; 
  CgHandler *v37; 
  int v38; 
  CgStatic *v39; 
  const cg_t *v40; 
  const characterInfo_t *v41; 
  double PenetrateMultiplier; 
  __int128 v44; 
  bool v46; 
  float v47; 
  float v48; 
  float v49; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  float v57; 
  float v58; 
  int weaponEntIndex; 
  int v60; 
  int v61; 
  bool v62; 
  bool v63; 
  bool v64; 
  unsigned __int16 v65; 
  team_t team; 
  int i; 
  unsigned int targetScriptableIndex; 
  centity_t *outHitEnt; 
  vec3_t *p_start; 
  vec3_t tracerStart; 
  BulletTraceResults br; 

  v14 = this;
  v15 = weapon;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFire_Ricochet");
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24725, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !inflictorEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24726, ASSERT_TYPE_ASSERT, "(inflictorEnt)", (const char *)&queryFormat, "inflictorEnt") )
    __debugbreak();
  v17 = isAlternate;
  if ( BG_GetWeaponType(v15, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24727, ASSERT_TYPE_ASSERT, "(CG_Weapons_IsBulletWeapon( weapon, isAlternate ))", (const char *)&queryFormat, "CG_Weapons_IsBulletWeapon( weapon, isAlternate )") )
    __debugbreak();
  if ( BG_IsBeamStyleTracer(v15, isAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24728, ASSERT_TYPE_ASSERT, "(!BG_IsBeamStyleTracer( weapon, isAlternate ))", (const char *)&queryFormat, "!BG_IsBeamStyleTracer( weapon, isAlternate )") )
    __debugbreak();
  v18 = *r_attackerPerks;
  v19 = bp->start.v[1];
  tracerStart.v[0] = bp->start.v[0];
  v20 = bp->start.v[2];
  p_start = &bp->start;
  tracerStart.v[2] = v20;
  tracerStart.v[1] = v19;
  CG_SND_VerifyTracerAndWhizbySpeeds(v18, v15, isAlternate);
  TracerSpeed = CG_GetTracerSpeed(*r_attackerPerks, v15, isAlternate);
  v22 = *(float *)&TracerSpeed;
  if ( *(float *)&TracerSpeed <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24746, ASSERT_TYPE_ASSERT, "(tracerSpeed > 0.0f)", (const char *)&queryFormat, "tracerSpeed > 0.0f") )
    __debugbreak();
  v23 = ricochetCount;
  travelDistance = 0.0;
  for ( i = 0; i < 12; ++i )
  {
    v64 = CG_Weapons_BulletTrace((const LocalClientNum_t)v14->m_localClientNum, bp, v15, v17, inflictorEnt, &br, 0, (const centity_t **)&outHitEnt, v23 > 0);
    EntityHitId = Trace_GetEntityHitId(&br.trace);
    if ( EntityHitId >= 0x800u )
      EntityHitId = 2047;
    v65 = EntityHitId;
    ScriptableHitId = Trace_GetScriptableHitId(&br.trace);
    v27 = DCONST_DVARBOOL_cg_debugBullets;
    targetScriptableIndex = ScriptableHitId;
    if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v27);
    if ( v27->current.enabled )
    {
      p_hitPos = &br.hitPos;
      if ( !v64 )
        p_hitPos = &bp->end;
      CgWeaponSystem::AddDebugBulletLine(v14, &bp->start, p_hitPos);
    }
    if ( br.trace.startsolid )
      break;
    if ( !v64 )
      break;
    partGroup = br.trace.partGroup;
    if ( (unsigned __int16)(br.trace.partGroup - 19) <= 1u || bp->methodOfDeath == MOD_EXPLOSIVE_BULLET )
      break;
    v30 = outHitEnt;
    if ( outHitEnt && (outHitEnt->flags & 1) != 0 )
    {
      if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&outHitEnt->nextState.lerp.eFlags, ACTIVE, 0x10u) )
      {
        if ( br.ignoreHitEnt )
        {
          BG_AdvanceTrace(bp, &br.trace, &br.hitPos, 0.0);
          v23 = ricochetCount;
        }
        else
        {
          if ( !Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_bullet_penetration_enabled, "bullet_penetration_enabled") || !BG_IsCharacterEntity(&v30->nextState) )
            break;
          team = TEAM_ZERO;
          Handler = CgHandler::getHandler(v14->m_localClientNum);
          number = v30->nextState.number;
          LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)Handler->m_localClientNum);
          LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
          if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
            __debugbreak();
          CharacterInfo = CG_GetCharacterInfo(LocalClientGlobals, number);
          if ( CharacterInfo )
            team = CharacterInfo->team;
          v36 = TEAM_ZERO;
          if ( (inflictorEnt->flags & 1) != 0 && BG_IsCharacterEntity(&inflictorEnt->nextState) )
          {
            v37 = CgHandler::getHandler(v14->m_localClientNum);
            v38 = inflictorEnt->nextState.number;
            v39 = CgStatic::GetLocalClientStatics((const LocalClientNum_t)v37->m_localClientNum);
            v40 = CG_GetLocalClientGlobals((const LocalClientNum_t)v39->m_localClientNum);
            if ( !v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
              __debugbreak();
            v41 = CG_GetCharacterInfo(v40, v38);
            v14 = this;
            if ( v41 )
              v36 = v41->team;
          }
          v17 = isAlternate;
          if ( !BG_IsRifleBullet(weapon, isAlternate) || inflictorEnt == v30 || v36 && v36 == team )
            break;
          BG_AdvanceTrace(bp, &br.trace, &br.hitPos, 0.0);
          v23 = ricochetCount;
          v15 = weapon;
        }
        continue;
      }
      partGroup = br.trace.partGroup;
    }
    if ( partGroup == 19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24851, ASSERT_TYPE_ASSERT, "(br.trace.partGroup != HITLOC_SHIELD)", (const char *)&queryFormat, "br.trace.partGroup != HITLOC_SHIELD") )
      __debugbreak();
    PenetrateMultiplier = BG_GetPenetrateMultiplier(v15, v17);
    if ( (int)*(float *)&PenetrateMultiplier >= 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24853, ASSERT_TYPE_ASSERT, "(weaponRicochetMax < 5)", (const char *)&queryFormat, "weaponRicochetMax < BULLET_MAX_RICOCHET") )
      __debugbreak();
    if ( ricochetCount >= (int)*(float *)&PenetrateMultiplier )
      break;
    v44 = LODWORD(bulletRange);
    *(float *)&v44 = bulletRange - bp->travelDistance;
    _XMM0 = v44;
    __asm { vmaxss  xmm9, xmm0, xmm10 }
    if ( *(float *)&_XMM9 <= 0.0 )
      break;
    CgWeaponSystem::TrySimulateBulletFire_HitEffect(v14, 0x80000000, shouldDeferEvents, inflictorEnt->nextState.number, v65, targetScriptableIndex, 2047, v15, v17, &bp->initialPos, &bp->start, &br.hitPos, &br.trace.normal, (br.trace.surfaceFlags >> 19) & 0x3F, bp->methodOfDeath, 0x800u, br.trace.contents, 0);
    CgWeaponSystem::TryBulletScriptableImpact(v14, 0x80000000, shouldDeferEvents, inflictorEnt->nextState.number, v65, v15, v17, (const meansOfDeath_t)bp->methodOfDeath, &bp->start, &br.hitPos, (const scr_string_t)br.trace.partName);
    if ( shouldSpawnTracer )
    {
      v46 = isPlayerWeaponView && !ricochetCount;
      CgWeaponSystem::TrySpawnTracer(v14, bulletId, shouldDeferEvents, v46, inflictorEnt->nextState.number, r_attackerPerks, hand, tagPair, &tracerStart, &br.hitPos, v15, v17, (int)(float)((float)(travelDistance / v22) * 1000.0));
      travelDistance = bp->travelDistance;
      if ( debugDrawTracer )
        CG_DebugLine(&tracerStart, &br.hitPos, &colorGreen, 1, 75);
    }
    v47 = br.trace.normal.v[2];
    v48 = br.trace.normal.v[1];
    v49 = br.hitPos.v[0] - (float)(0.13500001 * bp->dir.v[0]);
    v50 = br.hitPos.v[1];
    bp->start.v[0] = v49;
    v51 = v50 - (float)(0.13500001 * bp->dir.v[1]);
    v52 = br.hitPos.v[2];
    bp->start.v[1] = v51;
    v53 = v52 - (float)(0.13500001 * bp->dir.v[2]);
    bp->start.v[2] = v53;
    v54 = v47 * bp->dir.v[2];
    v55 = bp->dir.v[0];
    v56 = v48 * bp->dir.v[1];
    tracerStart.v[1] = v51;
    tracerStart.v[0] = v49;
    v57 = (float)(v54 * -2.0) - (float)((float)(v56 + (float)(v55 * br.trace.normal.v[0])) * 2.0);
    v58 = (float)(v57 * br.trace.normal.v[0]) + v55;
    bp->dir.v[0] = v58;
    bp->dir.v[1] = (float)(v48 * v57) + bp->dir.v[1];
    bp->dir.v[2] = (float)(v47 * v57) + bp->dir.v[2];
    bp->end.v[0] = (float)(*(float *)&_XMM9 * v58) + bp->start.v[0];
    bp->end.v[1] = (float)(*(float *)&_XMM9 * bp->dir.v[1]) + bp->start.v[1];
    bp->end.v[2] = (float)(*(float *)&_XMM9 * bp->dir.v[2]) + bp->start.v[2];
    weaponEntIndex = bp->weaponEntIndex;
    tracerStart.v[2] = v53;
    BG_RemoveIgnoreEntFromBP(bp, weaponEntIndex);
    if ( inflictorEnt->nextState.eType == ET_TURRET )
    {
      v60 = inflictorEnt->nextState.lerp.u.anonymous.data[6];
      if ( v60 != 2047 )
        BG_RemoveIgnoreEntFromBP(bp, v60);
    }
    v23 = ++ricochetCount;
  }
  v61 = inflictorEnt->nextState.number;
  if ( v64 )
  {
    CgWeaponSystem::TrySimulateBulletFire_HitEffect(v14, 0x80000000, shouldDeferEvents, v61, v65, targetScriptableIndex, 2047, weapon, v17, &bp->initialPos, &bp->start, &br.hitPos, &br.trace.normal, (br.trace.surfaceFlags >> 19) & 0x3F, bp->methodOfDeath, 0, br.trace.contents, 0);
    v62 = shouldDeferEvents;
    CgWeaponSystem::TryBulletScriptableImpact(v14, 0x80000000, shouldDeferEvents, inflictorEnt->nextState.number, v65, weapon, v17, (const meansOfDeath_t)bp->methodOfDeath, &bp->start, &br.hitPos, (const scr_string_t)br.trace.partName);
  }
  else
  {
    v62 = shouldDeferEvents;
    CgWeaponSystem::TrySimulateBulletFire_MissEffect(v14, 0x80000000, shouldDeferEvents, v61, weapon, v17, &bp->initialPos, p_start, &br.hitPos, (br.trace.surfaceFlags >> 19) & 0x3F);
  }
  if ( shouldSpawnTracer )
  {
    v63 = isPlayerWeaponView && !ricochetCount;
    CgWeaponSystem::TrySpawnTracer(v14, bulletId, v62, v63, inflictorEnt->nextState.number, r_attackerPerks, hand, tagPair, &tracerStart, &br.hitPos, weapon, v17, (int)(float)((float)(travelDistance / v22) * 1000.0));
    if ( debugDrawTracer )
      CG_DebugLine(&tracerStart, &br.hitPos, &colorGreen, 1, 75);
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CgWeaponSystem::SimulateImpactEffectForBeamWeapons
==============
*/
void CgWeaponSystem::SimulateImpactEffectForBeamWeapons(CgWeaponSystem *this, const int attackerEntNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *victimEnt, const BulletFireParams *bp, const vec3_t *bulletEndPos, const bool shouldDeferEvents, vec3_t *outImpactPos)
{
  __int128 v9; 
  __int128 v10; 
  __int128 v11; 
  __int128 v12; 
  bool IsCharacterEntity; 
  LocalClientNum_t m_localClientNum; 
  bool v17; 
  int v18; 
  int v19; 
  unsigned int DetailPhysicsInstanceId; 
  CG_PhysicsObject *v21; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  unsigned int impactEffects; 
  unsigned __int8 *WeaponPriorityMap; 
  float v25; 
  int v26; 
  Physics_CharacterProxy_Type v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  __int128 v34; 
  signed int v37; 
  hknpBodyId *RigidBodyID; 
  const Physics_DetailHitData *DetailHitData; 
  int surfaceFlags; 
  vec3_t *v41; 
  int v42; 
  float v43; 
  entityState_t *v44; 
  Weapon *weapon; 
  HavokPhysics_CollisionQueryResult *v46; 
  __int64 knownHitClientNum; 
  bool v49; 
  int NumRigidBodys; 
  hknpBodyId result; 
  vec3_t *v53; 
  entityState_t *p_nextState; 
  Weapon *v55; 
  CgWeaponSystem *v56; 
  Physics_RaycastExtendedData extendedData; 
  vec3_t pos; 
  vec3_t end; 
  vec3_t start; 
  trace_t trace; 
  __int128 v62; 
  __int128 v63; 
  __int128 v64; 
  __int128 v65; 

  v55 = (Weapon *)r_weapon;
  v56 = this;
  v53 = outImpactPos;
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23881, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !victimEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23882, ASSERT_TYPE_ASSERT, "(victimEnt)", (const char *)&queryFormat, "victimEnt") )
    __debugbreak();
  if ( (victimEnt->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23883, ASSERT_TYPE_ASSERT, "(CENextValid( victimEnt ))", (const char *)&queryFormat, "CENextValid( victimEnt )") )
    __debugbreak();
  *outImpactPos = *bulletEndPos;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateImpactEffectForBeamWeapons");
  p_nextState = &victimEnt->nextState;
  IsCharacterEntity = BG_IsCharacterEntity(&victimEnt->nextState);
  m_localClientNum = this->m_localClientNum;
  v17 = IsCharacterEntity;
  v49 = IsCharacterEntity;
  v18 = 3 * m_localClientNum;
  v19 = 3 * m_localClientNum + 4;
  if ( IsCharacterEntity )
  {
    DetailPhysicsInstanceId = CG_PhysicsCharacterProxy_GetDetailPhysicsInstanceId(m_localClientNum, victimEnt);
  }
  else
  {
    v21 = CG_PhysicsObject_Get(victimEnt->nextState.number, m_localClientNum);
    if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23902, ASSERT_TYPE_ASSERT, "(victimEntPhysicsObject)", (const char *)&queryFormat, "victimEntPhysicsObject") )
      __debugbreak();
    if ( (unsigned int)v19 >= 8 )
    {
      LODWORD(v46) = v18 + 4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23905, ASSERT_TYPE_ASSERT, "(unsigned)( clientDetailWorldId ) < (unsigned)( PHYSICS_WORLD_ID_COUNT )", "clientDetailWorldId doesn't index PHYSICS_WORLD_ID_COUNT\n\t%i not in [0, %i)", v46, 8) )
        __debugbreak();
    }
    DetailPhysicsInstanceId = v21->physicsInstances[v18 + 4];
  }
  if ( DetailPhysicsInstanceId != -1 )
  {
    v65 = v9;
    v64 = v10;
    v63 = v11;
    v62 = v12;
    ClosestResult = PhysicsQuery_GetClosestResult((Physics_WorldId)v19);
    HavokPhysics_CollisionQueryResult::Reset(ClosestResult, 1);
    impactEffects = 0;
    if ( v17 )
      WeaponPriorityMap = BG_GetWeaponPriorityMap(r_weapon, isAlternate);
    else
      WeaponPriorityMap = NULL;
    Physics_AddDetailTrace(ClosestResult, WeaponPriorityMap);
    v25 = bulletEndPos->v[0];
    v26 = 1;
    extendedData.ignoreBodies = NULL;
    extendedData.phaseSelection = All;
    v27 = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
    extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
    if ( v17 )
      v27 = PHYSICS_CHARACTERPROXY_TYPE_DETAIL;
    *(_WORD *)&extendedData.collectInsideHits = 256;
    extendedData.characterProxyType = v27;
    extendedData.collisionBuffer = 0.0;
    extendedData.contents = 41969969;
    v28 = bp->start.v[1];
    v29 = bp->start.v[2];
    v30 = v25 - bp->start.v[0];
    v31 = bulletEndPos->v[2];
    start.v[0] = bp->start.v[0];
    v34 = LODWORD(bulletEndPos->v[1]);
    v32 = bulletEndPos->v[1] - v28;
    v33 = v31 - v29;
    start.v[1] = v28;
    *(float *)&v34 = (float)((float)(v32 * v32) + (float)(v30 * v30)) + (float)(v33 * v33);
    start.v[2] = v29;
    if ( *(float *)&v34 <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 639, ASSERT_TYPE_SANITY, "( val > 0 )", (const char *)&queryFormat, "val > 0") )
      __debugbreak();
    _XMM1 = v34;
    __asm { vrsqrtss xmm4, xmm1, xmm1 }
    end.v[0] = (float)((float)(v30 * *(float *)&_XMM4) * 0.25) + bulletEndPos->v[0];
    end.v[1] = (float)((float)(v32 * *(float *)&_XMM4) * 0.25) + bulletEndPos->v[1];
    end.v[2] = (float)((float)(v33 * *(float *)&_XMM4) * 0.25) + bulletEndPos->v[2];
    v37 = 0;
    NumRigidBodys = Physics_GetNumRigidBodys((const Physics_WorldId)v19, DetailPhysicsInstanceId);
    if ( NumRigidBodys > 0 )
    {
      do
      {
        if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 105, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body ID when system is not initialized", "g_physicsInitialized") )
          __debugbreak();
        if ( (unsigned int)v19 > 7 )
        {
          LODWORD(knownHitClientNum) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 106, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", knownHitClientNum) )
            __debugbreak();
        }
        if ( !g_physicsClientWorldsCreated && (unsigned int)(v19 - 2) <= 5 )
        {
          LODWORD(knownHitClientNum) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 108, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", knownHitClientNum) )
            __debugbreak();
        }
        if ( !g_physicsServerWorldsCreated && (unsigned int)v19 <= 1 )
        {
          LODWORD(knownHitClientNum) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 109, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", knownHitClientNum) )
            __debugbreak();
        }
        RigidBodyID = HavokPhysics_GetRigidBodyID(&result, (const Physics_WorldId)v19, DetailPhysicsInstanceId, v37);
        Physics_Raycast((Physics_WorldId)v19, RigidBodyID->m_serialAndIndex, &start, &end, &extendedData, ClosestResult);
        ++v37;
      }
      while ( v37 < NumRigidBodys );
      v17 = v49;
      impactEffects = 0;
      v26 = 1;
    }
    if ( HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
    {
      DetailHitData = NULL;
      if ( v17 )
        DetailHitData = Physics_GetDetailHitData(ClosestResult, 0, 0);
      Physics_ConvertRayQueryResultToLegacyTrace(ClosestResult, NULL, DetailHitData, &trace);
      surfaceFlags = trace.surfaceFlags;
      if ( v17 )
        surfaceFlags = 3670016;
      trace.surfaceFlags = surfaceFlags;
      if ( trace.partGroup == 2 || trace.partGroup == 1 )
      {
        if ( trace.partGroup == 1 )
          v26 = 1025;
        impactEffects = v26;
      }
      else if ( (unsigned int)trace.partGroup - 6 > 0xB )
      {
        if ( trace.partGroup == 20 )
          impactEffects = 128;
      }
      else
      {
        impactEffects = 64;
      }
      HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(ClosestResult, 0, &pos);
      v41 = v53;
      v42 = trace.surfaceFlags;
      v43 = pos.v[1];
      v44 = p_nextState;
      weapon = v55;
      v53->v[0] = pos.v[0];
      v41->v[2] = pos.v[2];
      v41->v[1] = v43;
      CgWeaponSystem::TrySimulateBulletFire_HitEffect(v56, 0x80000000, shouldDeferEvents, attackerEntNum, v44->number, 0xFFFFFFFF, -1, weapon, isAlternate, &bp->initialPos, &bp->start, &pos, &trace.normal, (v42 >> 19) & 0x3F, bp->methodOfDeath, impactEffects, trace.contents, 1);
      CgWeaponSystem::TryBulletScriptableImpact(v56, 0x80000000, shouldDeferEvents, attackerEntNum, v44->number, weapon, isAlternate, (const meansOfDeath_t)bp->methodOfDeath, &bp->start, &pos, (const scr_string_t)trace.partName);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
SndWeaponShotGetSecureOrigin
==============
*/
void SndWeaponShotGetSecureOrigin(const vec3_t *from, vec3_t *to)
{
  float v2; 
  float v3; 
  float v4; 
  int v5; 
  __int64 v6; 

  v2 = from->v[2];
  v3 = from->v[0];
  LOBYTE(v5) = BYTE3(from);
  HIBYTE(v5) = BYTE2(from);
  *(_WORD *)((char *)&v5 + 1) = (_WORD)from;
  LODWORD(to->v[2]) = LODWORD(v2) ^ v5 ^ s_weaponsoundorg_aab_Z ^ LODWORD(from->v[1]);
  LODWORD(to->v[0]) = LODWORD(v3) ^ LODWORD(v2) ^ v5 ^ s_weaponsoundorg_aab_X;
  LODWORD(to->v[1]) = LODWORD(v3) ^ v5 ^ ~s_weaponsoundorg_aab_Y;
  v4 = to->v[0];
  memset(&v6, 0, sizeof(v6));
  if ( ((LODWORD(v4) & 0x7F800000) == 2139095040 || (LODWORD(to->v[1]) & 0x7F800000) == 2139095040 || (LODWORD(to->v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1352, ASSERT_TYPE_SANITY, "( !IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] )") )
    __debugbreak();
}

/*
==============
SndWeaponShotSetSecureOrigin
==============
*/
void SndWeaponShotSetSecureOrigin(const vec3_t *from, vec3_t *to)
{
  unsigned int v4; 
  unsigned int v5; 
  unsigned int v6; 
  int v7; 
  vec3_t *v8; 

  v8 = to;
  if ( ((LODWORD(from->v[0]) & 0x7F800000) == 2139095040 || (LODWORD(from->v[1]) & 0x7F800000) == 2139095040 || (LODWORD(from->v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1359, ASSERT_TYPE_SANITY, "( !IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] )") )
    __debugbreak();
  LOBYTE(v7) = BYTE3(to);
  HIBYTE(v7) = BYTE2(v8);
  *(_WORD *)((char *)&v7 + 1) = (_WORD)to;
  v4 = v7 ^ ~s_weaponsoundorg_aab_Y ^ LODWORD(from->v[1]);
  v5 = s_weaponsoundorg_aab_Z ^ LODWORD(from->v[2]);
  v6 = v7 ^ v4 ^ s_weaponsoundorg_aab_X ^ LODWORD(from->v[0]);
  LODWORD(to->v[0]) = v4;
  LODWORD(to->v[2]) = v6;
  LODWORD(to->v[1]) = v7 ^ v6 ^ v5;
  memset(&v8, 0, sizeof(v8));
}

/*
==============
CgWeaponSystem::SpawnTracer
==============
*/
void CgWeaponSystem::SpawnTracer(CgWeaponSystem *this, const int bulletId, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  int v16; 
  cg_t *LocalClientGlobals; 
  __int64 delayedSpawnTracerEventsCount; 
  __int64 v19; 
  scr_string_t FallbackTagName; 
  const vec3_t *v21; 
  __int64 instigatorEntNum; 
  Weapon *weapon; 

  if ( (unsigned int)inflictorEntNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16579, ASSERT_TYPE_ASSERT, "(unsigned)( inflictorEntNum ) < (unsigned)( ( 2048 ) )", "inflictorEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", inflictorEntNum, 2048) )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(weapon) = 2;
    LODWORD(instigatorEntNum) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16580, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", instigatorEntNum, weapon) )
      __debugbreak();
  }
  v16 = spawnDelay;
  if ( spawnDelay < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16581, ASSERT_TYPE_ASSERT, "(spawnDelay >= 0)", (const char *)&queryFormat, "spawnDelay >= 0") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !blendFromViewmodel || v16 )
  {
    Tracer_Spawn(this->m_localClientNum, bulletId, r_inflictorPerks, tracerStart, tracerEnd, inflictorEntNum, r_weapon, isAlternate, v16);
  }
  else
  {
    if ( !TagPair::GetPrimaryTagName((TagPair *)&sourceTagPair) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16591, ASSERT_TYPE_ASSERT, "(sourceTagPair.GetPrimaryTagName() != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "sourceTagPair.GetPrimaryTagName() != NULL_SCR_STRING") )
      __debugbreak();
    delayedSpawnTracerEventsCount = LocalClientGlobals->delayedSpawnTracerEventsCount;
    if ( (int)delayedSpawnTracerEventsCount < 16 )
    {
      v19 = delayedSpawnTracerEventsCount;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].bulletId = bulletId;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].sourceEntityNum = inflictorEntNum;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].sourcePrimaryTagName = TagPair::GetPrimaryTagName((TagPair *)&sourceTagPair);
      FallbackTagName = TagPair::GetFallbackTagName((TagPair *)&sourceTagPair);
      v21 = tracerEnd;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].sourceFallbackTagName = FallbackTagName;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].target = *v21;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].weapon = *r_weapon;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].isAlternate = isAlternate;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].hand = hand;
      LocalClientGlobals->delayedSpawnTracerEvents[v19].perks = *r_inflictorPerks;
      ++LocalClientGlobals->delayedSpawnTracerEventsCount;
    }
    else
    {
      Com_PrintWarning(14, "CgWeaponSystem::QueueTracer: No deferred tracers remaining - Too many this frame (max is %i).\n", 16i64);
    }
  }
}

/*
==============
StopAdditiveCrawlAnims
==============
*/
void StopAdditiveCrawlAnims(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj, const PlayerHandIndex hand, const float blendOutSeconds)
{
  const XAnimTree *Tree; 
  __int64 i; 
  CgHandler *Handler; 
  signed int v12; 
  double Weight; 
  double GoalTime; 
  weapAnimFiles_t anim[4]; 
  unsigned int animIndex[4]; 

  *(_OWORD *)animIndex = _xmm;
  *(_OWORD *)anim = _xmm;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4888, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !IsAdditiveCrawlEnabled(localClientNum, ps, hand) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4889, ASSERT_TYPE_ASSERT, "(IsAdditiveCrawlEnabled( localClientNum, ps, hand ))", (const char *)&queryFormat, "IsAdditiveCrawlEnabled( localClientNum, ps, hand )") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4891, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4893, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  for ( i = 0i64; i < 4; ++i )
  {
    Handler = CgHandler::getHandler(localClientNum);
    v12 = anim[i];
    if ( BG_ViewModelAnimExists(ps, (weapAnimFiles_t)v12, hand, Handler) )
    {
      Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v12);
      if ( *(float *)&Weight > 0.0 || (GoalTime = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, v12), blendOutSeconds < *(float *)&GoalTime) )
      {
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, animIndex[i], 0.0, blendOutSeconds, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v12, 0.0, blendOutSeconds, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
  }
}

/*
==============
CgWeaponSystem::StopPullbackSound
==============
*/
void CgWeaponSystem::StopPullbackSound(CgWeaponSystem *this, const int entNum)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  unsigned int lastPullbackId; 

  v2 = entNum;
  if ( entNum < cls.maxClients )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25077, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( (unsigned __int64)cls.maxClients > 0xC8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25079, ASSERT_TYPE_ASSERT, "( ( sizeof( *array_counter( cgameGlob->soundPlaybackCache.clients ) ) + 0 ) ) >= ( cls.maxClients )", "%s >= %s\n\t%i, %i", "ARRAY_COUNT( cgameGlob->soundPlaybackCache.clients )", "cls.maxClients", 200, cls.maxClients) )
      __debugbreak();
    lastPullbackId = LocalClientGlobals->soundPlaybackCache.clients[v2].lastPullbackId;
    if ( lastPullbackId )
      SND_StopSoundAliasAndSecondariesByAliasId(lastPullbackId, this->m_localClientNum, v2);
    LocalClientGlobals->soundPlaybackCache.clients[v2].lastPullbackId = 0;
  }
}

/*
==============
StopRecoilAnim
==============
*/
void StopRecoilAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, DObj *const obj)
{
  cg_t *LocalClientGlobals; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 
  char v8; 
  unsigned int v9; 
  unsigned int v10; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7068, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7069, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5970, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5976, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( &LocalClientGlobals->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5977, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
    __debugbreak();
  p_m_weaponAnimArrays = &LocalClientGlobals->m_weaponAnimArrays;
  if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5980, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( BG_UsingAlternate(ps) )
    p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
  v8 = 0;
  v9 = 412;
  v10 = 412;
  if ( p_m_weaponAnimArrays->normalAnimArray[176] )
  {
    v10 = 176;
    v8 = 1;
    v9 = 175;
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v9, 0.0, 0.15000001, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
  if ( v8 )
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v10, 0.0, 0.15000001, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
}

/*
==============
StoreShieldPersistentAnims
==============
*/
void StoreShieldPersistentAnims(const WeaponHand *weapHand, float *outAnimWeights, float *outAnimTimes, const XAnimParts **outShieldXParts)
{
  XAnimTree *tree; 
  bool v9; 
  unsigned int *v10; 
  signed __int64 v11; 
  signed __int64 v12; 
  XAnimTree *v13; 
  const XAnim_s *Anims; 
  const XAnimParts *Parts; 
  const XAnimParts *v16; 
  double Weight; 
  unsigned int v18; 
  double Time; 

  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10124, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !outAnimWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10125, ASSERT_TYPE_ASSERT, "(outAnimWeights)", (const char *)&queryFormat, "outAnimWeights") )
    __debugbreak();
  if ( !outAnimTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10126, ASSERT_TYPE_ASSERT, "(outAnimTimes)", (const char *)&queryFormat, "outAnimTimes") )
    __debugbreak();
  tree = weapHand->tree;
  v9 = tree && tree->anims;
  v10 = (unsigned int *)s_shieldPersistentAnims;
  v11 = (char *)outAnimWeights - (char *)s_shieldPersistentAnims;
  v12 = (char *)outAnimTimes - (char *)s_shieldPersistentAnims;
  do
  {
    *(unsigned int *)((char *)v10 + v11) = 0;
    *(unsigned int *)((char *)v10 + v12) = 0;
    *outShieldXParts = NULL;
    if ( v9 )
    {
      v13 = weapHand->tree;
      if ( (signed int)*v10 < (signed int)v13->anims->size )
      {
        Anims = XAnimGetAnims(v13);
        if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10148, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
          __debugbreak();
        Parts = XAnimGetParts(Anims, *v10);
        v16 = XAnimGetParts(Anims, 0xECu);
        if ( *v10 == 236 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10151, ASSERT_TYPE_ASSERT, "(s_shieldPersistentAnims[persistAnimIndex] != WEAP_ANIM_IDLE)", (const char *)&queryFormat, "s_shieldPersistentAnims[persistAnimIndex] != WEAP_ANIM_IDLE") )
          __debugbreak();
        if ( Parts )
        {
          if ( Parts != v16 )
          {
            Weight = XAnimGetWeight(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, *v10);
            v18 = *v10;
            *(unsigned int *)((char *)v10 + v11) = LODWORD(Weight);
            Time = XAnimGetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v18);
            *(unsigned int *)((char *)v10 + v12) = LODWORD(Time);
            *outShieldXParts = Parts;
          }
        }
      }
    }
    ++v10;
    ++outShieldXParts;
  }
  while ( (__int64)v10 < (__int64)&unk_1442D8E94 );
}

/*
==============
CgWeaponSystem::TryBulletScriptableImpact
==============
*/
void CgWeaponSystem::TryBulletScriptableImpact(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.hitEffect.targetEntityNum = targetEntityNum;
      QueueEntry->event.eventTriggerTime = triggerTime;
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_BulletScriptableImpact;
      QueueEntry->event.hitEffect.sourceEntityNum = inflictorEntNum;
      QueueEntry->event.bulletScriptableImpact.weapon = *weapon;
      QueueEntry->event.hitEffect.weapon.attachmentVariationIndices[25] = isAlternate;
      QueueEntry->event.bulletScriptableImpact.mod = mod;
      QueueEntry->event.bulletScriptableImpact.start = *start;
      QueueEntry->event.bulletScriptableImpact.hitPos = *hitPos;
      QueueEntry->event.bulletScriptableImpact.hitPartName = hitPartName;
      QueueEntry->valid = 1;
    }
  }
  else
  {
    CgWeaponSystem::BulletScriptableImpact(this, inflictorEntNum, targetEntityNum, weapon, isAlternate, mod, start, hitPos, hitPartName);
  }
}

/*
==============
CgWeaponSystem::TryCG_Glass_BreakGlass
==============
*/
void CgWeaponSystem::TryCG_Glass_BreakGlass(CgWeaponSystem *this, bool needsDeferring, LocalClientNum_t localClientNum, const vec3_t *cameraPosition, unsigned __int16 glassPieceIndex, const vec3_t *hitPosition, const vec3_t *hitDirection)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_BreakGlass;
      QueueEntry->event.hitEffect.sourceEntityNum = localClientNum;
      QueueEntry->event.hitEffect.targetEntityNum = LODWORD(cameraPosition->v[0]);
      QueueEntry->event.hitEffect.targetScriptableIndex = LODWORD(cameraPosition->v[1]);
      QueueEntry->event.hitEffect.knownHitClientNum = LODWORD(cameraPosition->v[2]);
      QueueEntry->event.hitEffect.weapon.weaponIdx = glassPieceIndex;
      QueueEntry->event.breakGlass.hitPosition = *hitPosition;
      QueueEntry->event.breakGlass.hitDirection = *hitDirection;
      QueueEntry->valid = 1;
    }
  }
  else
  {
    CG_Glass_BreakGlass(localClientNum, cameraPosition, glassPieceIndex, hitPosition, hitDirection);
  }
}

/*
==============
CgWeaponSystem::TryCG_LaserBeamAdd
==============
*/
void CgWeaponSystem::TryCG_LaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_LaserAdd;
      QueueEntry->event.hitEffect.sourceEntityNum = localClientNum;
      QueueEntry->event.hitEffect.targetEntityNum = LODWORD(start->v[0]);
      QueueEntry->event.hitEffect.targetScriptableIndex = LODWORD(start->v[1]);
      QueueEntry->event.hitEffect.knownHitClientNum = LODWORD(start->v[2]);
      QueueEntry->event.trackingLaserAdd.end = *end;
      QueueEntry->event.laserAdd.owner = owner;
      QueueEntry->event.laserAdd.weapon = *weapon;
      QueueEntry->event.trackingLaserAdd.weapon.attachmentVariationIndices[25] = isAlternate;
      QueueEntry->valid = 1;
    }
  }
  else
  {
    CG_LaserBeamAdd(localClientNum, start, end, owner, weapon, isAlternate, 0);
    if ( !owner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25250, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
      __debugbreak();
  }
}

/*
==============
CgWeaponSystem::TryCG_TrackingLaserBeamAdd
==============
*/
void CgWeaponSystem::TryCG_TrackingLaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate, const int shotIndex, const int trackedEntNum, const scr_string_t autoTargetEntTag, const vec3_t *tagOffset, const float aimSpreadAmount)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_TrackingLaserAdd;
      QueueEntry->event.hitEffect.sourceEntityNum = localClientNum;
      QueueEntry->event.hitEffect.targetEntityNum = LODWORD(start->v[0]);
      QueueEntry->event.hitEffect.targetScriptableIndex = LODWORD(start->v[1]);
      QueueEntry->event.hitEffect.knownHitClientNum = LODWORD(start->v[2]);
      QueueEntry->event.trackingLaserAdd.end = *end;
      QueueEntry->event.trackingLaserAdd.owner = owner;
      QueueEntry->event.trackingLaserAdd.weapon = *weapon;
      QueueEntry->event.trackingLaserAdd.isAlternate = isAlternate;
      QueueEntry->event.trackingLaserAdd.shotIndex = shotIndex;
      QueueEntry->event.trackingLaserAdd.trackedEntNum = trackedEntNum;
      QueueEntry->event.spawnTracer.spawnDelay = autoTargetEntTag;
      QueueEntry->event.trackingLaserAdd.tagOffset = *tagOffset;
      QueueEntry->event.hitEffect.normal.v[2] = aimSpreadAmount;
      QueueEntry->valid = 1;
    }
  }
  else
  {
    CG_TrackingLaserBeamAdd(localClientNum, start, end, owner, weapon, isAlternate, shotIndex, trackedEntNum, autoTargetEntTag, tagOffset, aimSpreadAmount, 0);
    if ( !owner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25250, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
      __debugbreak();
  }
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_HitEffect
==============
*/
void CgWeaponSystem::TrySimulateBulletFire_HitEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.hitEffect.targetEntityNum = targetEntityNum;
      QueueEntry->event.hitEffect.targetScriptableIndex = targetScriptableIndex;
      QueueEntry->event.eventTriggerTime = triggerTime;
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_HitEffect;
      QueueEntry->event.hitEffect.sourceEntityNum = sourceEntityNum;
      QueueEntry->event.hitEffect.knownHitClientNum = knownHitClientNum;
      QueueEntry->event.hitEffect.weapon = *weapon;
      QueueEntry->event.hitEffect.isAlternate = isAlternate;
      QueueEntry->event.hitEffect.initialShootingPos = *initialShootingPos;
      QueueEntry->event.hitEffect.startPos = *startPos;
      QueueEntry->event.hitEffect.position = *position;
      QueueEntry->event.hitEffect.normal = *normal;
      QueueEntry->event.hitEffect.surfType = surfType;
      QueueEntry->event.hitEffect.meansOfDeath = meansOfDeath;
      QueueEntry->event.hitEffect.impactEffects = impactEffects;
      QueueEntry->event.hitEffect.hitContents = hitContents;
      QueueEntry->event.hitEffect.forceClientSideHandling = forceClientSideHandling;
      QueueEntry->valid = 1;
    }
  }
  else
  {
    this->SimulateBulletFire_HitEffect(this, sourceEntityNum, targetEntityNum, targetScriptableIndex, knownHitClientNum, weapon, isAlternate, initialShootingPos, startPos, position, normal, surfType, meansOfDeath, impactEffects, hitContents, forceClientSideHandling);
  }
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_MissEffect
==============
*/
void CgWeaponSystem::TrySimulateBulletFire_MissEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.eventTriggerTime = triggerTime;
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_MissEffect;
      QueueEntry->event.hitEffect.sourceEntityNum = sourceEntityNum;
      QueueEntry->event.missEffect.weapon = *weapon;
      QueueEntry->event.hitEffect.weapon.attachmentVariationIndices[21] = isAlternate;
      QueueEntry->event.missEffect.initialShootingPos = *initialShootingPos;
      QueueEntry->event.hitEffect.initialShootingPos = *startPos;
      QueueEntry->event.hitEffect.startPos = *position;
      QueueEntry->event.missEffect.surfType = surfType;
      QueueEntry->valid = 1;
    }
  }
  else
  {
    this->SimulateBulletFire_MissEffect(this, sourceEntityNum, weapon, isAlternate, initialShootingPos, startPos, position, surfType);
  }
}

/*
==============
CgWeaponSystem::TrySpawnTracer
==============
*/
void CgWeaponSystem::TrySpawnTracer(CgWeaponSystem *this, const int bulletId, bool needsDeferring, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *v16; 
  scr_string_t FallbackTagName; 
  const vec3_t *v18; 
  float v19; 
  const vec3_t *v20; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    v16 = QueueEntry;
    if ( QueueEntry )
    {
      QueueEntry->event.hitEffect.targetScriptableIndex = inflictorEntNum;
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_SpawnTracer;
      QueueEntry->event.hitEffect.sourceEntityNum = bulletId;
      QueueEntry->event.spawnTracer.blendFromViewmodel = blendFromViewmodel;
      QueueEntry->event.spawnTracer.inflictorPerks = *r_inflictorPerks;
      QueueEntry->event.spawnTracer.hand = hand;
      QueueEntry->event.spawnTracer.sourcePrimaryTagName = TagPair::GetPrimaryTagName((TagPair *)&sourceTagPair);
      FallbackTagName = TagPair::GetFallbackTagName((TagPair *)&sourceTagPair);
      v18 = tracerStart;
      v16->event.spawnTracer.sourceFallbackTagName = FallbackTagName;
      v16->event.trackingLaserAdd.tagOffset.v[1] = v18->v[0];
      v16->event.trackingLaserAdd.tagOffset.v[2] = v18->v[1];
      v19 = v18->v[2];
      v20 = tracerEnd;
      v16->event.breakGlass.hitDirection.v[2] = v19;
      v16->event.spawnTracer.tracerEnd = *v20;
      v16->event.spawnTracer.r_weapon = *r_weapon;
      v16->event.spawnTracer.isAlternate = isAlternate;
      v16->event.spawnTracer.spawnDelay = spawnDelay;
      v16->valid = 1;
    }
  }
  else
  {
    CgWeaponSystem::SpawnTracer(this, bulletId, blendFromViewmodel, inflictorEntNum, r_inflictorPerks, hand, sourceTagPair, tracerStart, tracerEnd, r_weapon, isAlternate, spawnDelay);
  }
}

/*
==============
MovementAnimState::Update
==============
*/
void MovementAnimState::Update(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps)
{
  MovementAnimState::State newGoal; 
  bool IsSuperSprinting; 
  bool v10; 
  bool IsJogging; 

  if ( !this->m_isInitialized )
    MovementAnimState::Reset(this, localClientNum, hand);
  newGoal = NONE;
  if ( this->m_goal == -1 )
    MovementAnimState::UpdateInternal(this, localClientNum, hand, ps, NONE);
  if ( !MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
  {
    IsSuperSprinting = BG_IsSuperSprinting(ps);
    v10 = !IsSuperSprinting && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u);
    IsJogging = CG_IsJogging(localClientNum);
    if ( IsSuperSprinting )
    {
      newGoal = LONG;
    }
    else if ( v10 )
    {
      newGoal = HALF_HALF;
    }
    else
    {
      LOBYTE(newGoal) = IsJogging;
    }
  }
  MovementAnimState::UpdateInternal(this, localClientNum, hand, ps, newGoal);
}

/*
==============
UpdateAdditiveCrawlAnims
==============
*/
void UpdateAdditiveCrawlAnims(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj, const PlayerHandIndex hand)
{
  const dvar_t *v4; 
  float goalTime; 
  const dvar_t *v10; 
  float value; 
  XAnimTree *Tree; 
  cg_t *LocalClientGlobals; 
  double v14; 
  float v15; 
  __int128 v16; 
  __int128 v17; 
  __int128 v18; 
  float v19; 
  float v20; 
  float v21; 
  __int128 v22; 
  __int128 v23; 
  __int128 v24; 
  __int128 v25; 
  __int128 v26; 
  __int128 v27; 
  __int128 v28; 
  __int128 v29; 
  __int128 v33; 
  const dvar_t *v35; 
  __int128 rate; 
  double Weight; 
  double v39; 
  int firstProneCrawlLoopTime; 
  int time; 
  float v42; 
  float v43; 
  float v44; 
  const dvar_t *v46; 
  float v47; 
  double BobCycleAnimTime; 
  float v49; 
  cg_t *v51; 
  float prevProneForwardAnimTime; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  float v57; 
  float v58; 
  CgHandler *Handler; 
  float v60; 
  CgHandler *v61; 
  double v63; 
  BobCycle v64; 
  __int64 v65; 
  vec3_t forward; 
  vec3_t right; 

  v4 = DCONST_DVARINT_cg_crawlBlendTime;
  if ( !DCONST_DVARINT_cg_crawlBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  goalTime = (float)v4->current.integer * 0.001;
  if ( goalTime <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4752, ASSERT_TYPE_ASSERT, "(CRAWL_BLEND_SECONDS > 0.0f)", (const char *)&queryFormat, "CRAWL_BLEND_SECONDS > 0.0f") )
    __debugbreak();
  v10 = DCONST_DVARFLT_bg_crawlMaxSpeed;
  if ( !DCONST_DVARFLT_bg_crawlMaxSpeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_crawlMaxSpeed") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  value = v10->current.value;
  if ( value <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4754, ASSERT_TYPE_ASSERT, "(CRAWL_MAX_SPEED > 0.0f)", (const char *)&queryFormat, "CRAWL_MAX_SPEED > 0.0f") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4771, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4772, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !IsAdditiveCrawlEnabled(localClientNum, ps, hand) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4773, ASSERT_TYPE_ASSERT, "(IsAdditiveCrawlEnabled( localClientNum, ps, hand ))", (const char *)&queryFormat, "IsAdditiveCrawlEnabled( localClientNum, ps, hand )") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4776, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1145, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v14 = MSG_UnpackUnsignedFloat(ps->moveSpeedScaleMultiplier, 5.0, 0xCu);
  if ( *(float *)&v14 <= 0.0 )
    v15 = 1.0 / value;
  else
    v15 = 1.0 / (float)(*(float *)&v14 * value);
  AngleVectors(&ps->viewangles, &forward, &right, NULL);
  v16 = LODWORD(ps->velocity.v[0]);
  v18 = v16;
  *(float *)&v18 = *(float *)&v16 * forward.v[0];
  v17 = v18;
  v19 = ps->velocity.v[1];
  v20 = v19 * forward.v[1];
  v21 = ps->velocity.v[2];
  v23 = LODWORD(v19);
  *(float *)&v23 = v19 * right.v[1];
  v22 = v23;
  v24 = v17;
  *(float *)&v24 = (float)((float)(*(float *)&v17 + v20) + (float)(v21 * forward.v[2])) * v15;
  v25 = v24;
  v26 = v22;
  *(float *)&v26 = (float)((float)(*(float *)&v22 + (float)(*(float *)&v16 * right.v[0])) + (float)(v21 * right.v[2])) * v15;
  v27 = v26;
  *(double *)&v25 = I_fclamp(*(float *)&v25, -1.0, 1.0);
  v28 = v25;
  *(double *)&v25 = I_fclamp(*(float *)&v26, -1.0, 1.0);
  v29 = v28;
  *(float *)&v29 = fsqrt((float)((float)(*(float *)&v28 * *(float *)&v28) * 16.0) + (float)(*(float *)&v25 * *(float *)&v25));
  _XMM4 = v29;
  __asm
  {
    vcmpless xmm1, xmm4, cs:__real@80000000
    vblendvps xmm1, xmm4, xmm8, xmm1
  }
  v33 = LODWORD(FLOAT_1_0);
  *(float *)&v33 = (float)(1.0 / *(float *)&_XMM1) * *(float *)&v25;
  _XMM11 = v33;
  UpdateAdditiveCrawlBlend(LocalClientGlobals->frametime, *(float *)&v28, &LocalClientGlobals->crawlForwardBlend);
  UpdateAdditiveCrawlBlend(LocalClientGlobals->frametime, *(float *)&v33, &LocalClientGlobals->crawlRightBlend);
  v35 = DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled;
  if ( !DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_crawl_vm_left_right_blend_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v35);
  if ( v35->current.enabled )
  {
    LODWORD(rate) = LODWORD(LocalClientGlobals->crawlForwardBlend) & _xmm;
  }
  else
  {
    _XMM6 = v27 & (unsigned int)_xmm;
    __asm { vmaxss  xmm6, xmm6, xmm9 }
  }
  Weight = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Cu);
  if ( *(float *)&Weight != 1.0 )
  {
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Bu, 1.0, goalTime, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Cu, 1.0, goalTime, *(float *)&rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Cu, *(float *)&rate);
  v39 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Cu);
  if ( *(float *)&v39 >= 0.5 )
  {
    firstProneCrawlLoopTime = LocalClientGlobals->firstProneCrawlLoopTime;
    time = LocalClientGlobals->time;
    v42 = (float)(*(float *)&v39 - 0.5) * 2.0;
    v43 = v42;
    if ( firstProneCrawlLoopTime == -1 )
    {
      LocalClientGlobals->firstProneCrawlLoopTime = time;
      firstProneCrawlLoopTime = time;
    }
    v44 = goalTime - (float)((float)(time - firstProneCrawlLoopTime) * 0.001);
    _XMM1 = 0i64;
    I_fclamp(v44, 0.0, 1.0);
    v46 = DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled;
    v47 = v44;
    if ( !DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_crawl_vm_left_right_blend_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v46);
    if ( v46->current.enabled )
      _XMM11 = LODWORD(LocalClientGlobals->crawlRightBlend);
    BobCycleAnimTime = BG_GetBobCycleAnimTime((const int (*)[2])ps->packedBobCycle);
    v49 = *(float *)&BobCycleAnimTime;
    BobCycle::UnpackBobCycle(&v64, (const int (*)[2])ps->packedBobCycle);
    v65 = *(__int64 *)&v64.amplitudeRatioGun;
    if ( *(float *)&BobCycleAnimTime < 0.0 || *(float *)&BobCycleAnimTime > 1.0 )
    {
      __asm { vxorpd  xmm1, xmm1, xmm1 }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4688, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( animTime ) && ( animTime ) <= ( 1.0f )", "animTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", *(float *)&BobCycleAnimTime, *(double *)&_XMM1, DOUBLE_1_0) )
        __debugbreak();
    }
    v51 = CG_GetLocalClientGlobals(localClientNum);
    if ( !v51 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4691, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    prevProneForwardAnimTime = v51->prevProneForwardAnimTime;
    v53 = 0.0;
    if ( prevProneForwardAnimTime != -1.0 )
    {
      if ( (prevProneForwardAnimTime < 0.0 || prevProneForwardAnimTime >= 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4697, ASSERT_TYPE_ASSERT, "(0.0f <= cgameGlob->prevProneForwardAnimTime && cgameGlob->prevProneForwardAnimTime < 1.0f)", (const char *)&queryFormat, "0.0f <= cgameGlob->prevProneForwardAnimTime && cgameGlob->prevProneForwardAnimTime < 1.0f") )
        __debugbreak();
      v54 = v51->prevProneForwardAnimTime;
      v55 = v54;
      if ( BYTE4(v65) )
      {
        if ( v49 > v54 )
          v55 = v54 + 1.0;
      }
      else if ( v49 < v54 )
      {
        v55 = v54 - 1.0;
      }
      LODWORD(v53) = COERCE_UNSIGNED_INT(v49 - v55) & _xmm;
    }
    v51->prevProneForwardAnimTime = v49;
    if ( *(float *)&_XMM11 >= 0.0 )
    {
      if ( *(float *)&_XMM11 <= 0.0 )
        goto LABEL_72;
      v58 = v53 + v51->prevProneLeftRightAnimTime;
      v51->prevProneLeftRightAnimTime = v58;
      if ( v58 < 1.0 )
        goto LABEL_72;
      v57 = v58 - 1.0;
    }
    else
    {
      v56 = v51->prevProneLeftRightAnimTime - v53;
      v51->prevProneLeftRightAnimTime = v56;
      if ( v56 >= 0.0 )
      {
LABEL_72:
        Handler = CgHandler::getHandler(localClientNum);
        if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_CRAWL_LOOP_LEFT, hand, Handler) )
        {
          if ( *(float *)&_XMM11 >= 0.0 )
            v60 = 0.0;
          else
            LODWORD(v60) = _XMM11 ^ _xmm;
          v43 = v42 - (float)(v60 * v42);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Fu, v60 * v42, v47, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x70u, v60 * v42, v47, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x70u, LocalClientGlobals->prevProneLeftRightAnimTime);
        }
        v61 = CgHandler::getHandler(localClientNum);
        if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_CRAWL_LOOP_RIGHT, hand, v61) )
        {
          __asm { vmaxss  xmm0, xmm11, xmm7 }
          v43 = v43 - (float)(*(float *)&_XMM0 * v42);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x71u, *(float *)&_XMM0 * v42, v47, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x72u, *(float *)&_XMM0 * v42, v47, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x72u, LocalClientGlobals->prevProneLeftRightAnimTime);
        }
        v63 = I_fclamp(v43, 0.0, 1.0);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Du, *(float *)&v63, v47, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Eu, v43, v47, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Eu, v49);
        return;
      }
      v57 = v56 + 1.0;
    }
    v51->prevProneLeftRightAnimTime = v57;
    goto LABEL_72;
  }
}

/*
==============
UpdateAdditiveCrawlBlend
==============
*/
void UpdateAdditiveCrawlBlend(int timeMs, float right, float *inOutRightBlended)
{
  float v5; 
  const dvar_t *v6; 
  float v7; 

  v5 = right;
  if ( (right < -1.0 || right > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4734, ASSERT_TYPE_ASSERT, "( -1.0f ) <= ( right ) && ( right ) <= ( 1.0f )", "right not in [-1.0f, 1.0f]\n\t%g not in [%g, %g]", right, *(double *)&_xmm, *((double *)&_xmm + 1)) )
    __debugbreak();
  if ( !inOutRightBlended && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4735, ASSERT_TYPE_ASSERT, "(inOutRightBlended)", (const char *)&queryFormat, "inOutRightBlended") )
    __debugbreak();
  if ( timeMs > 0 )
  {
    v6 = DCONST_DVARINT_cg_crawlBlendDirTime;
    if ( !DCONST_DVARINT_cg_crawlBlendDirTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendDirTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    v7 = (float)v6->current.integer / (float)timeMs;
    if ( v7 > 1.0 )
      v5 = (float)(*inOutRightBlended - (float)((float)(1.0 / v7) * *inOutRightBlended)) + (float)((float)(1.0 / v7) * right);
    *inOutRightBlended = v5;
  }
}

/*
==============
MovementAnimState::UpdateInternal
==============
*/
void MovementAnimState::UpdateInternal(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps, const MovementAnimState::State newGoal)
{
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  const DObj **p_viewModelDObj; 
  XAnimTree *Tree; 
  MovementAnimState::State v12; 
  unsigned __int32 v13; 
  MovementAnimState::State m_goal; 
  const XAnimParts *const *normalAnimArray; 
  float v16; 
  weapAnimFiles_t v17; 
  unsigned int m_cycleAnim; 
  int v19; 
  float v20; 
  double Time; 
  weapAnimFiles_t OffsetAnimation; 
  double Float_Internal_DebugName; 
  float outTransDurationSec; 
  float outBlendTime; 
  float outNextRate; 
  weapAnimFiles_t outNextAnim; 
  float outCycleTransDurationSec; 

  v6 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v6 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, 2) )
    __debugbreak();
  p_viewModelDObj = (const DObj **)&LocalClientGlobals->m_weaponHand[v6].viewModelDObj;
  if ( (cg_t *)((char *)LocalClientGlobals + 40 * v6) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5431, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( *p_viewModelDObj )
  {
    Tree = DObjGetTree(*p_viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5439, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5440, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    v12 = newGoal;
    v13 = this->m_offsetAnim - 50;
    if ( newGoal == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5444, ASSERT_TYPE_ASSERT, "(newGoal != State::NONE)", (const char *)&queryFormat, "newGoal != State::NONE") )
      __debugbreak();
    m_goal = this->m_goal;
    if ( this->m_goal != v12 )
    {
      outTransDurationSec = 0.0;
      outCycleTransDurationSec = 0.0;
      MovementAnimState::GetTransitionDuration(this, localClientNum, ps, m_goal, v12, &outTransDurationSec, &outCycleTransDurationSec);
      normalAnimArray = (const XAnimParts *const *)LocalClientGlobals->m_weaponAnimArrays.normalAnimArray;
      if ( BG_UsingAlternate(ps) )
        normalAnimArray += 622;
      MovementAnimState::CalcOffsetTransitionParams(this, localClientNum, Tree, normalAnimArray, (const MovementAnimState::State)this->m_goal, v12, (const weapAnimFiles_t)this->m_offsetAnim, &outNextAnim, &outBlendTime, &outTransDurationSec, &outNextRate);
      v16 = outBlendTime;
      XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, this->m_offsetAnim, 0.0, outBlendTime, outTransDurationSec, (scr_string_t)0, 0, 0, LINEAR, NULL);
      v17 = outNextAnim;
      XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, outNextAnim, 1.0, v16, outNextRate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      m_cycleAnim = this->m_cycleAnim;
      if ( v12 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5781, ASSERT_TYPE_ASSERT, "(state != State::NONE)", (const char *)&queryFormat, "state != State::NONE") )
        __debugbreak();
      if ( v12 )
      {
        switch ( v12 )
        {
          case HALF:
            v19 = 64;
            goto LABEL_31;
          case HALF_HALF:
            v19 = 65;
            goto LABEL_31;
          case LONG:
            v19 = 66;
LABEL_31:
            v20 = outCycleTransDurationSec;
            XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, m_cycleAnim, 0.0, outCycleTransDurationSec, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
            XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v19, 1.0, v20, 0.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
            this->m_goal = v12;
            this->m_offsetAnim = v17;
            this->m_cycleAnim = v19;
            return;
        }
      }
      v19 = 63;
      goto LABEL_31;
    }
    if ( v13 <= 0xB )
    {
      Time = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, this->m_offsetAnim);
      if ( *(float *)&Time >= 1.0 )
      {
        OffsetAnimation = MovementAnimState::GetOffsetAnimation(this, (const MovementAnimState::State)this->m_goal);
        Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARMPFLT_movementAnimProto_TransitionBlendTime, "movementAnimProto_TransitionBlendTime");
        XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, this->m_offsetAnim, 0.0, *(float *)&Float_Internal_DebugName, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, OffsetAnimation, 1.0, *(float *)&Float_Internal_DebugName, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
        this->m_offsetAnim = OffsetAnimation;
      }
    }
  }
}

/*
==============
UpdateMovementAnimWeightRoot
==============
*/
float UpdateMovementAnimWeightRoot(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int128 v4; 
  CgWeaponMap *Instance; 
  bool v10; 
  double v14; 
  const SuitDef *SuitDef; 
  const SuitDef *v16; 
  float viewHeightCurrent; 
  int viewheight_crouch; 
  float v19; 
  float v20; 
  int viewheight_stand; 
  float v22; 
  double v23; 
  float outStartFrac[4]; 
  float outEndFrac; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5240, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_Skydive_IsSkydiving(ps) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 6u) || BG_Gesture_IsGestureTypePlaying(ps, GESTURE_TYPE_IK_TARGET) )
  {
    LODWORD(v23) = 0;
    return *(float *)&v23;
  }
  Instance = CgWeaponMap::GetInstance(localClientNum);
  if ( BG_IsUsingOffhandGestureWeaponADSSupport(Instance, ps) )
  {
    *(double *)&v4 = BG_GetOffhandAdsFrac(ps);
    _XMM8 = v4;
    weapon = BG_GetOffhandGestureWeapon(Instance, ps);
    v10 = 0;
  }
  else
  {
    v10 = BG_UsingAlternate(ps);
    _XMM8 = LODWORD(ps->weapCommon.fWeaponPosFrac);
  }
  BG_ADSMovementAnimBlendFrac(weapon, v10, outStartFrac, &outEndFrac);
  _XMM7 = 0i64;
  if ( outEndFrac > 0.0 )
  {
    if ( (float)(outEndFrac - outStartFrac[0]) > 0.0 )
    {
      v14 = I_fclamp((float)(*(float *)&_XMM8 - outStartFrac[0]) / (float)(outEndFrac - outStartFrac[0]), 0.0, 1.0);
      *(float *)&_XMM9 = 1.0 - *(float *)&v14;
    }
    else
    {
      __asm
      {
        vcmpltss xmm0, xmm8, xmm1
        vblendvps xmm9, xmm7, xmm6, xmm0
      }
    }
  }
  else
  {
    LODWORD(_XMM9) = 0;
  }
  SuitDef = BG_GetSuitDef(ps->suitIndex);
  v16 = SuitDef;
  if ( !SuitDef )
    goto LABEL_23;
  viewHeightCurrent = ps->viewHeightCurrent;
  if ( viewHeightCurrent < (float)BG_Suit_GetProneViewHeight(SuitDef) )
    goto LABEL_23;
  viewheight_crouch = v16->viewheight_crouch;
  if ( viewHeightCurrent >= (float)viewheight_crouch )
  {
    viewheight_stand = v16->viewheight_stand;
    if ( viewHeightCurrent < (float)viewheight_stand )
    {
      v22 = (float)(viewheight_stand - viewheight_crouch);
      if ( v22 > 0.000001 )
      {
        v20 = 1.0 - (float)((float)(1.0 - (float)((float)(viewHeightCurrent - (float)viewheight_crouch) / v22)) * (float)(1.0 - *(float *)&dword_147FA827C));
        goto LABEL_24;
      }
    }
LABEL_23:
    v20 = FLOAT_1_0;
    goto LABEL_24;
  }
  v19 = (float)(v16->viewheight_crouch - BG_Suit_GetProneViewHeight(v16));
  if ( v19 <= 0.000001 )
    goto LABEL_23;
  v20 = 1.0 - (float)((float)(1.0 - *(float *)&dword_147FA827C) * (float)((float)(viewHeightCurrent - (float)BG_Suit_GetProneViewHeight(v16)) / v19));
LABEL_24:
  v23 = I_fclamp(v20 * *(float *)&_XMM9, 0.0, 1.0);
  return *(float *)&v23;
}

/*
==============
ViewModelScriptedStateChanged
==============
*/
bool ViewModelScriptedStateChanged(LocalClientNum_t localClientNum, const playerState_s *ps)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9922, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9923, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return LocalClientGlobals->viewModelAnimScriptedInfo.lastScriptedAnimStartTime != ps->viewModelAnimScripted.animStartTime || LocalClientGlobals->viewModelAnimScriptedInfo.lastAnimIndex != ps->viewModelAnimScripted.animIndex;
}

/*
==============
WeaponAnimBlendMeleeMisprediction
==============
*/
__int64 WeaponAnimBlendMeleeMisprediction(const playerState_s *ps, DObj *obj, weapAnimFiles_t animIndex, float animRate, weapAnimFiles_t prevAnimIndex, int prevMeleeStartTime)
{
  XAnimTree *Tree; 
  double Length; 
  float v12; 
  double v13; 
  float rate; 
  double Time; 
  float v16; 
  float v18; 
  float v19; 
  float v20; 
  double v21; 
  float v22; 
  __int128 v24; 
  double Float_Internal_DebugName; 
  __int128 goalTime; 
  const XAnimParts *Parts; 
  const XAnimParts *v30; 

  if ( BG_IsMeleeAnim(prevAnimIndex) && BG_IsMeleeAnim(animIndex) && prevMeleeStartTime == ps->meleeStartTime )
  {
    if ( prevAnimIndex == animIndex )
      return 1i64;
    Tree = DObjGetTree(obj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1619, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( (prevAnimIndex - 262) / 3 != (animIndex - 262) / 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1626, ASSERT_TYPE_ASSERT, "( prevMeleeSet ) == ( meleeSet )", "%s == %s\n\t%i, %i", "prevMeleeSet", "meleeSet", (prevAnimIndex - 262) / 3, (animIndex - 262) / 3) )
      __debugbreak();
    Length = XAnimGetLength(Tree->anims, prevAnimIndex);
    v12 = *(float *)&Length;
    v13 = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
    rate = *(float *)&v13;
    Time = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
    v16 = *(float *)&Time;
    if ( *(float *)&Time > 0.0 )
    {
      __asm { vxorpd  xmm13, xmm13, xmm13 }
      if ( rate <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1638, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( prevAnimRate )", "%s < %s\n\t%g, %g", "0.0f", "prevAnimRate", *(double *)&_XMM13, rate) )
        __debugbreak();
      if ( rate > 0.00000011920929 )
        v12 = v12 / rate;
      if ( (*(float *)&Time < 0.0 || *(float *)&Time > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1640, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( prevAnimTime ) && ( prevAnimTime ) <= ( 1.0f )", "prevAnimTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", *(float *)&Time, *(double *)&_XMM13, DOUBLE_1_0) )
        __debugbreak();
      v19 = v12 * *(float *)&Time;
      v18 = v12 * *(float *)&Time;
      XAnimGetLength(Tree->anims, animIndex);
      v20 = v12 - (float)(v12 * v16);
      if ( animRate <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1647, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animRate )", "%s < %s\n\t%g, %g", "0.0f", "animRate", *(double *)&_XMM13, animRate) )
        __debugbreak();
      if ( animRate > 0.00000011920929 )
        v20 = v20 / animRate;
      v21 = I_fclamp(v18 / v20, 0.0, 1.0);
      v22 = v19 / v20;
      if ( *(float *)&v21 < 1.0 )
      {
        if ( (unsigned int)(ps->weapState[0].weaponState - 22) > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1663, ASSERT_TYPE_ASSERT, "(( (ps->weapState[WEAPON_HAND_DEFAULT].weaponState == WEAPON_MELEE) || (ps->weapState[WEAPON_HAND_DEFAULT].weaponState == WEAPON_MELEE_FATAL) || (ps->weapState[WEAPON_HAND_DEFAULT].weaponState == WEAPON_MELEE_END) ))", (const char *)&queryFormat, "WEAPONSTATE_MELEE( ps->weapState[WEAPON_HAND_DEFAULT].weaponState )") )
          __debugbreak();
        v24 = 0i64;
        *(float *)&v24 = (float)ps->weapState[0].weaponTime * 0.001;
        _XMM8 = v24;
        Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_melee_mispredictBlendDurationMinimum, "melee_mispredictBlendDurationMinimum");
        if ( *(float *)&v24 >= *(float *)&Float_Internal_DebugName && *(float *)&v24 > 0.00000011920929 )
        {
          if ( (v22 < 0.0 || v22 > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1671, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( animTime ) && ( animTime ) <= ( 1.0f )", "animTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", v22, *(double *)&_XMM13, DOUBLE_1_0) )
            __debugbreak();
          if ( *(float *)&v24 <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1672, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animDurationRemainingS )", "%s < %s\n\t%g, %g", "0.0f", "animDurationRemainingS", *(double *)&_XMM13, *(float *)&v24) )
            __debugbreak();
          *((_QWORD *)&_XMM0 + 1) = 0i64;
          *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_melee_mispredictBlendDuration, "melee_mispredictBlendDuration");
          __asm
          {
            vminss  xmm1, xmm8, [rsp+138h+var_D8]
            vminss  xmm8, xmm0, xmm1
          }
          Parts = XAnimGetParts(Tree->anims, prevAnimIndex);
          v30 = XAnimGetParts(Tree->anims, animIndex);
          Com_PrintWarning(17, "Melee result misprediction:\n\t'%s' t:%.2f r:%.2f bo:%.2f\n\t'%s' t:%.2f r:%.2f bi:%.2f\n", Parts->name, v16, rate, *(float *)&goalTime, v30->name, v22, animRate, *(float *)&goalTime);
          if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1688, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex, 0.0, *(float *)&goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, animIndex, 1.0, *(float *)&goalTime, (float)(1.0 - v22) / *(float *)&v24, (scr_string_t)0, 1u, 1, LINEAR, NULL);
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, animIndex, v22);
        }
      }
      return 1i64;
    }
  }
  return 0i64;
}

/*
==============
WeaponCycleAllowed
==============
*/
bool WeaponCycleAllowed(cg_t *cgameGlob)
{
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v4; 
  CgWeaponMap *v5; 
  const Weapon *v6; 
  CgHandler *Handler; 
  CgWeaponMap *v8; 
  bool v9; 
  bool v10; 
  int v11; 
  CgWeaponMap *v12; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16049, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( BG_Skydive_IsSkydiving(&cgameGlob->predictedPlayerState) )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x10u) )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0xFu) )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 6u) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xAu) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xEu) )
    return 0;
  if ( (unsigned int)(cgameGlob->predictedPlayerState.weapState[0].weaponState - 40) <= 3 )
    return 0;
  if ( BG_IsUsingOffhandGestureWeapon(&cgameGlob->predictedPlayerState) && (cgameGlob->predictedPlayerState.weapCommon.offhandGestureFlags & 8) == 0 )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &cgameGlob->predictedPlayerState);
    v4 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
    if ( !BG_AllowWeaponSwitchWhileHoldingGrenade(CurrentWeaponForPlayer, v4) )
      return 0;
  }
  v5 = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  v6 = BG_GetCurrentWeaponForPlayer(v5, &cgameGlob->predictedPlayerState);
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  v8 = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  LOBYTE(Handler) = PM_Weapon_IsInInterruptibleState(v8, &cgameGlob->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler);
  v9 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
  v10 = BG_IsForceUseWeapon(v6, v9) != 0;
  if ( !(_BYTE)Handler && v10 )
    return 0;
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.otherFlags, ACTIVE, 1u) )
    return 0;
  v11 = CL_Input_IsGamepadEnabled(cgameGlob->localClientNum) ? Dvar_GetInt_Internal_DebugName(DVARINT_cg_weaponCycleDelay, "cg_weaponCycleDelay") : GamerProfile_GetWeaponSwitchCancelDelay(cgameGlob->localClientNum);
  if ( cgameGlob->time - cgameGlob->weaponSelectTime < v11 )
    return 0;
  if ( cgameGlob->time < cgameGlob->weaponForcedSelectTime )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) )
  {
    v12 = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    if ( !Slide_CanSwitchWeapons(cgameGlob->localClientNum, v12, &cgameGlob->predictedPlayerState) )
      return 0;
  }
  return BG_IsPlayer(&cgameGlob->predictedPlayerState) && !cgameGlob->IsClientGamePaused(cgameGlob) && !BG_IsTurretActive(&cgameGlob->predictedPlayerState) && !BG_IsVehicleActive(&cgameGlob->predictedPlayerState);
}

/*
==============
WeaponRunOverrideAnims
==============
*/
void WeaponRunOverrideAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex, int curAnim, const Weapon *weapon, bool isAlternate, const bool raiseToIdle)
{
  __int64 v9; 
  cg_t *LocalClientGlobals; 
  unsigned int v12; 
  const DObj *viewModelDObj; 
  CgHandler *Handler; 
  unsigned int v15; 
  float rate; 
  CgHandler *v17; 
  float v18; 
  unsigned int notifyType; 

  v9 = handIndex;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v9 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v9, 2) )
    __debugbreak();
  v12 = curAnim & 0xFFFFFF7F;
  viewModelDObj = LocalClientGlobals->m_weaponHand[v9].viewModelDObj;
  if ( !isAlternate || !raiseToIdle && v12 - 22 <= 5 )
  {
    rate = FLOAT_1_0;
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1A6u, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    v15 = 332;
LABEL_11:
    notifyType = 0;
    v18 = 0.0;
    goto LABEL_12;
  }
  Handler = CgHandler::getHandler(localClientNum);
  v15 = 332;
  rate = FLOAT_1_0;
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ALT_OVERRIDE, (PlayerHandIndex)v9, Handler) )
  {
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x14Cu, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 0, LINEAR, NULL);
    v17 = CgHandler::getHandler(localClientNum);
    v15 = 422;
    if ( !BG_ViewModelAnimExists(ps, WEAP_ALT_ANIM_ADJUST, (PlayerHandIndex)v9, v17) )
      goto LABEL_11;
  }
  v18 = FLOAT_1_0;
  notifyType = 1;
LABEL_12:
  XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v15, v18, 0.0, rate, (scr_string_t)0, notifyType, 0, LINEAR, NULL);
}

/*
==============
WeaponRunXModelAnims
==============
*/
void WeaponRunXModelAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex)
{
  __int64 v3; 
  __int64 v5; 
  DObj *viewModelDObj; 
  CgWeaponMap *v7; 
  bool v8; 
  CgHandler *Handler; 
  bool v10; 
  bool isAiming; 
  int v12; 
  bool v13; 
  CgHandler *v14; 
  BOOL IsSwimWeapon; 
  bool v16; 
  XAnimTree *v17; 
  WeaponAnimNumber v18; 
  CgHandler *v19; 
  int v20; 
  WeaponHand *v21; 
  Weapon *p_prevViewmodelWeapon; 
  bool v23; 
  float value; 
  int v25; 
  cg_t *LocalClientGlobals; 
  unsigned int v27; 
  const WeaponAnimNumber *v28; 
  float v29; 
  CgWeaponMap *Instance; 
  bool v31; 
  float v32; 
  double v33; 
  double v34; 
  const dvar_t *v35; 
  char v36; 
  int v37; 
  int v38; 
  signed int VMRelativeAnimIndex; 
  signed int v40; 
  CgHandler *v41; 
  double Time; 
  int v43; 
  cg_t *v44; 
  DObj *v45; 
  CgHandler *v46; 
  unsigned int AdsUpAnim; 
  DObj *v48; 
  unsigned int AdsDownAnim; 
  DObj *v50; 
  double Weight; 
  const dvar_t *v52; 
  bool v53; 
  cg_t *v54; 
  DObj *v55; 
  int v56; 
  WeaponHand *v57; 
  WeaponAnimNumber isInterruptible; 
  bool v59; 
  char v60; 
  bool v61; 
  bool IsSprintAdditive; 
  char v63; 
  int weaponAnim; 
  int animState; 
  bool enabled; 
  weapAnimFiles_t prevAnimIndex; 
  WeaponHand *weapHand; 
  int outWeapAnimToggle; 
  DObj *obj; 
  cg_t *cgameGlob; 
  XAnimTree *tree; 
  float outAdsTransInSpeedMs; 
  float blendOutTime; 
  float outAdsTransOutSpeedMs; 
  Weapon r_weapon; 

  v3 = localClientNum;
  v5 = handIndex;
  cgameGlob = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v5 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v5, 2) )
    __debugbreak();
  viewModelDObj = cgameGlob->m_weaponHand[v5].viewModelDObj;
  weapHand = &cgameGlob->m_weaponHand[v5];
  obj = viewModelDObj;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8775, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  tree = DObjGetTree(viewModelDObj);
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v7 = CgWeaponMap::ms_instance[v3];
  r_weapon = *BG_GetViewmodelWeapon(v7, ps);
  v8 = BG_UsingAlternate(ps);
  v59 = v8;
  if ( !r_weapon.weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8783, ASSERT_TYPE_ASSERT, "(weapon.weaponIdx != 0)", (const char *)&queryFormat, "weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  Handler = CgHandler::getHandler((LocalClientNum_t)v3);
  v61 = PM_Weapon_IsInInterruptibleState(v7, ps, (PlayerHandIndex)v5, Handler);
  v10 = BG_IsAimDownSight(&r_weapon, v8) && (BG_PlayerLastWeaponHand(v7, ps) == WEAPON_HAND_DEFAULT || BG_HasLadderHand(ps));
  isAiming = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u) && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 1u) && BG_IsAimDownSight(&r_weapon, v59) && (BG_PlayerLastWeaponHand(v7, ps) == WEAPON_HAND_DEFAULT || BG_HasLadderHand(ps));
  v12 = cgameGlob->m_weaponHand[v5].iPrevAnim & 0xFFFFFF7F;
  cgameGlob->m_weaponHand[v5].animPlayingAtBeginFrame = v12;
  animState = v12;
  outWeapAnimToggle = ps->weapState[v5].weapAnim;
  weaponAnim = outWeapAnimToggle & 0xFFFFFF7F;
  CG_Weapons_FastADSTransitionOverride((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, &r_weapon, v59, isAiming, v61, &weaponAnim, &outWeapAnimToggle);
  prevAnimIndex = WEAP_ANIM_IDLE;
  if ( weapHand->iPrevAnim > 0 )
  {
    v13 = (unsigned int)(ps->weapState[v5].weaponState - 22) <= 2 && BG_IsMeleeAnimState(animState) && BG_IsMeleeAnimState(weaponAnim) && cgameGlob->playerWeaponInfo.meleeStartTime[v5] != ps->meleeStartTime;
    v14 = CgHandler::getHandler((LocalClientNum_t)v3);
    prevAnimIndex = BG_MapWeaponAnimStateToAnimIndex(v7, ps, weapHand->iPrevAnim & 0xFFFFFF7F, v13, &r_weapon, v59, (PlayerHandIndex)v5, v14);
  }
  IsSwimWeapon = BG_IsSwimWeapon(&r_weapon);
  if ( HandleExclusiveAkimboSwitchAnimPlay((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, &r_weapon) )
  {
    CG_Gesture_ProcessViewmodel((LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, &r_weapon);
    CG_Weapons_CheckForGestureForcedBlendOuts((const LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, &r_weapon);
    CG_Weapons_PlayDemeanorOffsetAnims((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, &r_weapon);
    CG_Weapons_HybridScopeUpdate((const LocalClientNum_t)v3, ps, &r_weapon, v59);
    return;
  }
  CG_SetADSAltSwitchGlobals((LocalClientNum_t)v3, ps, weapHand, &r_weapon, v59, cgameGlob);
  v16 = CG_Weapons_IsInAds((const LocalClientNum_t)v3, v7, ps, &r_weapon, v59, (const PlayerHandIndex)v5);
  if ( !v16 && weaponAnim == 3 && CG_HasRecoilAnim((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5) )
    PlayRecoilAnim((LocalClientNum_t)v3, ps, &r_weapon, (PlayerHandIndex)v5, WEAP_ANIM_RECOIL);
  else
    StopRecoilAnim((const LocalClientNum_t)v3, ps, obj);
  if ( !BG_IsUsingTurretViewarms(v7, ps) )
    PlayADSAnim((const LocalClientNum_t)v3, ps, v10, COERCE_DOUBLE((unsigned __int64)LODWORD(cgameGlob->weaponPosFracAnimData.correctedWeaponPosFrac)), obj, weaponAnim, (PlayerHandIndex)v5);
  CG_Weapons_PlaySkydiveAnims((const LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, obj);
  if ( IsSwimWeapon )
  {
    if ( v16 )
    {
      v17 = tree;
      XAnimSetAnimRate(tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 0.0);
      XAnimSetTime(v17, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 0.0);
    }
    else
    {
      XAnimSetAnimRate(tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, 1.0);
    }
  }
  v18 = weaponAnim;
  if ( ((unsigned int)weaponAnim <= 1 || weaponAnim == 67) && CG_HasRecoilAnim((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5) )
    PlayRecoilAnim((LocalClientNum_t)v3, ps, &r_weapon, (PlayerHandIndex)v5, WEAP_ANIM_RECOIL_SETTLE);
  v19 = CgHandler::getHandler((LocalClientNum_t)v3);
  v20 = BG_MapWeaponAnimStateToAnimIndex(v7, ps, v18, 0, &r_weapon, v59, (PlayerHandIndex)v5, v19);
  v21 = weapHand;
  weaponAnim = v20;
  if ( outWeapAnimToggle != weapHand->iPrevAnim || (p_prevViewmodelWeapon = &cgameGlob->prevViewmodelWeapon, memcmp_0(&r_weapon, &cgameGlob->prevViewmodelWeapon, 0x3Cui64)) && !BG_WeaponsDifferOnlyInVariantForInstantSwitch(ps, cgameGlob->prevWeaponFlags, &r_weapon, p_prevViewmodelWeapon) )
  {
    IsSprintAdditive = BG_IsSprintAdditive(v7, ps);
    v23 = IsSprintAdditive;
    value = 0.0;
    if ( v18 == WEAP_SLIDE )
    {
      v25 = animState;
    }
    else
    {
      if ( v18 == WEAP_IDLE )
        goto LABEL_59;
      v25 = animState;
      if ( animState == 55 )
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0, 0.0, 0.1, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
    }
    if ( (unsigned int)v18 > WEAP_FORCE_IDLE && v18 != WEAP_WALLRUN )
    {
LABEL_121:
      if ( v18 == WEAP_SLIDE )
      {
        CG_Weapons_StartWeaponAnim((LocalClientNum_t)v3, &r_weapon, (PlayerHandIndex)v5, WEAP_SLIDE, WEAP_ANIM_IDLE, (const WeaponAnimNumber)v25, prevAnimIndex, 0.1, 0);
        v46 = CgHandler::getHandler((LocalClientNum_t)v3);
        AdsUpAnim = BG_GetAdsUpAnim(ps, v46);
        v48 = obj;
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsUpAnim, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
        AdsDownAnim = BG_GetAdsDownAnim(ps, v46);
        XAnimSetGoalWeight(v48, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, 0.0, 0.0, 1.0, (scr_string_t)0, 0, 1, LINEAR, NULL);
        CG_GameInterface_ClearADSAnims((const LocalClientNum_t)v3, ps, v48);
      }
      else
      {
        if ( ((v18 - 32) & 0xFFFFFFFC) != 0 || v18 == WEAP_SPRINT_IN_CANCEL || !v23 )
        {
          Weight = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
          if ( *(float *)&Weight > 0.0 )
          {
            v52 = DCONST_DVARFLT_superSprintBlendTime;
            if ( !DCONST_DVARFLT_superSprintBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "superSprintBlendTime") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v52);
            value = v52->current.value;
          }
          CG_Weapons_StartWeaponAnim((LocalClientNum_t)v3, &r_weapon, (PlayerHandIndex)v5, v18, (const weapAnimFiles_t)weaponAnim, (const WeaponAnimNumber)v25, prevAnimIndex, value, 0);
          v50 = obj;
        }
        else
        {
          isInterruptible = v25;
          v50 = obj;
          CG_StartSprintAdditive((LocalClientNum_t)v3, ps, obj, &r_weapon, v21, (const PlayerHandIndex)v5, isInterruptible, prevAnimIndex, v18, (const weapAnimFiles_t)weaponAnim);
        }
        if ( (unsigned int)(v18 - 14) <= 1 )
          XAnimBonePhysicsReset(v50);
      }
      v53 = v59;
      p_prevViewmodelWeapon = &cgameGlob->prevViewmodelWeapon;
      v21->iPrevAnim = outWeapAnimToggle;
      *p_prevViewmodelWeapon = r_weapon;
      WeaponRunOverrideAnims((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, v21->iPrevAnim, &r_weapon, v59, 0);
      goto LABEL_137;
    }
LABEL_59:
    v25 = animState;
    if ( !IsSprintAdditive || ((animState - 32) & 0xFFFFFFFC) != 0 || (v63 = 1, animState == 33) )
      v63 = 0;
    XAnimGetAnims(v21->tree);
    blendOutTime = 0.0;
    *(float *)&animState = 0.0;
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2359, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( v18 == WEAP_FORCE_IDLE && LocalClientGlobals->fastADSTransActive )
    {
      v27 = 0;
      v28 = s_fastADSBlendAnimStates;
      while ( v25 != *v28 )
      {
        ++v27;
        ++v28;
        if ( v27 >= 0xE )
          goto LABEL_71;
      }
      Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v3);
      if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2376, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      v31 = BG_UsingAlternate(ps);
      BG_GetADSTransTimes(Instance, ps, &r_weapon, v31, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
      v32 = 0.001 / outAdsTransInSpeedMs;
      v33 = BG_WeaponADSFractionAffectedByReload(Instance, ps);
      v34 = I_fclamp(1.0 - *(float *)&v33, 0.0, 1.0);
      v29 = (float)(*(float *)&v34 * v32) * 0.69999999;
    }
    else
    {
LABEL_71:
      if ( !(unsigned int)GetAnimBlendTimes((const LocalClientNum_t)v3, &r_weapon, ps, (const WeaponAnimNumber)v25, prevAnimIndex, v18, weaponAnim, &blendOutTime, (float *)&animState) )
        goto LABEL_79;
      v29 = blendOutTime;
    }
    if ( v29 == 0.0 )
    {
      v60 = 1;
LABEL_80:
      v35 = DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled;
      if ( !DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_post_ship_relative_anim_fix_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v35);
      v37 = 176;
      enabled = v35->current.enabled;
      v36 = enabled;
      if ( enabled )
        v37 = 192;
      v38 = 0;
      outAdsTransInSpeedMs = *(float *)&v37;
      while ( 1 )
      {
        VMRelativeAnimIndex = CG_Weapons_GetVMRelativeAnimIndex(v38, v36);
        v40 = VMRelativeAnimIndex;
        if ( (unsigned int)(VMRelativeAnimIndex - 286) > 0x23 && (unsigned int)(VMRelativeAnimIndex - 381) > 7 && (unsigned int)(VMRelativeAnimIndex - 389) > 7 )
        {
          if ( VMRelativeAnimIndex == 341 && IsSprintAdditive )
            v40 = 97;
          v41 = CgHandler::getHandler((LocalClientNum_t)v3);
          if ( BG_ViewModelAnimExists(ps, (weapAnimFiles_t)v40, (PlayerHandIndex)v5, v41) )
          {
            if ( !XAnimIsLooped(tree->anims, v40) && !XAnimHasFinished(tree, 0, XANIM_SUBTREE_DEFAULT, v40) && (weapHand->iPrevAnim != v25 || !v60) )
            {
              if ( v25 != 28 && !v63 && !v60 && v25 != 4 )
                weapHand->iPrevAnim = -1;
              if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8724, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
                __debugbreak();
              if ( v40 == 323 && (GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u) || BG_IsSuperSprinting(ps)) && (Time = XAnimGetTime(tree, 0, XANIM_SUBTREE_DEFAULT, 0x143u), *(float *)&Time <= *(float *)&dword_147FA82C4) )
              {
                value = *(float *)&dword_147FA82C8;
              }
              else
              {
                if ( (outWeapAnimToggle & 1) == 0 )
                {
                  if ( (unsigned int)(v40 - 326) > 6 || (v43 = 83, !_bittest(&v43, v40 - 326)) )
                  {
                    if ( (unsigned int)(v40 - 259) > 2 && (v25 != 28 || v40 != 334) )
                    {
                      v44 = cgameGlob;
                      cgameGlob->prevViewmodelWeapon = r_weapon;
                      WeaponRunOverrideAnims((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, weapHand->iPrevAnim, &r_weapon, v59, (unsigned int)(v40 - 322) <= 1);
                      CG_Weapons_PlayAdditiveViewModelAnims((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, &r_weapon);
                      CG_Gesture_ProcessViewmodel((LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, &r_weapon);
                      CG_Weapons_CheckForGestureForcedBlendOuts((const LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, &r_weapon);
                      CG_Weapons_PlayDemeanorOffsetAnims((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, &r_weapon);
                      v45 = obj;
                      CG_Ladder_PlayAnims((const LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, obj);
                      CG_WeaponAnimGroup_Update((const weapAnimFiles_t)weaponAnim, v44, (const PlayerHandIndex)v5, &r_weapon, v59, tree, v45);
                      CG_Weapons_HybridScopeUpdate((const LocalClientNum_t)v3, ps, &r_weapon, v59);
                      return;
                    }
                  }
                }
                value = FLOAT_0_5;
              }
            }
          }
        }
        if ( ++v38 >= SLODWORD(outAdsTransInSpeedMs) )
          break;
        v36 = enabled;
      }
      v21 = weapHand;
      v23 = IsSprintAdditive;
      goto LABEL_121;
    }
LABEL_79:
    v60 = 0;
    goto LABEL_80;
  }
  v53 = v59;
LABEL_137:
  v54 = cgameGlob;
  if ( BG_WeaponsDifferOnlyInVariantForInstantSwitch(ps, cgameGlob->prevWeaponFlags, &r_weapon, p_prevViewmodelWeapon) )
    *p_prevViewmodelWeapon = r_weapon;
  CG_Weapons_HybridScopeUpdate((const LocalClientNum_t)v3, ps, &r_weapon, v53);
  v55 = obj;
  CG_Ladder_PlayAnims((const LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, obj);
  v56 = weaponAnim;
  CG_Weapons_UpdateSuperSprintAnim((LocalClientNum_t)v3, &r_weapon, (PlayerHandIndex)v5, (weapAnimFiles_t)weaponAnim);
  CG_Weapons_UpdateSprintAnim((LocalClientNum_t)v3, &r_weapon, (PlayerHandIndex)v5, (weapAnimFiles_t)v56);
  CG_Weapons_PlayAdditiveViewModelAnims((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, &r_weapon);
  CG_Gesture_ProcessViewmodel((LocalClientNum_t)v3, ps, (const PlayerHandIndex)v5, &r_weapon);
  weapHand = NULL;
  if ( !(_DWORD)v5 && CG_Gesture_ShouldBlendOutOfAnim((const LocalClientNum_t)v3, ps, WEAPON_HAND_DEFAULT, (const GestureWeaponAnimBlendOutInfo **)&weapHand) )
  {
    v57 = weapHand;
    if ( !weapHand )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8681, ASSERT_TYPE_ASSERT, "(blendOutInfo)", (const char *)&queryFormat, "blendOutInfo") )
        __debugbreak();
      v57 = weapHand;
    }
    CG_Weapons_StartWeaponAnim((LocalClientNum_t)v3, &r_weapon, WEAPON_HAND_DEFAULT, (const WeaponAnimNumber)v57->tree, SHIDWORD(v57->tree), (const WeaponAnimNumber)v57->viewModelDObj, SHIDWORD(v57->viewModelDObj), *(float *)&v57->rocketModel, 0);
  }
  CG_Weapons_PlayDemeanorOffsetAnims((LocalClientNum_t)v3, ps, (PlayerHandIndex)v5, &r_weapon);
  CG_WeaponAnimGroup_Update((const weapAnimFiles_t)v56, v54, (const PlayerHandIndex)v5, &r_weapon, v53, tree, v55);
}

