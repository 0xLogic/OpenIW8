/*
==============
CgCompassSystemCPRaid::DrawPlayerLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawPlayerLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid(CgCompassSystemCPRaid *this, const vec3_t *origin, ObjectiveSide side, ObjectiveSide progressSide, ObjectiveBackground background, int entNum, bool isSecurityScreen, vec4_t *newColor, vec4_t *backgroundColor, const vec4_t *color)
{
  ?GetObjectiveCompassColorCPRaid@CgCompassSystemCPRaid@@QEBAXAEBTvec3_t@@W4ObjectiveSide@@1W4ObjectiveBackground@@H_NAEATvec4_t@@4AEBT5@@Z(this, origin, side, progressSide, background, entNum, isSecurityScreen, newColor, backgroundColor, color);
}

/*
==============
CgCompassSystemCPRaid::DrawCursorLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawCursorLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawCursorLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::InitMaze
==============
*/

void __fastcall CgCompassSystemCPRaid::InitMaze(CgCompassSystemCPRaid *this, const GfxImage *image, const vec2_t *mazeUpperLeft, const vec2_t *mazeWorldSize)
{
  ?InitMaze@CgCompassSystemCPRaid@@QEAAXPEBUGfxImage@@AEBTvec2_t@@1@Z(this, image, mazeUpperLeft, mazeWorldSize);
}

/*
==============
CgCompassSystemCPRaid::DrawFriendliesCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawFriendliesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawFriendliesCPRaid@CgCompassSystemCPRaid@@QEAAXW4CompassType@@_N1PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::InitCompass
==============
*/

void __fastcall CgCompassSystemCPRaid::InitCompass(CgCompassSystemCPRaid *this)
{
  ?InitCompass@CgCompassSystemCPRaid@@QEAAXXZ(this);
}

/*
==============
CgCompassSystemCPRaid::DrawOthersLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawOthersLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawOthersLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::CgCompassSystemCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::CgCompassSystemCPRaid(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum)
{
  ??0CgCompassSystemCPRaid@@QEAA@W4LocalClientNum_t@@@Z(this, localClientNum);
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerPointersCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, bool isSecurityScreen, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawPlayerPointersCPRaid@CgCompassSystemCPRaid@@QEBAXW4CompassType@@_N11PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, isSecurityScreen, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawPlayerCPRaid@CgCompassSystemCPRaid@@QEAAXW4CompassType@@_N1PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawEnemiesCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawEnemiesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawEnemiesCPRaid@CgCompassSystemCPRaid@@QEAAXW4CompassType@@_N1PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawItemsLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawItemsLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawItemsLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::GetPlayerRoleMaterial
==============
*/

void __fastcall CgCompassSystemCPRaid::GetPlayerRoleMaterial(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum, int clientNum, const GfxImage **material)
{
  ?GetPlayerRoleMaterial@CgCompassSystemCPRaid@@QEAAXW4LocalClientNum_t@@HPEAPEBUGfxImage@@@Z(this, localClientNum, clientNum, material);
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerMapCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerMapCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, const rectDef_s *parentRect, const rectDef_s *rect, Material *material, const vec4_t *color, GfxImage *mapMask, GfxImage *mapOverlay, GfxImage *mapRotOverlay, LUIElement *element, lua_State *luaVM, const GfxImage *mapMaterial)
{
  ?DrawPlayerMapCPRaid@CgCompassSystemCPRaid@@QEBAXW4CompassType@@_NPEBUrectDef_s@@2PEAUMaterial@@AEBTvec4_t@@PEAUGfxImage@@55PEAULUIElement@@PEAUlua_State@@PEBU6@@Z(this, compassType, cropPartialMap, parentRect, rect, material, color, mapMask, mapOverlay, mapRotOverlay, element, luaVM, mapMaterial);
}

/*
==============
CgCompassSystemCPRaid::DrawMapLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawMapLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, const vec4_t *mapColor, LUIElement *element, lua_State *luaVM)
{
  ?DrawMapLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@2PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, mapColor, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::CgCompassSystemCPRaid
==============
*/
void CgCompassSystemCPRaid::CgCompassSystemCPRaid(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum)
{
  CgCompassSystemMP::CgCompassSystemMP(this, localClientNum);
  this->__vftable = (CgCompassSystemCPRaid_vtbl *)&CgCompassSystemCPRaid::`vftable';
  this->mazeCompassMapUpperLeft = 0i64;
  this->mazeCompassMapWorldSize.v[0] = 1.0;
  this->mazeCompassMapWorldSize.v[1] = 1.0;
}

/*
==============
CgCompassSystemCPRaid::DrawCursorLayer
==============
*/
void CgCompassSystemCPRaid::DrawCursorLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  if ( !minimapOptions->isCPRaidSecurityScreen )
    CgCompassSystemMP::DrawCursorLayer(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawEnemiesCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawEnemiesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  CgGlobalsMP *LocalClientGlobals; 
  CgStatic *LocalClientStatics; 
  characterInfo_t *CharacterInfo; 
  double IconFadeAlpha; 
  float v17; 
  vec2_t *p_mazeCompassMapWorldSize; 
  float v19; 
  float v20; 
  int *p_lastUpdate; 
  __int64 v22; 
  int v23; 
  int time; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  float v28; 
  double v29; 
  float width; 
  float v32; 
  float v33; 
  float outAngle; 
  vec2_t outPos; 
  const rectDef_s *v36; 
  lua_State *v37; 
  LUIElement *v38; 
  SecureVec3 out; 
  __int64 v40; 
  vec2_t outClipped; 
  vec4_t v42; 
  rectDef_s x; 
  vec2_t north; 

  v40 = -2i64;
  v36 = rect;
  v38 = element;
  v37 = luaVM;
  LocalClientGlobals = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
  CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, LocalClientGlobals->predictedPlayerState.clientNum);
  if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 365, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
    __debugbreak();
  if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 366, ASSERT_TYPE_ASSERT, "(localClientInfo)", (const char *)&queryFormat, "localClientInfo") )
    __debugbreak();
  CgCompassSystem::GetCompassYaw(this, compassType, cropPartialMap, LocalClientGlobals, &outAngle, &north);
  IconFadeAlpha = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, compassType);
  v17 = *(float *)&IconFadeAlpha * color->v[3];
  if ( v17 != 0.0 && CharacterInfo->infoValid && CharacterInfo->team != TEAM_SPECTATOR )
  {
    p_mazeCompassMapWorldSize = &this->mazeCompassMapWorldSize;
    CG_CompassCalcDimensions(compassType, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &x.x, &x.y, &x.w, &x.h);
    v19 = (float)(0.5 * x.w) + x.x;
    v20 = (float)(0.5 * x.h) + x.y;
    v42.v[0] = color->v[0];
    *(_QWORD *)&v42.xyz.y = *(_QWORD *)&color->xyz.y;
    CgCompassSystemMP::GetEnemyCompassColor(this, &v42, LocalClientGlobals);
    ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    CG_CalcPlayerPos(&out, this->m_localClientNum);
    p_lastUpdate = &this->m_compassActors[0].lastUpdate;
    v22 = 248i64;
    do
    {
      if ( (*(_BYTE *)(p_lastUpdate - 1) & 1) != 0 )
      {
        v23 = *p_lastUpdate;
        time = LocalClientGlobals->time;
        if ( *p_lastUpdate > time )
        {
          *p_lastUpdate = 0;
          time = LocalClientGlobals->time;
          v23 = 0;
        }
        if ( v23 >= time - 500 )
        {
          CompassActor_GetLastPos((const CompassActor *const)(p_lastUpdate - 1), &outPos);
          if ( !CgCompassSystem::WorldPosToCompass(this, compassType, cropPartialMap, &x, boundsRadius, p_mazeCompassMapWorldSize, &this->mazeCompassMapUpperLeft, &LocalClientGlobals->compassNorth, &north, (const vec2_t *)&out, &outPos, NULL, &outClipped) || Dvar_GetBool_Internal_DebugName(DVARBOOL_compassClampIcons, "compassClampIcons") )
          {
            CalcCompassFriendlySize(compassType, &v33, &v32);
            outClipped.v[0] = v19 + outClipped.v[0];
            outClipped.v[1] = v20 + outClipped.v[1];
            vertAlign = v36->vertAlign;
            horzAlign = v36->horzAlign;
            ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
            ScrPlace_ApplyRect(ActivePlacement, (float *)&outClipped, (float *)&outClipped + 1, &v33, &v32, horzAlign, vertAlign);
            v28 = outAngle - *((float *)p_lastUpdate + 1);
            v29 = AngleNormalize360(v28);
            width = *(float *)&v29;
            CgCompassSystem::WorldYawToCompass(this, compassType, LocalClientGlobals, v28, &width);
            if ( cgMedia.compass.enemy_arrow )
            {
              v42.v[3] = v17;
              LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v38, outClipped.v[0], outClipped.v[1], v33, v32, 0.0, 0.0, 1.0, 1.0, width, v42.v[0], v42.v[1], v42.v[2], v17, cgMedia.compass.enemy_arrow, v37);
            }
            p_mazeCompassMapWorldSize = &this->mazeCompassMapWorldSize;
          }
        }
      }
      p_lastUpdate += 34;
      --v22;
    }
    while ( v22 );
  }
  memset(&out, 0, sizeof(out));
  memset(&outPos, 0, sizeof(outPos));
}

/*
==============
CgCompassSystemCPRaid::DrawFriendliesCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawFriendliesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  CgGlobalsMP *LocalClientGlobals; 
  double IconFadeAlpha; 
  float v14; 
  float v15; 
  characterInfo_t *CharacterInfo; 
  CompassType v17; 
  float v18; 
  float v19; 
  int v20; 
  int *p_lastUpdate; 
  int v22; 
  int time; 
  bool v24; 
  CgStatic *v25; 
  clientInfo_t *v26; 
  const clientInfo_t *v27; 
  bool m_useSquads; 
  bool v29; 
  double v30; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  int v34; 
  int v35; 
  int v36; 
  const char *PlayerRole; 
  const char *v38; 
  GfxImage *v39; 
  float v40; 
  const dvar_t *v41; 
  double Float_Internal_DebugName; 
  int v43; 
  int v44; 
  float v45; 
  double v46; 
  const GfxImage *party_yelling; 
  float v48; 
  double v49; 
  int v50; 
  int v51; 
  float v52; 
  double v53; 
  __int64 v54; 
  lua_State *v55; 
  LUIElement *v56; 
  GfxImage *material; 
  float v59; 
  float v60; 
  CompassType compassTypea; 
  unsigned int clientNum; 
  int v63; 
  GfxImage *output_material; 
  vec2_t outPos; 
  LUIElement *v66; 
  lua_State *v67; 
  CgStatic *LocalClientStatics; 
  const rectDef_s *v69; 
  SecureVec3 out; 
  __int64 v71; 
  vec2_t v1; 
  vec4_t v73; 
  vec2_t v0; 
  rectDef_s mapRect; 

  v71 = -2i64;
  compassTypea = compassType;
  v69 = rect;
  v66 = element;
  v67 = luaVM;
  LocalClientGlobals = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
  IconFadeAlpha = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, compassType);
  v15 = *(float *)&IconFadeAlpha * color->v[3];
  v14 = v15;
  output_material = NULL;
  clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
  CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, clientNum);
  if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 201, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
    __debugbreak();
  if ( v15 != 0.0 && CharacterInfo->infoValid && CharacterInfo->team == TEAM_TWO )
  {
    v17 = compassTypea;
    CG_CompassCalcDimensions(compassTypea, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &mapRect.x, &mapRect.y, &mapRect.w, &mapRect.h);
    v18 = (float)(0.5 * mapRect.w) + mapRect.x;
    v19 = (float)(0.5 * mapRect.h) + mapRect.y;
    *(_QWORD *)v73.v = *(_QWORD *)color->v;
    v73.v[2] = color->v[2];
    CgCompassSystemMP::GetFriendlyCompassColor(this, &v73, LocalClientGlobals);
    v20 = 0;
    v63 = 0;
    p_lastUpdate = &this->m_compassActors[0].lastUpdate;
    while ( 1 )
    {
      v22 = *p_lastUpdate;
      time = LocalClientGlobals->time;
      if ( *p_lastUpdate > time )
      {
        *p_lastUpdate = 0;
        time = LocalClientGlobals->time;
        v22 = 0;
      }
      if ( v22 < time - 500 || (*(_BYTE *)(p_lastUpdate - 1) & 5) != 0 || clientNum == v20 )
        goto LABEL_74;
      CG_CalcPlayerPos(&out, this->m_localClientNum);
      CompassActor_GetLastPos((const CompassActor *const)(p_lastUpdate - 1), &outPos);
      v1.v[0] = 0.0;
      v1.v[1] = 0.0;
      v24 = CgCompassSystem::WorldPosToCompass(this, v17, cropPartialMap, &mapRect, boundsRadius, &this->mazeCompassMapWorldSize, &this->mazeCompassMapUpperLeft, &LocalClientGlobals->compassNorth, &this->m_compassPlayerForward, (const vec2_t *)&out, &outPos, &v0, &v1);
      if ( !v24 || Dvar_GetBool_Internal_DebugName(DVARBOOL_compassClampIcons, "compassClampIcons") && !Dvar_GetBool_Internal_DebugName(DVARBOOL_compassHideClippedFriendlies, "compassHideClippedFriendlies") )
        break;
LABEL_73:
      memset(&outPos, 0, sizeof(outPos));
LABEL_74:
      v63 = ++v20;
      p_lastUpdate += 34;
      if ( v20 >= 248 )
        goto LABEL_75;
    }
    v25 = LocalClientStatics;
    v26 = LocalClientStatics->GetClientInfo(LocalClientStatics, clientNum);
    if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 253, ASSERT_TYPE_ASSERT, "(myClientInfo)", (const char *)&queryFormat, "myClientInfo") )
      __debugbreak();
    v27 = v25->GetClientInfo(v25, v20);
    if ( !v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 255, ASSERT_TYPE_ASSERT, "(clientInfo)", (const char *)&queryFormat, "clientInfo") )
      __debugbreak();
    this->ComputeFriendlyCompassColor(this, v26, v27, &v73);
    m_useSquads = LocalClientGlobals->m_useSquads;
    v29 = m_useSquads && v26->squadIndex == v27->squadIndex;
    if ( v24 && m_useSquads && !v29 && Dvar_GetBool_Internal_DebugName(DVARBOOL_compassHideClippedNonSquad, "compassHideClippedNonSquad") )
    {
LABEL_72:
      v17 = compassTypea;
      goto LABEL_73;
    }
    CalcCompassFriendlySize(compassTypea, &v60, &v59);
    v0.v[0] = v18 + v0.v[0];
    v0.v[1] = v19 + v0.v[1];
    v1.v[0] = v18 + v1.v[0];
    v1.v[1] = v19 + v1.v[1];
    if ( v24 )
    {
      v30 = CalcCompassClippedDistanceScale(&v0, &v1, 0);
      v60 = *(float *)&v30 * v60;
      v59 = *(float *)&v30 * v59;
    }
    vertAlign = v69->vertAlign;
    horzAlign = v69->horzAlign;
    ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    ScrPlace_ApplyRect(ActivePlacement, (float *)&v1, (float *)&v1 + 1, &v60, &v59, horzAlign, vertAlign);
    v34 = LocalClientGlobals->time;
    v35 = p_lastUpdate[23];
    if ( v34 < v35 )
    {
      if ( *((_BYTE *)p_lastUpdate + 118) && (v35 - v34) % 500 >= 250 )
      {
        v36 = 1;
        output_material = (GfxImage *)cgMedia.compass.party_chatting;
        goto LABEL_37;
      }
    }
    else
    {
      *((_BYTE *)p_lastUpdate + 118) = 0;
    }
    v36 = 0;
    PlayerRole = CL_PlayerData_GetPlayerRole(this->m_localClientNum, v27->clientNum);
    v38 = StringTable_LookupFromAsset("cp/cp_fieldupgrades.csv", 1, PlayerRole, 2);
    if ( *v38 )
      LUI_Interface_RegisterMaterial(v38, (const GfxImage **)&output_material);
LABEL_37:
    v39 = NULL;
    v40 = 0.0;
    v41 = DVARFLT_compassSoundPingFadeTime;
    if ( !DVARFLT_compassSoundPingFadeTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassSoundPingFadeTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v41);
    if ( v41->current.value <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 298, ASSERT_TYPE_ASSERT, "(Dvar_GetFloat_Internal_DebugName( DVARFLT_compassSoundPingFadeTime, \"compassSoundPingFadeTime\" ) > 0.0f)", (const char *)&queryFormat, "Dvar_GetFloat( compassSoundPingFadeTime ) > 0.0f") )
      __debugbreak();
    Float_Internal_DebugName = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
    v43 = p_lastUpdate[24];
    v44 = LocalClientGlobals->time;
    if ( (float)((float)v43 + (float)(*(float *)&Float_Internal_DebugName * 1000.0)) >= (float)v44 )
    {
      if ( v43 < v44 )
      {
        v45 = (float)(v44 - v43);
        v46 = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
        v40 = 1.0 - (float)(v45 / (float)(*(float *)&v46 * 1000.0));
      }
      else
      {
        v40 = FLOAT_1_0;
      }
      v39 = output_material;
    }
    party_yelling = NULL;
    v48 = 0.0;
    v49 = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
    v50 = p_lastUpdate[26];
    v51 = LocalClientGlobals->time;
    if ( (float)((float)v50 + (float)(*(float *)&v49 * 1000.0)) >= (float)v51 )
    {
      if ( v50 < v51 )
      {
        v52 = (float)(v51 - v50);
        v53 = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
        v48 = 1.0 - (float)(v52 / (float)(*(float *)&v53 * 1000.0));
      }
      else
      {
        v48 = FLOAT_1_0;
      }
      party_yelling = cgMedia.compass.party_yelling;
    }
    if ( output_material )
    {
      if ( (v39 && v40 == 1.0 || party_yelling && v48 == 1.0) && !v36 )
      {
        v54 = *(_QWORD *)(p_lastUpdate + 31);
        if ( !v54 || !*(_BYTE *)(v54 + 9) )
          goto LABEL_66;
      }
      v73.v[3] = v14;
      LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v66, v1.v[0], v1.v[1], v60, v59, 0.0, 0.0, 1.0, 1.0, 0.0, v73.v[0], v73.v[1], v73.v[2], v14, output_material, v67);
    }
    if ( v36 )
    {
LABEL_71:
      v20 = v63;
      goto LABEL_72;
    }
LABEL_66:
    v55 = v67;
    if ( party_yelling )
    {
      v73.v[3] = v48 * v14;
      material = (GfxImage *)party_yelling;
      v56 = v66;
      LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v66, v1.v[0], v1.v[1], v60, v59, 0.0, 0.0, 1.0, 1.0, 0.0, v73.v[0], v73.v[1], v73.v[2], v48 * v14, material, v67);
    }
    else
    {
      v56 = v66;
    }
    if ( v39 )
    {
      v73.v[3] = v40 * v14;
      LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v56, v1.v[0], v1.v[1], v60, v59, 0.0, 0.0, 1.0, 1.0, 0.0, v73.v[0], v73.v[1], v73.v[2], v40 * v14, v39, v55);
    }
    goto LABEL_71;
  }
LABEL_75:
  memset(&out, 0, sizeof(out));
}

/*
==============
CgCompassSystemCPRaid::DrawItemsLayer
==============
*/
void CgCompassSystemCPRaid::DrawItemsLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  bool cropPartialMap; 
  float boundsRadius; 

  cropPartialMap = minimapOptions->cropPartialMap;
  boundsRadius = minimapOptions->boundsRadius;
  if ( minimapOptions->isCPRaidSecurityScreen )
  {
    CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(this, minimapOptions->compassType, cropPartialMap, minimapOptions->largeMap, 1, parentRect, rect, boundsRadius, color, element, luaVM);
  }
  else
  {
    CgCompassSystemMP::ComputeWorldToScreenScale(this, minimapOptions->compassType, cropPartialMap, parentRect, rect, boundsRadius, element, luaVM);
    CgCompassSystemMP::DrawScramblers(this, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, minimapOptions->boundsRadius, color, minimapOptions->mapMask, element, luaVM);
    CgCompassSystemMP::DrawPortableRadar(this, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, minimapOptions->boundsRadius, color, minimapOptions->mapMask, element, luaVM);
    CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, minimapOptions->largeMap, 0, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
    CgCompassSystemMP::DrawTurrets(this, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
    CgCompassSystemMP::DrawPlanes(this, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
    CgCompassSystemMP::DrawPlayerCalloutMarkerPings(this, 0, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
    CG_VehicleHudMP_DrawCompass(this->m_localClientNum, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, minimapOptions->boundsRadius, color, minimapOptions->largeMap, minimapOptions->mapMask, element, luaVM);
    CgCompassSystemMP::DrawMLGCameras(this, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
    CgCompassSystemMP::DrawGridLabels(this, minimapOptions->compassType, parentRect, rect, color, element, luaVM);
  }
}

/*
==============
CgCompassSystemCPRaid::DrawMapLayer
==============
*/
void CgCompassSystemCPRaid::DrawMapLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, const vec4_t *mapColor, LUIElement *element, lua_State *luaVM)
{
  if ( minimapOptions->isCPRaidSecurityScreen )
    CgCompassSystemCPRaid::DrawPlayerMapCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, NULL, mapColor, minimapOptions->mapMask, minimapOptions->mapOverlay, minimapOptions->mapRotOverlay, element, luaVM, this->mapImage);
  else
    CgCompassSystemMP::DrawMapLayer(this, minimapOptions, parentRect, rect, color, mapColor, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawOthersLayer
==============
*/
void CgCompassSystemCPRaid::DrawOthersLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  if ( minimapOptions->isCPRaidSecurityScreen )
  {
    CgCompassSystemCPRaid::DrawFriendliesCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, minimapOptions->largeMap, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
    CgCompassSystemCPRaid::DrawEnemiesCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, minimapOptions->largeMap, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
  }
  else
  {
    CgCompassSystemMP::DrawOthersLayer(this, minimapOptions, parentRect, rect, color, element, luaVM);
  }
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawPlayerCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  cg_t *LocalClientGlobals; 
  double IconFadeAlpha; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  const dvar_t *v20; 
  float value; 
  const dvar_t *v22; 
  const dvar_t *v23; 
  float v24; 
  const dvar_t *v25; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  const char *PlayerRole; 
  const char *v30; 
  float outHeight; 
  float outWidth; 
  float v35; 
  float v36; 
  GfxImage *output_material; 
  rectDef_s *v38; 
  lua_State *v39; 
  SecureVec3 out; 
  __int64 v41; 
  vec2_t outClipped; 
  __int64 v43; 
  float v44; 
  float v45; 
  rectDef_s mapRect; 

  v41 = -2i64;
  v38 = (rectDef_s *)parentRect;
  v39 = luaVM;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  IconFadeAlpha = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, compassType);
  v14 = *(float *)&IconFadeAlpha * color->v[3];
  output_material = NULL;
  if ( v14 != 0.0 && !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.eFlags, ACTIVE, 0xCu) )
  {
    v43 = *(_QWORD *)color->v;
    v44 = color->v[2];
    this->GetPlayerCompassColor(this, (vec4_t *)&v43, LocalClientGlobals);
    v15 = *(float *)&v43;
    v16 = *((float *)&v43 + 1);
    v17 = v44;
    v45 = FLOAT_1_0;
    CG_CompassCalcDimensions(compassType, LocalClientGlobals, v38, rect, &this->mazeCompassMapWorldSize, &mapRect.x, &mapRect.y, &mapRect.w, &mapRect.h);
    v18 = (float)(0.5 * mapRect.w) + mapRect.x;
    v19 = (float)(0.5 * mapRect.h) + mapRect.y;
    outClipped.v[0] = 0.0;
    outClipped.v[1] = 0.0;
    CG_CalcPlayerPos(&out, this->m_localClientNum);
    CgCompassSystem::WorldPosToCompass(this, compassType, cropPartialMap, &mapRect, boundsRadius, &this->mazeCompassMapWorldSize, &this->mazeCompassMapUpperLeft, &LocalClientGlobals->compassNorth, &this->m_compassPlayerForward, (const vec2_t *)&out, (const vec2_t *)&LocalClientGlobals->predictedPlayerState.origin, NULL, &outClipped);
    v36 = outClipped.v[0];
    v35 = outClipped.v[1];
    CgCompassSystem::GetPlayerDrawSize(this, compassType, largeMap, &outHeight, &outWidth);
    v36 = v18 + v36;
    v35 = v19 + v35;
    v20 = DVARFLT_compassSize;
    if ( !DVARFLT_compassSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v20);
    value = v20->current.value;
    v22 = DVARFLT_compassRoleIconScale;
    if ( !DVARFLT_compassRoleIconScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassRoleIconScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v22);
    outWidth = (float)(value * v22->current.value) * outWidth;
    v23 = DVARFLT_compassSize;
    if ( !DVARFLT_compassSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v23);
    v24 = v23->current.value;
    v25 = DVARFLT_compassRoleIconScale;
    if ( !DVARFLT_compassRoleIconScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassRoleIconScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v25);
    outHeight = (float)(v24 * v25->current.value) * outHeight;
    vertAlign = rect->vertAlign;
    horzAlign = rect->horzAlign;
    ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    ScrPlace_ApplyRect(ActivePlacement, &v36, &v35, &outWidth, &outHeight, horzAlign, vertAlign);
    PlayerRole = CL_PlayerData_GetPlayerRole(this->m_localClientNum, LocalClientGlobals->predictedPlayerState.clientNum);
    v30 = StringTable_LookupFromAsset("cp/cp_fieldupgrades.csv", 1, PlayerRole, 2);
    if ( *v30 )
      LUI_Interface_RegisterMaterial(v30, (const GfxImage **)&output_material);
    LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, element, v36, v35, outWidth, outHeight, 0.0, 0.0, 1.0, 1.0, 0.0, v15, v16, v17, v14, output_material, v39);
  }
  memset(&out, 0, sizeof(out));
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerLayer
==============
*/
void CgCompassSystemCPRaid::DrawPlayerLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  if ( minimapOptions->isCPRaidSecurityScreen )
    CgCompassSystemCPRaid::DrawPlayerCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, minimapOptions->largeMap, parentRect, rect, minimapOptions->boundsRadius, color, element, luaVM);
  else
    CgCompassSystemMP::DrawPlayerLayer(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerMapCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawPlayerMapCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, const rectDef_s *parentRect, const rectDef_s *rect, Material *material, const vec4_t *color, GfxImage *mapMask, GfxImage *mapOverlay, GfxImage *mapRotOverlay, LUIElement *element, lua_State *luaVM, const GfxImage *mapMaterial)
{
  const GfxImage *image; 
  cg_t *LocalClientGlobals; 
  float v18; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  float y; 
  float h; 
  float x; 
  float vMax; 
  lua_State *v26; 
  __int64 v27; 
  char v28[12]; 
  vec4_t v29; 
  vec4_t quadVerts[4]; 

  v27 = -2i64;
  v26 = luaVM;
  image = mapMaterial;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals->compassMapMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 625, ASSERT_TYPE_ASSERT, "(cgameGlob->compassMapMaterial)", (const char *)&queryFormat, "cgameGlob->compassMapMaterial") )
    __debugbreak();
  if ( !LocalClientGlobals->compassMapMaterial->textureCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 626, ASSERT_TYPE_ASSERT, "(cgameGlob->compassMapMaterial->textureCount > 0)", (const char *)&queryFormat, "cgameGlob->compassMapMaterial->textureCount > 0") )
    __debugbreak();
  if ( !mapMaterial )
    image = LocalClientGlobals->compassMapMaterial->textureTable->image;
  v18 = color->v[3];
  if ( v18 != 0.0 )
  {
    *(_QWORD *)v29.v = *(_QWORD *)color->v;
    v29.v[2] = color->v[2];
    v29.v[3] = v18;
    if ( this->mazeCompassMapWorldSize.v[0] == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 641, ASSERT_TYPE_ASSERT, "(mazeCompassMapWorldSize[0] != 0)", (const char *)&queryFormat, "mazeCompassMapWorldSize[0] != 0") )
      __debugbreak();
    if ( this->mazeCompassMapWorldSize.v[1] == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 642, ASSERT_TYPE_ASSERT, "(mazeCompassMapWorldSize[1] != 0)", (const char *)&queryFormat, "mazeCompassMapWorldSize[1] != 0") )
      __debugbreak();
    if ( cg_t::ms_allocatedType == GLOB_TYPE_MP )
      CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( compassType != COMPASS_TYPE_FULL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 653, ASSERT_TYPE_ASSERT, "(compassType == CompassType::COMPASS_TYPE_FULL)", (const char *)&queryFormat, "compassType == CompassType::COMPASS_TYPE_FULL") )
      __debugbreak();
    CG_CompassCalcDimensions(compassType, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &x, &y, &vMax, &h);
    vertAlign = rect->vertAlign;
    horzAlign = rect->horzAlign;
    ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    ScrPlace_ApplyRect(ActivePlacement, &x, &y, &vMax, &h, horzAlign, vertAlign);
    LUI_CoD_GenerateQuadVerts(x, y, x + vMax, y + h, (vec4_t (*)[4])quadVerts);
    LUI_Render_DrawImage((const LocalClientNum_t)this->m_localClientNum, element, v26, (const vec4_t (*)[4])quadVerts, 0.0, 0.0, 1.0, 1.0, &v29, image);
  }
  memset(v28, 0, sizeof(v28));
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerPointersCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, bool isSecurityScreen, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  __int128 v11; 
  CompassType v13; 
  cg_t *LocalClientGlobals; 
  __int128 v17; 
  float centerX; 
  float v19; 
  CgStatic *LocalClientStatics; 
  __int64 clientNum; 
  cg_t *v22; 
  const characterInfo_t *CharacterInfo; 
  int v24; 
  int v25; 
  bool v26; 
  __int64 v27; 
  __int64 entNum; 
  int v29; 
  vec3_t *v30; 
  __int64 v31; 
  const dvar_t *v35; 
  float v36; 
  const dvar_t *v37; 
  ObjectiveIconSize ObjectiveIconSizeDefault; 
  const GfxImage *v39; 
  unsigned __int8 i; 
  const ObjectiveSettings *v41; 
  const ObjectiveSettings *v42; 
  bool v43; 
  unsigned int v47; 
  const dvar_t *v48; 
  float v49; 
  const dvar_t *v50; 
  const GfxImage *v51; 
  ObjectiveIconSize v52; 
  float *x; 
  ObjectiveFlags xa; 
  bool xb; 
  float *y; 
  ObjectiveFlags ya; 
  ObjectiveFlags yb; 
  bool ObjectiveClippedPos; 
  unsigned __int8 v61; 
  bool v62; 
  CompassType compassTypea; 
  int objectiveIndex; 
  __int16 v65; 
  vec3_t origin; 
  GfxImage *icon; 
  float outAngle; 
  float pingAlpha; 
  float scale; 
  float v71; 
  cg_t *v72; 
  GfxImage *outIcon; 
  vec3_t *v74; 
  lua_State *v75; 
  LUIElement *v76; 
  rectDef_s *v77; 
  SecureVec3 out; 
  vec3_t v79; 
  vec3_t prevOrigin; 
  __int64 v81; 
  vec4_t newColor; 
  vec4_t backgroundColor; 
  rectDef_s scaledRect; 
  vec2_t xyClipped; 
  vec2_t xy; 
  vec2_t outVector; 

  v81 = -2i64;
  v13 = compassType;
  compassTypea = compassType;
  v77 = (rectDef_s *)rect;
  v76 = element;
  v75 = luaVM;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v72 = LocalClientGlobals;
  *(double *)&v11 = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, v13);
  v17 = v11;
  *(float *)&v17 = *(float *)&v11 * color->v[3];
  _XMM7 = v17;
  if ( *(float *)&v17 != 0.0 )
  {
    if ( isSecurityScreen )
      CG_CompassCalcDimensions(v13, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &scaledRect.x, &scaledRect.y, &scaledRect.w, &scaledRect.h);
    else
      CG_CompassCalcDimensions(v13, LocalClientGlobals, parentRect, rect, &scaledRect.x, &scaledRect.y, &scaledRect.w, &scaledRect.h);
    centerX = (float)(0.5 * scaledRect.w) + scaledRect.x;
    v19 = (float)(0.5 * scaledRect.h) + scaledRect.y;
    LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
    clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
    v22 = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
    if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( v22->IsMP(v22) )
    {
      if ( (unsigned int)clientNum >= v22[1].predictedPlayerState.rxvOmnvars[64].timeModified )
      {
        LODWORD(y) = v22[1].predictedPlayerState.rxvOmnvars[64].timeModified;
        LODWORD(x) = clientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_globals_mp_inline.h", 19, ASSERT_TYPE_ASSERT, "(unsigned)( characterIndex ) < (unsigned)( static_cast<int>( m_characterInfoCount ) )", "characterIndex doesn't index static_cast<int>( m_characterInfoCount )\n\t%i not in [0, %i)", x, y) )
          __debugbreak();
      }
      CharacterInfo = (const characterInfo_t *)(*(_QWORD *)&v22[1].predictedPlayerState.rxvOmnvars[62] + 14792 * clientNum);
    }
    else
    {
      CharacterInfo = CgGlobalsSP::GetCharacterInfo((CgGlobalsSP *)v22, clientNum);
    }
    if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 473, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
    if ( CharacterInfo->infoValid )
    {
      CgCompassSystem::GetCompassYaw(this, v13, cropPartialMap, LocalClientGlobals, &outAngle, &outVector);
      CG_CalcPlayerPos(&out, this->m_localClientNum);
      v24 = 0;
      objectiveIndex = 0;
      v25 = 0;
      v26 = isSecurityScreen;
      do
      {
        v27 = v25;
        entNum = (__int64)LocalClientGlobals->predictedPlayerState.objectives[v27].entNum;
        outIcon = NULL;
        if ( v26 || (*(_WORD *)LocalClientGlobals->predictedPlayerState.objectives[v27].flags & 0x2000) == 0 )
        {
          if ( CgCompassSystemMP::GetObjectiveShouldRender(this, LocalClientGlobals->predictedPlayerState.objectives[v27].state, (ObjectiveFlags)*(unsigned __int16 *)LocalClientGlobals->predictedPlayerState.objectives[v27].flags, 0, LocalClientGlobals->predictedPlayerState.objectives[v27].icon, (const GfxImage **)&outIcon) && !this->IsObjectiveFiltered(this, v13, *(ObjectiveBackground *)(entNum + 158)) )
          {
            CG_CompassGetObjectivePingAlpha((const ObjectiveView *)entNum, LocalClientGlobals->time, &pingAlpha);
            CgCompassSystemMP::GetObjectiveScale(this, (const ObjectiveView *)entNum, &objectiveIndex, &scale);
            LOWORD(LocalClientGlobals) = *(_WORD *)(entNum + 156) >> 11;
            LOBYTE(LocalClientGlobals) = (*(_WORD *)(entNum + 156) & 0x800) != 0;
            v65 = (__int16)LocalClientGlobals;
            v29 = 1;
            v30 = (vec3_t *)(entNum + 32);
            v74 = (vec3_t *)(entNum + 32);
            v31 = 8i64;
            icon = (GfxImage *)8;
            do
            {
              if ( (v29 & *(_DWORD *)(entNum + 128)) != 0 )
              {
                v79 = *v30;
                LOWORD(xa) = *(_WORD *)(entNum + 156);
                CgCompassSystemMP::GetObjectiveCompassOrigin(this, compassTypea, cropPartialMap, *(_DWORD *)entNum, 0xFFFFFFFF, xa, &v79, outAngle, (SecureVec3 *)&origin, &v62, &v71);
                ObjectiveClippedPos = CgCompassSystemMP::GetObjectiveClippedPos(this, compassTypea, v62, cropPartialMap, &scaledRect, boundsRadius, &outVector, &out, &origin, &prevOrigin, centerX, v19, &xy, &xyClipped);
                if ( !ObjectiveClippedPos || !(_BYTE)LocalClientGlobals )
                {
                  if ( isSecurityScreen )
                  {
                    newColor.v[0] = color->v[0];
                    *(_QWORD *)&newColor.xyz.y = *(_QWORD *)&color->xyz.y;
                    _XMM3 = LODWORD(color->v[3]);
                    backgroundColor.v[0] = newColor.v[0];
                    backgroundColor.v[1] = newColor.v[1];
                    backgroundColor.v[2] = newColor.v[2];
                    backgroundColor.v[3] = *(float *)&_XMM3;
                  }
                  else
                  {
                    CgCompassSystemMP::GetObjectiveCompassColor(this, &origin, *(ObjectiveSide *)(entNum + 161), *(ObjectiveSide *)(entNum + 162), *(ObjectiveBackground *)(entNum + 158), *(_DWORD *)entNum, &newColor, &backgroundColor, color);
                    _XMM3 = LODWORD(newColor.v[3]);
                  }
                  __asm
                  {
                    vcmpltss xmm0, xmm7, xmm3
                    vblendvps xmm1, xmm3, xmm7, xmm0
                  }
                  newColor.v[3] = *(float *)&_XMM1 * pingAlpha;
                  LODWORD(LocalClientGlobals) = 0;
                  v35 = DVARBOOL_compassPrototypeElevation;
                  if ( !DVARBOOL_compassPrototypeElevation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassPrototypeElevation") )
                    __debugbreak();
                  Dvar_CheckFrontendServerThread(v35);
                  if ( v35->current.enabled )
                  {
                    v36 = origin.v[2] - v72->predictedPlayerState.origin.v[2];
                    v37 = DCONST_DVARFLT_compassEnemyHeightDelta;
                    if ( !DCONST_DVARFLT_compassEnemyHeightDelta && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassEnemyHeightDelta") )
                      __debugbreak();
                    Dvar_CheckFrontendServerThread(v37);
                    if ( COERCE_FLOAT(LODWORD(v36) & _xmm) >= v37->current.value )
                    {
                      LOBYTE(LocalClientGlobals) = v36 <= 0.0;
                      LODWORD(LocalClientGlobals) = (_DWORD)LocalClientGlobals + 1;
                    }
                  }
                  ObjectiveIconSizeDefault = CgCompassSystemMP::GetObjectiveIconSizeDefault(this, (ObjectiveFlags)*(unsigned __int16 *)(entNum + 156), *(ObjectiveIconSize *)(entNum + 160));
                  v39 = this->GetObjectiveBackgroundImage(this, *(unsigned __int8 *)(entNum + 158), (unsigned int)LocalClientGlobals);
                  LOWORD(ya) = *(_WORD *)(entNum + 156);
                  CgCompassSystemMP::DrawObjective(this, compassTypea, v77, &xy, &xyClipped, ObjectiveClippedPos, ya, ObjectiveIconSizeDefault, v39, v71, scale, scale, outIcon, &newColor, &backgroundColor, v76, v75);
                  v30 = v74;
                  v31 = (__int64)icon;
                  LOBYTE(LocalClientGlobals) = v65;
                }
              }
              v29 = __ROL4__(v29, 1);
              v74 = ++v30;
              icon = (GfxImage *)--v31;
            }
            while ( v31 );
            v13 = compassTypea;
            LocalClientGlobals = v72;
            v26 = isSecurityScreen;
          }
          v24 = objectiveIndex;
        }
        objectiveIndex = ++v24;
        v25 = v24;
      }
      while ( v24 < 32 );
      v61 = ScriptableCl_ObjectiveCount((const LocalClientNum_t)this->m_localClientNum);
      for ( i = 0; i < v61; v26 = isSecurityScreen )
      {
        v41 = ScriptableCl_ObjectiveGet((const LocalClientNum_t)this->m_localClientNum, i, &origin);
        v42 = v41;
        if ( v41 )
        {
          origin.v[2] = (float)v41->zOffset + origin.v[2];
          if ( (v26 || (*(_WORD *)v41->flags & 0x2000) == 0) && CgCompassSystemMP::GetObjectiveShouldRender(this, v41->state, (ObjectiveFlags)*(unsigned __int16 *)v41->flags, 0, v41->icon, (const GfxImage **)&icon) && !this->IsObjectiveFiltered(this, v13, v42->background) )
          {
            v62 = 0;
            v43 = CgCompassSystemMP::GetObjectiveClippedPos(this, v13, 0, cropPartialMap, &scaledRect, boundsRadius, &outVector, &out, &origin, &prevOrigin, centerX, v19, &xy, &xyClipped);
            if ( v43 && (*(_WORD *)v42->flags & 0x800) != 0 )
            {
              v13 = compassTypea;
            }
            else
            {
              if ( v26 )
              {
                *(_QWORD *)newColor.v = *(_QWORD *)color->v;
                newColor.v[2] = color->v[2];
                _XMM3 = LODWORD(color->v[3]);
                backgroundColor.v[0] = newColor.v[0];
                backgroundColor.v[1] = newColor.v[1];
                backgroundColor.v[2] = newColor.v[2];
                backgroundColor.v[3] = *(float *)&_XMM3;
              }
              else
              {
                CgCompassSystemMP::GetObjectiveCompassColor(this, &origin, NEUTRAL, NEUTRAL, v42->background, 2047, &newColor, &backgroundColor, color);
                _XMM3 = LODWORD(newColor.v[3]);
              }
              __asm
              {
                vcmpltss xmm0, xmm7, xmm3
                vblendvps xmm0, xmm3, xmm7, xmm0
              }
              newColor.v[3] = *(float *)&_XMM0;
              v47 = 0;
              v48 = DVARBOOL_compassPrototypeElevation;
              if ( !DVARBOOL_compassPrototypeElevation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassPrototypeElevation") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v48);
              if ( v48->current.enabled )
              {
                v49 = (float)(origin.v[2] - (float)v42->zOffset) - v72->predictedPlayerState.origin.v[2];
                v50 = DCONST_DVARFLT_compassEnemyHeightDelta;
                if ( !DCONST_DVARFLT_compassEnemyHeightDelta && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassEnemyHeightDelta") )
                  __debugbreak();
                Dvar_CheckFrontendServerThread(v50);
                if ( COERCE_FLOAT(LODWORD(v49) & _xmm) >= v50->current.value )
                {
                  LOBYTE(v47) = v49 <= 0.0;
                  ++v47;
                }
              }
              v51 = this->GetObjectiveBackgroundImage(this, (unsigned __int8)v42->background, v47);
              v52 = CgCompassSystemMP::GetObjectiveIconSizeDefault(this, (ObjectiveFlags)*(unsigned __int16 *)v42->flags, v42->size);
              LOWORD(yb) = *(_WORD *)v42->flags;
              xb = v43;
              v13 = compassTypea;
              CgCompassSystemMP::DrawObjective(this, compassTypea, v77, &xy, &xyClipped, xb, yb, v52, v51, 0.0, 0.0, 0.0, icon, &newColor, &backgroundColor, v76, v75);
            }
          }
        }
        ++i;
      }
    }
  }
  memset(&out, 0, sizeof(out));
  memset(&prevOrigin, 0, sizeof(prevOrigin));
  memset(&origin, 0, sizeof(origin));
}

/*
==============
CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid
==============
*/
void CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid(CgCompassSystemCPRaid *this, const vec3_t *origin, ObjectiveSide side, ObjectiveSide progressSide, ObjectiveBackground background, int entNum, bool isSecurityScreen, vec4_t *newColor, vec4_t *backgroundColor, const vec4_t *color)
{
  if ( isSecurityScreen )
  {
    *newColor = *color;
    *backgroundColor = *color;
  }
  else
  {
    CgCompassSystemMP::GetObjectiveCompassColor(this, origin, side, progressSide, background, entNum, newColor, backgroundColor, color);
  }
}

/*
==============
CgCompassSystemCPRaid::GetPlayerRoleMaterial
==============
*/
void CgCompassSystemCPRaid::GetPlayerRoleMaterial(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum, int clientNum, const GfxImage **material)
{
  const char *PlayerRole; 
  const char *v6; 

  PlayerRole = CL_PlayerData_GetPlayerRole(localClientNum, clientNum);
  v6 = StringTable_LookupFromAsset("cp/cp_fieldupgrades.csv", 1, PlayerRole, 2);
  if ( *v6 )
    LUI_Interface_RegisterMaterial(v6, material);
}

/*
==============
CgCompassSystemCPRaid::InitCompass
==============
*/

void __fastcall CgCompassSystemCPRaid::InitCompass(CgCompassSystemCPRaid *this)
{
  CgCompassSystemMP::InitCompass(this);
}

/*
==============
CgCompassSystemCPRaid::InitMaze
==============
*/
void CgCompassSystemCPRaid::InitMaze(CgCompassSystemCPRaid *this, const GfxImage *image, const vec2_t *mazeUpperLeft, const vec2_t *mazeWorldSize)
{
  this->mazeCompassMapUpperLeft = *mazeUpperLeft;
  this->mazeCompassMapWorldSize = *mazeWorldSize;
  this->mapImage = image;
}

