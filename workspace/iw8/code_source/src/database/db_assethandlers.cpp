/*
==============
Mark_WeaponAttachmentAsset
==============
*/

int __fastcall Mark_WeaponAttachmentAsset(WeaponAttachment *attachment, int inuse)
{
  return ?Mark_WeaponAttachmentAsset@@YAHPEAUWeaponAttachment@@H@Z(attachment, inuse);
}

/*
==============
Load_KeyValuePairsAsset
==============
*/

void __fastcall Load_KeyValuePairsAsset(KeyValuePairs **keyValuePairs)
{
  ?Load_KeyValuePairsAsset@@YAXPEAPEAUKeyValuePairs@@@Z(keyValuePairs);
}

/*
==============
DB_GetGfxImageAtIndex
==============
*/

GfxImage *__fastcall DB_GetGfxImageAtIndex(unsigned int index)
{
  return ?DB_GetGfxImageAtIndex@@YAPEAUGfxImage@@I@Z(index);
}

/*
==============
Mark_GfxImageAsset
==============
*/

int __fastcall Mark_GfxImageAsset(GfxImage *image, int inuse)
{
  return ?Mark_GfxImageAsset@@YAHPEAUGfxImage@@H@Z(image, inuse);
}

/*
==============
Mark_AnimationClassAsset
==============
*/

int __fastcall Mark_AnimationClassAsset(AnimationClass *animClass, int inuse)
{
  return ?Mark_AnimationClassAsset@@YAHPEAUAnimationClass@@H@Z(animClass, inuse);
}

/*
==============
Load_MaterialSerializedShaderAsset
==============
*/

void __fastcall Load_MaterialSerializedShaderAsset(MaterialSerializedShader **serializedShader)
{
  ?Load_MaterialSerializedShaderAsset@@YAXPEAPEAUMaterialSerializedShader@@@Z(serializedShader);
}

/*
==============
Load_PhysicsFXShapeAsset
==============
*/

void __fastcall Load_PhysicsFXShapeAsset(PhysicsFXShape **physicsFXShape)
{
  ?Load_PhysicsFXShapeAsset@@YAXPEAPEAUPhysicsFXShape@@@Z(physicsFXShape);
}

/*
==============
Mark_FxWorldAsset
==============
*/

int __fastcall Mark_FxWorldAsset(FxWorld *curFxWorld, int inuse)
{
  return ?Mark_FxWorldAsset@@YAHPEAUFxWorld@@H@Z(curFxWorld, inuse);
}

/*
==============
Mark_LocalizeEntryAsset
==============
*/

int __fastcall Mark_LocalizeEntryAsset(LocalizeEntry *localize, int inuse)
{
  return ?Mark_LocalizeEntryAsset@@YAHPEAULocalizeEntry@@H@Z(localize, inuse);
}

/*
==============
Load_XAnimDynamicBonesAsset
==============
*/

void __fastcall Load_XAnimDynamicBonesAsset(XAnimDynamicBones **dynamicBones)
{
  ?Load_XAnimDynamicBonesAsset@@YAXPEAPEAUXAnimDynamicBones@@@Z(dynamicBones);
}

/*
==============
Mark_FootstepVFXAsset
==============
*/

int __fastcall Mark_FootstepVFXAsset(FootstepVFX *info, int inuse)
{
  return ?Mark_FootstepVFXAsset@@YAHPEAUFootstepVFX@@H@Z(info, inuse);
}

/*
==============
Load_TracerDefAsset
==============
*/

void __fastcall Load_TracerDefAsset(TracerDef **tracerDef)
{
  ?Load_TracerDefAsset@@YAXPEAPEAUTracerDef@@@Z(tracerDef);
}

/*
==============
Load_BulletPenetrationAsset
==============
*/

void __fastcall Load_BulletPenetrationAsset(BulletPenetration **bulletPenetration)
{
  ?Load_BulletPenetrationAsset@@YAXPEAPEAUBulletPenetration@@@Z(bulletPenetration);
}

/*
==============
Load_AnimationClassAsset
==============
*/

void __fastcall Load_AnimationClassAsset(AnimationClass **animClass)
{
  ?Load_AnimationClassAsset@@YAXPEAPEAUAnimationClass@@@Z(animClass);
}

/*
==============
DB_FreeXAssetPoolMem
==============
*/

void DB_FreeXAssetPoolMem(void)
{
  ?DB_FreeXAssetPoolMem@@YAXXZ();
}

/*
==============
Load_NavMeshDataAsset
==============
*/

void __fastcall Load_NavMeshDataAsset(NavMeshData **navMesh)
{
  ?Load_NavMeshDataAsset@@YAXPEAPEAUNavMeshData@@@Z(navMesh);
}

/*
==============
Mark_GfxWorldAsset
==============
*/

int __fastcall Mark_GfxWorldAsset(GfxWorld *gfxWorld, int inuse)
{
  return ?Mark_GfxWorldAsset@@YAHPEAUGfxWorld@@H@Z(gfxWorld, inuse);
}

/*
==============
Mark_KeyValuePairsAsset
==============
*/

int __fastcall Mark_KeyValuePairsAsset(KeyValuePairs *keyValuePairs, int inuse)
{
  return ?Mark_KeyValuePairsAsset@@YAHPEAUKeyValuePairs@@H@Z(keyValuePairs, inuse);
}

/*
==============
Load_FxParticleSimAnimationAsset
==============
*/

void __fastcall Load_FxParticleSimAnimationAsset(FxParticleSimAnimation **particleSimAnimation)
{
  ?Load_FxParticleSimAnimationAsset@@YAXPEAPEAUFxParticleSimAnimation@@@Z(particleSimAnimation);
}

/*
==============
Load_CinematicMotionDefAsset
==============
*/

void __fastcall Load_CinematicMotionDefAsset(CinematicMotionDef **cinematicMotionDefAsset)
{
  ?Load_CinematicMotionDefAsset@@YAXPEAPEAUCinematicMotionDef@@@Z(cinematicMotionDefAsset);
}

/*
==============
Mark_EquipmentSoundTableAsset
==============
*/

int __fastcall Mark_EquipmentSoundTableAsset(EquipmentSoundTable *equipmentSndTable, int inuse)
{
  return ?Mark_EquipmentSoundTableAsset@@YAHPEAUEquipmentSoundTable@@H@Z(equipmentSndTable, inuse);
}

/*
==============
Load_PhysicsAsset
==============
*/

void __fastcall Load_PhysicsAsset(PhysicsAsset **physicsAsset)
{
  ?Load_PhysicsAsset@@YAXPEAPEAUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
DB_AssetCount
==============
*/

unsigned int __fastcall DB_AssetCount(XAssetType type)
{
  return ?DB_AssetCount@@YAIW4XAssetType@@@Z(type);
}

/*
==============
Mark_BulletPenetrationAsset
==============
*/

int __fastcall Mark_BulletPenetrationAsset(BulletPenetration *bulletPenetration, int inuse)
{
  return ?Mark_BulletPenetrationAsset@@YAHPEAUBulletPenetration@@H@Z(bulletPenetration, inuse);
}

/*
==============
Mark_CinematicMotionDefAsset
==============
*/

int __fastcall Mark_CinematicMotionDefAsset(CinematicMotionDef *cinematicMotionDefAsset, int inuse)
{
  return ?Mark_CinematicMotionDefAsset@@YAHPEAUCinematicMotionDef@@H@Z(cinematicMotionDefAsset, inuse);
}

/*
==============
Mark_SoundBankListDefAsset
==============
*/

int __fastcall Mark_SoundBankListDefAsset(SoundBankListDef *soundBankListDef, int inuse)
{
  return ?Mark_SoundBankListDefAsset@@YAHPEAUSoundBankListDef@@H@Z(soundBankListDef, inuse);
}

/*
==============
Mark_DDLAsset
==============
*/

int __fastcall Mark_DDLAsset(DDLFile *ddlFile, int inuse)
{
  return ?Mark_DDLAsset@@YAHPEAUDDLFile@@H@Z(ddlFile, inuse);
}

/*
==============
Load_WeaponCompleteDefAsset
==============
*/

void __fastcall Load_WeaponCompleteDefAsset(WeaponCompleteDef **weapon)
{
  ?Load_WeaponCompleteDefAsset@@YAXPEAPEAUWeaponCompleteDef@@@Z(weapon);
}

/*
==============
DB_UpdateBlackboxAssetCounts
==============
*/

void DB_UpdateBlackboxAssetCounts(void)
{
  ?DB_UpdateBlackboxAssetCounts@@YAXXZ();
}

/*
==============
Postload_SndBankResidentAsset
==============
*/

void __fastcall Postload_SndBankResidentAsset(SndBankResident **sndBank)
{
  ?Postload_SndBankResidentAsset@@YAXPEAPEAUSndBankResident@@@Z(sndBank);
}

/*
==============
Mark_WeaponSFXPackageAsset
==============
*/

int __fastcall Mark_WeaponSFXPackageAsset(WeaponSFXPackage *info, int inuse)
{
  return ?Mark_WeaponSFXPackageAsset@@YAHPEAUWeaponSFXPackage@@H@Z(info, inuse);
}

/*
==============
Load_StreamTreeOverrideAsset
==============
*/

void __fastcall Load_StreamTreeOverrideAsset(StreamTreeOverride **treeOverride)
{
  ?Load_StreamTreeOverrideAsset@@YAXPEAPEAUStreamTreeOverride@@@Z(treeOverride);
}

/*
==============
Load_CollisionTile
==============
*/

void __fastcall Load_CollisionTile(CollisionTile **collisionTilePtr)
{
  ?Load_CollisionTile@@YAXPEAPEAUCollisionTile@@@Z(collisionTilePtr);
}

/*
==============
DB_CopyXAssetDefault
==============
*/

void __fastcall DB_CopyXAssetDefault(XAssetHeader from, XAssetHeader to, XAssetType type, const char *toAssetNewName)
{
  ?DB_CopyXAssetDefault@@YAXTXAssetHeader@@0W4XAssetType@@PEBD@Z(from, to, type, toAssetNewName);
}

/*
==============
Load_ClothAssetAsset
==============
*/

void __fastcall Load_ClothAssetAsset(ClothAsset **clothAsset)
{
  ?Load_ClothAssetAsset@@YAXPEAPEAUClothAsset@@@Z(clothAsset);
}

/*
==============
DB_GetShipPoolSize
==============
*/

unsigned int __fastcall DB_GetShipPoolSize(XAssetType type)
{
  return ?DB_GetShipPoolSize@@YAIW4XAssetType@@@Z(type);
}

/*
==============
Load_FxWorldAsset
==============
*/

void __fastcall Load_FxWorldAsset(FxWorld **curFxWorld)
{
  ?Load_FxWorldAsset@@YAXPEAPEAUFxWorld@@@Z(curFxWorld);
}

/*
==============
Mark_SurfaceFxTableAsset
==============
*/

int __fastcall Mark_SurfaceFxTableAsset(SurfaceFxTable *surfaceFx, int inuse)
{
  return ?Mark_SurfaceFxTableAsset@@YAHPEAUSurfaceFxTable@@H@Z(surfaceFx, inuse);
}

/*
==============
Load_SndGlobalsAsset
==============
*/

void __fastcall Load_SndGlobalsAsset(SndGlobals **soundGlobals)
{
  ?Load_SndGlobalsAsset@@YAXPEAPEAUSndGlobals@@@Z(soundGlobals);
}

/*
==============
DB_AssetPool_Free
==============
*/

void __fastcall DB_AssetPool_Free(const XAssetType assetType, const XAssetHeader header)
{
  ?DB_AssetPool_Free@@YAXW4XAssetType@@TXAssetHeader@@@Z(assetType, header);
}

/*
==============
Mark_SndGlobalsAsset
==============
*/

int __fastcall Mark_SndGlobalsAsset(SndGlobals *soundGlobals, int inuse)
{
  return ?Mark_SndGlobalsAsset@@YAHPEAUSndGlobals@@H@Z(soundGlobals, inuse);
}

/*
==============
DB_GetMaterialIndex
==============
*/

unsigned int __fastcall DB_GetMaterialIndex(const Material *material)
{
  return ?DB_GetMaterialIndex@@YAIPEBUMaterial@@@Z(material);
}

/*
==============
Mark_LightDefAsset
==============
*/

int __fastcall Mark_LightDefAsset(GfxLightDef *lightDef, int inuse)
{
  return ?Mark_LightDefAsset@@YAHPEAUGfxLightDef@@H@Z(lightDef, inuse);
}

/*
==============
Load_CamoAsset
==============
*/

void __fastcall Load_CamoAsset(Camo **camo)
{
  ?Load_CamoAsset@@YAXPEAPEAUCamo@@@Z(camo);
}

/*
==============
DB_AssetTypeHasADefaultAsset
==============
*/

bool __fastcall DB_AssetTypeHasADefaultAsset(const XAssetType type)
{
  return ?DB_AssetTypeHasADefaultAsset@@YA_NW4XAssetType@@@Z(type);
}

/*
==============
Mark_GfxWorldTransientZoneAsset
==============
*/

int __fastcall Mark_GfxWorldTransientZoneAsset(GfxWorldTransientZone *transientZone, int inuse)
{
  return ?Mark_GfxWorldTransientZoneAsset@@YAHPEAUGfxWorldTransientZone@@H@Z(transientZone, inuse);
}

/*
==============
Mark_GfxDecalVolumeMaterial
==============
*/

int __fastcall Mark_GfxDecalVolumeMaterial(GfxDecalVolumeMaterial *asset, int inuse)
{
  return ?Mark_GfxDecalVolumeMaterial@@YAHPEAUGfxDecalVolumeMaterial@@H@Z(asset, inuse);
}

/*
==============
Mark_AsmAsset
==============
*/

int __fastcall Mark_AsmAsset(ASM *info, int inuse)
{
  return ?Mark_AsmAsset@@YAHPEAUASM@@H@Z(info, inuse);
}

/*
==============
Load_PhysicsAsset
==============
*/

void __fastcall Load_PhysicsAsset(const DBStreamStart streamStart)
{
  ?Load_PhysicsAsset@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_GlassWorldAsset
==============
*/

int __fastcall Mark_GlassWorldAsset(GlassWorld *curGlassWorld, int inuse)
{
  return ?Mark_GlassWorldAsset@@YAHPEAUGlassWorld@@H@Z(curGlassWorld, inuse);
}

/*
==============
DB_GetStreamingInfoIndex
==============
*/

unsigned int __fastcall DB_GetStreamingInfoIndex(const StreamingInfo *streamingInfo)
{
  return ?DB_GetStreamingInfoIndex@@YAIAEBUStreamingInfo@@@Z(streamingInfo);
}

/*
==============
Mark_CameraDefAsset
==============
*/

int __fastcall Mark_CameraDefAsset(CameraDef *cameraDef, int inuse)
{
  return ?Mark_CameraDefAsset@@YAHPEAUCameraDef@@H@Z(cameraDef, inuse);
}

/*
==============
Mark_MapEdgeListAsset
==============
*/

int __fastcall Mark_MapEdgeListAsset(MapEdgeList *mapEdgeList, int inuse)
{
  return ?Mark_MapEdgeListAsset@@YAHPEAUMapEdgeList@@H@Z(mapEdgeList, inuse);
}

/*
==============
Load_VirtualLeaderboardDefAsset
==============
*/

void __fastcall Load_VirtualLeaderboardDefAsset(VirtualLeaderboardDef **vlbDef)
{
  ?Load_VirtualLeaderboardDefAsset@@YAXPEAPEAUVirtualLeaderboardDef@@@Z(vlbDef);
}

/*
==============
Load_ScriptDebugData
==============
*/

void __fastcall Load_ScriptDebugData(ScriptDebugData **scriptDebugData)
{
  ?Load_ScriptDebugData@@YAXPEAPEAUScriptDebugData@@@Z(scriptDebugData);
}

/*
==============
Load_ParticleSystemDefFromName
==============
*/

void __fastcall Load_ParticleSystemDefFromName(const char **name)
{
  ?Load_ParticleSystemDefFromName@@YAXPEAPEBD@Z(name);
}

/*
==============
Load_MayhemDataAsset
==============
*/

void __fastcall Load_MayhemDataAsset(MayhemData **mayhem)
{
  ?Load_MayhemDataAsset@@YAXPEAPEAUMayhemData@@@Z(mayhem);
}

/*
==============
Load_ImageStream
==============
*/

void __fastcall Load_ImageStream(GfxImage *image)
{
  ?Load_ImageStream@@YAXPEAUGfxImage@@@Z(image);
}

/*
==============
Load_TacticalGraphDataAsset
==============
*/

void __fastcall Load_TacticalGraphDataAsset(TacticalGraphData **tacGraph)
{
  ?Load_TacticalGraphDataAsset@@YAXPEAPEAUTacticalGraphData@@@Z(tacGraph);
}

/*
==============
Load_ClientCharacterAsset
==============
*/

void __fastcall Load_ClientCharacterAsset(ClientCharacter **clientCharacter)
{
  ?Load_ClientCharacterAsset@@YAXPEAPEAUClientCharacter@@@Z(clientCharacter);
}

/*
==============
Mark_HudOutlineDefAsset
==============
*/

int __fastcall Mark_HudOutlineDefAsset(HudOutlineDef *hudOutlineDef, int inuse)
{
  return ?Mark_HudOutlineDefAsset@@YAHPEAUHudOutlineDef@@H@Z(hudOutlineDef, inuse);
}

/*
==============
Mark_PhysicsAsset
==============
*/

int __fastcall Mark_PhysicsAsset()
{
  return ?Mark_PhysicsAsset@@YAHXZ();
}

/*
==============
DB_GetXModelIndex
==============
*/

unsigned int __fastcall DB_GetXModelIndex(const XModel *model)
{
  return ?DB_GetXModelIndex@@YAIPEBUXModel@@@Z(model);
}

/*
==============
Mark_XCompositeModelDefAsset
==============
*/

int __fastcall Mark_XCompositeModelDefAsset(XCompositeModelDef *compositeModel, int inuse)
{
  return ?Mark_XCompositeModelDefAsset@@YAHPEAUXCompositeModelDef@@H@Z(compositeModel, inuse);
}

/*
==============
Load_SndBankResidentAsset
==============
*/

void __fastcall Load_SndBankResidentAsset(SndBankResident **sndBank)
{
  ?Load_SndBankResidentAsset@@YAXPEAPEAUSndBankResident@@@Z(sndBank);
}

/*
==============
Load_StClutterSampleBitmask
==============
*/

void __fastcall Load_StClutterSampleBitmask(StClutterSampleBitmask *bitmask)
{
  ?Load_StClutterSampleBitmask@@YAXPEAUStClutterSampleBitmask@@@Z(bitmask);
}

/*
==============
Load_SndBankTransientAsset
==============
*/

void __fastcall Load_SndBankTransientAsset(SndBankTransient **sndBank)
{
  ?Load_SndBankTransientAsset@@YAXPEAPEAUSndBankTransient@@@Z(sndBank);
}

/*
==============
Mark_ExecutionDefAsset
==============
*/

int __fastcall Mark_ExecutionDefAsset(ExecutionDef *executionDef, int inuse)
{
  return ?Mark_ExecutionDefAsset@@YAHPEAUExecutionDef@@H@Z(executionDef, inuse);
}

/*
==============
DB_PushSuppressMaterialSort
==============
*/

void DB_PushSuppressMaterialSort(void)
{
  ?DB_PushSuppressMaterialSort@@YAXXZ();
}

/*
==============
Load_PhysicsFXPipelineAsset
==============
*/

void __fastcall Load_PhysicsFXPipelineAsset(PhysicsFXPipeline **physicsFXPipeline)
{
  ?Load_PhysicsFXPipelineAsset@@YAXPEAPEAUPhysicsFXPipeline@@@Z(physicsFXPipeline);
}

/*
==============
Load_NativeScriptPatchFileAsset
==============
*/

void __fastcall Load_NativeScriptPatchFileAsset(NativeScriptPatchFile **patchFilePtr)
{
  ?Load_NativeScriptPatchFileAsset@@YAXPEAPEAUNativeScriptPatchFile@@@Z(patchFilePtr);
}

/*
==============
Mark_SpaceshipTargetDefAsset
==============
*/

int __fastcall Mark_SpaceshipTargetDefAsset(SpaceshipTargetDef *spaceshipTargetDef, int inuse)
{
  return ?Mark_SpaceshipTargetDefAsset@@YAHPEAUSpaceshipTargetDef@@H@Z(spaceshipTargetDef, inuse);
}

/*
==============
Mark_DynEntityListAsset
==============
*/

int __fastcall Mark_DynEntityListAsset(DynEntityList *dynEntityList, int inuse)
{
  return ?Mark_DynEntityListAsset@@YAHPEAUDynEntityList@@H@Z(dynEntityList, inuse);
}

/*
==============
Mark_FxWorldTransientZoneAsset
==============
*/

int __fastcall Mark_FxWorldTransientZoneAsset(FxWorldTransientZone *transientZone, int inuse)
{
  return ?Mark_FxWorldTransientZoneAsset@@YAHPEAUFxWorldTransientZone@@H@Z(transientZone, inuse);
}

/*
==============
Mark_XModelDetailCollisionAsset
==============
*/

int __fastcall Mark_XModelDetailCollisionAsset(XModelDetailCollision *detailCollision, int inuse)
{
  return ?Mark_XModelDetailCollisionAsset@@YAHPEAUXModelDetailCollision@@H@Z(detailCollision, inuse);
}

/*
==============
DB_AllocXAssetHeader
==============
*/

XAssetHeader __fastcall DB_AllocXAssetHeader(XAssetType type)
{
  return ?DB_AllocXAssetHeader@@YA?ATXAssetHeader@@W4XAssetType@@@Z(type);
}

/*
==============
Mark_RawFileAsset
==============
*/

int __fastcall Mark_RawFileAsset(RawFile *rawfile, int inuse)
{
  return ?Mark_RawFileAsset@@YAHPEAURawFile@@H@Z(rawfile, inuse);
}

/*
==============
DB_ReleaseXModelSurfsXSurfaces
==============
*/

void __fastcall DB_ReleaseXModelSurfsXSurfaces(XModelSurfs *modelSurfs)
{
  ?DB_ReleaseXModelSurfsXSurfaces@@YAXPEAUXModelSurfs@@@Z(modelSurfs);
}

/*
==============
Load_XAnimPartsAsset
==============
*/

void __fastcall Load_XAnimPartsAsset(XAnimParts **parts)
{
  ?Load_XAnimPartsAsset@@YAXPEAPEAUXAnimParts@@@Z(parts);
}

/*
==============
Load_ScriptBundleAsset
==============
*/

void __fastcall Load_ScriptBundleAsset(ScriptBundle **scriptBundle)
{
  ?Load_ScriptBundleAsset@@YAXPEAPEAUScriptBundle@@@Z(scriptBundle);
}

/*
==============
Mark_SndBankResidentAsset
==============
*/

int __fastcall Mark_SndBankResidentAsset(SndBankResident *sndBank, int inuse)
{
  return ?Mark_SndBankResidentAsset@@YAHPEAUSndBankResident@@H@Z(sndBank, inuse);
}

/*
==============
Mark_PhysicsSFXEventAsset
==============
*/

int __fastcall Mark_PhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset, int inuse)
{
  return ?Mark_PhysicsSFXEventAsset@@YAHPEAUPhysicsSFXEventAsset@@H@Z(physicsSFXEventAsset, inuse);
}

/*
==============
Load_SpaceshipTargetDefAsset
==============
*/

void __fastcall Load_SpaceshipTargetDefAsset(SpaceshipTargetDef **spaceshipTargetDef)
{
  ?Load_SpaceshipTargetDefAsset@@YAXPEAPEAUSpaceshipTargetDef@@@Z(spaceshipTargetDef);
}

/*
==============
Load_PhysicsLibraryAsset
==============
*/

void __fastcall Load_PhysicsLibraryAsset(PhysicsLibrary **physicsLibrary)
{
  ?Load_PhysicsLibraryAsset@@YAXPEAPEAUPhysicsLibrary@@@Z(physicsLibrary);
}

/*
==============
Mark_ClothAssetAsset
==============
*/

int __fastcall Mark_ClothAssetAsset(ClothAsset *clothAsset, int inuse)
{
  return ?Mark_ClothAssetAsset@@YAHPEAUClothAsset@@H@Z(clothAsset, inuse);
}

/*
==============
DB_GetDecalVolumeMaskPool
==============
*/

const void *__fastcall DB_GetDecalVolumeMaskPool()
{
  return ?DB_GetDecalVolumeMaskPool@@YAPEBXXZ();
}

/*
==============
Mark_ScriptDebugData
==============
*/

int __fastcall Mark_ScriptDebugData(ScriptDebugData *scriptDebugData, int inuse)
{
  return ?Mark_ScriptDebugData@@YAHPEAUScriptDebugData@@H@Z(scriptDebugData, inuse);
}

/*
==============
Load_GestureAsset
==============
*/

void __fastcall Load_GestureAsset(Gesture **gesture)
{
  ?Load_GestureAsset@@YAXPEAPEAUGesture@@@Z(gesture);
}

/*
==============
Mark_XModelSurfsAsset
==============
*/

int __fastcall Mark_XModelSurfsAsset(XModelSurfs *modelSurfs, int inuse)
{
  return ?Mark_XModelSurfsAsset@@YAHPEAUXModelSurfs@@H@Z(modelSurfs, inuse);
}

/*
==============
Load_PhysicsDebugData
==============
*/

void __fastcall Load_PhysicsDebugData(PhysicsDebugData **physicsDebugData)
{
  ?Load_PhysicsDebugData@@YAXPEAPEAUPhysicsDebugData@@@Z(physicsDebugData);
}

/*
==============
Load_PhysicsSFXEventAsset
==============
*/

void __fastcall Load_PhysicsSFXEventAsset(const DBStreamStart streamStart)
{
  ?Load_PhysicsSFXEventAsset@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
DB_GetXCompositeModelAtIndex
==============
*/

XCompositeModelDef *__fastcall DB_GetXCompositeModelAtIndex(unsigned int compositeModelIndex)
{
  return ?DB_GetXCompositeModelAtIndex@@YAPEAUXCompositeModelDef@@I@Z(compositeModelIndex);
}

/*
==============
Mark_CoverSelectorAsset
==============
*/

int __fastcall Mark_CoverSelectorAsset(CoverSelector *coverSelector, int inuse)
{
  return ?Mark_CoverSelectorAsset@@YAHPEAUCoverSelector@@H@Z(coverSelector, inuse);
}

/*
==============
Load_AddonMapEntsAsset
==============
*/

void __fastcall Load_AddonMapEntsAsset(AddonMapEnts **addonMapEnts)
{
  ?Load_AddonMapEntsAsset@@YAXPEAPEAUAddonMapEnts@@@Z(addonMapEnts);
}

/*
==============
DB_AssetPool_GetItemIndex<WeaponAttachment>
==============
*/

unsigned int __fastcall DB_AssetPool_GetItemIndex<WeaponAttachment>(const XAssetType assetType, const WeaponAttachment *ptr)
{
  return ??$DB_AssetPool_GetItemIndex@UWeaponAttachment@@@@YAIW4XAssetType@@PEBUWeaponAttachment@@@Z(assetType, ptr);
}

/*
==============
Load_FootstepVFXAsset
==============
*/

void __fastcall Load_FootstepVFXAsset(FootstepVFX **info)
{
  ?Load_FootstepVFXAsset@@YAXPEAPEAUFootstepVFX@@@Z(info);
}

/*
==============
DB_GetWeaponAttachmentIndex
==============
*/

unsigned __int16 __fastcall DB_GetWeaponAttachmentIndex(const WeaponAttachment *const attachment)
{
  return ?DB_GetWeaponAttachmentIndex@@YAGQEBUWeaponAttachment@@@Z(attachment);
}

/*
==============
Mark_GradingClutAsset
==============
*/

int __fastcall Mark_GradingClutAsset(GfxGradingClut *gradingClut, int inuse)
{
  return ?Mark_GradingClutAsset@@YAHPEAUGfxGradingClut@@H@Z(gradingClut, inuse);
}

/*
==============
Mark_WeaponAnimPackageAsset
==============
*/

int __fastcall Mark_WeaponAnimPackageAsset(WeaponAnimPackage *info, int inuse)
{
  return ?Mark_WeaponAnimPackageAsset@@YAHPEAUWeaponAnimPackage@@H@Z(info, inuse);
}

/*
==============
Mark_FxImpactTableAsset
==============
*/

int __fastcall Mark_FxImpactTableAsset(FxImpactTable *impactFx, int inuse)
{
  return ?Mark_FxImpactTableAsset@@YAHPEAUFxImpactTable@@H@Z(impactFx, inuse);
}

/*
==============
Mark_XAnimProceduralBonesAsset
==============
*/

int __fastcall Mark_XAnimProceduralBonesAsset(XAnimProceduralBones *proceduralBones, int inuse)
{
  return ?Mark_XAnimProceduralBonesAsset@@YAHPEAUXAnimProceduralBones@@H@Z(proceduralBones, inuse);
}

/*
==============
Mark_PhysicsFXPipelineAsset
==============
*/

int __fastcall Mark_PhysicsFXPipelineAsset(PhysicsFXPipeline *physicsFXPipeline, int inuse)
{
  return ?Mark_PhysicsFXPipelineAsset@@YAHPEAUPhysicsFXPipeline@@H@Z(physicsFXPipeline, inuse);
}

/*
==============
Mark_LaserDefAsset
==============
*/

int __fastcall Mark_LaserDefAsset(LaserDef *laserDef, int inuse)
{
  return ?Mark_LaserDefAsset@@YAHPEAULaserDef@@H@Z(laserDef, inuse);
}

/*
==============
GfxWorldTransientZoneDeferredRelease_SetZoneIndex
==============
*/

void __fastcall GfxWorldTransientZoneDeferredRelease_SetZoneIndex(const unsigned int zoneIndex)
{
  ?GfxWorldTransientZoneDeferredRelease_SetZoneIndex@@YAXI@Z(zoneIndex);
}

/*
==============
Load_StTerrainAsset
==============
*/

void __fastcall Load_StTerrainAsset(StTerrain **terrain)
{
  ?Load_StTerrainAsset@@YAXPEAPEAUStTerrain@@@Z(terrain);
}

/*
==============
Load_VehicleDefAsset
==============
*/

void __fastcall Load_VehicleDefAsset(VehicleDef **vehDef)
{
  ?Load_VehicleDefAsset@@YAXPEAPEAUVehicleDef@@@Z(vehDef);
}

/*
==============
DB_GetXModelSurfsIndex
==============
*/

unsigned int __fastcall DB_GetXModelSurfsIndex(const XModelSurfs *modelSurfs)
{
  return ?DB_GetXModelSurfsIndex@@YAIPEBUXModelSurfs@@@Z(modelSurfs);
}

/*
==============
Load_PhysicsVFXEventAsset
==============
*/

void __fastcall Load_PhysicsVFXEventAsset(PhysicsVFXEventAsset **physicsVFXEventAsset)
{
  ?Load_PhysicsVFXEventAsset@@YAXPEAPEAUPhysicsVFXEventAsset@@@Z(physicsVFXEventAsset);
}

/*
==============
Mark_FogSplineAsset
==============
*/

int __fastcall Mark_FogSplineAsset(GfxFogSpline *fogSpline, int inuse)
{
  return ?Mark_FogSplineAsset@@YAHPEAUGfxFogSpline@@H@Z(fogSpline, inuse);
}

/*
==============
Load_GfxWorldAsset
==============
*/

void __fastcall Load_GfxWorldAsset(GfxWorld **gfxWorld)
{
  ?Load_GfxWorldAsset@@YAXPEAPEAUGfxWorld@@@Z(gfxWorld);
}

/*
==============
Load_ReticleDefAsset
==============
*/

void __fastcall Load_ReticleDefAsset(ReticleDef **reticleDef)
{
  ?Load_ReticleDefAsset@@YAXPEAPEAUReticleDef@@@Z(reticleDef);
}

/*
==============
Load_ScriptFileAsset
==============
*/

void __fastcall Load_ScriptFileAsset(ScriptFile **scriptfile)
{
  ?Load_ScriptFileAsset@@YAXPEAPEAUScriptFile@@@Z(scriptfile);
}

/*
==============
DB_GetPoolUtilization
==============
*/

void __fastcall DB_GetPoolUtilization(const XAssetType type, unsigned int *elementSize, unsigned int *countInUse, unsigned int *maxCountInUse)
{
  ?DB_GetPoolUtilization@@YAXW4XAssetType@@AEAI11@Z(type, elementSize, countInUse, maxCountInUse);
}

/*
==============
Load_ComWorldAsset
==============
*/

void __fastcall Load_ComWorldAsset(ComWorld **curComWorld)
{
  ?Load_ComWorldAsset@@YAXPEAPEAUComWorld@@@Z(curComWorld);
}

/*
==============
Load_VectorFieldAsset
==============
*/

void __fastcall Load_VectorFieldAsset(VectorField **vectorField)
{
  ?Load_VectorFieldAsset@@YAXPEAPEAUVectorField@@@Z(vectorField);
}

/*
==============
DB_GetMaterialAtIndex
==============
*/

Material *__fastcall DB_GetMaterialAtIndex(unsigned int index)
{
  return ?DB_GetMaterialAtIndex@@YAPEAUMaterial@@I@Z(index);
}

/*
==============
Load_GfxDecalVolumeMaterial
==============
*/

void __fastcall Load_GfxDecalVolumeMaterial(GfxDecalVolumeMaterial **asset)
{
  ?Load_GfxDecalVolumeMaterial@@YAXPEAPEAUGfxDecalVolumeMaterial@@@Z(asset);
}

/*
==============
DB_GetDecalVolumeMaskIndex
==============
*/

unsigned int __fastcall DB_GetDecalVolumeMaskIndex(const GfxDecalVolumeMask *mask)
{
  return ?DB_GetDecalVolumeMaskIndex@@YAIPEBUGfxDecalVolumeMask@@@Z(mask);
}

/*
==============
Load_GfxImageAsset
==============
*/

void __fastcall Load_GfxImageAsset(GfxImage **image)
{
  ?Load_GfxImageAsset@@YAXPEAPEAUGfxImage@@@Z(image);
}

/*
==============
Mark_MapEntsAsset
==============
*/

int __fastcall Mark_MapEntsAsset(MapEnts *mapEnts, int inuse)
{
  return ?Mark_MapEntsAsset@@YAHPEAUMapEnts@@H@Z(mapEnts, inuse);
}

/*
==============
Mark_ReticleDefAsset
==============
*/

int __fastcall Mark_ReticleDefAsset(ReticleDef *reticleDef, int inuse)
{
  return ?Mark_ReticleDefAsset@@YAHPEAUReticleDef@@H@Z(reticleDef, inuse);
}

/*
==============
Load_StClutterSampleBitmask
==============
*/

void __fastcall Load_StClutterSampleBitmask(const DBStreamStart streamStart)
{
  ?Load_StClutterSampleBitmask@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_NetConstStringsAsset
==============
*/

void __fastcall Load_NetConstStringsAsset(NetConstStrings **netConstStrings)
{
  ?Load_NetConstStringsAsset@@YAXPEAPEAUNetConstStrings@@@Z(netConstStrings);
}

/*
==============
Mark_PathDataAsset
==============
*/

int __fastcall Mark_PathDataAsset(PathData *curPathData, int inuse)
{
  return ?Mark_PathDataAsset@@YAHPEAUPathData@@H@Z(curPathData, inuse);
}

/*
==============
Load_FxImpactTableAsset
==============
*/

void __fastcall Load_FxImpactTableAsset(FxImpactTable **impactFx)
{
  ?Load_FxImpactTableAsset@@YAXPEAPEAUFxImpactTable@@@Z(impactFx);
}

/*
==============
Load_EnemySelectorAsset
==============
*/

void __fastcall Load_EnemySelectorAsset(EnemySelector **enemySelector)
{
  ?Load_EnemySelectorAsset@@YAXPEAPEAUEnemySelector@@@Z(enemySelector);
}

/*
==============
Load_CarryObjectDefAsset
==============
*/

void __fastcall Load_CarryObjectDefAsset(CarryObjectDef **carryObjectDef)
{
  ?Load_CarryObjectDefAsset@@YAXPEAPEAUCarryObjectDef@@@Z(carryObjectDef);
}

/*
==============
DB_GetGfxWorldTransientZoneAtIndex
==============
*/

GfxWorldTransientZone *__fastcall DB_GetGfxWorldTransientZoneAtIndex(unsigned int index)
{
  return ?DB_GetGfxWorldTransientZoneAtIndex@@YAAEAUGfxWorldTransientZone@@I@Z(index);
}

/*
==============
Load_HudOutlineDefAsset
==============
*/

void __fastcall Load_HudOutlineDefAsset(HudOutlineDef **hudOutlineDef)
{
  ?Load_HudOutlineDefAsset@@YAXPEAPEAUHudOutlineDef@@@Z(hudOutlineDef);
}

/*
==============
Load_XModelAsset
==============
*/

void __fastcall Load_XModelAsset(XModel **model)
{
  ?Load_XModelAsset@@YAXPEAPEAUXModel@@@Z(model);
}

/*
==============
Load_XCompositeModelDefAsset
==============
*/

void __fastcall Load_XCompositeModelDefAsset(XCompositeModelDef **compositeModel)
{
  ?Load_XCompositeModelDefAsset@@YAXPEAPEAUXCompositeModelDef@@@Z(compositeModel);
}

/*
==============
Load_MaterialTechniqueSetAsset
==============
*/

void __fastcall Load_MaterialTechniqueSetAsset(MaterialTechniqueSet **techniqueSet)
{
  ?Load_MaterialTechniqueSetAsset@@YAXPEAPEAUMaterialTechniqueSet@@@Z(techniqueSet);
}

/*
==============
Mark_AccessoryDefAsset
==============
*/

int __fastcall Mark_AccessoryDefAsset(AccessoryDef *accessoryDefAsset, int inuse)
{
  return ?Mark_AccessoryDefAsset@@YAHPEAUAccessoryDef@@H@Z(accessoryDefAsset, inuse);
}

/*
==============
Load_CameraDefAsset
==============
*/

void __fastcall Load_CameraDefAsset(CameraDef **cameraDef)
{
  ?Load_CameraDefAsset@@YAXPEAPEAUCameraDef@@@Z(cameraDef);
}

/*
==============
Load_LaserDefAsset
==============
*/

void __fastcall Load_LaserDefAsset(LaserDef **laserDef)
{
  ?Load_LaserDefAsset@@YAXPEAPEAULaserDef@@@Z(laserDef);
}

/*
==============
DB_AssetPool_GetItemIndex<Camo>
==============
*/

unsigned int __fastcall DB_AssetPool_GetItemIndex<Camo>(const XAssetType assetType, const Camo *ptr)
{
  return ??$DB_AssetPool_GetItemIndex@UCamo@@@@YAIW4XAssetType@@PEBUCamo@@@Z(assetType, ptr);
}

/*
==============
Mark_StringTableAsset
==============
*/

int __fastcall Mark_StringTableAsset(StringTable *stringTable, int inuse)
{
  return ?Mark_StringTableAsset@@YAHPEAUStringTable@@H@Z(stringTable, inuse);
}

/*
==============
Load_TerrainMesh
==============
*/

void __fastcall Load_TerrainMesh(StMesh *mesh, StTerrainNode *node)
{
  ?Load_TerrainMesh@@YAXPEAUStMesh@@PEAUStTerrainNode@@@Z(mesh, node);
}

/*
==============
Load_LeaderboardDefAsset
==============
*/

void __fastcall Load_LeaderboardDefAsset(LeaderboardDef **leaderboardDef)
{
  ?Load_LeaderboardDefAsset@@YAXPEAPEAULeaderboardDef@@@Z(leaderboardDef);
}

/*
==============
Load_PhysicsDebugData
==============
*/

void __fastcall Load_PhysicsDebugData(const DBStreamStart streamStart)
{
  ?Load_PhysicsDebugData@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_GfxWorldTransientZoneAsset
==============
*/

void __fastcall Load_GfxWorldTransientZoneAsset(GfxWorldTransientZone **transientZone)
{
  ?Load_GfxWorldTransientZoneAsset@@YAXPEAPEAUGfxWorldTransientZone@@@Z(transientZone);
}

/*
==============
DB_IsXModelSurfsInPool
==============
*/

bool __fastcall DB_IsXModelSurfsInPool(const XModelSurfs *modelSurfs)
{
  return ?DB_IsXModelSurfsInPool@@YA_NPEBUXModelSurfs@@@Z(modelSurfs);
}

/*
==============
Mark_ScriptFileAsset
==============
*/

int __fastcall Mark_ScriptFileAsset(ScriptFile *scriptfile, int inuse)
{
  return ?Mark_ScriptFileAsset@@YAHPEAUScriptFile@@H@Z(scriptfile, inuse);
}

/*
==============
Load_CoverSelectorAsset
==============
*/

void __fastcall Load_CoverSelectorAsset(CoverSelector **coverSelector)
{
  ?Load_CoverSelectorAsset@@YAXPEAPEAUCoverSelector@@@Z(coverSelector);
}

/*
==============
Load_BehaviorTreeAsset
==============
*/

void __fastcall Load_BehaviorTreeAsset(BehaviorTree **info)
{
  ?Load_BehaviorTreeAsset@@YAXPEAPEAUBehaviorTree@@@Z(info);
}

/*
==============
Load_GfxDecalVolumeMask
==============
*/

void __fastcall Load_GfxDecalVolumeMask(GfxDecalVolumeMask **asset)
{
  ?Load_GfxDecalVolumeMask@@YAXPEAPEAUGfxDecalVolumeMask@@@Z(asset);
}

/*
==============
DB_IsXModelInPool
==============
*/

bool __fastcall DB_IsXModelInPool(const XModel *model)
{
  return ?DB_IsXModelInPool@@YA_NPEBUXModel@@@Z(model);
}

/*
==============
Load_XModelSurfsAsset
==============
*/

void __fastcall Load_XModelSurfsAsset(XModelSurfs **modelSurfs)
{
  ?Load_XModelSurfsAsset@@YAXPEAPEAUXModelSurfs@@@Z(modelSurfs);
}

/*
==============
Load_XModelSurfsFixup
==============
*/

void __fastcall Load_XModelSurfsFixup(const XModelSurfs *const *modelSurfsPtrPtr, const XModel *model, XModelLodInfo *lodInfo)
{
  ?Load_XModelSurfsFixup@@YAXPEBQEBUXModelSurfs@@PEBUXModel@@PEAUXModelLodInfo@@@Z(modelSurfsPtrPtr, model, lodInfo);
}

/*
==============
Mark_ComputeShaderAsset
==============
*/

int __fastcall Mark_ComputeShaderAsset(ComputeShader *computeShader, int inuse)
{
  return ?Mark_ComputeShaderAsset@@YAHPEAUComputeShader@@H@Z(computeShader, inuse);
}

/*
==============
Mark_AddonMapEntsAsset
==============
*/

int __fastcall Mark_AddonMapEntsAsset(AddonMapEnts *addonMapEnts, int inuse)
{
  return ?Mark_AddonMapEntsAsset@@YAHPEAUAddonMapEnts@@H@Z(addonMapEnts, inuse);
}

/*
==============
GfxWorldTransientZoneDeferredRelease_TakeOwnership
==============
*/

bool __fastcall GfxWorldTransientZoneDeferredRelease_TakeOwnership(GfxWorldTransientZoneDeferredReleasePointers *dstPointers, unsigned int zoneIndex)
{
  return ?GfxWorldTransientZoneDeferredRelease_TakeOwnership@@YA_NAEAUGfxWorldTransientZoneDeferredReleasePointers@@I@Z(dstPointers, zoneIndex);
}

/*
==============
DB_InitXAssetPools
==============
*/

void DB_InitXAssetPools(void)
{
  ?DB_InitXAssetPools@@YAXXZ();
}

/*
==============
Mark_ComWorldAsset
==============
*/

int __fastcall Mark_ComWorldAsset(ComWorld *curComWorld, int inuse)
{
  return ?Mark_ComWorldAsset@@YAHPEAUComWorld@@H@Z(curComWorld, inuse);
}

/*
==============
Load_XCamAsset
==============
*/

void __fastcall Load_XCamAsset(XCam **xcam)
{
  ?Load_XCamAsset@@YAXPEAPEAUXCam@@@Z(xcam);
}

/*
==============
Mark_FxParticleSimAnimationAsset
==============
*/

int __fastcall Mark_FxParticleSimAnimationAsset(FxParticleSimAnimation *particleSimAnimation, int inuse)
{
  return ?Mark_FxParticleSimAnimationAsset@@YAHPEAUFxParticleSimAnimation@@H@Z(particleSimAnimation, inuse);
}

/*
==============
Load_ClipMapAsset
==============
*/

void __fastcall Load_ClipMapAsset(clipMap_t **clipMap)
{
  ?Load_ClipMapAsset@@YAXPEAPEAUclipMap_t@@@Z(clipMap);
}

/*
==============
Mark_ScriptDebugData
==============
*/

int __fastcall Mark_ScriptDebugData()
{
  return ?Mark_ScriptDebugData@@YAHXZ();
}

/*
==============
DB_ReleaseXAsset
==============
*/

void __fastcall DB_ReleaseXAsset(XAssetHeader header, XAssetType type, DB_ReleaseType releaseType)
{
  ?DB_ReleaseXAsset@@YAXTXAssetHeader@@W4XAssetType@@W4DB_ReleaseType@@@Z(header, type, releaseType);
}

/*
==============
Load_ScriptableDefAsset
==============
*/

void __fastcall Load_ScriptableDefAsset(ScriptableDef **scriptable)
{
  ?Load_ScriptableDefAsset@@YAXPEAPEAUScriptableDef@@@Z(scriptable);
}

/*
==============
Mark_StTerrainAsset
==============
*/

int __fastcall Mark_StTerrainAsset(StTerrain *terrain, int inuse)
{
  return ?Mark_StTerrainAsset@@YAHPEAUStTerrain@@H@Z(terrain, inuse);
}

/*
==============
Mark_TacticalGraphDataAsset
==============
*/

int __fastcall Mark_TacticalGraphDataAsset(TacticalGraphData *tacGraph, int inuse)
{
  return ?Mark_TacticalGraphDataAsset@@YAHPEAUTacticalGraphData@@H@Z(tacGraph, inuse);
}

/*
==============
Load_StreamingInfoAsset
==============
*/

void __fastcall Load_StreamingInfoAsset(StreamingInfo **streamingInfoPtr)
{
  ?Load_StreamingInfoAsset@@YAXPEAPEAUStreamingInfo@@@Z(streamingInfoPtr);
}

/*
==============
Mark_MaterialSerializedShaderAsset
==============
*/

int __fastcall Mark_MaterialSerializedShaderAsset(MaterialSerializedShader *serializedShader, int inuse)
{
  return ?Mark_MaterialSerializedShaderAsset@@YAHPEAUMaterialSerializedShader@@H@Z(serializedShader, inuse);
}

/*
==============
Mark_CamoAsset
==============
*/

int __fastcall Mark_CamoAsset(Camo *camo, int inuse)
{
  return ?Mark_CamoAsset@@YAHPEAUCamo@@H@Z(camo, inuse);
}

/*
==============
Mark_WeaponCompleteDefAsset
==============
*/

int __fastcall Mark_WeaponCompleteDefAsset(WeaponCompleteDef *weapon, int inuse)
{
  return ?Mark_WeaponCompleteDefAsset@@YAHPEAUWeaponCompleteDef@@H@Z(weapon, inuse);
}

/*
==============
Mark_PlayerAnimScriptAsset
==============
*/

int __fastcall Mark_PlayerAnimScriptAsset(PlayerAnimScript *playerAnimScript, int inuse)
{
  return ?Mark_PlayerAnimScriptAsset@@YAHPEAUPlayerAnimScript@@H@Z(playerAnimScript, inuse);
}

/*
==============
Mark_NetConstStringsAsset
==============
*/

int __fastcall Mark_NetConstStringsAsset(NetConstStrings *netConstStrings, int inuse)
{
  return ?Mark_NetConstStringsAsset@@YAHPEAUNetConstStrings@@H@Z(netConstStrings, inuse);
}

/*
==============
Mark_ScriptBundleAsset
==============
*/

int __fastcall Mark_ScriptBundleAsset(ScriptBundle *scriptBundle, int inuse)
{
  return ?Mark_ScriptBundleAsset@@YAHPEAUScriptBundle@@H@Z(scriptBundle, inuse);
}

/*
==============
DB_GetGfxImageIndex
==============
*/

unsigned int __fastcall DB_GetGfxImageIndex(const GfxImage *image)
{
  return ?DB_GetGfxImageIndex@@YAIPEBUGfxImage@@@Z(image);
}

/*
==============
Load_LocalizeEntryAsset
==============
*/

void __fastcall Load_LocalizeEntryAsset(LocalizeEntry **localize)
{
  ?Load_LocalizeEntryAsset@@YAXPEAPEAULocalizeEntry@@@Z(localize);
}

/*
==============
Load_ParticleSystemDefAsset
==============
*/

void __fastcall Load_ParticleSystemDefAsset(ParticleSystemDef **vfx)
{
  ?Load_ParticleSystemDefAsset@@YAXPEAPEAUParticleSystemDef@@@Z(vfx);
}

/*
==============
Mark_SuitAnimPackageAsset
==============
*/

int __fastcall Mark_SuitAnimPackageAsset(SuitAnimPackage *suitAnimPackage, int inuse)
{
  return ?Mark_SuitAnimPackageAsset@@YAHPEAUSuitAnimPackage@@H@Z(suitAnimPackage, inuse);
}

/*
==============
DB_AssetPool_GetItemIndex<FxWorldTransientZone>
==============
*/

unsigned int __fastcall DB_AssetPool_GetItemIndex<FxWorldTransientZone>(const XAssetType assetType, const FxWorldTransientZone *ptr)
{
  return ??$DB_AssetPool_GetItemIndex@UFxWorldTransientZone@@@@YAIW4XAssetType@@PEBUFxWorldTransientZone@@@Z(assetType, ptr);
}

/*
==============
Mark_LeaderboardDefAsset
==============
*/

int __fastcall Mark_LeaderboardDefAsset(LeaderboardDef *leaderboardDef, int inuse)
{
  return ?Mark_LeaderboardDefAsset@@YAHPEAULeaderboardDef@@H@Z(leaderboardDef, inuse);
}

/*
==============
Load_AnimsetAsset
==============
*/

void __fastcall Load_AnimsetAsset(Animset **info)
{
  ?Load_AnimsetAsset@@YAXPEAPEAUAnimset@@@Z(info);
}

/*
==============
GfxWorldTransientZoneDeferredRelease_Release
==============
*/

void __fastcall GfxWorldTransientZoneDeferredRelease_Release(GfxWorldTransientZoneDeferredReleasePointers *pointers)
{
  ?GfxWorldTransientZoneDeferredRelease_Release@@YAXAEAUGfxWorldTransientZoneDeferredReleasePointers@@@Z(pointers);
}

/*
==============
Load_SurfaceFxTableAsset
==============
*/

void __fastcall Load_SurfaceFxTableAsset(SurfaceFxTable **surfaceFx)
{
  ?Load_SurfaceFxTableAsset@@YAXPEAPEAUSurfaceFxTable@@@Z(surfaceFx);
}

/*
==============
DB_GetCamoIndex
==============
*/

unsigned int __fastcall DB_GetCamoIndex(const Camo *camo)
{
  return ?DB_GetCamoIndex@@YAIPEBUCamo@@@Z(camo);
}

/*
==============
Load_DLogSchemaAsset
==============
*/

void __fastcall Load_DLogSchemaAsset(DLogSchema **dlogSchema)
{
  ?Load_DLogSchemaAsset@@YAXPEAPEAUDLogSchema@@@Z(dlogSchema);
}

/*
==============
Load_GlassWorldAsset
==============
*/

void __fastcall Load_GlassWorldAsset(GlassWorld **curGlassWorld)
{
  ?Load_GlassWorldAsset@@YAXPEAPEAUGlassWorld@@@Z(curGlassWorld);
}

/*
==============
DB_CopyXAsset
==============
*/

void __fastcall DB_CopyXAsset(XAssetHeader from, XAssetHeader to, XAssetType type, const char *toAssetNewName)
{
  ?DB_CopyXAsset@@YAXTXAssetHeader@@0W4XAssetType@@PEBD@Z(from, to, type, toAssetNewName);
}

/*
==============
Mark_VehicleDefAsset
==============
*/

int __fastcall Mark_VehicleDefAsset(VehicleDef *vehDef, int inuse)
{
  return ?Mark_VehicleDefAsset@@YAHPEAUVehicleDef@@H@Z(vehDef, inuse);
}

/*
==============
DB_CreateXAsset
==============
*/

void __fastcall DB_CreateXAsset(XAssetHeader header, XAssetType type, DB_CreateType createType)
{
  ?DB_CreateXAsset@@YAXTXAssetHeader@@W4XAssetType@@W4DB_CreateType@@@Z(header, type, createType);
}

/*
==============
Load_PhysicsSFXEventAsset
==============
*/

void __fastcall Load_PhysicsSFXEventAsset(PhysicsSFXEventAsset **physicsSFXEventAsset)
{
  ?Load_PhysicsSFXEventAsset@@YAXPEAPEAUPhysicsSFXEventAsset@@@Z(physicsSFXEventAsset);
}

/*
==============
Load_StringTableAsset
==============
*/

void __fastcall Load_StringTableAsset(StringTable **stringTable)
{
  ?Load_StringTableAsset@@YAXPEAPEAUStringTable@@@Z(stringTable);
}

/*
==============
Postload_StreamingInfoAsset
==============
*/

void __fastcall Postload_StreamingInfoAsset(StreamingInfo **streamingInfoPtr)
{
  ?Postload_StreamingInfoAsset@@YAXPEAPEAUStreamingInfo@@@Z(streamingInfoPtr);
}

/*
==============
DB_MoveXAsset
==============
*/

void __fastcall DB_MoveXAsset(XAssetHeader from, XAssetHeader to, XAssetType type, DB_ReleaseType toReleaseType)
{
  ?DB_MoveXAsset@@YAXTXAssetHeader@@0W4XAssetType@@W4DB_ReleaseType@@@Z(from, to, type, toReleaseType);
}

/*
==============
Mark_XAnimPartsAsset
==============
*/

int __fastcall Mark_XAnimPartsAsset(XAnimParts *parts, int inuse)
{
  return ?Mark_XAnimPartsAsset@@YAHPEAUXAnimParts@@H@Z(parts, inuse);
}

/*
==============
Mark_MaterialTechniqueSetAsset
==============
*/

int __fastcall Mark_MaterialTechniqueSetAsset(MaterialTechniqueSet *techniqueSet, int inuse)
{
  return ?Mark_MaterialTechniqueSetAsset@@YAHPEAUMaterialTechniqueSet@@H@Z(techniqueSet, inuse);
}

/*
==============
Load_FogSplineAsset
==============
*/

void __fastcall Load_FogSplineAsset(GfxFogSpline **fogSpline)
{
  ?Load_FogSplineAsset@@YAXPEAPEAUGfxFogSpline@@@Z(fogSpline);
}

/*
==============
Load_SuitDefAsset
==============
*/

void __fastcall Load_SuitDefAsset(SuitDef **suitDef)
{
  ?Load_SuitDefAsset@@YAXPEAPEAUSuitDef@@@Z(suitDef);
}

/*
==============
Load_MapEdgeList
==============
*/

void __fastcall Load_MapEdgeList(MapEdgeList **mapEdgeListPtr)
{
  ?Load_MapEdgeList@@YAXPEAPEAUMapEdgeList@@@Z(mapEdgeListPtr);
}

/*
==============
Load_MapEdgeList
==============
*/

void __fastcall Load_MapEdgeList(const DBStreamStart streamStart)
{
  ?Load_MapEdgeList@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_PlayerAnimScriptAsset
==============
*/

void __fastcall Load_PlayerAnimScriptAsset(PlayerAnimScript **playerAnimScript)
{
  ?Load_PlayerAnimScriptAsset@@YAXPEAPEAUPlayerAnimScript@@@Z(playerAnimScript);
}

/*
==============
Load_ExecutionDefAsset
==============
*/

void __fastcall Load_ExecutionDefAsset(ExecutionDef **executionDef)
{
  ?Load_ExecutionDefAsset@@YAXPEAPEAUExecutionDef@@@Z(executionDef);
}

/*
==============
Mark_PhysicsFXShapeAsset
==============
*/

int __fastcall Mark_PhysicsFXShapeAsset(PhysicsFXShape *physicsFXShape, int inuse)
{
  return ?Mark_PhysicsFXShapeAsset@@YAHPEAUPhysicsFXShape@@H@Z(physicsFXShape, inuse);
}

/*
==============
Load_LocDmgTableAsset
==============
*/

void __fastcall Load_LocDmgTableAsset(LocDmgTable **locDmgTable)
{
  ?Load_LocDmgTableAsset@@YAXPEAPEAULocDmgTable@@@Z(locDmgTable);
}

/*
==============
DB_GetStreamKeyIndex
==============
*/

unsigned int __fastcall DB_GetStreamKeyIndex(const StreamKey *key)
{
  return ?DB_GetStreamKeyIndex@@YAIPEBUStreamKey@@@Z(key);
}

/*
==============
Mark_ParticleSystemDefAsset
==============
*/

int __fastcall Mark_ParticleSystemDefAsset(ParticleSystemDef *vfx, int inuse)
{
  return ?Mark_ParticleSystemDefAsset@@YAHPEAUParticleSystemDef@@H@Z(vfx, inuse);
}

/*
==============
Mark_TracerDefAsset
==============
*/

int __fastcall Mark_TracerDefAsset(TracerDef *tracerDef, int inuse)
{
  return ?Mark_TracerDefAsset@@YAHPEAUTracerDef@@H@Z(tracerDef, inuse);
}

/*
==============
Mark_XAnimCurveAsset
==============
*/

int __fastcall Mark_XAnimCurveAsset(XAnimCurve *curve, int inuse)
{
  return ?Mark_XAnimCurveAsset@@YAHPEAUXAnimCurve@@H@Z(curve, inuse);
}

/*
==============
DB_ReleaseSuperTerrain
==============
*/

void __fastcall DB_ReleaseSuperTerrain(XAssetHeader header, DB_ReleaseType releaseType)
{
  ?DB_ReleaseSuperTerrain@@YAXTXAssetHeader@@W4DB_ReleaseType@@@Z(header, releaseType);
}

/*
==============
DB_FreeXAssetHeader
==============
*/

void __fastcall DB_FreeXAssetHeader(XAssetType type, XAssetHeader header)
{
  ?DB_FreeXAssetHeader@@YAXW4XAssetType@@TXAssetHeader@@@Z(type, header);
}

/*
==============
Load_RumbleInfoAsset
==============
*/

void __fastcall Load_RumbleInfoAsset(RumbleInfo **info)
{
  ?Load_RumbleInfoAsset@@YAXPEAPEAURumbleInfo@@@Z(info);
}

/*
==============
DB_PopSuppressMaterialSort
==============
*/

void DB_PopSuppressMaterialSort(void)
{
  ?DB_PopSuppressMaterialSort@@YAXXZ();
}

/*
==============
Load_XModelDetailCollisionAsset
==============
*/

void __fastcall Load_XModelDetailCollisionAsset(XModelDetailCollision **detailCollision)
{
  ?Load_XModelDetailCollisionAsset@@YAXPEAPEAUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
Load_WeaponAnimPackageAsset
==============
*/

void __fastcall Load_WeaponAnimPackageAsset(WeaponAnimPackage **info)
{
  ?Load_WeaponAnimPackageAsset@@YAXPEAPEAUWeaponAnimPackage@@@Z(info);
}

/*
==============
DB_AssetPool_GetItemIndex<GfxWorldTransientZone>
==============
*/

unsigned int __fastcall DB_AssetPool_GetItemIndex<GfxWorldTransientZone>(const XAssetType assetType, const GfxWorldTransientZone *ptr)
{
  return ??$DB_AssetPool_GetItemIndex@UGfxWorldTransientZone@@@@YAIW4XAssetType@@PEBUGfxWorldTransientZone@@@Z(assetType, ptr);
}

/*
==============
Mark_RumbleGraphAsset
==============
*/

int __fastcall Mark_RumbleGraphAsset(RumbleGraph *info, int inuse)
{
  return ?Mark_RumbleGraphAsset@@YAHPEAURumbleGraph@@H@Z(info, inuse);
}

/*
==============
Mark_PhysicsLibraryAsset
==============
*/

int __fastcall Mark_PhysicsLibraryAsset(PhysicsLibrary *physicsLibrary, int inuse)
{
  return ?Mark_PhysicsLibraryAsset@@YAHPEAUPhysicsLibrary@@H@Z(physicsLibrary, inuse);
}

/*
==============
Mark_SuitDefAsset
==============
*/

int __fastcall Mark_SuitDefAsset(SuitDef *suitDef, int inuse)
{
  return ?Mark_SuitDefAsset@@YAHPEAUSuitDef@@H@Z(suitDef, inuse);
}

/*
==============
Load_AsmAsset
==============
*/

void __fastcall Load_AsmAsset(ASM **info)
{
  ?Load_AsmAsset@@YAXPEAPEAUASM@@@Z(info);
}

/*
==============
Load_DynEntityList
==============
*/

void __fastcall Load_DynEntityList(const DBStreamStart streamStart)
{
  ?Load_DynEntityList@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
DB_GetPoolSize
==============
*/

unsigned int __fastcall DB_GetPoolSize(XAssetType type)
{
  return ?DB_GetPoolSize@@YAIW4XAssetType@@@Z(type);
}

/*
==============
DB_GetDecalVolumeMaskAtIndex
==============
*/

GfxDecalVolumeMask *__fastcall DB_GetDecalVolumeMaskAtIndex(unsigned int index)
{
  return ?DB_GetDecalVolumeMaskAtIndex@@YAPEAUGfxDecalVolumeMask@@I@Z(index);
}

/*
==============
Load_EquipmentSoundTableAsset
==============
*/

void __fastcall Load_EquipmentSoundTableAsset(EquipmentSoundTable **equipmentSndTable)
{
  ?Load_EquipmentSoundTableAsset@@YAXPEAPEAUEquipmentSoundTable@@@Z(equipmentSndTable);
}

/*
==============
DB_MoveXAssetDefault
==============
*/

void __fastcall DB_MoveXAssetDefault(XAssetHeader from, XAssetHeader to, XAssetType type, DB_ReleaseType toReleaseType)
{
  ?DB_MoveXAssetDefault@@YAXTXAssetHeader@@0W4XAssetType@@W4DB_ReleaseType@@@Z(from, to, type, toReleaseType);
}

/*
==============
Load_GfxDecalVolumeMaterial
==============
*/

void __fastcall Load_GfxDecalVolumeMaterial(const DBStreamStart streamStart)
{
  ?Load_GfxDecalVolumeMaterial@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_SndBankTransientAsset
==============
*/

void __fastcall Postload_SndBankTransientAsset(SndBankTransient **sndBank)
{
  ?Postload_SndBankTransientAsset@@YAXPEAPEAUSndBankTransient@@@Z(sndBank);
}

/*
==============
Load_WeaponVFXPackageAsset
==============
*/

void __fastcall Load_WeaponVFXPackageAsset(WeaponVFXPackage **info)
{
  ?Load_WeaponVFXPackageAsset@@YAXPEAPEAUWeaponVFXPackage@@@Z(info);
}

/*
==============
Load_StreamKeyAsset
==============
*/

void __fastcall Load_StreamKeyAsset(StreamKey **key)
{
  ?Load_StreamKeyAsset@@YAXPEAPEAUStreamKey@@@Z(key);
}

/*
==============
Mark_AnimsetAsset
==============
*/

int __fastcall Mark_AnimsetAsset(Animset *info, int inuse)
{
  return ?Mark_AnimsetAsset@@YAHPEAUAnimset@@H@Z(info, inuse);
}

/*
==============
Mark_ClipMapAsset
==============
*/

int __fastcall Mark_ClipMapAsset(clipMap_t *clipMap, int inuse)
{
  return ?Mark_ClipMapAsset@@YAHPEAUclipMap_t@@H@Z(clipMap, inuse);
}

/*
==============
Mark_GfxDecalVolumeMask
==============
*/

int __fastcall Mark_GfxDecalVolumeMask()
{
  return ?Mark_GfxDecalVolumeMask@@YAHXZ();
}

/*
==============
Mark_PhysicsSFXEventAsset
==============
*/

int __fastcall Mark_PhysicsSFXEventAsset()
{
  return ?Mark_PhysicsSFXEventAsset@@YAHXZ();
}

/*
==============
Load_DDLAsset
==============
*/

void __fastcall Load_DDLAsset(DDLFile **ddlFile)
{
  ?Load_DDLAsset@@YAXPEAPEAUDDLFile@@@Z(ddlFile);
}

/*
==============
Mark_PhysicsAsset
==============
*/

int __fastcall Mark_PhysicsAsset(PhysicsAsset *physicsAsset, int inuse)
{
  return ?Mark_PhysicsAsset@@YAHPEAUPhysicsAsset@@H@Z(physicsAsset, inuse);
}

/*
==============
Mark_PhysicsDebugData
==============
*/

int __fastcall Mark_PhysicsDebugData(PhysicsDebugData *physicsDebugData, int inuse)
{
  return ?Mark_PhysicsDebugData@@YAHPEAUPhysicsDebugData@@H@Z(physicsDebugData, inuse);
}

/*
==============
DB_AssetPool_GetItemIndex<StreamingInfo>
==============
*/

unsigned int __fastcall DB_AssetPool_GetItemIndex<StreamingInfo>(const XAssetType assetType, const StreamingInfo *ptr)
{
  return ??$DB_AssetPool_GetItemIndex@UStreamingInfo@@@@YAIW4XAssetType@@PEBUStreamingInfo@@@Z(assetType, ptr);
}

/*
==============
Mark_XModelAsset
==============
*/

int __fastcall Mark_XModelAsset(XModel *model, int inuse)
{
  return ?Mark_XModelAsset@@YAHPEAUXModel@@H@Z(model, inuse);
}

/*
==============
Load_MaterialAsset
==============
*/

void __fastcall Load_MaterialAsset(Material **material)
{
  ?Load_MaterialAsset@@YAXPEAPEAUMaterial@@@Z(material);
}

/*
==============
DB_ReleaseKeyValuePairs
==============
*/

void __fastcall DB_ReleaseKeyValuePairs(XAssetHeader header, DB_ReleaseType releaseType)
{
  ?DB_ReleaseKeyValuePairs@@YAXTXAssetHeader@@W4DB_ReleaseType@@@Z(header, releaseType);
}

/*
==============
Mark_GestureAsset
==============
*/

int __fastcall Mark_GestureAsset(Gesture *gesture, int inuse)
{
  return ?Mark_GestureAsset@@YAHPEAUGesture@@H@Z(gesture, inuse);
}

/*
==============
Mark_StreamKeyAsset
==============
*/

int __fastcall Mark_StreamKeyAsset(StreamKey *key, int inuse)
{
  return ?Mark_StreamKeyAsset@@YAHPEAUStreamKey@@H@Z(key, inuse);
}

/*
==============
Mark_PhysicsVFXEventAsset
==============
*/

int __fastcall Mark_PhysicsVFXEventAsset()
{
  return ?Mark_PhysicsVFXEventAsset@@YAHXZ();
}

/*
==============
Load_DynEntityList
==============
*/

void __fastcall Load_DynEntityList(DynEntityList **dynEntityListPtr)
{
  ?Load_DynEntityList@@YAXPEAPEAUDynEntityList@@@Z(dynEntityListPtr);
}

/*
==============
Mark_CollisionTileAsset
==============
*/

int __fastcall Mark_CollisionTileAsset(CollisionTile *collisionTile, int inuse)
{
  return ?Mark_CollisionTileAsset@@YAHPEAUCollisionTile@@H@Z(collisionTile, inuse);
}

/*
==============
Mark_BlendSpace2DDefAsset
==============
*/

int __fastcall Mark_BlendSpace2DDefAsset(BlendSpace2DDef *blendSpace2DDef, int inuse)
{
  return ?Mark_BlendSpace2DDefAsset@@YAHPEAUBlendSpace2DDef@@H@Z(blendSpace2DDef, inuse);
}

/*
==============
Mark_VectorFieldAsset
==============
*/

int __fastcall Mark_VectorFieldAsset(VectorField *vectorField, int inuse)
{
  return ?Mark_VectorFieldAsset@@YAHPEAUVectorField@@H@Z(vectorField, inuse);
}

/*
==============
Mark_SndBankTransientAsset
==============
*/

int __fastcall Mark_SndBankTransientAsset(SndBankTransient *sndBank, int inuse)
{
  return ?Mark_SndBankTransientAsset@@YAHPEAUSndBankTransient@@H@Z(sndBank, inuse);
}

/*
==============
Mark_PhysicsDebugData
==============
*/

int __fastcall Mark_PhysicsDebugData()
{
  return ?Mark_PhysicsDebugData@@YAHXZ();
}

/*
==============
DB_GetDecalVolumeMaterialIndex
==============
*/

unsigned int __fastcall DB_GetDecalVolumeMaterialIndex(const GfxDecalVolumeMaterial *material)
{
  return ?DB_GetDecalVolumeMaterialIndex@@YAIPEBUGfxDecalVolumeMaterial@@@Z(material);
}

/*
==============
Mark_GfxDecalVolumeMaterial
==============
*/

int __fastcall Mark_GfxDecalVolumeMaterial()
{
  return ?Mark_GfxDecalVolumeMaterial@@YAHXZ();
}

/*
==============
DB_GetFxWorldTransientZoneAtIndex
==============
*/

FxWorldTransientZone *__fastcall DB_GetFxWorldTransientZoneAtIndex(unsigned int index)
{
  return ?DB_GetFxWorldTransientZoneAtIndex@@YAAEAUFxWorldTransientZone@@I@Z(index);
}

/*
==============
Load_LuaFileAsset
==============
*/

void __fastcall Load_LuaFileAsset(LuaFile **luaFile)
{
  ?Load_LuaFileAsset@@YAXPEAPEAULuaFile@@@Z(luaFile);
}

/*
==============
DB_GetWeaponAttachmentAtIndex
==============
*/

WeaponAttachment *__fastcall DB_GetWeaponAttachmentAtIndex(unsigned __int16 attachmentIndex)
{
  return ?DB_GetWeaponAttachmentAtIndex@@YAPEAUWeaponAttachment@@G@Z(attachmentIndex);
}

/*
==============
Load_LightDefAsset
==============
*/

void __fastcall Load_LightDefAsset(GfxLightDef **lightDef)
{
  ?Load_LightDefAsset@@YAXPEAPEAUGfxLightDef@@@Z(lightDef);
}

/*
==============
Load_ComputeShaderAsset
==============
*/

void __fastcall Load_ComputeShaderAsset(ComputeShader **computeShader)
{
  ?Load_ComputeShaderAsset@@YAXPEAPEAUComputeShader@@@Z(computeShader);
}

/*
==============
Mark_DLogSchemaAsset
==============
*/

int __fastcall Mark_DLogSchemaAsset(DLogSchema *dlogSchema, int inuse)
{
  return ?Mark_DLogSchemaAsset@@YAHPEAUDLogSchema@@H@Z(dlogSchema, inuse);
}

/*
==============
Load_ScriptDebugData
==============
*/

void __fastcall Load_ScriptDebugData(const DBStreamStart streamStart)
{
  ?Load_ScriptDebugData@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_NavMeshDataAsset
==============
*/

int __fastcall Mark_NavMeshDataAsset(NavMeshData *navMesh, int inuse)
{
  return ?Mark_NavMeshDataAsset@@YAHPEAUNavMeshData@@H@Z(navMesh, inuse);
}

/*
==============
DB_GetXModelAtIndex
==============
*/

XModel *__fastcall DB_GetXModelAtIndex(unsigned int modelIndex)
{
  return ?DB_GetXModelAtIndex@@YAPEAUXModel@@I@Z(modelIndex);
}

/*
==============
Mark_MaterialAsset
==============
*/

int __fastcall Mark_MaterialAsset(Material *material, int inuse)
{
  return ?Mark_MaterialAsset@@YAHPEAUMaterial@@H@Z(material, inuse);
}

/*
==============
Mark_CarryObjectDefAsset
==============
*/

int __fastcall Mark_CarryObjectDefAsset(CarryObjectDef *carryObjectDef, int inuse)
{
  return ?Mark_CarryObjectDefAsset@@YAHPEAUCarryObjectDef@@H@Z(carryObjectDef, inuse);
}

/*
==============
Load_TTFAsset
==============
*/

void __fastcall Load_TTFAsset(TTFDef **ttf)
{
  ?Load_TTFAsset@@YAXPEAPEAUTTFDef@@@Z(ttf);
}

/*
==============
Mark_StreamingInfoAsset
==============
*/

int __fastcall Mark_StreamingInfoAsset(StreamingInfo *streamingInfo, int inuse)
{
  return ?Mark_StreamingInfoAsset@@YAHPEAUStreamingInfo@@H@Z(streamingInfo, inuse);
}

/*
==============
DB_AssetPool_Alloc
==============
*/

XAssetHeader __fastcall DB_AssetPool_Alloc(const XAssetType assetType)
{
  return ?DB_AssetPool_Alloc@@YA?ATXAssetHeader@@W4XAssetType@@@Z(assetType);
}

/*
==============
Load_WeaponSFXPackageAsset
==============
*/

void __fastcall Load_WeaponSFXPackageAsset(WeaponSFXPackage **info)
{
  ?Load_WeaponSFXPackageAsset@@YAXPEAPEAUWeaponSFXPackage@@@Z(info);
}

/*
==============
Load_WeaponAttachmentAsset
==============
*/

void __fastcall Load_WeaponAttachmentAsset(WeaponAttachment **attachment)
{
  ?Load_WeaponAttachmentAsset@@YAXPEAPEAUWeaponAttachment@@@Z(attachment);
}

/*
==============
GfxWorldTransientZoneDeferredRelease_PointerListSet
==============
*/

void __fastcall GfxWorldTransientZoneDeferredRelease_PointerListSet(GfxWorldTransientZoneDeferredReleasePointerList *list)
{
  ?GfxWorldTransientZoneDeferredRelease_PointerListSet@@YAXPEAUGfxWorldTransientZoneDeferredReleasePointerList@@@Z(list);
}

/*
==============
Mark_GfxDecalVolumeMask
==============
*/

int __fastcall Mark_GfxDecalVolumeMask(GfxDecalVolumeMask *asset, int inuse)
{
  return ?Mark_GfxDecalVolumeMask@@YAHPEAUGfxDecalVolumeMask@@H@Z(asset, inuse);
}

/*
==============
Load_AccessoryDefAsset
==============
*/

void __fastcall Load_AccessoryDefAsset(AccessoryDef **accessoryDefAsset)
{
  ?Load_AccessoryDefAsset@@YAXPEAPEAUAccessoryDef@@@Z(accessoryDefAsset);
}

/*
==============
Load_FxWorldTransientZoneAsset
==============
*/

void __fastcall Load_FxWorldTransientZoneAsset(FxWorldTransientZone **transientZone)
{
  ?Load_FxWorldTransientZoneAsset@@YAXPEAPEAUFxWorldTransientZone@@@Z(transientZone);
}

/*
==============
Load_PhysicsVFXEventAsset
==============
*/

void __fastcall Load_PhysicsVFXEventAsset(const DBStreamStart streamStart)
{
  ?Load_PhysicsVFXEventAsset@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_LuaFileAsset
==============
*/

int __fastcall Mark_LuaFileAsset(LuaFile *luaFile, int inuse)
{
  return ?Mark_LuaFileAsset@@YAHPEAULuaFile@@H@Z(luaFile, inuse);
}

/*
==============
Load_RumbleGraphAsset
==============
*/

void __fastcall Load_RumbleGraphAsset(RumbleGraph **rumbleGraph)
{
  ?Load_RumbleGraphAsset@@YAXPEAPEAURumbleGraph@@@Z(rumbleGraph);
}

/*
==============
Load_XAnimCurveAsset
==============
*/

void __fastcall Load_XAnimCurveAsset(XAnimCurve **curve)
{
  ?Load_XAnimCurveAsset@@YAXPEAPEAUXAnimCurve@@@Z(curve);
}

/*
==============
Load_GradingClutAsset
==============
*/

void __fastcall Load_GradingClutAsset(GfxGradingClut **gradingClut)
{
  ?Load_GradingClutAsset@@YAXPEAPEAUGfxGradingClut@@@Z(gradingClut);
}

/*
==============
Load_SuitAnimPackageAsset
==============
*/

void __fastcall Load_SuitAnimPackageAsset(SuitAnimPackage **suitAnimPackage)
{
  ?Load_SuitAnimPackageAsset@@YAXPEAPEAUSuitAnimPackage@@@Z(suitAnimPackage);
}

/*
==============
DB_GetXModelSurfsAtIndex
==============
*/

XModelSurfs *__fastcall DB_GetXModelSurfsAtIndex(unsigned int modelSurfsIndex)
{
  return ?DB_GetXModelSurfsAtIndex@@YAPEAUXModelSurfs@@I@Z(modelSurfsIndex);
}

/*
==============
Mark_XAnimDynamicBonesAsset
==============
*/

int __fastcall Mark_XAnimDynamicBonesAsset(XAnimDynamicBones *dynamicBones, int inuse)
{
  return ?Mark_XAnimDynamicBonesAsset@@YAHPEAUXAnimDynamicBones@@H@Z(dynamicBones, inuse);
}

/*
==============
Mark_StreamTreeOverrideAsset
==============
*/

int __fastcall Mark_StreamTreeOverrideAsset(StreamTreeOverride *treeOverride, int inuse)
{
  return ?Mark_StreamTreeOverrideAsset@@YAHPEAUStreamTreeOverride@@H@Z(treeOverride, inuse);
}

/*
==============
DB_GetCamoAtIndex
==============
*/

Camo *__fastcall DB_GetCamoAtIndex(unsigned int camoIndex)
{
  return ?DB_GetCamoAtIndex@@YAPEAUCamo@@I@Z(camoIndex);
}

/*
==============
Mark_TTFAsset
==============
*/

int __fastcall Mark_TTFAsset(TTFDef *ttf, int inuse)
{
  return ?Mark_TTFAsset@@YAHPEAUTTFDef@@H@Z(ttf, inuse);
}

/*
==============
Mark_VirtualLeaderboardDefAsset
==============
*/

int __fastcall Mark_VirtualLeaderboardDefAsset(VirtualLeaderboardDef *vlbDef, int inuse)
{
  return ?Mark_VirtualLeaderboardDefAsset@@YAHPEAUVirtualLeaderboardDef@@H@Z(vlbDef, inuse);
}

/*
==============
DB_GetDecalVolumeMaterialPool
==============
*/

const void *__fastcall DB_GetDecalVolumeMaterialPool()
{
  return ?DB_GetDecalVolumeMaterialPool@@YAPEBXXZ();
}

/*
==============
Load_MapEntsAsset
==============
*/

void __fastcall Load_MapEntsAsset(MapEnts **mapEnts)
{
  ?Load_MapEntsAsset@@YAXPEAPEAUMapEnts@@@Z(mapEnts);
}

/*
==============
Load_GfxDecalVolumeMask
==============
*/

void __fastcall Load_GfxDecalVolumeMask(const DBStreamStart streamStart)
{
  ?Load_GfxDecalVolumeMask@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
DB_AssetPool_GetItemIndex<GfxImage>
==============
*/

unsigned int __fastcall DB_AssetPool_GetItemIndex<GfxImage>(const XAssetType assetType, const GfxImage *ptr)
{
  return ??$DB_AssetPool_GetItemIndex@UGfxImage@@@@YAIW4XAssetType@@PEBUGfxImage@@@Z(assetType, ptr);
}

/*
==============
Mark_PhysicsVFXEventAsset
==============
*/

int __fastcall Mark_PhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset, int inuse)
{
  return ?Mark_PhysicsVFXEventAsset@@YAHPEAUPhysicsVFXEventAsset@@H@Z(physicsVFXEventAsset, inuse);
}

/*
==============
Load_BlendSpace2DDefAsset
==============
*/

void __fastcall Load_BlendSpace2DDefAsset(BlendSpace2DDef **blendSpace2DDef)
{
  ?Load_BlendSpace2DDefAsset@@YAXPEAPEAUBlendSpace2DDef@@@Z(blendSpace2DDef);
}

/*
==============
DB_SwapXAsset
==============
*/

void __fastcall DB_SwapXAsset(XAssetHeader from, XAssetHeader to, XAssetType type)
{
  ?DB_SwapXAsset@@YAXTXAssetHeader@@0W4XAssetType@@@Z(from, to, type);
}

/*
==============
Mark_MayhemDataAsset
==============
*/

int __fastcall Mark_MayhemDataAsset(MayhemData *mayhem, int inuse)
{
  return ?Mark_MayhemDataAsset@@YAHPEAUMayhemData@@H@Z(mayhem, inuse);
}

/*
==============
Mark_WeaponVFXPackageAsset
==============
*/

int __fastcall Mark_WeaponVFXPackageAsset(WeaponVFXPackage *info, int inuse)
{
  return ?Mark_WeaponVFXPackageAsset@@YAHPEAUWeaponVFXPackage@@H@Z(info, inuse);
}

/*
==============
DB_IsImageInPool
==============
*/

bool __fastcall DB_IsImageInPool(const GfxImage *image)
{
  return ?DB_IsImageInPool@@YA_NPEBUGfxImage@@@Z(image);
}

/*
==============
DB_GetDecalVolumeMaterialAtIndex
==============
*/

GfxDecalVolumeMaterial *__fastcall DB_GetDecalVolumeMaterialAtIndex(unsigned int index)
{
  return ?DB_GetDecalVolumeMaterialAtIndex@@YAPEAUGfxDecalVolumeMaterial@@I@Z(index);
}

/*
==============
Mark_BehaviorTreeAsset
==============
*/

int __fastcall Mark_BehaviorTreeAsset(BehaviorTree *info, int inuse)
{
  return ?Mark_BehaviorTreeAsset@@YAHPEAUBehaviorTree@@H@Z(info, inuse);
}

/*
==============
DB_ShutdownMaterialOverrides
==============
*/

void DB_ShutdownMaterialOverrides(void)
{
  ?DB_ShutdownMaterialOverrides@@YAXXZ();
}

/*
==============
Mark_EnemySelectorAsset
==============
*/

int __fastcall Mark_EnemySelectorAsset(EnemySelector *enemySelector, int inuse)
{
  return ?Mark_EnemySelectorAsset@@YAHPEAUEnemySelector@@H@Z(enemySelector, inuse);
}

/*
==============
DB_GetXCompositeModelIndex
==============
*/

unsigned int __fastcall DB_GetXCompositeModelIndex(const XCompositeModelDef *compositeModel)
{
  return ?DB_GetXCompositeModelIndex@@YAIPEBUXCompositeModelDef@@@Z(compositeModel);
}

/*
==============
Load_RawFileAsset
==============
*/

void __fastcall Load_RawFileAsset(RawFile **rawfile)
{
  ?Load_RawFileAsset@@YAXPEAPEAURawFile@@@Z(rawfile);
}

/*
==============
DB_GetStreamKeyAtIndex
==============
*/

StreamKey *__fastcall DB_GetStreamKeyAtIndex(unsigned int index)
{
  return ?DB_GetStreamKeyAtIndex@@YAPEAUStreamKey@@I@Z(index);
}

/*
==============
Mark_ClientCharacterAsset
==============
*/

int __fastcall Mark_ClientCharacterAsset(ClientCharacter *clientCharacter, int inuse)
{
  return ?Mark_ClientCharacterAsset@@YAHPEAUClientCharacter@@H@Z(clientCharacter, inuse);
}

/*
==============
Load_PathDataAsset
==============
*/

void __fastcall Load_PathDataAsset(PathData **curPathData)
{
  ?Load_PathDataAsset@@YAXPEAPEAUPathData@@@Z(curPathData);
}

/*
==============
Mark_NativeScriptPatchFileAsset
==============
*/

int __fastcall Mark_NativeScriptPatchFileAsset(NativeScriptPatchFile *patchFile, int inuse)
{
  return ?Mark_NativeScriptPatchFileAsset@@YAHPEAUNativeScriptPatchFile@@H@Z(patchFile, inuse);
}

/*
==============
Mark_RumbleInfoAsset
==============
*/

int __fastcall Mark_RumbleInfoAsset(RumbleInfo *info, int inuse)
{
  return ?Mark_RumbleInfoAsset@@YAHPEAURumbleInfo@@H@Z(info, inuse);
}

/*
==============
Mark_ScriptableDefAsset
==============
*/

int __fastcall Mark_ScriptableDefAsset(ScriptableDef *scriptable, int inuse)
{
  return ?Mark_ScriptableDefAsset@@YAHPEAUScriptableDef@@H@Z(scriptable, inuse);
}

/*
==============
Mark_XCamAsset
==============
*/

int __fastcall Mark_XCamAsset(XCam *xcam, int inuse)
{
  return ?Mark_XCamAsset@@YAHPEAUXCam@@H@Z(xcam, inuse);
}

/*
==============
Load_XAnimProceduralBonesAsset
==============
*/

void __fastcall Load_XAnimProceduralBonesAsset(XAnimProceduralBones **proceduralBones)
{
  ?Load_XAnimProceduralBonesAsset@@YAXPEAPEAUXAnimProceduralBones@@@Z(proceduralBones);
}

/*
==============
Load_SoundBankListDefAsset
==============
*/

void __fastcall Load_SoundBankListDefAsset(SoundBankListDef **soundBankListDef)
{
  ?Load_SoundBankListDefAsset@@YAXPEAPEAUSoundBankListDef@@@Z(soundBankListDef);
}

/*
==============
Load_CollisionTile
==============
*/

void __fastcall Load_CollisionTile(const DBStreamStart streamStart)
{
  ?Load_CollisionTile@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
DB_GetStreamingPoolBase
==============
*/

const StreamingInfo *__fastcall DB_GetStreamingPoolBase()
{
  return ?DB_GetStreamingPoolBase@@YAPEBUStreamingInfo@@XZ();
}

/*
==============
Mark_LocDmgTableAsset
==============
*/

int __fastcall Mark_LocDmgTableAsset(LocDmgTable *locDmgTable, int inuse)
{
  return ?Mark_LocDmgTableAsset@@YAHPEAULocDmgTable@@H@Z(locDmgTable, inuse);
}

/*
==============
Load_PhysicsSFXEventAsset
==============
*/
void Load_PhysicsSFXEventAsset(const DBStreamStart streamStart)
{
  const char **v2; 
  PhysicsSFXEventAssetRules *v3; 

  DB_PatchMem_PushAsset(1, varPhysicsSFXEventAsset);
  Load_Stream(streamStart, varPhysicsSFXEventAsset, 0x20ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varPhysicsSFXEventAsset->name;
  Load_XString(NotAtStart);
  varXString = v2;
  v3 = varPhysicsSFXEventAssetRules;
  varPhysicsSFXEventAssetRules = &varPhysicsSFXEventAsset->rules;
  Load_PhysicsSFXEventAssetRules(NotAtStart);
  varPhysicsSFXEventAssetRules = v3;
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Load_PhysicsVFXEventAsset
==============
*/
void Load_PhysicsVFXEventAsset(const DBStreamStart streamStart)
{
  const char **v2; 
  PhysicsVFXEventAssetRules *v3; 

  DB_PatchMem_PushAsset(2, varPhysicsVFXEventAsset);
  Load_Stream(streamStart, varPhysicsVFXEventAsset, 0x20ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varPhysicsVFXEventAsset->name;
  Load_XString(NotAtStart);
  varXString = v2;
  v3 = varPhysicsVFXEventAssetRules;
  varPhysicsVFXEventAssetRules = &varPhysicsVFXEventAsset->rules;
  Load_PhysicsVFXEventAssetRules(NotAtStart);
  varPhysicsVFXEventAssetRules = v3;
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Mark_PhysicsSFXEventAsset
==============
*/
__int64 Mark_PhysicsSFXEventAsset()
{
  return 1i64;
}

/*
==============
Mark_PhysicsVFXEventAsset
==============
*/
__int64 Mark_PhysicsVFXEventAsset()
{
  return 1i64;
}

/*
==============
Load_PhysicsAsset
==============
*/
void Load_PhysicsAsset(const DBStreamStart streamStart)
{
  const char **v2; 
  PhysicsAsset *v3; 
  char *v4; 
  PhysicsAssetSimulationCategory *v5; 
  unsigned int *v6; 
  unsigned int *uint; 
  PhysicsSFXEventAsset **v8; 
  PhysicsSFXEventAsset **PhysicsSFXEventAssetPtr; 
  PhysicsVFXEventAsset **v10; 
  PhysicsVFXEventAsset **PhysicsVFXEventAssetPtr; 

  DB_PatchMem_PushAsset(3, varPhysicsAsset);
  Load_Stream(streamStart, varPhysicsAsset, 0x58ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varPhysicsAsset->name;
  Load_XString(NotAtStart);
  v3 = varPhysicsAsset;
  varXString = v2;
  if ( varPhysicsAsset->havokData )
  {
    v4 = varalignHavokAssetData_t;
    DB_PatchMem_FixStreamAlignment(0xFui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->havokData = (char *)g_streamPosGlob.pos;
    varalignHavokAssetData_t = (char *)g_streamPosGlob.pos;
    Load_Stream(AtStart, g_streamPosGlob.pos, varPhysicsAsset->havokDataSize);
    v3 = varPhysicsAsset;
    varalignHavokAssetData_t = v4;
  }
  if ( v3->simulationCategories )
  {
    v5 = varPhysicsAssetSimulationCategory;
    DB_PatchMem_FixStreamAlignment(3ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->simulationCategories = (PhysicsAssetSimulationCategory *)g_streamPosGlob.pos;
    varPhysicsAssetSimulationCategory = (PhysicsAssetSimulationCategory *)g_streamPosGlob.pos;
    Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varPhysicsAsset->numRigidBodies);
    v3 = varPhysicsAsset;
    varPhysicsAssetSimulationCategory = v5;
  }
  if ( v3->bodyContents )
  {
    v6 = varuint;
    uint = AllocLoad_uint();
    v3->bodyContents = uint;
    varuint = uint;
    Load_uintArray(AtStart, varPhysicsAsset->numRigidBodies);
    v3 = varPhysicsAsset;
    varuint = v6;
  }
  if ( v3->sfxEventAssets )
  {
    v8 = varPhysicsSFXEventAssetPtr;
    PhysicsSFXEventAssetPtr = AllocLoad_PhysicsSFXEventAssetPtr();
    v3->sfxEventAssets = PhysicsSFXEventAssetPtr;
    varPhysicsSFXEventAssetPtr = PhysicsSFXEventAssetPtr;
    Load_PhysicsSFXEventAssetPtrArray(AtStart, varPhysicsAsset->numSFXEventAssets);
    v3 = varPhysicsAsset;
    varPhysicsSFXEventAssetPtr = v8;
  }
  if ( v3->vfxEventAssets )
  {
    v10 = varPhysicsVFXEventAssetPtr;
    PhysicsVFXEventAssetPtr = AllocLoad_PhysicsVFXEventAssetPtr();
    v3->vfxEventAssets = PhysicsVFXEventAssetPtr;
    varPhysicsVFXEventAssetPtr = PhysicsVFXEventAssetPtr;
    Load_PhysicsVFXEventAssetPtrArray(AtStart, varPhysicsAsset->numVFXEventAssets);
    varPhysicsVFXEventAssetPtr = v10;
  }
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Load_PhysicsDebugData
==============
*/
void Load_PhysicsDebugData(const DBStreamStart streamStart)
{
  const char **v2; 
  PhysicsWorldMeshDebugData *v3; 
  PhysicsDebugData *v4; 
  vec3_t *v5; 
  vec3_t *vec3_t; 
  char *v7; 
  char *v8; 
  float *v9; 
  float *v10; 
  vec3_t *v11; 
  vec3_t *v12; 
  char *v13; 
  char *v14; 
  float *v15; 
  float *v16; 

  DB_PatchMem_PushAsset(6, varPhysicsDebugData);
  Load_Stream(streamStart, varPhysicsDebugData, 0x138ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varPhysicsDebugData->name;
  Load_XString(NotAtStart);
  varXString = v2;
  v3 = varPhysicsWorldMeshDebugData;
  varPhysicsWorldMeshDebugData = &varPhysicsDebugData->worldMeshDebugData;
  Load_PhysicsWorldMeshDebugData(NotAtStart);
  v4 = varPhysicsDebugData;
  varPhysicsWorldMeshDebugData = v3;
  if ( varPhysicsDebugData->pmoveSamplePositions )
  {
    v5 = varvec3_t;
    vec3_t = AllocLoad_vec3_t();
    v4->pmoveSamplePositions = vec3_t;
    varvec3_t = vec3_t;
    Load_vec3_tArray(AtStart, varPhysicsDebugData->pmoveNumSamples);
    v4 = varPhysicsDebugData;
    varvec3_t = v5;
  }
  if ( v4->pmoveSampleHitCounts )
  {
    v7 = varchar;
    v8 = AllocLoad_char();
    v4->pmoveSampleHitCounts = v8;
    varchar = v8;
    Load_charArray(AtStart, varPhysicsDebugData->pmoveNumSamples);
    v4 = varPhysicsDebugData;
    varchar = v7;
  }
  if ( v4->pmoveSampleTimes )
  {
    v9 = varfloat;
    v10 = AllocLoad_float();
    v4->pmoveSampleTimes = v10;
    varfloat = v10;
    Load_floatArray(AtStart, varPhysicsDebugData->pmoveNumSamples);
    v4 = varPhysicsDebugData;
    varfloat = v9;
  }
  if ( v4->bulletSamplePositions )
  {
    v11 = varvec3_t;
    v12 = AllocLoad_vec3_t();
    v4->bulletSamplePositions = v12;
    varvec3_t = v12;
    Load_vec3_tArray(AtStart, varPhysicsDebugData->bulletNumSamples);
    v4 = varPhysicsDebugData;
    varvec3_t = v11;
  }
  if ( v4->bulletSampleHitCounts )
  {
    v13 = varchar;
    v14 = AllocLoad_char();
    v4->bulletSampleHitCounts = v14;
    varchar = v14;
    Load_charArray(AtStart, varPhysicsDebugData->bulletNumSamples);
    v4 = varPhysicsDebugData;
    varchar = v13;
  }
  if ( v4->bulletSampleAverageTimes )
  {
    v15 = varfloat;
    v16 = AllocLoad_float();
    v4->bulletSampleAverageTimes = v16;
    varfloat = v16;
    Load_floatArray(AtStart, varPhysicsDebugData->bulletNumSamples);
    varfloat = v15;
  }
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Mark_PhysicsAsset
==============
*/
__int64 Mark_PhysicsAsset()
{
  PhysicsAsset *v0; 
  PhysicsSFXEventAsset **v1; 
  int v2; 
  PhysicsVFXEventAsset **v3; 
  int v4; 

  v0 = marPhysicsAsset;
  if ( marPhysicsAsset->sfxEventAssets )
  {
    v1 = marPhysicsSFXEventAssetPtr;
    marPhysicsSFXEventAssetPtr = marPhysicsAsset->sfxEventAssets;
    v2 = Mark_PhysicsSFXEventAssetPtrArray(marPhysicsAsset->numSFXEventAssets);
    marPhysicsSFXEventAssetPtr = v1;
    if ( !v2 )
      return 0i64;
    v0 = marPhysicsAsset;
  }
  if ( v0->vfxEventAssets )
  {
    v3 = marPhysicsVFXEventAssetPtr;
    marPhysicsVFXEventAssetPtr = v0->vfxEventAssets;
    v4 = Mark_PhysicsVFXEventAssetPtrArray(v0->numVFXEventAssets);
    marPhysicsVFXEventAssetPtr = v3;
    if ( !v4 )
      return 0i64;
  }
  return 1i64;
}

/*
==============
Mark_PhysicsDebugData
==============
*/
__int64 Mark_PhysicsDebugData()
{
  return 1i64;
}

/*
==============
Load_ScriptDebugData
==============
*/
void Load_ScriptDebugData(const DBStreamStart streamStart)
{
  const char **v2; 
  ScriptDebugData *v3; 
  ScriptDebugDataProfileString *profileStrings; 
  ScriptDebugDataProfileString *v5; 
  __int64 profileStringCount; 
  ScriptDebugDataProfileString *i; 
  const char **v8; 

  DB_PatchMem_PushAsset(49, varScriptDebugData);
  Load_Stream(streamStart, varScriptDebugData, 0x18ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varScriptDebugData->name;
  Load_XString(NotAtStart);
  varXString = v2;
  v3 = varScriptDebugData;
  profileStrings = varScriptDebugData->profileStrings;
  if ( profileStrings )
  {
    if ( profileStrings == (ScriptDebugDataProfileString *)-1i64 )
    {
      DB_PushSharedData();
    }
    else if ( profileStrings != (ScriptDebugDataProfileString *)-2i64 )
    {
      v3->profileStrings = (ScriptDebugDataProfileString *)DB_ResolvePackedOffsetAddress((const unsigned __int64)varScriptDebugData->profileStrings);
      goto LABEL_10;
    }
    v5 = varScriptDebugDataProfileString;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->profileStrings = (ScriptDebugDataProfileString *)g_streamPosGlob.pos;
    varScriptDebugDataProfileString = (ScriptDebugDataProfileString *)g_streamPosGlob.pos;
    profileStringCount = varScriptDebugData->profileStringCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 8 * profileStringCount);
    for ( i = varScriptDebugDataProfileString; profileStringCount; --profileStringCount )
    {
      varScriptDebugDataProfileString = i;
      Load_Stream(NotAtStart, i, 8ui64);
      v8 = varXString;
      varXString = &varScriptDebugDataProfileString->profileString;
      Load_XString(NotAtStart);
      ++i;
      varXString = v8;
    }
    varScriptDebugDataProfileString = v5;
    if ( profileStrings == (ScriptDebugDataProfileString *)-1i64 )
      DB_PopSharedData();
  }
LABEL_10:
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Mark_ScriptDebugData
==============
*/
__int64 Mark_ScriptDebugData()
{
  return 1i64;
}

/*
==============
Load_CollisionTile
==============
*/
void Load_CollisionTile(const DBStreamStart streamStart)
{
  const char **v2; 
  CollisionTile *v3; 
  StaticModelCollisionCompressedModelList *v4; 
  char *v5; 
  char *v6; 
  char *v7; 

  DB_PatchMem_PushAsset(103, varCollisionTile);
  Load_Stream(streamStart, varCollisionTile, 0x48ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varCollisionTile->name;
  Load_XString(NotAtStart);
  v3 = varCollisionTile;
  varXString = v2;
  if ( varCollisionTile->staticModelCollision )
  {
    v4 = varStaticModelCollisionCompressedModelList;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->staticModelCollision = (StaticModelCollisionCompressedModelList *)g_streamPosGlob.pos;
    varStaticModelCollisionCompressedModelList = (StaticModelCollisionCompressedModelList *)g_streamPosGlob.pos;
    Load_StaticModelCollisionCompressedModelList(AtStart);
    v3 = varCollisionTile;
    varStaticModelCollisionCompressedModelList = v4;
  }
  if ( v3->havokTileShapeData )
  {
    v5 = varalignHavokShapeData_t;
    DB_PatchMem_FixStreamAlignment(0xFui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->havokTileShapeData = (char *)g_streamPosGlob.pos;
    varalignHavokShapeData_t = (char *)g_streamPosGlob.pos;
    Load_Stream(AtStart, g_streamPosGlob.pos, varCollisionTile->havokTileShapeDataSize);
    v3 = varCollisionTile;
    varalignHavokShapeData_t = v5;
  }
  if ( v3->havokTileShapePointer )
  {
    v6 = varchar;
    v7 = AllocLoad_char();
    v3->havokTileShapePointer = v7;
    varchar = v7;
    Load_char(AtStart);
    varchar = v6;
  }
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Load_DynEntityList
==============
*/
void Load_DynEntityList(const DBStreamStart streamStart)
{
  const char **v2; 
  DynEntityList *v3; 
  DynEntityDef *v4; 
  DynEntityDef *DynEntityDef; 
  DynEntityDef *v6; 
  SpatialPartition_TransientPopulation **v7; 

  DB_PatchMem_PushAsset(109, varDynEntityList);
  Load_Stream(streamStart, varDynEntityList, 0x40ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varDynEntityList->name;
  Load_XString(NotAtStart);
  v3 = varDynEntityList;
  varXString = v2;
  v4 = varDynEntityDef;
  if ( varDynEntityList->dynEntDefList[0] )
  {
    DynEntityDef = AllocLoad_DynEntityDef();
    v3->dynEntDefList[0] = DynEntityDef;
    varDynEntityDef = DynEntityDef;
    Load_DynEntityDefArray(AtStart, varDynEntityList->dynEntCount[0]);
    v3 = varDynEntityList;
    varDynEntityDef = v4;
  }
  if ( v3->dynEntDefList[1] )
  {
    v6 = AllocLoad_DynEntityDef();
    v3->dynEntDefList[1] = v6;
    varDynEntityDef = v6;
    Load_DynEntityDefArray(AtStart, varDynEntityList->dynEntCount[1]);
    v3 = varDynEntityList;
    varDynEntityDef = v4;
  }
  v7 = varSpatialPartition_TransientPopulationPtr;
  varSpatialPartition_TransientPopulationPtr = v3->dynEntSpatialPopulation;
  Load_SpatialPartition_TransientPopulationPtrArray(NotAtStart, 2ui64);
  varSpatialPartition_TransientPopulationPtr = v7;
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Load_GfxDecalVolumeMask
==============
*/
void Load_GfxDecalVolumeMask(const DBStreamStart streamStart)
{
  const char **v2; 
  GfxImage **v3; 

  DB_PatchMem_PushAsset(108, varGfxDecalVolumeMask);
  Load_Stream(streamStart, varGfxDecalVolumeMask, 0x10ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varGfxDecalVolumeMask->name;
  Load_XString(NotAtStart);
  varXString = v2;
  v3 = varGfxImagePtr;
  varGfxImagePtr = &varGfxDecalVolumeMask->blendMap;
  Load_GfxImagePtr(NotAtStart);
  varGfxImagePtr = v3;
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Load_GfxDecalVolumeMaterial
==============
*/
void Load_GfxDecalVolumeMaterial(const DBStreamStart streamStart)
{
  const char **v2; 
  GfxImage **v3; 

  DB_PatchMem_PushAsset(107, varGfxDecalVolumeMaterial);
  Load_Stream(streamStart, varGfxDecalVolumeMaterial, 0x68ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varGfxDecalVolumeMaterial->name;
  Load_XString(NotAtStart);
  varXString = v2;
  v3 = varGfxImagePtr;
  varGfxImagePtr = varGfxDecalVolumeMaterial->channels;
  Load_GfxImagePtrArray(NotAtStart, 6ui64);
  varGfxImagePtr = v3;
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Load_MapEdgeList
==============
*/
void Load_MapEdgeList(const DBStreamStart streamStart)
{
  const char **v2; 
  MapEdgeList *v3; 
  float4 (*v4)[2]; 
  float4 (*lineSegmentFloat4_t)[2]; 
  FlaggedEdgeMetadata *v6; 
  FlaggedEdgeMetadata *FlaggedEdgeMetadata; 
  PMROctreeMetadata *v8; 
  PMROctreeMetadata *PMROctreeMetadata; 
  PMROctreeNodeSet *v10; 
  PMROctreeNodeSet *PMROctreeNodeSet; 
  unsigned int *v12; 
  unsigned int *EdgeIndex; 
  EdgeAdjacencyMetadata *v14; 
  EdgeAdjacencyMetadata *EdgeAdjacencyMetadata; 
  EdgeAdjacency *v16; 
  EdgeAdjacency *EdgeAdjacency; 

  DB_PatchMem_PushAsset(112, varMapEdgeList);
  Load_Stream(streamStart, varMapEdgeList, 0xA0ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varMapEdgeList->name;
  Load_XString(NotAtStart);
  v3 = varMapEdgeList;
  varXString = v2;
  if ( varMapEdgeList->edges )
  {
    v4 = varlineSegmentFloat4_t;
    lineSegmentFloat4_t = AllocLoad_lineSegmentFloat4_t();
    v3->edges = lineSegmentFloat4_t;
    varlineSegmentFloat4_t = lineSegmentFloat4_t;
    Load_lineSegmentFloat4_tArray(AtStart, varMapEdgeList->numEdges);
    v3 = varMapEdgeList;
    varlineSegmentFloat4_t = v4;
  }
  if ( v3->edgeMetadata )
  {
    v6 = varFlaggedEdgeMetadata;
    FlaggedEdgeMetadata = AllocLoad_FlaggedEdgeMetadata();
    v3->edgeMetadata = FlaggedEdgeMetadata;
    varFlaggedEdgeMetadata = FlaggedEdgeMetadata;
    Load_FlaggedEdgeMetadataArray(AtStart, varMapEdgeList->numEdges);
    v3 = varMapEdgeList;
    varFlaggedEdgeMetadata = v6;
  }
  if ( v3->edgeOctrees )
  {
    v8 = varPMROctreeMetadata;
    PMROctreeMetadata = AllocLoad_PMROctreeMetadata();
    v3->edgeOctrees = PMROctreeMetadata;
    varPMROctreeMetadata = PMROctreeMetadata;
    Load_PMROctreeMetadataArray(AtStart, varMapEdgeList->numEdgeOctrees);
    v3 = varMapEdgeList;
    varPMROctreeMetadata = v8;
  }
  if ( v3->edgeOctreeNodeSets )
  {
    v10 = varPMROctreeNodeSet;
    PMROctreeNodeSet = AllocLoad_PMROctreeNodeSet();
    v3->edgeOctreeNodeSets = PMROctreeNodeSet;
    varPMROctreeNodeSet = PMROctreeNodeSet;
    Load_PMROctreeNodeSetArray(AtStart, varMapEdgeList->numEdgeOctreeNodeSet);
    v3 = varMapEdgeList;
    varPMROctreeNodeSet = v10;
  }
  if ( v3->edgeIndices )
  {
    v12 = varEdgeIndex;
    EdgeIndex = AllocLoad_EdgeIndex();
    v3->edgeIndices = EdgeIndex;
    varEdgeIndex = EdgeIndex;
    Load_EdgeIndexArray(AtStart, varMapEdgeList->numEdgeIndices);
    v3 = varMapEdgeList;
    varEdgeIndex = v12;
  }
  if ( v3->edgeAdjacencyMetadata )
  {
    v14 = varEdgeAdjacencyMetadata;
    EdgeAdjacencyMetadata = AllocLoad_EdgeAdjacencyMetadata();
    v3->edgeAdjacencyMetadata = EdgeAdjacencyMetadata;
    varEdgeAdjacencyMetadata = EdgeAdjacencyMetadata;
    Load_EdgeAdjacencyMetadataArray(AtStart, varMapEdgeList->numEdgeAdjacencyMetadata);
    v3 = varMapEdgeList;
    varEdgeAdjacencyMetadata = v14;
  }
  if ( v3->edgeAdjacency )
  {
    v16 = varEdgeAdjacency;
    EdgeAdjacency = AllocLoad_EdgeAdjacency();
    v3->edgeAdjacency = EdgeAdjacency;
    varEdgeAdjacency = EdgeAdjacency;
    Load_EdgeAdjacencyArray(AtStart, varMapEdgeList->numEdgeAdjacency);
    varEdgeAdjacency = v16;
  }
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Mark_GfxDecalVolumeMask
==============
*/
_BOOL8 Mark_GfxDecalVolumeMask()
{
  GfxImage **v0; 
  int v1; 

  v0 = marGfxImagePtr;
  marGfxImagePtr = &marGfxDecalVolumeMask->blendMap;
  v1 = Mark_GfxImagePtr();
  marGfxImagePtr = v0;
  return v1 != 0;
}

/*
==============
Mark_GfxDecalVolumeMaterial
==============
*/
_BOOL8 Mark_GfxDecalVolumeMaterial()
{
  GfxImage **v0; 
  int v1; 

  v0 = marGfxImagePtr;
  marGfxImagePtr = marGfxDecalVolumeMaterial->channels;
  v1 = Mark_GfxImagePtrArray(6ui64);
  marGfxImagePtr = v0;
  return v1 != 0;
}

/*
==============
Load_StClutterSampleBitmask
==============
*/
void Load_StClutterSampleBitmask(const DBStreamStart streamStart)
{
  StreamKey **v1; 
  StClutterSampleBitmask *v2; 
  unsigned int *bitmask; 
  unsigned int *v4; 
  unsigned int *uint32_t; 
  GfxWrappedBuffer *v6; 
  GfxWrappedBuffer *p_bitmaskBuffer; 

  Load_Stream(streamStart, varStClutterSampleBitmask, 0x58ui64);
  v1 = varStreamKeyPtr;
  varStreamKeyPtr = &varStClutterSampleBitmask->streamKey;
  Load_StreamKeyPtr(NotAtStart);
  varStreamKeyPtr = v1;
  DB_PushStreamPos(7u);
  v2 = varStClutterSampleBitmask;
  bitmask = varStClutterSampleBitmask->bitmask;
  if ( bitmask )
  {
    if ( bitmask == (unsigned int *)-1i64 )
    {
      DB_PushSharedData();
    }
    else if ( bitmask != (unsigned int *)-2i64 )
    {
      v2->bitmask = (unsigned int *)DB_ResolvePackedOffsetAddress((const unsigned __int64)varStClutterSampleBitmask->bitmask);
      goto LABEL_8;
    }
    v4 = varuint32_t;
    uint32_t = AllocLoad_uint32_t();
    v2->bitmask = uint32_t;
    varuint32_t = uint32_t;
    Load_uint32_tArray(AtStart, varStClutterSampleBitmask->wordCount);
    varuint32_t = v4;
    if ( bitmask == (unsigned int *)-1i64 )
      DB_PopSharedData();
  }
LABEL_8:
  DB_PopStreamPos();
  v6 = varGfxWrappedBuffer;
  p_bitmaskBuffer = &varStClutterSampleBitmask->bitmaskBuffer;
  varGfxWrappedBuffer = &varStClutterSampleBitmask->bitmaskBuffer;
  Load_GfxWrappedBuffer(NotAtStart);
  Load_GfxWrappedBuffer(p_bitmaskBuffer, GfxWrappedBuffer_Raw, 4u, varStClutterSampleBitmask->wordCount, varStClutterSampleBitmask->bitmask, "clutter sample bitmasks", 0);
  varGfxWrappedBuffer = v6;
}

/*
==============
DB_ReleaseGfxWorldTransientZone
==============
*/
void DB_ReleaseGfxWorldTransientZone(const XAssetHeader header, const DB_ReleaseType releaseType)
{
  unsigned int Item; 
  int havokData; 
  bool v5; 
  GfxShaderBufferView v6; 
  GfxGpuLightGrid *v7; 
  GfxDynamicLightsetLGppZoneInfo *v8; 
  GfxDecalVolumeTransientData *name; 
  GfxReflectionProbeTransientData *v10; 
  __int64 numPointers; 
  unsigned int listHighWaterMark; 
  GfxWorldTransientZoneDeferredReleasePointerList *activeList; 
  __int64 v14; 
  GfxWorldTransientZoneDeferredReleasePointers pointers; 

  if ( releaseType == OWNS_RESOURCES )
  {
    if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2957, ASSERT_TYPE_ASSERT, "(header.gfxWorldTransientZone)", (const char *)&queryFormat, "header.gfxWorldTransientZone") )
      __debugbreak();
    Item = DB_AssetPool_GetItemIndex<GfxWorldTransientZone>(ASSET_TYPE_GFXWORLD_TRANSIENT_ZONE, header.gfxWorldTransientZone);
    DB_GfxWorldTransientZone_ResetValid(Item);
    memset_0(&pointers, 0, 0x58ui64);
    havokData = (int)header.physicsLibrary->havokData;
    if ( havokData )
      pointers.posBuffer = *(GfxWrappedBuffer *)&header.physicsLibrary[1].havokData;
    v5 = havokData != 0;
    if ( HIDWORD(header.physicsLibrary->havokData) )
    {
      pointers.auxBuffer = *(GfxWrappedBuffer *)&header.physicsLibrary[3].name;
      v5 = 1;
    }
    if ( *(_DWORD *)&header.physicsLibrary[4].isMaterialList )
    {
      v5 = 1;
      v6 = *(GfxShaderBufferView *)&header.physicsLibrary[5].isMaterialList;
      pointers.indexBuffer = (ID3D12Resource *)header.physicsLibrary[5].name;
      pointers.indexBufferView = v6;
    }
    memset_0(&header.physicsLibrary->havokData, 0, 0x80ui64);
    v7 = *(GfxGpuLightGrid **)&header.physicsLibrary[7].isMaterialList;
    pointers.gpuLightGrid = v7;
    if ( v5 || v7 )
      LOBYTE(v7) = 1;
    v8 = *(GfxDynamicLightsetLGppZoneInfo **)&header.physicsLibrary[8].isMaterialList;
    *(_QWORD *)&header.physicsLibrary[7].isMaterialList = 0i64;
    pointers.SMLGppZone = v8;
    if ( (_BYTE)v7 || v8 )
      LOBYTE(v7) = 1;
    name = (GfxDecalVolumeTransientData *)header.physicsLibrary[10].name;
    pointers.decalVolumes = name;
    *(_QWORD *)&header.physicsLibrary[8].isMaterialList = 0i64;
    if ( (_BYTE)v7 || name )
      LOBYTE(v7) = 1;
    v10 = (GfxReflectionProbeTransientData *)header.physicsLibrary[9].name;
    pointers.reflectionProbes = v10;
    header.physicsLibrary[10].name = NULL;
    if ( (_BYTE)v7 || v10 )
      LOBYTE(v7) = 1;
    header.physicsLibrary[9].name = NULL;
    if ( (_BYTE)v7 && GfxWorldTransientZoneDeferredRelease_Enabled() )
    {
      if ( !s_GfxWorldTransientZoneDeferredReleaseGlob.activeList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2750, ASSERT_TYPE_ASSERT, "(s_GfxWorldTransientZoneDeferredReleaseGlob.activeList)", (const char *)&queryFormat, "s_GfxWorldTransientZoneDeferredReleaseGlob.activeList") )
        __debugbreak();
      numPointers = s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->numPointers;
      if ( (unsigned int)numPointers >= 0x180 )
      {
        Sys_Error((const ObfuscateErrorText)&stru_143DFA918);
        numPointers = 0i64;
      }
      else
      {
        s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->numPointers = numPointers + 1;
        listHighWaterMark = s_GfxWorldTransientZoneDeferredReleaseGlob.listHighWaterMark;
        if ( (unsigned int)(numPointers + 1) > s_GfxWorldTransientZoneDeferredReleaseGlob.listHighWaterMark )
          listHighWaterMark = numPointers + 1;
        s_GfxWorldTransientZoneDeferredReleaseGlob.listHighWaterMark = listHighWaterMark;
      }
      if ( s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->currentZoneIndex == 0xFFFF )
      {
        LODWORD(v14) = 0xFFFF;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2969, ASSERT_TYPE_ASSERT, "( ( s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->currentZoneIndex != INVALID_ZONE_INDEX ) )", "( s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->currentZoneIndex ) = %u", v14) )
          __debugbreak();
      }
      activeList = s_GfxWorldTransientZoneDeferredReleaseGlob.activeList;
      s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->pointers[numPointers] = pointers;
      s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->zoneHandles[numPointers] = truncate_cast<unsigned short,unsigned int>(activeList->currentZoneIndex);
    }
    else
    {
      GfxWorldTransientZoneDeferredRelease_ReleaseInternal(&pointers, 1);
    }
  }
}

/*
==============
DB_SwapGfxWorldTransientZone
==============
*/
void DB_SwapGfxWorldTransientZone(const XAssetHeader from, const XAssetHeader to)
{
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_GFXWORLD_TRANSIENT_ZONE);
  DB_GfxWorldTransientZoneUpdateValidity(from);
  DB_GfxWorldTransientZoneUpdateValidity(to);
}

/*
==============
DB_MoveGfxWorldTransientZone
==============
*/
void DB_MoveGfxWorldTransientZone(const XAssetHeader from, const XAssetHeader to, const DB_ReleaseType toReleaseType)
{
  if ( off_147903E20 )
    ((void (__fastcall *)(_QWORD, _QWORD))off_147903E20)((const XAssetHeader)to.physicsLibrary, (unsigned int)toReleaseType);
  if ( g_assetSizes[28] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[28]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[28]);
  DB_GfxWorldTransientZoneUpdateValidity(to);
}

/*
==============
DB_CopyGfxWorldTransientZone
==============
*/
void DB_CopyGfxWorldTransientZone(const XAssetHeader from, const XAssetHeader to, const char *const toNewAssetName)
{
  if ( !from.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3020, ASSERT_TYPE_ASSERT, "(from.gfxWorldTransientZone)", (const char *)&queryFormat, "from.gfxWorldTransientZone") )
    __debugbreak();
  if ( DB_GfxWorldTransientZone_IsValidTransientZone(from.gfxWorldTransientZone) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3021, ASSERT_TYPE_ASSERT, "(!DB_GfxWorldTransientZone_IsValidTransientZone( *from.gfxWorldTransientZone ))", (const char *)&queryFormat, "!DB_GfxWorldTransientZone_IsValidTransientZone( *from.gfxWorldTransientZone )") )
    __debugbreak();
  if ( g_assetSizes[28] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[28]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[28]);
  DB_SetXAssetHeaderName(28, to, toNewAssetName);
}

/*
==============
DB_CreateFxWorldTransientZone
==============
*/
void DB_CreateFxWorldTransientZone(const XAssetHeader header, const DB_CreateType createType)
{
  unsigned int Item; 

  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3063, ASSERT_TYPE_ASSERT, "(header.fxWorldTransientZone)", (const char *)&queryFormat, "header.fxWorldTransientZone") )
    __debugbreak();
  Glass_OnTransientZoneLoaded(*(_DWORD *)&header.physicsLibrary->isMaterialList);
  if ( createType == NEW_LIVE_HEAD && DB_FxWorldTransientZone_IsValidTransientZone(header.fxWorldTransientZone) )
  {
    Item = DB_AssetPool_GetItemIndex<FxWorldTransientZone>(ASSET_TYPE_FXWORLD_TRANSIENT_ZONE, header.fxWorldTransientZone);
    DB_FxWorldTransientZone_SetValid(Item);
  }
}

/*
==============
DB_ReleaseFxWorldTransientZone
==============
*/
void DB_ReleaseFxWorldTransientZone(const XAssetHeader header, const DB_ReleaseType releaseType)
{
  unsigned int Item; 

  if ( releaseType == OWNS_RESOURCES )
  {
    if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3081, ASSERT_TYPE_ASSERT, "(header.fxWorldTransientZone)", (const char *)&queryFormat, "header.fxWorldTransientZone") )
      __debugbreak();
    Item = DB_AssetPool_GetItemIndex<FxWorldTransientZone>(ASSET_TYPE_FXWORLD_TRANSIENT_ZONE, header.fxWorldTransientZone);
    DB_FxWorldTransientZone_ResetValid(Item);
    Glass_OnTransientZoneUnloaded(*(_DWORD *)&header.physicsLibrary->isMaterialList);
  }
}

/*
==============
DB_SwapFxWorldTransientZone
==============
*/
void DB_SwapFxWorldTransientZone(const XAssetHeader from, const XAssetHeader to)
{
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_FXWORLD_TRANSIENT_ZONE);
  DB_FxWorldTransientZoneUpdateValidity(from);
  DB_FxWorldTransientZoneUpdateValidity(to);
}

/*
==============
DB_MoveFxWorldTransientZone
==============
*/
void DB_MoveFxWorldTransientZone(const XAssetHeader from, const XAssetHeader to, const DB_ReleaseType toReleaseType)
{
  if ( off_1479040B0 )
    ((void (__fastcall *)(_QWORD, _QWORD))off_1479040B0)((const XAssetHeader)to.physicsLibrary, (unsigned int)toReleaseType);
  if ( g_assetSizes[110] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[110]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[110]);
  DB_FxWorldTransientZoneUpdateValidity(to);
}

/*
==============
DB_CopyFxWorldTransientZoneAsset
==============
*/
void DB_CopyFxWorldTransientZoneAsset(const XAssetHeader from, const XAssetHeader to, const char *const toNewAssetName)
{
  if ( !from.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3127, ASSERT_TYPE_ASSERT, "(from.fxWorldTransientZone)", (const char *)&queryFormat, "from.fxWorldTransientZone") )
    __debugbreak();
  if ( DB_FxWorldTransientZone_IsValidTransientZone(from.fxWorldTransientZone) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3128, ASSERT_TYPE_ASSERT, "(!DB_FxWorldTransientZone_IsValidTransientZone( *from.fxWorldTransientZone ))", (const char *)&queryFormat, "!DB_FxWorldTransientZone_IsValidTransientZone( *from.fxWorldTransientZone )") )
    __debugbreak();
  if ( g_assetSizes[110] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[110]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[110]);
  DB_SetXAssetHeaderName(110, to, toNewAssetName);
}

/*
==============
DB_ReleaseFXWorld
==============
*/
void DB_ReleaseFXWorld(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    fxWorld.activeTransientZoneCount = 0;
}

/*
==============
DB_CreateClothAsset
==============
*/

void __fastcall DB_CreateClothAsset(XAssetHeader header, DB_CreateType createType)
{
  Cloth_AddClothAsset(header.clothAsset);
}

/*
==============
DB_ReleaseClothAsset
==============
*/
void DB_ReleaseClothAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  Cloth_ReleaseClothAsset(header.clothAsset, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapClothAsset
==============
*/

void __fastcall DB_SwapClothAsset(XAssetHeader from, XAssetHeader to)
{
  Cloth_SwapClothAsset(from.clothAsset, to.clothAsset);
}

/*
==============
DB_MoveClothAsset
==============
*/

void __fastcall DB_MoveClothAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  Cloth_MoveClothAsset(from.clothAsset, to.clothAsset);
}

/*
==============
DB_CopyClothAsset
==============
*/
void DB_CopyClothAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  Cloth_CopyClothAsset(from.clothAsset, to.clothAsset);
  if ( g_assetSizes[87] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[87]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[87]);
  DB_SetXAssetHeaderName(87, to, toNewAssetName);
}

/*
==============
DB_ReleaseSndGlobals
==============
*/
void DB_ReleaseSndGlobals(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    SND_RemoveGlobals(header.soundGlobals);
}

/*
==============
DB_ReleaseSoundBankResident
==============
*/
void DB_ReleaseSoundBankResident(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
  {
    if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3755, ASSERT_TYPE_ASSERT, "(header.soundBankResident)", (const char *)&queryFormat, "header.soundBankResident") )
      __debugbreak();
    SND_RemoveBank((const SndBank *)header.physicsLibrary);
  }
}

/*
==============
DB_SwapSoundBank
==============
*/

void __fastcall DB_SwapSoundBank(XAssetHeader from, XAssetHeader to)
{
  SND_SwapBank((SndBank *)from.physicsLibrary, (SndBank *)to.physicsLibrary);
}

/*
==============
DB_MoveSoundBankAsset
==============
*/
void DB_MoveSoundBankAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  if ( off_147903DC8 )
    ((void (__fastcall *)(_QWORD, _QWORD))off_147903DC8)((XAssetHeader)to.physicsLibrary, (unsigned int)toReleaseType);
  if ( g_assetSizes[17] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[17]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[17]);
}

/*
==============
DB_CopySoundBankAsset
==============
*/
void DB_CopySoundBankAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[17] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[17]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[17]);
  DB_SetXAssetHeaderName(17, to, toNewAssetName);
}

/*
==============
DB_ReleaseSoundBankTransient
==============
*/
void DB_ReleaseSoundBankTransient(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
  {
    if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3837, ASSERT_TYPE_ASSERT, "(header.soundBankTransient)", (const char *)&queryFormat, "header.soundBankTransient") )
      __debugbreak();
    SND_RemoveBank((const SndBank *)header.physicsLibrary);
  }
}

/*
==============
DB_SwapSoundBankTransient
==============
*/

void __fastcall DB_SwapSoundBankTransient(XAssetHeader from, XAssetHeader to)
{
  SND_SwapBank((SndBank *)from.physicsLibrary, (SndBank *)to.physicsLibrary);
}

/*
==============
DB_MoveSoundBankTransientAsset
==============
*/
void DB_MoveSoundBankTransientAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  if ( off_147903DD0 )
    ((void (__fastcall *)(_QWORD, _QWORD))off_147903DD0)((XAssetHeader)to.physicsLibrary, (unsigned int)toReleaseType);
  if ( g_assetSizes[18] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[18]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[18]);
}

/*
==============
DB_CopySoundBankTransientAsset
==============
*/
void DB_CopySoundBankTransientAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[18] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[18]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[18]);
  DB_SetXAssetHeaderName(18, to, toNewAssetName);
}

/*
==============
DB_ReleaseLuaFile
==============
*/
void DB_ReleaseLuaFile(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    LUI_CoD_MyChangesFileUnloaded();
}

/*
==============
DB_CreateScriptableAsset
==============
*/

void __fastcall DB_CreateScriptableAsset(XAssetHeader header, DB_CreateType createType)
{
  ScriptableBg_AddScriptableAsset(header.scriptable);
}

/*
==============
DB_ReleaseScriptableAsset
==============
*/
void DB_ReleaseScriptableAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  ScriptableBg_ReleaseScriptableAsset(header.scriptable, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapScriptableAsset
==============
*/

void __fastcall DB_SwapScriptableAsset(XAssetHeader from, XAssetHeader to)
{
  ScriptableBg_SwapScriptableAsset(from.scriptable, to.scriptable);
}

/*
==============
DB_MoveScriptableAsset
==============
*/

void __fastcall DB_MoveScriptableAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  ScriptableBg_MoveScriptableAsset(from.scriptable, to.scriptable);
}

/*
==============
DB_CopyScriptableAsset
==============
*/
void DB_CopyScriptableAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[59] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[59]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[59]);
  DB_SetXAssetHeaderName(59, to, toNewAssetName);
  ScriptableBg_CopyScriptableAsset(from.scriptable, to.scriptable);
}

/*
==============
DB_CreateAIAnimsetAsset
==============
*/

void __fastcall DB_CreateAIAnimsetAsset(XAssetHeader header, DB_CreateType createType)
{
  Animset_Register(header.animset);
}

/*
==============
DB_ReleaseAIAnimsetAsset
==============
*/
void DB_ReleaseAIAnimsetAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  Animset_Release(header.animset, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_CreateAsmAsset
==============
*/
void DB_CreateAsmAsset(XAssetHeader header, DB_CreateType createType)
{
  ;
}

/*
==============
DB_ReleaseAsmAsset
==============
*/
void DB_ReleaseAsmAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  bool v3; 

  v3 = releaseType == OWNS_RESOURCES;
  Ai_Asm::Release(header.asmAsset, releaseType == OWNS_RESOURCES);
  BgPlayer_Asm::Release(header.asmAsset, v3);
}

/*
==============
DB_ReleaseStreamingInfoAsset
==============
*/
void DB_ReleaseStreamingInfoAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4132, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4133, ASSERT_TYPE_ASSERT, "(header.streamingInfo)", (const char *)&queryFormat, "header.streamingInfo") )
    __debugbreak();
  DB_StreamingInfo_Release(header.streamingInfo);
}

/*
==============
DB_CreateStreamingInfoAsset
==============
*/
void DB_CreateStreamingInfoAsset(XAssetHeader header, DB_CreateType createType)
{
  if ( !Sys_IsDatabaseThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4141, ASSERT_TYPE_ASSERT, "(Sys_IsDatabaseThread())", (const char *)&queryFormat, "Sys_IsDatabaseThread()") )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4142, ASSERT_TYPE_ASSERT, "(header.streamingInfo)", (const char *)&queryFormat, "header.streamingInfo") )
    __debugbreak();
  DB_StreamingInfo_Create(header.streamingInfo);
}

/*
==============
DB_SwapStreamingInfoAsset
==============
*/
void DB_SwapStreamingInfoAsset(XAssetHeader from, XAssetHeader to)
{
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4151, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Not implemented") )
    __debugbreak();
}

/*
==============
DB_MoveStreamingInfoAsset
==============
*/
void DB_MoveStreamingInfoAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  if ( !from.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4158, ASSERT_TYPE_ASSERT, "(from.streamingInfo)", (const char *)&queryFormat, "from.streamingInfo") )
    __debugbreak();
  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4159, ASSERT_TYPE_ASSERT, "(to.streamingInfo)", (const char *)&queryFormat, "to.streamingInfo") )
    __debugbreak();
  DB_StreamingInfo_Move(from.streamingInfo, to.streamingInfo);
}

/*
==============
DB_CopyStreamingInfoAsset
==============
*/
void DB_CopyStreamingInfoAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( !from.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4167, ASSERT_TYPE_ASSERT, "(from.streamingInfo)", (const char *)&queryFormat, "from.streamingInfo") )
    __debugbreak();
  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4168, ASSERT_TYPE_ASSERT, "(to.streamingInfo)", (const char *)&queryFormat, "to.streamingInfo") )
    __debugbreak();
  DB_StreamingInfo_Copy(from.streamingInfo, to.streamingInfo, toNewAssetName);
}

/*
==============
DB_CreateStreamKey
==============
*/

void __fastcall DB_CreateStreamKey(XAssetHeader header, DB_CreateType createType)
{
  Stream_DBCreateStreamKey(header.streamKey);
}

/*
==============
DB_ReleaseStreamKey
==============
*/

void __fastcall DB_ReleaseStreamKey(XAssetHeader header, DB_ReleaseType releaseType)
{
  Stream_DBPreReleaseStreamKey(header.streamKey);
}

/*
==============
DB_SwapStreamKey
==============
*/
void DB_SwapStreamKey(const XAssetHeader from, XAssetHeader to)
{
  Stream_DBPreSwapStreamKey(from.streamKey, to.streamKey);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_STREAM_KEY);
}

/*
==============
DB_MoveStreamKey
==============
*/
void DB_MoveStreamKey(const XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  Stream_DBPreMoveStreamKey(from.streamKey, to.streamKey, toReleaseType == OWNS_RESOURCES);
  *(__m256i *)to.physicsLibrary = *(__m256i *)from.physicsLibrary;
  *(__m256i *)&to.physicsLibrary[1].isMaterialList = *(__m256i *)&from.physicsLibrary[1].isMaterialList;
}

/*
==============
DB_CopyStreamKey
==============
*/
void DB_CopyStreamKey(const XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[98] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[98]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[98]);
  DB_SetXAssetHeaderName(98, to, toNewAssetName);
  Stream_DBPostCopyStreamKey(from.streamKey, to.streamKey);
}

/*
==============
DB_ReleaseKeyValuePairs
==============
*/
void DB_ReleaseKeyValuePairs(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    KeyValuePairs_Remove(header.keyValuePairs);
}

/*
==============
DB_ReleaseSuperTerrain
==============
*/
void DB_ReleaseSuperTerrain(XAssetHeader header, DB_ReleaseType releaseType)
{
  unsigned int v3; 
  unsigned int v4; 
  char *v5; 
  __int64 v6; 
  unsigned int v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 
  ID3D12Resource *v11; 
  ID3D12Resource *v12; 
  ID3D12Resource *v13; 
  ID3D12Resource **v14; 
  ID3D12Resource *v15; 
  unsigned int i; 

  if ( header.physicsLibrary && releaseType == OWNS_RESOURCES )
  {
    v3 = 0;
    for ( i = 0; v3 < *(_DWORD *)&header.physicsLibrary->isMaterialList; i = v3 )
    {
      v4 = 0;
      v5 = &header.physicsLibrary->havokData[376 * v3];
      if ( *((_DWORD *)v5 + 6) )
      {
        do
        {
          v6 = *((_QWORD *)v5 + 4) + 16i64 * v4;
          v7 = *(_DWORD *)v6 * *(_DWORD *)(v6 + 4);
          if ( v7 )
          {
            v8 = 0i64;
            v9 = v7;
            do
            {
              v10 = *(_QWORD *)(v6 + 8);
              v11 = *(ID3D12Resource **)(v10 + v8 + 8);
              if ( v11 )
              {
                R_FreeStaticVertexBuffer(v11);
                R_AssignNullBuffer((ID3D12Resource **)(v10 + v8 + 8));
              }
              v12 = *(ID3D12Resource **)(v10 + v8 + 32);
              if ( v12 )
              {
                R_FreeStaticIndexBuffer(v12);
                R_AssignNullBuffer((ID3D12Resource **)(v10 + v8 + 32));
              }
              v13 = *(ID3D12Resource **)(v10 + v8 + 24);
              v14 = (ID3D12Resource **)(v10 + v8 + 24);
              if ( v13 )
              {
                R_FreeStaticVertexBuffer(v13);
                R_AssignNullBuffer(v14);
              }
              v8 += 136i64;
              --v9;
            }
            while ( v9 );
          }
          ++v4;
        }
        while ( v4 < *((_DWORD *)v5 + 6) );
        v3 = i;
      }
      v15 = (ID3D12Resource *)*((_QWORD *)v5 + 2);
      if ( v15 )
        R_FreeStaticIndexBuffer(v15);
      if ( *((_QWORD *)v5 + 26) && *((_DWORD *)v5 + 50) >= 2u )
        R_ShutdownGfxWrappedBuffer((GfxWrappedBuffer *)(v5 + 184));
      if ( *((_QWORD *)v5 + 33) && *((_DWORD *)v5 + 64) >= 2u )
        R_ShutdownGfxWrappedBuffer((GfxWrappedBuffer *)(v5 + 240));
      ++v3;
    }
    if ( header.physicsLibrary[4].name )
    {
      if ( LODWORD(header.physicsLibrary[3].havokData) >= 2 )
        R_ShutdownGfxWrappedBuffer((GfxWrappedBuffer *)&header.physicsLibrary[3]);
    }
  }
}

/*
==============
DB_CreateCollisionTileAsset
==============
*/
void DB_CreateCollisionTileAsset(XAssetHeader header, DB_CreateType createType)
{
  bool v3; 

  v3 = DB_HasHashWriteLock();
  if ( v3 )
    DB_UnlockHashWrite();
  WorldCollision_AddCollisionTile(header.collisionTile);
  StaticModels_AddCollisionTile(header.collisionTile);
  if ( v3 )
    DB_LockHashWrite();
}

/*
==============
DB_ReleaseCollisionTileAsset
==============
*/
void DB_ReleaseCollisionTileAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
  {
    StaticModels_RemoveCollisionTile(header.collisionTile);
    WorldCollision_RemoveCollisionTile(header.collisionTile);
  }
}

/*
==============
DB_SwapCollisionTileAsset
==============
*/
void DB_SwapCollisionTileAsset(XAssetHeader from, XAssetHeader to)
{
  StaticModels_SwapCollisionTile(from.collisionTile, to.collisionTile);
  WorldCollision_SwapCollisionTile(from.collisionTile, to.collisionTile);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_COLLISION_TILE);
}

/*
==============
DB_MoveCollisionTileAsset
==============
*/
void DB_MoveCollisionTileAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  StaticModels_MovingCollisionTile(from.collisionTile, to.collisionTile);
  WorldCollision_MovingCollisionTile(from.collisionTile, to.collisionTile);
  if ( off_147904078 )
    ((void (__fastcall *)(_QWORD, _QWORD))off_147904078)((XAssetHeader)to.physicsLibrary, (unsigned int)toReleaseType);
  if ( g_assetSizes[103] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[103]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[103]);
  StaticModels_MovedCollisionTile(from.collisionTile, to.collisionTile);
  WorldCollision_MovedCollisionTile(from.collisionTile, to.collisionTile);
}

/*
==============
DB_CopyCollisionTileAsset
==============
*/
void DB_CopyCollisionTileAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[103] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[103]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[103]);
  DB_SetXAssetHeaderName(103, to, toNewAssetName);
  StaticModels_CopyCollisionTile(from.collisionTile, to.collisionTile);
  WorldCollision_CopyCollisionTile(from.collisionTile, to.collisionTile);
}

/*
==============
DB_CreateGfxDecalVolumeMaterial
==============
*/

void __fastcall DB_CreateGfxDecalVolumeMaterial(XAssetHeader header, DB_CreateType createType)
{
  R_DecalVolumes_CreateGfxDecalVolumeMaterial(header.decalVolumeMaterial);
}

/*
==============
DB_ReleaseGfxDecalVolumeMaterial
==============
*/
void DB_ReleaseGfxDecalVolumeMaterial(XAssetHeader header, DB_ReleaseType releaseType)
{
  R_DecalVolumes_ReleaseGfxDecalVolumeMaterial(header.decalVolumeMaterial, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapGfxDecalVolumeMaterial
==============
*/
void DB_SwapGfxDecalVolumeMaterial(XAssetHeader from, XAssetHeader to)
{
  R_DecalVolumes_SwapGfxDecalVolumeMaterial(from.decalVolumeMaterial, to.decalVolumeMaterial);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_DECAL_VOLUME_MATERIAL);
  R_DecalVolumes_SwapGfxDecalVolumeMaterialEnd(from.decalVolumeMaterial, to.decalVolumeMaterial);
}

/*
==============
DB_MoveGfxDecalVolumeMaterial
==============
*/
void DB_MoveGfxDecalVolumeMaterial(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  R_DecalVolumes_MoveGfxDecalVolumeMaterial(from.decalVolumeMaterial, to.decalVolumeMaterial, toReleaseType == OWNS_RESOURCES);
}

/*
==============
DB_CopyGfxDecalVolumeMaterial
==============
*/
void DB_CopyGfxDecalVolumeMaterial(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  R_DecalVolumes_CopyGfxDecalVolumeMaterial(from.decalVolumeMaterial, to.decalVolumeMaterial, toNewAssetName);
  if ( g_assetSizes[107] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[107]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[107]);
  DB_SetXAssetHeaderName(107, to, toNewAssetName);
  R_DecalVolumes_CopyGfxDecalVolumeMaterialEnd(from.decalVolumeMaterial, to.decalVolumeMaterial, toNewAssetName);
}

/*
==============
DB_CreateGfxDecalVolumeMask
==============
*/

void __fastcall DB_CreateGfxDecalVolumeMask(XAssetHeader header, DB_CreateType createType)
{
  R_DecalVolumes_CreateGfxDecalVolumeMask(header.decalVolumeMask);
}

/*
==============
DB_ReleaseGfxDecalVolumeMask
==============
*/
void DB_ReleaseGfxDecalVolumeMask(XAssetHeader header, DB_ReleaseType releaseType)
{
  R_DecalVolumes_ReleaseGfxDecalVolumeMask(header.decalVolumeMask, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapGfxDecalVolumeMask
==============
*/
void DB_SwapGfxDecalVolumeMask(XAssetHeader from, XAssetHeader to)
{
  R_DecalVolumes_SwapGfxDecalVolumeMask(from.decalVolumeMask, to.decalVolumeMask);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_DECAL_VOLUME_MASK);
  R_DecalVolumes_SwapGfxDecalVolumeMaskEnd(from.decalVolumeMask, to.decalVolumeMask);
}

/*
==============
DB_MoveGfxDecalVolumeMask
==============
*/
void DB_MoveGfxDecalVolumeMask(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  R_DecalVolumes_MoveGfxDecalVolumeMask(from.decalVolumeMask, to.decalVolumeMask, toReleaseType == OWNS_RESOURCES);
}

/*
==============
DB_CopyGfxDecalVolumeMask
==============
*/
void DB_CopyGfxDecalVolumeMask(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  R_DecalVolumes_CopyGfxDecalVolumeMask(from.decalVolumeMask, to.decalVolumeMask, toNewAssetName);
  if ( g_assetSizes[108] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[108]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[108]);
  DB_SetXAssetHeaderName(108, to, toNewAssetName);
  R_DecalVolumes_CopyGfxDecalVolumeMaskEnd(from.decalVolumeMask, to.decalVolumeMask, toNewAssetName);
}

/*
==============
DB_CreateDynEntityListAsset
==============
*/
void DB_CreateDynEntityListAsset(XAssetHeader header, DB_CreateType createType)
{
  if ( createType == NEW_LIVE_HEAD )
    DynEnt_AddDynEntityList(header.dynEntityList);
}

/*
==============
DB_ReleaseDynEntityListAsset
==============
*/
void DB_ReleaseDynEntityListAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES && DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_DYNENTITY_LIST, header) )
    DynEnt_RemoveDynEntityList(header.dynEntityList);
}

/*
==============
DB_SwapDynEntityListAsset
==============
*/

void __fastcall DB_SwapDynEntityListAsset(XAssetHeader from, XAssetHeader to)
{
  DynEnt_SwapDynEntityList(from.dynEntityList, to.dynEntityList);
}

/*
==============
DB_MoveDynEntityListAsset
==============
*/

void __fastcall DB_MoveDynEntityListAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  DynEnt_MoveDynEntityList(from.dynEntityList, to.dynEntityList);
}

/*
==============
DB_CopyDynEntityListAsset
==============
*/
void DB_CopyDynEntityListAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  DynEnt_CopyDynEntityList(from.dynEntityList, to.dynEntityList);
  DB_SetXAssetHeaderName(109, to, toNewAssetName);
}

/*
==============
DB_CreateMapEdgeListAsset
==============
*/

void __fastcall DB_CreateMapEdgeListAsset(XAssetHeader header, DB_CreateType createType)
{
  MapEdgeList_Add(header.mapEdgeList);
}

/*
==============
DB_ReleaseMapEdgeListAsset
==============
*/
void DB_ReleaseMapEdgeListAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES && DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_EDGE_LIST, header) )
    MapEdgeList_Remove(header.mapEdgeList);
}

/*
==============
DB_ReleaseSoundBankListDefAsset
==============
*/
void DB_ReleaseSoundBankListDefAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    BG_UnloadSoundBankList(header.soundBankListDef);
}

/*
==============
DB_AssetPool_Alloc
==============
*/
XAssetHeader DB_AssetPool_Alloc(const XAssetType assetType)
{
  __int64 v1; 
  __int64 v2; 
  XAssetHeader result; 
  unsigned int m_maxUsedCount; 

  v1 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 229, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPools ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPools )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  v2 = v1;
  result.physicsLibrary = (PhysicsLibrary *)s_assetPools[v1].m_freeHead;
  if ( result.physicsLibrary )
  {
    m_maxUsedCount = ++s_assetPools[v2].m_usedCount;
    if ( s_assetPools[v2].m_maxUsedCount > m_maxUsedCount )
      m_maxUsedCount = s_assetPools[v2].m_maxUsedCount;
    s_assetPools[v2].m_maxUsedCount = m_maxUsedCount;
    s_assetPools[v2].m_freeHead = (void *)result.physicsLibrary->name;
  }
  return result;
}

/*
==============
DB_AssetPool_Free
==============
*/
void DB_AssetPool_Free(const XAssetType assetType, const XAssetHeader header)
{
  __int64 v2; 

  v2 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 239, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPools ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPools )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 241, ASSERT_TYPE_ASSERT, "(header.data)", (const char *)&queryFormat, "header.data") )
    __debugbreak();
  DB_AssetPool::Free(&s_assetPools[v2], header.data);
}

/*
==============
DB_AllocXAssetSingleton
==============
*/
XAssetHeader DB_AllocXAssetSingleton(const XAssetType type)
{
  void *const *v1; 

  v1 = &s_assetSingletons[type];
  if ( !*v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8385, ASSERT_TYPE_ASSERT, "(s_assetSingletons[type])", (const char *)&queryFormat, "s_assetSingletons[type]") )
    __debugbreak();
  return *(XAssetHeader *)v1;
}

/*
==============
DB_FreeXAssetSingleton
==============
*/
void DB_FreeXAssetSingleton(const XAssetType type, const XAssetHeader header)
{
  const void **v3; 

  v3 = (const void **)&s_assetSingletons[type];
  if ( !*v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8394, ASSERT_TYPE_ASSERT, "(s_assetSingletons[type])", (const char *)&queryFormat, "s_assetSingletons[type]") )
    __debugbreak();
  if ( header.physicsLibrary != *v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8395, ASSERT_TYPE_ASSERT, "( header.data ) == ( s_assetSingletons[type] )", "%s == %s\n\t%p, %p", "header.data", "s_assetSingletons[type]", header.physicsLibrary, *v3) )
    __debugbreak();
}

/*
==============
DB_CreatePhysicsLibrary
==============
*/

void __fastcall DB_CreatePhysicsLibrary(XAssetHeader header, DB_CreateType createType)
{
  Physics_AddPhysicsLibrary(header.physicsLibrary);
}

/*
==============
DB_ReleasePhysicsLibrary
==============
*/
void DB_ReleasePhysicsLibrary(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    Physics_ReleasePhysicsLibrary(header.physicsLibrary);
}

/*
==============
DB_CreatePhysicsSFXEventAsset
==============
*/
void DB_CreatePhysicsSFXEventAsset(XAssetHeader header, DB_CreateType createType)
{
  if ( createType == NEW_LIVE_HEAD )
    Physics_AddPhysicsSFXEventAsset(header.physicsSFXEventAsset);
}

/*
==============
DB_ReleasePhysicsSFXEventAsset
==============
*/
void DB_ReleasePhysicsSFXEventAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, header) )
    Physics_ReleasePhysicsSFXEventAsset(header.physicsSFXEventAsset);
}

/*
==============
DB_SwapPhysicsSFXEventAsset
==============
*/

void __fastcall DB_SwapPhysicsSFXEventAsset(const XAssetHeader from, XAssetHeader to)
{
  Physics_SwapPhysicsSFXEventAsset(from.physicsSFXEventAsset, to.physicsSFXEventAsset);
}

/*
==============
DB_MovePhysicsSFXEventAsset
==============
*/

void __fastcall DB_MovePhysicsSFXEventAsset(const XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  Physics_MovePhysicsSFXEventAsset(from.physicsSFXEventAsset, to.physicsSFXEventAsset);
}

/*
==============
DB_CopyPhysicsSFXEventAsset
==============
*/
void DB_CopyPhysicsSFXEventAsset(const XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[1] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[1]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[1]);
  DB_SetXAssetHeaderName(1, to, toNewAssetName);
  Physics_CopyPhysicsSFXEventAsset(from.physicsSFXEventAsset, to.physicsSFXEventAsset);
}

/*
==============
DB_CreatePhysicsVFXEventAsset
==============
*/
void DB_CreatePhysicsVFXEventAsset(XAssetHeader header, DB_CreateType createType)
{
  if ( createType == NEW_LIVE_HEAD )
    Physics_AddPhysicsVFXEventAsset(header.physicsVFXEventAsset);
}

/*
==============
DB_ReleasePhysicsVFXEventAsset
==============
*/
void DB_ReleasePhysicsVFXEventAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, header) )
    Physics_ReleasePhysicsVFXEventAsset(header.physicsVFXEventAsset);
}

/*
==============
DB_SwapPhysicsVFXEventAsset
==============
*/

void __fastcall DB_SwapPhysicsVFXEventAsset(XAssetHeader from, XAssetHeader to)
{
  Physics_SwapPhysicsVFXEventAsset(from.physicsVFXEventAsset, to.physicsVFXEventAsset);
}

/*
==============
DB_MovePhysicsVFXEventAsset
==============
*/

void __fastcall DB_MovePhysicsVFXEventAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  Physics_MovePhysicsVFXEventAsset(from.physicsVFXEventAsset, to.physicsVFXEventAsset);
}

/*
==============
DB_CopyPhysicsVFXEventAsset
==============
*/
void DB_CopyPhysicsVFXEventAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[2] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[2]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[2]);
  DB_SetXAssetHeaderName(2, to, toNewAssetName);
  Physics_CopyPhysicsVFXEventAsset(from.physicsVFXEventAsset, to.physicsVFXEventAsset);
}

/*
==============
DB_AllocPhysicsAsset
==============
*/
XAssetHeader DB_AllocPhysicsAsset(const XAssetType assetType)
{
  XAssetHeader result; 
  unsigned int m_maxUsedCount; 
  int v4; 

  if ( assetType != ASSET_TYPE_PHYSICSASSET )
  {
    v4 = 3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 458, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_PHYSICSASSET )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_PHYSICSASSET", assetType, v4) )
      __debugbreak();
  }
  result.physicsLibrary = (PhysicsLibrary *)s_assetPools[3].m_freeHead;
  if ( s_assetPools[3].m_freeHead )
  {
    m_maxUsedCount = ++s_assetPools[3].m_usedCount;
    if ( s_assetPools[3].m_maxUsedCount > s_assetPools[3].m_usedCount )
      m_maxUsedCount = s_assetPools[3].m_maxUsedCount;
    s_assetPools[3].m_maxUsedCount = m_maxUsedCount;
    s_assetPools[3].m_freeHead = *(void **)s_assetPools[3].m_freeHead;
    result.physicsLibrary[3].name = NULL;
    *(_DWORD *)&result.physicsLibrary[3].isMaterialList = 0;
  }
  else
  {
    return 0i64;
  }
  return result;
}

/*
==============
DB_CreatePhysicsAsset
==============
*/

void __fastcall DB_CreatePhysicsAsset(XAssetHeader header, DB_CreateType createType)
{
  Physics_AddPhysicsAsset(header.physicsAsset);
}

/*
==============
DB_ReleasePhysicsAsset
==============
*/
void DB_ReleasePhysicsAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  Physics_ReleasePhysicsAsset(header.physicsAsset, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapPhysicsAsset
==============
*/

void __fastcall DB_SwapPhysicsAsset(XAssetHeader from, XAssetHeader to)
{
  Physics_SwapPhysicsAsset(from.physicsAsset, to.physicsAsset);
}

/*
==============
DB_MovePhysicsAsset
==============
*/

void __fastcall DB_MovePhysicsAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  Physics_MovePhysicsAsset(from.physicsAsset, to.physicsAsset);
}

/*
==============
DB_CopyPhysicsAsset
==============
*/
void DB_CopyPhysicsAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  Physics_CopyPhysicsAsset(from.physicsAsset, to.physicsAsset);
  if ( g_assetSizes[3] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[3]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[3]);
  DB_SetXAssetHeaderName(3, to, toNewAssetName);
  to.physicsLibrary[3].name = NULL;
  *(_DWORD *)&to.physicsLibrary[3].isMaterialList = 0;
}

/*
==============
DB_CreatePhysicsFXPipeline
==============
*/

void __fastcall DB_CreatePhysicsFXPipeline(XAssetHeader header, DB_CreateType createType)
{
  PhysicsFX_AddPhysicsFXPipeline(header.physicsFXPipeline);
}

/*
==============
DB_ReleasePhysicsFXPipeline
==============
*/

void __fastcall DB_ReleasePhysicsFXPipeline(XAssetHeader header, DB_ReleaseType releaseType)
{
  PhysicsFX_ReleasePhysicsFXPipeline(header.physicsFXPipeline);
}

/*
==============
DB_SwapPhysicsFXPipeline
==============
*/

void __fastcall DB_SwapPhysicsFXPipeline(const XAssetHeader from, XAssetHeader to)
{
  PhysicsFX_SwapPhysicsFXPipeline(from.physicsFXPipeline, to.physicsFXPipeline);
}

/*
==============
DB_MovePhysicsFXPipeline
==============
*/

void __fastcall DB_MovePhysicsFXPipeline(const XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  PhysicsFX_MovePhysicsFXPipeline(from.physicsFXPipeline, to.physicsFXPipeline);
}

/*
==============
DB_CopyPhysicsFXPipeline
==============
*/
void DB_CopyPhysicsFXPipeline(const XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[4] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[4]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[4]);
  DB_SetXAssetHeaderName(4, to, toNewAssetName);
  PhysicsFX_CopyPhysicsFXPipeline(from.physicsFXPipeline, to.physicsFXPipeline);
}

/*
==============
DB_CreatePhysicsFXShape
==============
*/

void __fastcall DB_CreatePhysicsFXShape(XAssetHeader header, DB_CreateType createType)
{
  PhysicsFX_AddPhysicsFXShape(header.physicsFXShape);
}

/*
==============
DB_ReleasePhysicsFXShape
==============
*/
void DB_ReleasePhysicsFXShape(XAssetHeader header, DB_ReleaseType releaseType)
{
  PhysicsFX_ReleasePhysicsFXShape(header.physicsFXShape, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapPhysicsFXShape
==============
*/

void __fastcall DB_SwapPhysicsFXShape(XAssetHeader from, XAssetHeader to)
{
  PhysicsFX_SwapPhysicsFXShape(from.physicsFXShape, to.physicsFXShape);
}

/*
==============
DB_MovePhysicsFXShape
==============
*/

void __fastcall DB_MovePhysicsFXShape(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  PhysicsFX_MovePhysicsFXShape(from.physicsFXShape, to.physicsFXShape);
}

/*
==============
DB_CopyPhysicsFXShape
==============
*/
void DB_CopyPhysicsFXShape(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[5] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[5]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[5]);
  DB_SetXAssetHeaderName(5, to, toNewAssetName);
  PhysicsFX_CopyPhysicsFXShape(from.physicsFXShape, to.physicsFXShape);
}

/*
==============
DB_CreatePhysicsDebugData
==============
*/

void __fastcall DB_CreatePhysicsDebugData(XAssetHeader header, DB_CreateType createType)
{
  PhysPerfTrack_SetDebugDataAsset(header.physicsDebugData);
}

/*
==============
DB_ReleasePhysicsDebugData
==============
*/

void __fastcall DB_ReleasePhysicsDebugData(XAssetHeader header, DB_ReleaseType releaseType)
{
  PhysPerfTrack_ClearDebugDataAsset();
}

/*
==============
DB_CreateScriptDebugData
==============
*/

void __fastcall DB_CreateScriptDebugData(XAssetHeader header, DB_CreateType createType)
{
  ScriptDebugData_AddDebugData(header.scriptDebugData);
}

/*
==============
DB_ReleaseScriptDebugData
==============
*/

void __fastcall DB_ReleaseScriptDebugData(XAssetHeader header, DB_ReleaseType releaseType)
{
  ScriptDebugData_ReleaseDebugData(header.scriptDebugData);
}

/*
==============
DB_AllocXModel
==============
*/
XAssetHeader DB_AllocXModel(const XAssetType assetType)
{
  char *m_freeHead; 
  unsigned int m_maxUsedCount; 
  XModel *v3; 
  int v6; 

  if ( assetType != ASSET_TYPE_XMODEL )
  {
    v6 = 9;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 832, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_XMODEL )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_XMODEL", assetType, v6) )
      __debugbreak();
  }
  m_freeHead = (char *)s_assetPools[9].m_freeHead;
  if ( s_assetPools[9].m_freeHead )
  {
    m_maxUsedCount = ++s_assetPools[9].m_usedCount;
    if ( s_assetPools[9].m_maxUsedCount > s_assetPools[9].m_usedCount )
      m_maxUsedCount = s_assetPools[9].m_maxUsedCount;
    s_assetPools[9].m_maxUsedCount = m_maxUsedCount;
    v3 = (XModel *)s_assetPools[9].m_freeHead;
    s_assetPools[9].m_freeHead = *(void **)s_assetPools[9].m_freeHead;
    *(_QWORD *)(m_freeHead + 76) = 0i64;
    *((_DWORD *)m_freeHead + 21) = 0;
    Stream_DBAllocModel(v3);
    return (XAssetHeader)m_freeHead;
  }
  else
  {
    return 0i64;
  }
}

/*
==============
DB_FreeXModel
==============
*/
void DB_FreeXModel(const XAssetType assetType, const XAssetHeader header)
{
  Stream_DBFreeModel(header.model);
  if ( assetType != ASSET_TYPE_XMODEL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 857, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_XMODEL )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_XMODEL", assetType, 9) )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 858, ASSERT_TYPE_ASSERT, "(header.data)", (const char *)&queryFormat, "header.data") )
    __debugbreak();
  DB_AssetPool::Free(&s_assetPools[9], header.data);
}

/*
==============
DB_CreateXModelSurfs
==============
*/

void __fastcall DB_CreateXModelSurfs(XAssetHeader header, DB_CreateType createType)
{
  Stream_DBCreateMesh(header.modelSurfs);
}

/*
==============
DB_ReleaseXModelSurfs
==============
*/
void DB_ReleaseXModelSurfs(XAssetHeader header, DB_ReleaseType releaseType)
{
  unsigned __int16 i; 

  if ( releaseType == OWNS_RESOURCES )
  {
    for ( i = 0; i < *(_WORD *)&header.physicsLibrary[2].isMaterialList; ++i )
      XSurfaceReleaseResources((XSurface *)(*(_QWORD *)&header.physicsLibrary->isMaterialList + 192i64 * i));
  }
  Stream_DBPreReleaseMesh(header.modelSurfs);
}

/*
==============
DB_SwapXModelSurfs
==============
*/
void DB_SwapXModelSurfs(XAssetHeader from, XAssetHeader to)
{
  Stream_DBPreSwapMesh(from.modelSurfs, to.modelSurfs);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_XMODEL_SURFS);
}

/*
==============
DB_MoveXModelSurfs
==============
*/
void DB_MoveXModelSurfs(const XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  Stream_DBPreMoveMesh(from.modelSurfs, to.modelSurfs, toReleaseType == OWNS_RESOURCES);
  *(__m256i *)to.physicsLibrary = *(__m256i *)from.physicsLibrary;
  *(__m256i *)&to.physicsLibrary[1].isMaterialList = *(__m256i *)&from.physicsLibrary[1].isMaterialList;
  *(__m256i *)&to.physicsLibrary[2].havokData = *(__m256i *)&from.physicsLibrary[2].havokData;
}

/*
==============
DB_CopyXModelSurfs
==============
*/
void DB_CopyXModelSurfs(const XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[8] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[8]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[8]);
  DB_SetXAssetHeaderName(8, to, toNewAssetName);
  Stream_DBPostCopyMesh(from.modelSurfs, to.modelSurfs);
}

/*
==============
DB_CreateXModel
==============
*/
void DB_CreateXModel(XAssetHeader header, DB_CreateType createType)
{
  DB_XModelLookups_Create(header.model);
  Stream_DBCreateXModel(header.model);
  Physics_AddXModelAsset(header.model);
}

/*
==============
DB_ReleaseXModel
==============
*/
void DB_ReleaseXModel(XAssetHeader header, DB_ReleaseType releaseType)
{
  DB_XModelLookups_Release(header.model);
  Physics_ReleaseXModelAsset(header.model);
  Stream_DBPreReleaseXModel(header.model);
  if ( releaseType == OWNS_RESOURCES )
    XModelReleaseResources(header.model);
}

/*
==============
DB_SwapXModel
==============
*/
void DB_SwapXModel(XAssetHeader from, XAssetHeader to)
{
  DB_XModelLookups_Swap(from.model, to.model);
  Physics_SwapXModelAsset(from.model, to.model);
  Stream_DBPreSwapXModel(from.model, to.model);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_XMODEL);
}

/*
==============
DB_MoveXModel
==============
*/
void DB_MoveXModel(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  char **p_havokData; 
  signed __int64 v7; 
  __int64 v8; 

  DB_XModelLookups_Release(to.model);
  Physics_ReleaseXModelAsset(to.model);
  Stream_DBPreReleaseXModel(to.model);
  if ( toReleaseType == OWNS_RESOURCES )
    XModelReleaseResources(to.model);
  DB_XModelLookups_Move(from.model, to.model);
  Physics_MoveXModelAsset(from.model, to.model);
  Stream_DBPreMoveXModel(from.model, to.model);
  to.physicsLibrary->name = from.physicsLibrary->name;
  *(_WORD *)&to.physicsLibrary->isMaterialList = *(_WORD *)&from.physicsLibrary->isMaterialList;
  to.physicsLibrary->isMotionPropertiesList = from.physicsLibrary->isMotionPropertiesList;
  to.physicsLibrary->isGlobalTypeCompendium = from.physicsLibrary->isGlobalTypeCompendium;
  LOWORD(to.physicsLibrary->havokDataSize) = from.physicsLibrary->havokDataSize;
  BYTE2(to.physicsLibrary->havokDataSize) = BYTE2(from.physicsLibrary->havokDataSize);
  HIBYTE(to.physicsLibrary->havokDataSize) = HIBYTE(from.physicsLibrary->havokDataSize);
  LOBYTE(to.physicsLibrary->havokData) = from.physicsLibrary->havokData;
  BYTE1(to.physicsLibrary->havokData) = BYTE1(from.physicsLibrary->havokData);
  BYTE2(to.physicsLibrary->havokData) = BYTE2(from.physicsLibrary->havokData);
  BYTE3(to.physicsLibrary->havokData) = BYTE3(from.physicsLibrary->havokData);
  BYTE4(to.physicsLibrary->havokData) = BYTE4(from.physicsLibrary->havokData);
  BYTE5(to.physicsLibrary->havokData) = BYTE5(from.physicsLibrary->havokData);
  HIWORD(to.physicsLibrary->havokData) = HIWORD(from.physicsLibrary->havokData);
  LOBYTE(to.physicsLibrary[1].name) = from.physicsLibrary[1].name;
  HIDWORD(to.physicsLibrary[1].name) = HIDWORD(from.physicsLibrary[1].name);
  *(_DWORD *)&to.physicsLibrary[1].isMaterialList = *(_DWORD *)&from.physicsLibrary[1].isMaterialList;
  to.physicsLibrary[1].havokDataSize = from.physicsLibrary[1].havokDataSize;
  LODWORD(to.physicsLibrary[1].havokData) = from.physicsLibrary[1].havokData;
  *(_OWORD *)((char *)&to.physicsLibrary[1].havokData + 4) = *(_OWORD *)((char *)&from.physicsLibrary[1].havokData + 4);
  *(double *)&to.physicsLibrary[2].havokDataSize = *(double *)&from.physicsLibrary[2].havokDataSize;
  HIDWORD(to.physicsLibrary[2].havokData) = HIDWORD(from.physicsLibrary[2].havokData);
  LODWORD(to.physicsLibrary[3].name) = from.physicsLibrary[3].name;
  *(const char **)((char *)&to.physicsLibrary[3].name + 4) = *(const char **)((char *)&from.physicsLibrary[3].name + 4);
  to.physicsLibrary[3].havokDataSize = from.physicsLibrary[3].havokDataSize;
  LODWORD(to.physicsLibrary[3].havokData) = from.physicsLibrary[3].havokData;
  HIDWORD(to.physicsLibrary[3].havokData) = HIDWORD(from.physicsLibrary[3].havokData);
  LODWORD(to.physicsLibrary[4].name) = from.physicsLibrary[4].name;
  HIDWORD(to.physicsLibrary[4].name) = HIDWORD(from.physicsLibrary[4].name);
  *(_DWORD *)&to.physicsLibrary[4].isMaterialList = *(_DWORD *)&from.physicsLibrary[4].isMaterialList;
  to.physicsLibrary[4].havokDataSize = from.physicsLibrary[4].havokDataSize;
  LODWORD(to.physicsLibrary[4].havokData) = from.physicsLibrary[4].havokData;
  HIDWORD(to.physicsLibrary[4].havokData) = HIDWORD(from.physicsLibrary[4].havokData);
  to.physicsLibrary[5].name = from.physicsLibrary[5].name;
  *(_QWORD *)&to.physicsLibrary[5].isMaterialList = *(_QWORD *)&from.physicsLibrary[5].isMaterialList;
  to.physicsLibrary[5].havokData = from.physicsLibrary[5].havokData;
  p_havokData = &to.physicsLibrary[9].havokData;
  to.physicsLibrary[6].name = from.physicsLibrary[6].name;
  v7 = (char *)from.physicsLibrary - (char *)to.physicsLibrary;
  *(_QWORD *)&to.physicsLibrary[6].isMaterialList = *(_QWORD *)&from.physicsLibrary[6].isMaterialList;
  v8 = 6i64;
  to.physicsLibrary[6].havokData = from.physicsLibrary[6].havokData;
  to.physicsLibrary[7].name = from.physicsLibrary[7].name;
  *(_QWORD *)&to.physicsLibrary[7].isMaterialList = *(_QWORD *)&from.physicsLibrary[7].isMaterialList;
  to.physicsLibrary[7].havokData = from.physicsLibrary[7].havokData;
  to.physicsLibrary[8].name = from.physicsLibrary[8].name;
  *(_QWORD *)&to.physicsLibrary[8].isMaterialList = *(_QWORD *)&from.physicsLibrary[8].isMaterialList;
  to.physicsLibrary[8].havokData = from.physicsLibrary[8].havokData;
  to.physicsLibrary[9].name = from.physicsLibrary[9].name;
  do
  {
    *(p_havokData - 1) = *(char **)((char *)p_havokData + v7 - 8);
    *p_havokData = *(char **)((char *)p_havokData + v7);
    *((_DWORD *)p_havokData + 2) = *(_DWORD *)((char *)p_havokData + v7 + 8);
    *((_WORD *)p_havokData + 6) = *(_WORD *)((char *)p_havokData + v7 + 12);
    *((_WORD *)p_havokData + 7) = *(_WORD *)((char *)p_havokData + v7 + 14);
    *(__m256i *)(p_havokData + 2) = *(__m256i *)((char *)p_havokData + v7 + 16);
    *((_DWORD *)p_havokData + 12) = *(_DWORD *)((char *)p_havokData + v7 + 48);
    *((_BYTE *)p_havokData + 52) = *((_BYTE *)p_havokData + v7 + 52);
    p_havokData += 8;
    --v8;
  }
  while ( v8 );
  *(_QWORD *)&to.physicsLibrary[25].isMaterialList = *(_QWORD *)&from.physicsLibrary[25].isMaterialList;
  to.physicsLibrary[25].havokData = from.physicsLibrary[25].havokData;
  to.physicsLibrary[26].name = from.physicsLibrary[26].name;
  *(_QWORD *)&to.physicsLibrary[26].isMaterialList = *(_QWORD *)&from.physicsLibrary[26].isMaterialList;
  to.physicsLibrary[26].havokData = from.physicsLibrary[26].havokData;
  to.physicsLibrary[27].name = from.physicsLibrary[27].name;
  *(_QWORD *)&to.physicsLibrary[27].isMaterialList = *(_QWORD *)&from.physicsLibrary[27].isMaterialList;
  to.physicsLibrary[27].havokData = from.physicsLibrary[27].havokData;
  to.physicsLibrary[28].name = from.physicsLibrary[28].name;
}

/*
==============
DB_CopyXModel
==============
*/
void DB_CopyXModel(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  DB_XModelLookups_Copy(from.model, to.model);
  Physics_CopyXModelAsset(from.model, to.model);
  if ( g_assetSizes[9] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[9]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[9]);
  DB_SetXAssetHeaderName(9, to, toNewAssetName);
  *(const char **)((char *)&to.physicsLibrary[3].name + 4) = NULL;
  to.physicsLibrary[3].havokDataSize = 0;
  Stream_DBPostCopyXModel(from.model, to.model);
}

/*
==============
DB_CreateXModelDetailCollisionAsset
==============
*/

void __fastcall DB_CreateXModelDetailCollisionAsset(XAssetHeader header, DB_CreateType createType)
{
  Physics_AddXModelDetailCollisionAsset(header.modelDetailCollision);
}

/*
==============
DB_ReleaseXModelDetailCollisionAsset
==============
*/
void DB_ReleaseXModelDetailCollisionAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  Physics_ReleaseXModelDetailCollisionAsset(header.modelDetailCollision, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapXModelDetailCollisionAsset
==============
*/
void DB_SwapXModelDetailCollisionAsset(XAssetHeader from, XAssetHeader to)
{
  Physics_SwapXModelDetailCollisionAsset(from.modelDetailCollision, to.modelDetailCollision);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_XMODEL_DETAIL_COLLISION);
}

/*
==============
DB_MoveXModelDetailCollisionAsset
==============
*/
void DB_MoveXModelDetailCollisionAsset(XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  Physics_ReleaseXModelDetailCollisionAsset(to.modelDetailCollision, toReleaseType == OWNS_RESOURCES);
  Physics_MoveXModelDetailCollisionAsset(from.modelDetailCollision, to.modelDetailCollision);
  *(__m256i *)to.physicsLibrary = *(__m256i *)from.physicsLibrary;
  *(double *)&to.physicsLibrary[1].isMaterialList = *(double *)&from.physicsLibrary[1].isMaterialList;
}

/*
==============
DB_CopyXModelDetailCollisionAsset
==============
*/
void DB_CopyXModelDetailCollisionAsset(XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  Physics_CopyXModelDetailCollisionAsset(from.modelDetailCollision, to.modelDetailCollision);
  if ( g_assetSizes[97] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[97]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[97]);
  DB_SetXAssetHeaderName(97, to, toNewAssetName);
}

/*
==============
DB_ReleaseMayhemAsset
==============
*/
void DB_ReleaseMayhemAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    Mayhem_ReleaseResources(header.mayhem);
}

/*
==============
DB_CreateMaterial
==============
*/

void __fastcall DB_CreateMaterial(XAssetHeader header, DB_CreateType createType)
{
  Stream_DBCreateMaterial(header.material);
}

/*
==============
DB_ReleaseMaterial
==============
*/
void DB_ReleaseMaterial(XAssetHeader header, DB_ReleaseType releaseType)
{
  Stream_DBPreReleaseMaterial(header.material);
  if ( releaseType == OWNS_RESOURCES )
    Material_ReleaseMaterialResources(header.material);
}

/*
==============
DB_AllocMaterial
==============
*/
XAssetHeader DB_AllocMaterial(const XAssetType assetType)
{
  _BYTE *m_freeHead; 
  unsigned int m_maxUsedCount; 
  Material *v4; 
  XAssetType v6; 
  int v7; 

  ++rgp.addedMaterialCount;
  if ( !s_suppressMaterialSort )
    Material_DirtySort();
  if ( assetType != ASSET_TYPE_MATERIAL )
  {
    v7 = 11;
    v6 = assetType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1527, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_MATERIAL )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_MATERIAL", v6, v7) )
      __debugbreak();
  }
  m_freeHead = s_assetPools[11].m_freeHead;
  if ( s_assetPools[11].m_freeHead )
  {
    m_maxUsedCount = ++s_assetPools[11].m_usedCount;
    if ( s_assetPools[11].m_maxUsedCount > s_assetPools[11].m_usedCount )
      m_maxUsedCount = s_assetPools[11].m_maxUsedCount;
    s_assetPools[11].m_maxUsedCount = m_maxUsedCount;
    v4 = (Material *)s_assetPools[11].m_freeHead;
    s_assetPools[11].m_freeHead = *(void **)s_assetPools[11].m_freeHead;
    m_freeHead[28] = 0;
    Stream_DBAllocMaterial(v4);
    return (XAssetHeader)m_freeHead;
  }
  else
  {
    return 0i64;
  }
}

/*
==============
DB_FreeMaterial
==============
*/
void DB_FreeMaterial(const XAssetType assetType, const XAssetHeader header)
{
  ++rgp.killedMaterialCount;
  Stream_DBFreeMaterial(header.material);
  Material_DirtySort();
  if ( assetType != ASSET_TYPE_MATERIAL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1555, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_MATERIAL )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_MATERIAL", assetType, 11) )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1556, ASSERT_TYPE_ASSERT, "(header.data)", (const char *)&queryFormat, "header.data") )
    __debugbreak();
  DB_AssetPool::Free(&s_assetPools[11], header.data);
}

/*
==============
DB_FreeImage
==============
*/
void DB_FreeImage(const XAssetType assetType, const XAssetHeader header)
{
  CG_VisionSet_ValidateImageFree(header.image);
  if ( assetType != ASSET_TYPE_IMAGE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1568, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_IMAGE )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_IMAGE", assetType, 15) )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1569, ASSERT_TYPE_ASSERT, "(header.data)", (const char *)&queryFormat, "header.data") )
    __debugbreak();
  DB_AssetPool::Free(&s_assetPools[15], header.data);
}

/*
==============
DB_FreeGradingClut
==============
*/
void DB_FreeGradingClut(const XAssetType assetType, const XAssetHeader header)
{
  CG_VisionSet_ValidateGradingClutFree(header.gradingClut);
  if ( assetType != ASSET_TYPE_GRADING_CLUT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1581, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_GRADING_CLUT )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_GRADING_CLUT", assetType, 31) )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1582, ASSERT_TYPE_ASSERT, "(header.data)", (const char *)&queryFormat, "header.data") )
    __debugbreak();
  DB_AssetPool::Free(&s_assetPools[31], header.data);
}

/*
==============
DB_FreeFogSpline
==============
*/
void DB_FreeFogSpline(const XAssetType assetType, const XAssetHeader header)
{
  CG_VisionSet_ValidateFogSplineFree(header.fogSpline);
  if ( assetType != ASSET_TYPE_FOG_SPLINE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1594, ASSERT_TYPE_ASSERT, "( assetType ) == ( ASSET_TYPE_FOG_SPLINE )", "%s == %s\n\t%u, %u", "assetType", "ASSET_TYPE_FOG_SPLINE", assetType, 33) )
    __debugbreak();
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1595, ASSERT_TYPE_ASSERT, "(header.data)", (const char *)&queryFormat, "header.data") )
    __debugbreak();
  DB_AssetPool::Free(&s_assetPools[33], header.data);
}

/*
==============
DB_SwapMaterial
==============
*/
void DB_SwapMaterial(const XAssetHeader from, XAssetHeader to)
{
  __int128 v4; 

  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1602, ASSERT_TYPE_ASSERT, "(mtl)", (const char *)&queryFormat, "mtl") )
    __debugbreak();
  v4 = *(_OWORD *)&to.physicsLibrary[1].havokData;
  Stream_DBPreSwapMaterial(from.material, to.material);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_MATERIAL);
  *(_OWORD *)&to.physicsLibrary[1].havokData = v4;
}

/*
==============
DB_CopyMaterial
==============
*/
void DB_CopyMaterial(const XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[11] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[11]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[11]);
  DB_SetXAssetHeaderName(11, to, toNewAssetName);
  Stream_DBPostCopyMaterial(from.material, to.material);
}

/*
==============
DB_MoveMaterial
==============
*/
void DB_MoveMaterial(const XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  __int128 v6; 

  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1602, ASSERT_TYPE_ASSERT, "(mtl)", (const char *)&queryFormat, "mtl") )
    __debugbreak();
  v6 = *(_OWORD *)&to.physicsLibrary[1].havokData;
  Stream_DBPreMoveMaterial(from.material, to.material);
  if ( off_147903D98 )
    ((void (__fastcall *)(_QWORD, _QWORD))off_147903D98)((XAssetHeader)to.physicsLibrary, (unsigned int)toReleaseType);
  if ( g_assetSizes[11] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[11]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[11]);
  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1609, ASSERT_TYPE_ASSERT, "(mtl)", (const char *)&queryFormat, "mtl") )
    __debugbreak();
  *(_OWORD *)&to.physicsLibrary[1].havokData = v6;
}

/*
==============
DB_ReleaseComputeShader
==============
*/
void DB_ReleaseComputeShader(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    Material_ReleaseComputeShaderResources(header.computeShader);
}

/*
==============
DB_ReleaseTechniqueSet
==============
*/
void DB_ReleaseTechniqueSet(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    Material_ReleaseTechniqueSetResources(header.techniqueSet);
}

/*
==============
DB_CreateGfxImageAsset
==============
*/
void DB_CreateGfxImageAsset(XAssetHeader header, DB_CreateType createType)
{
  Stream_DBCreateImage(header.image);
  if ( ((__int64)header.physicsLibrary[1].name & 0x40) != 0 )
    R_Texture_CreateStreamedDefault(header.image);
  else
    R_Texture_CreateResident(header.image);
  if ( BYTE2(header.physicsLibrary[2].name) )
    R_DecalVolumes_CreateGfxImageAsset(header.image);
}

/*
==============
DB_ReleaseGfxImageAsset
==============
*/
void DB_ReleaseGfxImageAsset(XAssetHeader header, DB_ReleaseType releaseType)
{
  Stream_DBPreReleaseImage(header.image);
  if ( !R_Texture_IsValidTextureId((GfxTextureId)header.physicsLibrary->havokData) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2187, ASSERT_TYPE_ASSERT, "(R_Texture_IsValidTextureId( header.image->textureId ))", (const char *)&queryFormat, "R_Texture_IsValidTextureId( header.image->textureId )") )
    __debugbreak();
  if ( (releaseType == OWNS_RESOURCES) != R_Texture_IsOwnerId((GfxTextureId)header.physicsLibrary->havokData) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2188, ASSERT_TYPE_ASSERT, "((releaseType == DB_ReleaseType::OWNS_RESOURCES) == R_Texture_IsOwnerId( header.image->textureId ))", (const char *)&queryFormat, "(releaseType == DB_ReleaseType::OWNS_RESOURCES) == R_Texture_IsOwnerId( header.image->textureId )") )
    __debugbreak();
  Image_Release(header.image);
  if ( BYTE2(header.physicsLibrary[2].name) )
    R_DecalVolumes_ReleaseGfxImageAsset(header.image, releaseType == OWNS_RESOURCES);
}

/*
==============
DB_SwapGfxImage
==============
*/
void DB_SwapGfxImage(const XAssetHeader from, XAssetHeader to)
{
  int havokData; 

  if ( BYTE2(from.physicsLibrary[2].name) || BYTE2(to.physicsLibrary[2].name) )
    R_DecalVolumes_SwapGfxImage(from.image, to.image);
  Stream_DBPreSwapImage(from.image, to.image);
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_IMAGE);
  havokData = (int)from.physicsLibrary->havokData;
  LODWORD(from.physicsLibrary->havokData) = to.physicsLibrary->havokData;
  LODWORD(to.physicsLibrary->havokData) = havokData;
  R_Texture_Swap((GfxTextureId *)&from.physicsLibrary->havokData, (GfxTextureId *)&to.physicsLibrary->havokData);
  if ( BYTE2(from.physicsLibrary[2].name) || BYTE2(to.physicsLibrary[2].name) )
    R_DecalVolumes_SwapGfxImageEnd(from.image, to.image);
  XPak_CheckAdjacencyInfo(from.image);
  XPak_CheckAdjacencyInfo(to.image);
}

/*
==============
DB_MoveGfxImage
==============
*/
void DB_MoveGfxImage(const XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  unsigned int TextureIdIndex; 
  char v7; 
  unsigned int v8; 
  unsigned int v9; 
  GfxTextureId toId; 

  if ( BYTE2(from.physicsLibrary[2].name) )
  {
    R_DecalVolumes_MoveGfxImage(from.image, to.image, toReleaseType == OWNS_RESOURCES);
  }
  else if ( BYTE2(to.physicsLibrary[2].name) )
  {
    R_DecalVolumes_ReleaseGfxImageAsset(to.image, toReleaseType == OWNS_RESOURCES);
  }
  if ( !R_Texture_IsValidTextureId((GfxTextureId)from.physicsLibrary->havokData) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2262, ASSERT_TYPE_ASSERT, "(R_Texture_IsValidTextureId( from.image->textureId ))", (const char *)&queryFormat, "R_Texture_IsValidTextureId( from.image->textureId )") )
    __debugbreak();
  if ( !R_Texture_IsValidTextureId((GfxTextureId)to.physicsLibrary->havokData) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2263, ASSERT_TYPE_ASSERT, "(R_Texture_IsValidTextureId( to.image->textureId ))", (const char *)&queryFormat, "R_Texture_IsValidTextureId( to.image->textureId )") )
    __debugbreak();
  if ( (toReleaseType == OWNS_RESOURCES) != R_Texture_IsOwnerId((GfxTextureId)to.physicsLibrary->havokData) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2264, ASSERT_TYPE_ASSERT, "((toReleaseType == DB_ReleaseType::OWNS_RESOURCES) == R_Texture_IsOwnerId( to.image->textureId ))", (const char *)&queryFormat, "(toReleaseType == DB_ReleaseType::OWNS_RESOURCES) == R_Texture_IsOwnerId( to.image->textureId )") )
    __debugbreak();
  toId = (GfxTextureId)to.physicsLibrary->havokData;
  if ( Stream_DBPreMoveImage(from.image, to.image, toReleaseType == OWNS_RESOURCES) )
    R_Texture_Move((GfxTextureId *)&from.physicsLibrary->havokData, &toId);
  else
    R_Texture_Destroy((GfxTextureId)from.physicsLibrary->havokData);
  TextureIdIndex = R_Texture_GetTextureIdIndex(toId);
  if ( TextureIdIndex != R_Texture_GetTextureIdIndex((GfxTextureId)to.physicsLibrary->havokData) )
  {
    v9 = R_Texture_GetTextureIdIndex((GfxTextureId)to.physicsLibrary->havokData);
    v8 = R_Texture_GetTextureIdIndex(toId);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2284, ASSERT_TYPE_ASSERT, "( R_Texture_GetTextureIdIndex( textureId ) ) == ( R_Texture_GetTextureIdIndex( to.image->textureId ) )", "%s == %s\n\t%i, %i", "R_Texture_GetTextureIdIndex( textureId )", "R_Texture_GetTextureIdIndex( to.image->textureId )", v8, v9) )
      __debugbreak();
  }
  *(_OWORD *)&to.physicsLibrary->name = *(_OWORD *)&from.physicsLibrary->name;
  *(_OWORD *)&to.physicsLibrary->havokData = *(_OWORD *)&from.physicsLibrary->havokData;
  *(_OWORD *)&to.physicsLibrary[1].isMaterialList = *(_OWORD *)&from.physicsLibrary[1].isMaterialList;
  *(_OWORD *)&to.physicsLibrary[2].name = *(_OWORD *)&from.physicsLibrary[2].name;
  *(_OWORD *)&to.physicsLibrary[2].havokData = *(_OWORD *)&from.physicsLibrary[2].havokData;
  *(_OWORD *)&to.physicsLibrary[3].isMaterialList = *(_OWORD *)&from.physicsLibrary[3].isMaterialList;
  *(_OWORD *)&to.physicsLibrary[4].name = *(_OWORD *)&from.physicsLibrary[4].name;
  *(_OWORD *)&to.physicsLibrary[4].havokData = *(_OWORD *)&from.physicsLibrary[4].havokData;
  *(_OWORD *)&to.physicsLibrary[5].isMaterialList = *(_OWORD *)&from.physicsLibrary[5].isMaterialList;
  *(_OWORD *)&to.physicsLibrary[6].name = *(_OWORD *)&from.physicsLibrary[6].name;
  *(_OWORD *)&to.physicsLibrary[6].havokData = *(_OWORD *)&from.physicsLibrary[6].havokData;
  *(_OWORD *)&to.physicsLibrary[7].isMaterialList = *(_OWORD *)&from.physicsLibrary[7].isMaterialList;
  *(_OWORD *)&to.physicsLibrary[8].name = *(_OWORD *)&from.physicsLibrary[8].name;
  *(_OWORD *)&to.physicsLibrary[8].havokData = *(_OWORD *)&from.physicsLibrary[8].havokData;
  *(_QWORD *)&to.physicsLibrary[9].isMaterialList = *(_QWORD *)&from.physicsLibrary[9].isMaterialList;
  LODWORD(to.physicsLibrary->havokData) = toId;
  v7 = BYTE2(from.physicsLibrary[2].name);
  BYTE2(to.physicsLibrary[2].name) = v7;
  if ( v7 )
    R_DecalVolumes_MoveGfxImageEnd(to.image);
  XPak_CheckAdjacencyInfo(to.image);
}

/*
==============
DB_CopyGfxImage
==============
*/
void DB_CopyGfxImage(const XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  GfxTextureId havokData; 
  GfxTextureId toId; 

  if ( BYTE2(from.physicsLibrary[2].name) )
    R_DecalVolumes_CopyGfxImage(from.image, to.image, toNewAssetName);
  havokData = (GfxTextureId)from.physicsLibrary->havokData;
  toId = NULLID;
  R_Texture_Copy(havokData, &toId);
  if ( g_assetSizes[15] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[15]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[15]);
  DB_SetXAssetHeaderName(15, to, toNewAssetName);
  LODWORD(to.physicsLibrary->havokData) = toId;
  Stream_DBPostCopyImage(from.image, to.image);
}

/*
==============
DB_CreateClipMapAsset
==============
*/
void DB_CreateClipMapAsset(XAssetHeader header, DB_CreateType createType)
{
  Physics_AddClipMap(header.clipMap);
  WorldCollision_AddClipMap(header.clipMap);
  StaticModels_AddClipMap(header.clipMap);
}

/*
==============
DB_ReleaseClipMap
==============
*/
void DB_ReleaseClipMap(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
  {
    StaticModels_RemoveClipMap(header.clipMap);
    WorldCollision_RemoveClipMap(header.clipMap);
    Physics_RemoveClipMap(header.clipMap);
    SND_RemoveClipMap(header.clipMap);
    CM_Unload(header.clipMap);
  }
}

/*
==============
DB_ReleaseComWorld
==============
*/
void DB_ReleaseComWorld(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    Com_UnloadWorld(header.comWorld);
}

/*
==============
DB_CreateNavMeshAsset
==============
*/

void __fastcall DB_CreateNavMeshAsset(XAssetHeader header, DB_CreateType createType)
{
  Nav_AddPendingMesh(header.navMeshData);
}

/*
==============
DB_ReleaseNavMesh
==============
*/
void DB_ReleaseNavMesh(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    Nav_RemoveNavMeshData(header.navMeshData);
}

/*
==============
DB_CreateCoverSelectorAsset
==============
*/

void __fastcall DB_CreateCoverSelectorAsset(XAssetHeader header, DB_CreateType createType)
{
  CoverSelector_Add(header.coverSelector);
}

/*
==============
DB_ReleaseCoverSelector
==============
*/
void DB_ReleaseCoverSelector(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    CoverSelector_Remove(header.coverSelector);
}

/*
==============
DB_CreateEnemySelectorAsset
==============
*/

void __fastcall DB_CreateEnemySelectorAsset(XAssetHeader header, DB_CreateType createType)
{
  EnemySelector_Add(header.enemySelector);
}

/*
==============
DB_ReleaseEnemySelector
==============
*/
void DB_ReleaseEnemySelector(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    EnemySelector_Remove(header.enemySelector);
}

/*
==============
DB_CreateMapEntsAsset
==============
*/

void __fastcall DB_CreateMapEntsAsset(XAssetHeader header, DB_CreateType createType)
{
  WorldCollision_AddMapEnts(header.mapEnts);
}

/*
==============
DB_ReleaseMapEnts
==============
*/
void DB_ReleaseMapEnts(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    WorldCollision_RemoveMapEnts(header.mapEnts);
}

/*
==============
DB_SwapMapEntsAsset
==============
*/
void DB_SwapMapEntsAsset(const XAssetHeader from, XAssetHeader to)
{
  DB_SwapXAssetDefault(from, to, ASSET_TYPE_MAP_ENTS);
  WorldCollision_SwapMapEnts(from.mapEnts, to.mapEnts);
}

/*
==============
DB_MoveMapEntsAsset
==============
*/
void DB_MoveMapEntsAsset(const XAssetHeader from, XAssetHeader to, DB_ReleaseType toReleaseType)
{
  if ( off_147903E08 )
    ((void (__fastcall *)(_QWORD, _QWORD))off_147903E08)((XAssetHeader)to.physicsLibrary, (unsigned int)toReleaseType);
  if ( g_assetSizes[25] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[25]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[25]);
  WorldCollision_MoveMapEnts(from.mapEnts, to.mapEnts);
}

/*
==============
DB_CopyMapEntsAsset
==============
*/
void DB_CopyMapEntsAsset(const XAssetHeader from, XAssetHeader to, const char *toNewAssetName)
{
  if ( g_assetSizes[25] > s_largestAssetPoolItem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[25]) )
    __debugbreak();
  memcpy_0(to.data, from.physicsLibrary, g_assetSizes[25]);
  DB_SetXAssetHeaderName(25, to, toNewAssetName);
}

/*
==============
DB_ReleaseGfxWorld
==============
*/
void DB_ReleaseGfxWorld(XAssetHeader header, DB_ReleaseType releaseType)
{
  if ( releaseType == OWNS_RESOURCES )
    R_ReleaseWorld(header.gfxWorld);
}

/*
==============
DB_CreateGfxWorldTransientZone
==============
*/
void DB_CreateGfxWorldTransientZone(const XAssetHeader header, const DB_CreateType createType)
{
  unsigned int Item; 

  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2940, ASSERT_TYPE_ASSERT, "(header.gfxWorldTransientZone)", (const char *)&queryFormat, "header.gfxWorldTransientZone") )
    __debugbreak();
  if ( createType == NEW_LIVE_HEAD && DB_GfxWorldTransientZone_IsValidTransientZone(header.gfxWorldTransientZone) )
  {
    Item = DB_AssetPool_GetItemIndex<GfxWorldTransientZone>(ASSET_TYPE_GFXWORLD_TRANSIENT_ZONE, header.gfxWorldTransientZone);
    DB_GfxWorldTransientZone_SetValid(Item);
  }
}

/*
==============
DB_AssetPool_GetItemIndex<Camo>
==============
*/
unsigned __int64 DB_AssetPool_GetItemIndex<Camo>(const XAssetType assetType, const Camo *ptr)
{
  __int64 v2; 
  void **v4; 
  __int64 v5; 
  const Camo *m_entries; 
  unsigned __int64 m_elementSize; 
  const char *v8; 
  int v9; 
  const char *v10; 
  const char *v11; 

  v2 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 264, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPoolMem ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPoolMem )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  v4 = &s_assetPoolMem[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  v5 = v2;
  if ( s_assetPools[v5].m_elementSize != 184 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  m_entries = (const Camo *)s_assetPools[v5].m_entries;
  if ( ptr < m_entries || (m_elementSize = s_assetPools[v5].m_elementSize, ptr >= (const Camo *)((char *)m_entries + (unsigned int)(m_elementSize * s_assetPools[v5].m_poolSize))) )
  {
    v8 = "s_assetPools[assetType].IsInPool( ptr )";
    v9 = 267;
    v10 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !(((char *)ptr - (char *)m_entries) % m_elementSize) )
      return ((char *)ptr - (_BYTE *)*v4) / 0xB8ui64;
    v8 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v9 = 127;
    v10 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v11, v9, ASSERT_TYPE_ASSERT, v10, (const char *)&queryFormat, v8) )
    __debugbreak();
  return ((char *)ptr - (_BYTE *)*v4) / 0xB8ui64;
}

/*
==============
DB_AssetPool_GetItemIndex<FxWorldTransientZone>
==============
*/
__int64 DB_AssetPool_GetItemIndex<FxWorldTransientZone>(const XAssetType assetType, const FxWorldTransientZone *ptr)
{
  __int64 v2; 
  void **v4; 
  __int64 v5; 
  const FxWorldTransientZone *m_entries; 
  unsigned __int64 m_elementSize; 
  const char *v8; 
  int v9; 
  const char *v10; 
  const char *v11; 

  v2 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 264, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPoolMem ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPoolMem )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  v4 = &s_assetPoolMem[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  v5 = v2;
  if ( s_assetPools[v5].m_elementSize != 160 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  m_entries = (const FxWorldTransientZone *)s_assetPools[v5].m_entries;
  if ( ptr < m_entries || (m_elementSize = s_assetPools[v5].m_elementSize, ptr >= (const FxWorldTransientZone *)((char *)m_entries + (unsigned int)(m_elementSize * s_assetPools[v5].m_poolSize))) )
  {
    v8 = "s_assetPools[assetType].IsInPool( ptr )";
    v9 = 267;
    v10 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !(((char *)ptr - (char *)m_entries) % m_elementSize) )
      return (unsigned int)(((char *)ptr - (_BYTE *)*v4) / 0xA0ui64);
    v8 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v9 = 127;
    v10 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v11, v9, ASSERT_TYPE_ASSERT, v10, (const char *)&queryFormat, v8) )
    __debugbreak();
  return (unsigned int)(((char *)ptr - (_BYTE *)*v4) / 0xA0ui64);
}

/*
==============
DB_AssetPool_GetItemIndex<GfxImage>
==============
*/
unsigned __int64 DB_AssetPool_GetItemIndex<GfxImage>(const XAssetType assetType, const GfxImage *ptr)
{
  __int64 v2; 
  void **v4; 
  __int64 v5; 
  const GfxImage *m_entries; 
  unsigned __int64 m_elementSize; 
  const char *v8; 
  int v9; 
  const char *v10; 
  const char *v11; 

  v2 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 264, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPoolMem ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPoolMem )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  v4 = &s_assetPoolMem[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  v5 = v2;
  if ( s_assetPools[v5].m_elementSize != 232 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  m_entries = (const GfxImage *)s_assetPools[v5].m_entries;
  if ( ptr < m_entries || (m_elementSize = s_assetPools[v5].m_elementSize, ptr >= (const GfxImage *)((char *)m_entries + (unsigned int)(m_elementSize * s_assetPools[v5].m_poolSize))) )
  {
    v8 = "s_assetPools[assetType].IsInPool( ptr )";
    v9 = 267;
    v10 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !(((char *)ptr - (char *)m_entries) % m_elementSize) )
      return ((char *)ptr - (_BYTE *)*v4) / 0xE8ui64;
    v8 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v9 = 127;
    v10 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v11, v9, ASSERT_TYPE_ASSERT, v10, (const char *)&queryFormat, v8) )
    __debugbreak();
  return ((char *)ptr - (_BYTE *)*v4) / 0xE8ui64;
}

/*
==============
DB_AssetPool_GetItemIndex<GfxWorldTransientZone>
==============
*/
__int64 DB_AssetPool_GetItemIndex<GfxWorldTransientZone>(const XAssetType assetType, const GfxWorldTransientZone *ptr)
{
  __int64 v2; 
  void **v4; 
  __int64 v5; 
  const GfxWorldTransientZone *m_entries; 
  unsigned __int64 m_elementSize; 
  const char *v8; 
  int v9; 
  const char *v10; 
  const char *v11; 

  v2 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 264, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPoolMem ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPoolMem )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  v4 = &s_assetPoolMem[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  v5 = v2;
  if ( s_assetPools[v5].m_elementSize != 256 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  m_entries = (const GfxWorldTransientZone *)s_assetPools[v5].m_entries;
  if ( ptr < m_entries || (m_elementSize = s_assetPools[v5].m_elementSize, ptr >= (const GfxWorldTransientZone *)((char *)m_entries + (unsigned int)(m_elementSize * s_assetPools[v5].m_poolSize))) )
  {
    v8 = "s_assetPools[assetType].IsInPool( ptr )";
    v9 = 267;
    v10 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !(((char *)ptr - (char *)m_entries) % m_elementSize) )
      return (unsigned int)((unsigned __int64)((char *)ptr - (_BYTE *)*v4) >> 8);
    v8 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v9 = 127;
    v10 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v11, v9, ASSERT_TYPE_ASSERT, v10, (const char *)&queryFormat, v8) )
    __debugbreak();
  return (unsigned int)((unsigned __int64)((char *)ptr - (_BYTE *)*v4) >> 8);
}

/*
==============
DB_AssetPool_GetItemIndex<StreamingInfo>
==============
*/
unsigned __int64 DB_AssetPool_GetItemIndex<StreamingInfo>(const XAssetType assetType, const StreamingInfo *ptr)
{
  __int64 v2; 
  void **v4; 
  __int64 v5; 
  const StreamingInfo *m_entries; 
  unsigned __int64 m_elementSize; 
  const char *v8; 
  int v9; 
  const char *v10; 
  const char *v11; 

  v2 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 264, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPoolMem ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPoolMem )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  v4 = &s_assetPoolMem[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  v5 = v2;
  if ( s_assetPools[v5].m_elementSize != 184 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  m_entries = (const StreamingInfo *)s_assetPools[v5].m_entries;
  if ( ptr < m_entries || (m_elementSize = s_assetPools[v5].m_elementSize, ptr >= (const StreamingInfo *)((char *)m_entries + (unsigned int)(m_elementSize * s_assetPools[v5].m_poolSize))) )
  {
    v8 = "s_assetPools[assetType].IsInPool( ptr )";
    v9 = 267;
    v10 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !(((char *)ptr - (char *)m_entries) % m_elementSize) )
      return ((char *)ptr - (_BYTE *)*v4) / 0xB8ui64;
    v8 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v9 = 127;
    v10 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v11, v9, ASSERT_TYPE_ASSERT, v10, (const char *)&queryFormat, v8) )
    __debugbreak();
  return ((char *)ptr - (_BYTE *)*v4) / 0xB8ui64;
}

/*
==============
DB_AssetPool_GetItemIndex<WeaponAttachment>
==============
*/
unsigned __int64 DB_AssetPool_GetItemIndex<WeaponAttachment>(const XAssetType assetType, const WeaponAttachment *ptr)
{
  __int64 v2; 
  void **v4; 
  __int64 v5; 
  const WeaponAttachment *m_entries; 
  unsigned __int64 m_elementSize; 
  const char *v8; 
  int v9; 
  const char *v10; 
  const char *v11; 

  v2 = assetType;
  if ( (unsigned int)assetType >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 264, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ( sizeof( *array_counter( s_assetPoolMem ) ) + 0 ) )", "assetType doesn't index ARRAY_COUNT( s_assetPoolMem )\n\t%i not in [0, %i)", assetType, 113) )
    __debugbreak();
  v4 = &s_assetPoolMem[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  v5 = v2;
  if ( s_assetPools[v5].m_elementSize != 976 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  m_entries = (const WeaponAttachment *)s_assetPools[v5].m_entries;
  if ( ptr < m_entries || (m_elementSize = s_assetPools[v5].m_elementSize, ptr >= (const WeaponAttachment *)((char *)m_entries + (unsigned int)(m_elementSize * s_assetPools[v5].m_poolSize))) )
  {
    v8 = "s_assetPools[assetType].IsInPool( ptr )";
    v9 = 267;
    v10 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !(((char *)ptr - (char *)m_entries) % m_elementSize) )
      return ((char *)ptr - (_BYTE *)*v4) / 0x3D0ui64;
    v8 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v9 = 127;
    v10 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v11 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v11, v9, ASSERT_TYPE_ASSERT, v10, (const char *)&queryFormat, v8) )
    __debugbreak();
  return ((char *)ptr - (_BYTE *)*v4) / 0x3D0ui64;
}

/*
==============
DB_AllocXAssetHeader
==============
*/
XAssetHeader DB_AllocXAssetHeader(XAssetType type)
{
  __int64 v1; 
  XAssetHeader result; 
  const void *physicsLibrary; 
  __int64 v4; 
  __int64 v6; 
  int v7; 

  v1 = type;
  if ( (unsigned int)type >= ASSET_TYPE_COUNT )
  {
    v7 = 113;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8242, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_allocXAssetHeaderHandler ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_allocXAssetHeaderHandler )\n\t%i not in [0, %i)", type, v7) )
      __debugbreak();
  }
  result.physicsLibrary = s_allocXAssetHeaderHandler[v1]((const XAssetType)v1).physicsLibrary;
  physicsLibrary = result.physicsLibrary;
  if ( result.physicsLibrary )
  {
    ++db_assetCount[v1];
    if ( (unsigned int)v1 >= 0x71 )
    {
      LODWORD(v6) = 113;
      LODWORD(v4) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ASSET_TYPE_COUNT )", "assetType doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v4, v6) )
        __debugbreak();
    }
    IWMem_Alloc(s_iwMemAssetPools[v1], physicsLibrary, g_assetSizes[v1]);
    return (XAssetHeader)physicsLibrary;
  }
  return result;
}

/*
==============
DB_AllocateXAssetPoolMem
==============
*/
char DB_AllocateXAssetPoolMem()
{
  unsigned __int64 v0; 
  unsigned int i; 
  unsigned __int64 v2; 
  __int64 v3; 
  unsigned int v4; 
  unsigned int v5; 
  unsigned int v6; 
  char result; 
  char *fmt; 
  __int64 v9; 
  __int64 v10; 

  v0 = 0i64;
  PMem_BeginAlloc("$database", PMEM_STACK_GAME);
  Com_Printf(0, "\nAsset Pool Allocations:\n");
  for ( i = 0; i < 0x71; ++i )
  {
    v2 = 0i64;
    v3 = (int)i;
    if ( s_assetPoolMem[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 7896, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[type] == nullptr)", (const char *)&queryFormat, "s_assetPoolMem[type] == nullptr") )
      __debugbreak();
    v4 = s_poolSize[i];
    if ( s_assetSingletons[v3] )
    {
      if ( v4 != 1 )
      {
        LODWORD(v10) = 1;
        LODWORD(v9) = s_poolSize[i];
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 7902, ASSERT_TYPE_ASSERT, "( poolSize ) == ( 1 )", "%s == %s\n\t%u, %u", "poolSize", "1", v9, v10) )
          __debugbreak();
      }
      s_assetPoolMem[v3] = s_assetSingletons[v3];
    }
    else if ( v4 )
    {
      v5 = g_assetSizes[i];
      v2 = v4 * v5;
      s_assetPoolMem[v3] = PMem_Alloc(v2, g_assetAlignment[i], MEM_POOL_MAIN, PMEM_STACK_GAME, g_assetNames[v3]);
      v6 = s_largestAssetPoolItem;
      if ( v5 > s_largestAssetPoolItem )
        v6 = v5;
      s_largestAssetPoolItem = v6;
      LODWORD(fmt) = v4;
      Com_Printf(0, "%30s : Element Size=%6u Pool Size=%6u Memory Size=%5zu kb\n", g_assetNames[v3], v5, fmt, v2 >> 10);
    }
    else
    {
      s_assetPoolMem[v3] = NULL;
    }
    v0 += v2;
  }
  Com_Printf(0, "\tTotal Asset Pool Allocation Size : %zu kb\n\n", v0 >> 10);
  PMem_EndAlloc("$database", PMEM_STACK_GAME);
  result = s_largestAssetPoolItem;
  if ( s_largestAssetPoolItem > 0x1000 )
  {
    LODWORD(v10) = 4096;
    LODWORD(v9) = s_largestAssetPoolItem;
    result = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8043, ASSERT_TYPE_ASSERT, "( s_largestAssetPoolItem ) <= ( LARGEST_POOLED_ASSET_SIZE )", "%s <= %s\n\t%u, %u", "s_largestAssetPoolItem", "LARGEST_POOLED_ASSET_SIZE", v9, v10);
    if ( result )
      __debugbreak();
  }
  return result;
}

/*
==============
DB_AssetCount
==============
*/
__int64 DB_AssetCount(XAssetType type)
{
  __int64 v1; 
  int v4; 

  v1 = type;
  if ( (unsigned int)type >= ASSET_TYPE_COUNT )
  {
    v4 = 113;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8281, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", type, v4) )
      __debugbreak();
  }
  return (unsigned int)db_assetCount[v1];
}

/*
==============
DB_AssetTypeHasADefaultAsset
==============
*/
char DB_AssetTypeHasADefaultAsset(const XAssetType type)
{
  __int64 v1; 
  __int64 v2; 
  __int64 v4; 
  __int64 v5; 

  v1 = type;
  switch ( type )
  {
    case ASSET_TYPE_COMPUTESHADER:
    case ASSET_TYPE_SOUND_BANK:
    case ASSET_TYPE_SOUND_BANK_TRANSIENT:
    case ASSET_TYPE_MAP_ENTS:
    case ASSET_TYPE_STREAM_KEY:
    case ASSET_TYPE_KEYVALUEPAIRS:
      v2 = type;
      goto LABEL_3;
    default:
      if ( (unsigned int)type >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8318, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_poolSize ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_poolSize )\n\t%i not in [0, %i)", type, 113) )
        __debugbreak();
      v2 = v1;
      if ( s_poolSize[v1] <= 1 )
      {
LABEL_3:
        if ( (unsigned int)v1 >= 0x71 )
        {
          LODWORD(v5) = 113;
          LODWORD(v4) = v1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 29, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v4, v5) )
            __debugbreak();
        }
        if ( *g_defaultAssetName[v2] )
        {
          if ( (unsigned int)v1 >= 0x71 )
          {
            LODWORD(v5) = 113;
            LODWORD(v4) = v1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v4, v5) )
              __debugbreak();
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8375, ASSERT_TYPE_ASSERT, "( ( DB_GetDefaultXAssetName( type )[0] == '\\0' ) )", "( DB_GetXAssetTypeName( type ) ) = %s", g_assetNames[v2]) )
            __debugbreak();
        }
        return 0;
      }
      else
      {
        if ( (unsigned int)v1 >= 0x71 )
        {
          LODWORD(v5) = 113;
          LODWORD(v4) = v1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 29, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v4, v5) )
            __debugbreak();
        }
        if ( !*g_defaultAssetName[v1] )
        {
          if ( (unsigned int)v1 >= 0x71 )
          {
            LODWORD(v5) = 113;
            LODWORD(v4) = v1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v4, v5) )
              __debugbreak();
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8370, ASSERT_TYPE_ASSERT, "( ( DB_GetDefaultXAssetName( type )[0] != '\\0' ) )", "( DB_GetXAssetTypeName( type ) ) = %s", g_assetNames[v1]) )
            __debugbreak();
        }
        return 1;
      }
  }
}

/*
==============
DB_CopyXAsset
==============
*/
void DB_CopyXAsset(XAssetHeader from, XAssetHeader to, XAssetType type, const char *toAssetNewName)
{
  __int64 v4; 
  const char *name; 
  __int64 v9; 
  const char *v10; 
  signed __int64 v11; 
  char v12; 
  __int64 v13; 
  char v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 

  v4 = type;
  if ( !from.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8179, ASSERT_TYPE_ASSERT, "(from.data)", (const char *)&queryFormat, "from.data") )
    __debugbreak();
  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8180, ASSERT_TYPE_ASSERT, "(to.data)", (const char *)&queryFormat, "to.data") )
    __debugbreak();
  if ( from.physicsLibrary == to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8181, ASSERT_TYPE_ASSERT, "(from.data != to.data)", (const char *)&queryFormat, "from.data != to.data") )
    __debugbreak();
  if ( (unsigned int)v4 >= 0x71 )
  {
    LODWORD(v15) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8182, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, 113) )
      __debugbreak();
    LODWORD(v22) = 113;
    LODWORD(v16) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v22) )
      __debugbreak();
    LODWORD(v23) = 113;
    LODWORD(v17) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v17, v23) )
      __debugbreak();
  }
  if ( !g_assetNameFieldValid[v4] )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v21) = 113;
      LODWORD(v15) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v4], from.physicsLibrary) )
      __debugbreak();
  }
  if ( !from.physicsLibrary )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v21) = 113;
      LODWORD(v15) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v4]) )
      __debugbreak();
  }
  if ( !DB_IsPermanentAssetNonLocking((XAssetType)v4, from.physicsLibrary->name) )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v21) = 113;
      LODWORD(v15) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
        __debugbreak();
      LODWORD(v24) = 113;
      LODWORD(v18) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v18, v24) )
        __debugbreak();
    }
    if ( !g_assetNameFieldValid[v4] )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v21) = 113;
        LODWORD(v15) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v4], from.physicsLibrary) )
        __debugbreak();
    }
    if ( !from.physicsLibrary )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v21) = 113;
        LODWORD(v15) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v4]) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8186, ASSERT_TYPE_ASSERT, "( ( DB_IsPermanentAssetNonLocking( type, DB_GetXAssetHeaderName( type, from ) ) ) )", "( DB_GetXAssetHeaderName( type, from ) ) = %s", from.physicsLibrary->name) )
      __debugbreak();
  }
  if ( (unsigned int)v4 >= 0x71 )
  {
    LODWORD(v21) = 113;
    LODWORD(v15) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
      __debugbreak();
    LODWORD(v25) = 113;
    LODWORD(v19) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v19, v25) )
      __debugbreak();
  }
  if ( !g_assetNameFieldValid[v4] )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v21) = 113;
      LODWORD(v15) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v4], from.physicsLibrary) )
      __debugbreak();
  }
  if ( !from.physicsLibrary )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v21) = 113;
      LODWORD(v15) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v4]) )
      __debugbreak();
  }
  name = from.physicsLibrary->name;
  v9 = 0x7FFFFFFFi64;
  v10 = toAssetNewName;
  if ( !from.physicsLibrary->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !toAssetNewName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v11 = name - toAssetNewName;
  do
  {
    v12 = v10[v11];
    v13 = v9;
    v14 = *v10++;
    --v9;
    if ( !v13 )
      break;
    if ( v12 != v14 )
      goto LABEL_78;
  }
  while ( v12 );
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8189, ASSERT_TYPE_ASSERT, "(I_strcmp( DB_GetXAssetHeaderName( type, from ), toAssetNewName ) != 0)", (const char *)&queryFormat, "I_strcmp( DB_GetXAssetHeaderName( type, from ), toAssetNewName ) != 0") )
    __debugbreak();
LABEL_78:
  if ( s_copyXAssetHandler[v4] )
  {
    if ( !s_moveXAssetHandler[v4] )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v21) = 113;
        LODWORD(v15) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8195, ASSERT_TYPE_ASSERT, "(s_moveXAssetHandler[type])", "%s\n\tNeed to implement all three: swap/copy/move handlers: %s", "s_moveXAssetHandler[type]", g_assetNames[v4]) )
        __debugbreak();
    }
    if ( !s_swapXAssetHandler[v4] )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v21) = 113;
        LODWORD(v15) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8197, ASSERT_TYPE_ASSERT, "(s_swapXAssetHandler[type])", "%s\n\tNeed to implement all three: swap/copy/move handlers: %s", "s_swapXAssetHandler[type]", g_assetNames[v4]) )
        __debugbreak();
    }
    ((void (__fastcall *)(_QWORD, _QWORD, _QWORD))s_copyXAssetHandler[v4])((XAssetHeader)from.physicsLibrary, (XAssetHeader)to.physicsLibrary, toAssetNewName);
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v21) = 113;
      LODWORD(v15) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
        __debugbreak();
      LODWORD(v26) = 113;
      LODWORD(v20) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v20, v26) )
        __debugbreak();
    }
    if ( !g_assetNameFieldValid[v4] )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v21) = 113;
        LODWORD(v15) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v4], to.physicsLibrary) )
        __debugbreak();
    }
    if ( !to.physicsLibrary )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v21) = 113;
        LODWORD(v15) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v21) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v4]) )
        __debugbreak();
    }
    if ( to.physicsLibrary->name != toAssetNewName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8202, ASSERT_TYPE_ASSERT, "(DB_GetXAssetHeaderName( type, to ) == toAssetNewName)", (const char *)&queryFormat, "DB_GetXAssetHeaderName( type, to ) == toAssetNewName") )
      __debugbreak();
  }
  else
  {
    DB_CopyXAssetDataInternal(from, to, (XAssetType)v4);
    DB_SetXAssetHeaderName(v4, to, toAssetNewName);
  }
}

/*
==============
DB_CopyXAssetDataInternal
==============
*/
void DB_CopyXAssetDataInternal(const XAssetHeader from, XAssetHeader to, XAssetType type)
{
  __int64 v3; 
  size_t v6; 
  __int64 v7; 
  __int64 v8; 

  v3 = type;
  if ( (unsigned int)type >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ASSET_TYPE_COUNT )", "assetType doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", type, 113) )
    __debugbreak();
  v6 = g_assetSizes[v3];
  if ( (unsigned int)v6 > s_largestAssetPoolItem )
  {
    if ( (unsigned int)v3 >= 0x71 )
    {
      LODWORD(v8) = 113;
      LODWORD(v7) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8093, ASSERT_TYPE_ASSERT, "(size <= s_largestAssetPoolItem)", "%s\n\tAsset of type '%s' is larger than XAssetSize. It should be added to that union.", "size <= s_largestAssetPoolItem", g_assetNames[v3]) )
      __debugbreak();
  }
  memcpy_0(to.data, from.physicsLibrary, v6);
}

/*
==============
DB_CopyXAssetDefault
==============
*/
void DB_CopyXAssetDefault(XAssetHeader from, XAssetHeader to, XAssetType type, const char *toAssetNewName)
{
  DB_CopyXAssetDataInternal(from, to, type);
  DB_SetXAssetHeaderName(type, to, toAssetNewName);
}

/*
==============
DB_CreateXAsset
==============
*/
void DB_CreateXAsset(XAssetHeader header, XAssetType type, DB_CreateType createType)
{
  void (__fastcall *v3)(XAssetHeader, DB_CreateType); 

  v3 = s_createXAssetHandler[type];
  if ( v3 )
    v3(header, createType);
}

/*
==============
DB_FreeXAssetHeader
==============
*/
void DB_FreeXAssetHeader(XAssetType type, XAssetHeader header)
{
  __int64 v2; 
  __int64 v4; 
  __int64 v6; 
  __int64 v7; 
  int v8; 
  __int64 v9; 

  v2 = type;
  if ( (unsigned int)type >= ASSET_TYPE_COUNT )
  {
    v8 = 113;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8263, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_freeXAssetHeaderHandler ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_freeXAssetHeaderHandler )\n\t%i not in [0, %i)", type, v8) )
      __debugbreak();
    LODWORD(v9) = 113;
    LODWORD(v6) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ASSET_TYPE_COUNT )", "assetType doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v6, v9) )
      __debugbreak();
  }
  IWMem_Free(s_iwMemAssetPools[v2], header.physicsLibrary, g_assetSizes[v2]);
  if ( db_assetCount[v2] <= 0 )
  {
    if ( (unsigned int)v2 >= 0x71 )
    {
      LODWORD(v7) = 113;
      LODWORD(v4) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v4, v7) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8270, ASSERT_TYPE_ASSERT, "( ( db_assetCount[type] > 0 ) )", "( DB_GetXAssetTypeName( type ) ) = %s", g_assetNames[v2]) )
      __debugbreak();
  }
  --db_assetCount[v2];
  s_freeXAssetHeaderHandler[v2]((const XAssetType)v2, header);
}

/*
==============
DB_FreeXAssetPoolMem
==============
*/
void DB_FreeXAssetPoolMem(void)
{
  StreamerMemLoan result; 

  PMem_Free(&result, "$database", PMEM_STACK_GAME);
  StreamerMemLoan::~StreamerMemLoan(&result);
}

/*
==============
DB_FxWorldTransientZoneUpdateValidity
==============
*/
void DB_FxWorldTransientZoneUpdateValidity(const XAssetHeader header)
{
  unsigned int Item; 

  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3092, ASSERT_TYPE_ASSERT, "(header.fxWorldTransientZone)", (const char *)&queryFormat, "header.fxWorldTransientZone") )
    __debugbreak();
  Item = DB_AssetPool_GetItemIndex<FxWorldTransientZone>(ASSET_TYPE_FXWORLD_TRANSIENT_ZONE, header.fxWorldTransientZone);
  DB_FxWorldTransientZone_ResetValid(Item);
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3056, ASSERT_TYPE_ASSERT, "(header.fxWorldTransientZone)", (const char *)&queryFormat, "header.fxWorldTransientZone") )
    __debugbreak();
  if ( DB_FxWorldTransientZone_IsValidTransientZone(header.fxWorldTransientZone) && DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_FXWORLD_TRANSIENT_ZONE, header) )
    DB_FxWorldTransientZone_SetValid(Item);
}

/*
==============
DB_GetCamoAtIndex
==============
*/
Camo *DB_GetCamoAtIndex(unsigned int camoIndex)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = camoIndex;
  if ( !s_assetPoolMem[95] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[95].m_elementSize != 184 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x1FE )
  {
    v4 = 510;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (Camo *)((char *)s_assetPoolMem[95] + 184 * v1);
}

/*
==============
DB_GetCamoIndex
==============
*/
unsigned int DB_GetCamoIndex(const Camo *camo)
{
  return DB_AssetPool_GetItemIndex<Camo>(ASSET_TYPE_CAMO, camo);
}

/*
==============
DB_GetDecalVolumeMaskAtIndex
==============
*/
GfxDecalVolumeMask *DB_GetDecalVolumeMaskAtIndex(unsigned int index)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = index;
  if ( !s_assetPoolMem[108] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[108].m_elementSize != 16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x180 )
  {
    v4 = 384;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (GfxDecalVolumeMask *)((char *)s_assetPoolMem[108] + 16 * v1);
}

/*
==============
DB_GetDecalVolumeMaskIndex
==============
*/
__int64 DB_GetDecalVolumeMaskIndex(const GfxDecalVolumeMask *mask)
{
  const char *v2; 
  int v3; 
  const char *v4; 
  const char *v5; 

  if ( !s_assetPoolMem[108] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[108].m_elementSize != 16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !mask && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  if ( mask < s_assetPools[108].m_entries || (char *)mask >= (char *)s_assetPools[108].m_entries + s_assetPools[108].m_elementSize * s_assetPools[108].m_poolSize )
  {
    v2 = "s_assetPools[assetType].IsInPool( ptr )";
    v3 = 267;
    v4 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !((unsigned __int64)((char *)mask - (char *)s_assetPools[108].m_entries) % s_assetPools[108].m_elementSize) )
      return (unsigned int)((unsigned __int64)((char *)mask - (char *)s_assetPoolMem[108]) >> 4);
    v2 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v3 = 127;
    v4 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v5, v3, ASSERT_TYPE_ASSERT, v4, (const char *)&queryFormat, v2) )
    __debugbreak();
  return (unsigned int)((unsigned __int64)((char *)mask - (char *)s_assetPoolMem[108]) >> 4);
}

/*
==============
DB_GetDecalVolumeMaskPool
==============
*/
void *DB_GetDecalVolumeMaskPool()
{
  return s_assetPools[108].m_entries;
}

/*
==============
DB_GetDecalVolumeMaterialAtIndex
==============
*/
GfxDecalVolumeMaterial *DB_GetDecalVolumeMaterialAtIndex(unsigned int index)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = index;
  if ( !s_assetPoolMem[107] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[107].m_elementSize != 104 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x600 )
  {
    v4 = 1536;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (GfxDecalVolumeMaterial *)((char *)s_assetPoolMem[107] + 104 * v1);
}

/*
==============
DB_GetDecalVolumeMaterialIndex
==============
*/
__int64 DB_GetDecalVolumeMaterialIndex(const GfxDecalVolumeMaterial *material)
{
  const char *v2; 
  int v3; 
  const char *v4; 
  const char *v5; 

  if ( !s_assetPoolMem[107] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[107].m_elementSize != 104 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  if ( material < s_assetPools[107].m_entries || (char *)material >= (char *)s_assetPools[107].m_entries + s_assetPools[107].m_elementSize * s_assetPools[107].m_poolSize )
  {
    v2 = "s_assetPools[assetType].IsInPool( ptr )";
    v3 = 267;
    v4 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !((unsigned __int64)((char *)material - (char *)s_assetPools[107].m_entries) % s_assetPools[107].m_elementSize) )
      return (unsigned int)(((char *)material - (char *)s_assetPoolMem[107]) / 0x68ui64);
    v2 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v3 = 127;
    v4 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v5, v3, ASSERT_TYPE_ASSERT, v4, (const char *)&queryFormat, v2) )
    __debugbreak();
  return (unsigned int)(((char *)material - (char *)s_assetPoolMem[107]) / 0x68ui64);
}

/*
==============
DB_GetDecalVolumeMaterialPool
==============
*/
void *DB_GetDecalVolumeMaterialPool()
{
  return s_assetPools[107].m_entries;
}

/*
==============
DB_GetFxWorldTransientZoneAtIndex
==============
*/
FxWorldTransientZone *DB_GetFxWorldTransientZoneAtIndex(unsigned int index)
{
  __int64 v1; 
  char *v2; 
  __int64 v4; 

  v1 = index;
  if ( !s_assetPoolMem[110] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[110].m_elementSize != 160 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x702 )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v4, 1794) )
      __debugbreak();
  }
  v2 = (char *)s_assetPoolMem[110] + 160 * v1;
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3137, ASSERT_TYPE_ASSERT, "(zone)", (const char *)&queryFormat, "zone") )
    __debugbreak();
  return (FxWorldTransientZone *)v2;
}

/*
==============
DB_GetGfxImageAtIndex
==============
*/
GfxImage *DB_GetGfxImageAtIndex(unsigned int index)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = index;
  if ( !s_assetPoolMem[15] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[15].m_elementSize != 232 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x14000 )
  {
    v4 = 81920;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (GfxImage *)((char *)s_assetPoolMem[15] + 232 * v1);
}

/*
==============
DB_GetGfxImageIndex
==============
*/
unsigned int DB_GetGfxImageIndex(const GfxImage *image)
{
  return DB_AssetPool_GetItemIndex<GfxImage>(ASSET_TYPE_IMAGE, image);
}

/*
==============
DB_GetGfxWorldTransientZoneAtIndex
==============
*/
GfxWorldTransientZone *DB_GetGfxWorldTransientZoneAtIndex(unsigned int index)
{
  __int64 v1; 
  char *v2; 
  __int64 v4; 

  v1 = index;
  if ( !s_assetPoolMem[28] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[28].m_elementSize != 256 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x702 )
  {
    LODWORD(v4) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v4, 1794) )
      __debugbreak();
  }
  v2 = (char *)s_assetPoolMem[28] + 256 * v1;
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3030, ASSERT_TYPE_ASSERT, "(zone)", (const char *)&queryFormat, "zone") )
    __debugbreak();
  return (GfxWorldTransientZone *)v2;
}

/*
==============
DB_GetMaterialAtIndex
==============
*/
Material *DB_GetMaterialAtIndex(unsigned int index)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = index;
  if ( !s_assetPoolMem[11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[11].m_elementSize != 120 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0xB400 )
  {
    v4 = 46080;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (Material *)((char *)s_assetPoolMem[11] + 120 * v1);
}

/*
==============
DB_GetMaterialIndex
==============
*/
__int64 DB_GetMaterialIndex(const Material *material)
{
  const char *v2; 
  int v3; 
  const char *v4; 
  const char *v5; 

  if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1691, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
    __debugbreak();
  if ( !s_assetPoolMem[11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[11].m_elementSize != 120 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  if ( material < s_assetPools[11].m_entries || (char *)material >= (char *)s_assetPools[11].m_entries + s_assetPools[11].m_elementSize * s_assetPools[11].m_poolSize )
  {
    v2 = "s_assetPools[assetType].IsInPool( ptr )";
    v3 = 267;
    v4 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !((unsigned __int64)((char *)material - (char *)s_assetPools[11].m_entries) % s_assetPools[11].m_elementSize) )
      return (unsigned int)(((char *)material - (char *)s_assetPoolMem[11]) / 0x78ui64);
    v2 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v3 = 127;
    v4 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v5, v3, ASSERT_TYPE_ASSERT, v4, (const char *)&queryFormat, v2) )
    __debugbreak();
  return (unsigned int)(((char *)material - (char *)s_assetPoolMem[11]) / 0x78ui64);
}

/*
==============
DB_GetPoolSize
==============
*/
__int64 DB_GetPoolSize(XAssetType type)
{
  __int64 v1; 
  int v4; 

  v1 = type;
  if ( (unsigned int)type >= ASSET_TYPE_COUNT )
  {
    v4 = 113;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8318, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_poolSize ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_poolSize )\n\t%i not in [0, %i)", type, v4) )
      __debugbreak();
  }
  return s_poolSize[v1];
}

/*
==============
DB_GetPoolUtilization
==============
*/
void DB_GetPoolUtilization(const XAssetType type, unsigned int *elementSize, unsigned int *countInUse, unsigned int *maxCountInUse)
{
  __int64 v4; 
  bool v8; 
  __int64 v9; 
  unsigned int m_elementSize; 
  unsigned int m_maxUsedCount; 
  __int64 v12; 
  __int64 v14; 
  __int64 v15; 
  int v16; 
  __int64 v17; 
  unsigned int v18; 
  unsigned int v19; 

  v4 = type;
  if ( (unsigned int)type >= ASSET_TYPE_COUNT )
  {
    v16 = 113;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8291, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_assetPools ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_assetPools )\n\t%i not in [0, %i)", type, v16) )
      __debugbreak();
    LODWORD(v17) = 113;
    LODWORD(v14) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ASSET_TYPE_COUNT )", "assetType doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v14, v17) )
      __debugbreak();
  }
  v8 = s_assetSingletons[v4] == NULL;
  *elementSize = g_assetSizes[v4];
  if ( v8 )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v15) = 113;
      LODWORD(v12) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8318, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_poolSize ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_poolSize )\n\t%i not in [0, %i)", v12, v15) )
        __debugbreak();
    }
    if ( s_poolSize[v4] )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v15) = 113;
        LODWORD(v12) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ASSET_TYPE_COUNT )", "assetType doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v12, v15) )
          __debugbreak();
      }
      v9 = v4;
      m_elementSize = s_assetPools[v4].m_elementSize;
      if ( g_assetSizes[v4] != m_elementSize )
      {
        if ( (unsigned int)v4 >= 0x71 )
        {
          LODWORD(v15) = 113;
          LODWORD(v12) = v4;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ASSET_TYPE_COUNT )", "assetType doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v12, v15) )
            __debugbreak();
        }
        v19 = m_elementSize;
        v18 = g_assetSizes[v4];
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8302, ASSERT_TYPE_ASSERT, "( DB_GetXAssetTypeSize( type ) ) == ( s_assetPools[type].GetElementSize() )", "%s == %s\n\t%u, %u", "DB_GetXAssetTypeSize( type )", "s_assetPools[type].GetElementSize()", v18, v19) )
          __debugbreak();
      }
      *countInUse = s_assetPools[v9].m_usedCount;
      m_maxUsedCount = s_assetPools[v9].m_maxUsedCount;
    }
    else
    {
      m_maxUsedCount = 0;
      *countInUse = 0;
    }
    *maxCountInUse = m_maxUsedCount;
  }
  else
  {
    *countInUse = 1;
    *maxCountInUse = 1;
  }
}

/*
==============
DB_GetShipPoolSize
==============
*/
__int64 DB_GetShipPoolSize(XAssetType type)
{
  __int64 v1; 
  __int64 result; 
  __int64 v3; 
  __int64 v4; 

  v1 = type;
  if ( (unsigned int)type >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8326, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_shipPoolSize ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_shipPoolSize )\n\t%i not in [0, %i)", type, 113) )
    __debugbreak();
  result = s_shipPoolSize[v1];
  if ( !(_DWORD)result )
  {
    if ( (unsigned int)v1 >= 0x71 )
    {
      LODWORD(v4) = 113;
      LODWORD(v3) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8318, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_poolSize ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_poolSize )\n\t%i not in [0, %i)", v3, v4) )
        __debugbreak();
    }
    return s_poolSize[v1];
  }
  return result;
}

/*
==============
DB_GetStreamKeyAtIndex
==============
*/
StreamKey *DB_GetStreamKeyAtIndex(unsigned int index)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = index;
  if ( !s_assetPoolMem[98] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[98].m_elementSize != 64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x9400 )
  {
    v4 = 37888;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (StreamKey *)((char *)s_assetPoolMem[98] + 64 * v1);
}

/*
==============
DB_GetStreamKeyIndex
==============
*/
__int64 DB_GetStreamKeyIndex(const StreamKey *key)
{
  const char *v2; 
  int v3; 
  const char *v4; 
  const char *v5; 

  if ( !s_assetPoolMem[98] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[98].m_elementSize != 64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  if ( key < s_assetPools[98].m_entries || (char *)key >= (char *)s_assetPools[98].m_entries + s_assetPools[98].m_elementSize * s_assetPools[98].m_poolSize )
  {
    v2 = "s_assetPools[assetType].IsInPool( ptr )";
    v3 = 267;
    v4 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !((unsigned __int64)((char *)key - (char *)s_assetPools[98].m_entries) % s_assetPools[98].m_elementSize) )
      return (unsigned int)((unsigned __int64)((char *)key - (char *)s_assetPoolMem[98]) >> 6);
    v2 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v3 = 127;
    v4 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v5, v3, ASSERT_TYPE_ASSERT, v4, (const char *)&queryFormat, v2) )
    __debugbreak();
  return (unsigned int)((unsigned __int64)((char *)key - (char *)s_assetPoolMem[98]) >> 6);
}

/*
==============
DB_GetStreamingInfoIndex
==============
*/
unsigned int DB_GetStreamingInfoIndex(const StreamingInfo *streamingInfo)
{
  return DB_AssetPool_GetItemIndex<StreamingInfo>(ASSET_TYPE_STREAMING_INFO, streamingInfo);
}

/*
==============
DB_GetStreamingPoolBase
==============
*/
const StreamingInfo *DB_GetStreamingPoolBase()
{
  void *v0; 

  v0 = s_assetPoolMem[63];
  if ( !s_assetPoolMem[63] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4183, ASSERT_TYPE_ASSERT, "(pool)", (const char *)&queryFormat, "pool") )
    __debugbreak();
  return (const StreamingInfo *)v0;
}

/*
==============
DB_GetWeaponAttachmentAtIndex
==============
*/
WeaponAttachment *DB_GetWeaponAttachmentAtIndex(unsigned __int16 attachmentIndex)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = attachmentIndex;
  if ( !s_assetPoolMem[38] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[38].m_elementSize != 976 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0xC28 )
  {
    v4 = 3112;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (WeaponAttachment *)((char *)s_assetPoolMem[38] + 976 * v1);
}

/*
==============
DB_GetWeaponAttachmentIndex
==============
*/
unsigned __int16 DB_GetWeaponAttachmentIndex(const WeaponAttachment *const attachment)
{
  unsigned int Item; 

  Item = DB_AssetPool_GetItemIndex<WeaponAttachment>(ASSET_TYPE_ATTACHMENT, attachment);
  return truncate_cast<unsigned short,unsigned int>(Item);
}

/*
==============
DB_GetXCompositeModelAtIndex
==============
*/
XCompositeModelDef *DB_GetXCompositeModelAtIndex(unsigned int compositeModelIndex)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = compositeModelIndex;
  if ( !s_assetPoolMem[96] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[96].m_elementSize != 24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x600 )
  {
    v4 = 1536;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (XCompositeModelDef *)((char *)s_assetPoolMem[96] + 24 * v1);
}

/*
==============
DB_GetXCompositeModelIndex
==============
*/
__int64 DB_GetXCompositeModelIndex(const XCompositeModelDef *compositeModel)
{
  const char *v2; 
  int v3; 
  const char *v4; 
  const char *v5; 

  if ( !s_assetPoolMem[96] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[96].m_elementSize != 24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !compositeModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  if ( compositeModel < s_assetPools[96].m_entries || (char *)compositeModel >= (char *)s_assetPools[96].m_entries + s_assetPools[96].m_elementSize * s_assetPools[96].m_poolSize )
  {
    v2 = "s_assetPools[assetType].IsInPool( ptr )";
    v3 = 267;
    v4 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !((unsigned __int64)((char *)compositeModel - (char *)s_assetPools[96].m_entries) % s_assetPools[96].m_elementSize) )
      return (unsigned int)(((char *)compositeModel - (char *)s_assetPoolMem[96]) / 0x18ui64);
    v2 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v3 = 127;
    v4 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v5, v3, ASSERT_TYPE_ASSERT, v4, (const char *)&queryFormat, v2) )
    __debugbreak();
  return (unsigned int)(((char *)compositeModel - (char *)s_assetPoolMem[96]) / 0x18ui64);
}

/*
==============
DB_GetXModelAtIndex
==============
*/
XModel *DB_GetXModelAtIndex(unsigned int modelIndex)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = modelIndex;
  if ( !s_assetPoolMem[9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[9].m_elementSize != 680 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0x6000 )
  {
    v4 = 24576;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (XModel *)((char *)s_assetPoolMem[9] + 680 * v1);
}

/*
==============
DB_GetXModelIndex
==============
*/
__int64 DB_GetXModelIndex(const XModel *model)
{
  const char *v2; 
  int v3; 
  const char *v4; 
  const char *v5; 

  if ( !s_assetPoolMem[9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[9].m_elementSize != 680 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  if ( model < s_assetPools[9].m_entries || (char *)model >= (char *)s_assetPools[9].m_entries + s_assetPools[9].m_elementSize * s_assetPools[9].m_poolSize )
  {
    v2 = "s_assetPools[assetType].IsInPool( ptr )";
    v3 = 267;
    v4 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !((unsigned __int64)((char *)model - (char *)s_assetPools[9].m_entries) % s_assetPools[9].m_elementSize) )
      return (unsigned int)(((char *)model - (char *)s_assetPoolMem[9]) / 0x2A8ui64);
    v2 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v3 = 127;
    v4 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v5, v3, ASSERT_TYPE_ASSERT, v4, (const char *)&queryFormat, v2) )
    __debugbreak();
  return (unsigned int)(((char *)model - (char *)s_assetPoolMem[9]) / 0x2A8ui64);
}

/*
==============
DB_GetXModelSurfsAtIndex
==============
*/
XModelSurfs *DB_GetXModelSurfsAtIndex(unsigned int modelSurfsIndex)
{
  __int64 v1; 
  __int64 v3; 
  int v4; 

  v1 = modelSurfsIndex;
  if ( !s_assetPoolMem[8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[8].m_elementSize != 96 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( (unsigned int)v1 >= 0xB000 )
  {
    v4 = 45056;
    LODWORD(v3) = v1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 253, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( DB_GetPoolSize( assetType ) )", "index doesn't index DB_GetPoolSize( assetType )\n\t%i not in [0, %i)", v3, v4) )
      __debugbreak();
  }
  return (XModelSurfs *)((char *)s_assetPoolMem[8] + 96 * v1);
}

/*
==============
DB_GetXModelSurfsIndex
==============
*/
__int64 DB_GetXModelSurfsIndex(const XModelSurfs *modelSurfs)
{
  const char *v2; 
  int v3; 
  const char *v4; 
  const char *v5; 

  if ( !s_assetPoolMem[8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 265, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
    __debugbreak();
  if ( s_assetPools[8].m_elementSize != 96 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 266, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
    __debugbreak();
  if ( !modelSurfs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h", 122, ASSERT_TYPE_ASSERT, "(ptr)", (const char *)&queryFormat, "ptr") )
    __debugbreak();
  if ( modelSurfs < s_assetPools[8].m_entries || (char *)modelSurfs >= (char *)s_assetPools[8].m_entries + s_assetPools[8].m_elementSize * s_assetPools[8].m_poolSize )
  {
    v2 = "s_assetPools[assetType].IsInPool( ptr )";
    v3 = 267;
    v4 = "(s_assetPools[assetType].IsInPool( ptr ))";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp";
  }
  else
  {
    if ( !((unsigned __int64)((char *)modelSurfs - (char *)s_assetPools[8].m_entries) % s_assetPools[8].m_elementSize) )
      return (unsigned int)(((char *)modelSurfs - (char *)s_assetPoolMem[8]) / 0x60ui64);
    v2 = "( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0";
    v3 = 127;
    v4 = "(( ( reinterpret_cast<uintptr_t>( ptr ) - reinterpret_cast<uintptr_t>( m_entries ) ) % m_elementSize ) == 0)";
    v5 = "c:\\workspace\\iw8\\code_source\\src\\database\\db_assetpool.h";
  }
  if ( CoreAssert_Handler(v5, v3, ASSERT_TYPE_ASSERT, v4, (const char *)&queryFormat, v2) )
    __debugbreak();
  return (unsigned int)(((char *)modelSurfs - (char *)s_assetPoolMem[8]) / 0x60ui64);
}

/*
==============
DB_GfxWorldTransientZoneUpdateValidity
==============
*/
void DB_GfxWorldTransientZoneUpdateValidity(const XAssetHeader header)
{
  unsigned int Item; 

  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2985, ASSERT_TYPE_ASSERT, "(header.gfxWorldTransientZone)", (const char *)&queryFormat, "header.gfxWorldTransientZone") )
    __debugbreak();
  Item = DB_AssetPool_GetItemIndex<GfxWorldTransientZone>(ASSET_TYPE_GFXWORLD_TRANSIENT_ZONE, header.gfxWorldTransientZone);
  DB_GfxWorldTransientZone_ResetValid(Item);
  if ( !header.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2933, ASSERT_TYPE_ASSERT, "(header.gfxWorldTransientZone)", (const char *)&queryFormat, "header.gfxWorldTransientZone") )
    __debugbreak();
  if ( DB_GfxWorldTransientZone_IsValidTransientZone(header.gfxWorldTransientZone) && DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_GFXWORLD_TRANSIENT_ZONE, header) )
    DB_GfxWorldTransientZone_SetValid(Item);
}

/*
==============
DB_InitPoolHeader
==============
*/
void DB_InitPoolHeader(const XAssetType type)
{
  __int64 v1; 
  __int64 v2; 
  __int64 v3; 
  unsigned int v4; 
  unsigned __int64 v5; 
  const void *v6; 
  __int64 v7; 
  __int64 v8; 

  v1 = type;
  v2 = type;
  v3 = type;
  if ( s_assetPoolMem[v3] )
  {
    if ( (unsigned int)type >= ASSET_TYPE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8318, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ( sizeof( *array_counter( s_poolSize ) ) + 0 ) )", "type doesn't index ARRAY_COUNT( s_poolSize )\n\t%i not in [0, %i)", type, 113) )
      __debugbreak();
    v4 = s_poolSize[v1];
    if ( (unsigned int)v1 >= 0x71 )
    {
      LODWORD(v8) = 113;
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 114, ASSERT_TYPE_ASSERT, "(unsigned)( assetType ) < (unsigned)( ASSET_TYPE_COUNT )", "assetType doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    v5 = g_assetSizes[v1];
    if ( s_assetSingletons[v3] )
    {
      if ( v4 != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 7952, ASSERT_TYPE_ASSERT, "( poolSize ) == ( 1 )", "%s == %s\n\t%u, %u", "poolSize", "1", v4, 1) )
        __debugbreak();
    }
    else
    {
      if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 7956, ASSERT_TYPE_ASSERT, "(poolSize)", (const char *)&queryFormat, "poolSize") )
        __debugbreak();
      DB_AssetPool::Init(&s_assetPools[v2], s_assetPoolMem[v3], v5, v4, 0);
    }
    v6 = s_assetPoolMem[v3];
    if ( (unsigned int)v1 >= 0x71 )
    {
      LODWORD(v8) = 113;
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    IWMem_Allocator_CreateFixed(&s_iwMemAssetPools[v3], g_assetNames[v3], Count|0x4, v6, v4 * (unsigned int)v5);
    IWMem_Allocator_SetPoolItemSize(s_iwMemAssetPools[v3], v5);
  }
}

/*
==============
DB_InitXAssetPools
==============
*/
void DB_InitXAssetPools(void)
{
  unsigned int v0; 
  XAssetType i; 
  const Material *v2; 
  const Material *v3; 
  __int64 v4; 
  __int64 v5; 

  DB_AllocateXAssetPoolMem();
  v0 = 0;
  for ( i = ASSET_TYPE_PHYSICSLIBRARY; (unsigned int)i < ASSET_TYPE_COUNT; ++i )
    DB_InitPoolHeader(i);
  if ( s_perDObjMaterialOverridesInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 7974, ASSERT_TYPE_ASSERT, "(s_perDObjMaterialOverridesInitialized == false)", (const char *)&queryFormat, "s_perDObjMaterialOverridesInitialized == false") )
    __debugbreak();
  DB_LockHashWrite();
  do
  {
    DB_AssetUsage_AddExternalHeader(ASSET_TYPE_MATERIAL);
    v2 = (const Material *)off_147902838(11i64);
    v3 = v2;
    if ( v2 )
    {
      ++db_assetCount[11];
      IWMem_Alloc(s_iwMemAssetPools[11], v2, g_assetSizes[11]);
    }
    if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 7990, ASSERT_TYPE_ASSERT, "(header.material)", (const char *)&queryFormat, "header.material") )
      __debugbreak();
    if ( DB_GetMaterialIndex(v3) != v0 )
    {
      LODWORD(v5) = v0;
      LODWORD(v4) = DB_GetMaterialIndex(v3);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 7991, ASSERT_TYPE_ASSERT, "( DB_GetMaterialIndex( header.material ) ) == ( i )", "%s == %s\n\t%i, %i", "DB_GetMaterialIndex( header.material )", "i", v4, v5) )
        __debugbreak();
    }
    ++v0;
  }
  while ( v0 < 0x800 );
  DB_UnlockHashWrite();
  s_perDObjMaterialOverridesInitialized = 1;
}

/*
==============
DB_IsImageInPool
==============
*/
bool DB_IsImageInPool(const GfxImage *image)
{
  if ( !image && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2350, ASSERT_TYPE_ASSERT, "(image)", (const char *)&queryFormat, "image") )
    __debugbreak();
  return DB_AssetPool::IsInPool(&s_assetPools[15], image);
}

/*
==============
DB_IsXModelInPool
==============
*/
bool DB_IsXModelInPool(const XModel *model)
{
  if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1119, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  return DB_AssetPool::IsInPool(&s_assetPools[9], model);
}

/*
==============
DB_IsXModelSurfsInPool
==============
*/
bool DB_IsXModelSurfsInPool(const XModelSurfs *modelSurfs)
{
  if ( !modelSurfs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2358, ASSERT_TYPE_ASSERT, "(modelSurfs)", (const char *)&queryFormat, "modelSurfs") )
    __debugbreak();
  return DB_AssetPool::IsInPool(&s_assetPools[8], modelSurfs);
}

/*
==============
DB_MoveXAsset
==============
*/
void DB_MoveXAsset(XAssetHeader from, XAssetHeader to, XAssetType type, DB_ReleaseType toReleaseType)
{
  __int64 v4; 
  const char *name; 
  const char *v9; 
  __int64 v10; 
  signed __int64 v11; 
  char v12; 
  __int64 v13; 
  char v14; 
  void (__fastcall *v15)(XAssetHeader, DB_ReleaseType); 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  v4 = type;
  if ( !from.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8148, ASSERT_TYPE_ASSERT, "(from.data)", (const char *)&queryFormat, "from.data") )
    __debugbreak();
  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8149, ASSERT_TYPE_ASSERT, "(to.data)", (const char *)&queryFormat, "to.data") )
    __debugbreak();
  if ( from.physicsLibrary == to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8150, ASSERT_TYPE_ASSERT, "(from.data != to.data)", (const char *)&queryFormat, "from.data != to.data") )
    __debugbreak();
  if ( (unsigned int)v4 >= 0x71 )
  {
    LODWORD(v16) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8151, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, 113) )
      __debugbreak();
  }
  if ( !DB_IsLiveHeadAssetNonLocking((XAssetType)v4, to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8154, ASSERT_TYPE_ASSERT, "(DB_IsLiveHeadAssetNonLocking( type, to ))", (const char *)&queryFormat, "DB_IsLiveHeadAssetNonLocking( type, to )") )
    __debugbreak();
  if ( (unsigned int)v4 >= 0x71 )
  {
    LODWORD(v19) = 113;
    LODWORD(v16) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
      __debugbreak();
    LODWORD(v20) = 113;
    LODWORD(v17) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v17, v20) )
      __debugbreak();
  }
  if ( !g_assetNameFieldValid[v4] )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v19) = 113;
      LODWORD(v16) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v4], to.physicsLibrary) )
      __debugbreak();
  }
  if ( !to.physicsLibrary )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v19) = 113;
      LODWORD(v16) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v4]) )
      __debugbreak();
  }
  name = to.physicsLibrary->name;
  if ( (unsigned int)v4 >= 0x71 )
  {
    LODWORD(v19) = 113;
    LODWORD(v16) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
      __debugbreak();
    LODWORD(v21) = 113;
    LODWORD(v18) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v18, v21) )
      __debugbreak();
  }
  if ( !g_assetNameFieldValid[v4] )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v19) = 113;
      LODWORD(v16) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v4], from.physicsLibrary) )
      __debugbreak();
  }
  if ( !from.physicsLibrary )
  {
    if ( (unsigned int)v4 >= 0x71 )
    {
      LODWORD(v19) = 113;
      LODWORD(v16) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v4]) )
      __debugbreak();
  }
  v9 = from.physicsLibrary->name;
  v10 = 0x7FFFFFFFi64;
  if ( !from.physicsLibrary->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v11 = v9 - name;
  do
  {
    v12 = name[v11];
    v13 = v10;
    v14 = *name++;
    --v10;
    if ( !v13 )
      break;
    if ( v12 != v14 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8157, ASSERT_TYPE_ASSERT, "(I_strcmp( DB_GetXAssetHeaderName( type, from ), DB_GetXAssetHeaderName( type, to ) ) == 0)", (const char *)&queryFormat, "I_strcmp( DB_GetXAssetHeaderName( type, from ), DB_GetXAssetHeaderName( type, to ) ) == 0") )
        __debugbreak();
      break;
    }
  }
  while ( v12 );
  if ( s_moveXAssetHandler[v4] )
  {
    if ( !s_copyXAssetHandler[v4] )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v19) = 113;
        LODWORD(v16) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8164, ASSERT_TYPE_ASSERT, "(s_copyXAssetHandler[type])", "%s\n\tNeed to implement all three: swap/copy/move handlers: %s", "s_copyXAssetHandler[type]", g_assetNames[v4]) )
        __debugbreak();
    }
    if ( !s_swapXAssetHandler[v4] )
    {
      if ( (unsigned int)v4 >= 0x71 )
      {
        LODWORD(v19) = 113;
        LODWORD(v16) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v16, v19) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8166, ASSERT_TYPE_ASSERT, "(s_swapXAssetHandler[type])", "%s\n\tNeed to implement all three: swap/copy/move handlers: %s", "s_swapXAssetHandler[type]", g_assetNames[v4]) )
        __debugbreak();
    }
    ((void (__fastcall *)(_QWORD, _QWORD, _QWORD))s_moveXAssetHandler[v4])((XAssetHeader)from.physicsLibrary, (XAssetHeader)to.physicsLibrary, toReleaseType);
  }
  else
  {
    v15 = s_releaseXAssetHandler[v4];
    if ( v15 )
      v15(to, toReleaseType);
    DB_CopyXAssetDataInternal(from, to, (XAssetType)v4);
  }
}

/*
==============
DB_MoveXAssetDefault
==============
*/
void DB_MoveXAssetDefault(XAssetHeader from, XAssetHeader to, XAssetType type, DB_ReleaseType toReleaseType)
{
  void (__fastcall *v7)(XAssetHeader, DB_ReleaseType); 

  v7 = s_releaseXAssetHandler[type];
  if ( v7 )
    v7(to, toReleaseType);
  DB_CopyXAssetDataInternal(from, to, type);
}

/*
==============
DB_PopSuppressMaterialSort
==============
*/
void DB_PopSuppressMaterialSort(void)
{
  if ( !s_suppressMaterialSort && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1509, ASSERT_TYPE_ASSERT, "(s_suppressMaterialSort)", (const char *)&queryFormat, "s_suppressMaterialSort") )
    __debugbreak();
  s_suppressMaterialSort = 0;
}

/*
==============
DB_PushSuppressMaterialSort
==============
*/
void DB_PushSuppressMaterialSort(void)
{
  if ( s_suppressMaterialSort && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 1501, ASSERT_TYPE_ASSERT, "(!s_suppressMaterialSort)", (const char *)&queryFormat, "!s_suppressMaterialSort") )
    __debugbreak();
  s_suppressMaterialSort = 1;
}

/*
==============
DB_ReleaseXAsset
==============
*/
void DB_ReleaseXAsset(XAssetHeader header, XAssetType type, DB_ReleaseType releaseType)
{
  void (__fastcall *v3)(XAssetHeader, DB_ReleaseType); 

  v3 = s_releaseXAssetHandler[type];
  if ( v3 )
    v3(header, releaseType);
}

/*
==============
DB_ReleaseXModelSurfsXSurfaces
==============
*/
void DB_ReleaseXModelSurfsXSurfaces(XModelSurfs *modelSurfs)
{
  unsigned __int16 i; 

  for ( i = 0; i < modelSurfs->numsurfs; ++i )
    XSurfaceReleaseResources(&modelSurfs->surfs[i]);
}

/*
==============
DB_ShutdownMaterialOverrides
==============
*/
void DB_ShutdownMaterialOverrides(void)
{
  unsigned int v0; 
  __int64 v1; 
  char *v2; 

  if ( s_perDObjMaterialOverridesInitialized )
  {
    v0 = 0;
    v1 = 0i64;
    do
    {
      DB_AssetUsage_RemoveExternalHeader(ASSET_TYPE_MATERIAL);
      if ( !s_assetPoolMem[11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 251, ASSERT_TYPE_ASSERT, "(s_assetPoolMem[assetType])", (const char *)&queryFormat, "s_assetPoolMem[assetType]") )
        __debugbreak();
      if ( s_assetPools[11].m_elementSize != 120 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 252, ASSERT_TYPE_ASSERT, "(sizeof( T ) == s_assetPools[assetType].GetElementSize())", (const char *)&queryFormat, "sizeof( T ) == s_assetPools[assetType].GetElementSize()") )
        __debugbreak();
      v2 = (char *)s_assetPoolMem[11] + v1;
      IWMem_Free(s_iwMemAssetPools[11], (char *)s_assetPoolMem[11] + v1, g_assetSizes[11]);
      if ( db_assetCount[11] <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8270, ASSERT_TYPE_ASSERT, "( ( db_assetCount[type] > 0 ) )", "( DB_GetXAssetTypeName( type ) ) = %s", g_assetNames[11]) )
        __debugbreak();
      --db_assetCount[11];
      off_147902BC8(11i64, v2);
      ++v0;
      v1 += 120i64;
    }
    while ( v0 < 0x800 );
    s_perDObjMaterialOverridesInitialized = 0;
  }
}

/*
==============
DB_SwapXAsset
==============
*/
void DB_SwapXAsset(XAssetHeader from, XAssetHeader to, XAssetType type)
{
  __int64 v3; 
  const char *name; 
  const char *v7; 
  __int64 v8; 
  signed __int64 v9; 
  char v10; 
  __int64 v11; 
  char v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 

  v3 = type;
  if ( !from.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8116, ASSERT_TYPE_ASSERT, "(from.data)", (const char *)&queryFormat, "from.data") )
    __debugbreak();
  if ( !to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8117, ASSERT_TYPE_ASSERT, "(to.data)", (const char *)&queryFormat, "to.data") )
    __debugbreak();
  if ( from.physicsLibrary == to.physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8118, ASSERT_TYPE_ASSERT, "(from.data != to.data)", (const char *)&queryFormat, "from.data != to.data") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x71 )
  {
    LODWORD(v13) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8119, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, 113) )
      __debugbreak();
  }
  if ( !DB_IsLiveHeadAssetNonLocking((XAssetType)v3, to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8122, ASSERT_TYPE_ASSERT, "(DB_IsLiveHeadAssetNonLocking( type, to ))", (const char *)&queryFormat, "DB_IsLiveHeadAssetNonLocking( type, to )") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x71 )
  {
    LODWORD(v16) = 113;
    LODWORD(v13) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
      __debugbreak();
    LODWORD(v17) = 113;
    LODWORD(v14) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v14, v17) )
      __debugbreak();
  }
  if ( !g_assetNameFieldValid[v3] )
  {
    if ( (unsigned int)v3 >= 0x71 )
    {
      LODWORD(v16) = 113;
      LODWORD(v13) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v3], to.physicsLibrary) )
      __debugbreak();
  }
  if ( !to.physicsLibrary )
  {
    if ( (unsigned int)v3 >= 0x71 )
    {
      LODWORD(v16) = 113;
      LODWORD(v13) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v3]) )
      __debugbreak();
  }
  name = to.physicsLibrary->name;
  if ( (unsigned int)v3 >= 0x71 )
  {
    LODWORD(v16) = 113;
    LODWORD(v13) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 62, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
      __debugbreak();
    LODWORD(v18) = 113;
    LODWORD(v15) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 20, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v15, v18) )
      __debugbreak();
  }
  if ( !g_assetNameFieldValid[v3] )
  {
    if ( (unsigned int)v3 >= 0x71 )
    {
      LODWORD(v16) = 113;
      LODWORD(v13) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[v3], from.physicsLibrary) )
      __debugbreak();
  }
  if ( !from.physicsLibrary )
  {
    if ( (unsigned int)v3 >= 0x71 )
    {
      LODWORD(v16) = 113;
      LODWORD(v13) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[v3]) )
      __debugbreak();
  }
  v7 = from.physicsLibrary->name;
  v8 = 0x7FFFFFFFi64;
  if ( !from.physicsLibrary->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v9 = v7 - name;
  do
  {
    v10 = name[v9];
    v11 = v8;
    v12 = *name++;
    --v8;
    if ( !v11 )
      break;
    if ( v10 != v12 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8125, ASSERT_TYPE_ASSERT, "(I_strcmp( DB_GetXAssetHeaderName( type, from ), DB_GetXAssetHeaderName( type, to ) ) == 0)", (const char *)&queryFormat, "I_strcmp( DB_GetXAssetHeaderName( type, from ), DB_GetXAssetHeaderName( type, to ) ) == 0") )
        __debugbreak();
      break;
    }
  }
  while ( v10 );
  if ( s_swapXAssetHandler[v3] )
  {
    if ( !s_copyXAssetHandler[v3] )
    {
      if ( (unsigned int)v3 >= 0x71 )
      {
        LODWORD(v16) = 113;
        LODWORD(v13) = v3;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8134, ASSERT_TYPE_ASSERT, "(s_copyXAssetHandler[type])", "%s\n\tNeed to implement all three: swap/copy/move handlers: %s", "s_copyXAssetHandler[type]", g_assetNames[v3]) )
        __debugbreak();
    }
    if ( !s_moveXAssetHandler[v3] )
    {
      if ( (unsigned int)v3 >= 0x71 )
      {
        LODWORD(v16) = 113;
        LODWORD(v13) = v3;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v13, v16) )
          __debugbreak();
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8135, ASSERT_TYPE_ASSERT, "(s_moveXAssetHandler[type])", "%s\n\tNeed to implement all three: swap/copy/move handlers: %s", "s_moveXAssetHandler[type]", g_assetNames[v3]) )
        __debugbreak();
    }
    ((void (__fastcall *)(_QWORD, _QWORD))s_swapXAssetHandler[v3])((XAssetHeader)from.physicsLibrary, (XAssetHeader)to.physicsLibrary);
  }
  else
  {
    DB_SwapXAssetDefault(from, to, (XAssetType)v3);
  }
}

/*
==============
DB_SwapXAssetDefault
==============
*/
void DB_SwapXAssetDefault(XAssetHeader from, XAssetHeader to, XAssetType type)
{
  XAssetHeader toa; 

  if ( s_largestAssetPoolItem > 0x1000 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 8104, ASSERT_TYPE_ASSERT, "(sizeof( assetLargestSize ) >= s_largestAssetPoolItem)", (const char *)&queryFormat, "sizeof( assetLargestSize ) >= s_largestAssetPoolItem") )
    __debugbreak();
  DB_CopyXAssetDataInternal(to, (XAssetHeader)&toa, type);
  DB_CopyXAssetDataInternal(from, to, type);
  DB_CopyXAssetDataInternal((const XAssetHeader)&toa, from, type);
}

/*
==============
DB_UpdateBlackboxAssetCounts
==============
*/
void DB_UpdateBlackboxAssetCounts(void)
{
  int v0; 
  unsigned __int64 UserId; 
  int DemonwareActiveController; 
  const char **v3; 
  unsigned int *v4; 
  unsigned int v5; 
  const char *v6; 
  bool v7; 
  unsigned int MaxAssetEntriesUsed; 
  __int64 v9; 
  __int64 v10; 
  unsigned int maxCountInUse; 
  unsigned int countInUse; 
  unsigned int elementSize; 
  __int64 v14; 
  DLogContext context; 
  char buffer[4096]; 

  v14 = -2i64;
  if ( !DB_IsDebugZoneActive() )
  {
    v0 = 0;
    UserId = 0i64;
    if ( BB_GetDemonwareActiveController() >= 0 )
    {
      DemonwareActiveController = BB_GetDemonwareActiveController();
      UserId = DLog_GetUserId(DemonwareActiveController);
    }
    v3 = (const char **)g_assetNames;
    v4 = s_lastAssetPoolBlackboxHWM;
    do
    {
      DB_GetPoolUtilization((const XAssetType)v0, &elementSize, &countInUse, &maxCountInUse);
      v5 = maxCountInUse;
      if ( maxCountInUse > *v4 )
      {
        *v4 = maxCountInUse;
        if ( (unsigned int)v0 >= 0x71 )
        {
          LODWORD(v10) = 113;
          LODWORD(v9) = v0;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 38, ASSERT_TYPE_ASSERT, "(unsigned)( type ) < (unsigned)( ASSET_TYPE_COUNT )", "type doesn't index ASSET_TYPE_COUNT\n\t%i not in [0, %i)", v9, v10) )
            __debugbreak();
        }
        v6 = *v3;
        if ( DLog_IsActive() && DLog_CreateContext(&context, UserId, buffer, 4096) )
        {
          if ( DLog_IsActive() )
          {
            v7 = DLog_BeginEvent(&context, "highwater");
            context.autoEndEvent = 1;
            if ( v7 && DLog_String(&context, (const char *)&stru_143C9A1A4, v6, 0) && DLog_UInt32(&context, (const char *)&stru_143CE7590, v5) )
              DLog_RecordContext(&context);
          }
          else
          {
            context.error = DLOG_ERROR_NOT_ACTIVE;
          }
        }
      }
      ++v0;
      ++v4;
      ++v3;
    }
    while ( v0 < 113 );
    if ( dword_14A29D2D8 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
    {
      j__Init_thread_header(&dword_14A29D2D8);
      if ( dword_14A29D2D8 == -1 )
      {
        _hwm_id = BB_RegisterHighWaterMark("AssetPool_AssetEntries");
        j__Init_thread_footer(&dword_14A29D2D8);
      }
    }
    MaxAssetEntriesUsed = DB_AssetUsage_GetMaxAssetEntriesUsed();
    BB_SetHighWaterMark(_hwm_id, MaxAssetEntriesUsed);
  }
}

/*
==============
GfxWorldTransientZoneDeferredRelease_Enabled
==============
*/
bool GfxWorldTransientZoneDeferredRelease_Enabled()
{
  const dvar_t *v0; 

  if ( !s_GfxWorldTransientZoneDeferredReleaseGlob.activeList )
    return 0;
  v0 = DCONST_DVARBOOL_db_deferredGfxTransientWorldZoneRelease;
  if ( !DCONST_DVARBOOL_db_deferredGfxTransientWorldZoneRelease && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "db_deferredGfxTransientWorldZoneRelease") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.enabled;
}

/*
==============
GfxWorldTransientZoneDeferredRelease_PointerListSet
==============
*/
void GfxWorldTransientZoneDeferredRelease_PointerListSet(GfxWorldTransientZoneDeferredReleasePointerList *list)
{
  if ( list )
  {
    if ( s_GfxWorldTransientZoneDeferredReleaseGlob.activeList )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 2736, ASSERT_TYPE_ASSERT, "(!s_GfxWorldTransientZoneDeferredReleaseGlob.activeList)", (const char *)&queryFormat, "!s_GfxWorldTransientZoneDeferredReleaseGlob.activeList") )
        __debugbreak();
    }
    s_GfxWorldTransientZoneDeferredReleaseGlob.activeList = list;
    list->numPointers = 0;
    list->currentZoneIndex = 0xFFFF;
  }
  else
  {
    s_GfxWorldTransientZoneDeferredReleaseGlob.activeList = NULL;
  }
}

/*
==============
GfxWorldTransientZoneDeferredRelease_Release
==============
*/
void GfxWorldTransientZoneDeferredRelease_Release(GfxWorldTransientZoneDeferredReleasePointers *pointers)
{
  GfxWorldTransientZoneDeferredRelease_ReleaseInternal(pointers, 0);
}

/*
==============
GfxWorldTransientZoneDeferredRelease_ReleaseInternal
==============
*/
void GfxWorldTransientZoneDeferredRelease_ReleaseInternal(GfxWorldTransientZoneDeferredReleasePointers *pointers, bool forceRelease)
{
  const dvar_t *v2; 
  ID3D12Resource *indexBuffer; 
  GfxDecalVolumeTransientData *decalVolumes; 

  v2 = DCONST_DVARBOOL_db_deferredGfxTransientWorldZoneRelease;
  if ( !DCONST_DVARBOOL_db_deferredGfxTransientWorldZoneRelease && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "db_deferredGfxTransientWorldZoneRelease") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled || forceRelease )
  {
    if ( pointers->posBuffer.data )
      R_ShutdownGfxWrappedBuffer(&pointers->posBuffer);
    if ( pointers->auxBuffer.data )
      R_ShutdownGfxWrappedBuffer(&pointers->auxBuffer);
    indexBuffer = pointers->indexBuffer;
    if ( indexBuffer )
    {
      if ( pointers->indexBufferView.view > 1 )
      {
        R_ReleaseShaderBufferView(&pointers->indexBufferView);
        indexBuffer = pointers->indexBuffer;
      }
      R_FreeStaticIndexBuffer(indexBuffer);
    }
    R_GpuLightGrid_ShutdownBuffers(pointers->gpuLightGrid);
    R_DynamicLightsets_ShutdownTransientZoneBuffers(pointers->SMLGppZone);
    decalVolumes = pointers->decalVolumes;
    if ( decalVolumes )
      R_ShutdownGfxWrappedBuffer(&decalVolumes->decalVolumesBuffer);
    R_ReflectionProbe_ReleaseTransientData(pointers->reflectionProbes);
    memset_0(pointers, 0, sizeof(GfxWorldTransientZoneDeferredReleasePointers));
  }
}

/*
==============
GfxWorldTransientZoneDeferredRelease_SetZoneIndex
==============
*/
void GfxWorldTransientZoneDeferredRelease_SetZoneIndex(const unsigned int zoneIndex)
{
  if ( GfxWorldTransientZoneDeferredRelease_Enabled() )
    s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->currentZoneIndex = zoneIndex;
}

/*
==============
GfxWorldTransientZoneDeferredRelease_TakeOwnership
==============
*/
char GfxWorldTransientZoneDeferredRelease_TakeOwnership(GfxWorldTransientZoneDeferredReleasePointers *dstPointers, unsigned int zoneIndex)
{
  const dvar_t *v2; 
  GfxWorldTransientZoneDeferredReleasePointerList *activeList; 
  unsigned int numPointers; 
  unsigned int v7; 
  unsigned __int16 *i; 
  GfxWorldTransientZoneDeferredReleasePointers *v10; 
  __int64 v11; 

  v2 = DCONST_DVARBOOL_db_deferredGfxTransientWorldZoneRelease;
  if ( !DCONST_DVARBOOL_db_deferredGfxTransientWorldZoneRelease && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "db_deferredGfxTransientWorldZoneRelease") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( !v2->current.enabled )
    return 0;
  activeList = s_GfxWorldTransientZoneDeferredReleaseGlob.activeList;
  if ( !s_GfxWorldTransientZoneDeferredReleaseGlob.activeList )
    return 0;
  numPointers = s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->numPointers;
  v7 = 0;
  if ( !numPointers )
    return 0;
  for ( i = s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->zoneHandles; zoneIndex != *i; ++i )
  {
    if ( ++v7 >= numPointers )
      return 0;
  }
  v10 = &s_GfxWorldTransientZoneDeferredReleaseGlob.activeList->pointers[v7];
  dstPointers->posBuffer = v10->posBuffer;
  dstPointers->auxBuffer = v10->auxBuffer;
  *(__m256i *)&dstPointers->indexBuffer = *(__m256i *)&v10->indexBuffer;
  *(_OWORD *)&dstPointers->SMLGppZone = *(_OWORD *)&v10->SMLGppZone;
  dstPointers->reflectionProbes = v10->reflectionProbes;
  v11 = activeList->numPointers - 1;
  activeList->numPointers = v11;
  if ( v7 < (unsigned int)v11 )
  {
    v10->posBuffer = activeList->pointers[v11].posBuffer;
    v10->auxBuffer = activeList->pointers[v11].auxBuffer;
    *(__m256i *)&v10->indexBuffer = *(__m256i *)&activeList->pointers[v11].indexBuffer;
    *(_OWORD *)&v10->SMLGppZone = *(_OWORD *)&activeList->pointers[v11].SMLGppZone;
    v10->reflectionProbes = activeList->pointers[v11].reflectionProbes;
    activeList->zoneHandles[v7] = activeList->zoneHandles[activeList->numPointers];
  }
  return 1;
}

/*
==============
Load_AccessoryDefAsset
==============
*/
void Load_AccessoryDefAsset(AccessoryDef **accessoryDefAsset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*accessoryDefAsset;
  *accessoryDefAsset = DB_AddXAsset(ASSET_TYPE_ACCESSORY, &header).accessory;
  DB_PostAddXAsset();
}

/*
==============
Load_AddonMapEntsAsset
==============
*/
void Load_AddonMapEntsAsset(AddonMapEnts **addonMapEnts)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*addonMapEnts;
  *addonMapEnts = DB_AddXAsset(ASSET_TYPE_ADDON_MAP_ENTS, &header).addonMapEnts;
  DB_PostAddXAsset();
}

/*
==============
Load_AnimationClassAsset
==============
*/
void Load_AnimationClassAsset(AnimationClass **animClass)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*animClass;
  *animClass = DB_AddXAsset(ASSET_TYPE_ANIMCLASS, &header).animClass;
  DB_PostAddXAsset();
}

/*
==============
Load_AnimsetAsset
==============
*/
void Load_AnimsetAsset(Animset **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_ANIMSET, &header).animset;
  DB_PostAddXAsset();
}

/*
==============
Load_AsmAsset
==============
*/
void Load_AsmAsset(ASM **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_ASM, &header).asmAsset;
  DB_PostAddXAsset();
}

/*
==============
Load_BehaviorTreeAsset
==============
*/
void Load_BehaviorTreeAsset(BehaviorTree **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_BEHAVIOR_TREE, &header).behaviorTree;
  DB_PostAddXAsset();
}

/*
==============
Load_BlendSpace2DDefAsset
==============
*/
void Load_BlendSpace2DDefAsset(BlendSpace2DDef **blendSpace2DDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*blendSpace2DDef;
  *blendSpace2DDef = DB_AddXAsset(ASSET_TYPE_BLENDSPACE2D, &header).blendSpace2DDef;
  DB_PostAddXAsset();
}

/*
==============
Load_BulletPenetrationAsset
==============
*/
void Load_BulletPenetrationAsset(BulletPenetration **bulletPenetration)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*bulletPenetration;
  *bulletPenetration = DB_AddXAsset(ASSET_TYPE_BULLETPENETRATION, &header).bulletPenetration;
  DB_PostAddXAsset();
}

/*
==============
Load_CameraDefAsset
==============
*/
void Load_CameraDefAsset(CameraDef **cameraDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*cameraDef;
  *cameraDef = DB_AddXAsset(ASSET_TYPE_CAMERA, &header).cameraDef;
  DB_PostAddXAsset();
}

/*
==============
Load_CamoAsset
==============
*/
void Load_CamoAsset(Camo **camo)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*camo;
  *camo = DB_AddXAsset(ASSET_TYPE_CAMO, &header).camo;
  DB_PostAddXAsset();
}

/*
==============
Load_CarryObjectDefAsset
==============
*/
void Load_CarryObjectDefAsset(CarryObjectDef **carryObjectDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*carryObjectDef;
  *carryObjectDef = DB_AddXAsset(ASSET_TYPE_CARRYOBJECT, &header).carryObjectDef;
  DB_PostAddXAsset();
}

/*
==============
Load_CinematicMotionDefAsset
==============
*/
void Load_CinematicMotionDefAsset(CinematicMotionDef **cinematicMotionDefAsset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*cinematicMotionDefAsset;
  *cinematicMotionDefAsset = DB_AddXAsset(ASSET_TYPE_CINEMATICMOTION, &header).cinematicMotion;
  DB_PostAddXAsset();
}

/*
==============
Load_ClientCharacterAsset
==============
*/
void Load_ClientCharacterAsset(ClientCharacter **clientCharacter)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*clientCharacter;
  *clientCharacter = DB_AddXAsset(ASSET_TYPE_CLIENTCHARACTER, &header).clientCharacter;
  DB_PostAddXAsset();
}

/*
==============
Load_ClipMapAsset
==============
*/
void Load_ClipMapAsset(clipMap_t **clipMap)
{
  XAssetHeader header; 

  (*clipMap)->isInUse = 1;
  header.physicsLibrary = (PhysicsLibrary *)*clipMap;
  *clipMap = DB_AddXAsset(ASSET_TYPE_CLIPMAP, &header).clipMap;
  DB_PostAddXAsset();
}

/*
==============
Load_ClothAssetAsset
==============
*/
void Load_ClothAssetAsset(ClothAsset **clothAsset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*clothAsset;
  *clothAsset = DB_AddXAsset(ASSET_TYPE_CLOTHASSET, &header).clothAsset;
  DB_PostAddXAsset();
}

/*
==============
Load_CollisionTile
==============
*/
void Load_CollisionTile(CollisionTile **collisionTilePtr)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*collisionTilePtr;
  *collisionTilePtr = DB_AddXAsset(ASSET_TYPE_COLLISION_TILE, &header).collisionTile;
  DB_PostAddXAsset();
}

/*
==============
Load_ComWorldAsset
==============
*/
void Load_ComWorldAsset(ComWorld **curComWorld)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*curComWorld;
  *curComWorld = DB_AddXAsset(ASSET_TYPE_COMWORLD, &header).comWorld;
  DB_PostAddXAsset();
  R_SpotShadow_FlushStaleCache();
  R_SpotShadow_FlushActiveCache();
  R_InitializeCachedSunShadowData();
}

/*
==============
Load_ComputeShaderAsset
==============
*/
void Load_ComputeShaderAsset(ComputeShader **computeShader)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*computeShader;
  *computeShader = DB_AddXAsset(ASSET_TYPE_COMPUTESHADER, &header).computeShader;
  DB_PostAddXAsset();
}

/*
==============
Load_CoverSelectorAsset
==============
*/
void Load_CoverSelectorAsset(CoverSelector **coverSelector)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*coverSelector;
  *coverSelector = DB_AddXAsset(ASSET_TYPE_COVERSELECTOR, &header).coverSelector;
  DB_PostAddXAsset();
}

/*
==============
Load_DDLAsset
==============
*/
void Load_DDLAsset(DDLFile **ddlFile)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*ddlFile;
  *ddlFile = DB_AddXAsset(ASSET_TYPE_DDL, &header).ddlFile;
  DB_PostAddXAsset();
}

/*
==============
Load_DLogSchemaAsset
==============
*/
void Load_DLogSchemaAsset(DLogSchema **dlogSchema)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*dlogSchema;
  *dlogSchema = DB_AddXAsset(ASSET_TYPE_DLOG_SCHEMA, &header).dlogSchema;
  DB_PostAddXAsset();
  DLog_PostLoad(*dlogSchema);
}

/*
==============
Load_DynEntityList
==============
*/
void Load_DynEntityList(DynEntityList **dynEntityListPtr)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*dynEntityListPtr;
  *dynEntityListPtr = DB_AddXAsset(ASSET_TYPE_DYNENTITY_LIST, &header).dynEntityList;
  DB_PostAddXAsset();
}

/*
==============
Load_EnemySelectorAsset
==============
*/
void Load_EnemySelectorAsset(EnemySelector **enemySelector)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*enemySelector;
  *enemySelector = DB_AddXAsset(ASSET_TYPE_ENEMYSELECTOR, &header).enemySelector;
  DB_PostAddXAsset();
}

/*
==============
Load_EquipmentSoundTableAsset
==============
*/
void Load_EquipmentSoundTableAsset(EquipmentSoundTable **equipmentSndTable)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*equipmentSndTable;
  *equipmentSndTable = DB_AddXAsset(ASSET_TYPE_EQUIPMENT_SND_TABLE, &header).equipSndTable;
  DB_PostAddXAsset();
}

/*
==============
Load_ExecutionDefAsset
==============
*/
void Load_ExecutionDefAsset(ExecutionDef **executionDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*executionDef;
  *executionDef = DB_AddXAsset(ASSET_TYPE_EXECUTION, &header).executionDef;
  DB_PostAddXAsset();
}

/*
==============
Load_FogSplineAsset
==============
*/
void Load_FogSplineAsset(GfxFogSpline **fogSpline)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*fogSpline;
  *fogSpline = DB_AddXAsset(ASSET_TYPE_FOG_SPLINE, &header).fogSpline;
  DB_PostAddXAsset();
}

/*
==============
Load_FootstepVFXAsset
==============
*/
void Load_FootstepVFXAsset(FootstepVFX **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_FOOTSTEP_VFX, &header).footstepVFX;
  DB_PostAddXAsset();
}

/*
==============
Load_FxImpactTableAsset
==============
*/
void Load_FxImpactTableAsset(FxImpactTable **impactFx)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*impactFx;
  *impactFx = DB_AddXAsset(ASSET_TYPE_IMPACT_FX, &header).impactFx;
  DB_PostAddXAsset();
}

/*
==============
Load_FxParticleSimAnimationAsset
==============
*/
void Load_FxParticleSimAnimationAsset(FxParticleSimAnimation **particleSimAnimation)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*particleSimAnimation;
  *particleSimAnimation = DB_AddXAsset(ASSET_TYPE_PARTICLE_SIM_ANIMATION, &header).particleSimAnimation;
  DB_PostAddXAsset();
}

/*
==============
Load_FxWorldAsset
==============
*/
void Load_FxWorldAsset(FxWorld **curFxWorld)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*curFxWorld;
  *curFxWorld = DB_AddXAsset(ASSET_TYPE_FXWORLD, &header).fxWorld;
  DB_PostAddXAsset();
}

/*
==============
Load_FxWorldTransientZoneAsset
==============
*/
void Load_FxWorldTransientZoneAsset(FxWorldTransientZone **transientZone)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*transientZone;
  *transientZone = DB_AddXAsset(ASSET_TYPE_FXWORLD_TRANSIENT_ZONE, &header).fxWorldTransientZone;
  DB_PostAddXAsset();
}

/*
==============
Load_GestureAsset
==============
*/
void Load_GestureAsset(Gesture **gesture)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*gesture;
  *gesture = DB_AddXAsset(ASSET_TYPE_GESTURE, &header).gesture;
  DB_PostAddXAsset();
}

/*
==============
Load_GfxDecalVolumeMask
==============
*/
void Load_GfxDecalVolumeMask(GfxDecalVolumeMask **asset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*asset;
  *asset = DB_AddXAsset(ASSET_TYPE_DECAL_VOLUME_MASK, &header).decalVolumeMask;
  DB_PostAddXAsset();
}

/*
==============
Load_GfxDecalVolumeMaterial
==============
*/
void Load_GfxDecalVolumeMaterial(GfxDecalVolumeMaterial **asset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*asset;
  *asset = DB_AddXAsset(ASSET_TYPE_DECAL_VOLUME_MATERIAL, &header).decalVolumeMaterial;
  DB_PostAddXAsset();
}

/*
==============
Load_GfxImageAsset
==============
*/
void Load_GfxImageAsset(GfxImage **image)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*image;
  *image = DB_AddXAsset(ASSET_TYPE_IMAGE, &header).image;
  DB_PostAddXAsset();
}

/*
==============
Load_GfxWorldAsset
==============
*/
void Load_GfxWorldAsset(GfxWorld **gfxWorld)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*gfxWorld;
  *gfxWorld = DB_AddXAsset(ASSET_TYPE_GFXWORLD, &header).gfxWorld;
  DB_PostAddXAsset();
  R_CompressedSunShadow_InitStreaming(*gfxWorld);
}

/*
==============
Load_GfxWorldTransientZoneAsset
==============
*/
void Load_GfxWorldTransientZoneAsset(GfxWorldTransientZone **transientZone)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*transientZone;
  *transientZone = DB_AddXAsset(ASSET_TYPE_GFXWORLD_TRANSIENT_ZONE, &header).gfxWorldTransientZone;
  DB_PostAddXAsset();
}

/*
==============
Load_GlassWorldAsset
==============
*/
void Load_GlassWorldAsset(GlassWorld **curGlassWorld)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*curGlassWorld;
  *curGlassWorld = DB_AddXAsset(ASSET_TYPE_GLASSWORLD, &header).glassWorld;
  DB_PostAddXAsset();
}

/*
==============
Load_GradingClutAsset
==============
*/
void Load_GradingClutAsset(GfxGradingClut **gradingClut)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*gradingClut;
  *gradingClut = DB_AddXAsset(ASSET_TYPE_GRADING_CLUT, &header).gradingClut;
  DB_PostAddXAsset();
}

/*
==============
Load_HudOutlineDefAsset
==============
*/
void Load_HudOutlineDefAsset(HudOutlineDef **hudOutlineDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*hudOutlineDef;
  *hudOutlineDef = DB_AddXAsset(ASSET_TYPE_HUDOUTLINE, &header).hudOutlineDef;
  DB_PostAddXAsset();
}

/*
==============
Load_ImageStream
==============
*/
void Load_ImageStream(GfxImage *image)
{
  ;
}

/*
==============
Load_KeyValuePairsAsset
==============
*/
void Load_KeyValuePairsAsset(KeyValuePairs **keyValuePairs)
{
  XAssetHeader v2; 
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*keyValuePairs;
  v2.physicsLibrary = DB_AddXAsset(ASSET_TYPE_KEYVALUEPAIRS, &header).physicsLibrary;
  *keyValuePairs = (KeyValuePairs *)v2.physicsLibrary;
  KeyValuePairs_Add(v2.keyValuePairs);
  DB_PostAddXAsset();
}

/*
==============
Load_LaserDefAsset
==============
*/
void Load_LaserDefAsset(LaserDef **laserDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*laserDef;
  *laserDef = DB_AddXAsset(ASSET_TYPE_LASER, &header).laserDef;
  DB_PostAddXAsset();
}

/*
==============
Load_LeaderboardDefAsset
==============
*/
void Load_LeaderboardDefAsset(LeaderboardDef **leaderboardDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*leaderboardDef;
  *leaderboardDef = DB_AddXAsset(ASSET_TYPE_LEADERBOARD, &header).leaderboardDef;
  DB_PostAddXAsset();
}

/*
==============
Load_LightDefAsset
==============
*/
void Load_LightDefAsset(GfxLightDef **lightDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*lightDef;
  *lightDef = DB_AddXAsset(ASSET_TYPE_LIGHT_DEF, &header).lightDef;
  DB_PostAddXAsset();
}

/*
==============
Load_LocDmgTableAsset
==============
*/
void Load_LocDmgTableAsset(LocDmgTable **locDmgTable)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*locDmgTable;
  *locDmgTable = DB_AddXAsset(ASSET_TYPE_LOCDMGTABLE, &header).locDmgTable;
  DB_PostAddXAsset();
}

/*
==============
Load_LocalizeEntryAsset
==============
*/
void Load_LocalizeEntryAsset(LocalizeEntry **localize)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*localize;
  *localize = DB_AddXAsset(ASSET_TYPE_LOCALIZE_ENTRY, &header).localize;
  DB_PostAddXAsset();
}

/*
==============
Load_LuaFileAsset
==============
*/
void Load_LuaFileAsset(LuaFile **luaFile)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*luaFile;
  *luaFile = DB_AddXAsset(ASSET_TYPE_LUA_FILE, &header).luaFile;
  DB_PostAddXAsset();
}

/*
==============
Load_MapEdgeList
==============
*/
void Load_MapEdgeList(MapEdgeList **mapEdgeListPtr)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*mapEdgeListPtr;
  *mapEdgeListPtr = DB_AddXAsset(ASSET_TYPE_EDGE_LIST, &header).mapEdgeList;
  DB_PostAddXAsset();
}

/*
==============
Load_MapEntsAsset
==============
*/
void Load_MapEntsAsset(MapEnts **mapEnts)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*mapEnts;
  *mapEnts = DB_AddXAsset(ASSET_TYPE_MAP_ENTS, &header).mapEnts;
  DB_PostAddXAsset();
}

/*
==============
Load_MaterialAsset
==============
*/
void Load_MaterialAsset(Material **material)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*material;
  *material = DB_AddXAsset(ASSET_TYPE_MATERIAL, &header).material;
  DB_PostAddXAsset();
}

/*
==============
Load_MaterialSerializedShaderAsset
==============
*/
void Load_MaterialSerializedShaderAsset(MaterialSerializedShader **serializedShader)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*serializedShader;
  *serializedShader = DB_AddXAsset(ASSET_TYPE_SERIALIZEDSHADER, &header).serializedShader;
  DB_PostAddXAsset();
}

/*
==============
Load_MaterialTechniqueSetAsset
==============
*/
void Load_MaterialTechniqueSetAsset(MaterialTechniqueSet **techniqueSet)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*techniqueSet;
  *techniqueSet = DB_AddXAsset(ASSET_TYPE_TECHNIQUE_SET, &header).techniqueSet;
  DB_PostAddXAsset();
}

/*
==============
Load_MayhemDataAsset
==============
*/
void Load_MayhemDataAsset(MayhemData **mayhem)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*mayhem;
  *mayhem = DB_AddXAsset(ASSET_TYPE_MAYHEM, &header).mayhem;
  DB_PostAddXAsset();
}

/*
==============
Load_NativeScriptPatchFileAsset
==============
*/
void Load_NativeScriptPatchFileAsset(NativeScriptPatchFile **patchFilePtr)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*patchFilePtr;
  *patchFilePtr = DB_AddXAsset(ASSET_TYPE_NATIVE_SCRIPT_PATCH, &header).nativeScriptPatch;
  DB_PostAddXAsset();
}

/*
==============
Load_NavMeshDataAsset
==============
*/
void Load_NavMeshDataAsset(NavMeshData **navMesh)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*navMesh;
  *navMesh = DB_AddXAsset(ASSET_TYPE_NAVMESH, &header).navMeshData;
  DB_PostAddXAsset();
}

/*
==============
Load_NetConstStringsAsset
==============
*/
void Load_NetConstStringsAsset(NetConstStrings **netConstStrings)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*netConstStrings;
  *netConstStrings = DB_AddXAsset(ASSET_TYPE_NET_CONST_STRINGS, &header).netConstStrings;
  DB_PostAddXAsset();
}

/*
==============
Load_ParticleSystemDefAsset
==============
*/
void Load_ParticleSystemDefAsset(ParticleSystemDef **vfx)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*vfx;
  *vfx = DB_AddXAsset(ASSET_TYPE_VFX, &header).vfx;
  DB_PostAddXAsset();
  Particle_AssetFixup(*vfx);
  if ( (*(_BYTE *)vfx & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4204, ASSERT_TYPE_ASSERT, "(((uintptr_t)(const void *)(*vfx)) % (16) == 0)", (const char *)&queryFormat, "((uintptr_t)(const void *)(*vfx)) % (PARTICLE_ALIGNMENT) == 0") )
    __debugbreak();
}

/*
==============
Load_ParticleSystemDefFromName
==============
*/
void Load_ParticleSystemDefFromName(const char **name)
{
  if ( *name )
    *name = (const char *)DB_FindXAssetHeader(ASSET_TYPE_VFX, *name, 1).physicsLibrary;
}

/*
==============
Load_PathDataAsset
==============
*/
void Load_PathDataAsset(PathData **curPathData)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*curPathData;
  *curPathData = DB_AddXAsset(ASSET_TYPE_PATHDATA, &header).pathData;
  DB_PostAddXAsset();
}

/*
==============
Load_PhysicsAsset
==============
*/
void Load_PhysicsAsset(PhysicsAsset **physicsAsset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*physicsAsset;
  *physicsAsset = DB_AddXAsset(ASSET_TYPE_PHYSICSASSET, &header).physicsAsset;
  DB_PostAddXAsset();
}

/*
==============
Load_PhysicsDebugData
==============
*/
void Load_PhysicsDebugData(PhysicsDebugData **physicsDebugData)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*physicsDebugData;
  *physicsDebugData = DB_AddXAsset(ASSET_TYPE_PHYSICS_DEBUG_DATA, &header).physicsDebugData;
  DB_PostAddXAsset();
}

/*
==============
Load_PhysicsFXPipelineAsset
==============
*/
void Load_PhysicsFXPipelineAsset(PhysicsFXPipeline **physicsFXPipeline)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*physicsFXPipeline;
  *physicsFXPipeline = DB_AddXAsset(ASSET_TYPE_PHYSICS_FX_PIPELINE, &header).physicsFXPipeline;
  DB_PostAddXAsset();
}

/*
==============
Load_PhysicsFXShapeAsset
==============
*/
void Load_PhysicsFXShapeAsset(PhysicsFXShape **physicsFXShape)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*physicsFXShape;
  *physicsFXShape = DB_AddXAsset(ASSET_TYPE_PHYSICS_FX_SHAPE, &header).physicsFXShape;
  DB_PostAddXAsset();
}

/*
==============
Load_PhysicsLibraryAsset
==============
*/
void Load_PhysicsLibraryAsset(PhysicsLibrary **physicsLibrary)
{
  XAssetHeader header; 

  header.physicsLibrary = *physicsLibrary;
  *physicsLibrary = DB_AddXAsset(ASSET_TYPE_PHYSICSLIBRARY, &header).physicsLibrary;
  DB_PostAddXAsset();
}

/*
==============
Load_PhysicsSFXEventAsset
==============
*/
void Load_PhysicsSFXEventAsset(PhysicsSFXEventAsset **physicsSFXEventAsset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*physicsSFXEventAsset;
  *physicsSFXEventAsset = DB_AddXAsset(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, &header).physicsSFXEventAsset;
  DB_PostAddXAsset();
}

/*
==============
Load_PhysicsVFXEventAsset
==============
*/
void Load_PhysicsVFXEventAsset(PhysicsVFXEventAsset **physicsVFXEventAsset)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*physicsVFXEventAsset;
  *physicsVFXEventAsset = DB_AddXAsset(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, &header).physicsVFXEventAsset;
  DB_PostAddXAsset();
}

/*
==============
Load_PlayerAnimScriptAsset
==============
*/
void Load_PlayerAnimScriptAsset(PlayerAnimScript **playerAnimScript)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*playerAnimScript;
  *playerAnimScript = DB_AddXAsset(ASSET_TYPE_PLAYERANIM, &header).playerAnim;
  DB_PostAddXAsset();
}

/*
==============
Load_RawFileAsset
==============
*/
void Load_RawFileAsset(RawFile **rawfile)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*rawfile;
  *rawfile = DB_AddXAsset(ASSET_TYPE_RAWFILE, &header).rawfile;
  if ( header.physicsLibrary && !*(_DWORD *)&header.physicsLibrary->isMaterialList && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4318, ASSERT_TYPE_ASSERT, "(!header.rawfile || header.rawfile->compressedLen)", (const char *)&queryFormat, "!header.rawfile || header.rawfile->compressedLen") )
    __debugbreak();
  DB_PostAddXAsset();
  if ( header.physicsLibrary )
  {
    if ( !I_stricmp(header.physicsLibrary->name, "structlayout.bin") )
      DB_StructLayout_Test(header.rawfile);
  }
}

/*
==============
Load_ReticleDefAsset
==============
*/
void Load_ReticleDefAsset(ReticleDef **reticleDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*reticleDef;
  *reticleDef = DB_AddXAsset(ASSET_TYPE_RETICLE, &header).reticleDef;
  DB_PostAddXAsset();
}

/*
==============
Load_RumbleGraphAsset
==============
*/
void Load_RumbleGraphAsset(RumbleGraph **rumbleGraph)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*rumbleGraph;
  *rumbleGraph = DB_AddXAsset(ASSET_TYPE_RUMBLE_GRAPH, &header).rumbleGraph;
  DB_PostAddXAsset();
}

/*
==============
Load_RumbleInfoAsset
==============
*/
void Load_RumbleInfoAsset(RumbleInfo **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_RUMBLE, &header).rumble;
  DB_PostAddXAsset();
}

/*
==============
Load_ScriptBundleAsset
==============
*/
void Load_ScriptBundleAsset(ScriptBundle **scriptBundle)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*scriptBundle;
  *scriptBundle = DB_AddXAsset(ASSET_TYPE_SCRIPTBUNDLE, &header).scriptBundle;
  DB_PostAddXAsset();
}

/*
==============
Load_ScriptDebugData
==============
*/
void Load_ScriptDebugData(ScriptDebugData **scriptDebugData)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*scriptDebugData;
  *scriptDebugData = DB_AddXAsset(ASSET_TYPE_SCRIPT_DEBUG_DATA, &header).scriptDebugData;
  DB_PostAddXAsset();
}

/*
==============
Load_ScriptFileAsset
==============
*/
void Load_ScriptFileAsset(ScriptFile **scriptfile)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*scriptfile;
  *scriptfile = DB_AddXAsset(ASSET_TYPE_SCRIPTFILE, &header).scriptfile;
  DB_PostAddXAsset();
}

/*
==============
Load_ScriptableDefAsset
==============
*/
void Load_ScriptableDefAsset(ScriptableDef **scriptable)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*scriptable;
  *scriptable = DB_AddXAsset(ASSET_TYPE_SCRIPTABLE, &header).scriptable;
  DB_PostAddXAsset();
}

/*
==============
Load_SndBankResidentAsset
==============
*/
void Load_SndBankResidentAsset(SndBankResident **sndBank)
{
  SndBankResident *v2; 
  const char *name; 
  char v4; 
  StreamKey *loadedStreamKey; 
  XAssetHeader header; 

  v2 = *sndBank;
  header.physicsLibrary = (PhysicsLibrary *)*sndBank;
  if ( !g_assetNameFieldValid[17] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[17], v2) )
    __debugbreak();
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[17]) )
    __debugbreak();
  name = v2->bank.name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 87, ASSERT_TYPE_ASSERT, "(assetName)", (const char *)&queryFormat, "assetName") )
    __debugbreak();
  v4 = *name;
  *sndBank = DB_AddXAsset(ASSET_TYPE_SOUND_BANK, &header).soundBankResident;
  DB_PostAddXAsset();
  if ( !*sndBank && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3710, ASSERT_TYPE_ASSERT, "(*sndBank)", (const char *)&queryFormat, "*sndBank") )
    __debugbreak();
  if ( v4 != 44 )
  {
    SND_AddBank(&(*sndBank)->bank, g_dbPreloading);
    loadedStreamKey = (*sndBank)->bank.streamInfo.loadedStreamKey;
    if ( loadedStreamKey )
      Load_StreamKeyResident(loadedStreamKey);
  }
}

/*
==============
Load_SndBankTransientAsset
==============
*/
void Load_SndBankTransientAsset(SndBankTransient **sndBank)
{
  SndBankTransient *v2; 
  const char *name; 
  char v4; 
  XAssetHeader header; 

  v2 = *sndBank;
  header.physicsLibrary = (PhysicsLibrary *)*sndBank;
  if ( !g_assetNameFieldValid[18] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 63, ASSERT_TYPE_ASSERT, "(DB_XAssetTypeHasName( type ))", "%s\n\tDB_GetXAssetHeaderName %s, 0x%p", "DB_XAssetTypeHasName( type )", g_assetNames[18], v2) )
    __debugbreak();
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 65, ASSERT_TYPE_ASSERT, "(header.data)", "%s\n\tDB_GetXAssetHeaderName %s, nullptr", "header.data", g_assetNames[18]) )
    __debugbreak();
  name = v2->bank.name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assetnames.h", 87, ASSERT_TYPE_ASSERT, "(assetName)", (const char *)&queryFormat, "assetName") )
    __debugbreak();
  v4 = *name;
  *sndBank = DB_AddXAsset(ASSET_TYPE_SOUND_BANK_TRANSIENT, &header).soundBankTransient;
  DB_PostAddXAsset();
  if ( !*sndBank && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3794, ASSERT_TYPE_ASSERT, "(*sndBank)", (const char *)&queryFormat, "*sndBank") )
    __debugbreak();
  if ( v4 != 44 )
  {
    SND_AddBank(&(*sndBank)->bank, g_dbPreloading);
    if ( ((*sndBank)->bank.streamInfo.loadedStreamKey->flags & 2) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3806, ASSERT_TYPE_ASSERT, "(!loadedStreamKey->Resident())", (const char *)&queryFormat, "!loadedStreamKey->Resident()") )
      __debugbreak();
  }
}

/*
==============
Load_SndGlobalsAsset
==============
*/
void Load_SndGlobalsAsset(SndGlobals **soundGlobals)
{
  XAssetHeader v2; 
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*soundGlobals;
  v2.physicsLibrary = DB_AddXAsset(ASSET_TYPE_SOUND_GLOBALS, &header).physicsLibrary;
  *soundGlobals = (SndGlobals *)v2.physicsLibrary;
  SND_AddGlobals(v2.soundGlobals);
  DB_PostAddXAsset();
}

/*
==============
Load_SoundBankListDefAsset
==============
*/
void Load_SoundBankListDefAsset(SoundBankListDef **soundBankListDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*soundBankListDef;
  *soundBankListDef = DB_AddXAsset(ASSET_TYPE_SOUNDBANKLIST, &header).soundBankListDef;
  DB_PostAddXAsset();
  BG_LoadSoundBankList(*soundBankListDef);
}

/*
==============
Load_SpaceshipTargetDefAsset
==============
*/
void Load_SpaceshipTargetDefAsset(SpaceshipTargetDef **spaceshipTargetDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*spaceshipTargetDef;
  *spaceshipTargetDef = DB_AddXAsset(ASSET_TYPE_SPACESHIPTARGET, &header).spaceshipTargetDef;
  DB_PostAddXAsset();
}

/*
==============
Load_StClutterSampleBitmask
==============
*/
void Load_StClutterSampleBitmask(StClutterSampleBitmask *bitmask)
{
  if ( bitmask->streamKey )
  {
    if ( bitmask->bitmask && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4961, ASSERT_TYPE_ASSERT, "(bitmask->bitmask == nullptr)", (const char *)&queryFormat, "bitmask->bitmask == nullptr") )
      __debugbreak();
    if ( bitmask->bitmaskBuffer.data && bitmask->bitmaskBuffer.view.view >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4962, ASSERT_TYPE_ASSERT, "(bitmask->bitmaskBuffer.IsNull())", (const char *)&queryFormat, "bitmask->bitmaskBuffer.IsNull()") )
      __debugbreak();
    bitmask->streamKey->assetHash = (unsigned __int64)bitmask;
    Load_StreamKeyResident(bitmask->streamKey);
  }
}

/*
==============
Load_StTerrainAsset
==============
*/
void Load_StTerrainAsset(StTerrain **terrain)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*terrain;
  *terrain = DB_AddXAsset(ASSET_TYPE_SUPER_TERRAIN, &header).stTerrain;
  DB_PostAddXAsset();
}

/*
==============
Load_StreamKeyAsset
==============
*/
void Load_StreamKeyAsset(StreamKey **key)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*key;
  *key = DB_AddXAsset(ASSET_TYPE_STREAM_KEY, &header).streamKey;
  DB_PostAddXAsset();
}

/*
==============
Load_StreamTreeOverrideAsset
==============
*/
void Load_StreamTreeOverrideAsset(StreamTreeOverride **treeOverride)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*treeOverride;
  *treeOverride = DB_AddXAsset(ASSET_TYPE_STREAM_TREE_OVERRIDE, &header).streamTreeOverride;
  DB_PostAddXAsset();
}

/*
==============
Load_StreamingInfoAsset
==============
*/
void Load_StreamingInfoAsset(StreamingInfo **streamingInfoPtr)
{
  DBTransientsRegisterStage v2; 
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*streamingInfoPtr;
  *streamingInfoPtr = DB_AddXAsset(ASSET_TYPE_STREAMING_INFO, &header).streamingInfo;
  DB_PostAddXAsset();
  if ( !*streamingInfoPtr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4104, ASSERT_TYPE_ASSERT, "(*streamingInfoPtr)", (const char *)&queryFormat, "*streamingInfoPtr") )
    __debugbreak();
  LOBYTE(v2) = g_dbPreloading;
  DB_StreamingInfo_Register(*streamingInfoPtr, v2);
}

/*
==============
Load_StringTableAsset
==============
*/
void Load_StringTableAsset(StringTable **stringTable)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*stringTable;
  *stringTable = DB_AddXAsset(ASSET_TYPE_STRINGTABLE, &header).stringTable;
  DB_PostAddXAsset();
}

/*
==============
Load_SuitAnimPackageAsset
==============
*/
void Load_SuitAnimPackageAsset(SuitAnimPackage **suitAnimPackage)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*suitAnimPackage;
  *suitAnimPackage = DB_AddXAsset(ASSET_TYPE_SUITANIMPACKAGE, &header).suitAnimPackage;
  DB_PostAddXAsset();
}

/*
==============
Load_SuitDefAsset
==============
*/
void Load_SuitDefAsset(SuitDef **suitDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*suitDef;
  *suitDef = DB_AddXAsset(ASSET_TYPE_SUIT, &header).suitDef;
  DB_PostAddXAsset();
}

/*
==============
Load_SurfaceFxTableAsset
==============
*/
void Load_SurfaceFxTableAsset(SurfaceFxTable **surfaceFx)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*surfaceFx;
  *surfaceFx = DB_AddXAsset(ASSET_TYPE_SURFACE_FX, &header).surfaceFx;
  DB_PostAddXAsset();
}

/*
==============
Load_TTFAsset
==============
*/
void Load_TTFAsset(TTFDef **ttf)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*ttf;
  *ttf = DB_AddXAsset(ASSET_TYPE_TTF, &header).ttfDef;
  DB_PostAddXAsset();
}

/*
==============
Load_TacticalGraphDataAsset
==============
*/
void Load_TacticalGraphDataAsset(TacticalGraphData **tacGraph)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*tacGraph;
  *tacGraph = DB_AddXAsset(ASSET_TYPE_TACGRAPH, &header).tacGraphData;
  DB_PostAddXAsset();
}

/*
==============
Load_TerrainMesh
==============
*/
void Load_TerrainMesh(StMesh *mesh, StTerrainNode *node)
{
  StreamKey *streamKey; 

  streamKey = mesh->streamKey;
  if ( streamKey )
  {
    streamKey->assetHash = (unsigned __int64)node;
    Load_StreamKeyResident(mesh->streamKey);
  }
}

/*
==============
Load_TracerDefAsset
==============
*/
void Load_TracerDefAsset(TracerDef **tracerDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*tracerDef;
  *tracerDef = DB_AddXAsset(ASSET_TYPE_TRACER, &header).tracerDef;
  DB_PostAddXAsset();
}

/*
==============
Load_VectorFieldAsset
==============
*/
void Load_VectorFieldAsset(VectorField **vectorField)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*vectorField;
  *vectorField = DB_AddXAsset(ASSET_TYPE_VECTORFIELD, &header).vectorField;
  DB_PostAddXAsset();
}

/*
==============
Load_VehicleDefAsset
==============
*/
void Load_VehicleDefAsset(VehicleDef **vehDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*vehDef;
  *vehDef = DB_AddXAsset(ASSET_TYPE_VEHICLE, &header).vehDef;
  DB_PostAddXAsset();
}

/*
==============
Load_VirtualLeaderboardDefAsset
==============
*/
void Load_VirtualLeaderboardDefAsset(VirtualLeaderboardDef **vlbDef)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*vlbDef;
  *vlbDef = DB_AddXAsset(ASSET_TYPE_VIRTUAL_LEADERBOARD, &header).virtualLeaderboardDef;
  DB_PostAddXAsset();
}

/*
==============
Load_WeaponAnimPackageAsset
==============
*/
void Load_WeaponAnimPackageAsset(WeaponAnimPackage **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_ANIM_PACKAGE, &header).weaponAnimPackage;
  DB_PostAddXAsset();
}

/*
==============
Load_WeaponAttachmentAsset
==============
*/
void Load_WeaponAttachmentAsset(WeaponAttachment **attachment)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*attachment;
  *attachment = DB_AddXAsset(ASSET_TYPE_ATTACHMENT, &header).attachment;
  DB_PostAddXAsset();
}

/*
==============
Load_WeaponCompleteDefAsset
==============
*/
void Load_WeaponCompleteDefAsset(WeaponCompleteDef **weapon)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*weapon;
  *weapon = DB_AddXAsset(ASSET_TYPE_WEAPON, &header).weapon;
  DB_PostAddXAsset();
}

/*
==============
Load_WeaponSFXPackageAsset
==============
*/
void Load_WeaponSFXPackageAsset(WeaponSFXPackage **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_SFX_PACKAGE, &header).weaponSFXPackage;
  DB_PostAddXAsset();
}

/*
==============
Load_WeaponVFXPackageAsset
==============
*/
void Load_WeaponVFXPackageAsset(WeaponVFXPackage **info)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*info;
  *info = DB_AddXAsset(ASSET_TYPE_VFX_PACKAGE, &header).weaponVFXPackage;
  DB_PostAddXAsset();
}

/*
==============
Load_XAnimCurveAsset
==============
*/
void Load_XAnimCurveAsset(XAnimCurve **curve)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*curve;
  *curve = DB_AddXAsset(ASSET_TYPE_XANIMCURVE, &header).xanimCurve;
  DB_PostAddXAsset();
}

/*
==============
Load_XAnimDynamicBonesAsset
==============
*/
void Load_XAnimDynamicBonesAsset(XAnimDynamicBones **dynamicBones)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*dynamicBones;
  *dynamicBones = DB_AddXAsset(ASSET_TYPE_XANIM_DYNAMICBONES, &header).dynamicBones;
  DB_PostAddXAsset();
}

/*
==============
Load_XAnimPartsAsset
==============
*/
void Load_XAnimPartsAsset(XAnimParts **parts)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*parts;
  *parts = DB_AddXAsset(ASSET_TYPE_XANIMPARTS, &header).parts;
  DB_PostAddXAsset();
}

/*
==============
Load_XAnimProceduralBonesAsset
==============
*/
void Load_XAnimProceduralBonesAsset(XAnimProceduralBones **proceduralBones)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*proceduralBones;
  *proceduralBones = DB_AddXAsset(ASSET_TYPE_XANIM_PROCEDURALBONES, &header).proceduralBones;
  DB_PostAddXAsset();
}

/*
==============
Load_XCamAsset
==============
*/
void Load_XCamAsset(XCam **xcam)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*xcam;
  *xcam = DB_AddXAsset(ASSET_TYPE_XCAM, &header).xcam;
  DB_PostAddXAsset();
}

/*
==============
Load_XCompositeModelDefAsset
==============
*/
void Load_XCompositeModelDefAsset(XCompositeModelDef **compositeModel)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*compositeModel;
  *compositeModel = DB_AddXAsset(ASSET_TYPE_XCOMPOSITEMODEL, &header).compositeModel;
  DB_PostAddXAsset();
}

/*
==============
Load_XModelAsset
==============
*/
void Load_XModelAsset(XModel **model)
{
  XAssetHeader v2; 
  XModel *physicsLibrary; 
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*model;
  v2.physicsLibrary = DB_AddXAsset(ASSET_TYPE_XMODEL, &header).physicsLibrary;
  physicsLibrary = (XModel *)header.physicsLibrary;
  *model = (XModel *)v2.physicsLibrary;
  if ( physicsLibrary )
    DB_ModelFixup_FixXModel(physicsLibrary);
  DB_PostAddXAsset();
}

/*
==============
Load_XModelDetailCollisionAsset
==============
*/
void Load_XModelDetailCollisionAsset(XModelDetailCollision **detailCollision)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*detailCollision;
  *detailCollision = DB_AddXAsset(ASSET_TYPE_XMODEL_DETAIL_COLLISION, &header).modelDetailCollision;
  DB_PostAddXAsset();
}

/*
==============
Load_XModelSurfsAsset
==============
*/
void Load_XModelSurfsAsset(XModelSurfs **modelSurfs)
{
  XAssetHeader header; 

  header.physicsLibrary = (PhysicsLibrary *)*modelSurfs;
  *modelSurfs = DB_AddXAsset(ASSET_TYPE_XMODEL_SURFS, &header).modelSurfs;
  DB_PostAddXAsset();
}

/*
==============
Load_XModelSurfsFixup
==============
*/
void Load_XModelSurfsFixup(const XModelSurfs *const *modelSurfsPtrPtr, const XModel *model, XModelLodInfo *lodInfo)
{
  if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 966, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  if ( !lodInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 967, ASSERT_TYPE_ASSERT, "(lodInfo)", (const char *)&queryFormat, "lodInfo") )
    __debugbreak();
  if ( !modelSurfsPtrPtr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 968, ASSERT_TYPE_ASSERT, "(modelSurfsPtrPtr)", (const char *)&queryFormat, "modelSurfsPtrPtr") )
    __debugbreak();
  if ( *modelSurfsPtrPtr )
    DB_ModelFixup_FixXModelSurf(model, lodInfo, *modelSurfsPtrPtr);
}

/*
==============
Mark_AccessoryDefAsset
==============
*/
int Mark_AccessoryDefAsset(AccessoryDef *accessoryDefAsset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ACCESSORY, (XAssetHeader)accessoryDefAsset, inuse);
}

/*
==============
Mark_AddonMapEntsAsset
==============
*/
int Mark_AddonMapEntsAsset(AddonMapEnts *addonMapEnts, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ADDON_MAP_ENTS, (XAssetHeader)addonMapEnts, inuse);
}

/*
==============
Mark_AnimationClassAsset
==============
*/
int Mark_AnimationClassAsset(AnimationClass *animClass, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ANIMCLASS, (XAssetHeader)animClass, inuse);
}

/*
==============
Mark_AnimsetAsset
==============
*/
int Mark_AnimsetAsset(Animset *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ANIMSET, (XAssetHeader)info, inuse);
}

/*
==============
Mark_AsmAsset
==============
*/
int Mark_AsmAsset(ASM *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ASM, (XAssetHeader)info, inuse);
}

/*
==============
Mark_BehaviorTreeAsset
==============
*/
int Mark_BehaviorTreeAsset(BehaviorTree *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_BEHAVIOR_TREE, (XAssetHeader)info, inuse);
}

/*
==============
Mark_BlendSpace2DDefAsset
==============
*/
int Mark_BlendSpace2DDefAsset(BlendSpace2DDef *blendSpace2DDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_BLENDSPACE2D, (XAssetHeader)blendSpace2DDef, inuse);
}

/*
==============
Mark_BulletPenetrationAsset
==============
*/
int Mark_BulletPenetrationAsset(BulletPenetration *bulletPenetration, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_BULLETPENETRATION, (XAssetHeader)bulletPenetration, inuse);
}

/*
==============
Mark_CameraDefAsset
==============
*/
int Mark_CameraDefAsset(CameraDef *cameraDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_CAMERA, (XAssetHeader)cameraDef, inuse);
}

/*
==============
Mark_CamoAsset
==============
*/
int Mark_CamoAsset(Camo *camo, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_CAMO, (XAssetHeader)camo, inuse);
}

/*
==============
Mark_CarryObjectDefAsset
==============
*/
int Mark_CarryObjectDefAsset(CarryObjectDef *carryObjectDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_CARRYOBJECT, (XAssetHeader)carryObjectDef, inuse);
}

/*
==============
Mark_CinematicMotionDefAsset
==============
*/
int Mark_CinematicMotionDefAsset(CinematicMotionDef *cinematicMotionDefAsset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_CINEMATICMOTION, (XAssetHeader)cinematicMotionDefAsset, inuse);
}

/*
==============
Mark_ClientCharacterAsset
==============
*/
int Mark_ClientCharacterAsset(ClientCharacter *clientCharacter, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_CLIENTCHARACTER, (XAssetHeader)clientCharacter, inuse);
}

/*
==============
Mark_ClipMapAsset
==============
*/
int Mark_ClipMapAsset(clipMap_t *clipMap, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_CLIPMAP, (XAssetHeader)clipMap, inuse);
}

/*
==============
Mark_ClothAssetAsset
==============
*/
int Mark_ClothAssetAsset(ClothAsset *clothAsset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_CLOTHASSET, (XAssetHeader)clothAsset, inuse);
}

/*
==============
Mark_CollisionTileAsset
==============
*/
int Mark_CollisionTileAsset(CollisionTile *collisionTile, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_COLLISION_TILE, (XAssetHeader)collisionTile, inuse);
}

/*
==============
Mark_ComWorldAsset
==============
*/
int Mark_ComWorldAsset(ComWorld *curComWorld, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_COMWORLD, (XAssetHeader)curComWorld, inuse);
}

/*
==============
Mark_ComputeShaderAsset
==============
*/
int Mark_ComputeShaderAsset(ComputeShader *computeShader, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_COMPUTESHADER, (XAssetHeader)computeShader, inuse);
}

/*
==============
Mark_CoverSelectorAsset
==============
*/
int Mark_CoverSelectorAsset(CoverSelector *coverSelector, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_COVERSELECTOR, (XAssetHeader)coverSelector, inuse);
}

/*
==============
Mark_DDLAsset
==============
*/
int Mark_DDLAsset(DDLFile *ddlFile, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_DDL, (XAssetHeader)ddlFile, inuse);
}

/*
==============
Mark_DLogSchemaAsset
==============
*/
int Mark_DLogSchemaAsset(DLogSchema *dlogSchema, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_DLOG_SCHEMA, (XAssetHeader)dlogSchema, inuse);
}

/*
==============
Mark_DynEntityListAsset
==============
*/
int Mark_DynEntityListAsset(DynEntityList *dynEntityList, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_DYNENTITY_LIST, (XAssetHeader)dynEntityList, inuse);
}

/*
==============
Mark_EnemySelectorAsset
==============
*/
int Mark_EnemySelectorAsset(EnemySelector *enemySelector, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ENEMYSELECTOR, (XAssetHeader)enemySelector, inuse);
}

/*
==============
Mark_EquipmentSoundTableAsset
==============
*/
int Mark_EquipmentSoundTableAsset(EquipmentSoundTable *equipmentSndTable, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_EQUIPMENT_SND_TABLE, (XAssetHeader)equipmentSndTable, inuse);
}

/*
==============
Mark_ExecutionDefAsset
==============
*/
int Mark_ExecutionDefAsset(ExecutionDef *executionDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_EXECUTION, (XAssetHeader)executionDef, inuse);
}

/*
==============
Mark_FogSplineAsset
==============
*/
int Mark_FogSplineAsset(GfxFogSpline *fogSpline, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_FOG_SPLINE, (XAssetHeader)fogSpline, inuse);
}

/*
==============
Mark_FootstepVFXAsset
==============
*/
int Mark_FootstepVFXAsset(FootstepVFX *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_FOOTSTEP_VFX, (XAssetHeader)info, inuse);
}

/*
==============
Mark_FxImpactTableAsset
==============
*/
int Mark_FxImpactTableAsset(FxImpactTable *impactFx, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_IMPACT_FX, (XAssetHeader)impactFx, inuse);
}

/*
==============
Mark_FxParticleSimAnimationAsset
==============
*/
int Mark_FxParticleSimAnimationAsset(FxParticleSimAnimation *particleSimAnimation, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PARTICLE_SIM_ANIMATION, (XAssetHeader)particleSimAnimation, inuse);
}

/*
==============
Mark_FxWorldAsset
==============
*/
int Mark_FxWorldAsset(FxWorld *curFxWorld, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_FXWORLD, (XAssetHeader)curFxWorld, inuse);
}

/*
==============
Mark_FxWorldTransientZoneAsset
==============
*/
int Mark_FxWorldTransientZoneAsset(FxWorldTransientZone *transientZone, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_FXWORLD_TRANSIENT_ZONE, (XAssetHeader)transientZone, inuse);
}

/*
==============
Mark_GestureAsset
==============
*/
int Mark_GestureAsset(Gesture *gesture, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_GESTURE, (XAssetHeader)gesture, inuse);
}

/*
==============
Mark_GfxDecalVolumeMask
==============
*/
int Mark_GfxDecalVolumeMask(GfxDecalVolumeMask *asset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_DECAL_VOLUME_MASK, (XAssetHeader)asset, inuse);
}

/*
==============
Mark_GfxDecalVolumeMaterial
==============
*/
int Mark_GfxDecalVolumeMaterial(GfxDecalVolumeMaterial *asset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_DECAL_VOLUME_MATERIAL, (XAssetHeader)asset, inuse);
}

/*
==============
Mark_GfxImageAsset
==============
*/
int Mark_GfxImageAsset(GfxImage *image, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_IMAGE, (XAssetHeader)image, inuse);
}

/*
==============
Mark_GfxWorldAsset
==============
*/
int Mark_GfxWorldAsset(GfxWorld *gfxWorld, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_GFXWORLD, (XAssetHeader)gfxWorld, inuse);
}

/*
==============
Mark_GfxWorldTransientZoneAsset
==============
*/
int Mark_GfxWorldTransientZoneAsset(GfxWorldTransientZone *transientZone, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_GFXWORLD_TRANSIENT_ZONE, (XAssetHeader)transientZone, inuse);
}

/*
==============
Mark_GlassWorldAsset
==============
*/
int Mark_GlassWorldAsset(GlassWorld *curGlassWorld, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_GLASSWORLD, (XAssetHeader)curGlassWorld, inuse);
}

/*
==============
Mark_GradingClutAsset
==============
*/
int Mark_GradingClutAsset(GfxGradingClut *gradingClut, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_GRADING_CLUT, (XAssetHeader)gradingClut, inuse);
}

/*
==============
Mark_HudOutlineDefAsset
==============
*/
int Mark_HudOutlineDefAsset(HudOutlineDef *hudOutlineDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_HUDOUTLINE, (XAssetHeader)hudOutlineDef, inuse);
}

/*
==============
Mark_KeyValuePairsAsset
==============
*/
int Mark_KeyValuePairsAsset(KeyValuePairs *keyValuePairs, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_KEYVALUEPAIRS, (XAssetHeader)keyValuePairs, inuse);
}

/*
==============
Mark_LaserDefAsset
==============
*/
int Mark_LaserDefAsset(LaserDef *laserDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_LASER, (XAssetHeader)laserDef, inuse);
}

/*
==============
Mark_LeaderboardDefAsset
==============
*/
int Mark_LeaderboardDefAsset(LeaderboardDef *leaderboardDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_LEADERBOARD, (XAssetHeader)leaderboardDef, inuse);
}

/*
==============
Mark_LightDefAsset
==============
*/
int Mark_LightDefAsset(GfxLightDef *lightDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_LIGHT_DEF, (XAssetHeader)lightDef, inuse);
}

/*
==============
Mark_LocDmgTableAsset
==============
*/
int Mark_LocDmgTableAsset(LocDmgTable *locDmgTable, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_LOCDMGTABLE, (XAssetHeader)locDmgTable, inuse);
}

/*
==============
Mark_LocalizeEntryAsset
==============
*/
int Mark_LocalizeEntryAsset(LocalizeEntry *localize, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_LOCALIZE_ENTRY, (XAssetHeader)localize, inuse);
}

/*
==============
Mark_LuaFileAsset
==============
*/
int Mark_LuaFileAsset(LuaFile *luaFile, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_LUA_FILE, (XAssetHeader)luaFile, inuse);
}

/*
==============
Mark_MapEdgeListAsset
==============
*/
int Mark_MapEdgeListAsset(MapEdgeList *mapEdgeList, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_EDGE_LIST, (XAssetHeader)mapEdgeList, inuse);
}

/*
==============
Mark_MapEntsAsset
==============
*/
int Mark_MapEntsAsset(MapEnts *mapEnts, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_MAP_ENTS, (XAssetHeader)mapEnts, inuse);
}

/*
==============
Mark_MaterialAsset
==============
*/
int Mark_MaterialAsset(Material *material, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_MATERIAL, (XAssetHeader)material, inuse);
}

/*
==============
Mark_MaterialSerializedShaderAsset
==============
*/
int Mark_MaterialSerializedShaderAsset(MaterialSerializedShader *serializedShader, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SERIALIZEDSHADER, (XAssetHeader)serializedShader, inuse);
}

/*
==============
Mark_MaterialTechniqueSetAsset
==============
*/
int Mark_MaterialTechniqueSetAsset(MaterialTechniqueSet *techniqueSet, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_TECHNIQUE_SET, (XAssetHeader)techniqueSet, inuse);
}

/*
==============
Mark_MayhemDataAsset
==============
*/
int Mark_MayhemDataAsset(MayhemData *mayhem, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_MAYHEM, (XAssetHeader)mayhem, inuse);
}

/*
==============
Mark_NativeScriptPatchFileAsset
==============
*/
int Mark_NativeScriptPatchFileAsset(NativeScriptPatchFile *patchFile, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_NATIVE_SCRIPT_PATCH, (XAssetHeader)patchFile, inuse);
}

/*
==============
Mark_NavMeshDataAsset
==============
*/
int Mark_NavMeshDataAsset(NavMeshData *navMesh, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_NAVMESH, (XAssetHeader)navMesh, inuse);
}

/*
==============
Mark_NetConstStringsAsset
==============
*/
int Mark_NetConstStringsAsset(NetConstStrings *netConstStrings, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_NET_CONST_STRINGS, (XAssetHeader)netConstStrings, inuse);
}

/*
==============
Mark_ParticleSystemDefAsset
==============
*/
int Mark_ParticleSystemDefAsset(ParticleSystemDef *vfx, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_VFX, (XAssetHeader)vfx, inuse);
}

/*
==============
Mark_PathDataAsset
==============
*/
int Mark_PathDataAsset(PathData *curPathData, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PATHDATA, (XAssetHeader)curPathData, inuse);
}

/*
==============
Mark_PhysicsAsset
==============
*/
int Mark_PhysicsAsset(PhysicsAsset *physicsAsset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PHYSICSASSET, (XAssetHeader)physicsAsset, inuse);
}

/*
==============
Mark_PhysicsDebugData
==============
*/
int Mark_PhysicsDebugData(PhysicsDebugData *physicsDebugData, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PHYSICS_DEBUG_DATA, (XAssetHeader)physicsDebugData, inuse);
}

/*
==============
Mark_PhysicsFXPipelineAsset
==============
*/
int Mark_PhysicsFXPipelineAsset(PhysicsFXPipeline *physicsFXPipeline, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PHYSICS_FX_PIPELINE, (XAssetHeader)physicsFXPipeline, inuse);
}

/*
==============
Mark_PhysicsFXShapeAsset
==============
*/
int Mark_PhysicsFXShapeAsset(PhysicsFXShape *physicsFXShape, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PHYSICS_FX_SHAPE, (XAssetHeader)physicsFXShape, inuse);
}

/*
==============
Mark_PhysicsLibraryAsset
==============
*/
int Mark_PhysicsLibraryAsset(PhysicsLibrary *physicsLibrary, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PHYSICSLIBRARY, (XAssetHeader)physicsLibrary, inuse);
}

/*
==============
Mark_PhysicsSFXEventAsset
==============
*/
int Mark_PhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)physicsSFXEventAsset, inuse);
}

/*
==============
Mark_PhysicsVFXEventAsset
==============
*/
int Mark_PhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)physicsVFXEventAsset, inuse);
}

/*
==============
Mark_PlayerAnimScriptAsset
==============
*/
int Mark_PlayerAnimScriptAsset(PlayerAnimScript *playerAnimScript, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_PLAYERANIM, (XAssetHeader)playerAnimScript, inuse);
}

/*
==============
Mark_RawFileAsset
==============
*/
int Mark_RawFileAsset(RawFile *rawfile, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_RAWFILE, (XAssetHeader)rawfile, inuse);
}

/*
==============
Mark_ReticleDefAsset
==============
*/
int Mark_ReticleDefAsset(ReticleDef *reticleDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_RETICLE, (XAssetHeader)reticleDef, inuse);
}

/*
==============
Mark_RumbleGraphAsset
==============
*/
int Mark_RumbleGraphAsset(RumbleGraph *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_RUMBLE_GRAPH, (XAssetHeader)info, inuse);
}

/*
==============
Mark_RumbleInfoAsset
==============
*/
int Mark_RumbleInfoAsset(RumbleInfo *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_RUMBLE, (XAssetHeader)info, inuse);
}

/*
==============
Mark_ScriptBundleAsset
==============
*/
int Mark_ScriptBundleAsset(ScriptBundle *scriptBundle, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SCRIPTBUNDLE, (XAssetHeader)scriptBundle, inuse);
}

/*
==============
Mark_ScriptDebugData
==============
*/
int Mark_ScriptDebugData(ScriptDebugData *scriptDebugData, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SCRIPT_DEBUG_DATA, (XAssetHeader)scriptDebugData, inuse);
}

/*
==============
Mark_ScriptFileAsset
==============
*/
int Mark_ScriptFileAsset(ScriptFile *scriptfile, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SCRIPTFILE, (XAssetHeader)scriptfile, inuse);
}

/*
==============
Mark_ScriptableDefAsset
==============
*/
int Mark_ScriptableDefAsset(ScriptableDef *scriptable, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SCRIPTABLE, (XAssetHeader)scriptable, inuse);
}

/*
==============
Mark_SndBankResidentAsset
==============
*/
int Mark_SndBankResidentAsset(SndBankResident *sndBank, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SOUND_BANK, (XAssetHeader)sndBank, inuse);
}

/*
==============
Mark_SndBankTransientAsset
==============
*/
int Mark_SndBankTransientAsset(SndBankTransient *sndBank, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SOUND_BANK_TRANSIENT, (XAssetHeader)sndBank, inuse);
}

/*
==============
Mark_SndGlobalsAsset
==============
*/
int Mark_SndGlobalsAsset(SndGlobals *soundGlobals, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SOUND_GLOBALS, (XAssetHeader)soundGlobals, inuse);
}

/*
==============
Mark_SoundBankListDefAsset
==============
*/
int Mark_SoundBankListDefAsset(SoundBankListDef *soundBankListDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SOUNDBANKLIST, (XAssetHeader)soundBankListDef, inuse);
}

/*
==============
Mark_SpaceshipTargetDefAsset
==============
*/
int Mark_SpaceshipTargetDefAsset(SpaceshipTargetDef *spaceshipTargetDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SPACESHIPTARGET, (XAssetHeader)spaceshipTargetDef, inuse);
}

/*
==============
Mark_StTerrainAsset
==============
*/
int Mark_StTerrainAsset(StTerrain *terrain, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SUPER_TERRAIN, (XAssetHeader)terrain, inuse);
}

/*
==============
Mark_StreamKeyAsset
==============
*/
int Mark_StreamKeyAsset(StreamKey *key, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_STREAM_KEY, (XAssetHeader)key, inuse);
}

/*
==============
Mark_StreamTreeOverrideAsset
==============
*/
int Mark_StreamTreeOverrideAsset(StreamTreeOverride *treeOverride, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_STREAM_TREE_OVERRIDE, (XAssetHeader)treeOverride, inuse);
}

/*
==============
Mark_StreamingInfoAsset
==============
*/
int Mark_StreamingInfoAsset(StreamingInfo *streamingInfo, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_STREAMING_INFO, (XAssetHeader)streamingInfo, inuse);
}

/*
==============
Mark_StringTableAsset
==============
*/
int Mark_StringTableAsset(StringTable *stringTable, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_STRINGTABLE, (XAssetHeader)stringTable, inuse);
}

/*
==============
Mark_SuitAnimPackageAsset
==============
*/
int Mark_SuitAnimPackageAsset(SuitAnimPackage *suitAnimPackage, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SUITANIMPACKAGE, (XAssetHeader)suitAnimPackage, inuse);
}

/*
==============
Mark_SuitDefAsset
==============
*/
int Mark_SuitDefAsset(SuitDef *suitDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SUIT, (XAssetHeader)suitDef, inuse);
}

/*
==============
Mark_SurfaceFxTableAsset
==============
*/
int Mark_SurfaceFxTableAsset(SurfaceFxTable *surfaceFx, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SURFACE_FX, (XAssetHeader)surfaceFx, inuse);
}

/*
==============
Mark_TTFAsset
==============
*/
int Mark_TTFAsset(TTFDef *ttf, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_TTF, (XAssetHeader)ttf, inuse);
}

/*
==============
Mark_TacticalGraphDataAsset
==============
*/
int Mark_TacticalGraphDataAsset(TacticalGraphData *tacGraph, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_TACGRAPH, (XAssetHeader)tacGraph, inuse);
}

/*
==============
Mark_TracerDefAsset
==============
*/
int Mark_TracerDefAsset(TracerDef *tracerDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_TRACER, (XAssetHeader)tracerDef, inuse);
}

/*
==============
Mark_VectorFieldAsset
==============
*/
int Mark_VectorFieldAsset(VectorField *vectorField, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_VECTORFIELD, (XAssetHeader)vectorField, inuse);
}

/*
==============
Mark_VehicleDefAsset
==============
*/
int Mark_VehicleDefAsset(VehicleDef *vehDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_VEHICLE, (XAssetHeader)vehDef, inuse);
}

/*
==============
Mark_VirtualLeaderboardDefAsset
==============
*/
int Mark_VirtualLeaderboardDefAsset(VirtualLeaderboardDef *vlbDef, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_VIRTUAL_LEADERBOARD, (XAssetHeader)vlbDef, inuse);
}

/*
==============
Mark_WeaponAnimPackageAsset
==============
*/
int Mark_WeaponAnimPackageAsset(WeaponAnimPackage *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ANIM_PACKAGE, (XAssetHeader)info, inuse);
}

/*
==============
Mark_WeaponAttachmentAsset
==============
*/
int Mark_WeaponAttachmentAsset(WeaponAttachment *attachment, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_ATTACHMENT, (XAssetHeader)attachment, inuse);
}

/*
==============
Mark_WeaponCompleteDefAsset
==============
*/
int Mark_WeaponCompleteDefAsset(WeaponCompleteDef *weapon, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_WEAPON, (XAssetHeader)weapon, inuse);
}

/*
==============
Mark_WeaponSFXPackageAsset
==============
*/
int Mark_WeaponSFXPackageAsset(WeaponSFXPackage *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_SFX_PACKAGE, (XAssetHeader)info, inuse);
}

/*
==============
Mark_WeaponVFXPackageAsset
==============
*/
int Mark_WeaponVFXPackageAsset(WeaponVFXPackage *info, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_VFX_PACKAGE, (XAssetHeader)info, inuse);
}

/*
==============
Mark_XAnimCurveAsset
==============
*/
int Mark_XAnimCurveAsset(XAnimCurve *curve, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XANIMCURVE, (XAssetHeader)curve, inuse);
}

/*
==============
Mark_XAnimDynamicBonesAsset
==============
*/
int Mark_XAnimDynamicBonesAsset(XAnimDynamicBones *dynamicBones, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XANIM_DYNAMICBONES, (XAssetHeader)dynamicBones, inuse);
}

/*
==============
Mark_XAnimPartsAsset
==============
*/
int Mark_XAnimPartsAsset(XAnimParts *parts, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XANIMPARTS, (XAssetHeader)parts, inuse);
}

/*
==============
Mark_XAnimProceduralBonesAsset
==============
*/
int Mark_XAnimProceduralBonesAsset(XAnimProceduralBones *proceduralBones, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XANIM_PROCEDURALBONES, (XAssetHeader)proceduralBones, inuse);
}

/*
==============
Mark_XCamAsset
==============
*/
int Mark_XCamAsset(XCam *xcam, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XCAM, (XAssetHeader)xcam, inuse);
}

/*
==============
Mark_XCompositeModelDefAsset
==============
*/
int Mark_XCompositeModelDefAsset(XCompositeModelDef *compositeModel, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XCOMPOSITEMODEL, (XAssetHeader)compositeModel, inuse);
}

/*
==============
Mark_XModelAsset
==============
*/
int Mark_XModelAsset(XModel *model, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XMODEL, (XAssetHeader)model, inuse);
}

/*
==============
Mark_XModelDetailCollisionAsset
==============
*/
int Mark_XModelDetailCollisionAsset(XModelDetailCollision *detailCollision, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XMODEL_DETAIL_COLLISION, (XAssetHeader)detailCollision, inuse);
}

/*
==============
Mark_XModelSurfsAsset
==============
*/
int Mark_XModelSurfsAsset(XModelSurfs *modelSurfs, int inuse)
{
  return DB_MarkXAsset(ASSET_TYPE_XMODEL_SURFS, (XAssetHeader)modelSurfs, inuse);
}

/*
==============
Postload_SndBankResidentAsset
==============
*/
void Postload_SndBankResidentAsset(SndBankResident **sndBank)
{
  if ( !sndBank && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3744, ASSERT_TYPE_ASSERT, "(sndBank)", (const char *)&queryFormat, "sndBank") )
    __debugbreak();
  if ( !*sndBank && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3745, ASSERT_TYPE_ASSERT, "(*sndBank)", (const char *)&queryFormat, "*sndBank") )
    __debugbreak();
  SND_AddBank(&(*sndBank)->bank, 0);
}

/*
==============
Postload_SndBankTransientAsset
==============
*/
void Postload_SndBankTransientAsset(SndBankTransient **sndBank)
{
  if ( !sndBank && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 3824, ASSERT_TYPE_ASSERT, "(sndBank)", (const char *)&queryFormat, "sndBank") )
    __debugbreak();
  if ( *sndBank )
    SND_AddBank(&(*sndBank)->bank, 0);
}

/*
==============
Postload_StreamingInfoAsset
==============
*/
void Postload_StreamingInfoAsset(StreamingInfo **streamingInfoPtr, DBTransientsRegisterStage a2)
{
  if ( !streamingInfoPtr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4114, ASSERT_TYPE_ASSERT, "(streamingInfoPtr)", (const char *)&queryFormat, "streamingInfoPtr") )
    __debugbreak();
  if ( !*streamingInfoPtr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_assethandlers.cpp", 4115, ASSERT_TYPE_ASSERT, "(*streamingInfoPtr)", (const char *)&queryFormat, "*streamingInfoPtr") )
    __debugbreak();
  LOBYTE(a2) = 2;
  DB_StreamingInfo_Register(*streamingInfoPtr, a2);
}

