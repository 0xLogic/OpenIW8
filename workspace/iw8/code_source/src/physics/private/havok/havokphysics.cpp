/*
==============
HavokPhysics_GetRigidBodyMaxAngSpeed
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMaxAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxAngSpeed)
{
  ?HavokPhysics_GetRigidBodyMaxAngSpeed@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAM@Z(worldId, bodyId, maxAngSpeed);
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool excludeDoNotUse)
{
  ?HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets@@YAXPEBUScreenPlacement@@PEAM1MM_N@Z(scrPlace, x, y, tabWidth, charHeight, excludeDoNotUse);
}

/*
==============
HavokPhysics_DrawDebugWorldCPU
==============
*/

void __fastcall HavokPhysics_DrawDebugWorldCPU(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugWorldCPU@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyBounds
==============
*/

void __fastcall HavokPhysics_GetPhysicsAssetBodyBounds(const PhysicsAsset *physicsAsset, int bodyIdx, hkTransformf *transform, hkAabb *aabb)
{
  ?HavokPhysics_GetPhysicsAssetBodyBounds@@YAXPEBUPhysicsAsset@@HAEAVhkTransformf@@AEAVhkAabb@@@Z(physicsAsset, bodyIdx, transform, aabb);
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreBody
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::AddIgnoreBody(HavokPhysics_IgnoreBodies *this, unsigned int bodyId)
{
  ?AddIgnoreBody@HavokPhysics_IgnoreBodies@@QEAAXI@Z(this, bodyId);
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreEntity
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::AddIgnoreEntity(HavokPhysics_IgnoreBodies *this, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  ?AddIgnoreEntity@HavokPhysics_IgnoreBodies@@QEAAXH_N0000@Z(this, svEntNum, self, children, parent, siblings, linked);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_LoosenConstraint
==============
*/

bool __fastcall HavokPhysics_LoosenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *result)
{
  return ?HavokPhysics_LoosenConstraint@@YA_NW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@PEAUPhysicsConstraintLooseningResult@@@Z(worldId, constraintId, result);
}

/*
==============
HavokPhysics_Shapecast
==============
*/

void __fastcall HavokPhysics_Shapecast(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?HavokPhysics_Shapecast@@YAXW4Physics_WorldId@@IPEAIPEAVhknpShape@@AEBVhkVector4f@@3AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@6@Z(worldId, numBodies, bodyIds, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
HavokPhysics_CopyXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_CopyXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?HavokPhysics_CopyXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
HavokPhysics_AreDetailModelsInterchangeable
==============
*/

bool __fastcall HavokPhysics_AreDetailModelsInterchangeable(const XModel *const detailModelA, const XModel *const detailModelB)
{
  return ?HavokPhysics_AreDetailModelsInterchangeable@@YA_NQEBUXModel@@0@Z(detailModelA, detailModelB);
}

/*
==============
HavokPhysics_InstantiateAssetBodySphere
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetBodySphere(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAssetBodySphere@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBVhkVector4f@@AEBVhkQuaternionf@@_N44MW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientation, add, tryStartDeactivated, neverDeactivate, radius, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_GetNumContentsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumContentsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumContentsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::Reset
==============
*/

void __fastcall HavokPhysics_BroadphaseCollisionQueryResult::Reset(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  ?Reset@HavokPhysics_BroadphaseCollisionQueryResult@@QEAAXXZ(this);
}

/*
==============
HavokPhysics_AABBBroadphaseQuery
==============
*/

void __fastcall HavokPhysics_AABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  ?HavokPhysics_AABBBroadphaseQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBBroadphaseQueryExtendedData@@PEAVHavokPhysics_BroadphaseCollisionQueryResult@@@Z(worldId, aabb, extendedData, result);
}

/*
==============
HavokPhysics_AABBQuery
==============
*/

void __fastcall HavokPhysics_AABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_AABBQuery@@YAXW4Physics_WorldId@@UhknpBodyId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, aabb, extendedData, result);
}

/*
==============
HavokPhysics_DrawPhysicsXModels
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModels(Physics_DebugXModelSortType sortType, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsXModels@@YAXW4Physics_DebugXModelSortType@@PEBUScreenPlacement@@PEAM2MM@Z(sortType, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddDebugLine
==============
*/

void __fastcall HavokPhysics_AddDebugLine(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, const unsigned int *color)
{
  ?HavokPhysics_AddDebugLine@@YAXW4Physics_WorldId@@AEBVhkVector4f@@1AEBI@Z(worldId, start, end, color);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHit
==============
*/

const hknpCollisionResult *__fastcall HavokPhysics_CollisionQueryResult::GetHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetHit@HavokPhysics_CollisionQueryResult@@QEBAAEBUhknpCollisionResult@@H@Z(this, hitId);
}

/*
==============
HavokPhysics_AddXModelAsset
==============
*/

void __fastcall HavokPhysics_AddXModelAsset(XModel *xmodel)
{
  ?HavokPhysics_AddXModelAsset@@YAXPEAUXModel@@@Z(xmodel);
}

/*
==============
HavokPhysics_GetInstanceDetailModel
==============
*/

const XModel *__fastcall HavokPhysics_GetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_GetInstanceDetailModel@@YAPEBUXModel@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsVFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsVFXEventAssets@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_StartDrawDebugWorld
==============
*/

void __fastcall HavokPhysics_StartDrawDebugWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_StartDrawDebugWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>
==============
*/

hknpShape *__fastcall HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoadWithGlobalTypeCompendium@VhknpShape@@@@YAPEAVhknpShape@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetRaycastHitPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_IsWorldMultithreaded
==============
*/

bool __fastcall HavokPhysics_IsWorldMultithreaded(Physics_WorldId worldId)
{
  return ?HavokPhysics_IsWorldMultithreaded@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_SetRigidBodyDynamic
==============
*/

void __fastcall HavokPhysics_SetRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_SetRigidBodyDynamic@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CalculateMassProperties
==============
*/

void __fastcall HavokPhysics_CalculateMassProperties(hknpShape *shape, float mass, hkMassProperties *massProperties)
{
  ?HavokPhysics_CalculateMassProperties@@YAXPEAVhknpShape@@MPEAUhkMassProperties@@@Z(shape, mass, massProperties);
}

/*
==============
HavokPhysics_IsChildOfShape
==============
*/

bool __fastcall HavokPhysics_IsChildOfShape(const hknpShape *possibleParent, const hknpShape *possibleChild)
{
  return ?HavokPhysics_IsChildOfShape@@YA_NPEBVhknpShape@@0@Z(possibleParent, possibleChild);
}

/*
==============
HavokPhysics_ReleasePhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  ?HavokPhysics_ReleasePhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@@Z(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_Shapecast
==============
*/

void __fastcall HavokPhysics_Shapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?HavokPhysics_Shapecast@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@3AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@6@Z(worldId, bodyId, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
HavokPhysics_GetRigidBodyName
==============
*/

const char *__fastcall HavokPhysics_GetRigidBodyName(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_GetRigidBodyName@@YAPEBDW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_AABBQuery
==============
*/

void __fastcall HavokPhysics_AABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_AABBQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, aabb, extendedData, result);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHits
==============
*/

const hknpCollisionResult *__fastcall HavokPhysics_CollisionQueryResult::GetHits(HavokPhysics_CollisionQueryResult *this)
{
  return ?GetHits@HavokPhysics_CollisionQueryResult@@QEBAPEBUhknpCollisionResult@@XZ(this);
}

/*
==============
HavokPhysics_InstantiateAsset
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateAsset(Physics_WorldId worldId, const XModel *xModel, const PhysicsAsset *physicsAsset, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool forceAddImmediate, bool tryStartDeactivated, Physics_InstantiateShapeOverride *shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAsset@@YAIW4Physics_WorldId@@PEBUXModel@@PEBUPhysicsAsset@@HAEBVhkVector4f@@AEBVhkQuaternionf@@_N55PEAUPhysics_InstantiateShapeOverride@@W4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@5@Z(worldId, xModel, physicsAsset, ref, position, orientation, add, forceAddImmediate, tryStartDeactivated, shapeOverride, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_WarpRigidBodyToRelative
==============
*/

void __fastcall HavokPhysics_WarpRigidBodyToRelative(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkStartPosition, const hkQuaternionf *hkStartOrientation, const hkVector4f *hkEndPosition, const hkQuaternionf *hkEndOrientation)
{
  ?HavokPhysics_WarpRigidBodyToRelative@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@23@Z(worldId, bodyId, hkStartPosition, hkStartOrientation, hkEndPosition, hkEndOrientation);
}

/*
==============
HavokPhysics_Shutdown
==============
*/

void HavokPhysics_Shutdown(void)
{
  ?HavokPhysics_Shutdown@@YAXXZ();
}

/*
==============
HavokPhysics_MovePhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_MovePhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?HavokPhysics_MovePhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_RemoveShapeList
==============
*/

void __fastcall HavokPhysics_RemoveShapeList(char *rawShapeData, unsigned int rawShapeDataSize)
{
  ?HavokPhysics_RemoveShapeList@@YAXPEADI@Z(rawShapeData, rawShapeDataSize);
}

/*
==============
HavokPhysics_CreateShapeConvexHullFromAABB
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeConvexHullFromAABB(const hkVector4f *mins, const hkVector4f *maxs)
{
  return ?HavokPhysics_CreateShapeConvexHullFromAABB@@YAPEAVhknpShape@@AEBVhkVector4f@@0@Z(mins, maxs);
}

/*
==============
HavokPhysics_FreeBroadphaseCollisionQueryResult
==============
*/

void __fastcall HavokPhysics_FreeBroadphaseCollisionQueryResult(HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  ?HavokPhysics_FreeBroadphaseCollisionQueryResult@@YAXPEAVHavokPhysics_BroadphaseCollisionQueryResult@@@Z(result);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyCount
==============
*/

int __fastcall HavokPhysics_GetPhysicsAssetBodyCount(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetPhysicsAssetBodyCount@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_DrawDebugShapecast
==============
*/

void __fastcall HavokPhysics_DrawDebugShapecast(Physics_WorldId worldId, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugShapecast@@YAXW4Physics_WorldId@@IPEBUScreenPlacement@@PEAM2MM@Z(worldId, collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_MoveXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_MoveXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?HavokPhysics_MoveXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_SwapPhysicsAsset
==============
*/

void __fastcall HavokPhysics_SwapPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?HavokPhysics_SwapPhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_BatchRaycast
==============
*/

void __fastcall HavokPhysics_BatchRaycast(Physics_WorldId worldId, unsigned int numRays, const hkVector4f *starts, const hkVector4f *ends, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult **results)
{
  ?HavokPhysics_BatchRaycast@@YAXW4Physics_WorldId@@IPEBVhkVector4f@@1PEAUPhysics_RaycastExtendedData@@PEAPEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, numRays, starts, ends, extendedData, results);
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTag
==============
*/

unsigned __int16 __fastcall HavokPhysics_GetDetailCollisionShapeTag(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return ?HavokPhysics_GetDetailCollisionShapeTag@@YAGPEBUXModelDetailCollision@@H@Z(detailCollision, shapeIdx);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::cannotAllocate
==============
*/

void __fastcall HavokPhysicsLBALimitedMemoryListener::cannotAllocate(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  ?cannotAllocate@HavokPhysicsLBALimitedMemoryListener@@EEAAX_K@Z(this, size);
}

/*
==============
HavokPhysics_GetRigidBodyContents
==============
*/

int __fastcall HavokPhysics_GetRigidBodyContents(const Physics_WorldId worldId, const hknpBodyId bodyId)
{
  return ?HavokPhysics_GetRigidBodyContents@@YAHW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CreateShapeConvexHull
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeConvexHull(hkArray<hkVector4f,hkContainerHeapAllocator> *verts, unsigned int maxNumGeneratedVertices, bool useCache)
{
  return ?HavokPhysics_CreateShapeConvexHull@@YAPEAVhknpShape@@AEAV?$hkArray@VhkVector4f@@UhkContainerHeapAllocator@@@@I_N@Z(verts, maxNumGeneratedVertices, useCache);
}

/*
==============
HavokPhysics_GetThreadId
==============
*/

unsigned int __fastcall HavokPhysics_GetThreadId()
{
  return ?HavokPhysics_GetThreadId@@YAIXZ();
}

/*
==============
HavokPhysics_GetNumTriCountsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumTriCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumTriCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_Shapecast
==============
*/

void __fastcall HavokPhysics_Shapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  ?HavokPhysics_Shapecast@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@2AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@5@Z(worldId, shape, start, end, rotation, extendedData, result, startResult);
}

/*
==============
HavokPhysics_ProcessDeferredKeyframe
==============
*/

void __fastcall HavokPhysics_ProcessDeferredKeyframe(const Physics_WorldId worldId, const float velocityScale)
{
  ?HavokPhysics_ProcessDeferredKeyframe@@YAXW4Physics_WorldId@@M@Z(worldId, velocityScale);
}

/*
==============
HavokPhysics_IsInstanceInUse
==============
*/

bool __fastcall HavokPhysics_IsInstanceInUse(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_IsInstanceInUse@@YA_NW4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits
==============
*/

unsigned int __fastcall HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  return ?GetNumHits@HavokPhysics_BroadphaseCollisionQueryResult@@QEBAIXZ(this);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetShapecastHitQueryContactNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_AddInstanceToWorld
==============
*/

void __fastcall HavokPhysics_AddInstanceToWorld(Physics_WorldId worldId, unsigned int instanceId, bool immediate, bool tryStartDeactivated)
{
  ?HavokPhysics_AddInstanceToWorld@@YAXW4Physics_WorldId@@I_N1@Z(worldId, instanceId, immediate, tryStartDeactivated);
}

/*
==============
HavokPhysics_DrawDebugGeneralCPU
==============
*/

void __fastcall HavokPhysics_DrawDebugGeneralCPU(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugGeneralCPU@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_LockWorld
==============
*/

void __fastcall HavokPhysics_LockWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_LockWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AntilagRestoreInstanceTo
==============
*/

void __fastcall HavokPhysics_AntilagRestoreInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation)
{
  ?HavokPhysics_AntilagRestoreInstanceTo@@YAXW4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@@Z(worldId, instanceId, hkPosition, hkOrientation);
}

/*
==============
HavokPhysics_IsShapeCacheDisabled
==============
*/

bool __fastcall HavokPhysics_IsShapeCacheDisabled(unsigned int threadId)
{
  return ?HavokPhysics_IsShapeCacheDisabled@@YA_NI@Z(threadId);
}

/*
==============
HavokPhysics_InstantiateAssetBody
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetBody(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, int shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAssetBody@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBVhkVector4f@@AEBVhkQuaternionf@@_N44HW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientation, add, tryStartDeactivated, neverDeactivate, shapeOverride, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_UnsubscribeFromEvent
==============
*/

void __fastcall HavokPhysics_UnsubscribeFromEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (__fastcall *function)(const hknpEventHandlerInput *, const hknpEvent *))
{
  ?HavokPhysics_UnsubscribeFromEvent@@YAXW4Physics_WorldId@@W4Enum@hknpEventType@@UhknpBodyId@@P6AXAEBUhknpEventHandlerInput@@AEBUhknpEvent@@@Z@Z(worldId, eventType, specificBodyId, function);
}

/*
==============
HavokPhysics_SetMassPropertiesInertiaTensor
==============
*/

void __fastcall HavokPhysics_SetMassPropertiesInertiaTensor(hkMassProperties *massProperties, hkVector4f *inertiaTensor)
{
  ?HavokPhysics_SetMassPropertiesInertiaTensor@@YAXPEAUhkMassProperties@@AEAVhkVector4f@@@Z(massProperties, inertiaTensor);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CopyPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_CopyPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?HavokPhysics_CopyPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitFraction
==============
*/

double __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  double result; 

  *(float *)&result = ?GetRaycastHitFraction@HavokPhysics_CollisionQueryResult@@QEBAMH@Z(this, hitId);
  return result;
}

/*
==============
HavokPhysics_ClearShapeCache
==============
*/

void HavokPhysics_ClearShapeCache(void)
{
  ?HavokPhysics_ClearShapeCache@@YAXXZ();
}

/*
==============
HavokPhysics_AllocateBroadphaseCollisionQueryResult
==============
*/

HavokPhysics_BroadphaseCollisionQueryResult *__fastcall HavokPhysics_AllocateBroadphaseCollisionQueryResult(Physics_WorldId worldId)
{
  return ?HavokPhysics_AllocateBroadphaseCollisionQueryResult@@YAPEAVHavokPhysics_BroadphaseCollisionQueryResult@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_RenderDebug
==============
*/

void __fastcall HavokPhysics_RenderDebug(GfxCmdBufContext *gfxContext, bool includeWorlds)
{
  ?HavokPhysics_RenderDebug@@YAXUGfxCmdBufContext@@_N@Z(gfxContext, includeWorlds);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetDetailCollisionShape
==============
*/

const hknpShape *__fastcall HavokPhysics_GetDetailCollisionShape(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return ?HavokPhysics_GetDetailCollisionShape@@YAPEBVhknpShape@@PEBUXModelDetailCollision@@H@Z(detailCollision, shapeIdx);
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTransform
==============
*/

void __fastcall HavokPhysics_GetDetailCollisionShapeTransform(const XModelDetailCollision *detailCollision, int shapeIdx, hkVector4f *shapePosition, hkQuaternionf *shapeOrientationAsQuat)
{
  ?HavokPhysics_GetDetailCollisionShapeTransform@@YAXPEBUXModelDetailCollision@@HAEAVhkVector4f@@AEAVhkQuaternionf@@@Z(detailCollision, shapeIdx, shapePosition, shapeOrientationAsQuat);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_TransientZoneLoaded
==============
*/

void __fastcall HavokPhysics_TransientZoneLoaded(unsigned int worldTransientIndex, bool fullLoad)
{
  ?HavokPhysics_TransientZoneLoaded@@YAXI_N@Z(worldTransientIndex, fullLoad);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualitys
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryBodyQualitys(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryBodyQualitys@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithColLods
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelsWithColLods(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool excludeDoNotUse)
{
  ?HavokPhysics_DrawPhysicsXModelsWithColLods@@YAXPEBUScreenPlacement@@PEAM1MM_N@Z(scrPlace, x, y, tabWidth, charHeight, excludeDoNotUse);
}

/*
==============
HavokPhysics_GetShapeConvexCountFromShapeList
==============
*/

int __fastcall HavokPhysics_GetShapeConvexCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeConvexCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_DebugSetVisualizeContents
==============
*/

void __fastcall HavokPhysics_DebugSetVisualizeContents(int visualizeContents)
{
  ?HavokPhysics_DebugSetVisualizeContents@@YAXH@Z(visualizeContents);
}

/*
==============
HavokPhysics_SetRigidBodyMass
==============
*/

void __fastcall HavokPhysics_SetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, float mass)
{
  ?HavokPhysics_SetRigidBodyMass@@YAXW4Physics_WorldId@@UhknpBodyId@@M@Z(worldId, bodyId, mass);
}

/*
==============
HavokPhysics_GetShapeTypeName
==============
*/

const char *__fastcall HavokPhysics_GetShapeTypeName(const hknpShape *shape)
{
  return ?HavokPhysics_GetShapeTypeName@@YAPEBDPEBVhknpShape@@@Z(shape);
}

/*
==============
HavokPhysics_StepWorldCollide
==============
*/

void __fastcall HavokPhysics_StepWorldCollide(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldCollide@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterials
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMaterials(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMaterials@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/

void __fastcall HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredShapecast@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@2AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, shape, start, end, rotation, extendedData, data);
}

/*
==============
HavokPhysics_IsPhysicsAssetBodyDynamic
==============
*/

bool __fastcall HavokPhysics_IsPhysicsAssetBodyDynamic(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_IsPhysicsAssetBodyDynamic@@YA_NPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastBackfaceHit@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_MyChangesSaveAndShutdown
==============
*/

void HavokPhysics_MyChangesSaveAndShutdown(void)
{
  ?HavokPhysics_MyChangesSaveAndShutdown@@YAXXZ();
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyTransform
==============
*/

void __fastcall HavokPhysics_GetPhysicsAssetBodyTransform(const PhysicsAsset *physicsAsset, int bodyIdx, hkVector4f *bodyPosition, hkQuaternionf *bodyOrientationAsQuat)
{
  ?HavokPhysics_GetPhysicsAssetBodyTransform@@YAXPEBUPhysicsAsset@@HAEAVhkVector4f@@AEAVhkQuaternionf@@@Z(physicsAsset, bodyIdx, bodyPosition, bodyOrientationAsQuat);
}

/*
==============
HavokPhysics_GetShapeNameFromShapeList
==============
*/

const char *__fastcall HavokPhysics_GetShapeNameFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeNameFromShapeList@@YAPEBDPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_UpdateGravityScalar
==============
*/

void __fastcall HavokPhysics_UpdateGravityScalar(Physics_WorldId worldId, Physics_GravityType gravityType, float scalar)
{
  ?HavokPhysics_UpdateGravityScalar@@YAXW4Physics_WorldId@@W4Physics_GravityType@@M@Z(worldId, gravityType, scalar);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetShapecastHitContactPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_UpdateLoosenedConstraint
==============
*/

bool __fastcall HavokPhysics_UpdateLoosenedConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  return ?HavokPhysics_UpdateLoosenedConstraint@@YA_NW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@AEBVhkTransformf@@2PEAUPhysicsConstraintLooseningResult@@@Z(worldId, constraintId, bodyATransform, bodyBTransform, result);
}

/*
==============
HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats
==============
*/

void __fastcall HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  ??0HavokPhysics_CylinderShapeStats@@QEAA@XZ(this);
}

/*
==============
HavokPhysics_DrawPhysicsAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsAssets(bool sortByName, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsAssets@@YAX_NPEBUScreenPlacement@@PEAM2MM@Z(sortByName, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_ClearAntilagFlags
==============
*/

void __fastcall HavokPhysics_ClearAntilagFlags(Physics_WorldId worldId)
{
  ?HavokPhysics_ClearAntilagFlags@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_GetLandscapeShapeHelper
==============
*/

void __fastcall HavokPhysics_GetLandscapeShapeHelper(const hknpShape **shape, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> *meshShapeKey, int *shapeKeyPathSizeOut, hknpShapeCollector *shapeCollector)
{
  ?HavokPhysics_GetLandscapeShapeHelper@@YAXAEAPEBVhknpShape@@AEAU?$hkHandle@I$0PPPPPPPP@UhknpShapeKeyDiscriminant@@@@AEAHAEAUhknpShapeCollector@@@Z(shape, meshShapeKey, shapeKeyPathSizeOut, shapeCollector);
}

/*
==============
HavokPhysics_GetRef
==============
*/

int __fastcall HavokPhysics_GetRef(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_GetRef@@YAHW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_ReleasePhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  ?HavokPhysics_ReleasePhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@@Z(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_Raycast
==============
*/

void __fastcall HavokPhysics_Raycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_Raycast@@YAXW4Physics_WorldId@@AEBVhkVector4f@@1PEAUPhysics_RaycastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, start, end, extendedData, result);
}

/*
==============
HavokPhysics_DisableShapeCache
==============
*/

void __fastcall HavokPhysics_DisableShapeCache(unsigned int threadId, bool disable)
{
  ?HavokPhysics_DisableShapeCache@@YAXI_N@Z(threadId, disable);
}

/*
==============
HavokPhysics_Raycast
==============
*/

void __fastcall HavokPhysics_Raycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_Raycast@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2PEAUPhysics_RaycastExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, start, end, extendedData, result);
}

/*
==============
HavokPhysics_AddPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  ?HavokPhysics_AddPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@@Z(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_GetNumConvexCountsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumConvexCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumConvexCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_AddDetailCollisionShapesToInstanceList
==============
*/

unsigned int __fastcall HavokPhysics_AddDetailCollisionShapesToInstanceList(const XModelDetailCollision *detailCollision, const hkVector4f *origin, const float scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?HavokPhysics_AddDetailCollisionShapesToInstanceList@@YAIPEBUXModelDetailCollision@@AEBVhkVector4f@@MAEBVhkQuaternionf@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(detailCollision, origin, scale, orientation, instanceArray);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/

void __fastcall HavokPhysics_DeferredRaycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredRaycast@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2PEAUPhysics_RaycastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, start, end, extendedData, data);
}

/*
==============
HavokPhysics_WarpLeafDetailRigidBodyTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_WarpLeafDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase, bool activate)
{
  return ?HavokPhysics_WarpLeafDetailRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@_N4@Z(worldId, bodyId, hkPosition, hkOrientation, updateBroadphase, activate);
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMass
==============
*/

void __fastcall HavokPhysics_GetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMass)
{
  ?HavokPhysics_GetRigidBodyCenterOfMass@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkVector4f@@@Z(worldId, bodyId, centerOfMass);
}

/*
==============
HavokPhysics_DrawPhysicsContents
==============
*/

void __fastcall HavokPhysics_DrawPhysicsContents(unsigned int contents, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsContents@@YAXIPEBUScreenPlacement@@PEAM1MM@Z(contents, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_QueryPoint
==============
*/

void __fastcall HavokPhysics_QueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_QueryPoint@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, point, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_TransientZoneUnloading
==============
*/

void __fastcall HavokPhysics_TransientZoneUnloading(unsigned int worldTransientIndex, bool fullUnload)
{
  ?HavokPhysics_TransientZoneUnloading@@YAXI_N@Z(worldTransientIndex, fullUnload);
}

/*
==============
HavokPhysics_InstantiateDetailModel
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateDetailModel(Physics_WorldId worldId, const XModel *detailModel, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly, bool allowSingleBodyAddToWorld)
{
  return ?HavokPhysics_InstantiateDetailModel@@YAIW4Physics_WorldId@@PEBUXModel@@HAEBVhkVector4f@@AEBVhkQuaternionf@@_N444@Z(worldId, detailModel, ref, position, orientation, add, tryStartDeactivated, forQueryOnly, allowSingleBodyAddToWorld);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawDebugWorld
==============
*/

void __fastcall HavokPhysics_DrawDebugWorld(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugWorld@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DestroyInstance
==============
*/

void __fastcall HavokPhysics_DestroyInstance(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  ?HavokPhysics_DestroyInstance@@YAXW4Physics_WorldId@@I_N@Z(worldId, instanceId, activate);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::HasHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::HasHit(HavokPhysics_CollisionQueryResult *this)
{
  return ?HasHit@HavokPhysics_CollisionQueryResult@@QEBA_NXZ(this);
}

/*
==============
HavokPhysics_GetShapeOverrideContents
==============
*/

int __fastcall HavokPhysics_GetShapeOverrideContents(int shapeOverride)
{
  return ?HavokPhysics_GetShapeOverrideContents@@YAHH@Z(shapeOverride);
}

/*
==============
HavokPhysics_IsRigidBodyDynamic
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyDynamic@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_InplaceLoad<hknpShape>
==============
*/

hknpShape *__fastcall HavokPhysics_InplaceLoad<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VhknpShape@@@@YAPEAVhknpShape@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsSFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsSFXEventAssetId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_AddXModelDetailCollisionAsset(XModelDetailCollision *detailCollision)
{
  ?HavokPhysics_AddXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
HavokPhysics_DrawDebugGeneralMemory
==============
*/

void __fastcall HavokPhysics_DrawDebugGeneralMemory(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugGeneralMemory@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddPhysicsLibrary
==============
*/

void __fastcall HavokPhysics_AddPhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  ?HavokPhysics_AddPhysicsLibrary@@YAXPEAUPhysicsLibrary@@@Z(physicsLibrary);
}

/*
==============
HavokPhysics_GetAssetByName
==============
*/

const PhysicsAsset *__fastcall HavokPhysics_GetAssetByName(const char *name)
{
  return ?HavokPhysics_GetAssetByName@@YAPEBUPhysicsAsset@@PEBD@Z(name);
}

/*
==============
HavokPhysics_IsInstanceDeactivated
==============
*/

bool __fastcall HavokPhysics_IsInstanceDeactivated(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_IsInstanceDeactivated@@YA_NW4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinAngSpeed
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMaxLinAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed, float *maxAngSpeed)
{
  ?HavokPhysics_GetRigidBodyMaxLinAngSpeed@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAM2@Z(worldId, bodyId, maxLinSpeed, maxAngSpeed);
}

/*
==============
HavokPhysics_IsRigidBodyStatic
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyStatic@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsShapeList>
==============
*/

HavokPhysicsShapeList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsShapeList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsShapeList@@@@YAPEAVHavokPhysicsShapeList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_StepWorldStart
==============
*/

void __fastcall HavokPhysics_StepWorldStart(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldStart@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_CreateShapeCylinder
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCylinder(const hkVector4f *center, float halfHeight, float radius, int numVertices, bool useCache)
{
  return ?HavokPhysics_CreateShapeCylinder@@YAPEAVhknpShape@@AEBVhkVector4f@@MMH_N@Z(center, halfHeight, radius, numVertices, useCache);
}

/*
==============
HavokPhysics_InstantiateAssetBodyCylinder
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetBodyCylinder(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, float height, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateAssetBodyCylinder@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HHAEBVhkVector4f@@AEBVhkQuaternionf@@_N44MMW4Physics_InstantiationForceType@@W4Physics_InstantiationFilterType@@4@Z(instanceId, worldId, physicsAsset, bodyIdx, ref, position, orientation, add, tryStartDeactivated, neverDeactivate, radius, height, forceType, filterType, forQueryOnly);
}

/*
==============
HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly(HavokPhysics_IgnoreBodies *this, bool simulationBodiesOnly)
{
  ?SetSimulationBodiesOnly@HavokPhysics_IgnoreBodies@@QEAAX_N@Z(this, simulationBodiesOnly);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetClosestPointHitHitPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_InstantiateKeyframedBody
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateKeyframedBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateKeyframedBody@@YAIW4Physics_WorldId@@PEBVhknpShape@@HPEBD2HAEBVhkVector4f@@AEBVhkQuaternionf@@_N55@Z(worldId, shape, ref, name, physicsMaterial, collisionFilterInfo, position, orientation, add, tryStartDeactivated, forQueryOnly);
}

/*
==============
HavokPhysics_UnlockAssetWrite
==============
*/

void HavokPhysics_UnlockAssetWrite(void)
{
  ?HavokPhysics_UnlockAssetWrite@@YAXXZ();
}

/*
==============
HavokPhysics_IsRigidBodyActive
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyActive(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyActive@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_DrawWorld
==============
*/

void __fastcall HavokPhysics_DrawWorld(Physics_WorldId worldId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawWorld@@YAXW4Physics_WorldId@@_NPEBUScreenPlacement@@PEAM3MM@Z(worldId, fullDisplay, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_MovePhysicsAsset
==============
*/

void __fastcall HavokPhysics_MovePhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?HavokPhysics_MovePhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_KeyframeInstanceTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_KeyframeInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?HavokPhysics_KeyframeInstanceTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@M_N3M@Z(worldId, instanceId, hkPosition, hkOrientation, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetRaycastHitNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_SetMassPropertiesCenterOfMass
==============
*/

void __fastcall HavokPhysics_SetMassPropertiesCenterOfMass(hkMassProperties *massProperties, hkVector4f *centerOfMass)
{
  ?HavokPhysics_SetMassPropertiesCenterOfMass@@YAXPEAUhkMassProperties@@AEAVhkVector4f@@@Z(massProperties, centerOfMass);
}

/*
==============
HavokPhysics_AllocateCollisionQueryResult
==============
*/

HavokPhysics_CollisionQueryResult *__fastcall HavokPhysics_AllocateCollisionQueryResult(Physics_WorldId worldId, Physics_CollisionQueryCollectionType type)
{
  return ?HavokPhysics_AllocateCollisionQueryResult@@YAPEAVHavokPhysics_CollisionQueryResult@@W4Physics_WorldId@@W4Physics_CollisionQueryCollectionType@@@Z(worldId, type);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/

void __fastcall HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredAABBQuery@@YAXW4Physics_WorldId@@UhknpBodyId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, aabb, extendedData, data);
}

/*
==============
HavokPhysics_ApplyImpulse
==============
*/

void __fastcall HavokPhysics_ApplyImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  ?HavokPhysics_ApplyImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2M@Z(worldId, bodyId, hkPosition, hkDirection, magnitude);
}

/*
==============
HavokPhysics_TakeSnapshot
==============
*/

void __fastcall HavokPhysics_TakeSnapshot(Physics_WorldId worldId, const char *filename, bool humanReadable)
{
  ?HavokPhysics_TakeSnapshot@@YAXW4Physics_WorldId@@PEBD_N@Z(worldId, filename, humanReadable);
}

/*
==============
HavokPhysics_AddClipMap
==============
*/

void __fastcall HavokPhysics_AddClipMap(clipMap_t *clipMap)
{
  ?HavokPhysics_AddClipMap@@YAXPEAUclipMap_t@@@Z(clipMap);
}

/*
==============
HavokPhysics_DecodeSubShapeKey
==============
*/

void __fastcall HavokPhysics_DecodeSubShapeKey(Physics_WorldId worldId, unsigned int instanceId, unsigned __int64 key, int *bodyIdx, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> *shapeInstanceId)
{
  ?HavokPhysics_DecodeSubShapeKey@@YAXW4Physics_WorldId@@I_KPEAHAEAU?$hkHandle@G$0PPPP@UhknpShapeInstanceIdDiscriminant@@@@@Z(worldId, instanceId, key, bodyIdx, shapeInstanceId);
}

/*
==============
HavokPhysics_DebugSetVisualizeQuery
==============
*/

void __fastcall HavokPhysics_DebugSetVisualizeQuery(bool showQueryBodies)
{
  ?HavokPhysics_DebugSetVisualizeQuery@@YAX_N@Z(showQueryBodies);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetDetailHitData
==============
*/

const Physics_DetailHitData *__fastcall HavokPhysics_GetDetailHitData(const HavokPhysics_CollisionQueryResult *result, int modifierIndex, int hitIndex)
{
  return ?HavokPhysics_GetDetailHitData@@YAPEBUPhysics_DetailHitData@@PEBVHavokPhysics_CollisionQueryResult@@HH@Z(result, modifierIndex, hitIndex);
}

/*
==============
HavokPhysics_GetInstantiatiationPenetrationDepthForAsset
==============
*/

double __fastcall HavokPhysics_GetInstantiatiationPenetrationDepthForAsset(Physics_WorldId worldId, const PhysicsAsset *physicsAsset, const hkVector4f *position, const hkQuaternionf *orientation, Physics_InstantiateShapeOverride *shapeOverride, int ignoreSystems)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetInstantiatiationPenetrationDepthForAsset@@YAMW4Physics_WorldId@@PEBUPhysicsAsset@@AEBVhkVector4f@@AEBVhkQuaternionf@@PEAUPhysics_InstantiateShapeOverride@@H@Z(worldId, physicsAsset, position, orientation, shapeOverride, ignoreSystems);
  return result;
}

/*
==============
HavokPhysics_Init
==============
*/

void __fastcall HavokPhysics_Init(char *generalMemoryBuffer, int generalMemoryBufferSize, int generalMemoryBufferWarningThreshold, char *debugMemoryBuffer, int debugMemoryBufferSize)
{
  ?HavokPhysics_Init@@YAXPEADHH0H@Z(generalMemoryBuffer, generalMemoryBufferSize, generalMemoryBufferWarningThreshold, debugMemoryBuffer, debugMemoryBufferSize);
}

/*
==============
HavokPhysics_CopyXModelAsset
==============
*/

void __fastcall HavokPhysics_CopyXModelAsset(XModel *from, XModel *to)
{
  ?HavokPhysics_CopyXModelAsset@@YAXPEAUXModel@@0@Z(from, to);
}

/*
==============
HavokPhysics_MoveXModelAsset
==============
*/

void __fastcall HavokPhysics_MoveXModelAsset(XModel *from, XModel *to)
{
  ?HavokPhysics_MoveXModelAsset@@YAXPEAUXModel@@0@Z(from, to);
}

/*
==============
HavokPhysics_DrawDebugQueryPoint
==============
*/

void __fastcall HavokPhysics_DrawDebugQueryPoint(Physics_WorldId worldId, const hkVector4f *position, float maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugQueryPoint@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MIPEBUScreenPlacement@@PEAM3MM@Z(worldId, position, maxDistance, collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_LockAssetWrite
==============
*/

void HavokPhysics_LockAssetWrite(void)
{
  ?HavokPhysics_LockAssetWrite@@YAXXZ();
}

/*
==============
HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer
==============
*/

void __fastcall HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer(HavokPhysics_SimpleShapeBuffer *this)
{
  ??1HavokPhysics_SimpleShapeBuffer@@UEAA@XZ(this);
}

/*
==============
HavokPhysics_SnapshotFixup::Validate
==============
*/

void __fastcall HavokPhysics_SnapshotFixup::Validate(HavokPhysics_SnapshotFixup *this, HavokPhysicsWorld *world)
{
  ?Validate@HavokPhysics_SnapshotFixup@@QEAAXPEAUHavokPhysicsWorld@@@Z(this, world);
}

/*
==============
HavokPhysics_DrawDebugBadColLods
==============
*/

void __fastcall HavokPhysics_DrawDebugBadColLods(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugBadColLods@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
hkKeycodeManager::setKeycodes
==============
*/

hkResult __fastcall hkKeycodeManager::setKeycodes()
{
  return ?setKeycodes@hkKeycodeManager@@SA?AUhkResult@@XZ();
}

/*
==============
HavokPhysics_DrawDebugAABBWorldQuery
==============
*/

void __fastcall HavokPhysics_DrawDebugAABBWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugAABBWorldQuery@@YAXW4Physics_WorldId@@IVhkAabb@@PEBUScreenPlacement@@PEAM3MM@Z(worldId, collisionFilterInfo, aabb, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_SwapPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_SwapPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?HavokPhysics_SwapPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_MovePhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_MovePhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  ?HavokPhysics_MovePhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_AddPhysicsAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsAsset(PhysicsAsset *physicsAsset)
{
  ?HavokPhysics_AddPhysicsAsset@@YAXPEAUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQuerySurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetDebugWorldPersistantMemoryPeak
==============
*/

int __fastcall HavokPhysics_GetDebugWorldPersistantMemoryPeak(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetDebugWorldPersistantMemoryPeak@@YAHW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionProperties
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMotionProperties(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMotionProperties@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DrawDebugMutableShapesInWorld
==============
*/

void __fastcall HavokPhysics_DrawDebugMutableShapesInWorld(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, Physics_WorldId worldId, float detailRange)
{
  ?HavokPhysics_DrawDebugMutableShapesInWorld@@YAXPEBUScreenPlacement@@PEAM1MMW4Physics_WorldId@@M@Z(scrPlace, x, y, tabWidth, charHeight, worldId, detailRange);
}

/*
==============
HavokPhysics_DrawPhysicsXModelId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsXModelId(bool indexByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsXModelId@@YAX_NHPEBUScreenPlacement@@PEAM2MM@Z(indexByName, assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetWorldId
==============
*/

Physics_WorldId __fastcall HavokPhysics_GetWorldId(const hknpWorld *world)
{
  return ?HavokPhysics_GetWorldId@@YA?AW4Physics_WorldId@@PEBVhknpWorld@@@Z(world);
}

/*
==============
HavokPhysics_GetNumShapesInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumShapesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumShapesInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_Write
==============
*/

void __fastcall HavokPhysics_Write(MemoryFile *memFile)
{
  ?HavokPhysics_Write@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DeactivateBody
==============
*/

void __fastcall HavokPhysics_DeactivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_DeactivateBody@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_Load
==============
*/

void __fastcall HavokPhysics_Load(SaveGame *save)
{
  ?HavokPhysics_Load@@YAXPEAUSaveGame@@@Z(save);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_CalcShapeRadius
==============
*/

void __fastcall HavokPhysics_CalcShapeRadius(const hknpShape *shape, float *radiusOut)
{
  ?HavokPhysics_CalcShapeRadius@@YAXPEBVhknpShape@@AEAM@Z(shape, radiusOut);
}

/*
==============
HavokPhysics_StopDrawDebugWorld
==============
*/

void __fastcall HavokPhysics_StopDrawDebugWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_StopDrawDebugWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_GetRef
==============
*/

int __fastcall HavokPhysics_GetRef(const hknpBody *body)
{
  return ?HavokPhysics_GetRef@@YAHAEBVhknpBody@@@Z(body);
}

/*
==============
HavokPhysics_SetMapLocalAllocatorBuffer
==============
*/

void __fastcall HavokPhysics_SetMapLocalAllocatorBuffer(void *buffer, unsigned int size)
{
  ?HavokPhysics_SetMapLocalAllocatorBuffer@@YAXPEAXI@Z(buffer, size);
}

/*
==============
HavokPhysics_SwapPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_SwapPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?HavokPhysics_SwapPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/

void __fastcall HavokPhysics_DeferredRaycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredRaycast@@YAXW4Physics_WorldId@@AEBVhkVector4f@@1PEAUPhysics_RaycastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, start, end, extendedData, data);
}

/*
==============
HavokPhysics_RemoveModifier
==============
*/

void __fastcall HavokPhysics_RemoveModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  ?HavokPhysics_RemoveModifier@@YAXW4Physics_WorldId@@PEAVhknpModifier@@@Z(worldId, modifier);
}

/*
==============
HavokPhysics_GetInstanceXModel
==============
*/

const XModel *__fastcall HavokPhysics_GetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_GetInstanceXModel@@YAPEBUXModel@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_RemoveInstanceFromWorld
==============
*/

void __fastcall HavokPhysics_RemoveInstanceFromWorld(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  ?HavokPhysics_RemoveInstanceFromWorld@@YAXW4Physics_WorldId@@I_N@Z(worldId, instanceId, activate);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>
==============
*/

HavokPhysicsBodyQualityList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsBodyQualityList@@@@YAPEAVHavokPhysicsBodyQualityList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/

void __fastcall HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  ?HavokPhysics_ApplyAngularImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2M@Z(worldId, bodyId, hkPosition, hkDirection, magnitude);
}

/*
==============
HavokPhysics_StepWorldSolve
==============
*/

void __fastcall HavokPhysics_StepWorldSolve(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldSolve@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_SetRigidBodyStatic
==============
*/

void __fastcall HavokPhysics_SetRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_SetRigidBodyStatic@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_ReleaseShape
==============
*/

void __fastcall HavokPhysics_ReleaseShape(Physics_WorldId worldId, hknpShape *shape, bool finalReference)
{
  ?HavokPhysics_ReleaseShape@@YAXW4Physics_WorldId@@PEAVhknpShape@@_N@Z(worldId, shape, finalReference);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreBody
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIgnoreBody(HavokPhysics_IgnoreBodies *this, int index, unsigned int bodyId)
{
  ?SetIgnoreBody@HavokPhysics_IgnoreBodies@@QEAAXHI@Z(this, index, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQuerySurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsBody
==============
*/

void __fastcall HavokPhysics_DrawPhysicsBody(Physics_WorldId worldId, hknpBodyId bodyId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsBody@@YAXW4Physics_WorldId@@UhknpBodyId@@_NPEBUScreenPlacement@@PEAM4MM@Z(worldId, bodyId, fullDisplay, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetRigidBodyDynamicMass
==============
*/

void __fastcall HavokPhysics_GetRigidBodyDynamicMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  ?HavokPhysics_GetRigidBodyDynamicMass@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAM@Z(worldId, bodyId, mass);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetRigidBodyInverseInertiaLocal
==============
*/

void __fastcall HavokPhysics_GetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *invInertia)
{
  ?HavokPhysics_GetRigidBodyInverseInertiaLocal@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkVector4f@@@Z(worldId, bodyId, invInertia);
}

/*
==============
HavokPhysics_GetRigidBodyAABB
==============
*/

void __fastcall HavokPhysics_GetRigidBodyAABB(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb, bool worldSpace)
{
  ?HavokPhysics_GetRigidBodyAABB@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkAabb@@_N@Z(worldId, bodyId, aabb, worldSpace);
}

/*
==============
HavokPhysics_SetInstanceDetailModel
==============
*/

void __fastcall HavokPhysics_SetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  ?HavokPhysics_SetInstanceDetailModel@@YAXW4Physics_WorldId@@IPEBUXModel@@@Z(worldId, instanceId, xModel);
}

/*
==============
HavokPhysics_UnlockWorld
==============
*/

void __fastcall HavokPhysics_UnlockWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_UnlockWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_GetErrorString
==============
*/

const char *__fastcall HavokPhysics_GetErrorString()
{
  return ?HavokPhysics_GetErrorString@@YAPEBDXZ();
}

/*
==============
HavokPhysics_DecodeShapeKeyIntoShapes
==============
*/

unsigned int __fastcall HavokPhysics_DecodeShapeKeyIntoShapes(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> key, const hknpShape **shapes)
{
  return ?HavokPhysics_DecodeShapeKeyIntoShapes@@YAIW4Physics_WorldId@@UhknpBodyId@@U?$hkHandle@I$0PPPPPPPP@UhknpShapeKeyDiscriminant@@@@QEAPEBVhknpShape@@@Z(worldId, bodyId, key, shapes);
}

/*
==============
HavokPhysics_DrawDebugAABBBroadphaseWorldQuery
==============
*/

void __fastcall HavokPhysics_DrawDebugAABBBroadphaseWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugAABBBroadphaseWorldQuery@@YAXW4Physics_WorldId@@IVhkAabb@@PEBUScreenPlacement@@PEAM3MM@Z(worldId, collisionFilterInfo, aabb, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_CreateShapeCube
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCube(const hkVector4f *center, float halfSize)
{
  return ?HavokPhysics_CreateShapeCube@@YAPEAVhknpShape@@AEBVhkVector4f@@M@Z(center, halfSize);
}

/*
==============
HavokPhysics_GetConstraintBodyIds
==============
*/

void __fastcall HavokPhysics_GetConstraintBodyIds(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, hknpBodyId *bodyIdA, hknpBodyId *bodyIdB)
{
  ?HavokPhysics_GetConstraintBodyIds@@YAXW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@PEAUhknpBodyId@@2@Z(worldId, constraintId, bodyIdA, bodyIdB);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreEntity
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIgnoreEntity(HavokPhysics_IgnoreBodies *this, int index, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  ?SetIgnoreEntity@HavokPhysics_IgnoreBodies@@QEAAXHH_N0000@Z(this, index, svEntNum, self, children, parent, siblings, linked);
}

/*
==============
HavokPhysics_TightenConstraint
==============
*/

void __fastcall HavokPhysics_TightenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *values, float proportion)
{
  ?HavokPhysics_TightenConstraint@@YAXW4Physics_WorldId@@U?$hkHandle@I$0HPPPPPPP@UhknpConstraintIdDiscriminant@@@@PEAUPhysicsConstraintLooseningResult@@M@Z(worldId, constraintId, values, proportion);
}

/*
==============
HavokPhysics_StepWorldFX
==============
*/

void __fastcall HavokPhysics_StepWorldFX(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldFX@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_AddDeferredBulletEffectCallback
==============
*/

void __fastcall HavokPhysics_AddDeferredBulletEffectCallback(void (__fastcall *effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int), const Physics_WorldId worldId, hknpBodyId hitBodyId, unsigned int shapeKey, const vec3_t *start, const vec3_t *hitPos, const int hitSurfaceFlags, const vec3_t *hitNormal, const scr_string_t *partName, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, int mod)
{
  ?HavokPhysics_AddDeferredBulletEffectCallback@@YAXP6AXW4LocalClientNum_t@@IIAEBTvec3_t@@1H1PEBW4scr_string_t@@IAEBUWeapon@@_NH@ZW4Physics_WorldId@@UhknpBodyId@@I11H1AEBW43@I34H@Z(effectCallback, worldId, hitBodyId, shapeKey, start, hitPos, hitSurfaceFlags, hitNormal, partName, inflictorEntNum, weapon, isAlternate, mod);
}

/*
==============
HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(HavokPhysics_IgnoreBodies *this, int minEntities, int minBodies)
{
  ??0HavokPhysics_IgnoreBodies@@QEAA@HH@Z(this, minEntities, minBodies);
}

/*
==============
HavokPhysics_DrawPhysicsSurfaceFlags
==============
*/

void __fastcall HavokPhysics_DrawPhysicsSurfaceFlags(int surfFlags, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsSurfaceFlags@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(surfFlags, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_IgnoreBodies::Reset
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::Reset(HavokPhysics_IgnoreBodies *this)
{
  ?Reset@HavokPhysics_IgnoreBodies@@QEAAXXZ(this);
}

/*
==============
HavokPhysics_AddPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  ?HavokPhysics_AddPhysicsVFXEventAsset@@YAXPEAUPhysicsVFXEventAsset@@@Z(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_GetRigidBodyMass
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  ?HavokPhysics_GetRigidBodyMass@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAM@Z(worldId, bodyId, mass);
}

/*
==============
HavokPhysics_StepWorldPrep
==============
*/

void __fastcall HavokPhysics_StepWorldPrep(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  ?HavokPhysics_StepWorldPrep@@YAXW4Physics_WorldId@@HHM@Z(worldId, stepIndex, numStepsPlanned, stepTimeOverride);
}

/*
==============
HavokPhysics_AddModifier
==============
*/

void __fastcall HavokPhysics_AddModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  ?HavokPhysics_AddModifier@@YAXW4Physics_WorldId@@PEAVhknpModifier@@@Z(worldId, modifier);
}

/*
==============
HavokPhysics_SetRigidBodyContents
==============
*/

void __fastcall HavokPhysics_SetRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  ?HavokPhysics_SetRigidBodyContents@@YAXW4Physics_WorldId@@UhknpBodyId@@H_N@Z(worldId, bodyId, contents, forceCacheRebuild);
}

/*
==============
HavokPhysics_PreStepWorld
==============
*/

void __fastcall HavokPhysics_PreStepWorld(Physics_WorldId worldId, float timeStep)
{
  ?HavokPhysics_PreStepWorld@@YAXW4Physics_WorldId@@M@Z(worldId, timeStep);
}

/*
==============
HavokPhysics_EnableShapeInstance
==============
*/

void __fastcall HavokPhysics_EnableShapeInstance(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> shapeInstanceId, bool enabled)
{
  ?HavokPhysics_EnableShapeInstance@@YAXW4Physics_WorldId@@UhknpBodyId@@U?$hkHandle@G$0PPPP@UhknpShapeInstanceIdDiscriminant@@@@_N@Z(worldId, bodyId, shapeInstanceId, enabled);
}

/*
==============
HavokPhysics_LockAssetRead
==============
*/

void HavokPhysics_LockAssetRead(void)
{
  ?HavokPhysics_LockAssetRead@@YAXXZ();
}

/*
==============
HavokPhysics_SetRigidBodyInverseInertiaLocal
==============
*/

void __fastcall HavokPhysics_SetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *invInertia)
{
  ?HavokPhysics_SetRigidBodyInverseInertiaLocal@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@@Z(worldId, bodyId, invInertia);
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId(HavokPhysics_BroadphaseCollisionQueryResult *this, unsigned int hitId)
{
  return ?GetHitBodyId@HavokPhysics_BroadphaseCollisionQueryResult@@QEBAII@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_UpdateBroadphase
==============
*/

void __fastcall HavokPhysics_UpdateBroadphase(Physics_WorldId worldId, bool updateAll)
{
  ?HavokPhysics_UpdateBroadphase@@YAXW4Physics_WorldId@@_N@Z(worldId, updateAll);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/

void __fastcall HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredShapecast@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@3AEBVhkQuaternionf@@PEAUPhysics_ShapecastExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, shape, start, end, rotation, extendedData, data);
}

/*
==============
HavokPhysics_GetDetailCollisionShapeCount
==============
*/

int __fastcall HavokPhysics_GetDetailCollisionShapeCount(const XModelDetailCollision *detailCollision)
{
  return ?HavokPhysics_GetDetailCollisionShapeCount@@YAHPEBUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
HavokPhysics_AddPhysicsAssetShapesToInstanceList
==============
*/

unsigned int __fastcall HavokPhysics_AddPhysicsAssetShapesToInstanceList(const PhysicsAsset *physicsAsset, const hkVector4f *origin, const float scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?HavokPhysics_AddPhysicsAssetShapesToInstanceList@@YAIPEBUPhysicsAsset@@AEBVhkVector4f@@MAEBVhkQuaternionf@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(physicsAsset, origin, scale, orientation, instanceArray);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitCoverWallId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_AddRigidBodyContents
==============
*/

void __fastcall HavokPhysics_AddRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  ?HavokPhysics_AddRigidBodyContents@@YAXW4Physics_WorldId@@UhknpBodyId@@H_N@Z(worldId, bodyId, contents, forceCacheRebuild);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetWireframeGeometry
==============
*/

void __fastcall HavokPhysics_GetWireframeGeometry(hknpShape *shape, vec3_t *pointArray, int pointArraySize, int *numLines)
{
  ?HavokPhysics_GetWireframeGeometry@@YAXPEAVhknpShape@@PEATvec3_t@@HPEAH@Z(shape, pointArray, pointArraySize, numLines);
}

/*
==============
HavokPhysics_DrawDebugPhysicsRefSystemCounts
==============
*/

void __fastcall HavokPhysics_DrawDebugPhysicsRefSystemCounts(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugPhysicsRefSystemCounts@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_AddDeferredBulletForce
==============
*/

void __fastcall HavokPhysics_AddDeferredBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (__fastcall *effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  ?HavokPhysics_AddDeferredBulletForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@1I_NAEBUWeapon@@_NHP6AXW4LocalClientNum_t@@II11H1PEBW4scr_string_t@@I34H@Z@Z(worldId, start, end, inflictorEntNum, isMelee, weapon, isAlternate, mod, effectCallback);
}

/*
==============
HavokPhysics_GetStepInput
==============
*/

hknpStepInput *__fastcall HavokPhysics_GetStepInput(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetStepInput@@YAPEAUhknpStepInput@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_SetRigidBodyToDefault
==============
*/

void __fastcall HavokPhysics_SetRigidBodyToDefault(Physics_WorldId worldId, hknpBodyId bodyId, const PhysicsAsset *asset, unsigned int assetIndex)
{
  ?HavokPhysics_SetRigidBodyToDefault@@YAXW4Physics_WorldId@@UhknpBodyId@@PEBUPhysicsAsset@@I@Z(worldId, bodyId, asset, assetIndex);
}

/*
==============
HavokPhysics_DrawDebugRaycast
==============
*/

void __fastcall HavokPhysics_DrawDebugRaycast(Physics_WorldId worldId, unsigned int collisionFilterInfo, bool isClutter, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugRaycast@@YAXW4Physics_WorldId@@I_NPEBUScreenPlacement@@PEAM3MM@Z(worldId, collisionFilterInfo, isClutter, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_SetRigidBodyKeyframed
==============
*/

void __fastcall HavokPhysics_SetRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_SetRigidBodyKeyframed@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_IsInstanceInWorld
==============
*/

bool __fastcall HavokPhysics_IsInstanceInWorld(Physics_WorldId worldId, unsigned int instanceId, bool checkPending)
{
  return ?HavokPhysics_IsInstanceInWorld@@YA_NW4Physics_WorldId@@I_N@Z(worldId, instanceId, checkPending);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetNumHits
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetNumHits(HavokPhysics_CollisionQueryResult *this)
{
  return ?GetNumHits@HavokPhysics_CollisionQueryResult@@QEBAIXZ(this);
}

/*
==============
HavokPhysics_CollisionQueryResult::SortResults
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::SortResults(HavokPhysics_CollisionQueryResult *this)
{
  ?SortResults@HavokPhysics_CollisionQueryResult@@QEAAXXZ(this);
}

/*
==============
HavokPhysics_GetTaskQueue
==============
*/

hkDefaultTaskQueue *__fastcall HavokPhysics_GetTaskQueue(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetTaskQueue@@YAPEAVhkDefaultTaskQueue@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_FindShapeTag
==============
*/

unsigned __int16 __fastcall HavokPhysics_FindShapeTag(HavokPhysicsShapeList::ShapeTagData *shapeTagData)
{
  return ?HavokPhysics_FindShapeTag@@YAGAEAUShapeTagData@HavokPhysicsShapeList@@@Z(shapeTagData);
}

/*
==============
HavokPhysics_DestroyWorld
==============
*/

void __fastcall HavokPhysics_DestroyWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_DestroyWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CreateInstance
==============
*/

unsigned int __fastcall HavokPhysics_CreateInstance(Physics_WorldId worldId)
{
  return ?HavokPhysics_CreateInstance@@YAIW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AntilagWarpInstanceTo
==============
*/

bool __fastcall HavokPhysics_AntilagWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, hkVector4f *hkRestorePosition, hkQuaternionf *hkRestoreOrientation)
{
  return ?HavokPhysics_AntilagWarpInstanceTo@@YA_NW4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@AEAV2@AEAV3@@Z(worldId, instanceId, hkPosition, hkOrientation, hkRestorePosition, hkRestoreOrientation);
}

/*
==============
HavokPhysics_ActivateBody
==============
*/

void __fastcall HavokPhysics_ActivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  ?HavokPhysics_ActivateBody@@YAXW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_FindMaterialId
==============
*/

hknpMaterialId *__fastcall HavokPhysics_FindMaterialId(hknpMaterialId *result, const char *physicsMaterial)
{
  return ?HavokPhysics_FindMaterialId@@YA?AUhknpMaterialId@@PEBD@Z(result, physicsMaterial);
}

/*
==============
HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled
==============
*/

bool __fastcall HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled(const Physics_WorldId worldId)
{
  return ?HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled@@YA_NW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_DestroyConstraint
==============
*/

void __fastcall HavokPhysics_DestroyConstraint(Physics_WorldId worldId, unsigned int instanceId, int constraintIdx, bool activate)
{
  ?HavokPhysics_DestroyConstraint@@YAXW4Physics_WorldId@@IH_N@Z(worldId, instanceId, constraintIdx, activate);
}

/*
==============
HavokPhysics_GetContentsFromShapeList
==============
*/

int __fastcall HavokPhysics_GetContentsFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetContentsFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_CreateShapeCapsulePoints
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCapsulePoints(Physics_WorldId worldId, const hkVector4f *a, const hkVector4f *b, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  return ?HavokPhysics_CreateShapeCapsulePoints@@YAPEAVhknpShape@@W4Physics_WorldId@@AEBVhkVector4f@@1MPEADHW4Physics_ShapeStorage@@@Z(worldId, a, b, radius, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsVFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsVFXEventAssetId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_InstantiateHingeConstraint
==============
*/

bool __fastcall HavokPhysics_InstantiateHingeConstraint(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIndex, hkVector4f *pos, hkVector4f *dir, float friction, float minAngle, float maxAngle, float breakingThreshold, unsigned int *outConstraintId)
{
  return ?HavokPhysics_InstantiateHingeConstraint@@YA_NW4Physics_WorldId@@IIAEAVhkVector4f@@1MMMMPEAI@Z(worldId, instanceId, bodyIndex, pos, dir, friction, minAngle, maxAngle, breakingThreshold, outConstraintId);
}

/*
==============
HavokPhysics_DirtyBroadphase
==============
*/

void __fastcall HavokPhysics_DirtyBroadphase(Physics_WorldId worldId, const hkArray<hknpBodyId,hkContainerHeapAllocator> *array)
{
  ?HavokPhysics_DirtyBroadphase@@YAXW4Physics_WorldId@@PEBV?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@@Z(worldId, array);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_IsRigidBodyKeyframed
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyKeyframed@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_AccumulateAngularImpulse
==============
*/

void __fastcall HavokPhysics_AccumulateAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *impulseWs, const hkVector4f *atPointWs, hkVector4f *outAngularVelWs)
{
  ?HavokPhysics_AccumulateAngularImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2AEAV3@@Z(worldId, bodyId, impulseWs, atPointWs, outAngularVelWs);
}

/*
==============
HavokPhysics_DoGarbageCollectionClient
==============
*/

void HavokPhysics_DoGarbageCollectionClient(void)
{
  ?HavokPhysics_DoGarbageCollectionClient@@YAXXZ();
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  ?GetClosestPointHitQueryPosition@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, pos);
}

/*
==============
HavokPhysics_GetDetailCollisionContents
==============
*/

int __fastcall HavokPhysics_GetDetailCollisionContents(const XModelDetailCollision *detailCollision)
{
  return ?HavokPhysics_GetDetailCollisionContents@@YAHPEBUXModelDetailCollision@@@Z(detailCollision);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_SetRigidBodyVelocity
==============
*/

void __fastcall HavokPhysics_SetRigidBodyVelocity(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkLinVel, const hkVector4f *hkAngVel)
{
  ?HavokPhysics_SetRigidBodyVelocity@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@2@Z(worldId, bodyId, hkLinVel, hkAngVel);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetShapecastHitHitContactNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_IsMeshShape
==============
*/

bool __fastcall HavokPhysics_IsMeshShape(const hknpShape *shape)
{
  return ?HavokPhysics_IsMeshShape@@YA_NPEBVhknpShape@@@Z(shape);
}

/*
==============
HavokPhysics_SetRigidBodyUserData
==============
*/

void __fastcall HavokPhysics_SetRigidBodyUserData(Physics_WorldId worldId, hknpBodyId bodyId, unsigned __int64 userData)
{
  ?HavokPhysics_SetRigidBodyUserData@@YAXW4Physics_WorldId@@UhknpBodyId@@_K@Z(worldId, bodyId, userData);
}

/*
==============
HavokPhysics_SetMassPropertiesMass
==============
*/

void __fastcall HavokPhysics_SetMassPropertiesMass(hkMassProperties *massProperties, float mass)
{
  ?HavokPhysics_SetMassPropertiesMass@@YAXPEAUhkMassProperties@@M@Z(massProperties, mass);
}

/*
==============
HavokPhysics_GetDetailBoundingSphereMax
==============
*/

double __fastcall HavokPhysics_GetDetailBoundingSphereMax(Physics_WorldId worldId)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetDetailBoundingSphereMax@@YAMW4Physics_WorldId@@@Z(worldId);
  return result;
}

/*
==============
HavokPhysics_FreeCollisionQueryResult
==============
*/

void __fastcall HavokPhysics_FreeCollisionQueryResult(HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_FreeCollisionQueryResult@@YAXPEAVHavokPhysics_CollisionQueryResult@@@Z(result);
}

/*
==============
HavokPhysics_GetShape
==============
*/

hknpShape *__fastcall HavokPhysics_GetShape(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_GetShape@@YAPEAVhknpShape@@W4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_OnThreadShutdown
==============
*/

void __fastcall HavokPhysics_OnThreadShutdown(unsigned int threadId)
{
  ?HavokPhysics_OnThreadShutdown@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreRefs
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIgnoreRefs(HavokPhysics_IgnoreBodies *this, int refFlags)
{
  ?SetIgnoreRefs@HavokPhysics_IgnoreBodies@@QEAAXH@Z(this, refFlags);
}

/*
==============
HavokPhysics_EnableDeactivationForBody
==============
*/

void __fastcall HavokPhysics_EnableDeactivationForBody(Physics_WorldId worldId, hknpBodyId bodyId, bool enableDeactivation)
{
  ?HavokPhysics_EnableDeactivationForBody@@YAXW4Physics_WorldId@@UhknpBodyId@@_N@Z(worldId, bodyId, enableDeactivation);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionPropertiesId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMotionPropertiesId(const hknpMotionProperties *worldMotionProperties, int motionPropertiesId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMotionPropertiesId@@YAXPEBVhknpMotionProperties@@HPEBUScreenPlacement@@PEAM2MM@Z(worldMotionProperties, motionPropertiesId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_MyChangesInitAndLoad
==============
*/

void HavokPhysics_MyChangesInitAndLoad(void)
{
  ?HavokPhysics_MyChangesInitAndLoad@@YAXXZ();
}

/*
==============
HavokPhysics_SetErrorString
==============
*/

void __fastcall HavokPhysics_SetErrorString(const char *string)
{
  ?HavokPhysics_SetErrorString@@YAXPEBD@Z(string);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationMapLocal
==============
*/

void __fastcall HavokPhysics_SetThreadHeapAllocationMapLocal(unsigned int threadId)
{
  ?HavokPhysics_SetThreadHeapAllocationMapLocal@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_SmoothTimeStep
==============
*/

void __fastcall HavokPhysics_SmoothTimeStep(Physics_WorldId worldId, float timeStep)
{
  ?HavokPhysics_SmoothTimeStep@@YAXW4Physics_WorldId@@M@Z(worldId, timeStep);
}

/*
==============
HavokPhysics_RemoveRigidBodiesFromWorld
==============
*/

void __fastcall HavokPhysics_RemoveRigidBodiesFromWorld(Physics_WorldId worldId, hknpBodyId *bodyIds, int bodyCount, bool activate)
{
  ?HavokPhysics_RemoveRigidBodiesFromWorld@@YAXW4Physics_WorldId@@PEAUhknpBodyId@@H_N@Z(worldId, bodyIds, bodyCount, activate);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CopyPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_CopyPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  ?HavokPhysics_CopyPhysicsSFXEventAsset@@YAXPEAUPhysicsSFXEventAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>
==============
*/

HavokPhysicsMotionPropertiesList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsMotionPropertiesList@@@@YAPEAVHavokPhysicsMotionPropertiesList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CreateShapeCompound
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCompound(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  return ?HavokPhysics_CreateShapeCompound@@YAPEAVhknpShape@@PEAV?$hkArray@UhknpShapeInstance@@UhkContainerHeapAllocator@@@@@Z(instanceArray);
}

/*
==============
HavokPhysics_ReleasePhysicsLibrary
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  ?HavokPhysics_ReleasePhysicsLibrary@@YAXPEAUPhysicsLibrary@@@Z(physicsLibrary);
}

/*
==============
HavokPhysics_GetPhysicsAssetShapeTag
==============
*/

unsigned __int16 __fastcall HavokPhysics_GetPhysicsAssetShapeTag(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_GetPhysicsAssetShapeTag@@YAGPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_TakeMemorySnapshot
==============
*/

void __fastcall HavokPhysics_TakeMemorySnapshot(const char *filename)
{
  ?HavokPhysics_TakeMemorySnapshot@@YAXPEBD@Z(filename);
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintCount
==============
*/

int __fastcall HavokPhysics_GetPhysicsAssetConstraintCount(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetPhysicsAssetConstraintCount@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_DeferredAABBBroadphaseQuery
==============
*/

void __fastcall HavokPhysics_DeferredAABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, Physics_DeferredBroadphaseCollisionQueryData *data)
{
  ?HavokPhysics_DeferredAABBBroadphaseQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBBroadphaseQueryExtendedData@@PEAUPhysics_DeferredBroadphaseCollisionQueryData@@@Z(worldId, aabb, extendedData, data);
}

/*
==============
HavokPhysics_StepWorldDetail
==============
*/

void __fastcall HavokPhysics_StepWorldDetail(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ?HavokPhysics_StepWorldDetail@@YAXW4Physics_WorldId@@HH@Z(worldId, stepIndex, numStepsPlanned);
}

/*
==============
HavokPhysics_GetShapeVertCountFromShapeList
==============
*/

int __fastcall HavokPhysics_GetShapeVertCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeVertCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_GetNumServerRigidBodysInAsset
==============
*/

int __fastcall HavokPhysics_GetNumServerRigidBodysInAsset(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetNumServerRigidBodysInAsset@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssets
==============
*/

void __fastcall HavokPhysics_DrawPhysicsSFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsSFXEventAssets@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitFraction
==============
*/

double __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  double result; 

  *(float *)&result = ?GetShapecastHitFraction@HavokPhysics_CollisionQueryResult@@QEBAMH@Z(this, hitId);
  return result;
}

/*
==============
HavokPhysics_IsPhysicsAssetDynamic
==============
*/

bool __fastcall HavokPhysics_IsPhysicsAssetDynamic(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_IsPhysicsAssetDynamic@@YA_NPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_StepWorldPhysicsObjects
==============
*/

void __fastcall HavokPhysics_StepWorldPhysicsObjects(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ?HavokPhysics_StepWorldPhysicsObjects@@YAXW4Physics_WorldId@@HH@Z(worldId, stepIndex, numStepsPlanned);
}

/*
==============
HavokPhysics_GetNumVertCountsInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumVertCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumVertCountsInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_CreateShapeSphere
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeSphere(const hkVector4f *center, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize)
{
  return ?HavokPhysics_CreateShapeSphere@@YAPEAVhknpShape@@AEBVhkVector4f@@MPEADH@Z(center, radius, optionalInplaceBuffer, optionalInplaceBufferSize);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetShapecastHitSurfaceNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_RemoveClipMap
==============
*/

void __fastcall HavokPhysics_RemoveClipMap(clipMap_t *clipMap)
{
  ?HavokPhysics_RemoveClipMap@@YAXPEAUclipMap_t@@@Z(clipMap);
}

/*
==============
HavokPhysics_KeyframeRigidBodyTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_KeyframeRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?HavokPhysics_KeyframeRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@M_N4M@Z(worldId, bodyId, hkPosition, hkOrientation, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
HavokPhysics_ReleaseMapLocalAllocatorBuffer
==============
*/

void HavokPhysics_ReleaseMapLocalAllocatorBuffer(void)
{
  ?HavokPhysics_ReleaseMapLocalAllocatorBuffer@@YAXXZ();
}

/*
==============
HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit(HavokPhysics_CollisionQueryResult *this, Physics_WorldId worldId, HavokPhysics_CollisionQueryResult *queryPointResult, int hitIndex, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData)
{
  ?AddQueryPointHitAsRaycastHit@HavokPhysics_CollisionQueryResult@@QEAAXW4Physics_WorldId@@PEAV1@HAEBTvec3_t@@2PEAUPhysics_RaycastExtendedData@@@Z(this, worldId, queryPointResult, hitIndex, start, end, extendedData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualityId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryBodyQualityId(int bodyQualityId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryBodyQualityId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(bodyQualityId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_DrawPhysicsAssetId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsAssetId(bool sortByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsAssetId@@YAX_NHPEBUScreenPlacement@@PEAM2MM@Z(sortByName, assetId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_WarpInstanceTo
==============
*/

bool __fastcall HavokPhysics_WarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphaseIfNecessary)
{
  return ?HavokPhysics_WarpInstanceTo@@YA_NW4Physics_WorldId@@IAEBVhkVector4f@@AEBVhkQuaternionf@@_N@Z(worldId, instanceId, hkPosition, hkOrientation, updateBroadphaseIfNecessary);
}

/*
==============
HavokPhysics_FlushMovedStatics
==============
*/

void __fastcall HavokPhysics_FlushMovedStatics(Physics_WorldId worldId)
{
  ?HavokPhysics_FlushMovedStatics@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AddPendingBodies
==============
*/

void __fastcall HavokPhysics_AddPendingBodies(Physics_WorldId worldId)
{
  ?HavokPhysics_AddPendingBodies@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_UnlockAssetRead
==============
*/

void HavokPhysics_UnlockAssetRead(void)
{
  ?HavokPhysics_UnlockAssetRead@@YAXXZ();
}

/*
==============
HavokPhysics_AddDetailTrace
==============
*/

void __fastcall HavokPhysics_AddDetailTrace(HavokPhysics_CollisionQueryResult *result, unsigned __int8 *detailPriorityMap)
{
  ?HavokPhysics_AddDetailTrace@@YAXPEAVHavokPhysics_CollisionQueryResult@@PEAE@Z(result, detailPriorityMap);
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/

void __fastcall HavokPhysics_GetClosestPoints(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_GetClosestPoints@@YAXW4Physics_WorldId@@IPEAIPEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, numBodies, bodyIds, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_GetClothVisContexts
==============
*/

void __fastcall HavokPhysics_GetClothVisContexts(const unsigned int clothIdx, unsigned int *numContexts, hclClothContext **clothContexts)
{
  ?HavokPhysics_GetClothVisContexts@@YAXIPEAIPEAPEAVhclClothContext@@@Z(clothIdx, numContexts, clothContexts);
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMassLocal
==============
*/

void __fastcall HavokPhysics_GetRigidBodyCenterOfMassLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMassLocal)
{
  ?HavokPhysics_GetRigidBodyCenterOfMassLocal@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkVector4f@@@Z(worldId, bodyId, centerOfMassLocal);
}

/*
==============
HavokPhysics_AddRigidBodyIdToArray
==============
*/

void __fastcall HavokPhysics_AddRigidBodyIdToArray(hkArray<hknpBodyId,hkContainerHeapAllocator> *array, hknpBodyId bodyId)
{
  ?HavokPhysics_AddRigidBodyIdToArray@@YAXPEAV?$hkArray@UhknpBodyId@@UhkContainerHeapAllocator@@@@UhknpBodyId@@@Z(array, bodyId);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/

void __fastcall HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredQueryPoint@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, point, maxDistance, extendedData, data);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::allocationFailure
==============
*/

void __fastcall HavokPhysicsLBALimitedMemoryListener::allocationFailure(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  ?allocationFailure@HavokPhysicsLBALimitedMemoryListener@@EEAAX_K@Z(this, size);
}

/*
==============
HavokPhysics_WarpDetailRigidBodyTo
==============
*/

Physics_MovementType __fastcall HavokPhysics_WarpDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase, bool activate)
{
  return ?HavokPhysics_WarpDetailRigidBodyTo@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@_N4@Z(worldId, bodyId, hkPosition, hkOrientation, updateBroadphase, activate);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationGeneral
==============
*/

void __fastcall HavokPhysics_SetThreadHeapAllocationGeneral(unsigned int threadId)
{
  ?HavokPhysics_SetThreadHeapAllocationGeneral@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance
==============
*/

double __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  double result; 

  *(float *)&result = ?GetClosestPointHitDistance@HavokPhysics_CollisionQueryResult@@QEBAMH@Z(this, hitId);
  return result;
}

/*
==============
HavokPhysics_GetThreadPool
==============
*/

HavokPhysicsThreadPool *__fastcall HavokPhysics_GetThreadPool()
{
  return ?HavokPhysics_GetThreadPool@@YAPEAVHavokPhysicsThreadPool@@XZ();
}

/*
==============
HavokPhysics_GetWorld
==============
*/

hknpWorld *__fastcall HavokPhysics_GetWorld(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetWorld@@YAPEAVhknpWorld@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_DrawDebugWorldMemory
==============
*/

void __fastcall HavokPhysics_DrawDebugWorldMemory(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugWorldMemory@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM@Z(worldId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_ReleaseXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_ReleaseXModelDetailCollisionAsset(XModelDetailCollision *detailCollision, bool unloadPackFileData)
{
  ?HavokPhysics_ReleaseXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@_N@Z(detailCollision, unloadPackFileData);
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/

void __fastcall HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_GetClosestPoints@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_DoDeferredQueries
==============
*/

void __fastcall HavokPhysics_DoDeferredQueries(Physics_WorldId worldId)
{
  ?HavokPhysics_DoDeferredQueries@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_ProcessDeferredForce
==============
*/

void __fastcall HavokPhysics_ProcessDeferredForce(const Physics_WorldId worldId)
{
  ?HavokPhysics_ProcessDeferredForce@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_AddShapeReference
==============
*/

void __fastcall HavokPhysics_AddShapeReference(hknpShape *shape)
{
  ?HavokPhysics_AddShapeReference@@YAXPEAVhknpShape@@@Z(shape);
}

/*
==============
HavokPhysics_GetShapeUserData
==============
*/

unsigned __int64 __fastcall HavokPhysics_GetShapeUserData(hknpShape *inShape)
{
  return ?HavokPhysics_GetShapeUserData@@YA_KPEAVhknpShape@@@Z(inShape);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/

void __fastcall HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredQueryPoint@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, point, maxDistance, extendedData, data);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawDebugDetailModel
==============
*/

void __fastcall HavokPhysics_DrawDebugDetailModel(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugDetailModel@@YAXPEBUScreenPlacement@@PEAM1MM@Z(scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintBodyIds
==============
*/

void __fastcall HavokPhysics_GetPhysicsAssetConstraintBodyIds(const PhysicsAsset *physicsAsset, int constraintIdx, int *bodyId1, int *bodyId2)
{
  ?HavokPhysics_GetPhysicsAssetConstraintBodyIds@@YAXPEBUPhysicsAsset@@HPEAH1@Z(physicsAsset, constraintIdx, bodyId1, bodyId2);
}

/*
==============
HavokPhysics_InplaceUnload
==============
*/

void __fastcall HavokPhysics_InplaceUnload(void *buffer, const unsigned __int64 size)
{
  ?HavokPhysics_InplaceUnload@@YAXPEAX_K@Z(buffer, size);
}

/*
==============
HavokPhysics_CopyPhysicsAsset
==============
*/

void __fastcall HavokPhysics_CopyPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  ?HavokPhysics_CopyPhysicsAsset@@YAXPEAUPhysicsAsset@@0@Z(from, to);
}

/*
==============
HavokPhysics_GetInstanceAsset
==============
*/

const PhysicsAsset *__fastcall HavokPhysics_GetInstanceAsset(Physics_WorldId worldId, unsigned int instanceId)
{
  return ?HavokPhysics_GetInstanceAsset@@YAPEBUPhysicsAsset@@W4Physics_WorldId@@I@Z(worldId, instanceId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitSurfFlags@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_UpdateWorld
==============
*/

void __fastcall HavokPhysics_UpdateWorld(Physics_WorldId worldId, bool syncStats)
{
  ?HavokPhysics_UpdateWorld@@YAXW4Physics_WorldId@@_N@Z(worldId, syncStats);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_Task
==============
*/

void __fastcall HavokPhysics_Task(Physics_WorldId worldId, int taskId)
{
  ?HavokPhysics_Task@@YAXW4Physics_WorldId@@H@Z(worldId, taskId);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/

void __fastcall HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredGetClosestPoints@@YAXW4Physics_WorldId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, shape, point, rotation, maxDistance, extendedData, data);
}

/*
==============
HavokPhysics_GetRigidBodyDefaultMass
==============
*/

double __fastcall HavokPhysics_GetRigidBodyDefaultMass(Physics_WorldId worldId, const PhysicsAsset *physAsset)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetRigidBodyDefaultMass@@YAMW4Physics_WorldId@@PEBUPhysicsAsset@@@Z(worldId, physAsset);
  return result;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/

void __fastcall HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredAABBQuery@@YAXW4Physics_WorldId@@VhkAabb@@PEAUPhysics_AABBQueryExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, aabb, extendedData, data);
}

/*
==============
HavokPhysics_SnapshotFixup::getShapeForBody
==============
*/

const hknpShape *__fastcall HavokPhysics_SnapshotFixup::getShapeForBody(HavokPhysics_SnapshotFixup *this, hknpBody *body)
{
  return ?getShapeForBody@HavokPhysics_SnapshotFixup@@UEAAPEBVhknpShape@@AEAVhknpBody@@@Z(this, body);
}

/*
==============
HavokPhysics_IsRigidBodyValid
==============
*/

bool __fastcall HavokPhysics_IsRigidBodyValid(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_IsRigidBodyValid@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_SwapXModelDetailCollisionAsset
==============
*/

void __fastcall HavokPhysics_SwapXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  ?HavokPhysics_SwapXModelDetailCollisionAsset@@YAXPEAUXModelDetailCollision@@0@Z(from, to);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastInternalHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastInternalHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastInternalHit@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_ApplyLinearImpulse
==============
*/

void __fastcall HavokPhysics_ApplyLinearImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkDirection, float magnitude)
{
  ?HavokPhysics_ApplyLinearImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@M@Z(worldId, bodyId, hkDirection, magnitude);
}

/*
==============
HavokPhysics_IsAssetBodyAnimationDriven
==============
*/

bool __fastcall HavokPhysics_IsAssetBodyAnimationDriven(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_IsAssetBodyAnimationDriven@@YA_NPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_StepVDB
==============
*/

void __fastcall HavokPhysics_StepVDB(Physics_WorldId worldId, float time, bool updateStats)
{
  ?HavokPhysics_StepVDB@@YAXW4Physics_WorldId@@M_N@Z(worldId, time, updateStats);
}

/*
==============
HavokPhysics_GetNumShapeNamesInShapeList
==============
*/

int __fastcall HavokPhysics_GetNumShapeNamesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return ?HavokPhysics_GetNumShapeNamesInShapeList@@YAHPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_ReleaseXModelAsset
==============
*/

void __fastcall HavokPhysics_ReleaseXModelAsset(XModel *xmodel)
{
  ?HavokPhysics_ReleaseXModelAsset@@YAXPEAUXModel@@@Z(xmodel);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitQueryGlassId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_QueryPoint
==============
*/

void __fastcall HavokPhysics_QueryPoint(Physics_WorldId worldId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_QueryPoint@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MPEAUPhysics_QueryPointExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, point, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitHitContents@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/

void __fastcall HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  ?HavokPhysics_GetClosestPoints@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAVHavokPhysics_CollisionQueryResult@@@Z(worldId, bodyId, shape, point, rotation, maxDistance, extendedData, result);
}

/*
==============
HavokPhysics_ProcessDeferredForceCallbacks
==============
*/

void __fastcall HavokPhysics_ProcessDeferredForceCallbacks(const Physics_WorldId worldId)
{
  ?HavokPhysics_ProcessDeferredForceCallbacks@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_SetMainShapeList
==============
*/

void __fastcall HavokPhysics_SetMainShapeList(HavokPhysicsShapeList *shapeList)
{
  ?HavokPhysics_SetMainShapeList@@YAXPEAVHavokPhysicsShapeList@@@Z(shapeList);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitRef
==============
*/

int __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetClosestPointHitRef@HavokPhysics_CollisionQueryResult@@QEBAHH@Z(this, hitId);
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>
==============
*/

HavokPhysicsAsset *__fastcall HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoadWithGlobalTypeCompendium@VHavokPhysicsAsset@@@@YAPEAVHavokPhysicsAsset@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_HasSFXEventAsset
==============
*/

bool __fastcall HavokPhysics_HasSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_HasSFXEventAsset@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo
==============
*/

void __fastcall HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, hknpBodyId bodyId, const hkVector4f *hkInstancePosition, const hkQuaternionf *hkInstanceOrientation, hkVector4f *hkBodyPosition, hkQuaternionf *hkBodyOrientation)
{
  ?HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo@@YAXW4Physics_WorldId@@IUhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@AEAV3@AEAV4@@Z(worldId, instanceId, bodyId, hkInstancePosition, hkInstanceOrientation, hkBodyPosition, hkBodyOrientation);
}

/*
==============
HavokPhysics_AllocateIgnoreBodies
==============
*/

HavokPhysics_IgnoreBodies *__fastcall HavokPhysics_AllocateIgnoreBodies(int minEntities, int minBodies)
{
  return ?HavokPhysics_AllocateIgnoreBodies@@YAPEAVHavokPhysics_IgnoreBodies@@HH@Z(minEntities, minBodies);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>
==============
*/

HavokPhysicsMaterialList *__fastcall HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoad@VHavokPhysicsMaterialList@@@@YAPEAVHavokPhysicsMaterialList@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_CalcRigidBodyShapeAABBWorld
==============
*/

void __fastcall HavokPhysics_CalcRigidBodyShapeAABBWorld(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb)
{
  ?HavokPhysics_CalcRigidBodyShapeAABBWorld@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAVhkAabb@@@Z(worldId, bodyId, aabb);
}

/*
==============
HavokPhysics_GetShapeTriCountFromShapeList
==============
*/

int __fastcall HavokPhysics_GetShapeTriCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeTriCountFromShapeList@@YAHPEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_SetRigidBodyCenterOfMass
==============
*/

void __fastcall HavokPhysics_SetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *centerOfMass)
{
  ?HavokPhysics_SetRigidBodyCenterOfMass@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@@Z(worldId, bodyId, centerOfMass);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitBodyId@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetShapeFromShapeList
==============
*/

hknpShape *__fastcall HavokPhysics_GetShapeFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return ?HavokPhysics_GetShapeFromShapeList@@YAPEAVhknpShape@@PEAVHavokPhysicsShapeList@@I@Z(shapeList, shapeIdx);
}

/*
==============
HavokPhysics_ReleasePhysicsAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsAsset(PhysicsAsset *physicsAsset, bool unloadPackFileData)
{
  ?HavokPhysics_ReleasePhysicsAsset@@YAXPEAUPhysicsAsset@@_N@Z(physicsAsset, unloadPackFileData);
}

/*
==============
HavokPhysics_StepWorldEnd
==============
*/

void __fastcall HavokPhysics_StepWorldEnd(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ?HavokPhysics_StepWorldEnd@@YAXW4Physics_WorldId@@HH@Z(worldId, stepIndex, numStepsPlanned);
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinSpeed
==============
*/

void __fastcall HavokPhysics_GetRigidBodyMaxLinSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed)
{
  ?HavokPhysics_GetRigidBodyMaxLinSpeed@@YAXW4Physics_WorldId@@UhknpBodyId@@AEAM@Z(worldId, bodyId, maxLinSpeed);
}

/*
==============
HavokPhysics_CreateShapeCapsuleCenterHeight
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCapsuleCenterHeight(Physics_WorldId worldId, const hkVector4f *center, float halfHeight, float radius, hkVector4f *majorAxis, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  return ?HavokPhysics_CreateShapeCapsuleCenterHeight@@YAPEAVhknpShape@@W4Physics_WorldId@@AEBVhkVector4f@@MMV3@PEADHW4Physics_ShapeStorage@@@Z(worldId, center, halfHeight, radius, majorAxis, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  ?GetClosestPointHitSeparatingNormal@HavokPhysics_CollisionQueryResult@@QEBAXHAEATvec3_t@@@Z(this, hitId, normal);
}

/*
==============
HavokPhysics_CreateWorld
==============
*/

void __fastcall HavokPhysics_CreateWorld(Physics_WorldId worldId, Physics_WorldCInfo *worldCInfo)
{
  ?HavokPhysics_CreateWorld@@YAXW4Physics_WorldId@@PEAUPhysics_WorldCInfo@@@Z(worldId, worldCInfo);
}

/*
==============
HavokPhysics_GetVFXEventAsset
==============
*/

int __fastcall HavokPhysics_GetVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsVFXEventAsset **asset)
{
  return ?HavokPhysics_GetVFXEventAsset@@YAHW4Physics_WorldId@@UhknpBodyId@@1PEAPEAUPhysicsVFXEventAsset@@@Z(worldId, bodyId0, bodyId1, asset);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryBrushBasis@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_DrawDebugGetClosestPoints
==============
*/

void __fastcall HavokPhysics_DrawDebugGetClosestPoints(Physics_WorldId worldId, const hkVector4f *position, float maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawDebugGetClosestPoints@@YAXW4Physics_WorldId@@AEBVhkVector4f@@MIPEBUScreenPlacement@@PEAM3MM@Z(worldId, position, maxDistance, collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastFrontfaceHit@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats
==============
*/

void __fastcall HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  ??1HavokPhysics_CylinderShapeStats@@UEAA@XZ(this);
}

/*
==============
HavokPhysics_InstantiateAssetConstraint
==============
*/

bool __fastcall HavokPhysics_InstantiateAssetConstraint(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int constraintIdx, int instanceRef, bool deepCloneConstraintData)
{
  return ?HavokPhysics_InstantiateAssetConstraint@@YA_NIW4Physics_WorldId@@PEBUPhysicsAsset@@HH_N@Z(instanceId, worldId, physicsAsset, constraintIdx, instanceRef, deepCloneConstraintData);
}

/*
==============
HavokPhysics_InstantiateStaticBody
==============
*/

unsigned int __fastcall HavokPhysics_InstantiateStaticBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  return ?HavokPhysics_InstantiateStaticBody@@YAIW4Physics_WorldId@@PEBVhknpShape@@HPEBD2HAEBVhkVector4f@@AEBVhkQuaternionf@@_N55@Z(worldId, shape, ref, name, physicsMaterial, collisionFilterInfo, position, orientation, add, tryStartDeactivated, forQueryOnly);
}

/*
==============
HavokPhysics_GetPhysicsAssetShape
==============
*/

const hknpShape *__fastcall HavokPhysics_GetPhysicsAssetShape(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_GetPhysicsAssetShape@@YAPEBVhknpShape@@PEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_KeyframeRigidBodyToFast
==============
*/

Physics_MovementType __fastcall HavokPhysics_KeyframeRigidBodyToFast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  return ?HavokPhysics_KeyframeRigidBodyToFast@@YA?AW4Physics_MovementType@@W4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@AEBVhkQuaternionf@@M_N4M@Z(worldId, bodyId, hkPosition, hkOrientation, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
}

/*
==============
HavokPhysics_GetFixedMemoryPoolUsage
==============
*/

double __fastcall HavokPhysics_GetFixedMemoryPoolUsage(Physics_WorldId worldId)
{
  double result; 

  *(float *)&result = ?HavokPhysics_GetFixedMemoryPoolUsage@@YAMW4Physics_WorldId@@@Z(worldId);
  return result;
}

/*
==============
HavokPhysics_DrawDebugWorldTimestep
==============
*/

void __fastcall HavokPhysics_DrawDebugWorldTimestep(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool drawFrame)
{
  ?HavokPhysics_DrawDebugWorldTimestep@@YAXW4Physics_WorldId@@PEBUScreenPlacement@@PEAM2MM_N@Z(worldId, scrPlace, x, y, tabWidth, charHeight, drawFrame);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/

void __fastcall HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  ?HavokPhysics_DeferredGetClosestPoints@@YAXW4Physics_WorldId@@UhknpBodyId@@PEAVhknpShape@@AEBVhkVector4f@@AEBVhkQuaternionf@@MPEAUPhysics_GetClosestPointsExtendedData@@PEAUPhysics_DeferredCollisionQueryData@@@Z(worldId, bodyId, shape, point, rotation, maxDistance, extendedData, data);
}

/*
==============
HavokPhysics_GetDebugLines
==============
*/

hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *__fastcall HavokPhysics_GetDebugLines(Physics_WorldId worldId)
{
  return ?HavokPhysics_GetDebugLines@@YAPEAV?$hkArray@UHavokPhysicsDebugLine@@UhkContainerHeapAllocator@@@@W4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_IgnoreBodies::SetIsClutter
==============
*/

void __fastcall HavokPhysics_IgnoreBodies::SetIsClutter(HavokPhysics_IgnoreBodies *this, bool isClutter)
{
  ?SetIsClutter@HavokPhysics_IgnoreBodies@@QEAAX_N@Z(this, isClutter);
}

/*
==============
HavokPhysics_OnThreadInit
==============
*/

void __fastcall HavokPhysics_OnThreadInit(unsigned int threadId)
{
  ?HavokPhysics_OnThreadInit@@YAXI@Z(threadId);
}

/*
==============
HavokPhysics_GetPhysicsAssetContents
==============
*/

int __fastcall HavokPhysics_GetPhysicsAssetContents(const PhysicsAsset *physicsAsset)
{
  return ?HavokPhysics_GetPhysicsAssetContents@@YAHPEBUPhysicsAsset@@@Z(physicsAsset);
}

/*
==============
HavokPhysics_GetSFXEventAsset
==============
*/

int __fastcall HavokPhysics_GetSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsSFXEventAsset **asset)
{
  return ?HavokPhysics_GetSFXEventAsset@@YAHW4Physics_WorldId@@UhknpBodyId@@1PEAPEAUPhysicsSFXEventAsset@@@Z(worldId, bodyId0, bodyId1, asset);
}

/*
==============
HavokPhysics_HasVFXEventAsset
==============
*/

bool __fastcall HavokPhysics_HasVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_HasVFXEventAsset@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType
==============
*/

bool __fastcall HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetShapecastHitQueryDecalType@HavokPhysics_CollisionQueryResult@@QEBA_NH@Z(this, hitId);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyName
==============
*/

const char *__fastcall HavokPhysics_GetPhysicsAssetBodyName(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  return ?HavokPhysics_GetPhysicsAssetBodyName@@YAPEBDPEBUPhysicsAsset@@H@Z(physicsAsset, bodyIdx);
}

/*
==============
HavokPhysics_AddDeferredKeyframeInstance
==============
*/

void __fastcall HavokPhysics_AddDeferredKeyframeInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *origin, const vec4_t *orientationAsQuat)
{
  ?HavokPhysics_AddDeferredKeyframeInstance@@YAXW4Physics_WorldId@@IAEBTvec3_t@@AEBTvec4_t@@@Z(worldId, instanceId, origin, orientationAsQuat);
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterialId
==============
*/

void __fastcall HavokPhysics_DrawPhysicsLibraryMaterialId(int materialId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  ?HavokPhysics_DrawPhysicsLibraryMaterialId@@YAXHPEBUScreenPlacement@@PEAM1MM@Z(materialId, scrPlace, x, y, tabWidth, charHeight);
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/

void __fastcall HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkTorqueVector, float magnitude)
{
  ?HavokPhysics_ApplyAngularImpulse@@YAXW4Physics_WorldId@@UhknpBodyId@@AEBVhkVector4f@@M@Z(worldId, bodyId, hkTorqueVector, magnitude);
}

/*
==============
HavokPhysics_AddDeferredRadiusForce
==============
*/

void __fastcall HavokPhysics_AddDeferredRadiusForce(const Physics_WorldId worldId, const vec3_t *position, const float radius, const float innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, int randSeed, float forceScalar)
{
  ?HavokPhysics_AddDeferredRadiusForce@@YAXW4Physics_WorldId@@AEBTvec3_t@@MMMM1HM@Z(worldId, position, radius, innerDamage, outerDamage, impulseOverride, impulseVecOverride, randSeed, forceScalar);
}

/*
==============
HavokPhysics_AddShapeList
==============
*/

HavokPhysicsShapeList *__fastcall HavokPhysics_AddShapeList(char **rawShapeData, unsigned int *rawShapeDataSize, const char *name, int type)
{
  return ?HavokPhysics_AddShapeList@@YAPEAVHavokPhysicsShapeList@@PEAPEADPEAIPEBDH@Z(rawShapeData, rawShapeDataSize, name, type);
}

/*
==============
HavokPhysics_CollisionQueryResult::Reset
==============
*/

void __fastcall HavokPhysics_CollisionQueryResult::Reset(HavokPhysics_CollisionQueryResult *this, bool clearModifiers)
{
  ?Reset@HavokPhysics_CollisionQueryResult@@QEAAX_N@Z(this, clearModifiers);
}

/*
==============
HavokPhysics_FreeIgnoreBodies
==============
*/

void __fastcall HavokPhysics_FreeIgnoreBodies(HavokPhysics_IgnoreBodies *ignoreBodies)
{
  ?HavokPhysics_FreeIgnoreBodies@@YAXPEAVHavokPhysics_IgnoreBodies@@@Z(ignoreBodies);
}

/*
==============
HavokPhysics_InitialErrorReportFunction
==============
*/

void __fastcall HavokPhysics_InitialErrorReportFunction(const char *msg, void *__formal)
{
  ?HavokPhysics_InitialErrorReportFunction@@YAXPEBDPEAX@Z(msg, __formal);
}

/*
==============
HavokPhysics_DoGarbageCollectionServer
==============
*/

void HavokPhysics_DoGarbageCollectionServer(void)
{
  ?HavokPhysics_DoGarbageCollectionServer@@YAXXZ();
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey
==============
*/

unsigned int __fastcall HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetRaycastHitShapeKey@HavokPhysics_CollisionQueryResult@@QEBAIH@Z(this, hitId);
}

/*
==============
HavokPhysics_ValidateWorld
==============
*/

void __fastcall HavokPhysics_ValidateWorld(Physics_WorldId worldId)
{
  ?HavokPhysics_ValidateWorld@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>
==============
*/

HavokPhysicsXModelLOD *__fastcall HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>(char **outData, unsigned int *outSize, const char *name, int type)
{
  return ??$HavokPhysics_InplaceLoadWithGlobalTypeCompendium@VHavokPhysicsXModelLOD@@@@YAPEAVHavokPhysicsXModelLOD@@PEAPEADPEAIPEBDH@Z(outData, outSize, name, type);
}

/*
==============
HavokPhysics_SnapshotFixup::getConstraintDataForConstraint
==============
*/

hkpConstraintData *__fastcall HavokPhysics_SnapshotFixup::getConstraintDataForConstraint(HavokPhysics_SnapshotFixup *this, hknpConstraint *constraint)
{
  return ?getConstraintDataForConstraint@HavokPhysics_SnapshotFixup@@QEAAPEAVhkpConstraintData@@AEAVhknpConstraint@@@Z(this, constraint);
}

/*
==============
HavokPhysics_HasTriggerEvent
==============
*/

bool __fastcall HavokPhysics_HasTriggerEvent(Physics_WorldId worldId, hknpBodyId bodyId)
{
  return ?HavokPhysics_HasTriggerEvent@@YA_NW4Physics_WorldId@@UhknpBodyId@@@Z(worldId, bodyId);
}

/*
==============
HavokPhysics_SetInstanceXModel
==============
*/

void __fastcall HavokPhysics_SetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  ?HavokPhysics_SetInstanceXModel@@YAXW4Physics_WorldId@@IPEBUXModel@@@Z(worldId, instanceId, xModel);
}

/*
==============
HavokPhysics_SetDebugCameras
==============
*/

void __fastcall HavokPhysics_SetDebugCameras(const GfxViewInfo *viewInfo)
{
  ?HavokPhysics_SetDebugCameras@@YAXPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
HavokPhysics_SubscribeToEvent
==============
*/

void __fastcall HavokPhysics_SubscribeToEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (__fastcall *function)(const hknpEventHandlerInput *, const hknpEvent *), const char *name)
{
  ?HavokPhysics_SubscribeToEvent@@YAXW4Physics_WorldId@@W4Enum@hknpEventType@@UhknpBodyId@@P6AXAEBUhknpEventHandlerInput@@AEBUhknpEvent@@@ZPEBD@Z(worldId, eventType, specificBodyId, function, name);
}

/*
==============
HavokPhysics_CheckWorldReplayDeterminism
==============
*/

void __fastcall HavokPhysics_CheckWorldReplayDeterminism(Physics_WorldId worldId)
{
  ?HavokPhysics_CheckWorldReplayDeterminism@@YAXW4Physics_WorldId@@@Z(worldId);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId
==============
*/

unsigned __int16 __fastcall HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return ?GetAABBQueryHitMaterialId@HavokPhysics_CollisionQueryResult@@QEBAGH@Z(this, hitId);
}

/*
==============
HavokPhysics_BroadphaseBodiesChangedServerMain
==============
*/

void __fastcall HavokPhysics_BroadphaseBodiesChangedServerMain(Physics_WorldId worldId)
{
  GPlayerTraceInfo::ClearServerCages();
}

/*
==============
HavokPhysics_BroadphaseBodiesChangedClientPred
==============
*/
void HavokPhysics_BroadphaseBodiesChangedClientPred(Physics_WorldId worldId)
{
  LocalClientNum_t LocalClientForWorld; 

  LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
  CgPlayerTraceInfo::ClearCage(LocalClientForWorld);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::cannotAllocate
==============
*/
void HavokPhysicsLBALimitedMemoryListener::cannotAllocate(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  bool v4; 
  unsigned __int64 v5; 
  unsigned __int64 v6; 
  char dest[512]; 

  if ( this->m_isDebug || Physics_GetDebugMemorySize() )
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 538, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Cannot Allocate %zu bytes.", this->m_name, size);
  else
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 533, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Cannot Allocate %zu bytes.  Physics Debug Memory is NOT ENABLED - if you are trying to use a debug feature, please set dvar physics_debugMemoryEnable.", this->m_name, size);
  if ( v4 )
    __debugbreak();
  v5 = 0i64;
  if ( s_havokPhysicsGeneralLargeBlockAllocator )
    v6 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  else
    v6 = 0i64;
  if ( s_havokPhysicsMapLocalLargeBlockAllocator )
    v5 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  Com_sprintf<512>((char (*)[512])dest, "Hk:s=%zum=%zu:%zu", size, v6, v5);
  Mem_Error_CannotAlloc_Dev((Mem_AllocatorType)9, "HavokPhysicsLBALimitedMemoryListener::cannotAllocate", "c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 550, (const char *)&queryFormat, dest);
}

/*
==============
HavokPhysicsLBALimitedMemoryListener::allocationFailure
==============
*/
void HavokPhysicsLBALimitedMemoryListener::allocationFailure(HavokPhysicsLBALimitedMemoryListener *this, unsigned __int64 size)
{
  bool v4; 
  unsigned __int64 v5; 
  unsigned __int64 v6; 
  char dest[512]; 

  if ( this->m_isDebug || Physics_GetDebugMemorySize() )
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 562, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Allocation Failure: %zu bytes.", this->m_name, size);
  else
    v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 557, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Havok %s Memory Allocation Failure: %zu bytes.  Physics Debug Memory is NOT ENABLED - if you are trying to use a debug feature, please set dvar physics_debugMemoryEnable.", this->m_name, size);
  if ( v4 )
    __debugbreak();
  v5 = 0i64;
  if ( s_havokPhysicsGeneralLargeBlockAllocator )
    v6 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  else
    v6 = 0i64;
  if ( s_havokPhysicsMapLocalLargeBlockAllocator )
    v5 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  Com_sprintf<512>((char (*)[512])dest, "Hk:s=%zum=%zu:%zu", size, v6, v5);
  Mem_Error_CannotAlloc_Dev((Mem_AllocatorType)9, "HavokPhysicsLBALimitedMemoryListener::allocationFailure", "c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 574, (const char *)&queryFormat, dest);
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>
==============
*/
HavokPhysicsBodyQualityList *HavokPhysics_InplaceLoad<HavokPhysicsBodyQualityList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsBodyQualityList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsBodyQualityList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsBodyQualityList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>
==============
*/
HavokPhysicsMaterialList *HavokPhysics_InplaceLoad<HavokPhysicsMaterialList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMaterialList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMaterialList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsMaterialList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>
==============
*/
HavokPhysicsMotionPropertiesList *HavokPhysics_InplaceLoad<HavokPhysicsMotionPropertiesList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMotionPropertiesList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMotionPropertiesList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsMotionPropertiesList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<HavokPhysicsShapeList>
==============
*/
HavokPhysicsShapeList *HavokPhysics_InplaceLoad<HavokPhysicsShapeList>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  void *m_addr; 
  hkSerialize::InplaceLoad v9; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  hkSerialize::InplaceLoad::toVar(v6, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsShapeList::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsShapeList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return (HavokPhysicsShapeList *)m_addr;
}

/*
==============
HavokPhysics_InplaceLoad<hknpShape>
==============
*/
hknpShape *HavokPhysics_InplaceLoad<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  hknpShape *v7; 
  hkSerialize::InplaceLoad v9; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData", -2i64) )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v9);
  v7 = hkSerialize::InplaceLoad::toObject<hknpShape>(v6, *outData, *outSize);
  hkSerialize::InplaceLoad::~InplaceLoad(&v9);
  return v7;
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>
==============
*/
HavokPhysicsAsset *HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsAsset>(char **outData, unsigned int *outSize, const char *name, int type)
{
  void *m_addr; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsAsset::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsAsset::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return (HavokPhysicsAsset *)m_addr;
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return 0i64;
  }
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>
==============
*/
HavokPhysicsXModelLOD *HavokPhysics_InplaceLoadWithGlobalTypeCompendium<HavokPhysicsXModelLOD>(char **outData, unsigned int *outSize, const char *name, int type)
{
  void *m_addr; 
  hkReflect::Var result; 

  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, *outData, *outSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsXModelLOD::typeData);
  m_addr = result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsXModelLOD::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return (HavokPhysicsXModelLOD *)m_addr;
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    return 0i64;
  }
}

/*
==============
HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>
==============
*/
hknpShape *HavokPhysics_InplaceLoadWithGlobalTypeCompendium<hknpShape>(char **outData, unsigned int *outSize, const char *name, int type)
{
  if ( !*outData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*outSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  return hkSerialize::InplaceLoad::toObject<hknpShape>(s_havokPhysicsInPlaceLoad, *outData, *outSize);
}

/*
==============
HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats
==============
*/
void HavokPhysics_CylinderShapeStats::HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  this->m_propertyBag.m_bag = NULL;
  this->__vftable = (HavokPhysics_CylinderShapeStats_vtbl *)&HavokPhysics_CylinderShapeStats::`vftable';
  *(_DWORD *)&this->m_memSizeAndFlags = 0x1FFFF;
}

/*
==============
HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies
==============
*/
void HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(HavokPhysics_IgnoreBodies *this, int minEntities, int minBodies)
{
  int v5; 
  hkMemoryAllocator *v6; 
  int v7; 
  int v8; 
  HavokPhysics_IgnoreBodies::IgnoreEntity *v9; 
  int v10; 
  hkMemoryAllocator *v11; 
  int v12; 
  int v13; 
  hknpBodyId *v14; 
  int numInOut; 
  int v16; 

  this->m_ignoreRefs = 0;
  this->m_ignoreEntities.m_data = NULL;
  this->m_ignoreEntities.m_size = 0;
  v5 = 0x80000000;
  this->m_ignoreEntities.m_capacityAndFlags = 0x80000000;
  numInOut = minEntities;
  v6 = hkMemHeapAllocator();
  v7 = numInOut;
  v8 = numInOut;
  if ( numInOut )
  {
    v9 = (HavokPhysics_IgnoreBodies::IgnoreEntity *)hkMemoryAllocator::bufAlloc2(v6, 8, &numInOut);
    v7 = numInOut;
  }
  else
  {
    v9 = NULL;
  }
  v10 = 0x80000000;
  if ( v7 )
    v10 = v7;
  this->m_ignoreEntities.m_data = v9;
  this->m_ignoreEntities.m_size = v8;
  this->m_ignoreEntities.m_capacityAndFlags = v10;
  this->m_ignoreBodies.m_data = NULL;
  this->m_ignoreBodies.m_size = 0;
  this->m_ignoreBodies.m_capacityAndFlags = 0x80000000;
  v16 = minBodies;
  v11 = hkMemHeapAllocator();
  v12 = v16;
  v13 = v16;
  if ( v16 )
  {
    v14 = (hknpBodyId *)hkMemoryAllocator::bufAlloc2(v11, 4, &v16);
    v12 = v16;
  }
  else
  {
    v14 = NULL;
  }
  if ( v12 )
    v5 = v12;
  this->m_ignoreBodies.m_data = v14;
  this->m_ignoreBodies.m_size = v13;
  this->m_ignoreBodies.m_capacityAndFlags = v5;
  *(_QWORD *)&this->m_ignorePhysicsVolumes = 0i64;
  *(_WORD *)&this->m_isClutter = 0;
  this->m_ignoreLayers = 32;
}

/*
==============
HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats
==============
*/
void HavokPhysics_CylinderShapeStats::~HavokPhysics_CylinderShapeStats(HavokPhysics_CylinderShapeStats *this)
{
  this->__vftable = (HavokPhysics_CylinderShapeStats_vtbl *)&HavokPhysics_CylinderShapeStats::`vftable';
  hkReferencedObject::~hkReferencedObject(this);
}

/*
==============
HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer
==============
*/
void HavokPhysics_SimpleShapeBuffer::~HavokPhysics_SimpleShapeBuffer(HavokPhysics_SimpleShapeBuffer *this)
{
  this->m_shape = NULL;
  this->__vftable = (HavokPhysics_SimpleShapeBuffer_vtbl *)hknpShapeBuffer::`vftable';
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreBody
==============
*/
void HavokPhysics_IgnoreBodies::AddIgnoreBody(HavokPhysics_IgnoreBodies *this, unsigned int bodyId)
{
  hkArray<hknpBodyId,hkContainerHeapAllocator> *p_m_ignoreBodies; 
  hkMemoryAllocator *v4; 
  int m_size; 

  p_m_ignoreBodies = &this->m_ignoreBodies;
  v4 = hkMemHeapAllocator();
  m_size = p_m_ignoreBodies->m_size;
  if ( m_size == (p_m_ignoreBodies->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v4, p_m_ignoreBodies, 4);
    m_size = p_m_ignoreBodies->m_size;
  }
  p_m_ignoreBodies->m_data[m_size].m_serialAndIndex = bodyId;
  ++p_m_ignoreBodies->m_size;
}

/*
==============
HavokPhysics_IgnoreBodies::AddIgnoreEntity
==============
*/
void HavokPhysics_IgnoreBodies::AddIgnoreEntity(HavokPhysics_IgnoreBodies *this, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  hkArray<HavokPhysics_IgnoreBodies::IgnoreEntity,hkContainerHeapAllocator> *p_m_ignoreEntities; 
  hkMemoryAllocator *v11; 
  int m_size; 
  __int64 v13; 
  char v14; 

  if ( svEntNum != 2047 )
  {
    p_m_ignoreEntities = &this->m_ignoreEntities;
    v11 = hkMemHeapAllocator();
    m_size = p_m_ignoreEntities->m_size;
    if ( m_size == (p_m_ignoreEntities->m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v11, p_m_ignoreEntities, 8);
      m_size = p_m_ignoreEntities->m_size;
    }
    v13 = (__int64)&p_m_ignoreEntities->m_data[m_size];
    p_m_ignoreEntities->m_size = m_size + 1;
    *(_BYTE *)(v13 + 4) &= ~1u;
    v14 = (*(_BYTE *)(v13 + 4) | self) & 0xE1;
    *(_DWORD *)v13 = svEntNum;
    *(_BYTE *)(v13 + 4) = v14 | (2 * (children & 0xF1 | (2 * (parent & 0xF9 | (2 * ((2 * linked) | siblings & 0xFD))))));
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit
==============
*/
void HavokPhysics_CollisionQueryResult::AddQueryPointHitAsRaycastHit(HavokPhysics_CollisionQueryResult *this, Physics_WorldId worldId, HavokPhysics_CollisionQueryResult *queryPointResult, int hitIndex, const vec3_t *start, const vec3_t *end, Physics_RaycastExtendedData *extendedData)
{
  hknpCollisionQueryCollector *Collector; 
  const hknpCollisionResult *Hit; 
  float v13; 
  float v14; 
  __int128 v16; 
  const HavokPhysicsWorld *ConstWorld; 
  float v19; 
  const hknpCollisionFilter **p_traceCollisionFilter; 
  Physics_CharacterProxy_Type characterProxyType; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  unsigned int v31; 
  HavokPhysicsHitCollector *m_collector; 
  __int64 v33; 
  __int64 v34; 
  __int64 v35[2]; 
  Physics_CharacterProxy_Type v36; 
  __int128 v37; 
  __int64 v38; 
  hknpRayCastQuery query; 
  hkVector4f v40; 
  hkVector4f v41; 
  __int128 v42[2]; 
  float v43; 
  unsigned int m_serialAndIndex; 
  unsigned int m_value; 
  int v46; 
  unsigned __int16 v47; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  unsigned int v50; 
  unsigned int v51; 
  int v52; 
  unsigned __int16 v53; 
  unsigned int v54; 
  unsigned __int64 v55; 
  int v56; 
  unsigned int v57; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2334, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to AddQueryPointHitAsRaycastHit with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !queryPointResult && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2335, ASSERT_TYPE_ASSERT, "(queryPointResult)", (const char *)&queryFormat, "queryPointResult") )
    __debugbreak();
  if ( hitIndex >= HavokPhysics_CollisionQueryResult::GetNumHits(queryPointResult) )
  {
    LODWORD(v34) = HavokPhysics_CollisionQueryResult::GetNumHits(queryPointResult);
    LODWORD(v33) = hitIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2336, ASSERT_TYPE_ASSERT, "(unsigned)( hitIndex ) < (unsigned)( queryPointResult->GetNumHits() )", "hitIndex doesn't index queryPointResult->GetNumHits()\n\t%i not in [0, %i)", v33, v34) )
      __debugbreak();
  }
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2338, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2340, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  Hit = HavokPhysics_CollisionQueryResult::GetHit(queryPointResult, hitIndex);
  v42[0] = (__int128)Hit->m_position;
  v42[1] = (__int128)Hit->m_normal;
  v43 = 0.0;
  m_serialAndIndex = Hit->m_queryBodyInfo.m_bodyId.m_serialAndIndex;
  m_value = Hit->m_queryBodyInfo.m_shapeKey.m_value;
  v46 = *(_DWORD *)Hit->m_queryBodyInfo.m_levelOfDetail;
  v47 = Hit->m_queryBodyInfo.m_filterData.m_materialId.m_value;
  m_collisionFilterInfo = Hit->m_queryBodyInfo.m_filterData.m_collisionFilterInfo;
  m_userData = Hit->m_queryBodyInfo.m_filterData.m_userData;
  v50 = Hit->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
  v51 = Hit->m_hitBodyInfo.m_shapeKey.m_value;
  v52 = *(_DWORD *)Hit->m_hitBodyInfo.m_levelOfDetail;
  v53 = Hit->m_hitBodyInfo.m_filterData.m_materialId.m_value;
  v54 = Hit->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
  v55 = Hit->m_hitBodyInfo.m_filterData.m_userData;
  v56 = 1;
  v57 = Hit->m_rayCastResult.m_value;
  v41.m_quad.m128_f32[3] = 0.0;
  v40.m_quad.m128_f32[3] = 0.0;
  v13 = 0.03125 * start->v[1];
  v14 = 0.03125 * start->v[2];
  v41.m_quad.m128_f32[0] = 0.03125 * start->v[0];
  v41.m_quad.m128_f32[1] = v13;
  v41.m_quad.m128_f32[2] = v14;
  v16 = LODWORD(FLOAT_0_03125);
  *(float *)&v16 = 0.03125 * end->v[1];
  _XMM0 = v16;
  *(float *)&v16 = 0.03125 * end->v[2];
  v40.m_quad.m128_f32[0] = 0.03125 * end->v[0];
  v40.m_quad.m128_f32[1] = *(float *)&_XMM0;
  v40.m_quad.m128_f32[2] = *(float *)&v16;
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v37 = _XMM0;
  v19 = 0.03125 * extendedData->collisionBuffer;
  p_traceCollisionFilter = (const hknpCollisionFilter **)&ConstWorld->traceCollisionFilter;
  v35[1] = (__int64)extendedData->ignoreBodies;
  characterProxyType = extendedData->characterProxyType;
  *(float *)v35 = v19;
  _XMM1 = _mm128_sub_ps(v40.m_quad, v41.m_quad);
  __asm { vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants }
  v36 = characterProxyType;
  __asm { vcmpeqps xmm0, xmm2, xmm7 }
  LODWORD(v38) = extendedData->phaseSelection;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  insideHitType = extendedData->insideHitType;
  __asm
  {
    vandnps xmm1, xmm0, xmm2
    vrcpps  xmm3, xmm1
  }
  query.m_ray.m_direction = (hkVector4f)_XMM1.m_quad;
  __asm { vcmpeqps xmm0, xmm1, xmm7 }
  _XMM3 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM3, _XMM1.m_quad)), _XMM3);
  __asm { vblendvps xmm1, xmm3, xmm4, xmm0 }
  query.m_ray.m_invDirection = (hkVector4f)_XMM1.m_quad;
  query.m_ray.m_origin = (hkVector4f)v41.m_quad;
  if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
  {
    v31 = 4;
  }
  else
  {
    v31 = 0;
    if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
      v31 = 8;
  }
  query.m_flags.m_storage = v31;
  if ( extendedData->disableBackFacingTriangleHits )
    query.m_flags.m_storage = v31 | 1;
  m_collector = this->m_collector;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = *p_traceCollisionFilter;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)v35;
  *(_DWORD *)query.m_levelOfDetail = 0;
  HavokPhysicsHitCollector::SetRaycastDataForModifiers(m_collector, &v41, &v40, &query);
  Collector->addHit(Collector, (const hknpCollisionResult *)v42);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 911, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetAABBQueryHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1011, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 932, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetAABBQueryHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1027, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetAABBQueryHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 994, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 925, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetAABBQueryHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetAABBQueryHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 918, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int AABBQueryHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v17; 
  hknpInplaceTriangleShape v18; 
  hknpShapeCollector v19; 

  v17 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 939, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 946, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    AABBQueryHitBodyId = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, AABBQueryHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 965, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v18, 0.015);
      v19.m_internal.m_shapeBuffer.m_shape = NULL;
      v19.m_internal.m_shapeBuffer.m_buffer = v19.m_internal.m_shapeBuffer.m_storage;
      v19.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v19.m_internal.m_shape = NULL;
      v19.m_parentShape = NULL;
      v19.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v19.m_internal.m_flags.m_storage = 13i64;
      *(__m256i *)v19.m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
      *(__m256i *)v19.m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
      v19.m_internal.m_scale.m_quad = g_vectorfConstants[6];
      v19.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v19);
      if ( (v19.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v19, 0, (hknpTriangleShape *)&v18);
      else
        TriangleShape = (const hknpTriangleShape *)v19.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v19.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v19.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v19.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v19.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v19.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v19.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance
==============
*/
float HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1700, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_fraction * 32.0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1828, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1743, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1844, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1812, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1729, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  const hknpCollisionResult *Hit; 
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1675, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  pos->v[0] = 32.0 * Hit->m_position.m_quad.m128_f32[0];
  pos->v[1] = 32.0 * Hit->m_position.m_quad.m128_f32[1];
  pos->v[2] = 32.0 * Hit->m_position.m_quad.m128_f32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1715, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int ClosestPointHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v17; 
  hknpInplaceTriangleShape v18; 
  hknpShapeCollector v19; 

  v17 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1757, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1764, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    ClosestPointHitBodyId = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, ClosestPointHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1783, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v18, 0.015);
      v19.m_internal.m_shapeBuffer.m_shape = NULL;
      v19.m_internal.m_shapeBuffer.m_buffer = v19.m_internal.m_shapeBuffer.m_storage;
      v19.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v19.m_internal.m_shape = NULL;
      v19.m_parentShape = NULL;
      v19.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v19.m_internal.m_flags.m_storage = 13i64;
      *(__m256i *)v19.m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
      *(__m256i *)v19.m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
      v19.m_internal.m_scale.m_quad = g_vectorfConstants[6];
      v19.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v19);
      if ( (v19.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v19, 0, (hknpTriangleShape *)&v18);
      else
        TriangleShape = (const hknpTriangleShape *)v19.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v19.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v19.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v19.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v19.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v19.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v19.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1891, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1750, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1907, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1875, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1736, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  __m128 v8; 
  int v9; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v9 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1683, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v9, NumHits) )
      __debugbreak();
  }
  _RAX = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  __asm { vbroadcastss xmm1, dword ptr [rax+20h] }
  v8 = _mm128_add_ps(_mm128_mul_ps(_XMM1, _RAX->m_normal.m_quad), _RAX->m_position.m_quad);
  pos->v[0] = v8.m128_f32[0] * 32.0;
  pos->v[1] = _mm_shuffle_ps(v8, v8, 85).m128_f32[0] * 32.0;
  pos->v[2] = _mm_shuffle_ps(v8, v8, 170).m128_f32[0] * 32.0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1722, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetClosestPointHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1860, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return truncate_cast<unsigned int,unsigned __int64>(LODWORD(Hit->m_queryBodyInfo.m_filterData.m_userData));
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetClosestPointHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetClosestPointHitSeparatingNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const hknpCollisionResult *Hit; 
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1691, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  LODWORD(normal->v[0]) = Hit->m_normal.m_quad.m128_i32[0];
  LODWORD(normal->v[1]) = Hit->m_normal.m_quad.m128_i32[1];
  LODWORD(normal->v[2]) = Hit->m_normal.m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHit
==============
*/
hknpCollisionResult *HavokPhysics_CollisionQueryResult::GetHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  __int64 v2; 
  hknpCollisionQueryCollector *Collector; 
  Physics_CollisionQueryCollectionType CollectorType; 
  __int32 v6; 
  unsigned int NumHits; 

  v2 = hitId;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1931, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v2, NumHits) )
      __debugbreak();
  }
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1933, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1935, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  CollectorType = HavokPhysicsHitCollector::GetCollectorType(this->m_collector);
  if ( CollectorType == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ANY )
    return (hknpCollisionResult *)&Collector[1];
  v6 = CollectorType - 1;
  if ( !v6 )
    return (hknpCollisionResult *)&Collector[1];
  if ( v6 == 1 )
    return (hknpCollisionResult *)&Collector->getHits(Collector)[v2];
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1962, ASSERT_TYPE_ASSERT, "(false)", (const char *)&queryFormat, "false") )
    __debugbreak();
  if ( dword_150D5FA34 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
    return &dummy;
  j__Init_thread_header(&dword_150D5FA34);
  if ( dword_150D5FA34 != -1 )
    return &dummy;
  *(__m256i *)dummy.m_position.m_quad.m128_f32 = (__m256i)0i64;
  j__Init_thread_footer(&dword_150D5FA34);
  return &dummy;
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId
==============
*/
__int64 HavokPhysics_BroadphaseCollisionQueryResult::GetHitBodyId(HavokPhysics_BroadphaseCollisionQueryResult *this, unsigned int hitId)
{
  __int64 v2; 

  v2 = (int)hitId;
  if ( hitId >= this->m_hits.m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 851, ASSERT_TYPE_ASSERT, "(hitId < GetNumHits())", (const char *)&queryFormat, "hitId < GetNumHits()") )
    __debugbreak();
  return this->m_hits.m_data[v2].m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetHits
==============
*/
hknpCollisionQueryCollector *HavokPhysics_CollisionQueryResult::GetHits(HavokPhysics_CollisionQueryResult *this)
{
  hknpCollisionQueryCollector *Collector; 
  Physics_CollisionQueryCollectionType CollectorType; 
  __int32 v4; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1974, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1976, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  CollectorType = HavokPhysicsHitCollector::GetCollectorType(this->m_collector);
  if ( CollectorType == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ANY )
    return Collector + 1;
  v4 = CollectorType - 1;
  if ( !v4 )
    return Collector + 1;
  if ( v4 == 1 )
    return (hknpCollisionQueryCollector *)Collector->getHits(Collector);
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2003, ASSERT_TYPE_ASSERT, "(false)", (const char *)&queryFormat, "false") )
    __debugbreak();
  return 0i64;
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits
==============
*/
__int64 HavokPhysics_BroadphaseCollisionQueryResult::GetNumHits(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  return (unsigned int)this->m_hits.m_size;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetNumHits
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetNumHits(HavokPhysics_CollisionQueryResult *this)
{
  hknpCollisionQueryCollector *Collector; 
  Physics_CollisionQueryCollectionType CollectorType; 
  unsigned int m_numHits; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 867, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 869, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  CollectorType = HavokPhysicsHitCollector::GetCollectorType(this->m_collector);
  m_numHits = Collector->m_numHits;
  if ( CollectorType == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL )
    return m_numHits;
  else
    return m_numHits != 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastBackfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_rayCastResult.m_value & 1;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastFrontfaceHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return (HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_rayCastResult.m_value & 2) != 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1075, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1214, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1096, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitCoverWallId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  unsigned int m_value; 
  hknpWorld *world; 
  unsigned int RaycastHitBodyId; 
  __int64 v7; 
  hknpBodyId v8; 
  int Ref; 
  __int64 v10; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1159, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
    return 0xFFFFi64;
  world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1169, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
    __debugbreak();
  RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, RaycastHitBodyId);
  v8.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
  Ref = HavokPhysics_GetRef(this->m_worldId, v8);
  if ( !PhysicsCoverWall_IsCoverWall(this->m_worldId, Ref) )
    return 0xFFFFi64;
  v10 = *(_QWORD *)(v7 + 96);
  if ( *(_BYTE *)(v10 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1180, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::COMPOUND") )
    __debugbreak();
  return (unsigned __int16)(m_value >> (32 - *(_BYTE *)(v10 + 27)));
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1231, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitFraction
==============
*/
float HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1068, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_fraction;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetRaycastHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1197, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1089, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const hknpCollisionResult *Hit; 
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1058, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  LODWORD(normal->v[0]) = Hit->m_normal.m_quad.m128_i32[0];
  LODWORD(normal->v[1]) = Hit->m_normal.m_quad.m128_i32[1];
  LODWORD(normal->v[2]) = Hit->m_normal.m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  const hknpCollisionResult *Hit; 
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1051, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  pos->v[0] = 32.0 * Hit->m_position.m_quad.m128_f32[0];
  pos->v[1] = 32.0 * Hit->m_position.m_quad.m128_f32[1];
  pos->v[2] = 32.0 * Hit->m_position.m_quad.m128_f32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetRaycastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetRaycastHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1082, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int RaycastHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v17; 
  hknpInplaceTriangleShape v18; 
  hknpShapeCollector v19; 

  v17 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1103, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1111, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, RaycastHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1130, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v18, 0.015);
      v19.m_internal.m_shapeBuffer.m_shape = NULL;
      v19.m_internal.m_shapeBuffer.m_buffer = v19.m_internal.m_shapeBuffer.m_storage;
      v19.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v19.m_internal.m_shape = NULL;
      v19.m_parentShape = NULL;
      v19.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v19.m_internal.m_flags.m_storage = 13i64;
      *(__m256i *)v19.m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
      *(__m256i *)v19.m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
      v19.m_internal.m_scale.m_quad = g_vectorfConstants[6];
      v19.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v19);
      if ( (v19.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v19, 0, (hknpTriangleShape *)&v18);
      else
        TriangleShape = (const hknpTriangleShape *)v19.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v19.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v19.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v19.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v19.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v19.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v19.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetRaycastInternalHit
==============
*/
bool HavokPhysics_CollisionQueryResult::GetRaycastInternalHit(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  return (HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_rayCastResult.m_value & 4) != 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1452, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitContactPosition(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *pos)
{
  const hknpCollisionResult *Hit; 
  int v7; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v7 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1274, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  pos->v[0] = 32.0 * Hit->m_position.m_quad.m128_f32[0];
  pos->v[1] = 32.0 * Hit->m_position.m_quad.m128_f32[1];
  pos->v[2] = 32.0 * Hit->m_position.m_quad.m128_f32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitFraction
==============
*/
float HavokPhysics_CollisionQueryResult::GetShapecastHitFraction(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1445, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_fraction;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitHitBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1572, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitHitContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const hknpCollisionResult *Hit; 
  __int64 v7; 
  unsigned int NumHits; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1281, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    LODWORD(v7) = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1282, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v7, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  LODWORD(normal->v[0]) = Hit->m_normal.m_quad.m128_i32[0];
  LODWORD(normal->v[1]) = Hit->m_normal.m_quad.m128_i32[1];
  LODWORD(normal->v[2]) = Hit->m_normal.m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitHitContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1487, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitHitDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1588, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetShapecastHitHitGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1556, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitHitMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1473, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitHitShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1459, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpWorld *world; 
  unsigned int ShapecastHitBodyId; 
  unsigned __int64 v6; 
  unsigned __int64 m_userData; 
  hknpWorld *v8; 
  unsigned int v9; 
  __int64 v10; 
  const hknpTriangleShape *TriangleShape; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  unsigned int NumHits; 
  unsigned int m_value; 
  __int64 v17; 
  hknpInplaceTriangleShape v18; 
  hknpShapeCollector v19; 

  v17 = -2i64;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1501, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", hitId, NumHits) )
      __debugbreak();
  }
  m_value = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_shapeKey.m_value;
  if ( m_value == -1 )
  {
    world = HavokPhysics_GetConstWorld(this->m_worldId)->world;
    if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1508, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
      __debugbreak();
    ShapecastHitBodyId = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(this, hitId);
    v6 = *(unsigned int *)(*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, ShapecastHitBodyId) + 96) + 40i64);
  }
  else
  {
    m_userData = HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_hitBodyInfo.m_filterData.m_userData;
    if ( !m_userData )
    {
      v8 = HavokPhysics_GetConstWorld(this->m_worldId)->world;
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1527, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
        __debugbreak();
      v9 = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(this, hitId);
      v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v8->getBody)(&v8->hknpWorldReader, v9);
      hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v18, 0.015);
      v19.m_internal.m_shapeBuffer.m_shape = NULL;
      v19.m_internal.m_shapeBuffer.m_buffer = v19.m_internal.m_shapeBuffer.m_storage;
      v19.m_internal.m_shapeBuffer.m_bufferSize = 2048;
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
      v19.m_internal.m_shape = NULL;
      v19.m_parentShape = NULL;
      v19.m_shapeTagPath.m_size = 0;
      *(_QWORD *)&v19.m_internal.m_flags.m_storage = 13i64;
      *(__m256i *)v19.m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
      *(__m256i *)v19.m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
      v19.m_internal.m_scale.m_quad = g_vectorfConstants[6];
      v19.m_internal.m_shapeTags[0] = -1;
      (*(void (__fastcall **)(_QWORD, unsigned int *, __int64, hknpShapeCollector *))(**(_QWORD **)(v10 + 96) + 176i64))(*(_QWORD *)(v10 + 96), &m_value, 1i64, &v19);
      if ( (v19.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v19, 0, (hknpTriangleShape *)&v18);
      else
        TriangleShape = (const hknpTriangleShape *)v19.m_internal.m_shape;
      m_userData = TriangleShape->m_userData;
      if ( v19.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v19.m_shapeTagPath.m_data[0].m_shape;
        m_size = (unsigned int)v19.m_shapeTagPath.m_size;
        do
        {
          m_userData |= (*p_m_shape)->m_userData;
          p_m_shape += 4;
          --m_size;
        }
        while ( m_size );
      }
      v19.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
      if ( v19.m_internal.m_shapeBuffer.m_shape )
        ((void (__fastcall *)(hknpShape *, _QWORD))v19.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v19.m_internal.m_shapeBuffer.m_shape, 0i64);
    }
    v6 = (unsigned int)m_userData;
  }
  return truncate_cast<unsigned int,unsigned __int64>(v6);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitQueryBrushBasis(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1635, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetBrushBasisFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContactNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  int v11; 
  unsigned int NumHits; 

  _RSI = normal;
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v11 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1293, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v11, NumHits) )
      __debugbreak();
  }
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vpinsrw xmm0, xmm0, ecx, 1
    vpshufd xmm2, xmm0, 40h ; '@'
  }
  _XMM3 = _XMM2 ^ *(_OWORD *)&HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_normal;
  _RSI->v[0] = *(float *)&_XMM3;
  __asm
  {
    vextractps dword ptr [rsi+4], xmm3, 1
    vextractps dword ptr [rsi+8], xmm3, 2
  }
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryContents(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1494, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType
==============
*/
bool HavokPhysics_CollisionQueryResult::GetShapecastHitQueryDecalType(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1651, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetDecalTypeFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId
==============
*/
unsigned __int16 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryGlassId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1619, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return Physics_GetGlassIdFromUserData(Hit->m_queryBodyInfo.m_filterData.m_userData);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryMaterialId(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1480, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_filterData.m_materialId.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey
==============
*/
__int64 HavokPhysics_CollisionQueryResult::GetShapecastHitQueryShapeKey(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  int v5; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v5 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1466, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v5, NumHits) )
      __debugbreak();
  }
  return HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value;
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags
==============
*/
unsigned int HavokPhysics_CollisionQueryResult::GetShapecastHitQuerySurfFlags(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  const hknpCollisionResult *Hit; 
  int v6; 
  unsigned int NumHits; 

  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    v6 = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1604, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v6, NumHits) )
      __debugbreak();
  }
  if ( HavokPhysics_CollisionQueryResult::GetHit(this, hitId)->m_queryBodyInfo.m_shapeKey.m_value == -1 )
    return 0;
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  return truncate_cast<unsigned int,unsigned __int64>(LODWORD(Hit->m_queryBodyInfo.m_filterData.m_userData));
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitRef
==============
*/
int HavokPhysics_CollisionQueryResult::GetShapecastHitRef(HavokPhysics_CollisionQueryResult *this, int hitId)
{
  hknpBodyId v3; 

  v3.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(this, hitId);
  return HavokPhysics_GetRef(this->m_worldId, v3);
}

/*
==============
HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal
==============
*/
void HavokPhysics_CollisionQueryResult::GetShapecastHitSurfaceNormal(HavokPhysics_CollisionQueryResult *this, int hitId, vec3_t *normal)
{
  const hknpCollisionResult *Hit; 
  const HavokPhysicsWorld *ConstWorld; 
  hkTransformf *v8; 
  const hknpTriangleShape *TriangleShape; 
  int v10; 
  unsigned int v11; 
  char v23; 
  unsigned __int16 m_storage; 
  hknpTriangleShape *v25; 
  int m_size; 
  hknpConvexShape *v27; 
  __m128 *v30; 
  int v34; 
  unsigned __int16 v35; 
  __m128 *v36; 
  __int64 v40; 
  unsigned int NumHits; 
  float zero; 
  unsigned int m_value; 
  hkStridedVertices verticesInOrg; 
  __int64 v45; 
  hknpConvexShape::BuildConfig configInOrg; 
  __m128 v47; 
  hkVector4f v48; 
  hkVector4f v49; 
  hkVector4f b; 
  hkTransformf v51; 
  hkTransformf a; 
  hknpShapeCollector v53; 
  hknpInplaceTriangleShape v54; 

  v45 = -2i64;
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1305, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  if ( hitId >= HavokPhysics_CollisionQueryResult::GetNumHits(this) )
  {
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(this);
    LODWORD(v40) = hitId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1306, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v40, NumHits) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(this, hitId);
  ConstWorld = HavokPhysics_GetConstWorld(this->m_worldId);
  v8 = (hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, Hit->m_hitBodyInfo.m_bodyId.m_serialAndIndex);
  TriangleShape = (const hknpTriangleShape *)v8[1].m_rotation.m_col2.m_quad.m128_u64[0];
  v51 = *v8;
  m_value = Hit->m_hitBodyInfo.m_shapeKey.m_value;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v54, 0.015);
  v10 = 0;
  v53.m_internal.m_shapeBuffer.m_shape = NULL;
  v53.m_internal.m_shapeBuffer.m_buffer = v53.m_internal.m_shapeBuffer.m_storage;
  v53.m_internal.m_shapeBuffer.m_bufferSize = 2048;
  v53.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
  v53.m_internal.m_shapeTags[0] = -1;
  v53.m_internal.m_shape = NULL;
  v53.m_parentShape = NULL;
  v53.m_shapeTagPath.m_size = 0;
  *(_QWORD *)&v53.m_internal.m_flags.m_storage = 8i64;
  v53.m_transform = v51;
  v53.m_internal.m_scale.m_quad = g_vectorfConstants[6];
  zero = FLOAT_1_1920929eN7;
  if ( hkMatrix3Impl<float>::isApproximatelyEqual(&v51.m_rotation, (const hkMatrix3Impl<float> *)&g_vectorfConstants[32], &zero) )
  {
    v11 = v53.m_internal.m_flags.m_storage | 4;
    v53.m_internal.m_flags.m_storage |= 4u;
    b.m_quad = g_vectorfConstants[38];
    _XMM0.m_quad = (__m128)v51.m_translation;
    _mm128_sub_ps(v51.m_translation.m_quad, g_vectorfConstants[5]);
    _XMM1 = *(_OWORD *)hkMath::hkSse_signMask;
    __asm
    {
      vandnps xmm3, xmm1, xmm2
      vcmpleps xmm5, xmm3, xmm4
    }
    _XMM2 = 0i64;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vpcmpeqd xmm1, xmm0, xmm0
      vblendps xmm2, xmm2, xmm1, 7
      vpand   xmm0, xmm5, xmm2
      vptest  xmm0, xmm2
    }
    if ( _CF )
      v53.m_internal.m_flags.m_storage = v11 | 1;
  }
  v53.m_internal.m_shapeTags[0] = -1;
  a = v51;
  if ( m_value != -1 )
  {
    TriangleShape->getLeafShapes(&TriangleShape->hknpConvexPolytopeShape, (const hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> *)&m_value, 1, &v53);
    if ( (v53.m_internal.m_flags.m_storage & 0x10) != 0 )
      TriangleShape = hknpShapeCollector::getTriangleShape(&v53, 0, (hknpTriangleShape *)&v54);
    else
      TriangleShape = (const hknpTriangleShape *)v53.m_internal.m_shape;
    a = v53.m_transform;
  }
  v23 = 0;
  if ( TriangleShape->m_type.m_storage == 17 )
    TriangleShape = *(const hknpTriangleShape **)&TriangleShape->m_maxAllowedPenetration.m_value;
  m_storage = TriangleShape->m_flags.m_storage;
  v25 = (hknpTriangleShape *)TriangleShape;
  if ( (m_storage & 2) == 0 )
    v25 = NULL;
  if ( !v25 )
  {
    if ( (m_storage & 1) == 0 )
      TriangleShape = NULL;
    if ( !TriangleShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1354, ASSERT_TYPE_ASSERT, "(convexShape)", (const char *)&queryFormat, "convexShape") )
      __debugbreak();
    if ( (TriangleShape->m_flags.m_storage & 0x10) != 0 )
    {
      v25 = NULL;
      v48.m_quad = (__m128)Hit->m_normal;
      goto LABEL_38;
    }
    v23 = 1;
    m_size = TriangleShape->m_vertices.m_size;
    verticesInOrg.m_vertices = (const float *)((char *)&TriangleShape->m_vertices.m_size + TriangleShape->m_vertices.m_offset);
    verticesInOrg.m_numVertices = m_size;
    verticesInOrg.m_striding = 16;
    hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
    configInOrg.m_buildMassProperties.m_bool = 0;
    configInOrg.m_featurePreservationFactor = FLOAT_1_0;
    configInOrg.m_shrinkByRadius.m_bool = 0;
    configInOrg.m_simplificationTolerance = 0.0;
    v27 = hknpConvexShape::createFromVertices(&verticesInOrg, 0.015, &configInOrg);
    v25 = NULL;
    if ( (v27->m_flags.m_storage & 2) != 0 )
      v25 = (hknpTriangleShape *)v27;
    hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
    if ( !v25 )
    {
      v48.m_quad = (__m128)Hit->m_normal;
      goto LABEL_38;
    }
  }
  b.m_quad = (__m128)Hit->m_position;
  hkVector4f::setTransformedInversePos(&v49, &a, &b);
  _XMM0 = v49.m_quad;
  __asm { vblendps xmm3, xmm0, cs:__xmm@3f8000003f8000003f8000003f800000, 8 }
  v49.m_quad = _XMM3;
  v30 = (__m128 *)((char *)&v25->m_planes + v25->m_planes.m_offset);
  v47 = *v30;
  _mm_shuffle_ps(v47, v47, 255);
  _XMM1 = v47;
  __asm { vinsertps xmm1, xmm1, xmm0, 30h ; '0' }
  v47 = _XMM1;
  __asm { vdpps   xmm2, xmm1, xmm3, 0FFh }
  if ( (v25->m_flags.m_storage & 0x200) == 0 )
  {
    v34 = 1;
    v35 = v25->m_planes.m_size;
    if ( v35 > 1u )
    {
      v36 = v30 + 1;
      do
      {
        v47 = *v36;
        _mm_shuffle_ps(v47, v47, 255);
        _XMM1 = v47;
        __asm { vinsertps xmm1, xmm1, xmm0, 30h ; '0' }
        v47 = _XMM1;
        __asm { vdpps   xmm0, xmm1, xmm3, 0FFh }
        if ( *(float *)&_XMM0 > *(float *)&_XMM2 )
        {
          v10 = v34;
          LODWORD(_XMM2) = _XMM0;
        }
        ++v34;
        ++v36;
      }
      while ( v34 < v35 );
    }
  }
  hkVector4f::setRotatedDir(&v48, &a.m_rotation, (const hkVector4f *)&v30[v10]);
LABEL_38:
  if ( v23 && v25 )
    ((void (__fastcall *)(hknpTriangleShape *, __int64))v25->~hkBaseObject)(v25, 1i64);
  normal->v[0] = v48.m_quad.m128_f32[0];
  normal->v[1] = v48.m_quad.m128_f32[1];
  normal->v[2] = v48.m_quad.m128_f32[2];
  v53.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
  if ( v53.m_internal.m_shapeBuffer.m_shape )
    ((void (__fastcall *)(hknpShape *, _QWORD))v53.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v53.m_internal.m_shapeBuffer.m_shape, 0i64);
}

/*
==============
HavokPhysics_CollisionQueryResult::HasHit
==============
*/
bool HavokPhysics_CollisionQueryResult::HasHit(HavokPhysics_CollisionQueryResult *this)
{
  hknpCollisionQueryCollector *Collector; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 858, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 860, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
  return Collector->m_numHits != 0;
}

/*
==============
HavokPhysics_AABBBroadphaseQuery
==============
*/
void HavokPhysics_AABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  const HavokPhysicsWorld *ConstWorld; 
  __m256i v9; 
  __int64 traceCollisionFilter; 
  hkMonitorStream *Value; 
  hkMonitorStream *v12; 
  float v13; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v15; 
  __int128 v16; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v18[2]; 
  __int16 v19; 
  int contents; 
  float *v21; 
  int v22; 
  char v23; 
  __m256i v24; 

  ignoreBodies = NULL;
  v15 = 1;
  phaseSelection = All;
  v23 = -5;
  v13 = 0.0;
  v16 = 0i64;
  *(__m128 *)v24.m256i_i8 = g_vectorfConstants[36];
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13758, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13759, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13760, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid result", "result") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v9 = *(__m256i *)aabb;
  ignoreBodies = extendedData->ignoreBodies;
  phaseSelection = extendedData->phaseSelection;
  v18[0] = (__int64)s_shapeTagCodec;
  v24 = v9;
  traceCollisionFilter = (__int64)ConstWorld->traceCollisionFilter;
  v19 = -1;
  contents = extendedData->contents;
  v18[1] = traceCollisionFilter;
  v21 = &v13;
  v22 = 0;
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtQueryBroadphaseAABB_HK");
  ConstWorld->world->queryAabb(&ConstWorld->world->hknpWorldReader, (const hknpAabbQuery *)v18, &result->m_hits);
  v12 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v12 )
    hkMonitorStream::timerEnd(v12, "Et");
}

/*
==============
HavokPhysics_AABBQuery
==============
*/
void HavokPhysics_AABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v16; 
  const hknpShape *v17; 
  hkVector4f v18; 
  __m128 v19; 
  __m128 v20; 
  __m128 v32; 
  hkVector4f v44; 
  hkVector4f v45; 
  hkMonitorStream *Value; 
  hkMonitorStream *v47; 
  hkMonitorStream *v48; 
  hkMonitorStream *v51; 
  __int64 v52; 
  __int128 v53; 
  __int16 v54; 
  int contents; 
  float *v56; 
  hknpCollisionQueryDispatcher *m_collisionQueryDispatcher; 
  hkReferencedObject *v58; 
  hkReferencedObject *v59; 
  float v60; 
  int v61; 
  __int128 v62; 
  float v63; 
  __int64 v64; 
  int v65; 
  __int128 v66; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v68; 
  hkMonitorStream *v69; 
  hkErrStream v70; 
  __int128 v71; 
  __int64 v72; 
  int v73; 
  int v74; 
  __int128 v75; 
  char v76; 
  int v77; 
  float v78; 
  __int128 v79; 
  __int128 v80; 
  __int64 v81[2]; 
  __int16 v82; 
  int v83; 
  __int64 v84; 
  int v85; 
  char v86; 
  hkAabb v87; 
  __int128 v88; 
  __int64 v89; 
  int v90; 
  int v91; 
  __int128 v92; 
  char v93; 
  int v94; 
  float v95; 
  __int128 v96; 
  __int128 v97; 
  hknpInplaceTriangleShape v98; 
  char buf[512]; 

  v68 = -2i64;
  v63 = 0.0;
  v64 = 0i64;
  v65 = 1;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v66 = _XMM0;
  phaseSelection = All;
  v54 = -1;
  contents = 0;
  v56 = NULL;
  _XMM1 = 0i64;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v98, 0.0);
  m_collisionQueryDispatcher = NULL;
  v58 = (hkReferencedObject *)&v98;
  v59 = (hkReferencedObject *)&v98;
  v60 = 0.0;
  v61 = 1;
  v73 = -1;
  v74 = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v71 = _XMM0;
  v72 = 0i64;
  __asm { vpxor   xmm1, xmm1, xmm1 }
  v75 = _XMM1;
  v76 = 0;
  v79 = _xmm;
  v77 = 0;
  v80 = 0i64;
  v78 = 0.0;
  LOWORD(v53) = -1;
  DWORD1(v53) = 0;
  *((_QWORD *)&v53 + 1) = 0i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14592, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v52) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14593, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid body id %i", "bodyId.isValid()", v52) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14594, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14595, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire aabb query with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14596, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire aabb query with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14597, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14598, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire aabb query with body with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14601, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v16 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v17 = *(const hknpShape **)(v16 + 96);
  v63 = extendedData->collisionBuffer * 0.03125;
  phaseSelection = extendedData->phaseSelection;
  v54 = -1;
  contents = extendedData->contents;
  v56 = &v63;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, QUERY_AABB, (const hknpQueryFilterData *)&v54, (const hknpBody *)v16) )
  {
    m_collisionQueryDispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    v18.m_quad = (__m128)aabb->m_max;
    v19 = _mm128_mul_ps(_mm128_add_ps(v18.m_quad, aabb->m_min.m_quad), g_vectorfConstants[21]);
    v20 = _mm128_mul_ps(_mm128_sub_ps(v18.m_quad, aabb->m_min.m_quad), g_vectorfConstants[21]);
    _XMM1 = *(_OWORD *)v16;
    __asm
    {
      vunpcklps xmm2, xmm1, xmm0
      vunpckhps xmm0, xmm1, xmm0
      vblendps xmm7, xmm0, xmm3, 0Ch
      vmovlhps xmm4, xmm2, xmm3
      vmovhlps xmm0, xmm4, xmm2
    }
    _mm128_mul_ps(_mm_shuffle_ps(v20, v20, 0), _XMM4);
    _XMM2 = *(_OWORD *)hkMath::hkSse_signMask;
    __asm { vandnps xmm4, xmm2, xmm0 }
    _mm128_mul_ps(_mm_shuffle_ps(_XMM0, *(__m128 *)(v16 + 32), 212), _mm_shuffle_ps(v20, v20, 85));
    __asm { vandnps xmm3, xmm2, xmm0 }
    _XMM1 = _mm128_mul_ps(_XMM7, _mm_shuffle_ps(v20, v20, 170));
    __asm { vandnps xmm2, xmm2, xmm1 }
    v32 = _mm128_add_ps(_mm128_add_ps(_XMM3, _XMM4), _XMM2);
    __asm
    {
      vpxor   xmm1, xmm1, xmm1
      vpinsrw xmm0, xmm1, eax, 1
      vpshufd xmm6, xmm0, 0
    }
    _mm128_sub_ps(v19, *(__m128 *)(v16 + 48));
    _XMM0 = *(_OWORD *)v16;
    _XMM1 = *(_OWORD *)(v16 + 16);
    _XMM3 = *(_OWORD *)(v16 + 32);
    __asm
    {
      vdpps   xmm4, xmm0, xmm5, 71h ; 'q'
      vdpps   xmm2, xmm1, xmm5, 72h ; 'r'
      vdpps   xmm3, xmm3, xmm5, 74h ; 't'
    }
    _XMM1 = (__m128)(_XMM3 | _XMM2 | _XMM4);
    _XMM0 = *(_OWORD *)&v32 ^ _XMM6;
    v44.m_quad = _mm128_add_ps((__m128)(*(_OWORD *)&v32 ^ _XMM6), _XMM1);
    v45.m_quad = _mm128_add_ps(_XMM1, v32);
    *(_QWORD *)&v71 = v16;
    *((_QWORD *)&v71 + 1) = *(_QWORD *)(v16 + 96);
    *(_QWORD *)&v75 = v16;
    LOWORD(v53) = *(_WORD *)(v16 + 106);
    DWORD1(v53) = *(_DWORD *)(v16 + 108);
    *((_QWORD *)&v53 + 1) = *(_QWORD *)(v16 + 160);
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, QUERY_AABB, (const hknpBody *)v16, v17, (hknpQueryFilterData *)&v53);
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtQueryAABB_Body_HK");
    v82 = -1;
    v83 = 0;
    v84 = 0i64;
    v81[1] = 0i64;
    v81[0] = 0i64;
    v85 = 2;
    v86 = -5;
    v87.m_min = (hkVector4f)v44.m_quad;
    v87.m_max = (hkVector4f)v45.m_quad;
    v47 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v48 = v47;
    if ( v47 )
      hkMonitorStream::timerBegin(v47, "TtQueryAabb");
    v69 = v48;
    if ( hkAabb::isValid(&v87) )
    {
      v90 = -1;
      v91 = 0;
      __asm { vpxor   xmm0, xmm0, xmm0 }
      v88 = _XMM0;
      v89 = 0i64;
      __asm { vpxor   xmm1, xmm1, xmm1 }
      v92 = _XMM1;
      v93 = 0;
      v96 = _xmm;
      v94 = 0;
      v97 = 0i64;
      v95 = 0.0;
      v62 = v53;
      if ( v81[0] && (*(_BYTE *)(v81[0] + 24) & 1) != 0 )
        (*(void (__fastcall **)(__int64, __int64, _QWORD, const hknpShape *, __int128 *))(*(_QWORD *)v81[0] + 24i64))(v81[0], 5i64, v71, v17, &v62);
      v17->queryAabbImpl((hknpShape *)v17, (hknpCollisionQueryContext *)&m_collisionQueryDispatcher, (const hknpAabbQuery *)v81, (const hknpShapeQueryInfo *)&v88, (const hknpQueryFilterData *)&v62, (const hknpShapeQueryInfo *)&v71, Collector, NULL);
      if ( v48 )
        hkMonitorStream::timerEnd(v48, "Et");
    }
    else
    {
      hkErrStream::hkErrStream(&v70, buf, 512);
      hkOstream::operator<<(&v70, "Invalid AABB query. Please check your input AABB.");
      hkErrorFwd::messageWarning(-1357677090, buf, "c:\\workspace\\iw8\\shared\\codware\\sdk\\havok\\hk2018_2_0_r1\\source\\physics\\physics\\collide\\shape\\hknpshapequeryinterface.inl", 215);
      hkErrStream::~hkErrStream(&v70);
      if ( v48 )
        hkMonitorStream::timerEnd(v48, "Et");
    }
    v51 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v51 )
      hkMonitorStream::timerEnd(v51, "Et");
    if ( !v61 )
    {
      hkReferencedObject::removeReference(v58);
      hkReferencedObject::removeReference(v59);
    }
  }
  else if ( !v61 )
  {
    hkReferencedObject::removeReference(v58);
    hkReferencedObject::removeReference(v59);
  }
}

/*
==============
HavokPhysics_AABBQuery
==============
*/
void HavokPhysics_AABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 *ConstWorld; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v11; 
  __int64 NumHits; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v14; 
  int v15; 
  int v16; 
  __m256i *v17; 
  __int64 v18; 
  signed __int64 v19; 
  hknpBodyId *i; 
  int Ref; 
  int v22; 
  unsigned int v23; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v25; 
  __int64 v26; 
  __int64 v27; 
  hknpBodyId *array; 
  int v29; 
  int v30; 
  float v31; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v33; 
  __int128 v34; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v36; 
  __int64 v37[2]; 
  __int16 v38; 
  int contents; 
  float *v40; 
  int v41; 
  char v42; 
  __m256i v43; 

  v36 = -2i64;
  v31 = 0.0;
  ignoreBodies = NULL;
  v33 = 1;
  v34 = 0i64;
  phaseSelection = All;
  v42 = -5;
  *(__m128 *)v43.m256i_i8 = g_vectorfConstants[36];
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13830, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13831, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13832, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid result", "result") )
    __debugbreak();
  ConstWorld = (__int64 *)HavokPhysics_GetConstWorld(worldId);
  ignoreBodies = extendedData->ignoreBodies;
  v31 = extendedData->collisionBuffer * 0.03125;
  phaseSelection = extendedData->phaseSelection;
  v43 = *(__m256i *)aabb;
  v37[0] = (__int64)s_shapeTagCodec;
  v37[1] = *ConstWorld;
  v38 = -1;
  contents = extendedData->contents;
  v40 = &v31;
  v41 = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13852, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13855, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire aabb query with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtQueryAABB_HK");
  (*(void (__fastcall **)(__int64, __int64 *, hknpCollisionQueryCollector *))(*(_QWORD *)(ConstWorld[3] + 32) + 296i64))(ConstWorld[3] + 32, v37, Collector);
  v11 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v11 )
    hkMonitorStream::timerEnd(v11, "Et");
  if ( extendedData->simplify )
  {
    array = NULL;
    v29 = 0;
    v30 = 0x80000000;
    NumHits = (int)HavokPhysics_CollisionQueryResult::GetNumHits(result);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(result);
    v14 = hkMemHeapAllocator();
    v15 = 0;
    if ( (int)NumHits > 0 )
    {
      v16 = NumHits;
      if ( (int)NumHits < 0 )
        v16 = 0;
      hkArrayUtil::_reserve(v14, &array, v16, 112);
      v15 = v29;
    }
    v17 = (__m256i *)&array[28 * v15];
    v18 = NumHits;
    if ( (int)NumHits > 0 )
    {
      v19 = (char *)Hits - (char *)v17;
      do
      {
        if ( v17 )
        {
          *v17 = *(__m256i *)((char *)v17 + v19);
          v17[1] = *(__m256i *)((char *)&v17[1] + v19);
          v17[2] = *(__m256i *)((char *)&v17[2] + v19);
          *(_OWORD *)v17[3].m256i_i8 = *(_OWORD *)&v17[3].m256i_i8[v19];
        }
        v17 = (__m256i *)((char *)v17 + 112);
        --v18;
      }
      while ( v18 );
    }
    v29 = NumHits;
    Collector->reset(Collector);
    for ( i = array; i != &array[28 * v29]; i += 28 )
    {
      Ref = HavokPhysics_GetRef(result->m_worldId, i[18]);
      v22 = HavokPhysics_CollisionQueryResult::GetNumHits(result);
      v23 = 0;
      if ( v22 <= 0 )
      {
LABEL_37:
        Collector->addHit(Collector, (const hknpCollisionResult *)i);
      }
      else
      {
        while ( 1 )
        {
          if ( v23 >= HavokPhysics_CollisionQueryResult::GetNumHits(result) )
          {
            LODWORD(v27) = HavokPhysics_CollisionQueryResult::GetNumHits(result);
            LODWORD(v26) = v23;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 911, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v26, v27) )
              __debugbreak();
          }
          Hit = HavokPhysics_CollisionQueryResult::GetHit(result, v23);
          if ( HavokPhysics_GetRef(result->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
            break;
          if ( (int)++v23 >= v22 )
            goto LABEL_37;
        }
      }
    }
    v25 = hkMemHeapAllocator();
    v29 = 0;
    if ( v30 >= 0 )
      hkMemoryAllocator::bufFree2(v25, array, 112, v30 & 0x3FFFFFFF);
  }
}

/*
==============
HavokPhysics_AccumulateAngularImpulse
==============
*/
void HavokPhysics_AccumulateAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *impulseWs, const hkVector4f *atPointWs, hkVector4f *outAngularVelWs)
{
  hknpWorld *world; 
  __int64 v10; 
  hknpMotion *v11; 
  __m128 v12; 
  __m128 v13; 
  __m128 v14; 
  __int64 v15; 
  hkMatrix3Impl<float> invInertiaOut; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11807, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to accumulate angular impulse from rigid body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v15) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11808, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to accumulate angular impulse from rigid body with invalid body id for world %i", "bodyId.isValid()", v15) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v15) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11813, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics AccumulateAngularImpulse %i: world is NULL", "world", v15) )
      __debugbreak();
  }
  v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v10 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11817, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  v11 = (hknpMotion *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getMotion)(&world->hknpWorldReader, *(unsigned int *)(v10 + 64));
  v12 = _mm128_sub_ps(atPointWs->m_quad, v11->m_centerOfMass.m_quad);
  v13 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(impulseWs->m_quad, impulseWs->m_quad, 201), v12), _mm128_mul_ps(_mm_shuffle_ps(v12, v12, 201), impulseWs->m_quad));
  v14 = _mm_shuffle_ps(v13, v13, 201);
  hknpMotion::getInverseInertiaWorld(v11, &invInertiaOut);
  outAngularVelWs->m_quad = _mm128_add_ps(_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v14, v14, 85), invInertiaOut.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v14, v14, 0), invInertiaOut.m_col0.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v14, v14, 170), invInertiaOut.m_col2.m_quad)), outAngularVelWs->m_quad);
}

/*
==============
HavokPhysics_ActivateBody
==============
*/
void HavokPhysics_ActivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13176, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to activate a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13177, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to activate a body with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD))MutableWorld->world->setBodyActivationState)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 0i64);
}

/*
==============
HavokPhysics_AddBodyQualityLibraryToWorld
==============
*/
void HavokPhysics_AddBodyQualityLibraryToWorld(HavokPhysicsBodyQualityLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hknpWorld *world; 
  unsigned __int8 v7; 
  HavokPhysicsBodyQualityList *list; 
  hknpBodyQuality *m_data; 
  hknpBodyQualityLibrary *m_ptr; 
  unsigned __int64 m_ptrAndInt; 
  unsigned __int64 *p_m_qualityModifiedSignal; 
  _QWORD *v13; 
  unsigned __int64 *v14; 
  unsigned __int64 v15; 
  __int64 v16; 
  hknpWorld *v17; 
  __int64 m_size; 
  unsigned int *v19; 
  __int64 v20; 
  HavokPhysicsWorld *v22; 
  _RTL_CRITICAL_SECTION *v23; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6456, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Add Body Quality Library to world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v20) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6464, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Add Body Quality Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v20) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    v22 = MutableWorld;
    p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    v23 = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getBodyQualityLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v20) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6476, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getBodyQualityLibrary())", "%s\n\tHavokPhysics: Trying to Add Body Quality Library with world index %i, but can't find world library to add to", "havokPhysicsWorld->world->getBodyQualityLibrary()", v20) )
          __debugbreak();
      }
      v7 = 16;
      list = library->list;
      m_data = list->m_bodyQualitys.m_data;
      if ( list->m_bodyQualitys.m_data != &list->m_bodyQualitys.m_data[list->m_bodyQualitys.m_size] )
      {
        do
        {
          m_ptr = MutableWorld->world->m_qualityLibrary.m_ptr;
          if ( hkString::memCmp(&m_ptr->m_qualities[v7].m_priority, &m_data->m_priority, 24) )
          {
            hkPropertyBag::operator=(&m_ptr->m_qualities[v7].m_propertyBag, &m_data->m_propertyBag);
            m_ptr->m_qualities[v7].m_priority = m_data->m_priority;
            m_ptr->m_qualities[v7].m_supportedFlags.m_storage = m_data->m_supportedFlags.m_storage;
            m_ptr->m_qualities[v7].m_requestedFlags.m_storage = m_data->m_requestedFlags.m_storage;
            m_ptr->m_qualities[v7].m_contactCachingRelativeMovementThreshold = m_data->m_contactCachingRelativeMovementThreshold;
            m_ptr->m_qualities[v7].m_motionRangeBreachPolicy = m_data->m_motionRangeBreachPolicy;
            m_ptr->m_qualities[v7].m_motionWeldBreachPolicy = m_data->m_motionWeldBreachPolicy;
            m_ptrAndInt = (unsigned __int64)m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64 | 1;
            m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt = (hkSlot *)m_ptrAndInt;
            p_m_qualityModifiedSignal = (unsigned __int64 *)&m_ptr->m_qualityModifiedSignal;
            v13 = (_QWORD *)(m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64);
            if ( (m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64) != 0 )
            {
              do
              {
                v14 = v13 + 1;
                v15 = v13[1] & 0xFFFFFFFFFFFFFFFCui64;
                v16 = *v13;
                if ( (v13[1] & 3) != 0 )
                {
                  (*(void (__fastcall **)(_QWORD *, __int64))v16)(v13, 1i64);
                  *p_m_qualityModifiedSignal = v15 | *(_DWORD *)p_m_qualityModifiedSignal & 3;
                }
                else
                {
                  (*(void (__fastcall **)(_QWORD *, hknpBodyQualityLibrary *, _QWORD))(v16 + 16))(v13, m_ptr, v7);
                  p_m_qualityModifiedSignal = v14;
                }
                v13 = (_QWORD *)v15;
              }
              while ( v15 );
              m_ptrAndInt = (unsigned __int64)m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt;
            }
            m_ptr->m_qualityModifiedSignal.m_slots.m_ptrAndInt = (hkSlot *)(m_ptrAndInt & 0xFFFFFFFFFFFFFFFCui64);
            MutableWorld = v22;
          }
          ++v7;
          ++m_data;
        }
        while ( m_data != &library->list->m_bodyQualitys.m_data[library->list->m_bodyQualitys.m_size] );
        p_critSection = v23;
      }
      v17 = MutableWorld->world;
      m_size = (unsigned int)v17->m_dirtyQualities.m_storage.m_words.m_size;
      if ( (int)m_size > 0 )
      {
        v19 = v17->m_dirtyQualities.m_storage.m_words.m_data;
        while ( m_size )
        {
          *v19++ = 0;
          --m_size;
        }
      }
    }
    LeaveCriticalSection(p_critSection);
  }
}

/*
==============
HavokPhysics_AddClipMap
==============
*/
void HavokPhysics_AddClipMap(clipMap_t *clipMap)
{
  ;
}

/*
==============
HavokPhysics_AddDebugLine
==============
*/
void HavokPhysics_AddDebugLine(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, const unsigned int *color)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v9; 
  int m_size; 
  hkVector4f *p_start; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->debugLines && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24015, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  debugLines = MutableWorld->debugLines;
  v9 = hkMemHeapAllocator();
  m_size = debugLines->m_size;
  if ( m_size == (debugLines->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v9, debugLines, 48);
    m_size = debugLines->m_size;
  }
  p_start = &debugLines->m_data[m_size].start;
  debugLines->m_size = m_size + 1;
  *p_start = (hkVector4f)start->m_quad;
  p_start[1] = (hkVector4f)end->m_quad;
  p_start[2].m_quad.m128_i32[0] = *color;
}

/*
==============
HavokPhysics_AddDeferredBulletEffectCallback
==============
*/
void HavokPhysics_AddDeferredBulletEffectCallback(void (*effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int), const Physics_WorldId worldId, hknpBodyId hitBodyId, unsigned int shapeKey, const vec3_t *start, const vec3_t *hitPos, const int hitSurfaceFlags, const vec3_t *hitNormal, const scr_string_t *partName, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, int mod)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletEffectCallback,hkContainerHeapAllocator> *m_deferredBulletEffectEntries; 
  hkMemoryAllocator *v18; 
  int m_size; 
  __int64 v20; 
  scr_string_t v21; 

  if ( !effectCallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12974, ASSERT_TYPE_ASSERT, "(effectCallback)", "%s\n\tHavok Physics: Trying to Add deferred bullte effect callback with no callback", "effectCallback") )
    __debugbreak();
  if ( ((LODWORD(start->v[0]) & 0x7F800000) == 2139095040 || (LODWORD(start->v[1]) & 0x7F800000) == 2139095040 || (LODWORD(start->v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12975, ASSERT_TYPE_ASSERT, "(!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] ))", (const char *)&queryFormat, "!IS_NAN( start[0] ) && !IS_NAN( start[1] ) && !IS_NAN( start[2] )") )
    __debugbreak();
  if ( ((LODWORD(hitPos->v[0]) & 0x7F800000) == 2139095040 || (LODWORD(hitPos->v[1]) & 0x7F800000) == 2139095040 || (LODWORD(hitPos->v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12976, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] ))", (const char *)&queryFormat, "!IS_NAN( hitPos[0] ) && !IS_NAN( hitPos[1] ) && !IS_NAN( hitPos[2] )") )
    __debugbreak();
  if ( ((LODWORD(hitNormal->v[0]) & 0x7F800000) == 2139095040 || (LODWORD(hitNormal->v[1]) & 0x7F800000) == 2139095040 || (LODWORD(hitNormal->v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12977, ASSERT_TYPE_ASSERT, "(!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] ))", (const char *)&queryFormat, "!IS_NAN( hitNormal[0] ) && !IS_NAN( hitNormal[1] ) && !IS_NAN( hitNormal[2] )") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredRadiusForceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12983, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  m_deferredBulletEffectEntries = MutableWorld->m_deferredBulletEffectEntries;
  v18 = hkMemHeapAllocator();
  m_size = m_deferredBulletEffectEntries->m_size;
  if ( m_size == (m_deferredBulletEffectEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v18, m_deferredBulletEffectEntries, 136);
    m_size = m_deferredBulletEffectEntries->m_size;
  }
  v20 = (__int64)&m_deferredBulletEffectEntries->m_data[m_size];
  m_deferredBulletEffectEntries->m_size = m_size + 1;
  *(_QWORD *)v20 = effectCallback;
  *(_DWORD *)(v20 + 8) = Physics_GetLocalClientForWorld(worldId);
  *(_DWORD *)(v20 + 16) = shapeKey;
  *(hknpBodyId *)(v20 + 12) = hitBodyId;
  *(vec3_t *)(v20 + 20) = *start;
  *(vec3_t *)(v20 + 32) = *hitPos;
  *(_DWORD *)(v20 + 44) = hitSurfaceFlags;
  *(vec3_t *)(v20 + 48) = *hitNormal;
  v21 = *partName;
  *(_DWORD *)(v20 + 64) = inflictorEntNum;
  *(_DWORD *)(v20 + 60) = v21;
  *(Weapon *)(v20 + 68) = *weapon;
  *(_BYTE *)(v20 + 128) = isAlternate;
  *(_DWORD *)(v20 + 132) = mod;
}

/*
==============
HavokPhysics_AddDeferredBulletForce
==============
*/
void HavokPhysics_AddDeferredBulletForce(const Physics_WorldId worldId, const vec3_t *start, const vec3_t *end, const unsigned int inflictorEntNum, const bool isMelee, const Weapon *weapon, bool isAlternate, int mod, void (*effectCallback)(const LocalClientNum_t, unsigned int, unsigned int, const vec3_t *, const vec3_t *, const int, const vec3_t *, const scr_string_t *, const unsigned int, const Weapon *, bool, int))
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletForce,hkContainerHeapAllocator> *m_deferredBulletForceEntries; 
  hkMemoryAllocator *v15; 
  int m_size; 
  __int64 v17; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12924, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add deferred bullet force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredBulletForceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12930, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredBulletForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredBulletForceEntries") )
    __debugbreak();
  m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  v15 = hkMemHeapAllocator();
  m_size = m_deferredBulletForceEntries->m_size;
  if ( m_size == (m_deferredBulletForceEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v15, m_deferredBulletForceEntries, 104);
    m_size = m_deferredBulletForceEntries->m_size;
  }
  v17 = (__int64)&m_deferredBulletForceEntries->m_data[m_size];
  m_deferredBulletForceEntries->m_size = m_size + 1;
  *(float *)v17 = start->v[0];
  *(float *)(v17 + 4) = start->v[1];
  *(float *)(v17 + 8) = start->v[2];
  *(float *)(v17 + 12) = end->v[0];
  *(float *)(v17 + 16) = end->v[1];
  *(float *)(v17 + 20) = end->v[2];
  *(_BYTE *)(v17 + 28) = isMelee;
  *(_DWORD *)(v17 + 24) = inflictorEntNum;
  *(Weapon *)(v17 + 30) = *weapon;
  *(_BYTE *)(v17 + 90) = isAlternate;
  *(_DWORD *)(v17 + 92) = mod;
  *(_QWORD *)(v17 + 96) = effectCallback;
}

/*
==============
HavokPhysics_AddDeferredKeyframeInstance
==============
*/
void HavokPhysics_AddDeferredKeyframeInstance(const Physics_WorldId worldId, const unsigned int instanceId, const vec3_t *origin, const vec4_t *orientationAsQuat)
{
  float v8; 
  float v9; 
  float v10; 
  float v11; 
  float v12; 
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredKeyframeInstance,hkContainerHeapAllocator> *m_deferredKeyframeInstanceEntries; 
  hkMemoryAllocator *v15; 
  int m_size; 
  __int64 v17; 
  Physics_WorldId v18; 

  if ( worldId )
  {
    if ( !Physics_IsAuthoritativeWorld(worldId) )
    {
      v18 = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12902, ASSERT_TYPE_ASSERT, "(worldId == PHYSICS_WORLD_ID_SERVER_MAIN || Physics_IsAuthoritativeWorld( worldId ))", "%s\n\tHavok Physics: Trying to Add deferred keyframe with invalid world index %i", "worldId == PHYSICS_WORLD_ID_SERVER_MAIN || Physics_IsAuthoritativeWorld( worldId )", v18) )
        __debugbreak();
    }
  }
  v8 = orientationAsQuat->v[1];
  v9 = orientationAsQuat->v[0];
  v10 = orientationAsQuat->v[2];
  v11 = orientationAsQuat->v[3];
  v12 = (float)((float)((float)(v9 * v9) + (float)(v8 * v8)) + (float)(v10 * v10)) + (float)(v11 * v11);
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(v12 - 1.0) & _xmm) >= 0.0020000001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12904, ASSERT_TYPE_ASSERT, "( Vec4IsNormalized( orientationAsQuat ) )", "(%g, %g, %g, %g) len: %g", v9, v8, v10, v11, fsqrt(v12)) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredKeyframeInstanceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12910, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredKeyframeInstanceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredKeyframeInstanceEntries") )
    __debugbreak();
  m_deferredKeyframeInstanceEntries = MutableWorld->m_deferredKeyframeInstanceEntries;
  v15 = hkMemHeapAllocator();
  m_size = m_deferredKeyframeInstanceEntries->m_size;
  if ( m_size == (m_deferredKeyframeInstanceEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v15, m_deferredKeyframeInstanceEntries, 32);
    m_size = m_deferredKeyframeInstanceEntries->m_size;
  }
  v17 = (__int64)&m_deferredKeyframeInstanceEntries->m_data[m_size];
  m_deferredKeyframeInstanceEntries->m_size = m_size + 1;
  *(float *)(v17 + 4) = origin->v[0];
  *(float *)(v17 + 8) = origin->v[1];
  *(float *)(v17 + 12) = origin->v[2];
  *(float *)(v17 + 16) = orientationAsQuat->v[0];
  *(float *)(v17 + 20) = orientationAsQuat->v[1];
  *(float *)(v17 + 24) = orientationAsQuat->v[2];
  *(float *)(v17 + 28) = orientationAsQuat->v[3];
  *(_DWORD *)v17 = instanceId;
}

/*
==============
HavokPhysics_AddDeferredRadiusForce
==============
*/
void HavokPhysics_AddDeferredRadiusForce(const Physics_WorldId worldId, const vec3_t *position, const float radius, const float innerDamage, const float outerDamage, const float impulseOverride, const vec3_t *impulseVecOverride, int randSeed, float forceScalar)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredRadiusForce,hkContainerHeapAllocator> *m_deferredRadiusForceEntries; 
  hkMemoryAllocator *v13; 
  int m_size; 
  __int64 v15; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12949, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add deferred radius force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->m_deferredRadiusForceEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12955, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  m_deferredRadiusForceEntries = MutableWorld->m_deferredRadiusForceEntries;
  v13 = hkMemHeapAllocator();
  m_size = m_deferredRadiusForceEntries->m_size;
  if ( m_size == (m_deferredRadiusForceEntries->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v13, m_deferredRadiusForceEntries, 48);
    m_size = m_deferredRadiusForceEntries->m_size;
  }
  v15 = (__int64)&m_deferredRadiusForceEntries->m_data[m_size];
  m_deferredRadiusForceEntries->m_size = m_size + 1;
  *(float *)v15 = position->v[0];
  *(float *)(v15 + 4) = position->v[1];
  *(float *)(v15 + 8) = position->v[2];
  *(const float *)(v15 + 12) = radius;
  *(const float *)(v15 + 16) = innerDamage;
  *(const float *)(v15 + 20) = outerDamage;
  *(const float *)(v15 + 24) = impulseOverride;
  *(vec3_t *)(v15 + 28) = *impulseVecOverride;
  *(_DWORD *)(v15 + 40) = randSeed;
  *(float *)(v15 + 44) = forceScalar;
}

/*
==============
HavokPhysics_AddDetailCollisionShapesToInstanceList
==============
*/

__int64 __fastcall HavokPhysics_AddDetailCollisionShapesToInstanceList(const XModelDetailCollision *detailCollision, const hkVector4f *origin, double scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  __int64 result; 
  int v9; 
  __int64 v10; 
  __int64 v11; 
  const hkRotationImpl<float> *p_m_rotation; 
  __m128 m_quad; 
  __m128 v18; 
  __m128 v19; 
  hkMemoryAllocator *v23; 
  int m_size; 
  hknpShapeInstance *m_data; 
  int v26; 
  hknpShapeInstance *v27; 
  hknpShapeInstance *v28; 
  hkVector4f direction; 
  hkQuaternionf v31; 
  hkQuaternionf qi; 
  hkVector4f scalea; 
  hkTransformf v34; 

  _R13 = orientation;
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15792, ASSERT_TYPE_ASSERT, "(detailCollision)", (const char *)&queryFormat, "detailCollision") )
    __debugbreak();
  if ( !instanceArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15793, ASSERT_TYPE_ASSERT, "(instanceArray)", (const char *)&queryFormat, "instanceArray") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15797, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics AddDetailCollisionShapesToInstanceList %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  result = (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
  v9 = 0;
  if ( (int)result > 0 )
  {
    v10 = 0i64;
    v11 = 0i64;
    _XMM9 = _mm_shuffle_ps(*(__m128 *)&scale, *(__m128 *)&scale, 0);
    __asm { vblendps xmm10, xmm9, xmm0, 8 }
    do
    {
      p_m_rotation = &HavokPhysicsXModelLODFromDetailCol->m_bodyBindPoses.m_data[v11].m_rotation;
      hkQuaternionf::setAndNormalize(&v31, p_m_rotation);
      direction.m_quad = _mm128_mul_ps(_XMM9, p_m_rotation[1].m_col0.m_quad);
      hkVector4f::setRotatedDir(&direction, _R13, &direction);
      m_quad = v31.m_vec.m_quad;
      _XMM8 = _R13->m_vec.m_quad;
      __asm { vbroadcastss xmm7, dword ptr [r13+0Ch] }
      v18 = _mm_shuffle_ps(m_quad, m_quad, 255);
      direction.m_quad = _mm128_add_ps(direction.m_quad, origin->m_quad);
      v19 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(m_quad, m_quad, 201), _XMM8), _mm128_mul_ps(_mm_shuffle_ps(_XMM8, _XMM8, 201), v31.m_vec.m_quad));
      __asm { vdpps   xmm0, xmm8, xmm5, 7Fh }
      _mm128_sub_ps(_mm128_mul_ps(v18, _XMM7), _XMM0);
      _XMM2 = _mm128_add_ps(_mm128_add_ps(_mm_shuffle_ps(v19, v19, 201), _mm128_mul_ps(v31.m_vec.m_quad, _XMM7)), _mm128_mul_ps(_XMM8, v18));
      __asm { vblendps xmm0, xmm2, xmm3, 8 }
      qi.m_vec.m_quad = _XMM0;
      hkRotationImpl<float>::set(&v34.m_rotation, &qi);
      v34.m_translation = (hkVector4f)direction.m_quad;
      v23 = hkMemHeapAllocator();
      m_size = instanceArray->m_size;
      if ( m_size == (instanceArray->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v23, instanceArray, 112);
        m_size = instanceArray->m_size;
      }
      m_data = instanceArray->m_data;
      v26 = m_size;
      v27 = &instanceArray->m_data[m_size];
      if ( v27 )
      {
        *(__m256i *)v27->m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
        *(__m256i *)v27->m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
        v27->m_scale.m_quad = g_vectorfConstants[6];
        v27->m_shape.m_ptr = NULL;
        *(_DWORD *)&v27->m_shapeTag = -1;
        v27->m_isEmpty = 0;
        v27->m_nextEmptyElement = 0;
        v27->m_instanceId.m_value = -1;
        v27->m_parentShape = NULL;
        v27->m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
        v26 = instanceArray->m_size;
        m_data = instanceArray->m_data;
      }
      instanceArray->m_size = v26 + 1;
      v28 = &m_data[v26];
      hknpShapeInstance::setShape(v28, HavokPhysicsXModelLODFromDetailCol->m_shapes.m_data[v10]);
      scalea.m_quad = _XMM10;
      hknpShapeInstance::setScale(v28, &scalea, SCALE_SURFACE);
      hknpShapeInstance::setTransform(v28, &v34);
      result = (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
      ++v9;
      ++v11;
      ++v10;
    }
    while ( v9 < (int)result );
  }
  return result;
}

/*
==============
HavokPhysics_AddDetailTrace
==============
*/
void HavokPhysics_AddDetailTrace(HavokPhysics_CollisionQueryResult *result, unsigned __int8 *detailPriorityMap)
{
  hkMemoryRouter *Value; 
  HavokPhysicsHitCollector_DetailTraceModifier *v5; 
  HavokPhysicsHitCollector_Modifier *v6; 
  HavokPhysicsHitCollector_Modifier *v7; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v5 = (HavokPhysicsHitCollector_DetailTraceModifier *)Value->m_heap->blockAlloc(Value->m_heap, 464i64);
  if ( v5 )
  {
    HavokPhysicsHitCollector_DetailTraceModifier::HavokPhysicsHitCollector_DetailTraceModifier(v5, result->m_worldId, detailPriorityMap);
    v7 = v6;
  }
  else
  {
    v7 = NULL;
  }
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13644, ASSERT_TYPE_ASSERT, "(modifier)", (const char *)&queryFormat, "modifier", -2i64) )
    __debugbreak();
  HavokPhysicsHitCollector::AddModifier(result->m_collector, v7);
}

/*
==============
HavokPhysics_AddInstanceToWorld
==============
*/
void HavokPhysics_AddInstanceToWorld(Physics_WorldId worldId, unsigned int instanceId, bool immediate, bool tryStartDeactivated)
{
  __int64 v4; 
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  hknpBodyId *m_data; 
  int m_size; 
  int v12; 
  __int64 v13; 

  v4 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11134, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to add instance to world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v4 == -1 )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11135, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to add instance to world with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v13) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11140, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics AddInstanceToWorld %i: world is NULL", "havokPhysicsWorld->world", v13) )
      __debugbreak();
  }
  p_instanceManager = &MutableWorld->instanceManager;
  if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", (_DWORD)MutableWorld + 228, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v4 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  m_data = p_instanceManager->buffer[v4].bodies.m_data;
  m_size = p_instanceManager->buffer[v4].bodies.m_size;
  if ( HavokPhysics_IsInstanceDetailBounded(worldId, v4) )
  {
    v12 = m_size - 1;
    m_size = 1;
    m_data += v12;
  }
  HavokPhysics_AddRigidBodies(MutableWorld, m_data, m_size, immediate, tryStartDeactivated);
  HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v4, immediate, !immediate);
}

/*
==============
HavokPhysics_AddMaterialLibraryToWorld
==============
*/
void HavokPhysics_AddMaterialLibraryToWorld(HavokPhysicsMaterialLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  hknpWorld *v6; 
  hknpMaterialLibrary *m_ptr; 
  int v8; 
  HavokPhysicsMaterialList *list; 
  hknpMaterial *m_data; 
  hknpWorld *v11; 
  __int64 m_size; 
  unsigned int *v13; 
  __int64 v14; 
  int capacity; 
  hkCriticalSection *p_critSection; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6500, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Add Material Library to world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6508, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Add Material Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v14) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    p_critSection = &MutableWorld->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMaterialLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v14) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6520, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMaterialLibrary())", "%s\n\tHavokPhysics: Trying to Add Material Library with world index %i, but can't find world library to add to", "havokPhysicsWorld->world->getMaterialLibrary()", v14) )
          __debugbreak();
      }
      v6 = MutableWorld->world;
      m_ptr = v6->m_materialLibrary.m_ptr;
      v6->getMaterialLibrary(&v6->hknpWorldReader);
      hknpMaterialLibrary::setCapacity(m_ptr, (int)&capacity);
      v8 = 0;
      list = library->list;
      m_data = list->m_materials.m_data;
      if ( list->m_materials.m_data != &list->m_materials.m_data[list->m_materials.m_size] )
      {
        do
        {
          if ( v8 != hknpMaterialLibrary::addEntry(MutableWorld->world->m_materialLibrary.m_ptr, (hknpMaterialId *)&capacity, m_data)->m_value - library->firstId.m_value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6531, ASSERT_TYPE_ASSERT, "(materialIdx == materialId.value() - library->firstId.value())", "%s\n\tPhysics Material Library index is assumed to be linearly increasing", "materialIdx == materialId.value() - library->firstId.value()") )
            __debugbreak();
          ++v8;
          ++m_data;
        }
        while ( m_data != &library->list->m_materials.m_data[library->list->m_materials.m_size] );
      }
      v11 = MutableWorld->world;
      m_size = (unsigned int)v11->m_dirtyMaterials.m_storage.m_words.m_size;
      if ( (int)m_size > 0 )
      {
        v13 = v11->m_dirtyMaterials.m_storage.m_words.m_data;
        while ( m_size )
        {
          *v13++ = 0;
          --m_size;
        }
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  }
}

/*
==============
HavokPhysics_AddModifier
==============
*/
void HavokPhysics_AddModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16430, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to AddModifier with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16434, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics AddModifier %i: world is NULL", "physicsWorld->world", v5) )
      __debugbreak();
  }
  hknpModifierManager::addModifier(MutableWorld->world->m_modifierManager, (hknpCollisionFlags)128, modifier, PRIORITY_LOWER);
}

/*
==============
HavokPhysics_AddMotionPropertiesLibraryToWorld
==============
*/
void HavokPhysics_AddMotionPropertiesLibraryToWorld(HavokPhysicsMotionPropertiesLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hknpWorld *world; 
  hknpWorld *v7; 
  hknpMotionPropertiesLibrary *m_ptr; 
  HavokPhysicsMotionPropertiesList *list; 
  __int64 m_size; 
  hkMemoryAllocator *v11; 
  int v12; 
  __int64 v13; 
  __int64 v14; 
  char *v15; 
  unsigned int v16; 
  __int64 v17; 
  __m256i *v18; 
  signed __int64 v19; 
  char *v20; 
  float *v21; 
  int v22; 
  __int64 v23; 
  signed int v24; 
  char *v25; 
  __int64 v26; 
  int m_value; 
  unsigned int v28; 
  char *v29; 
  unsigned int v30; 
  signed int v31; 
  __int64 v32; 
  __int64 v33; 
  unsigned __int16 v34; 
  signed int v35; 
  int v36; 
  hknpMotionProperties *v37; 
  __int64 v38; 
  unsigned __int16 v39; 
  __int64 v40; 
  unsigned int v41; 
  signed int v42; 
  unsigned __int16 v43; 
  hkMemoryAllocator *v44; 
  __int64 v45; 
  __int64 v46; 
  __int64 v47; 
  int numInOut; 
  int v49; 
  unsigned int v50; 
  void *p; 
  HavokPhysicsWorld *v52; 
  int v53; 
  int v54; 
  __int64 v55; 
  _RTL_CRITICAL_SECTION *v56; 
  char *v57; 
  int v58; 
  unsigned int v59; 
  __int64 v60; 
  int capacity; 
  hknpMotionPropertiesId result; 
  hknpMotionPropertiesId v63; 

  v60 = -2i64;
  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6549, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Add Motion Properties Library to world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v45) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6557, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Add Motion Properties Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v45) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    v52 = MutableWorld;
    p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    v56 = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMotionPropertiesLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v45) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6569, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMotionPropertiesLibrary())", "%s\n\tHavokPhysics: Trying to Add Motion Properties Library with world index %i, but can't find world library to add to", "havokPhysicsWorld->world->getMotionPropertiesLibrary()", v45) )
          __debugbreak();
      }
      v7 = MutableWorld->world;
      m_ptr = v7->m_motionPropertiesLibrary.m_ptr;
      v7->getMotionPropertiesLibrary(&v7->hknpWorldReader);
      hknpMotionPropertiesLibrary::setCapacity(m_ptr, (int)&capacity);
      list = library->list;
      m_size = list->m_motionProperties.m_size;
      numInOut = list->m_motionProperties.m_size;
      v11 = hkMemHeapAllocator();
      v12 = numInOut;
      v13 = numInOut;
      v53 = numInOut;
      LODWORD(v14) = 0;
      v55 = 0i64;
      if ( numInOut )
      {
        v15 = (char *)hkMemoryAllocator::bufAlloc2(v11, 112, &numInOut);
        p = v15;
        v12 = numInOut;
      }
      else
      {
        v15 = NULL;
        p = NULL;
      }
      v16 = 0x80000000;
      if ( v12 )
        v16 = v12;
      v54 = v16;
      v57 = v15;
      v58 = v13;
      v59 = v16;
      v17 = m_size;
      if ( (int)m_size > 0 )
      {
        v18 = (__m256i *)v15;
        v19 = (char *)list->m_motionProperties.m_data - v15;
        do
        {
          if ( v18 )
          {
            *v18 = *(__m256i *)((char *)v18 + v19);
            v18[1] = *(__m256i *)((char *)&v18[1] + v19);
            v18[2] = *(__m256i *)((char *)&v18[2] + v19);
            *(_OWORD *)v18[3].m256i_i8 = *(_OWORD *)&v18[3].m256i_i8[v19];
          }
          v18 = (__m256i *)((char *)v18 + 112);
          --v17;
        }
        while ( v17 );
      }
      v20 = &v15[112 * v13];
      if ( v15 != v20 )
      {
        v21 = (float *)(v15 + 4);
        do
        {
          if ( v21[1] != 0.0 )
            *(_DWORD *)v21 |= 0x10000u;
          v21 += 28;
        }
        while ( v21 - 1 != (float *)v20 );
      }
      v22 = 11;
      v49 = 11;
      if ( (unsigned int)v13 < 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6588, ASSERT_TYPE_ASSERT, "( SP_GOLD_MOTION_PROPERTIES_LIST_COUNT ) <= ( motionPropertiesArray.getSize() )", "%s <= %s\n\t%u, %u", "SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", "motionPropertiesArray.getSize()", 11, v13) )
        __debugbreak();
      if ( s_motionPropertiesAreReorderedForSPGold || (v22 = v13, v49 = v13, (int)v13 > 0) )
      {
        v23 = 0i64;
        v24 = 0;
        v25 = (char *)p;
        v26 = (__int64)v52;
        do
        {
          m_value = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v26 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, (const hknpMotionProperties *)&v25[v23])->m_value;
          if ( v24 != m_value - library->firstId.m_value && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6599, ASSERT_TYPE_ASSERT, "(motionPropertiesIdx == motionPropertiesId.value() - library->firstId.value())", "%s\n\tPhysics Motion Properties Library index is assumed to be linearly increasing", "motionPropertiesIdx == motionPropertiesId.value() - library->firstId.value()") )
            __debugbreak();
          if ( (_WORD)m_value != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, 0, v24)->m_value )
          {
            LODWORD(v47) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v63, 0, v24)->m_value;
            LODWORD(v46) = m_value;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6600, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value()", v46, v47) )
              __debugbreak();
          }
          if ( v24 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)m_value) )
          {
            LODWORD(v47) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)m_value);
            LODWORD(v46) = v24;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6601, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v46, v47) )
              __debugbreak();
          }
          ++v24;
          v23 += 112i64;
        }
        while ( v24 < v22 );
        LODWORD(v14) = 0;
      }
      v28 = 0;
      v50 = 0;
      v29 = (char *)p;
      do
      {
        v30 = v28 + 1;
        v31 = 0;
        if ( v22 > 0 )
        {
          v32 = 0i64;
          v33 = (__int64)v52;
          do
          {
            v34 = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v33 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, (const hknpMotionProperties *)&v29[v32])->m_value;
            if ( v34 != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, v30, v31)->m_value )
            {
              LODWORD(v47) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v63, v30, v31)->m_value;
              LODWORD(v46) = v34;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6615, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value()", v46, v47) )
                __debugbreak();
            }
            if ( v31 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v34) )
            {
              LODWORD(v47) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v34);
              LODWORD(v46) = v31;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6616, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v46, v47) )
                __debugbreak();
            }
            ++v31;
            v32 += 112i64;
          }
          while ( v31 < v22 );
          v28 = v50;
          LODWORD(v14) = 0;
        }
        v50 = ++v28;
      }
      while ( v28 < 4 );
      v35 = v22;
      v36 = v53;
      v37 = (hknpMotionProperties *)p;
      if ( v22 < v53 )
      {
        v38 = (__int64)v52;
        do
        {
          v39 = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v38 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, &v37[v35])->m_value;
          if ( v39 != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, 0, v35)->m_value )
          {
            LODWORD(v47) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v63, 0, v35)->m_value;
            LODWORD(v46) = v39;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6625, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( 0, motionPropertiesIdx ).value()", v46, v47) )
              __debugbreak();
          }
          if ( v35 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v39) )
          {
            LODWORD(v47) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v39);
            LODWORD(v46) = v35;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6626, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v46, v47) )
              __debugbreak();
          }
          ++v35;
        }
        while ( v35 < v36 );
        v22 = v49;
        LODWORD(v14) = 0;
      }
      v40 = (__int64)v52;
      do
      {
        v41 = v14 + 1;
        v42 = v22;
        if ( v22 < v36 )
        {
          do
          {
            v43 = hknpMotionPropertiesLibrary::addEntry(*(hknpMotionPropertiesLibrary **)(*(_QWORD *)(v40 + 24) + 2792i64), (hknpMotionPropertiesId *)&capacity, &v37[v42])->m_value;
            if ( v43 != HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, v41, v42)->m_value )
            {
              LODWORD(v47) = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&v63, v41, v42)->m_value;
              LODWORD(v46) = v43;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6639, ASSERT_TYPE_ASSERT, "( motionPropertiesId.value() ) == ( HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value() )", "%s == %s\n\t%i, %i", "motionPropertiesId.value()", "HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex( gravityPropertyIndex, motionPropertiesIdx ).value()", v46, v47) )
                __debugbreak();
            }
            if ( v42 != HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v43) )
            {
              LODWORD(v47) = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)v43);
              LODWORD(v46) = v42;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6640, ASSERT_TYPE_ASSERT, "( motionPropertiesIdx ) == ( static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId )) )", "%s == %s\n\t%i, %i", "motionPropertiesIdx", "static_cast<int>(HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId( motionPropertiesId ))", v46, v47) )
                __debugbreak();
            }
            ++v42;
          }
          while ( v42 < v36 );
          v22 = v49;
          LODWORD(v14) = v55;
        }
        v14 = (unsigned int)(v14 + 1);
        v55 = v14;
      }
      while ( (unsigned int)v14 < 4 );
      v44 = hkMemHeapAllocator();
      p_critSection = v56;
      if ( v54 >= 0 )
        hkMemoryAllocator::bufFree2(v44, v37, 112, v54 & 0x3FFFFFFF);
    }
    LeaveCriticalSection(p_critSection);
  }
}

/*
==============
HavokPhysics_AddPendingBodies
==============
*/
void HavokPhysics_AddPendingBodies(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  __int64 v4; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10905, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add Pending Bodies to invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10909, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavok Physics: Trying to Add Pending Bodies where index %i doesn't have a world yet", "havokPhysicsWorld->world", v4) )
      __debugbreak();
  }
  world = MutableWorld->world;
  if ( world->m_bodyManager.m_bodiesToAddAsActive.m_size || world->m_bodyManager.m_bodiesToAddAsInactive.m_size )
  {
    world->commitAddBodies(&world->hknpWorldWriter);
    MutableWorld->world->updateBroadPhase(&MutableWorld->world->hknpWorldWriter);
  }
}

/*
==============
HavokPhysics_AddPhysicsAsset
==============
*/
void HavokPhysics_AddPhysicsAsset(PhysicsAsset *physicsAsset)
{
  int v2; 
  int *m_addr; 
  int m_hashMod; 
  unsigned __int32 v5; 
  unsigned __int32 v6; 
  int v7; 
  int v8; 
  PhysicsAsset *key; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v10; 
  int v11; 
  int v12; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  PhysicsAsset *v18; 
  __int64 v19; 
  _DWORD *v20; 
  __int64 v21; 
  unsigned int v22; 
  int *m_data; 
  int *v24; 
  _DWORD *v25; 
  __int64 v26; 
  char v27; 
  int *v28; 
  int *v29; 
  _DWORD *v30; 
  __int64 v31; 
  __int16 v32; 
  int *v33; 
  int *v34; 
  char v35; 
  char containsDynamicBodies; 
  const char *v37; 
  const char *v38; 
  __int64 v39; 
  hkReflect::Var result; 
  hkMemoryAllocator alloc; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7327, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tTrying to add a NULL Physics Asset", "physicsAsset") )
    __debugbreak();
  if ( !physicsAsset->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7329, ASSERT_TYPE_ASSERT, "(physicsAsset->havokData)", "%s\n\tTrying to add a Physics Asset with NULL data", "physicsAsset->havokData") )
    __debugbreak();
  if ( !physicsAsset->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7330, ASSERT_TYPE_ASSERT, "(physicsAsset->havokDataSize > 0)", "%s\n\tTrying to add a Physics Asset with 0 data size", "physicsAsset->havokDataSize > 0") )
    __debugbreak();
  if ( !physicsAsset->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !physicsAsset->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  v2 = 0;
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, physicsAsset->havokData, physicsAsset->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsAsset::typeData);
  m_addr = (int *)result.m_addr;
  if ( !result.m_addr )
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
    goto LABEL_30;
  }
  if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsAsset::typeData) )
    m_addr = NULL;
  if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
    hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  if ( !m_addr )
  {
LABEL_30:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7335, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
      __debugbreak();
  }
  HavokPhysics_LockAssetWrite();
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7340, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Add a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
    __debugbreak();
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v5 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset), v6 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset)), v7 = m_hashMod & (v6 ^ ((v5 >> 2) + v5 + (v6 << 6) - 1640531527)), v8 = v7, key = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v7].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_39:
    v8 = m_hashMod + 1;
  }
  else
  {
    while ( key != physicsAsset )
    {
      v7 = m_hashMod & (v7 + 1);
      v8 = v7;
      key = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v7].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_39;
    }
  }
  if ( v8 <= m_hashMod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7341, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsAssets->hasKey( physicsAsset ))", "%s\n\tPhysics asset already exists in map", "!s_havokPhysicsAssets->hasKey( physicsAsset )") )
    __debugbreak();
  v10 = s_havokPhysicsAssets;
  v11 = (unsigned int)hkMemHeapAllocator();
  v12 = v10->m_map.m_hashMod;
  if ( 2 * v10->m_map.m_numElems > v12 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v10->m_map, &alloc, v11);
    v12 = v10->m_map.m_hashMod;
  }
  v13 = 1;
  v14 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset);
  v15 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset));
  v16 = v12 & (v15 ^ ((v14 >> 2) + v14 + (v15 << 6) - 1640531527));
  m_elem = v10->m_map.m_elem;
  v18 = (PhysicsAsset *)v10->m_map.m_elem[v16].key;
  if ( v18 != (PhysicsAsset *)-1i64 )
  {
    while ( v18 != physicsAsset )
    {
      v16 = v10->m_map.m_hashMod & (v16 + 1);
      v18 = (PhysicsAsset *)m_elem[v16].key;
      if ( v18 == (PhysicsAsset *)-1i64 )
        goto LABEL_50;
    }
    v13 = 0;
  }
LABEL_50:
  v10->m_map.m_numElems += v13;
  v19 = (int)v16;
  m_elem[v19].key = (unsigned __int64)physicsAsset;
  v10->m_map.m_elem[v19].val = (unsigned __int64)m_addr;
  if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7342, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->insert( physicsAsset, havokPhysicsAsset ))", (const char *)&queryFormat, "s_havokPhysicsAssets->insert( physicsAsset, havokPhysicsAsset )") )
    __debugbreak();
  v20 = (_DWORD *)*((_QWORD *)m_addr + 6);
  if ( v20 != &v20[m_addr[14]] )
  {
    v21 = 0i64;
    do
    {
      v22 = 0;
      m_data = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_data;
      v24 = &m_data[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size];
      if ( m_data == v24 )
        goto LABEL_60;
      while ( *m_data != *v20 )
      {
        ++v22;
        if ( ++m_data == v24 )
          goto LABEL_60;
      }
      if ( m_data == v24 )
      {
LABEL_60:
        LODWORD(v39) = *v20;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7374, ASSERT_TYPE_ASSERT, "(libraryCRCIt != s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.end())", "%s\n\tMotion Properties %x not found when loading physics asset %s", "libraryCRCIt != s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.end()", v39, physicsAsset->name) )
          __debugbreak();
      }
      *(hknpMotionPropertiesId *)(*(_QWORD *)(*((_QWORD *)m_addr + 1) + 56i64) + v21 + 136) = (hknpMotionPropertiesId)HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex((hknpMotionPropertiesId *)&alloc, 0, v22)->m_value;
      v21 += 192i64;
      ++v20;
    }
    while ( v20 != (_DWORD *)(*((_QWORD *)m_addr + 6) + 4i64 * m_addr[14]) );
  }
  v25 = (_DWORD *)*((_QWORD *)m_addr + 2);
  if ( v25 != &v25[m_addr[6]] )
  {
    v26 = 0i64;
    do
    {
      v27 = 0;
      v28 = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_data;
      v29 = &v28[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_size];
      if ( v28 == v29 )
        goto LABEL_70;
      while ( *v28 != *v25 )
      {
        ++v27;
        if ( ++v28 == v29 )
          goto LABEL_70;
      }
      if ( v28 == v29 )
      {
LABEL_70:
        LODWORD(v39) = *v25;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7407, ASSERT_TYPE_ASSERT, "(libraryCRCIt != s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.end())", "%s\n\tBody Quality %x not found when loading physics asset %s", "libraryCRCIt != s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.end()", v39, physicsAsset->name) )
          __debugbreak();
      }
      *(_BYTE *)(*(_QWORD *)(*((_QWORD *)m_addr + 1) + 56i64) + v26 + 22) = v27 + 16;
      v26 += 192i64;
      ++v25;
    }
    while ( v25 != (_DWORD *)(*((_QWORD *)m_addr + 2) + 4i64 * m_addr[6]) );
  }
  v30 = (_DWORD *)*((_QWORD *)m_addr + 4);
  if ( v30 != &v30[m_addr[10]] )
  {
    v31 = 0i64;
    do
    {
      v32 = 0;
      v33 = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data;
      v34 = &v33[s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size];
      if ( v33 == v34 )
        goto LABEL_80;
      while ( *v33 != *v30 )
      {
        ++v32;
        if ( ++v33 == v34 )
          goto LABEL_80;
      }
      if ( v33 == v34 )
      {
LABEL_80:
        LODWORD(v39) = *v30;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7440, ASSERT_TYPE_ASSERT, "(libraryCRCIt != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.end())", "%s\n\tMaterial %x not found when loading physics asset %s", "libraryCRCIt != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.end()", v39, physicsAsset->name) )
          __debugbreak();
      }
      *(_WORD *)(*(_QWORD *)(*((_QWORD *)m_addr + 1) + 56i64) + v31 + 20) = v32 + s_havokPhysicsMaterialLibrary.firstId.m_value;
      v31 += 192i64;
      ++v30;
    }
    while ( v30 != (_DWORD *)(*((_QWORD *)m_addr + 4) + 4i64 * m_addr[10]) );
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  v35 = 0;
  if ( *(int *)(*((_QWORD *)m_addr + 1) + 64i64) > 0 )
  {
    do
      v35 |= HavokPhysics_IsPhysicsAssetBodyDynamic(physicsAsset, v2++);
    while ( v2 < *(_DWORD *)(*((_QWORD *)m_addr + 1) + 64i64) );
  }
  containsDynamicBodies = physicsAsset->containsDynamicBodies;
  if ( v35 != containsDynamicBodies )
  {
    v37 = "doesn't";
    if ( v35 )
      v37 = "does";
    v38 = "not have";
    if ( containsDynamicBodies )
      v38 = "have";
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7462, ASSERT_TYPE_ASSERT, "(anyBodiesDynamic == physicsAsset->containsDynamicBodies)", "%s\n\tHavokPhysics AddPhysicsAsset %s: physics asset claims to %s dynamic bodies, but it %s", "anyBodiesDynamic == physicsAsset->containsDynamicBodies", physicsAsset->name, v38, v37) )
      __debugbreak();
  }
}

/*
==============
HavokPhysics_AddPhysicsAssetShapesToInstanceList
==============
*/

__int64 __fastcall HavokPhysics_AddPhysicsAssetShapesToInstanceList(const PhysicsAsset *physicsAsset, const hkVector4f *origin, double scale, const hkQuaternionf *orientation, hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  const hkVector4f *v6; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  const hknpShape **p_m_ptr; 
  __m128 v15; 
  __m128 v18; 
  unsigned __int16 ShapeTag; 
  hkMemoryAllocator *v23; 
  int m_size; 
  hknpShapeInstance *m_data; 
  int v26; 
  hknpShapeInstance *v27; 
  hknpShapeInstance *v28; 
  hknpPhysicsSystemData *v29; 
  HavokPhysicsShapeList::ShapeTagData shapeTagData; 
  hkVector4f direction; 
  hkQuaternionf qi; 
  hkVector4f scalea; 
  hkTransformf v36; 

  _R13 = orientation;
  v6 = origin;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15743, ASSERT_TYPE_ASSERT, "(physicsAsset)", (const char *)&queryFormat, "physicsAsset") )
    __debugbreak();
  if ( !instanceArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15744, ASSERT_TYPE_ASSERT, "(instanceArray)", (const char *)&queryFormat, "instanceArray") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15748, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics AddPhysicsAssetShapesToInstanceList %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  p_m_ptr = &m_physicsSystemData->m_bodyCinfos.m_data->m_shape.m_ptr;
  if ( p_m_ptr == &p_m_ptr[24 * m_physicsSystemData->m_bodyCinfos.m_size] )
    return (unsigned int)m_physicsSystemData->m_bodyCinfos.m_size;
  _R14 = (__m128 *)(p_m_ptr + 8);
  _XMM9 = _mm_shuffle_ps(*(__m128 *)&scale, *(__m128 *)&scale, 0);
  __asm { vblendps xmm10, xmm9, xmm0, 8 }
  do
  {
    direction.m_quad = _mm128_mul_ps(_XMM9, _R14[-1]);
    hkVector4f::setRotatedDir(&direction, _R13, &direction);
    _XMM8 = _R13->m_vec.m_quad;
    v15 = *_R14;
    __asm
    {
      vbroadcastss xmm6, dword ptr [r13+0Ch]
      vbroadcastss xmm5, dword ptr [r14+0Ch]
    }
    direction.m_quad = _mm128_add_ps(direction.m_quad, v6->m_quad);
    v18 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v15, v15, 201), _XMM8), _mm128_mul_ps(_mm_shuffle_ps(_XMM8, _XMM8, 201), v15));
    __asm { vdpps   xmm0, xmm8, xmm7, 7Fh }
    _mm128_sub_ps(_mm128_mul_ps(_XMM5, _XMM6), _XMM0);
    _XMM2 = _mm128_add_ps(_mm128_add_ps(_mm_shuffle_ps(v18, v18, 201), _mm128_mul_ps(v15, _XMM6)), _mm128_mul_ps(_XMM8, _XMM5));
    __asm { vblendps xmm0, xmm2, xmm3, 8 }
    qi.m_vec.m_quad = _XMM0;
    hkRotationImpl<float>::set(&v36.m_rotation, &qi);
    shapeTagData.m_collisionFilterInfo = _R14[-3].m128_u32[0];
    shapeTagData.m_materialId.m_value = _R14[-3].m128_u16[2];
    v36.m_translation = (hkVector4f)direction.m_quad;
    shapeTagData.m_materialCRC = 0;
    shapeTagData.m_userData = 0i64;
    ShapeTag = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
    v23 = hkMemHeapAllocator();
    m_size = instanceArray->m_size;
    if ( m_size == (instanceArray->m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v23, instanceArray, 112);
      m_size = instanceArray->m_size;
    }
    m_data = instanceArray->m_data;
    v26 = m_size;
    v27 = &instanceArray->m_data[m_size];
    if ( v27 )
    {
      *(__m256i *)v27->m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
      *(__m256i *)v27->m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
      v27->m_scale.m_quad = g_vectorfConstants[6];
      v27->m_shape.m_ptr = NULL;
      *(_DWORD *)&v27->m_shapeTag = -1;
      v27->m_isEmpty = 0;
      v27->m_nextEmptyElement = 0;
      v27->m_instanceId.m_value = -1;
      v27->m_parentShape = NULL;
      v27->m_transform.m_rotation.m_col0.m_quad.m128_i32[3] = 1056964672;
      v26 = instanceArray->m_size;
      m_data = instanceArray->m_data;
    }
    v28 = &m_data[v26];
    instanceArray->m_size = v26 + 1;
    hknpShapeInstance::setShape(v28, *p_m_ptr);
    scalea.m_quad = _XMM10;
    hknpShapeInstance::setScale(v28, &scalea, SCALE_SURFACE);
    hknpShapeInstance::setTransform(v28, &v36);
    v28->m_shapeTag = ShapeTag;
    p_m_ptr += 24;
    v29 = HavokPhysicsAsset->m_physicsSystemData;
    _R14 += 12;
    v6 = origin;
  }
  while ( p_m_ptr != &v29->m_bodyCinfos.m_data[v29->m_bodyCinfos.m_size].m_shape.m_ptr );
  return (unsigned int)v29->m_bodyCinfos.m_size;
}

/*
==============
HavokPhysics_AddPhysicsLibrary
==============
*/
void HavokPhysics_AddPhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  hkSerialize::InplaceLoad *v2; 
  HavokPhysicsBodyQualityList *m_addr; 
  int v4; 
  int v5; 
  int *m_data; 
  int *v7; 
  int v8; 
  int v9; 
  int v10; 
  hkSerialize::InplaceLoad *v11; 
  HavokPhysicsMaterialList *v12; 
  int v13; 
  hkSerialize::InplaceLoad *v14; 
  HavokPhysicsMotionPropertiesList *v15; 
  int v16; 
  int v17; 
  int *v18; 
  int *i; 
  int v20; 
  hkSerialize::InplaceLoad *v21; 
  hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *v22; 
  const char *HostString; 
  hkSerialize::InplaceLoad *v24; 
  __int64 v25; 
  hkSerialize::InplaceLoad v26; 
  hkReflect::Var result; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "HavokPhysics_AddPhysicsLibrary");
  if ( !physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6654, ASSERT_TYPE_ASSERT, "(physicsLibrary)", "%s\n\tTrying to add a NULL Physics Library", "physicsLibrary") )
    __debugbreak();
  if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6656, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokData)", "%s\n\tTrying to add a Physics Library with NULL data", "physicsLibrary->havokData") )
    __debugbreak();
  if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6657, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokDataSize > 0)", "%s\n\tTrying to add a Physics Library with 0 data size", "physicsLibrary->havokDataSize > 0") )
    __debugbreak();
  if ( physicsLibrary->isBodyQualityList )
  {
    if ( s_havokPhysicsBodyQualityLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6670, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.list == nullptr)", "%s\n\tOnly 1 Havok Body Quality library supported", "s_havokPhysicsBodyQualityLibrary.list == HK_NULL") )
      __debugbreak();
    s_havokPhysicsBodyQualityLibrary.asset = physicsLibrary;
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v2, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsBodyQualityList::typeData);
    m_addr = (HavokPhysicsBodyQualityList *)result.m_addr;
    if ( result.m_addr )
    {
      v4 = 0;
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsBodyQualityList::typeData) )
        m_addr = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v4 = 0;
      m_addr = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsBodyQualityLibrary.list = m_addr;
    if ( !m_addr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6673, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsBodyQualityLibrary.list") )
      __debugbreak();
    v5 = 0;
    m_data = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_data;
    v7 = &m_data[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNameCRC32s.m_size];
    v8 = s_staticBodyQualityIdx;
    if ( m_data != v7 )
    {
      do
      {
        v9 = *m_data;
        if ( *m_data == s_staticBodyQualityCRC )
        {
          v8 = v5;
        }
        else if ( v9 == s_dynamicBodyQualityCRC )
        {
          s_dynamicBodyQualityIdx = v5;
        }
        else
        {
          v10 = s_vehicleBodyQualityIdx;
          if ( v9 == s_vehicleBodyQualityCRC )
            v10 = v5;
          s_vehicleBodyQualityIdx = v10;
        }
        ++v5;
        ++m_data;
      }
      while ( m_data != v7 );
      s_staticBodyQualityIdx = v8;
    }
    if ( (v8 < 0 || v8 >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6700, ASSERT_TYPE_ASSERT, "(s_staticBodyQualityIdx >= 0 && s_staticBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Body Quality Library and couldn't find body quality %s", "s_staticBodyQualityIdx >= 0 && s_staticBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize()", s_staticBodyQualityName) )
      __debugbreak();
    if ( (s_dynamicBodyQualityIdx < 0 || s_dynamicBodyQualityIdx >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6701, ASSERT_TYPE_ASSERT, "(s_dynamicBodyQualityIdx >= 0 && s_dynamicBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Body Quality Library and couldn't find body quality %s", "s_dynamicBodyQualityIdx >= 0 && s_dynamicBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize()", s_dynamicBodyQualityName) )
      __debugbreak();
    if ( (s_vehicleBodyQualityIdx < 0 || s_vehicleBodyQualityIdx >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6702, ASSERT_TYPE_ASSERT, "(s_vehicleBodyQualityIdx >= 0 && s_vehicleBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Body Quality Library and couldn't find body quality %s", "s_vehicleBodyQualityIdx >= 0 && s_vehicleBodyQualityIdx < s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.getSize()", s_vehicleBodyQualityName) )
      __debugbreak();
    do
      HavokPhysics_AddBodyQualityLibraryToWorld(&s_havokPhysicsBodyQualityLibrary, (Physics_WorldId)v4++);
    while ( v4 < 8 );
  }
  else if ( physicsLibrary->isMaterialList )
  {
    if ( s_havokPhysicsMaterialLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6712, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.list == nullptr)", "%s\n\tOnly 1 Havok Material library supported", "s_havokPhysicsMaterialLibrary.list == HK_NULL") )
      __debugbreak();
    s_havokPhysicsMaterialLibrary.asset = physicsLibrary;
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v11, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMaterialList::typeData);
    v12 = (HavokPhysicsMaterialList *)result.m_addr;
    if ( result.m_addr )
    {
      v13 = 0;
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMaterialList::typeData) )
        v12 = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v13 = 0;
      v12 = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsMaterialLibrary.list = v12;
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6715, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsMaterialLibrary.list") )
      __debugbreak();
    s_havokPhysicsMaterialLibrary.firstId.m_value = 4;
    s_havokPhysicsMaterialLibrary.lastId.m_value = LOWORD(s_havokPhysicsMaterialLibrary.list->m_materials.m_size) + 3;
    do
      HavokPhysics_AddMaterialLibraryToWorld(&s_havokPhysicsMaterialLibrary, (Physics_WorldId)v13++);
    while ( v13 < 8 );
  }
  else if ( physicsLibrary->isMotionPropertiesList )
  {
    if ( s_havokPhysicsMotionPropertiesLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6733, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list == nullptr)", "%s\n\tOnly 1 Havok Motion Properties library supported", "s_havokPhysicsMotionPropertiesLibrary.list == HK_NULL") )
      __debugbreak();
    s_havokPhysicsMotionPropertiesLibrary.asset = physicsLibrary;
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v14, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsMotionPropertiesList::typeData);
    v15 = (HavokPhysicsMotionPropertiesList *)result.m_addr;
    if ( result.m_addr )
    {
      v16 = 0;
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsMotionPropertiesList::typeData) )
        v15 = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v16 = 0;
      v15 = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsMotionPropertiesLibrary.list = v15;
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6736, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsMotionPropertiesLibrary.list") )
      __debugbreak();
    s_havokPhysicsMotionPropertiesLibrary.firstId.m_value = 5;
    s_havokPhysicsMotionPropertiesLibrary.lastId.m_value = LOWORD(s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) + 4;
    v17 = 0;
    v18 = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_data;
    for ( i = &v18[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size]; v18 != i; ++v18 )
    {
      if ( *v18 == s_staticMotionPropertiesCRC )
      {
        s_staticMotionPropertiesIdx = v17;
      }
      else
      {
        v20 = s_keyframedMotionPropertiesIdx;
        if ( *v18 == s_keyframedMotionPropertiesCRC )
          v20 = v17;
        s_keyframedMotionPropertiesIdx = v20;
      }
      ++v17;
    }
    if ( (s_staticMotionPropertiesIdx < 0 || s_staticMotionPropertiesIdx >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6760, ASSERT_TYPE_ASSERT, "(s_staticMotionPropertiesIdx >= 0 && s_staticMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and couldn't find motion Property%s", "s_staticMotionPropertiesIdx >= 0 && s_staticMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize()", s_staticMotionPropertiesName) )
      __debugbreak();
    if ( (s_keyframedMotionPropertiesIdx < 0 || s_keyframedMotionPropertiesIdx >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6761, ASSERT_TYPE_ASSERT, "(s_keyframedMotionPropertiesIdx >= 0 && s_keyframedMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize())", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and couldn't find motion Property%s", "s_keyframedMotionPropertiesIdx >= 0 && s_keyframedMotionPropertiesIdx < s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize()", s_keyframedMotionPropertiesName) )
      __debugbreak();
    s_motionPropertiesAreReorderedForSPGold = 1;
    if ( s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size >= 0xBu )
      goto LABEL_173;
    LODWORD(v25) = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6770, ASSERT_TYPE_ASSERT, "(!s_motionPropertiesAreReorderedForSPGold || s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize() >= SP_GOLD_MOTION_PROPERTIES_LIST_COUNT)", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and expected at least %i motion properties from SP gold, but found %i", "!s_motionPropertiesAreReorderedForSPGold || s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.getSize() >= SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", v25, s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size) )
      __debugbreak();
    if ( s_motionPropertiesAreReorderedForSPGold )
    {
LABEL_173:
      if ( (unsigned int)s_staticMotionPropertiesIdx >= 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6771, ASSERT_TYPE_ASSERT, "(!s_motionPropertiesAreReorderedForSPGold || s_staticMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT)", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and found motion property %s after the last SP gold index", "!s_motionPropertiesAreReorderedForSPGold || s_staticMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", s_staticMotionPropertiesName) )
        __debugbreak();
      if ( s_motionPropertiesAreReorderedForSPGold && (unsigned int)s_keyframedMotionPropertiesIdx >= 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6772, ASSERT_TYPE_ASSERT, "(!s_motionPropertiesAreReorderedForSPGold || s_keyframedMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT)", "%s\n\tHavokPhysics: Trying to Add Physics Motion Properties Library and found motion property %s after the last SP gold index", "!s_motionPropertiesAreReorderedForSPGold || s_keyframedMotionPropertiesIdx < SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", s_keyframedMotionPropertiesName) )
        __debugbreak();
    }
    do
      HavokPhysics_AddMotionPropertiesLibraryToWorld(&s_havokPhysicsMotionPropertiesLibrary, (Physics_WorldId)v16++);
    while ( v16 < 8 );
  }
  else if ( physicsLibrary->isGlobalTypeCompendium )
  {
    if ( s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6784, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", s_havokPhysicsGlobalTypeCompendiumTypes, NULL) )
      __debugbreak();
    if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
      __debugbreak();
    if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&v26);
    hkSerialize::InplaceLoad::toVar(v21, &result, physicsLibrary->havokData, physicsLibrary->havokDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&hkReflect::ReflectionOf<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>>::typeData);
    v22 = (hkArray<hkReflect::Type const *,hkContainerHeapAllocator> *)result.m_addr;
    if ( result.m_addr )
    {
      if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &hkReflect::ReflectionOf<hkArray<hkReflect::Type const *,hkContainerHeapAllocator>>::typeData) )
        v22 = NULL;
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    }
    else
    {
      if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
        hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
      v22 = NULL;
    }
    hkSerialize::InplaceLoad::~InplaceLoad(&v26);
    s_havokPhysicsGlobalTypeCompendiumTypes = v22;
    if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6786, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", NULL, NULL) )
      __debugbreak();
    if ( s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6789, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", s_havokPhysicsGlobalTypeCompendiumData, NULL) )
      __debugbreak();
    *(_QWORD *)s_havokPhysicsGlobalTypeCompendiumDataBuffer = 0i64;
    *(_DWORD *)&s_havokPhysicsGlobalTypeCompendiumDataBuffer[8] = 0;
    *(_DWORD *)&s_havokPhysicsGlobalTypeCompendiumDataBuffer[12] = 0x80000000;
    s_havokPhysicsGlobalTypeCompendiumData = (hkArray<char,hkContainerHeapAllocator> *)s_havokPhysicsGlobalTypeCompendiumDataBuffer;
    HostString = hkReflect::TypeCopier::getHostString();
    HavokPhysics_GlobalTypeCompendium_PrepareData(s_havokPhysicsGlobalTypeCompendiumData, s_havokPhysicsGlobalTypeCompendiumTypes, HostString);
    if ( s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6795, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", s_havokPhysicsInPlaceLoad, NULL) )
      __debugbreak();
    hkSerialize::InplaceLoad::InplaceLoad(&s_havokPhysicsInPlaceLoadBuffer);
    s_havokPhysicsInPlaceLoad = v24;
    if ( !v24 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6797, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
        __debugbreak();
      v24 = s_havokPhysicsInPlaceLoad;
    }
    HavokPhysics_GlobalTypeCompendium_PrepareInplaceLoad(v24, s_havokPhysicsGlobalTypeCompendiumData);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6804, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Library - type unknown") )
  {
    __debugbreak();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_AddPhysicsSFXAssetInternal
==============
*/
__int64 HavokPhysics_AddPhysicsSFXAssetInternal(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  unsigned int i; 
  __int64 v5; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  int v8; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 j; 
  int v12; 
  PhysicsSFXEventAsset *val; 
  const char *v14; 
  __int64 v15; 
  const char *v16; 
  signed __int64 v17; 
  char v18; 
  __int64 v19; 
  char v20; 
  __int64 v21; 
  bool v22; 
  __int64 v23; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v24; 
  int v25; 
  int v26; 
  int v27; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v28; 
  unsigned __int32 v29; 
  unsigned int key; 
  __int64 v31; 
  hkMemoryAllocator alloc; 

  if ( !physicsSFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7009, ASSERT_TYPE_ASSERT, "(physicsSFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsSFXEventAsset", "physicsSFXEventAsset") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7010, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", "%s\n\tTrying to add a physics SFXevent asset but the container is NULL", "g_physicsSFXEventAssets") )
    __debugbreak();
  name = physicsSFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  for ( i = -1; v3; --v3 )
  {
    v5 = *(unsigned __int8 *)name++;
    i = (i >> 8) ^ g_crc32Table[v5 ^ (unsigned __int8)i];
  }
  v6 = ~i;
  HavokPhysics_LockAssetWrite();
  v7 = g_physicsSFXEventAssets;
  v8 = 0;
  m_hashMod = g_physicsSFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsSFXEventAssets->m_elem;
    for ( j = 0i64; j <= m_hashMod; ++j )
    {
      if ( m_elem->key != -1 )
        break;
      ++v8;
      ++m_elem;
    }
  }
  v12 = 1;
  if ( v8 <= (int)m_hashMod )
  {
    do
    {
      val = v7->m_elem[v8].val;
      if ( val == physicsSFXEventAsset )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7023, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s with the same pointer already exists!", physicsSFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsSFXEventAssets;
      }
      if ( v7->m_elem[v8].key == v6 )
      {
        v14 = physicsSFXEventAsset->name;
        v15 = 0x7FFFFFFFi64;
        v16 = val->name;
        if ( !physicsSFXEventAsset->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v17 = v14 - v16;
        do
        {
          v18 = v16[v17];
          v19 = v15;
          v20 = *v16++;
          --v15;
          if ( !v19 )
            break;
          if ( v18 != v20 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7028, ASSERT_TYPE_ASSERT, "(I_strcmp( physicsSFXEventAsset->name, testAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( physicsSFXEventAsset->name, testAsset->name ) == 0", physicsSFXEventAsset->name, val->name) )
              __debugbreak();
            break;
          }
        }
        while ( v18 );
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7029, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s already added, but with a different pointer", physicsSFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsSFXEventAssets;
      }
      v21 = v7->m_hashMod;
      v22 = ++v8 <= (int)v21;
      if ( v8 <= (int)v21 )
      {
        v23 = v8;
        v24 = &v7->m_elem[v8];
        do
        {
          if ( v24->key != -1 )
            break;
          ++v8;
          ++v23;
          ++v24;
        }
        while ( v23 <= v21 );
        v22 = v8 <= (int)v21;
      }
    }
    while ( v22 );
  }
  v25 = (unsigned int)hkMemHeapAllocator();
  v26 = v7->m_hashMod;
  v27 = v26;
  if ( 2 * v7->m_numElems > v26 )
  {
    hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>>::resizeTable(v7, &alloc, v25);
    v26 = v7->m_hashMod;
    v27 = v26;
  }
  v28 = v7->m_elem;
  v29 = v27 & _byteswap_ulong(-1640531535 * v6);
  key = v7->m_elem[v29].key;
  if ( key != -1 )
  {
    while ( key != v6 )
    {
      v29 = v26 & (v29 + 1);
      key = v28[v29].key;
      if ( key == -1 )
        goto LABEL_50;
    }
    v12 = 0;
  }
LABEL_50:
  v7->m_numElems += v12;
  v31 = (int)v29;
  v28[v31].key = v6;
  v7->m_elem[v31].val = physicsSFXEventAsset;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v6;
}

/*
==============
HavokPhysics_AddPhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  HavokPhysics_AddPhysicsSFXAssetInternal(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_AddPhysicsVFXAssetInternal
==============
*/
__int64 HavokPhysics_AddPhysicsVFXAssetInternal(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  unsigned int i; 
  __int64 v5; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  int v8; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 j; 
  int v12; 
  PhysicsVFXEventAsset *val; 
  const char *v14; 
  __int64 v15; 
  const char *v16; 
  signed __int64 v17; 
  char v18; 
  __int64 v19; 
  char v20; 
  __int64 v21; 
  bool v22; 
  __int64 v23; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v24; 
  int v25; 
  int v26; 
  int v27; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v28; 
  unsigned __int32 v29; 
  unsigned int key; 
  __int64 v31; 
  hkMemoryAllocator alloc; 

  if ( !physicsVFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7173, ASSERT_TYPE_ASSERT, "(physicsVFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsVFXEventAsset", "physicsVFXEventAsset") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7174, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", "%s\n\tTrying to Add a physics VFXevent asset but the container is NULL", "g_physicsVFXEventAssets") )
    __debugbreak();
  name = physicsVFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  for ( i = -1; v3; --v3 )
  {
    v5 = *(unsigned __int8 *)name++;
    i = (i >> 8) ^ g_crc32Table[v5 ^ (unsigned __int8)i];
  }
  v6 = ~i;
  HavokPhysics_LockAssetWrite();
  v7 = g_physicsVFXEventAssets;
  v8 = 0;
  m_hashMod = g_physicsVFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsVFXEventAssets->m_elem;
    for ( j = 0i64; j <= m_hashMod; ++j )
    {
      if ( m_elem->key != -1 )
        break;
      ++v8;
      ++m_elem;
    }
  }
  v12 = 1;
  if ( v8 <= (int)m_hashMod )
  {
    do
    {
      val = v7->m_elem[v8].val;
      if ( val == physicsVFXEventAsset )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7187, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s with the same pointer already exists!", physicsVFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsVFXEventAssets;
      }
      if ( v7->m_elem[v8].key == v6 )
      {
        v14 = physicsVFXEventAsset->name;
        v15 = 0x7FFFFFFFi64;
        v16 = val->name;
        if ( !physicsVFXEventAsset->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v17 = v14 - v16;
        do
        {
          v18 = v16[v17];
          v19 = v15;
          v20 = *v16++;
          --v15;
          if ( !v19 )
            break;
          if ( v18 != v20 )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7192, ASSERT_TYPE_ASSERT, "(I_strcmp( physicsVFXEventAsset->name, testAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( physicsVFXEventAsset->name, testAsset->name ) == 0", physicsVFXEventAsset->name, val->name) )
              __debugbreak();
            break;
          }
        }
        while ( v18 );
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7193, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Asset %s already added, but with a different pointer", physicsVFXEventAsset->name) )
          __debugbreak();
        v7 = g_physicsVFXEventAssets;
      }
      v21 = v7->m_hashMod;
      v22 = ++v8 <= (int)v21;
      if ( v8 <= (int)v21 )
      {
        v23 = v8;
        v24 = &v7->m_elem[v8];
        do
        {
          if ( v24->key != -1 )
            break;
          ++v8;
          ++v23;
          ++v24;
        }
        while ( v23 <= v21 );
        v22 = v8 <= (int)v21;
      }
    }
    while ( v22 );
  }
  v25 = (unsigned int)hkMemHeapAllocator();
  v26 = v7->m_hashMod;
  v27 = v26;
  if ( 2 * v7->m_numElems > v26 )
  {
    hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>>::resizeTable(v7, &alloc, v25);
    v26 = v7->m_hashMod;
    v27 = v26;
  }
  v28 = v7->m_elem;
  v29 = v27 & _byteswap_ulong(-1640531535 * v6);
  key = v7->m_elem[v29].key;
  if ( key != -1 )
  {
    while ( key != v6 )
    {
      v29 = v26 & (v29 + 1);
      key = v28[v29].key;
      if ( key == -1 )
        goto LABEL_50;
    }
    v12 = 0;
  }
LABEL_50:
  v7->m_numElems += v12;
  v31 = (int)v29;
  v28[v31].key = v6;
  v7->m_elem[v31].val = physicsVFXEventAsset;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v6;
}

/*
==============
HavokPhysics_AddPhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_AddPhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  HavokPhysics_AddPhysicsVFXAssetInternal(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_AddRigidBodies
==============
*/
void HavokPhysics_AddRigidBodies(HavokPhysicsWorld *world, hknpBodyId *bodies, int bodyCount, bool immediateAdd, bool tryStartDeactivated)
{
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8914, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( bodyCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8916, ASSERT_TYPE_ASSERT, "(bodyCount > 0)", (const char *)&queryFormat, "bodyCount > 0") )
    __debugbreak();
  ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, _QWORD, bool))world->world->addBodies)(&world->world->hknpWorldWriter, bodies, (unsigned int)bodyCount, !immediateAdd);
}

/*
==============
HavokPhysics_AddRigidBodyContents
==============
*/
void HavokPhysics_AddRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 
  _BOOL8 v10; 
  __int64 v11; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11932, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11933, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Add RigidBody contents with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11938, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics AddRigidBodyContents %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v10 = !forceCacheRebuild && (*(_BYTE *)(v9 + 68) & 9) == 0;
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, _BOOL8))MutableWorld->world->setBodyCollisionFilterInfo)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, (unsigned int)contents | *(_DWORD *)(v9 + 108), v10);
}

/*
==============
HavokPhysics_AddRigidBodyIdToArray
==============
*/
void HavokPhysics_AddRigidBodyIdToArray(hkArray<hknpBodyId,hkContainerHeapAllocator> *array, hknpBodyId bodyId)
{
  hkMemoryAllocator *v4; 
  int m_size; 

  v4 = hkMemHeapAllocator();
  m_size = array->m_size;
  if ( m_size == (array->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v4, array, 4);
    m_size = array->m_size;
  }
  array->m_data[m_size] = bodyId;
  ++array->m_size;
}

/*
==============
HavokPhysics_AddShapeList
==============
*/
HavokPhysicsShapeList *HavokPhysics_AddShapeList(char **rawShapeData, unsigned int *rawShapeDataSize, const char *name, int type)
{
  hkSerialize::InplaceLoad *v6; 
  int *m_addr; 
  __int64 v8; 
  int v9; 
  int m_size; 
  __int64 v12; 
  hkSerialize::InplaceLoad v13; 
  hkReflect::Var result; 

  if ( !*rawShapeData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24164, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !*rawShapeDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24165, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  hkSerialize::InplaceLoad::InplaceLoad(&v13);
  hkSerialize::InplaceLoad::toVar(v6, &result, *rawShapeData, *rawShapeDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsShapeList::typeData);
  m_addr = (int *)result.m_addr;
  if ( result.m_addr )
  {
    if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsShapeList::typeData) )
      m_addr = NULL;
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  }
  else
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
  }
  hkSerialize::InplaceLoad::~InplaceLoad(&v13);
  if ( !m_addr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7588, ASSERT_TYPE_ASSERT, "(shapeList)", (const char *)&queryFormat, "shapeList") )
    __debugbreak();
  v8 = *((_QWORD *)m_addr + 13);
  if ( v8 != v8 + 24i64 * m_addr[28] )
  {
    do
    {
      v9 = 0;
      m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
      if ( m_size > 0 )
      {
        do
        {
          if ( *(_DWORD *)(v8 + 4) == s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v9] )
            break;
          ++v9;
        }
        while ( v9 < m_size );
      }
      if ( v9 >= m_size )
      {
        LODWORD(v12) = *(_DWORD *)(v8 + 4);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7616, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", "%s\n\tHavokPhysics: Couldn't find material crc %x", "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()", v12) )
          __debugbreak();
      }
      *(_WORD *)(v8 + 8) = s_havokPhysicsMaterialLibrary.firstId.m_value + v9;
      v8 += 24i64;
    }
    while ( v8 != *((_QWORD *)m_addr + 13) + 24i64 * m_addr[28] );
  }
  return (HavokPhysicsShapeList *)m_addr;
}

/*
==============
HavokPhysics_AddShapeReference
==============
*/

void __fastcall HavokPhysics_AddShapeReference(hknpShape *shape)
{
  hkReferencedObject::addReference(shape);
}

/*
==============
HavokPhysics_AddXModelAsset
==============
*/
void HavokPhysics_AddXModelAsset(XModel *xmodel)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v2; 
  hkMemoryAllocator *v3; 
  int m_size; 

  if ( !xmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7775, ASSERT_TYPE_ASSERT, "(xmodel)", "%s\n\tTrying to add a NULL XModel Asset", "xmodel") )
    __debugbreak();
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7778, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Add an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  if ( HavokPhysics_DebugXModelGetIndex(xmodel) >= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7779, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( xmodel ) < 0)", "%s\n\txmodel %s already exists in debug list", "HavokPhysics_DebugXModelGetIndex( xmodel ) < 0", xmodel->name) )
    __debugbreak();
  v2 = s_havokPhysicsXModels;
  v3 = hkMemHeapAllocator();
  m_size = v2->m_size;
  if ( m_size == (v2->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v3, v2, 8);
    m_size = v2->m_size;
  }
  v2->m_data[m_size] = xmodel;
  ++v2->m_size;
}

/*
==============
HavokPhysics_AddXModelDetailCollisionAsset
==============
*/
void HavokPhysics_AddXModelDetailCollisionAsset(XModelDetailCollision *detailCollision)
{
  XModelDetailCollision *v1; 
  int *m_addr; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v3; 
  int v4; 
  int m_hashMod; 
  int v6; 
  int v7; 
  unsigned __int32 v8; 
  unsigned __int32 v9; 
  unsigned int v10; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  XModelDetailCollision *key; 
  __int64 v13; 
  __int64 v14; 
  unsigned __int8 *v15; 
  unsigned int i; 
  unsigned __int64 v17; 
  hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *v18; 
  int v19; 
  unsigned __int32 v20; 
  unsigned __int32 v21; 
  int v22; 
  int v23; 
  unsigned __int64 v24; 
  unsigned __int64 m_size; 
  int v26; 
  int v27; 
  unsigned __int32 v28; 
  unsigned __int32 v29; 
  unsigned int v30; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v31; 
  unsigned __int64 v32; 
  __int64 v33; 
  hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *v34; 
  hkMemoryAllocator *v35; 
  int v36; 
  int v37; 
  hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator> *m_data; 
  __int64 v39; 
  hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator> *v40; 
  int v41; 
  __int64 v42; 
  hkMemoryAllocator *v43; 
  int v44; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *v45; 
  __int64 v46; 
  __int64 v47; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *v48; 
  __int64 v49; 
  __int64 v50; 
  int v51; 
  __int64 v52; 
  __int64 v53; 
  int v54; 
  __int64 v55; 
  const char *v56; 
  hkMemoryAllocator alloc; 
  XModelDetailCollision *v58; 
  hkReflect::Var result; 
  __int64 v60; 
  char dest[256]; 

  v60 = -2i64;
  v1 = detailCollision;
  v58 = detailCollision;
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7788, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tTrying to add a NULL physics LOD", "detailCollision") )
    __debugbreak();
  if ( !v1->physicsLODDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7790, ASSERT_TYPE_ASSERT, "(detailCollision->physicsLODDataSize)", "%s\n\tPhysics LOD should not be empty", "detailCollision->physicsLODDataSize") )
    __debugbreak();
  if ( !v1->physicsLODData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24185, ASSERT_TYPE_ASSERT, "(*outData)", (const char *)&queryFormat, "*outData") )
    __debugbreak();
  if ( !v1->physicsLODDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24186, ASSERT_TYPE_ASSERT, "(*outSize > 0)", (const char *)&queryFormat, "*outSize > 0") )
    __debugbreak();
  if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24187, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
    __debugbreak();
  hkSerialize::InplaceLoad::toVar(s_havokPhysicsInPlaceLoad, &result, v1->physicsLODData, v1->physicsLODDataSize, (const hkReflect::QualifiedType<hkReflect::Type>)&HavokPhysicsXModelLOD::typeData);
  m_addr = (int *)result.m_addr;
  if ( !result.m_addr )
  {
    if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
      hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
    m_addr = NULL;
    goto LABEL_27;
  }
  if ( !result.m_type.m_type || !hkReflect::Type::extendsOrEquals((hkReflect::Type *)result.m_type.m_type, &HavokPhysicsXModelLOD::typeData) )
    m_addr = NULL;
  if ( ((__int64)result.m_impl.m_ptrAndInt & 1) != 0 )
    hkReflect::Detail::Impl::removeReference((hkReflect::Detail::Impl *)((unsigned __int64)result.m_impl.m_ptrAndInt & 0xFFFFFFFFFFFFFFFEui64));
  if ( !m_addr )
  {
LABEL_27:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7795, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", "%s\n\tCouldn't load XModel Physics LOD %s", "havokPhysicsXModelLOD", v1->name) )
      __debugbreak();
  }
  HavokPhysics_LockAssetWrite();
  if ( !s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7800, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tTrying to Add a physics LOD asset but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
    __debugbreak();
  v3 = s_havokPhysicsXModelLODs;
  v4 = (unsigned int)hkMemHeapAllocator();
  m_hashMod = v3->m_map.m_hashMod;
  if ( 2 * v3->m_map.m_numElems > m_hashMod )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v3->m_map, (hkMemoryAllocator *)((char *)&alloc.__vftable + 4), v4);
    m_hashMod = v3->m_map.m_hashMod;
  }
  v6 = 1;
  v7 = 1;
  v8 = _byteswap_ulong(-1640531535 * (_DWORD)v1);
  v9 = _byteswap_ulong(-1640531535 * HIDWORD(v1));
  v10 = m_hashMod & (v9 ^ ((v8 >> 2) + v8 + (v9 << 6) - 1640531527));
  m_elem = v3->m_map.m_elem;
  key = (XModelDetailCollision *)v3->m_map.m_elem[v10].key;
  if ( key != (XModelDetailCollision *)-1i64 )
  {
    while ( key != v1 )
    {
      v10 = v3->m_map.m_hashMod & (v10 + 1);
      key = (XModelDetailCollision *)m_elem[v10].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_39;
    }
    v7 = 0;
  }
LABEL_39:
  v3->m_map.m_numElems += v7;
  v13 = (int)v10;
  m_elem[v13].key = (unsigned __int64)v1;
  v3->m_map.m_elem[v13].val = (unsigned __int64)m_addr;
  v14 = 8i64 * m_addr[14];
  v15 = (unsigned __int8 *)*((_QWORD *)m_addr + 6);
  for ( i = -1; v14; --v14 )
    i = (i >> 8) ^ g_crc32Table[*v15++ ^ (unsigned __int64)(unsigned __int8)i];
  v17 = ~i;
  v18 = s_havokPhysicsXModelLODShapeTagLookup;
  v19 = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_hashMod;
  if ( v19 <= 0 || (v20 = _byteswap_ulong(-1640531535 * v17), v21 = _byteswap_ulong(0), v22 = v19 & (v21 ^ ((v20 >> 2) + v20 + (v21 << 6) - 1640531527)), v23 = v22, v24 = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_elem[v22].key, v24 == -1i64) )
  {
LABEL_45:
    v23 = v19 + 1;
  }
  else
  {
    while ( v24 != v17 )
    {
      v22 = v19 & (v22 + 1);
      v23 = v22;
      v24 = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_elem[v22].key;
      if ( v24 == -1i64 )
        goto LABEL_45;
    }
  }
  if ( v23 > v19 )
  {
    LODWORD(alloc.__vftable) = -2147220992;
    m_size = (unsigned int)g_havokPhysicsXModelLODShapeTagDatas->m_size;
    v26 = (unsigned int)hkMemHeapAllocator();
    v27 = v18->m_map.m_hashMod;
    if ( 2 * v18->m_map.m_numElems > v27 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v18->m_map, &alloc, v26);
      v27 = v18->m_map.m_hashMod;
    }
    v28 = _byteswap_ulong(-1640531535 * v17);
    v29 = _byteswap_ulong(-1640531535 * HIDWORD(v17));
    v30 = v27 & (v29 ^ ((v28 >> 2) + v28 + (v29 << 6) - 1640531527));
    v31 = v18->m_map.m_elem;
    v32 = v18->m_map.m_elem[v30].key;
    if ( v32 != -1i64 )
    {
      while ( v32 != v17 )
      {
        v30 = v18->m_map.m_hashMod & (v30 + 1);
        v32 = v31[v30].key;
        if ( v32 == -1i64 )
          goto LABEL_55;
      }
      v6 = 0;
    }
LABEL_55:
    v18->m_map.m_numElems += v6;
    v33 = (int)v30;
    v31[v33].key = v17;
    v18->m_map.m_elem[v33].val = m_size;
    v34 = g_havokPhysicsXModelLODShapeTagDatas;
    v35 = hkMemHeapAllocator();
    v36 = v34->m_size;
    v37 = v36;
    if ( v36 == (v34->m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v35, v34, 16);
      v36 = v34->m_size;
      v37 = v36;
    }
    m_data = v34->m_data;
    v39 = (__int64)&v34->m_data[v36];
    if ( v39 )
    {
      *(_QWORD *)v39 = 0i64;
      *(_DWORD *)(v39 + 8) = 0;
      *(_DWORD *)(v39 + 12) = 0x80000000;
      v37 = v34->m_size;
      m_data = v34->m_data;
    }
    v40 = &m_data[v37];
    v34->m_size = v37 + 1;
    v41 = m_addr[14];
    v42 = *((_QWORD *)m_addr + 6);
    v43 = hkMemHeapAllocator();
    if ( (v40->m_capacityAndFlags & 0x3FFFFFFF) < v41 )
      hkArrayUtil::_reserve(v43, v40, v41, 8);
    v44 = v41;
    if ( v41 > v40->m_size )
      v44 = v40->m_size;
    v45 = v40->m_data;
    if ( v44 > 0 )
    {
      v46 = v42 - (_QWORD)v45;
      v47 = v44;
      do
      {
        *v45 = *(HavokPhysicsXModelLOD::XModelCollisionTagData *)((char *)v45 + v46);
        ++v45;
        --v47;
      }
      while ( v47 );
      v45 = v40->m_data;
    }
    v48 = &v45[v44];
    v49 = v41 - v44;
    if ( v41 - v44 > 0 )
    {
      v50 = v42 + 8i64 * v44 - (_QWORD)v48;
      do
      {
        if ( v48 )
          *v48 = *(HavokPhysicsXModelLOD::XModelCollisionTagData *)((char *)v48 + v50);
        ++v48;
        --v49;
      }
      while ( v49 );
    }
    v40->m_size = v41;
  }
  else
  {
    m_size = s_havokPhysicsXModelLODShapeTagLookup->m_map.m_elem[v23].val;
  }
  v51 = 0;
  if ( m_addr[2] > 0 )
  {
    v52 = 0i64;
    do
    {
      v53 = *(_QWORD *)(v52 + *(_QWORD *)m_addr);
      if ( (*(_BYTE *)(v53 + 24) & 4) == 0 )
        v53 = 0i64;
      if ( !v53 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7819, ASSERT_TYPE_ASSERT, "(compositeShape)", (const char *)&queryFormat, "compositeShape") )
        __debugbreak();
      *(_DWORD *)(v53 + 56) = m_size;
      ++v51;
      v52 += 8i64;
    }
    while ( v51 < m_addr[2] );
    v1 = v58;
  }
  v54 = 0;
  if ( m_addr[6] > 0 )
  {
    v55 = 0i64;
    do
    {
      v56 = (const char *)(*(_QWORD *)(v55 + *((_QWORD *)m_addr + 2)) & 0xFFFFFFFFFFFFFFFEui64);
      Core_strcpy(dest, 0x100ui64, v56);
      I_strlwr(dest);
      if ( !SL_FindString(dest) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7846, ASSERT_TYPE_ASSERT, "(scrName != ( static_cast< scr_string_t >( 0 ) ))", "%s\n\tCouldn't find script string for bone %s in detailCollision %s", "scrName != NULL_SCR_STRING", v56, v1->name) )
        __debugbreak();
      ++v54;
      v55 += 8i64;
    }
    while ( v54 < m_addr[6] );
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_AllocateBroadphaseCollisionQueryResult
==============
*/
HavokPhysics_BroadphaseCollisionQueryResult *HavokPhysics_AllocateBroadphaseCollisionQueryResult(Physics_WorldId worldId)
{
  hkMemoryRouter *Value; 
  HavokPhysics_BroadphaseCollisionQueryResult *result; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  result = (HavokPhysics_BroadphaseCollisionQueryResult *)Value->m_heap->blockAlloc(Value->m_heap, 48i64);
  if ( result )
  {
    result->m_propertyBag.m_bag = NULL;
    result->__vftable = (HavokPhysics_BroadphaseCollisionQueryResult_vtbl *)&HavokPhysics_BroadphaseCollisionQueryResult::`vftable';
    *(_DWORD *)&result->m_memSizeAndFlags = 0x1FFFF;
    result->m_hits.m_data = NULL;
    result->m_hits.m_size = 0;
    result->m_hits.m_capacityAndFlags = 0x80000000;
    result->m_worldId = worldId;
  }
  else
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13561, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    result = NULL;
    MEMORY[0x28] = worldId;
  }
  return result;
}

/*
==============
HavokPhysics_AllocateCollisionQueryResult
==============
*/
HavokPhysics_CollisionQueryResult *HavokPhysics_AllocateCollisionQueryResult(Physics_WorldId worldId, Physics_CollisionQueryCollectionType type)
{
  hkMemoryRouter *Value; 
  __int64 v5; 
  __int64 v6; 
  hknpCollisionQueryCollector *v7; 
  hkMemoryRouter *v8; 
  HavokPhysicsHitCollector *v9; 
  __int64 v10; 
  hkMemoryRouter *v11; 
  HavokPhysicsAllHitsCollector *v12; 
  hknpCollisionQueryCollector *v13; 
  hkMemoryRouter *v14; 
  HavokPhysicsClosestHitCollector *v15; 
  hknpCollisionQueryCollector *v16; 
  hkMemoryRouter *v17; 
  HavokPhysicsAnyHitCollector *v18; 
  hknpCollisionQueryCollector *v19; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v5 = (__int64)Value->m_heap->blockAlloc(Value->m_heap, 40i64);
  v6 = v5;
  v7 = NULL;
  if ( v5 )
  {
    *(_QWORD *)(v5 + 8) = 0i64;
    *(_DWORD *)(v5 + 16) = 0x1FFFF;
    *(_QWORD *)v5 = &HavokPhysics_CollisionQueryResult::`vftable';
  }
  else
  {
    v6 = 0i64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13590, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result", -2i64) )
      __debugbreak();
  }
  *(_DWORD *)(v6 + 32) = worldId;
  v8 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v8 )
    v8 = hkMemoryRouter::s_fallbackRouter;
  v9 = (HavokPhysicsHitCollector *)v8->m_heap->blockAlloc(v8->m_heap, 144i64);
  if ( v9 )
    HavokPhysicsHitCollector::HavokPhysicsHitCollector(v9);
  else
    v10 = 0i64;
  *(_QWORD *)(v6 + 24) = v10;
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13598, ASSERT_TYPE_ASSERT, "(result->m_collector)", (const char *)&queryFormat, "result->m_collector") )
    __debugbreak();
  switch ( type )
  {
    case PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ANY:
      v17 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v17 )
        v17 = hkMemoryRouter::s_fallbackRouter;
      v18 = (HavokPhysicsAnyHitCollector *)v17->m_heap->blockAlloc(v17->m_heap, 176i64);
      if ( v18 )
      {
        HavokPhysicsAnyHitCollector::HavokPhysicsAnyHitCollector(v18, *(HavokPhysicsHitCollector **)(v6 + 24), worldId);
        v7 = v19;
      }
LABEL_34:
      if ( v7 )
        goto LABEL_37;
      goto LABEL_35;
    case PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST:
      v14 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v14 )
        v14 = hkMemoryRouter::s_fallbackRouter;
      v15 = (HavokPhysicsClosestHitCollector *)v14->m_heap->blockAlloc(v14->m_heap, 176i64);
      if ( v15 )
      {
        HavokPhysicsClosestHitCollector::HavokPhysicsClosestHitCollector(v15, *(HavokPhysicsHitCollector **)(v6 + 24), worldId);
        v7 = v16;
      }
      goto LABEL_34;
    case PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL:
      v11 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v11 )
        v11 = hkMemoryRouter::s_fallbackRouter;
      v12 = (HavokPhysicsAllHitsCollector *)v11->m_heap->blockAlloc(v11->m_heap, 1216i64);
      if ( v12 )
      {
        HavokPhysicsAllHitsCollector::HavokPhysicsAllHitsCollector(v12, *(HavokPhysicsHitCollector **)(v6 + 24), worldId);
        v7 = v13;
      }
      goto LABEL_34;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13624, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics: Invalid type for collector") )
    __debugbreak();
LABEL_35:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13630, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
    __debugbreak();
LABEL_37:
  HavokPhysicsHitCollector::SetCollector(*(HavokPhysicsHitCollector **)(v6 + 24), type, v7);
  return (HavokPhysics_CollisionQueryResult *)v6;
}

/*
==============
HavokPhysics_AllocateIgnoreBodies
==============
*/
HavokPhysics_IgnoreBodies *HavokPhysics_AllocateIgnoreBodies(int minEntities, int minBodies)
{
  hkMemoryRouter *Value; 
  HavokPhysics_IgnoreBodies *v5; 
  __int64 v6; 
  __int64 v7; 

  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v5 = (HavokPhysics_IgnoreBodies *)Value->m_heap->blockAlloc(Value->m_heap, 56i64);
  if ( v5 )
  {
    HavokPhysics_IgnoreBodies::HavokPhysics_IgnoreBodies(v5, minEntities, minBodies);
    v7 = v6;
  }
  else
  {
    v7 = 0i64;
  }
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13694, ASSERT_TYPE_ASSERT, "(ignoreBodies)", (const char *)&queryFormat, "ignoreBodies", -2i64) )
    __debugbreak();
  return (HavokPhysics_IgnoreBodies *)v7;
}

/*
==============
HavokPhysics_AntilagRestoreInstanceTo
==============
*/
void HavokPhysics_AntilagRestoreInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation)
{
  __int64 v4; 
  hknpWorld *world; 
  unsigned int v9; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int m_serialAndIndex; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  hknpBodyId result; 
  int NumRigidBodys; 
  hkTransformf t; 
  hkTransformf bTc; 
  hkTransformf v20; 
  hkTransformf transform; 
  hkTransformf aTb; 
  hkTransformf v23; 

  v4 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12375, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v4 == -1 )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12376, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v13) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v13) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12381, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v13) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v20.m_rotation, hkOrientation);
  v20.m_translation = (hkVector4f)hkPosition->m_quad;
  v9 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v4);
  if ( NumRigidBodys > 0 )
  {
    do
    {
      if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        LODWORD(v13) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v13) )
          __debugbreak();
      }
      if ( (_DWORD)v4 == -1 )
      {
        LODWORD(v13) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v13) )
          __debugbreak();
      }
      ConstWorld = HavokPhysics_GetConstWorld(worldId);
      if ( !ConstWorld->world )
      {
        LODWORD(v13) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v13) )
          __debugbreak();
      }
      p_instanceManager = &ConstWorld->instanceManager;
      if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
        __debugbreak();
      if ( (_DWORD)v4 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
        __debugbreak();
      if ( v9 >= p_instanceManager->buffer[v4].bodies.m_size )
      {
        LODWORD(v14) = worldId;
        LODWORD(v13) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v13, v14) )
          __debugbreak();
      }
      HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v4, v9);
      m_serialAndIndex = result.m_serialAndIndex;
      if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
      {
        LODWORD(v15) = worldId;
        LODWORD(v14) = v4;
        LODWORD(v13) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12398, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v13, v14, v15) )
          __debugbreak();
      }
      if ( !v9 )
      {
        t = *(hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, m_serialAndIndex);
        hkTransformf::setInverse(&aTb, &t);
      }
      bTc = *(hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, m_serialAndIndex);
      hkTransformf::setMul(&v23, &aTb, &bTc);
      hkTransformf::setMul(&transform, &v20, &v23);
      hkRotationImpl<float>::renormalize(&transform.m_rotation);
      hknpBody::setTransform(&world->m_bodyManager.m_bodies.m_objects.m_data[m_serialAndIndex & 0xFFFFFF].m_pod, &transform);
      ++v9;
    }
    while ( (int)v9 < NumRigidBodys );
  }
}

/*
==============
HavokPhysics_AntilagWarpInstanceTo
==============
*/
__int64 HavokPhysics_AntilagWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, hkVector4f *hkRestorePosition, hkQuaternionf *hkRestoreOrientation)
{
  __int64 v9; 
  hknpWorld *world; 
  unsigned __int8 v11; 
  unsigned int v12; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  hkQuaternionf *v15; 
  hknpWorld *v16; 
  hknpBroadPhase *UndecoratedBroadPhase; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  hknpBodyId ids; 
  hknpBodyId result; 
  float zero; 
  int NumRigidBodys; 
  hkVector4f *v26; 
  hkQuaternionf *v27; 
  hkTransformf t; 
  hkTransformf bTc; 
  hkTransformf v30; 
  hkTransformf transform; 
  hkTransformf aTb; 
  hkTransformf v33; 

  v26 = hkRestorePosition;
  v27 = hkRestoreOrientation;
  v9 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12295, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v9 == -1 )
  {
    LODWORD(v19) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12296, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v19) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v19) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12301, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v19) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v30.m_rotation, hkOrientation);
  v30.m_translation = (hkVector4f)hkPosition->m_quad;
  v11 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v9);
  v12 = 0;
  if ( NumRigidBodys <= 0 )
    return 0i64;
  do
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v19) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v19) )
        __debugbreak();
    }
    if ( (_DWORD)v9 == -1 )
    {
      LODWORD(v19) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v19) )
        __debugbreak();
    }
    ConstWorld = HavokPhysics_GetConstWorld(worldId);
    if ( !ConstWorld->world )
    {
      LODWORD(v19) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v19) )
        __debugbreak();
    }
    p_instanceManager = &ConstWorld->instanceManager;
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v9 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    if ( v12 >= p_instanceManager->buffer[v9].bodies.m_size )
    {
      LODWORD(v20) = worldId;
      LODWORD(v19) = v12;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v19, v20) )
        __debugbreak();
    }
    HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v9, v12);
    ids.m_serialAndIndex = result.m_serialAndIndex;
    if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(v21) = worldId;
      LODWORD(v20) = v9;
      LODWORD(v19) = v12;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12319, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v19, v20, v21) )
        __debugbreak();
    }
    if ( !v12 )
    {
      t = *(hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, ids.m_serialAndIndex);
      hkTransformf::setInverse(&aTb, &t);
      zero = FLOAT_0_001;
      if ( hkTransformf::isApproximatelyEqual(&t, &v30, &zero) )
        return v11;
      v15 = v27;
      *v26 = t.m_translation;
      hkQuaternionf::set(v15, &t.m_rotation);
    }
    v16 = HavokPhysics_GetMutableWorld(worldId)->world;
    bTc = *(hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, ids.m_serialAndIndex);
    hkTransformf::setMul(&v33, &aTb, &bTc);
    hkTransformf::setMul(&transform, &v30, &v33);
    hkRotationImpl<float>::renormalize(&transform.m_rotation);
    hknpBody::setTransform(&v16->m_bodyManager.m_bodies.m_objects.m_data[ids.m_serialAndIndex & 0xFFFFFF].m_pod, &transform);
    UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(world);
    hknpBroadPhase::markBodiesAntilag(UndecoratedBroadPhase, &ids, 1, 4);
    ++v12;
    v11 = 1;
  }
  while ( (int)v12 < NumRigidBodys );
  return v11;
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/
void HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  HavokPhysicsWorld *MutableWorld; 
  __m128 v11; 
  hknpWorld *world; 
  __int64 v13; 
  __m128 v14; 
  __m128 v15; 
  __int64 v16; 
  __m128 v18; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12859, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12860, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply angular impulse to a Body with invalid body id for world %i", "bodyId.isValid()", v16) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  __asm { vbroadcastss xmm0, [rsp+88h+magnitude] }
  v11 = _mm128_mul_ps(_XMM0, hkDirection->m_quad);
  world = MutableWorld->world;
  v13 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  v14 = _mm128_sub_ps(hkPosition->m_quad, *(__m128 *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getMotion)(&world->hknpWorldReader, *(unsigned int *)(v13 + 64)));
  v15 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v11, v11, 201), v14), _mm128_mul_ps(_mm_shuffle_ps(v14, v14, 201), v11));
  v18 = _mm_shuffle_ps(v15, v15, 201);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __m128 *, _QWORD))world->applyBodyAngularImpulse)(&world->hknpWorldWriter, bodyId.m_serialAndIndex, &v18, 0i64);
}

/*
==============
HavokPhysics_ApplyAngularImpulse
==============
*/

void __fastcall HavokPhysics_ApplyAngularImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkTorqueVector, double magnitude)
{
  hknpWorldWriter *v7; 
  __int64 v8; 
  __m128 v10; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12884, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12885, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply angular impulse to a Body with invalid body id for world %i", "bodyId.isValid()", v8) )
      __debugbreak();
  }
  v7 = &HavokPhysics_GetMutableWorld(worldId)->world->hknpWorldWriter;
  v10 = _mm128_mul_ps(_mm_shuffle_ps(*(__m128 *)&magnitude, *(__m128 *)&magnitude, 0), hkTorqueVector->m_quad);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __m128 *, _QWORD))v7->applyBodyAngularImpulse)(v7, bodyId.m_serialAndIndex, &v10, 0i64);
}

/*
==============
HavokPhysics_ApplyImpulse
==============
*/
void HavokPhysics_ApplyImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkVector4f *hkDirection, float magnitude)
{
  hknpWorldWriter *v10; 
  __int64 v11; 
  __m128 v13; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12819, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12820, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply Fimpulseorce to a Body with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  __asm { vbroadcastss xmm0, [rsp+78h+magnitude] }
  v10 = &HavokPhysics_GetMutableWorld(worldId)->world->hknpWorldWriter;
  v13 = _mm128_mul_ps(_XMM0, hkDirection->m_quad);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __m128 *, const hkVector4f *, _DWORD))v10->applyBodyImpulseAt)(v10, bodyId.m_serialAndIndex, &v13, hkPosition, 0);
}

/*
==============
HavokPhysics_ApplyLinearImpulse
==============
*/

void __fastcall HavokPhysics_ApplyLinearImpulse(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkDirection, double magnitude)
{
  hknpWorldWriter *v7; 
  __int64 v8; 
  __m128 v10; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12839, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Apply impulse to a Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12840, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Apply Fimpulseorce to a Body with invalid body id for world %i", "bodyId.isValid()", v8) )
      __debugbreak();
  }
  v7 = &HavokPhysics_GetMutableWorld(worldId)->world->hknpWorldWriter;
  v10 = _mm128_mul_ps(_mm_shuffle_ps(*(__m128 *)&magnitude, *(__m128 *)&magnitude, 0), hkDirection->m_quad);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __m128 *, _QWORD))v7->applyBodyLinearImpulse)(v7, bodyId.m_serialAndIndex, &v10, 0i64);
}

/*
==============
HavokPhysics_AreDetailModelsInterchangeable
==============
*/
bool HavokPhysics_AreDetailModelsInterchangeable(const XModel *const detailModelA, const XModel *const detailModelB)
{
  if ( !detailModelA && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9944, ASSERT_TYPE_ASSERT, "(detailModelA)", (const char *)&queryFormat, "detailModelA") )
    __debugbreak();
  if ( !detailModelB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9945, ASSERT_TYPE_ASSERT, "(detailModelB)", (const char *)&queryFormat, "detailModelB") )
    __debugbreak();
  return detailModelA->detailCollision == detailModelB->detailCollision && detailModelB->radius == detailModelA->radius;
}

/*
==============
HavokPhysics_BatchRaycast
==============
*/
void HavokPhysics_BatchRaycast(Physics_WorldId worldId, unsigned int numRays, const hkVector4f *starts, const hkVector4f *ends, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult **results)
{
  HavokPhysics_CollisionQueryResult **v11; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  int v14; 
  int v15; 
  unsigned int v16; 
  const hkVector4f *v18; 
  signed __int64 v19; 
  hkMemoryAllocator *v20; 
  int m_size; 
  hkcdRay *v22; 
  hknpCollisionQueryCollector *Collector; 
  hkMemoryAllocator *v32; 
  int v33; 
  hkMonitorStream *Value; 
  const hknpWorldReader *v35; 
  const hknpWorldReader *v36; 
  hkMonitorStream *v37; 
  hkMemoryAllocator *v38; 
  hkMemoryAllocator *v39; 
  __int64 v40; 
  hkArrayBase<hknpCollisionQueryCollector *> collectorPtrsOut; 
  hkArrayBase<hkcdRay> array; 
  hknpCollisionQuery query; 
  __int64 v44; 
  float v45; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  Physics_CharacterProxy_Type characterProxyType; 
  __int128 v48; 
  Physics_QueryPhaseSelection phaseSelection; 
  signed __int64 v51; 
  HavokPhysics_CollisionQueryResult **resultsa; 

  v44 = -2i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14014, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !starts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14015, ASSERT_TYPE_ASSERT, "(starts)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid starts", "starts") )
    __debugbreak();
  if ( !ends && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14016, ASSERT_TYPE_ASSERT, "(ends)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid ends", "ends") )
    __debugbreak();
  v11 = results;
  if ( !results && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14017, ASSERT_TYPE_ASSERT, "(results)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid results", "results") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14018, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( numRays <= 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14019, ASSERT_TYPE_ASSERT, "(numRays > 1)", "%s\n\tHavok Physics: Trying to fire BatchRaycast with too few rays", "numRays > 1") )
    __debugbreak();
  if ( numRays > 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14020, ASSERT_TYPE_ASSERT, "(numRays <= PHYSICS_BATCHRAYCAST_MAX_RAYS)", "%s\n\tHavok Physics: Trying to fire BatchRaycast with too many rays", "numRays <= PHYSICS_BATCHRAYCAST_MAX_RAYS") )
    __debugbreak();
  resultsa = (HavokPhysics_CollisionQueryResult **)HavokPhysics_GetConstWorld(worldId);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v48 = _XMM0;
  ignoreBodies = extendedData->ignoreBodies;
  characterProxyType = extendedData->characterProxyType;
  v45 = extendedData->collisionBuffer * 0.03125;
  phaseSelection = extendedData->phaseSelection;
  query.m_broadPhaseFilterMask = -5;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = (const hknpCollisionFilter *)*resultsa;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v45;
  *(_DWORD *)query.m_levelOfDetail = 0;
  insideHitType = extendedData->insideHitType;
  if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
  {
    v14 = 4;
  }
  else
  {
    v14 = 0;
    if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
      v14 = 8;
  }
  v15 = v14 | 1;
  if ( !extendedData->disableBackFacingTriangleHits )
    v15 = v14;
  array.m_data = NULL;
  array.m_size = 0;
  array.m_capacityAndFlags = 0x80000000;
  collectorPtrsOut.m_data = NULL;
  collectorPtrsOut.m_size = 0;
  collectorPtrsOut.m_capacityAndFlags = 0x80000000;
  v16 = 0;
  if ( numRays )
  {
    _XMM6 = 0i64;
    v18 = starts;
    v19 = (char *)ends - (char *)starts;
    v51 = v19;
    do
    {
      v20 = hkMemHeapAllocator();
      m_size = array.m_size;
      if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v20, &array, 48);
        m_size = array.m_size;
      }
      v22 = &array.m_data[m_size];
      array.m_size = m_size + 1;
      _XMM1 = _mm128_sub_ps(*(__m128 *)((char *)&starts->m_quad + v19), starts->m_quad);
      __asm
      {
        vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
        vcmpeqps xmm0, xmm6, xmm2
        vandnps xmm4, xmm0, xmm2
        vcmpeqps xmm0, xmm6, xmm4
        vrcpps  xmm3, xmm4
      }
      _XMM3 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM3, _XMM4)), _XMM3);
      __asm { vblendvps xmm1, xmm3, xmm7, xmm0 }
      v22->m_direction.m_quad = _XMM4;
      v22->m_invDirection = (hkVector4f)_XMM1.m_quad;
      v22->m_origin = (hkVector4f)starts->m_quad;
      if ( !(*v11)->m_collector )
      {
        LODWORD(v40) = v16;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14064, ASSERT_TYPE_ASSERT, "(results[rayIdx]->m_collector)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid collector %i", "results[rayIdx]->m_collector", v40) )
          __debugbreak();
      }
      HavokPhysicsHitCollector::SetBatchRaycastDataForModifiers((*v11)->m_collector, v18, (const hkVector4f *)((char *)v18 + v19), &query, (hkFlags<enum hkcdRayQueryFlags::Enum,unsigned int>)v15);
      HavokPhysicsHitCollector::EnableInsideHits((*v11)->m_collector, extendedData->collectInsideHits);
      Collector = HavokPhysicsHitCollector::GetCollector((*v11)->m_collector);
      if ( !Collector )
      {
        LODWORD(v40) = v16;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14070, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire batch raycast with invalid havok collector %i", "collector", v40) )
          __debugbreak();
      }
      v32 = hkMemHeapAllocator();
      v33 = collectorPtrsOut.m_size;
      if ( collectorPtrsOut.m_size == (collectorPtrsOut.m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v32, &collectorPtrsOut, 8);
        v33 = collectorPtrsOut.m_size;
      }
      collectorPtrsOut.m_data[v33] = Collector;
      ++collectorPtrsOut.m_size;
      ++v16;
      ++v18;
      ++starts;
      ++v11;
      v19 = v51;
    }
    while ( v16 < numRays );
  }
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtBatchRaycast_HK");
  v35 = (const hknpWorldReader *)resultsa[3];
  v36 = v35 + 4;
  if ( !v35 )
    v36 = NULL;
  hknpBatchQueryUtil::castBatch(v36, &array, &query, (hkFlags<enum hkcdRayQueryFlags::Enum,unsigned int>)v15, &collectorPtrsOut);
  v37 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v37 )
    hkMonitorStream::timerEnd(v37, "Et");
  v38 = hkMemHeapAllocator();
  collectorPtrsOut.m_size = 0;
  if ( collectorPtrsOut.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v38, collectorPtrsOut.m_data, 8, collectorPtrsOut.m_capacityAndFlags & 0x3FFFFFFF);
  collectorPtrsOut.m_data = NULL;
  collectorPtrsOut.m_capacityAndFlags = 0x80000000;
  v39 = hkMemHeapAllocator();
  array.m_size = 0;
  if ( array.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v39, array.m_data, 48, array.m_capacityAndFlags & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_BroadphaseBodiesChanged
==============
*/
void HavokPhysics_BroadphaseBodiesChanged(int worldId)
{
  void (__fastcall *v1)(Physics_WorldId); 

  v1 = s_havokPhysicsBroadphaseBodiesChangedFns[worldId];
  if ( v1 )
    v1((Physics_WorldId)worldId);
}

/*
==============
HavokPhysics_CalcRigidBodyShapeAABBWorld
==============
*/
void HavokPhysics_CalcRigidBodyShapeAABBWorld(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11711, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying toGet the AABB Shape with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11712, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get the AABB Shape with invalid body id for world %i", "bodyId.isValid()", v9) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11717, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v9) )
      __debugbreak();
  }
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v8 = *(_QWORD *)(*(_QWORD *)(v7 + 152) + 8i64 * (*(_BYTE *)(v7 + 147) & 7));
  (*(void (__fastcall **)(__int64, __int64, hkAabb *))(*(_QWORD *)v8 + 32i64))(v8, v7, aabb);
}

/*
==============
HavokPhysics_CalcShapeRadius
==============
*/
void HavokPhysics_CalcShapeRadius(const hknpShape *shape, float *radiusOut)
{
  hknpShape_vtbl *v4; 
  __int128 v5; 
  __int128 v6; 

  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14245, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to calculate shape radius with an invalid shape", "shape") )
    __debugbreak();
  v4 = shape->__vftable;
  v5 = 0i64;
  v4->calcBoundingRadius((hknpShape *)shape, (const hkVector4f *)&v5, (hkSimdFloat32 *)&v6);
  *radiusOut = *(float *)&v6;
}

/*
==============
HavokPhysics_CalculateMassProperties
==============
*/
void HavokPhysics_CalculateMassProperties(hknpShape *shape, float mass, hkMassProperties *massProperties)
{
  hkReferencedObject v4; 
  int v5; 
  float v6; 
  float v7; 
  __int64 v8; 
  hkDiagonalizedMassProperties v9; 

  v8 = -2i64;
  v4.m_propertyBag.m_bag = NULL;
  *(_DWORD *)&v4.m_memSizeAndFlags = 0x1FFFF;
  v4.__vftable = (hkReferencedObject_vtbl *)hknpShape::MassConfig::`vftable';
  v7 = mass;
  v6 = FLOAT_1_0;
  v5 = 1;
  shape->buildMassProperties(shape, (const hknpShape::MassConfig *)&v4, &v9);
  hkDiagonalizedMassProperties::unpack(&v9, massProperties);
  hkReferencedObject::~hkReferencedObject(&v4);
}

/*
==============
HavokPhysics_CheckWorldReplayDeterminism
==============
*/
void HavokPhysics_CheckWorldReplayDeterminism(Physics_WorldId worldId)
{
  ;
}

/*
==============
HavokPhysics_ClearAntilagFlags
==============
*/
void HavokPhysics_ClearAntilagFlags(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpBroadPhase *UndecoratedBroadPhase; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to ClearAntilagFlags with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(MutableWorld->world);
  hknpBroadPhase::clearAntilagBodies(UndecoratedBroadPhase);
}

/*
==============
HavokPhysics_ClearShapeCache
==============
*/
void HavokPhysics_ClearShapeCache(void)
{
  int v0; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **v1; 
  __int64 v2; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *v3; 
  int v4; 
  __int64 v5; 
  __int64 m_hashMod; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  hkReferencedObject *val; 
  unsigned __int16 m_refCount; 
  __int64 v10; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v11; 
  int v12; 
  int v13; 
  __int64 v14; 
  signed __int32 v15[8]; 

  v0 = 27;
  v1 = &s_havokPhysicsShapeCaches[27];
  v2 = 27i64;
  do
  {
    if ( !*v1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15837, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCaches[threadId])", "%s\n\tHavokPhysics_ClearShapeCache: the cache should be valid", "s_havokPhysicsShapeCaches[threadId]") )
      __debugbreak();
    v3 = *v1;
    v4 = 0;
    v5 = 0i64;
    m_hashMod = (*v1)->m_map.m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = v3->m_map.m_elem;
      do
      {
        if ( m_elem->key != -1i64 )
          break;
        ++v4;
        ++v5;
        ++m_elem;
      }
      while ( v5 <= m_hashMod );
    }
    if ( v4 <= (int)m_hashMod )
    {
      do
      {
        val = (hkReferencedObject *)v3->m_map.m_elem[v4].val;
        if ( !val || (_InterlockedOr(v15, 0), m_refCount = val->m_refCount, _InterlockedOr(v15, 0), m_refCount != 1) )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15843, ASSERT_TYPE_ASSERT, "(shape && shape->getReferenceCount() == 1)", "%s\n\tHavokPhysics_ClearShapeCache: havok physics shape cache entries should have a single reference only", "shape && shape->getReferenceCount() == 1") )
            __debugbreak();
        }
        hkReferencedObject::removeReference(val);
        v3 = *v1;
        ++v4;
        v10 = (*v1)->m_map.m_hashMod;
        if ( v4 > (int)v10 )
          break;
        v5 = v4;
        v11 = &v3->m_map.m_elem[v4];
        do
        {
          if ( v11->key != -1i64 )
            break;
          ++v4;
          ++v5;
          ++v11;
        }
        while ( v5 <= v10 );
      }
      while ( v4 <= (int)v10 );
    }
    v12 = v3->m_map.m_hashMod;
    if ( v12 )
    {
      v13 = v12 + 1;
      v14 = v13;
      if ( v13 > 0 )
      {
        v5 = 0i64;
        do
        {
          if ( *(unsigned __int64 *)((char *)&v3->m_map.m_elem->key + v5) != -1i64 )
            *(unsigned __int64 *)((char *)&v3->m_map.m_elem->key + v5) = -1i64;
          v5 += 16i64;
          --v14;
        }
        while ( v14 );
      }
    }
    v3->m_map.m_numElems &= 0x80000000;
    if ( v1 >= (hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **)s_havokPhysicsShapeCachesDisabled )
    {
      j___report_rangecheckfailure(v5);
      JUMPOUT(0x141B1AA2Ei64);
    }
    s_havokPhysicsShapeCachesDisabled[v2--] = 0;
    --v1;
    --v0;
  }
  while ( v0 >= 0 );
}

/*
==============
HavokPhysics_CopyPhysicsAsset
==============
*/
void HavokPhysics_CopyPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v4; 
  int m_hashMod; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  int v9; 
  PhysicsAsset *key; 
  int v11; 
  unsigned __int32 v12; 
  unsigned __int32 v13; 
  unsigned int v14; 
  int v15; 
  PhysicsAsset *v16; 
  unsigned __int64 val; 
  int v18; 
  int v19; 
  int v20; 
  unsigned __int32 v21; 
  unsigned __int32 v22; 
  int v23; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v25; 
  PhysicsAsset *v26; 
  __int64 v27; 
  hkMemoryAllocator alloc; 

  HavokPhysics_LockAssetWrite();
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7565, ASSERT_TYPE_ASSERT, "(from)", "%s\n\tTrying to clone a NULL Physics Asset", "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7566, ASSERT_TYPE_ASSERT, "(to)", "%s\n\tTrying to clone a NULL Physics Asset", "to") )
    __debugbreak();
  v4 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7567, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Clone a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  m_hashMod = v4->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v6 = _byteswap_ulong(-1640531535 * (_DWORD)from), v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = m_hashMod & (v7 ^ ((v6 >> 2) + v6 + (v7 << 6) - 1640531527)), v9 = v8, key = (PhysicsAsset *)v4->m_map.m_elem[v8].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_15:
    v9 = m_hashMod + 1;
  }
  else
  {
    while ( key != from )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = v8;
      key = (PhysicsAsset *)v4->m_map.m_elem[v8].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_15;
    }
  }
  if ( v9 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7570, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( it ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( it )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  v11 = v4->m_map.m_hashMod;
  if ( v11 <= 0 || (v12 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v13 = _byteswap_ulong(-1640531535 * (_DWORD)to), v14 = v11 & (v12 ^ ((v13 >> 2) + v13 + (v12 << 6) - 1640531527)), v15 = v14, v16 = (PhysicsAsset *)v4->m_map.m_elem[v14].key, v16 == (PhysicsAsset *)-1i64) )
  {
LABEL_24:
    v15 = v11 + 1;
  }
  else
  {
    while ( v16 != to )
    {
      v14 = v11 & (v14 + 1);
      v15 = v14;
      v16 = (PhysicsAsset *)v4->m_map.m_elem[v14].key;
      if ( v16 == (PhysicsAsset *)-1i64 )
        goto LABEL_24;
    }
  }
  if ( v15 <= v11 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7571, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsAssets->hasKey( to ))", (const char *)&queryFormat, "!s_havokPhysicsAssets->hasKey( to )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  val = v4->m_map.m_elem[v9].val;
  v18 = (unsigned int)hkMemHeapAllocator();
  v19 = v4->m_map.m_hashMod;
  if ( 2 * v4->m_map.m_numElems > v19 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v4->m_map, &alloc, v18);
    v19 = v4->m_map.m_hashMod;
  }
  v20 = 1;
  v21 = _byteswap_ulong(-1640531535 * (_DWORD)to);
  v22 = _byteswap_ulong(-1640531535 * HIDWORD(to));
  v23 = v22 ^ ((v21 >> 2) + v21 + (v22 << 6) - 1640531527);
  m_elem = v4->m_map.m_elem;
  v25 = v19 & v23;
  v26 = (PhysicsAsset *)v4->m_map.m_elem[v25].key;
  if ( v26 != (PhysicsAsset *)-1i64 )
  {
    while ( v26 != to )
    {
      v25 = v4->m_map.m_hashMod & (v25 + 1);
      v26 = (PhysicsAsset *)m_elem[v25].key;
      if ( v26 == (PhysicsAsset *)-1i64 )
        goto LABEL_36;
    }
    v20 = 0;
  }
LABEL_36:
  v4->m_map.m_numElems += v20;
  v27 = (int)v25;
  m_elem[v27].key = (unsigned __int64)to;
  v4->m_map.m_elem[v27].val = val;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_CopyPhysicsSFXEventAsset
==============
*/
void HavokPhysics_CopyPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7140, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7141, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7142, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", (const char *)&queryFormat, "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7146, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to )") )
    __debugbreak();
  HavokPhysics_AddPhysicsSFXAssetInternal(to);
}

/*
==============
HavokPhysics_CopyPhysicsVFXEventAsset
==============
*/
void HavokPhysics_CopyPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7304, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7305, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7306, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", (const char *)&queryFormat, "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7310, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to )") )
    __debugbreak();
  HavokPhysics_AddPhysicsVFXAssetInternal(to);
}

/*
==============
HavokPhysics_CopyXModelAsset
==============
*/
void HavokPhysics_CopyXModelAsset(XModel *from, XModel *to)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v4; 
  hkMemoryAllocator *v5; 
  int m_size; 

  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7985, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  if ( HavokPhysics_DebugXModelGetIndex(from) < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7986, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( from ) >= 0)", "%s\n\txmodel doesn't exist in debug list", "HavokPhysics_DebugXModelGetIndex( from ) >= 0") )
    __debugbreak();
  if ( HavokPhysics_DebugXModelGetIndex(to) > 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7987, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( to ) <= 0)", "%s\n\tdest xmodel already exists", "HavokPhysics_DebugXModelGetIndex( to ) <= 0") )
    __debugbreak();
  v4 = s_havokPhysicsXModels;
  v5 = hkMemHeapAllocator();
  m_size = v4->m_size;
  if ( m_size == (v4->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v5, v4, 8);
    m_size = v4->m_size;
  }
  v4->m_data[m_size] = to;
  ++v4->m_size;
}

/*
==============
HavokPhysics_CopyXModelDetailCollisionAsset
==============
*/
void HavokPhysics_CopyXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  unsigned __int64 val; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v5; 
  int m_hashMod; 
  unsigned __int32 v7; 
  unsigned __int32 v8; 
  int v9; 
  int v10; 
  XModelDetailCollision *key; 
  unsigned __int32 v12; 
  unsigned __int32 v13; 
  int v14; 
  int v15; 
  XModelDetailCollision *v16; 
  int v17; 
  int v18; 
  int v19; 
  unsigned __int32 v20; 
  unsigned __int32 v21; 
  int v22; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v24; 
  XModelDetailCollision *v25; 
  __int64 v26; 
  hkMemoryAllocator alloc; 

  val = 0i64;
  HavokPhysics_LockAssetWrite();
  v5 = s_havokPhysicsXModelLODs;
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = _byteswap_ulong(-1640531535 * (_DWORD)from), v9 = m_hashMod & (v7 ^ ((v8 >> 2) + v8 + (v7 << 6) - 1640531527)), v10 = v9, key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_5:
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != from )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_5;
    }
  }
  if ( v10 <= m_hashMod )
    val = s_havokPhysicsXModelLODs->m_map.m_elem[v10].val;
  if ( m_hashMod <= 0 || (v12 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v13 = _byteswap_ulong(-1640531535 * (_DWORD)to), v14 = m_hashMod & (v12 ^ ((v13 >> 2) + v13 + (v12 << 6) - 1640531527)), v15 = v14, v16 = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v14].key, v16 == (XModelDetailCollision *)-1i64) )
  {
LABEL_12:
    v15 = m_hashMod + 1;
  }
  else
  {
    while ( v16 != to )
    {
      v14 = m_hashMod & (v14 + 1);
      v15 = v14;
      v16 = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v14].key;
      if ( v16 == (XModelDetailCollision *)-1i64 )
        goto LABEL_12;
    }
  }
  if ( v15 <= m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8012, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsXModelLODs->hasKey( to ))", (const char *)&queryFormat, "!s_havokPhysicsXModelLODs->hasKey( to )") )
      __debugbreak();
    v5 = s_havokPhysicsXModelLODs;
  }
  if ( val )
  {
    v17 = (unsigned int)hkMemHeapAllocator();
    v18 = v5->m_map.m_hashMod;
    if ( 2 * v5->m_map.m_numElems > v18 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v5->m_map, &alloc, v17);
      v18 = v5->m_map.m_hashMod;
    }
    v19 = 1;
    v20 = _byteswap_ulong(-1640531535 * (_DWORD)to);
    v21 = _byteswap_ulong(-1640531535 * HIDWORD(to));
    v22 = v21 ^ ((v20 >> 2) + v20 + (v21 << 6) - 1640531527);
    m_elem = v5->m_map.m_elem;
    v24 = v18 & v22;
    v25 = (XModelDetailCollision *)v5->m_map.m_elem[v24].key;
    if ( v25 != (XModelDetailCollision *)-1i64 )
    {
      while ( v25 != to )
      {
        v24 = v5->m_map.m_hashMod & (v24 + 1);
        v25 = (XModelDetailCollision *)m_elem[v24].key;
        if ( v25 == (XModelDetailCollision *)-1i64 )
          goto LABEL_25;
      }
      v19 = 0;
    }
LABEL_25:
    v5->m_map.m_numElems += v19;
    v26 = (int)v24;
    m_elem[v26].key = (unsigned __int64)to;
    v5->m_map.m_elem[v26].val = val;
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_CreateConstraint
==============
*/
hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> *HavokPhysics_CreateConstraint(hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> *result, HavokPhysicsWorld *world, hknpConstraintCinfo *constraintCinfo, const hkVector4f *position, const hkQuaternionf *orientation)
{
  hkpConstraintData *m_ptr; 
  hkpConstraintData *v10; 
  hkpConstraintData *v11; 
  __int64 m_value; 
  char v14[16]; 
  hkTransformf v15; 
  hkTransformf pivot; 
  hkTransformf v17; 

  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8988, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8989, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( !constraintCinfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8990, ASSERT_TYPE_ASSERT, "(constraintCinfo)", (const char *)&queryFormat, "constraintCinfo") )
    __debugbreak();
  if ( (constraintCinfo->m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    m_ptr = constraintCinfo->m_constraintData.m_ptr;
    v10 = hkpConstraintDataUtils::deepClone(constraintCinfo->m_constraintData.m_ptr);
    v11 = v10;
    if ( v10 )
      hkReferencedObject::addReference(v10);
    if ( constraintCinfo->m_constraintData.m_ptr )
      hkReferencedObject::removeReference(constraintCinfo->m_constraintData.m_ptr);
    constraintCinfo->m_constraintData.m_ptr = v11;
    hkReferencedObject::removeReference(v11);
    hkRotationImpl<float>::set(&v15.m_rotation, orientation);
    v15.m_translation = (hkVector4f)position->m_quad;
    hkpConstraintDataUtils::getPivotTransform(m_ptr, 1, &pivot);
    hkTransformf::setMul(&v17, &v15, &pivot);
    hkpConstraintDataUtils::setPivotTransform(constraintCinfo->m_constraintData.m_ptr, &v17, 1);
  }
  m_value = world->world->allocateConstraint(&world->world->hknpWorldWriter, v14, constraintCinfo)->m_value;
  result->m_value = m_value;
  ((void (__fastcall *)(hknpWorldWriter *, __int64, __int64))world->world->addConstraint)(&world->world->hknpWorldWriter, m_value, 1i64);
  return result;
}

/*
==============
HavokPhysics_CreateInstance
==============
*/
unsigned int HavokPhysics_CreateInstance(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int result; 
  unsigned int v4; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9061, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Create Instance world %i is NULL", "havokPhysicsWorld->world", worldId) )
    __debugbreak();
  result = HavokPhysicsInstanceManager_AllocateInstance(&MutableWorld->instanceManager);
  v4 = result;
  if ( result == -1 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9065, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics Create Instance: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    return v4;
  }
  return result;
}

/*
==============
HavokPhysics_CreateRigidBody
==============
*/
hknpBodyId *HavokPhysics_CreateRigidBody(hknpBodyId *result, Physics_WorldId worldId, HavokPhysicsWorld *world, const PhysicsAsset *physicsAsset, int assetId, hknpPhysicsSystemData::bodyCinfoWithAttachment *bodyCinfo, int ref, hkVector4f *position, hkQuaternionf *orientation, bool immediateAdd, bool tryStartDeactivated, bool wrapMutables)
{
  bool v17; 
  int v18; 
  PhysicsSFXEventAsset *v19; 
  PhysicsVFXEventAsset *v20; 
  char *v21; 
  char v22; 
  char v23; 
  const hknpShape *m_ptr; 
  hkMemoryRouter *Value; 
  hknpMaskedShape *v26; 
  hknpShape *v27; 
  hknpShape *v28; 
  __int64 v29; 
  Physics_RefSystem RefSystem; 
  __int64 v31; 
  hkQuaternionf v34; 
  __m128 v37; 
  __int64 v43; 
  PhysicsSFXEventAsset *v44; 
  __int64 v45; 
  const char *name; 
  __int64 v47; 
  unsigned int i; 
  int v49; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v50; 
  int m_hashMod; 
  unsigned __int32 v52; 
  int v53; 
  unsigned int key; 
  PhysicsSFXEventAsset *val; 
  PhysicsVFXEventAsset *v56; 
  const char *v57; 
  unsigned int j; 
  int v59; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v60; 
  int v61; 
  unsigned __int32 v62; 
  int v63; 
  unsigned int v64; 
  PhysicsVFXEventAsset *v65; 
  unsigned int m_serialAndIndex; 
  const HavokPhysicsWorld *ConstWorld; 
  hknpActionManager *ActionManager; 
  __int64 v70; 
  __int64 v71; 
  char v72; 
  char action[40]; 
  hkQuaternionf qi; 
  hkRotationImpl<float> v75; 
  __int128 v76; 

  *(_QWORD *)&action[16] = -2i64;
  _RBX = bodyCinfo;
  *(_QWORD *)&action[8] = orientation;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8689, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8690, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( !bodyCinfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8691, ASSERT_TYPE_ASSERT, "(bodyCinfo)", (const char *)&queryFormat, "bodyCinfo") )
    __debugbreak();
  if ( !bodyCinfo->m_shape.m_ptr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8692, ASSERT_TYPE_ASSERT, "(bodyCinfo->m_shape)", (const char *)&queryFormat, "bodyCinfo->m_shape") )
    __debugbreak();
  if ( Physics_IsQueryWorld(worldId) && bodyCinfo->m_motionType.m_storage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8693, ASSERT_TYPE_ASSERT, "(!Physics_IsQueryWorld( worldId ) || bodyCinfo->m_motionType == hknpMotionType::STATIC)", (const char *)&queryFormat, "!Physics_IsQueryWorld( worldId ) || bodyCinfo->m_motionType == hknpMotionType::STATIC") )
    __debugbreak();
  if ( !physicsAsset || physicsAsset->useCategory != PhysicsAssetUseCategory_Vehicle || (v72 = 1, (unsigned int)(*physicsAsset->simulationCategories - 7) > 1) )
    v72 = 0;
  v17 = 0;
  v18 = assetId;
  if ( Physics_IsAuthoritativeWorld(worldId) )
  {
    if ( !physicsAsset )
      goto LABEL_34;
    v19 = physicsAsset->sfxEventAssets[assetId];
    if ( v19 )
      v17 = v19->rules.numrules > 0;
    v20 = physicsAsset->vfxEventAssets[assetId];
    if ( v20 && v20->rules.numrules > 0 )
    {
LABEL_33:
      bodyCinfo->m_flags.m_storage |= 0x80u;
      goto LABEL_34;
    }
LABEL_32:
    if ( !v17 )
      goto LABEL_34;
    goto LABEL_33;
  }
  if ( worldId == PHYSICS_WORLD_ID_FIRST || Physics_IsPredictiveWorld(worldId) )
  {
    v17 = bodyCinfo->m_qualityId.m_value == s_vehicleBodyQualityIdx + 16;
    if ( v72 )
      bodyCinfo->m_flags.m_storage |= 0x400000u;
    goto LABEL_32;
  }
LABEL_34:
  bodyCinfo->m_motionId.m_value = 0x7FFFFFFF;
  v21 = (char *)((unsigned __int64)bodyCinfo->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
  v22 = *v21;
  if ( *v21 )
  {
    do
    {
      if ( *v21 != (unsigned __int8)tolower(v22) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8771, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Rigid body name %s should be lower case\n", (const char *)((unsigned __int64)bodyCinfo->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64)) )
        __debugbreak();
      v22 = *++v21;
    }
    while ( *v21 );
    v18 = assetId;
  }
  v23 = 0;
  if ( wrapMutables && bodyCinfo->m_shape.m_ptr->getMutationSignals(bodyCinfo->m_shape.m_ptr) )
  {
    m_ptr = bodyCinfo->m_shape.m_ptr;
    if ( bodyCinfo->m_shape.m_ptr->m_type.m_storage != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8783, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::COMPOUND") )
      __debugbreak();
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v26 = (hknpMaskedShape *)Value->m_heap->blockAlloc(Value->m_heap, 104i64);
    *(_QWORD *)action = v26;
    if ( v26 )
    {
      hknpMaskedShape::hknpMaskedShape(v26, m_ptr);
      v28 = v27;
    }
    else
    {
      v28 = NULL;
    }
    if ( v28 )
    {
      hkReferencedObject::addReference(v28);
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8788, ASSERT_TYPE_ASSERT, "(maskedShape)", (const char *)&queryFormat, "maskedShape") )
    {
      __debugbreak();
    }
    if ( bodyCinfo->m_shape.m_ptr )
      hkReferencedObject::removeReference(&bodyCinfo->m_shape.m_ptr->hkReferencedObject);
    bodyCinfo->m_shape.m_ptr = v28;
    v23 = 1;
  }
  Sys_EnterCriticalSection(CRITSECT_PHYS_BODY_CREATE);
  result->m_serialAndIndex = world->world->allocateBody(&world->world->hknpWorldWriter, action, bodyCinfo)->m_serialAndIndex;
  Sys_LeaveCriticalSection(CRITSECT_PHYS_BODY_CREATE);
  if ( !*(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->world->getBody)(&world->world->hknpWorldReader, result->m_serialAndIndex) + 96) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8807, ASSERT_TYPE_ASSERT, "(world->world->getBody( bodyId ).getShape())", (const char *)&queryFormat, "world->world->getBody( bodyId ).getShape()") )
    __debugbreak();
  if ( v23 )
  {
    hkReferencedObject::removeReference(&bodyCinfo->m_shape.m_ptr->hkReferencedObject);
    if ( bodyCinfo->m_shape.m_ptr )
      hkReferencedObject::removeReference(&bodyCinfo->m_shape.m_ptr->hkReferencedObject);
    bodyCinfo->m_shape.m_ptr = NULL;
  }
  v29 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->world->getBody)(&world->world->hknpWorldReader, result->m_serialAndIndex);
  *(_QWORD *)(v29 + 160) |= (unsigned int)ref;
  if ( immediateAdd )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, bool))world->world->addBody)(&world->world->hknpWorldWriter, result->m_serialAndIndex, 0i64, tryStartDeactivated);
  RefSystem = Physics_GetRefSystem(ref);
  v31 = RefSystem;
  if ( (unsigned int)RefSystem >= Physics_RefSystem_Count )
  {
    LODWORD(v70) = RefSystem;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8828, ASSERT_TYPE_ASSERT, "(unsigned)( refSystem ) < (unsigned)( Physics_RefSystem_Count )", "refSystem doesn't index Physics_RefSystem_Count\n\t%i not in [0, %i)", v70, 13) )
      __debugbreak();
  }
  ++world->refSystemCounts[v31];
  _RDI = *(__m128 **)&action[8];
  hkVector4f::setRotatedDir((hkVector4f *)&action[24], *(const hkQuaternionf **)&action[8], &bodyCinfo->m_position);
  *(__m128 *)&action[24] = _mm128_add_ps(*(__m128 *)&action[24], position->m_quad);
  _XMM8 = *_RDI;
  v34.m_vec.m_quad = (__m128)bodyCinfo->m_orientation;
  __asm
  {
    vbroadcastss xmm6, dword ptr [rdi+0Ch]
    vbroadcastss xmm5, dword ptr [rbx+4Ch]
  }
  v37 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v34.m_vec.m_quad, v34.m_vec.m_quad, 201), *_RDI), _mm128_mul_ps(_mm_shuffle_ps(_XMM8, _XMM8, 201), v34.m_vec.m_quad));
  __asm { vdpps   xmm0, xmm8, xmm7, 7Fh }
  _mm128_sub_ps(_mm128_mul_ps(_XMM5, _XMM6), _XMM0);
  _XMM2 = _mm128_add_ps(_mm128_add_ps(_mm_shuffle_ps(v37, v37, 201), _mm128_mul_ps(v34.m_vec.m_quad, _XMM6)), _mm128_mul_ps(*_RDI, _XMM5));
  __asm
  {
    vblendps xmm5, xmm2, xmm3, 8
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
  }
  qi.m_vec.m_quad = _mm128_mul_ps(_mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM4, _XMM0), _XMM4)), _mm128_mul_ps(_XMM4, *(__m128 *)hkMath::hkSse_floatHalf)), _XMM5);
  hkRotationImpl<float>::set(&v75, &qi);
  v76 = *(_OWORD *)&action[24];
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, hkRotationImpl<float> *, bool))world->world->setBodyTransform)(&world->world->hknpWorldWriter, result->m_serialAndIndex, &v75, tryStartDeactivated);
  world->bodySFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = NULL;
  world->bodyVFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = NULL;
  if ( physicsAsset )
  {
    v43 = v18;
    v44 = physicsAsset->sfxEventAssets[v43];
    v45 = -1i64;
    if ( v44 )
    {
      name = v44->name;
      v47 = -1i64;
      do
        ++v47;
      while ( name[v47] );
      for ( i = -1; v47; --v47 )
        i = (i >> 8) ^ g_crc32Table[*(unsigned __int8 *)name++ ^ (unsigned __int64)(unsigned __int8)i];
      v49 = ~i;
      Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
      AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      v50 = g_physicsSFXEventAssets;
      m_hashMod = g_physicsSFXEventAssets->m_hashMod;
      if ( m_hashMod <= 0 || (v52 = m_hashMod & _byteswap_ulong(-1640531535 * v49), v53 = v52, key = g_physicsSFXEventAssets->m_elem[v52].key, key == -1) )
      {
LABEL_79:
        v53 = m_hashMod + 1;
      }
      else
      {
        while ( key != v49 )
        {
          v52 = m_hashMod & (v52 + 1);
          v53 = v52;
          key = g_physicsSFXEventAssets->m_elem[v52].key;
          if ( key == -1 )
            goto LABEL_79;
        }
      }
      if ( v53 > m_hashMod )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8876, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets->isValid( eventIt ))", (const char *)&queryFormat, "g_physicsSFXEventAssets->isValid( eventIt )") )
          __debugbreak();
        v50 = g_physicsSFXEventAssets;
      }
      val = v50->m_elem[v53].val;
      ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
      world->bodySFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = val;
    }
    v56 = physicsAsset->vfxEventAssets[v43];
    if ( v56 )
    {
      v57 = v56->name;
      do
        ++v45;
      while ( v57[v45] );
      for ( j = -1; v45; --v45 )
        j = (j >> 8) ^ g_crc32Table[*(unsigned __int8 *)v57++ ^ (unsigned __int64)(unsigned __int8)j];
      v59 = ~j;
      Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
      AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      v60 = g_physicsVFXEventAssets;
      v61 = g_physicsVFXEventAssets->m_hashMod;
      if ( v61 <= 0 || (v62 = v61 & _byteswap_ulong(-1640531535 * v59), v63 = v62, v64 = g_physicsVFXEventAssets->m_elem[v62].key, v64 == -1) )
      {
LABEL_94:
        v63 = v61 + 1;
      }
      else
      {
        while ( v64 != v59 )
        {
          v62 = v61 & (v62 + 1);
          v63 = v62;
          v64 = g_physicsVFXEventAssets->m_elem[v62].key;
          if ( v64 == -1 )
            goto LABEL_94;
        }
      }
      if ( v63 > v61 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8887, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets->isValid( eventIt ))", (const char *)&queryFormat, "g_physicsVFXEventAssets->isValid( eventIt )") )
          __debugbreak();
        v60 = g_physicsVFXEventAssets;
      }
      v65 = v60->m_elem[v63].val;
      ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
      Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
      world->bodyVFXEventAssets->m_data[result->m_serialAndIndex & 0xFFFFFF] = v65;
    }
  }
  if ( !Physics_IsQueryWorld(worldId) )
  {
    m_serialAndIndex = result->m_serialAndIndex;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v71) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11402, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v71) )
        __debugbreak();
    }
    if ( (m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(v71) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11403, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid body id for world %i", "bodyId.isValid()", v71) )
        __debugbreak();
    }
    ConstWorld = HavokPhysics_GetConstWorld(worldId);
    if ( !ConstWorld->world )
    {
      LODWORD(v71) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11408, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v71) )
        __debugbreak();
    }
    if ( (ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[m_serialAndIndex & 0xFFFFFF].m_pod.m_flags.m_storage & 6) == 2 && !Physics_IsPredictiveWorld(worldId) && !v72 )
    {
      PhysicsForceAction_Create(worldId, result->m_serialAndIndex);
      ActionManager = hknpWorld::getActionManager(world->world);
      hknpActionManager::addAction(ActionManager, (hknpAction *)action);
    }
  }
  return result;
}

/*
==============
HavokPhysics_CreateShapeCapsuleCenterHeight
==============
*/

hknpShape *__fastcall HavokPhysics_CreateShapeCapsuleCenterHeight(Physics_WorldId worldId, const hkVector4f *center, double halfHeight, float radius, hkVector4f *majorAxis, char *optionalInplaceBuffer, int optionalInplaceBufferSize, Physics_ShapeStorage shapeStorage)
{
  __m128 v10; 
  __m128 v20; 
  float v22; 
  hkVector4f a; 
  hkVector4f b; 

  v10 = *(__m128 *)&halfHeight;
  _XMM2 = majorAxis->m_quad;
  v22 = FLOAT_0_000099999997;
  __asm
  {
    vpand   xmm0, xmm2, cs:?g_mantissaMaskf@@3QBIB; uint const near * const g_mantissaMaskf
    vpcmpeqd xmm1, xmm0, cs:?g_mantissaMaskf@@3QBIB; uint const near * const g_mantissaMaskf
    vpmovmskb eax, xmm1
  }
  if ( (_EAX & 0x111) != 0 )
    goto LABEL_8;
  _XMM0 = *(_OWORD *)hkMath::hkSse_signMask;
  __asm
  {
    vbroadcastss xmm1, [rsp+0B8h+var_78]
    vdpps   xmm3, xmm2, xmm2, 7Fh
  }
  a.m_quad = g_vectorfConstants[6];
  _mm128_sub_ps(_XMM3, g_vectorfConstants[6]);
  __asm { vandnps xmm3, xmm0, xmm2 }
  if ( *(float *)&_XMM1 <= *(float *)&_XMM3 )
  {
LABEL_8:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15570, ASSERT_TYPE_ASSERT, "(majorAxis.isNormalized<3>())", (const char *)&queryFormat, "majorAxis.isNormalized<3>()") )
      __debugbreak();
  }
  v20 = _mm128_mul_ps(_mm_shuffle_ps(v10, v10, 0), majorAxis->m_quad);
  a.m_quad = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps((__m128)(*(_OWORD *)&v10 ^ _xmm), (__m128)(*(_OWORD *)&v10 ^ _xmm), 0), majorAxis->m_quad), center->m_quad);
  b.m_quad = _mm128_add_ps(v20, center->m_quad);
  return HavokPhysics_CreateShapeCapsulePoints(worldId, &a, &b, radius, optionalInplaceBuffer, optionalInplaceBufferSize, shapeStorage);
}

/*
==============
HavokPhysics_CreateShapeCapsulePoints
==============
*/
hknpShape *HavokPhysics_CreateShapeCapsulePoints(Physics_WorldId worldId, const hkVector4f *a, const hkVector4f *b, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize, hkMemoryAllocator shapeStorage)
{
  int v10; 
  unsigned __int64 v11; 
  unsigned __int64 v12; 
  hknpCapsuleShape *ConvexShape; 
  unsigned __int64 v14; 
  HavokPhysicsWorld *MutableWorld; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> > *p_m_map; 
  int v17; 
  int m_hashMod; 
  int v19; 
  unsigned __int32 v20; 
  unsigned __int32 v21; 
  unsigned int v22; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 key; 
  __int64 v25; 

  v10 = (int)shapeStorage.__vftable;
  if ( optionalInplaceBuffer )
  {
    hknpCapsuleShape::hknpCapsuleShape((hknpCapsuleShape *)optionalInplaceBuffer, a, b, radius);
    v12 = v11;
    *(_WORD *)(v11 + 16) = 0;
  }
  else
  {
    if ( LODWORD(shapeStorage.__vftable) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15593, ASSERT_TYPE_ASSERT, "(shapeStorage == Physics_ShapeStorage::Permanent)", "%s\n\tShould not use heap allocator temporary storage", "shapeStorage == Physics_ShapeStorage::Permanent") )
      __debugbreak();
    ConvexShape = (hknpCapsuleShape *)hknpConvexShape::allocateConvexShape(2, 64, (int *)&shapeStorage);
    if ( ConvexShape )
    {
      hknpCapsuleShape::hknpCapsuleShape(ConvexShape, a, b, radius);
      v12 = v14;
    }
    else
    {
      v12 = 0i64;
    }
    *(_WORD *)(v12 + 16) = shapeStorage.__vftable;
  }
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15596, ASSERT_TYPE_ASSERT, "(capsuleShape)", (const char *)&queryFormat, "capsuleShape") )
    __debugbreak();
  if ( !v10 )
  {
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15602, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics CreateShapeCapsule %i: world is NULL", "physicsWorld->world", worldId) )
      __debugbreak();
    p_m_map = &MutableWorld->capsuleRadii->m_map;
    *(float *)&shapeStorage.__vftable = radius;
    v17 = (unsigned int)hkMemHeapAllocator();
    m_hashMod = p_m_map->m_hashMod;
    if ( 2 * p_m_map->m_numElems > m_hashMod )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(p_m_map, &shapeStorage, v17);
      m_hashMod = p_m_map->m_hashMod;
    }
    v19 = 1;
    v20 = _byteswap_ulong(-1640531535 * v12);
    v21 = _byteswap_ulong(-1640531535 * HIDWORD(v12));
    v22 = m_hashMod & (v21 ^ ((v20 >> 2) + v20 + (v21 << 6) - 1640531527));
    m_elem = p_m_map->m_elem;
    key = p_m_map->m_elem[v22].key;
    if ( key != -1i64 )
    {
      while ( key != v12 )
      {
        v22 = p_m_map->m_hashMod & (v22 + 1);
        key = m_elem[v22].key;
        if ( key == -1i64 )
          goto LABEL_24;
      }
      v19 = 0;
    }
LABEL_24:
    p_m_map->m_numElems += v19;
    v25 = (int)v22;
    m_elem[v25].key = v12;
    p_m_map->m_elem[v25].val = LODWORD(radius);
  }
  return (hknpShape *)v12;
}

/*
==============
HavokPhysics_CreateShapeCompound
==============
*/
hknpShape *HavokPhysics_CreateShapeCompound(hkArray<hknpShapeInstance,hkContainerHeapAllocator> *instanceArray)
{
  __int64 m_size; 
  int v4; 
  int v5; 
  __int64 v6; 
  __int64 v7; 
  __int64 v8; 
  hknpShapeInstance *v9; 
  hkMemoryAllocator *v10; 
  int v11; 
  __int64 v12; 
  bool v13; 
  __m256i *v14; 
  hkReferencedObject *v15; 
  hkMemoryRouter *v16; 
  hknpCompoundShape *v17; 
  hknpShape *v18; 
  hknpShape *v19; 
  hkMemoryAllocator *v20; 
  int v21; 
  hknpShapeInstance *v22; 
  __m256i *v23; 
  hkMemoryAllocator *v24; 
  __int64 v25; 
  hkReferencedObject **p_m_shape; 
  hkMemoryRouter *v27; 
  hknpCompoundShape *v28; 
  __int64 v29; 
  __int64 v30; 
  hkMemoryAllocator *v31; 
  __int64 v32; 
  hkReferencedObject **v33; 
  hkMemoryRouter *Value; 
  hknpCompoundShape *v35; 
  __int64 v36; 
  __int64 v37; 
  hknpShapeInstance *array; 
  int v39; 
  int v40; 
  void *p; 
  int v42; 
  int v43; 
  hknpCompoundShapeCinfo v44; 
  __int64 v45; 
  __m256i *v46; 
  hknpCompoundShapeCinfo cinfo; 
  int v48; 
  int v49; 
  __int64 v50; 

  v45 = -2i64;
  if ( !instanceArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15660, ASSERT_TYPE_ASSERT, "(instanceArray)", (const char *)&queryFormat, "instanceArray") )
    __debugbreak();
  m_size = instanceArray->m_size;
  v49 = m_size;
  if ( !(_DWORD)m_size )
    return 0i64;
  if ( (int)m_size < 0xFFFF )
  {
    hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&v44);
    v44.m_instances = instanceArray->m_data;
    v44.m_numInstances = instanceArray->m_size;
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v35 = (hknpCompoundShape *)Value->m_heap->blockAlloc(Value->m_heap, 288i64);
    if ( v35 )
    {
      hknpCompoundShape::hknpCompoundShape(v35, &v44);
      v37 = v36;
    }
    else
    {
      v37 = 0i64;
    }
    if ( !v37 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15733, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    return (hknpShape *)v37;
  }
  else
  {
    p = NULL;
    v42 = 0;
    v43 = 0x80000000;
    v4 = 0;
    v48 = 0;
    if ( (int)m_size > 0 )
    {
      v50 = m_size;
      do
      {
        array = NULL;
        v5 = 0;
        v39 = 0;
        v40 = 0x80000000;
        v6 = 0i64;
        v7 = v4;
        v8 = v4;
        do
        {
          if ( v7 + v6 >= v50 )
            break;
          v9 = &instanceArray->m_data[v8];
          v10 = hkMemHeapAllocator();
          v11 = v39;
          if ( v39 == (v40 & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v10, &array, 112);
            v11 = v39;
          }
          v12 = v11;
          v13 = &array[v12] == NULL;
          v14 = (__m256i *)&array[v12];
          v46 = v14;
          if ( !v13 )
          {
            *v14 = *(__m256i *)v9->m_transform.m_rotation.m_col0.m_quad.m128_f32;
            v14[1] = *(__m256i *)v9->m_transform.m_rotation.m_col2.m_quad.m128_f32;
            *(hkVector4f *)v14[2].m256i_i8 = v9->m_scale;
            v15 = &v9->m_shape.m_ptr->hkReferencedObject;
            v14[2].m256i_i64[2] = (__int64)v15;
            if ( v15 )
              hkReferencedObject::addReference(v15);
            v14[2].m256i_i16[12] = v9->m_shapeTag;
            v14[2].m256i_i16[13] = v9->m_destructionTag;
            v14[2].m256i_i8[28] = v9->m_isEmpty;
            v14[3].m256i_i32[0] = v9->m_nextEmptyElement;
            v14[3].m256i_i16[2] = v9->m_instanceId.m_value;
            v14[3].m256i_i64[1] = (__int64)v9->m_parentShape;
            v11 = v39;
          }
          v5 = v11 + 1;
          v39 = v5;
          ++v6;
          ++v8;
        }
        while ( v6 < 0xFFFF );
        if ( v5 <= 0 )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15692, ASSERT_TYPE_ASSERT, "(childInstanceArray.getSize() > 0)", (const char *)&queryFormat, "childInstanceArray.getSize() > 0") )
            __debugbreak();
          v5 = v39;
        }
        v4 = v5 + v48;
        v48 += v5;
        hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&cinfo);
        cinfo.m_instances = array;
        cinfo.m_numInstances = v39;
        v16 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
        if ( !v16 )
          v16 = hkMemoryRouter::s_fallbackRouter;
        v17 = (hknpCompoundShape *)v16->m_heap->blockAlloc(v16->m_heap, 288i64);
        if ( v17 )
        {
          hknpCompoundShape::hknpCompoundShape(v17, &cinfo);
          v19 = v18;
        }
        else
        {
          v19 = NULL;
        }
        if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15702, ASSERT_TYPE_ASSERT, "(childShape)", (const char *)&queryFormat, "childShape") )
          __debugbreak();
        v20 = hkMemHeapAllocator();
        v21 = v42;
        if ( v42 == (v43 & 0x3FFFFFFF) )
        {
          hkArrayUtil::_reserveMore(v20, &p, 112);
          v21 = v42;
        }
        v22 = (hknpShapeInstance *)p;
        v23 = (__m256i *)((char *)p + 112 * v21);
        if ( v23 )
        {
          *v23 = *(__m256i *)g_vectorfConstants[32].m128_f32;
          v23[1] = *(__m256i *)g_vectorfConstants[34].m128_f32;
          *(__m128 *)v23[2].m256i_i8 = g_vectorfConstants[6];
          v23[2].m256i_i64[2] = 0i64;
          v23[2].m256i_i32[6] = -1;
          v23[2].m256i_i8[28] = 0;
          v23[3].m256i_i32[0] = 0;
          v23[3].m256i_i16[2] = -1;
          v23[3].m256i_i64[1] = 0i64;
          v23->m256i_i32[3] = 1056964672;
          v21 = v42;
          v22 = (hknpShapeInstance *)p;
        }
        v42 = v21 + 1;
        hknpShapeInstance::setShape(&v22[v21], v19);
        hkReferencedObject::removeReference(v19);
        v24 = hkMemHeapAllocator();
        v25 = v39 - 1;
        if ( v39 - 1 >= 0 )
        {
          p_m_shape = (hkReferencedObject **)&array[v25].m_shape;
          do
          {
            if ( *p_m_shape )
              hkReferencedObject::removeReference(*p_m_shape);
            p_m_shape -= 14;
            --v25;
          }
          while ( v25 >= 0 );
          v4 = v48;
        }
        v39 = 0;
        if ( v40 >= 0 )
          hkMemoryAllocator::bufFree2(v24, array, 112, v40 & 0x3FFFFFFF);
        array = NULL;
        v40 = 0x80000000;
      }
      while ( v4 < v49 );
    }
    hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&v44);
    v44.m_instances = (const hknpShapeInstance *)p;
    v44.m_numInstances = v42;
    v27 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v27 )
      v27 = hkMemoryRouter::s_fallbackRouter;
    v28 = (hknpCompoundShape *)v27->m_heap->blockAlloc(v27->m_heap, 288i64);
    if ( v28 )
    {
      hknpCompoundShape::hknpCompoundShape(v28, &v44);
      v30 = v29;
    }
    else
    {
      v30 = 0i64;
    }
    if ( !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15719, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    v31 = hkMemHeapAllocator();
    v32 = v42 - 1;
    if ( v42 - 1 >= 0 )
    {
      v33 = (hkReferencedObject **)((char *)p + 112 * v32 + 80);
      do
      {
        if ( *v33 )
          hkReferencedObject::removeReference(*v33);
        v33 -= 14;
        --v32;
      }
      while ( v32 >= 0 );
    }
    v42 = 0;
    if ( v43 >= 0 )
      hkMemoryAllocator::bufFree2(v31, p, 112, v43 & 0x3FFFFFFF);
    return (hknpShape *)v30;
  }
}

/*
==============
HavokPhysics_CreateShapeConvexHull
==============
*/
hknpConvexShape *HavokPhysics_CreateShapeConvexHull(hkArray<hkVector4f,hkContainerHeapAllocator> *verts, unsigned int maxNumGeneratedVertices, bool useCache)
{
  unsigned int v6; 
  __int64 ThreadId; 
  bool v8; 
  unsigned int v9; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *v10; 
  int m_size; 
  hkVector4f *m_data; 
  unsigned __int8 *v13; 
  __int64 v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned int v24; 
  unsigned int v25; 
  int m_hashMod; 
  unsigned __int32 v27; 
  unsigned __int32 v28; 
  unsigned int v29; 
  int v30; 
  unsigned __int64 key; 
  hknpConvexShape *val; 
  int v33; 
  int v34; 
  int v35; 
  int v36; 
  int v37; 
  unsigned __int32 v38; 
  unsigned __int32 v39; 
  unsigned int v40; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 v42; 
  __int64 v43; 
  hkStridedVertices verticesInOrg; 
  hknpConvexShape::BuildConfig configInOrg; 
  hkMemoryAllocator alloc; 

  v6 = 252;
  if ( maxNumGeneratedVertices > 0xFC && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15963, ASSERT_TYPE_ASSERT, "(maxNumGeneratedVertices <= hknpConvexShape::MAX_NUM_VERTICES)", (const char *)&queryFormat, "maxNumGeneratedVertices <= hknpConvexShape::MAX_NUM_VERTICES", -2i64) )
    __debugbreak();
  hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
  ThreadId = Physics_GetThreadId();
  v8 = 0;
  if ( !s_havokPhysicsShapeCachesDisabled[ThreadId] )
    v8 = useCache;
  if ( maxNumGeneratedVertices )
    v6 = maxNumGeneratedVertices;
  v9 = 0;
  v10 = NULL;
  if ( !v8 )
    goto LABEL_25;
  m_size = verts->m_size;
  if ( m_size > 0 )
  {
    m_data = verts->m_data;
    v13 = &verts->m_data->m_quad.m128_u8[6];
    v14 = (unsigned int)m_size;
    do
    {
      v15 = (~v9 >> 8) ^ g_crc32Table[m_data->m_quad.m128_u8[0] ^ (unsigned __int64)(unsigned __int8)~(_BYTE)v9];
      v16 = (v15 >> 8) ^ g_crc32Table[(unsigned __int8)v15 ^ (unsigned __int64)*(v13 - 5)];
      v17 = (v16 >> 8) ^ g_crc32Table[(unsigned __int8)v16 ^ (unsigned __int64)*(v13 - 4)];
      v18 = (v17 >> 8) ^ g_crc32Table[(unsigned __int8)v17 ^ (unsigned __int64)*(v13 - 3)];
      v19 = (v18 >> 8) ^ g_crc32Table[(unsigned __int8)v18 ^ (unsigned __int64)*(v13 - 2)];
      v20 = (v19 >> 8) ^ g_crc32Table[(unsigned __int8)v19 ^ (unsigned __int64)*(v13 - 1)];
      v21 = (v20 >> 8) ^ g_crc32Table[*v13 ^ (unsigned __int64)(unsigned __int8)v20];
      v22 = (v21 >> 8) ^ g_crc32Table[(unsigned __int8)v21 ^ (unsigned __int64)v13[1]];
      v23 = (v22 >> 8) ^ g_crc32Table[(unsigned __int8)v22 ^ (unsigned __int64)v13[2]];
      v24 = (v23 >> 8) ^ g_crc32Table[(unsigned __int8)v23 ^ (unsigned __int64)v13[3]];
      v25 = (v24 >> 8) ^ g_crc32Table[(unsigned __int8)v24 ^ (unsigned __int64)v13[4]];
      v9 = ~((v25 >> 8) ^ g_crc32Table[(unsigned __int8)v25 ^ (unsigned __int64)v13[5]]);
      ++m_data;
      v13 += 16;
      --v14;
    }
    while ( v14 );
  }
  v10 = s_havokPhysicsShapeCaches[ThreadId];
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15999, ASSERT_TYPE_ASSERT, "(cache)", "%s\n\tHavokPhysics_CreateShapeConvexHull: Cache is invalid", "cache") )
    __debugbreak();
  m_hashMod = v10->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v27 = _byteswap_ulong(-1640531535 * v9), v28 = _byteswap_ulong(0), v29 = m_hashMod & (v28 ^ ((v27 >> 2) + v27 + (v28 << 6) - 1640531527)), v30 = v29, key = v10->m_map.m_elem[v29].key, key == -1i64) )
  {
LABEL_19:
    v30 = m_hashMod + 1;
  }
  else
  {
    while ( key != v9 )
    {
      v29 = m_hashMod & (v29 + 1);
      v30 = v29;
      key = v10->m_map.m_elem[v29].key;
      if ( key == -1i64 )
        goto LABEL_19;
    }
  }
  if ( v30 <= m_hashMod )
  {
    val = (hknpConvexShape *)v10->m_map.m_elem[v30].val;
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16011, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    hkReferencedObject::addReference(val);
  }
  else
  {
LABEL_25:
    configInOrg.m_shrinkByRadius.m_bool = 0;
    configInOrg.m_simplificationTolerance = 0.0;
    configInOrg.m_maxNumVertices = v6;
    v33 = verts->m_size;
    verticesInOrg.m_vertices = verts->m_data->m_quad.m128_f32;
    verticesInOrg.m_numVertices = v33;
    verticesInOrg.m_striding = 16;
    val = hknpConvexShape::createFromVertices(&verticesInOrg, 0.0, &configInOrg);
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16025, ASSERT_TYPE_ASSERT, "(hullShape)", (const char *)&queryFormat, "hullShape") )
      __debugbreak();
    if ( v8 )
    {
      hkReferencedObject::addReference(val);
      v34 = (unsigned int)hkMemHeapAllocator();
      v35 = v10->m_map.m_hashMod;
      v36 = v35;
      if ( 2 * v10->m_map.m_numElems > v35 )
      {
        hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v10->m_map, &alloc, v34);
        v35 = v10->m_map.m_hashMod;
        v36 = v35;
      }
      v37 = 1;
      v38 = _byteswap_ulong(-1640531535 * v9);
      v39 = _byteswap_ulong(0);
      v40 = v36 & (v39 ^ ((v38 >> 2) + v38 + (v39 << 6) - 1640531527));
      m_elem = v10->m_map.m_elem;
      v42 = v10->m_map.m_elem[v40].key;
      if ( v42 != -1i64 )
      {
        while ( v42 != v9 )
        {
          v40 = v35 & (v40 + 1);
          v42 = m_elem[v40].key;
          if ( v42 == -1i64 )
            goto LABEL_36;
        }
        v37 = 0;
      }
LABEL_36:
      v10->m_map.m_numElems += v37;
      v43 = (int)v40;
      m_elem[v43].key = v9;
      v10->m_map.m_elem[v43].val = (unsigned __int64)val;
    }
  }
  hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
  return val;
}

/*
==============
HavokPhysics_CreateShapeConvexHullFromAABB
==============
*/
hknpConvexShape *HavokPhysics_CreateShapeConvexHullFromAABB(const hkVector4f *mins, const hkVector4f *maxs)
{
  const hknpConvexShape::BuildConfig *v2; 
  hknpConvexShape *v3; 
  hknpConvexShape::BuildConfig v5; 
  hkAabb aabb; 

  aabb.m_min = (hkVector4f)mins->m_quad;
  aabb.m_max = (hkVector4f)maxs->m_quad;
  hknpConvexShape::BuildConfig::BuildConfig(&v5);
  v3 = hknpConvexShape::createFromAabb(&aabb, 0.015, v2);
  hkReferencedObject::~hkReferencedObject(&v5.m_massConfig);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16049, ASSERT_TYPE_ASSERT, "(hullShape)", (const char *)&queryFormat, "hullShape", -2i64) )
    __debugbreak();
  return v3;
}

/*
==============
HavokPhysics_CreateShapeCube
==============
*/
hknpConvexShape *HavokPhysics_CreateShapeCube(const hkVector4f *center, float halfSize)
{
  int v3; 
  hkMemoryAllocator *v4; 
  __int64 v5; 
  __int64 v10; 
  __int64 v15; 
  __int64 v20; 
  __int64 v25; 
  __int64 v30; 
  __int64 v35; 
  __int64 v44; 
  hknpConvexShape *v45; 
  hkMemoryAllocator *v46; 
  __m128 *array; 
  int v49; 
  int v50; 
  hkStridedVertices verticesInOrg; 
  hknpConvexShape::BuildConfig configInOrg; 

  array = NULL;
  v49 = 0;
  v50 = 0x80000000;
  hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
  v3 = numVertices;
  v4 = hkMemHeapAllocator();
  if ( v3 > 0 )
    hkArrayUtil::_reserve(v4, &array, v3, 16);
  v5 = v49++;
  _XMM0 = 0i64;
  __asm
  {
    vinsertps xmm0, xmm0, xmm2, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
  }
  array[v5] = _mm128_add_ps(_XMM0, center->m_quad);
  v10 = v49++;
  _XMM0 = 0i64;
  __asm
  {
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
  }
  array[v10] = _mm128_add_ps(_XMM0, center->m_quad);
  v15 = v49++;
  _XMM0 = 0i64;
  __asm
  {
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
  }
  array[v15] = _mm128_add_ps(_XMM0, center->m_quad);
  v20 = v49++;
  _XMM0 = 0i64;
  __asm
  {
    vinsertps xmm0, xmm0, xmm2, 0
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm2, 20h ; ' '
  }
  array[v20] = _mm128_add_ps(_XMM0, center->m_quad);
  v25 = v49++;
  _XMM0 = 0i64;
  __asm
  {
    vinsertps xmm0, xmm0, xmm2, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm6, 20h ; ' '
  }
  array[v25] = _mm128_add_ps(_XMM0, center->m_quad);
  v30 = v49++;
  _XMM0 = 0i64;
  __asm
  {
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm2, 10h
    vinsertps xmm0, xmm0, xmm6, 20h ; ' '
  }
  array[v30] = _mm128_add_ps(_XMM0, center->m_quad);
  v35 = v49++;
  _XMM0 = 0i64;
  __asm
  {
    vinsertps xmm0, xmm0, xmm6, 0
    vinsertps xmm0, xmm0, xmm6, 10h
    vinsertps xmm0, xmm0, xmm6, 20h ; ' '
  }
  array[v35] = _mm128_add_ps(_XMM0, center->m_quad);
  _XMM1 = 0i64;
  __asm
  {
    vinsertps xmm1, xmm1, xmm2, 0
    vinsertps xmm1, xmm1, xmm6, 10h
    vinsertps xmm1, xmm1, xmm6, 20h ; ' '
  }
  v44 = v49++;
  array[v44] = _mm128_add_ps(_XMM1, center->m_quad);
  configInOrg.m_shrinkByRadius.m_bool = 0;
  configInOrg.m_simplificationTolerance = 0.0;
  verticesInOrg.m_vertices = (const float *)array;
  verticesInOrg.m_numVertices = v49;
  verticesInOrg.m_striding = 16;
  v45 = hknpConvexShape::createFromVertices(&verticesInOrg, 0.0, &configInOrg);
  if ( !v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15651, ASSERT_TYPE_ASSERT, "(cubeShape)", (const char *)&queryFormat, "cubeShape", -2i64) )
    __debugbreak();
  hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
  v46 = hkMemHeapAllocator();
  v49 = 0;
  if ( v50 >= 0 )
    hkMemoryAllocator::bufFree2(v46, array, 16, v50 & 0x3FFFFFFF);
  return v45;
}

/*
==============
HavokPhysics_CreateShapeCylinder
==============
*/
hknpConvexShape *HavokPhysics_CreateShapeCylinder(const hkVector4f *center, float halfHeight, float radius, int numVertices, hkMemoryAllocator useCache)
{
  __int64 ThreadId; 
  char v9; 
  unsigned int v10; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *v11; 
  unsigned int v12; 
  unsigned int v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned int v24; 
  unsigned int v25; 
  unsigned int v26; 
  unsigned int v27; 
  unsigned int v28; 
  unsigned int v29; 
  unsigned int v30; 
  unsigned int v31; 
  unsigned int v32; 
  unsigned int v33; 
  int m_hashMod; 
  unsigned __int32 v35; 
  unsigned __int32 v36; 
  unsigned int v37; 
  int v38; 
  unsigned __int64 key; 
  hknpConvexShape *val; 
  hkMemoryAllocator *v41; 
  int v42; 
  int v43; 
  hkResult v44; 
  const __m128 *v45; 
  int v46; 
  int v47; 
  int v48; 
  float v49; 
  __m128 v50; 
  const __m128 *v51; 
  __int64 v60; 
  __int64 v61; 
  hkMemoryRouter *Value; 
  __int64 v63; 
  __int64 v64; 
  int v65; 
  int v66; 
  int v67; 
  int v68; 
  unsigned __int32 v69; 
  unsigned __int32 v70; 
  unsigned int v71; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 v73; 
  __int64 v74; 
  hkMemoryAllocator *v75; 
  __m128 *array; 
  unsigned int v78; 
  int v79; 
  __m128 result; 
  __int64 v81; 
  hknpConvexShape::BuildConfig configInOrg; 

  v81 = -2i64;
  array = NULL;
  v78 = 0;
  v79 = 0x80000000;
  hknpConvexShape::BuildConfig::BuildConfig(&configInOrg);
  ThreadId = Physics_GetThreadId();
  v9 = 0;
  if ( !s_havokPhysicsShapeCachesDisabled[ThreadId] )
    v9 = (char)useCache.__vftable;
  v10 = 0;
  v11 = NULL;
  if ( !v9 )
    goto LABEL_17;
  v12 = ((g_crc32Table[(unsigned __int8)~center->m_quad.m128_i8[0]] ^ 0xFFFFFF) >> 8) ^ g_crc32Table[center->m_quad.m128_u8[1] ^ (unsigned __int64)(unsigned __int8)~LOBYTE(g_crc32Table[(unsigned __int8)~center->m_quad.m128_i8[0]])];
  v13 = (v12 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[2] ^ (unsigned __int64)(unsigned __int8)v12];
  v14 = (v13 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[3] ^ (unsigned __int64)(unsigned __int8)v13];
  v15 = (v14 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[4] ^ (unsigned __int64)(unsigned __int8)v14];
  v16 = (v15 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[5] ^ (unsigned __int64)(unsigned __int8)v15];
  v17 = (v16 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[6] ^ (unsigned __int64)(unsigned __int8)v16];
  v18 = (v17 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[7] ^ (unsigned __int64)(unsigned __int8)v17];
  v19 = (v18 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[8] ^ (unsigned __int64)(unsigned __int8)v18];
  v20 = (v19 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[9] ^ (unsigned __int64)(unsigned __int8)v19];
  v21 = (v20 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[10] ^ (unsigned __int64)(unsigned __int8)v20];
  v22 = (v21 >> 8) ^ g_crc32Table[center->m_quad.m128_u8[11] ^ (unsigned __int64)(unsigned __int8)v21];
  v23 = (v22 >> 8) ^ g_crc32Table[LOBYTE(halfHeight) ^ (unsigned __int64)(unsigned __int8)v22];
  v24 = (v23 >> 8) ^ g_crc32Table[BYTE1(halfHeight) ^ (unsigned __int64)(unsigned __int8)v23];
  v25 = (v24 >> 8) ^ g_crc32Table[BYTE2(halfHeight) ^ (unsigned __int64)(unsigned __int8)v24];
  v26 = (v25 >> 8) ^ g_crc32Table[HIBYTE(halfHeight) ^ (unsigned __int64)(unsigned __int8)v25];
  v27 = (v26 >> 8) ^ g_crc32Table[LOBYTE(radius) ^ (unsigned __int64)(unsigned __int8)v26];
  v28 = (v27 >> 8) ^ g_crc32Table[BYTE1(radius) ^ (unsigned __int64)(unsigned __int8)v27];
  v29 = (v28 >> 8) ^ g_crc32Table[BYTE2(radius) ^ (unsigned __int64)(unsigned __int8)v28];
  v30 = (v29 >> 8) ^ g_crc32Table[HIBYTE(radius) ^ (unsigned __int64)(unsigned __int8)v29];
  v31 = (v30 >> 8) ^ g_crc32Table[(unsigned __int8)numVertices ^ (unsigned __int64)(unsigned __int8)v30];
  v32 = (v31 >> 8) ^ g_crc32Table[BYTE1(numVertices) ^ (unsigned __int64)(unsigned __int8)v31];
  v33 = (v32 >> 8) ^ g_crc32Table[BYTE2(numVertices) ^ (unsigned __int64)(unsigned __int8)v32];
  v10 = ~((v33 >> 8) ^ g_crc32Table[HIBYTE(numVertices) ^ (unsigned __int64)(unsigned __int8)v33]);
  v11 = s_havokPhysicsShapeCaches[ThreadId];
  if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15897, ASSERT_TYPE_ASSERT, "(cache)", "%s\n\tHavokPhysics_CreateShapeCylinder: Cache is invalid", "cache") )
    __debugbreak();
  m_hashMod = v11->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v35 = _byteswap_ulong(-1640531535 * v10), v36 = _byteswap_ulong(0), v37 = m_hashMod & (v36 ^ ((v35 >> 2) + v35 + (v36 << 6) - 1640531527)), v38 = v37, key = v11->m_map.m_elem[v37].key, key == -1i64) )
  {
LABEL_11:
    v38 = m_hashMod + 1;
  }
  else
  {
    while ( key != v10 )
    {
      v37 = m_hashMod & (v37 + 1);
      v38 = v37;
      key = v11->m_map.m_elem[v37].key;
      if ( key == -1i64 )
        goto LABEL_11;
    }
  }
  if ( v38 <= m_hashMod )
  {
    val = (hknpConvexShape *)v11->m_map.m_elem[v38].val;
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15909, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
      __debugbreak();
    hkReferencedObject::addReference(val);
  }
  else
  {
LABEL_17:
    v41 = hkMemHeapAllocator();
    if ( (v79 & 0x3FFFFFFF) >= numVertices )
    {
      v44.m_code = 0;
    }
    else
    {
      v42 = 2 * (v79 & 0x3FFFFFFF);
      if ( (unsigned int)v42 >= 0x3FFFFFFF )
        v42 = 1073741822;
      v43 = numVertices;
      if ( numVertices < v42 )
        v43 = v42;
      v44.m_code = hkArrayUtil::_reserve(v41, &array, v43, 16).m_code;
    }
    LODWORD(useCache.__vftable) = v44;
    v45 = (const __m128 *)(unsigned int)(numVertices >> 31);
    v46 = numVertices / 2;
    v47 = numVertices / 2;
    v48 = 0;
    if ( v46 > 0 )
    {
      v49 = 1.0 / (float)v46;
      do
      {
        v50 = 0i64;
        v50.m128_f32[0] = (float)((float)v48 * 6.2831855) * v49;
        *(float *)&useCache.__vftable = v50.m128_f32[0];
        result = v50;
        hkMath::quadSin(&result, v45);
        *(float *)&useCache.__vftable = v50.m128_f32[0];
        result = v50;
        hkMath::quadCos(&result, v51);
        _XMM2 = 0i64;
        __asm
        {
          vinsertps xmm2, xmm2, xmm7, 0
          vinsertps xmm2, xmm2, xmm1, 10h
          vinsertps xmm2, xmm2, xmm11, 20h ; ' '
        }
        _XMM3 = 0i64;
        __asm
        {
          vinsertps xmm3, xmm3, xmm7, 0
          vinsertps xmm3, xmm3, xmm1, 10h
          vinsertps xmm3, xmm3, xmm9, 20h ; ' '
        }
        v60 = (int)v78++;
        array[v60] = _mm128_add_ps(_XMM2, center->m_quad);
        v61 = (int)v78++;
        array[v61] = _mm128_add_ps(_XMM3, center->m_quad);
        ++v48;
      }
      while ( v48 < v47 );
    }
    configInOrg.m_shrinkByRadius.m_bool = 0;
    configInOrg.m_simplificationTolerance = 0.0;
    result.m128_u64[0] = (unsigned __int64)array;
    result.m128_u64[1] = v78 | 0x1000000000i64;
    val = hknpConvexShape::createFromVertices((const hkStridedVertices *)&result, 0.0, &configInOrg);
    if ( !val && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15939, ASSERT_TYPE_ASSERT, "(cylinderShape)", (const char *)&queryFormat, "cylinderShape") )
      __debugbreak();
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v63 = (__int64)Value->m_heap->blockAlloc(Value->m_heap, 32i64);
    v64 = v63;
    v65 = 1;
    if ( v63 )
    {
      *(_QWORD *)(v63 + 8) = 0i64;
      *(_DWORD *)(v63 + 16) = 0x1FFFF;
      *(_QWORD *)v63 = &HavokPhysics_CylinderShapeStats::`vftable';
    }
    else
    {
      v64 = 0i64;
    }
    *(float *)(v64 + 24) = radius;
    *(float *)(v64 + 28) = halfHeight * 2.0;
    hknpShape::setProperty(val, 1u, (hkReferencedObject *)v64);
    hkReferencedObject::removeReference((hkReferencedObject *)v64);
    if ( v9 )
    {
      hkReferencedObject::addReference(val);
      v66 = (unsigned int)hkMemHeapAllocator();
      v67 = v11->m_map.m_hashMod;
      v68 = v67;
      if ( 2 * v11->m_map.m_numElems > v67 )
      {
        hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v11->m_map, &useCache, v66);
        v67 = v11->m_map.m_hashMod;
        v68 = v67;
      }
      v69 = _byteswap_ulong(-1640531535 * v10);
      v70 = _byteswap_ulong(0);
      v71 = v68 & (v70 ^ ((v69 >> 2) + v69 + (v70 << 6) - 1640531527));
      m_elem = v11->m_map.m_elem;
      v73 = v11->m_map.m_elem[v71].key;
      if ( v73 != -1i64 )
      {
        while ( v73 != v10 )
        {
          v71 = v67 & (v71 + 1);
          v73 = m_elem[v71].key;
          if ( v73 == -1i64 )
            goto LABEL_43;
        }
        v65 = 0;
      }
LABEL_43:
      v11->m_map.m_numElems += v65;
      v74 = (int)v71;
      m_elem[v74].key = v10;
      v11->m_map.m_elem[v74].val = (unsigned __int64)val;
    }
  }
  hkReferencedObject::~hkReferencedObject(&configInOrg.m_massConfig);
  v75 = hkMemHeapAllocator();
  v78 = 0;
  if ( v79 >= 0 )
    hkMemoryAllocator::bufFree2(v75, array, 16, v79 & 0x3FFFFFFF);
  return val;
}

/*
==============
HavokPhysics_CreateShapeSphere
==============
*/
hknpShape *HavokPhysics_CreateShapeSphere(const hkVector4f *center, float radius, char *optionalInplaceBuffer, int optionalInplaceBufferSize)
{
  __int64 v6; 
  __int64 v7; 
  hknpSphereShape *v8; 
  __int64 v9; 
  float v10; 
  int shapeSizeOut; 
  char *v13; 

  if ( optionalInplaceBuffer )
  {
    v13 = optionalInplaceBuffer;
    hknpSphereShape::hknpSphereShape((hknpSphereShape *)optionalInplaceBuffer, center, radius);
    v7 = v6;
    *(_WORD *)(v6 + 16) = 0;
  }
  else
  {
    v8 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
    v13 = (char *)v8;
    if ( v8 )
    {
      hknpSphereShape::hknpSphereShape(v8, center, radius);
      v7 = v9;
    }
    else
    {
      v7 = 0i64;
    }
    *(_WORD *)(v7 + 16) = shapeSizeOut;
  }
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15558, ASSERT_TYPE_ASSERT, "(sphereShape)", (const char *)&queryFormat, "sphereShape") )
    __debugbreak();
  v10 = *(float *)(v7 + 32);
  if ( v10 != radius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", v10, radius) )
    __debugbreak();
  return (hknpShape *)v7;
}

/*
==============
HavokPhysics_CreateWorld
==============
*/
void HavokPhysics_CreateWorld(Physics_WorldId worldId, Physics_WorldCInfo *worldCInfo)
{
  unsigned __int64 v3; 
  HavokPhysicsWorld *MutableWorld; 
  hkMemoryRouter *Value; 
  hkFixedBlockStreamAllocator *v6; 
  hkFixedBlockStreamAllocator *v7; 
  hkMemoryRouter *v8; 
  HavokPhysicsCollisionFilter *v9; 
  HavokPhysicsCollisionFilter *v10; 
  hkMemoryRouter *v11; 
  HavokPhysicsCollisionFilter *v12; 
  HavokPhysicsCollisionFilter *v13; 
  hkMemoryRouter *v14; 
  __int64 v15; 
  hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *v16; 
  __int64 maxRagdolls; 
  hkMemoryAllocator *v18; 
  int v19; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *v20; 
  unsigned int v21; 
  __int64 v22; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *v23; 
  int v24; 
  hkDefaultTaskQueue *v25; 
  bool isMultithreaded; 
  hkMemoryRouter *v27; 
  hkDefaultTaskQueue *v28; 
  hknpCollisionFilter *simulationCollisionFilter; 
  hkMemoryRouter *v32; 
  hknpWorld *v33; 
  hknpWorld *v34; 
  hknpCollisionQueryDispatcher *m_object; 
  int v36; 
  __int64 v37; 
  const hknpShapeType::Enum *m_baseTypeMap; 
  hknpCollisionQueryDispatcher *v39; 
  int v40; 
  __int64 v41; 
  __int64 v42; 
  const hknpShapeType::Enum *v43; 
  __int64 v44; 
  hknpBroadPhase *UndecoratedBroadPhase; 
  hknpModifier *v46; 
  __int64 v47; 
  __int64 v48; 
  hkMemoryRouter *v49; 
  HavokPhysics_CollisionQueryDispatcher *v50; 
  __int64 v51; 
  __int64 v52; 
  hkMemoryRouter *v53; 
  __int64 v54; 
  __int64 v55; 
  int v56; 
  hkMemoryAllocator *v57; 
  int v58; 
  int v59; 
  void *v60; 
  unsigned int v61; 
  hkMemoryRouter *v62; 
  __int64 v63; 
  __int64 v64; 
  int v65; 
  hkMemoryAllocator *v66; 
  int v67; 
  int v68; 
  void *v69; 
  unsigned int v70; 
  __int64 v71; 
  __int64 v72; 
  hkMemoryRouter *v73; 
  __int64 v74; 
  hkMemoryRouter *v75; 
  __int64 v76; 
  hkMemoryRouter *v77; 
  __int64 v78; 
  hkMemoryRouter *v79; 
  __int64 v80; 
  hkMemoryRouter *v81; 
  __int64 v82; 
  hkMemoryRouter *v83; 
  __int64 v84; 
  __int64 v85; 
  __int64 v86; 
  hkMemoryRouter *v87; 
  __int64 v88; 
  hkMemoryRouter *v89; 
  __int64 v90; 
  hkMemoryRouter *v91; 
  __int64 v92; 
  hkMemoryRouter *v93; 
  __int64 v94; 
  hkMemoryRouter *v95; 
  __int64 v96; 
  _DWORD *v97; 
  __int64 v98; 
  hkMemoryRouter *v99; 
  __int64 v100; 
  hkMemoryRouter *v101; 
  __int64 v102; 
  hkProcessContext *v103; 
  hkMemoryAllocator *v104; 
  int m_size; 
  hkMemoryRouter *v106; 
  hknpProcessContext *v107; 
  __int64 v108; 
  hkProcessFactory *m_ptr; 
  __int64 v110; 
  hkProcessContext *v111; 
  hkMemoryAllocator *v112; 
  int v113; 
  hkMemoryRouter *v114; 
  hclClothContext *v115; 
  __int64 v116; 
  __int64 v117; 
  hkProcessContext *v118; 
  hkMemoryAllocator *v119; 
  int v120; 
  hkMemoryRouter *v121; 
  hkVisualDebugger *v122; 
  __int64 v123; 
  hkMemoryRouter *v124; 
  __int64 v125; 
  __int64 v126; 
  hkMemoryRouter *v127; 
  hkServerObjectSerializer *v128; 
  __int64 v129; 
  hkMemoryRouter *v130; 
  hkServerObjectHandler *v131; 
  __int64 v132; 
  hkMemoryRouter *v133; 
  HavokPhysicsProcessHandler *v134; 
  __int64 v135; 
  hkMemoryRouter *v136; 
  __int64 v137; 
  hknpSphereShape *v138; 
  __int64 v139; 
  __int64 v140; 
  float v141; 
  hknpSphereShape *v142; 
  __int64 v143; 
  __int64 v144; 
  float v145; 
  unsigned int i; 
  hkMemoryRouter *v147; 
  __int64 v148; 
  __int64 v149; 
  unsigned __int8 *WeaponPriorityMap; 
  __int64 v151; 
  __int64 v152; 
  HavokPhysicsWorld *v153; 
  hknpEventSignal *EventSignal; 
  HavokPhysicsWorld *v155; 
  hkMemoryAllocator *v156; 
  __int64 levelA; 
  int listenPort[2]; 
  hkArray<hkProcessContext *,hkContainerHeapAllocator> array; 
  int numInOut; 
  int v161; 
  int v162; 
  int shapeSizeOut; 
  int v164; 
  HavokPhysicsWorld *v165; 
  Physics_WorldCInfo *v166; 
  hknpSphereShape *v167; 
  int v168; 
  LPCRITICAL_SECTION lpCriticalSection; 
  hkDefaultTaskQueue::Cinfo cinfo; 
  __int64 v171; 
  hkCriticalSection *p_critSection; 
  hknpWorldCinfo v173; 
  hkVector4f center; 

  v171 = -2i64;
  v166 = worldCInfo;
  v3 = worldId;
  shapeSizeOut = worldId;
  array.m_data = NULL;
  array.m_size = 0;
  array.m_capacityAndFlags = 0x80000000;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3088, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to CreateWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !worldCInfo )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3089, ASSERT_TYPE_ASSERT, "(worldCInfo)", "%s\n\tHavokPhysics CreateWorld %i: WorldCInfo is NULL", "worldCInfo", levelA) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v3);
  v165 = MutableWorld;
  lpCriticalSection = (LPCRITICAL_SECTION)&MutableWorld->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v6 = (hkFixedBlockStreamAllocator *)Value->m_heap->blockAlloc(Value->m_heap, 112i64);
  *(_QWORD *)listenPort = v6;
  if ( v6 )
    hkFixedBlockStreamAllocator::hkFixedBlockStreamAllocator(v6, 0);
  else
    v7 = NULL;
  MutableWorld->persistentStreamAllocator = v7;
  if ( !v7 )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3099, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics CreateWorld %i: persistent stream allocator failed to create", "havokPhysicsWorld->persistentStreamAllocator", levelA) )
      __debugbreak();
  }
  hkFixedBlockStreamAllocator::init(MutableWorld->persistentStreamAllocator, worldCInfo->persistentBuffer, worldCInfo->persistentBufferSize);
  v8 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v8 )
    v8 = hkMemoryRouter::s_fallbackRouter;
  v9 = (HavokPhysicsCollisionFilter *)v8->m_heap->blockAlloc(v8->m_heap, 56i64);
  *(_QWORD *)listenPort = v9;
  if ( v9 )
    HavokPhysicsCollisionFilter::HavokPhysicsCollisionFilter(v9, (Physics_WorldId)v3, COLLISIONFILTERTYPE_TRACE);
  else
    v10 = NULL;
  MutableWorld->traceCollisionFilter = v10;
  if ( !v10 )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3105, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->traceCollisionFilter)", "%s\n\tHavokPhysics CreateWorld %i: trace collision filter failed to create", "havokPhysicsWorld->traceCollisionFilter", levelA) )
      __debugbreak();
  }
  v11 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v11 )
    v11 = hkMemoryRouter::s_fallbackRouter;
  v12 = (HavokPhysicsCollisionFilter *)v11->m_heap->blockAlloc(v11->m_heap, 56i64);
  *(_QWORD *)listenPort = v12;
  if ( v12 )
    HavokPhysicsCollisionFilter::HavokPhysicsCollisionFilter(v12, (Physics_WorldId)v3, COLLISIONFILTERTYPE_SIMULATION);
  else
    v13 = NULL;
  MutableWorld->simulationCollisionFilter = v13;
  if ( !v13 )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3107, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->simulationCollisionFilter)", "%s\n\tHavokPhysics CreateWorld %i: simulation collision filter failed to create", "havokPhysicsWorld->simulationCollisionFilter", levelA) )
      __debugbreak();
  }
  MutableWorld->isMultithreaded = worldCInfo->isMultiThreaded;
  MutableWorld->hasFXSupport = worldCInfo->hasFXSupport;
  if ( worldCInfo->maxRagdolls <= 0 )
  {
    MutableWorld->m_ragdollConstraintGroupId = NULL;
  }
  else
  {
    v14 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v14 )
      v14 = hkMemoryRouter::s_fallbackRouter;
    v15 = (__int64)v14->m_heap->blockAlloc(v14->m_heap, 16i64);
    v16 = (hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *)v15;
    *(_QWORD *)listenPort = v15;
    if ( v15 )
    {
      v168 = 0x7FFFFFFF;
      maxRagdolls = worldCInfo->maxRagdolls;
      *(_QWORD *)v15 = 0i64;
      *(_DWORD *)(v15 + 8) = 0;
      *(_DWORD *)(v15 + 12) = 0x80000000;
      numInOut = maxRagdolls;
      v18 = hkMemHeapAllocator();
      v19 = maxRagdolls;
      if ( (_DWORD)maxRagdolls )
      {
        v20 = (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *)hkMemoryAllocator::bufAlloc2(v18, 4, &numInOut);
        v19 = numInOut;
      }
      else
      {
        v20 = NULL;
      }
      v21 = 0x80000000;
      if ( v19 )
        v21 = v19;
      v16->m_data = v20;
      v16->m_size = maxRagdolls;
      v16->m_capacityAndFlags = v21;
      v22 = maxRagdolls;
      if ( (int)maxRagdolls > 0 )
      {
        v23 = v20;
        while ( v22 )
        {
          v23->m_value = 0x7FFFFFFF;
          ++v23;
          --v22;
        }
      }
    }
    else
    {
      v16 = NULL;
    }
    MutableWorld->m_ragdollConstraintGroupId = v16;
  }
  MutableWorld->defaultTimeStep = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[0] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[1] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[2] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[3] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[4] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[5] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[6] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[7] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[8] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[9] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[10] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[11] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[12] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[13] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[14] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[15] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[16] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[17] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[18] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistory[19] = worldCInfo->defaultTimeStep;
  MutableWorld->timeStepHistoryStart = 0;
  MutableWorld->timeStep = worldCInfo->defaultTimeStep;
  v24 = 1;
  if ( MutableWorld->isMultithreaded )
    v24 = 4;
  MutableWorld->stepInput.m_numThreads = v24;
  *(_QWORD *)&cinfo.m_schedulingMode = 0i64;
  cinfo.m_maxNumThreads = 64;
  cinfo.m_asyncThreadPool = NULL;
  if ( MutableWorld->isMultithreaded || MutableWorld->hasFXSupport )
  {
    v27 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v27 )
      v27 = hkMemoryRouter::s_fallbackRouter;
    v28 = (hkDefaultTaskQueue *)v27->m_heap->blockAlloc(v27->m_heap, 912i64);
    *(_QWORD *)listenPort = v28;
    if ( v28 )
      hkDefaultTaskQueue::hkDefaultTaskQueue(v28, &cinfo);
    else
      v25 = NULL;
    isMultithreaded = MutableWorld->isMultithreaded;
  }
  else
  {
    v25 = NULL;
    isMultithreaded = 0;
  }
  MutableWorld->taskQueue = v25;
  if ( isMultithreaded && !v25 )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3145, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics CreateWorld %i: task queue failed to create", "!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue", levelA) )
      __debugbreak();
  }
  if ( !MutableWorld->isMultithreaded && !MutableWorld->hasFXSupport )
  {
    if ( MutableWorld->taskQueue )
    {
      LODWORD(levelA) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3146, ASSERT_TYPE_ASSERT, "(( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics CreateWorld %i: task queue should be null here", "( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue", levelA) )
        __debugbreak();
    }
  }
  HavokPhysicsInstanceManager_Init(&MutableWorld->instanceManager, worldCInfo->systemCountMax);
  hknpWorldCinfo::hknpWorldCinfo(&v173);
  v173.m_blockStreamAllocator = MutableWorld->persistentStreamAllocator;
  v173.m_bodyBufferCapacity = worldCInfo->bodyCountMax;
  v173.m_userBodyBuffer = NULL;
  v173.m_motionBufferCapacity = worldCInfo->motionCountMax;
  v173.m_userMotionBuffer = NULL;
  v173.m_constraintBufferCapacity = worldCInfo->constraintCountMax;
  v173.m_userConstraintBuffer = NULL;
  v173.m_constraintGroupBufferCapacity = 1;
  v173.m_userConstraintGroupBuffer = NULL;
  v173.m_useBodyBacklinkBuffer.m_bool = 0;
  if ( v173.m_materialLibrary.m_ptr )
    hkReferencedObject::removeReference(v173.m_materialLibrary.m_ptr);
  v173.m_materialLibrary.m_ptr = NULL;
  if ( v173.m_motionPropertiesLibrary.m_ptr )
    hkReferencedObject::removeReference(v173.m_motionPropertiesLibrary.m_ptr);
  v173.m_motionPropertiesLibrary.m_ptr = NULL;
  if ( v173.m_qualityLibrary.m_ptr )
    hkReferencedObject::removeReference(v173.m_qualityLibrary.m_ptr);
  v173.m_qualityLibrary.m_ptr = NULL;
  v173.m_simulationType.m_storage = MutableWorld->isMultithreaded;
  v173.m_numSplitterCells = 32;
  _XMM2 = 0i64;
  __asm { vinsertps xmm2, xmm2, xmm1, 20h ; ' ' }
  v173.m_gravity = (hkVector4f)_XMM2.m_quad;
  *(_WORD *)&v173.m_enableContactCaching.m_bool = 257;
  v173.m_broadPhaseType.m_storage = 2;
  v173.m_broadPhaseAabb.m_min.m_quad.m128_f32[0] = 0.03125 * cm.broadphaseMin.v[0];
  v173.m_broadPhaseAabb.m_min.m_quad.m128_f32[1] = 0.03125 * cm.broadphaseMin.v[1];
  v173.m_broadPhaseAabb.m_min.m_quad.m128_f32[2] = 0.03125 * cm.broadphaseMin.v[2];
  v173.m_broadPhaseAabb.m_min.m_quad.m128_f32[3] = 0.0;
  v173.m_broadPhaseAabb.m_max.m_quad.m128_f32[0] = 0.03125 * cm.broadphaseMax.v[0];
  v173.m_broadPhaseAabb.m_max.m_quad.m128_f32[1] = 0.03125 * cm.broadphaseMax.v[1];
  v173.m_broadPhaseAabb.m_max.m_quad.m128_f32[2] = 0.03125 * cm.broadphaseMax.v[2];
  v173.m_broadPhaseAabb.m_max.m_quad.m128_f32[3] = 0.0;
  if ( v173.m_broadPhaseConfig.m_ptr )
    hkReferencedObject::removeReference(v173.m_broadPhaseConfig.m_ptr);
  v173.m_broadPhaseConfig.m_ptr = NULL;
  simulationCollisionFilter = MutableWorld->simulationCollisionFilter;
  if ( simulationCollisionFilter )
    hkReferencedObject::addReference(MutableWorld->simulationCollisionFilter);
  if ( v173.m_collisionFilter.m_ptr )
    hkReferencedObject::removeReference(v173.m_collisionFilter.m_ptr);
  v173.m_collisionFilter.m_ptr = simulationCollisionFilter;
  if ( v173.m_shapeTagCodec.m_ptr )
    hkReferencedObject::removeReference(v173.m_shapeTagCodec.m_ptr);
  v173.m_shapeTagCodec.m_ptr = NULL;
  v173.m_collisionTolerance = 0.03125 * worldCInfo->collisionTolerance;
  v173.m_relativeCollisionAccuracy = worldCInfo->collisionAccuracy;
  v173.m_aabbMargin = 0.03125 * worldCInfo->aabbMargin;
  *(_WORD *)&v173.m_enableWeldingForDefaultObjects.m_bool = 0;
  v173.m_weldingConfig.m_relativeGhostPlaneThreshold = 0.03125 * worldCInfo->relativeGhostPlaneThreshold;
  *(_WORD *)&v173.m_lodManagerCinfo.m_registerDefaultConfig.m_bool = 0;
  v173.m_lodManagerCinfo.m_autoBuildLodOnMeshBodyAdded.m_bool = 0;
  *(_WORD *)&v173.m_enableSdfEdgeCollisions.m_bool = 256;
  v173.m_particlesLandscapeQuadCacheSize = 4096;
  v173.m_solverTau = worldCInfo->solverStrength;
  v173.m_solverDamp = worldCInfo->solverDamping;
  v173.m_solverIterations = worldCInfo->solverIterations;
  v173.m_solverMicrosteps = 1;
  v173.m_maxApproachSpeedForHighQualitySolver = FLOAT_1_0;
  v173.m_enableDeactivation.m_bool = !Physics_IsQueryWorld((Physics_WorldId)v3);
  v173.m_enablePenetrationRecovery.m_bool = !Physics_IsQueryWorld((Physics_WorldId)v3);
  v173.m_maxApproachSpeedForHighQualitySolver = FLOAT_1_0;
  v173.m_adjustSolverSettingsBasedOnTimestep.m_bool = worldCInfo->adjustSolverSettingsOnTimestep;
  v173.m_expectedDeltaTime = MutableWorld->defaultTimeStep;
  v173.m_minSolverIterations = 1;
  v173.m_maxSolverIterations = v173.m_solverIterations;
  v32 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v32 )
    v32 = hkMemoryRouter::s_fallbackRouter;
  v33 = (hknpWorld *)v32->m_heap->blockAlloc(v32->m_heap, 2992i64);
  *(_QWORD *)listenPort = v33;
  if ( v33 )
    hknpWorld::hknpWorld(v33, &v173);
  else
    v34 = NULL;
  MutableWorld->world = v34;
  if ( !v34 )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3242, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics CreateWorld %i: world failed to create", "havokPhysicsWorld->world", levelA) )
      __debugbreak();
  }
  MutableWorld->world->m_userData = v3;
  m_object = MutableWorld->world->m_particlesCollidersManager.m_object->m_particleQueryDispatcher.m_object;
  v36 = 0;
  v37 = 0i64;
  do
  {
    m_baseTypeMap = m_object->m_closestPointsDispatchTable.m_baseTypeMap;
    if ( m_baseTypeMap[v37] == NOP )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&m_object->m_closestPointsDispatchTable, (hknpShapeType::Enum)v36, USER_7|DISTANCE_FIELD, HavokPhysics_Particles_ConvexVsStaticModelTile, "HavokPhysics_Particles_ConvexVsStaticModelTile", 0xFFFFFFFF, 1);
      m_baseTypeMap = m_object->m_closestPointsDispatchTable.m_baseTypeMap;
    }
    if ( m_baseTypeMap[v37] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&m_object->m_closestPointsDispatchTable, NOP, (hknpShapeType::Enum)v36, HavokPhysics_Particles_ConvexVsStaticModelTile, "HavokPhysics_Particles_ConvexVsStaticModelTile", 0xFFFFFFFF, 1);
    ++v36;
    ++v37;
  }
  while ( v36 < 30 );
  m_object->m_closestPointsDispatchTable.m_dispatchTable[0][22] = HavokPhysics_Particles_ConvexVsStaticModelTile;
  v39 = v165->world->m_particlesCollidersManager.m_object->m_particleQueryDispatcher.m_object;
  v40 = 0;
  v41 = 0i64;
  v42 = (__int64)v166;
  do
  {
    v43 = v39->m_closestPointsDispatchTable.m_baseTypeMap;
    if ( v43[v41] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&v39->m_closestPointsDispatchTable, (hknpShapeType::Enum)v40, NOP, HavokPhsyics_Particles_Flip__HavokPhysics_Particles_ConvexVsStaticModelTile_, "HavokPhysics_Particles_Flip<HavokPhysics_Particles_ConvexVsStaticModelTile>", 0xFFFFFFFF, 1);
      v43 = v39->m_closestPointsDispatchTable.m_baseTypeMap;
    }
    if ( v43[v41] == NOP )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&v39->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v40, HavokPhsyics_Particles_Flip__HavokPhysics_Particles_ConvexVsStaticModelTile_, "HavokPhysics_Particles_Flip<HavokPhysics_Particles_ConvexVsStaticModelTile>", 0xFFFFFFFF, 1);
    ++v40;
    ++v41;
  }
  while ( v40 < 30 );
  v39->m_closestPointsDispatchTable.m_dispatchTable[22][0] = HavokPhsyics_Particles_Flip__HavokPhysics_Particles_ConvexVsStaticModelTile_;
  v44 = (__int64)v165;
  hknpWorld::setIWProfileCallbacks(v165->world, HavokPhysics_ProfileStart, HavokPhysics_ProfileEnd);
  UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(*(const hknpWorld **)(v44 + 24));
  UndecoratedBroadPhase->m_world = *(hknpWorld **)(v44 + 24);
  UndecoratedBroadPhase->m_worldId = v3;
  if ( Physics_IsQueryWorld((Physics_WorldId)v3) )
  {
    *(_QWORD *)(v44 + 264) = 0i64;
  }
  else
  {
    v46 = PhysicsGravityModifier_Create((const Physics_WorldId)v3);
    *(_QWORD *)(v44 + 264) = v46;
    v47 = *(_QWORD *)(v44 + 24);
    LODWORD(v167) = 0x10000;
    hknpModifierManager::addModifier(*(hknpModifierManager **)(v47 + 1200), (hknpCollisionFlags)0x10000, v46, PRIORITY_LOWER);
  }
  if ( !*(_QWORD *)(*(_QWORD *)(v44 + 24) + 1568i64) )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3265, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->m_collisionQueryDispatcher)", "%s\n\tHavokPhysics CreateWorld %i: world default collision query dispatcher didn't exist", "havokPhysicsWorld->world->m_collisionQueryDispatcher", levelA) )
      __debugbreak();
  }
  v48 = *(_QWORD *)(*(_QWORD *)(v44 + 24) + 1568i64);
  if ( v48 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v48 + 8i64))(v48, 1i64);
  v49 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v49 )
    v49 = hkMemoryRouter::s_fallbackRouter;
  v50 = (HavokPhysics_CollisionQueryDispatcher *)v49->m_heap->blockAlloc(v49->m_heap, 15080i64);
  *(_QWORD *)listenPort = v50;
  if ( v50 )
  {
    HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher(v50);
    v52 = v51;
  }
  else
  {
    v52 = 0i64;
  }
  *(_QWORD *)(*(_QWORD *)(v44 + 24) + 1568i64) = v52;
  if ( !*(_QWORD *)(*(_QWORD *)(v44 + 24) + 1568i64) )
  {
    LODWORD(levelA) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3268, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->m_collisionQueryDispatcher)", "%s\n\tHavokPhysics CreateWorld %i: world collision query dispatcher failed to create", "havokPhysicsWorld->world->m_collisionQueryDispatcher", levelA) )
      __debugbreak();
  }
  HavokPhysics_AddBodyQualityLibraryToWorld(&s_havokPhysicsBodyQualityLibrary, (Physics_WorldId)v3);
  HavokPhysics_AddMaterialLibraryToWorld(&s_havokPhysicsMaterialLibrary, (Physics_WorldId)v3);
  HavokPhysics_AddMotionPropertiesLibraryToWorld(&s_havokPhysicsMotionPropertiesLibrary, (Physics_WorldId)v3);
  if ( *(_QWORD *)(v44 + 248) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3277, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->bodySFXEventAssets)", (const char *)&queryFormat, "!havokPhysicsWorld->bodySFXEventAssets") )
    __debugbreak();
  v53 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v53 )
    v53 = hkMemoryRouter::s_fallbackRouter;
  v54 = (__int64)v53->m_heap->blockAlloc(v53->m_heap, 16i64);
  v55 = v54;
  *(_QWORD *)listenPort = v54;
  if ( v54 )
  {
    v56 = *(_DWORD *)(v42 + 4);
    *(_QWORD *)v54 = 0i64;
    *(_DWORD *)(v54 + 8) = 0;
    *(_DWORD *)(v54 + 12) = 0x80000000;
    v161 = v56;
    v57 = hkMemHeapAllocator();
    v58 = v161;
    v59 = v161;
    if ( v161 )
    {
      v60 = hkMemoryAllocator::bufAlloc2(v57, 8, &v161);
      v58 = v161;
    }
    else
    {
      v60 = NULL;
    }
    v61 = 0x80000000;
    if ( v58 )
      v61 = v58;
    *(_QWORD *)v55 = v60;
    *(_DWORD *)(v55 + 8) = v59;
    *(_DWORD *)(v55 + 12) = v61;
  }
  else
  {
    v55 = 0i64;
  }
  *(_QWORD *)(v44 + 248) = v55;
  if ( *(_QWORD *)(v44 + 256) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3279, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->bodyVFXEventAssets)", (const char *)&queryFormat, "!havokPhysicsWorld->bodyVFXEventAssets") )
    __debugbreak();
  v62 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v62 )
    v62 = hkMemoryRouter::s_fallbackRouter;
  v63 = (__int64)v62->m_heap->blockAlloc(v62->m_heap, 16i64);
  v64 = v63;
  *(_QWORD *)listenPort = v63;
  if ( v63 )
  {
    v65 = *(_DWORD *)(v42 + 4);
    *(_QWORD *)v63 = 0i64;
    *(_DWORD *)(v63 + 8) = 0;
    *(_DWORD *)(v63 + 12) = 0x80000000;
    v162 = v65;
    v66 = hkMemHeapAllocator();
    v67 = v162;
    v68 = v162;
    if ( v162 )
    {
      v69 = hkMemoryAllocator::bufAlloc2(v66, 8, &v162);
      v67 = v162;
    }
    else
    {
      v69 = NULL;
    }
    v70 = 0x80000000;
    if ( v67 )
      v70 = v67;
    *(_QWORD *)v64 = v69;
    *(_DWORD *)(v64 + 8) = v68;
    *(_DWORD *)(v64 + 12) = v70;
  }
  else
  {
    v64 = 0i64;
  }
  *(_QWORD *)(v44 + 256) = v64;
  *(_DWORD *)(v44 + 272) = 0;
  v71 = 296i64;
  v72 = 2i64;
  do
  {
    if ( *(_QWORD *)(v71 + v44 - 16) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3287, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx]") )
      __debugbreak();
    v73 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v73 )
      v73 = hkMemoryRouter::s_fallbackRouter;
    v74 = (__int64)v73->m_heap->blockAlloc(v73->m_heap, 16i64);
    if ( v74 )
    {
      *(_QWORD *)v74 = 0i64;
      *(_DWORD *)(v74 + 8) = 0;
      *(_DWORD *)(v74 + 12) = 0x80000000;
    }
    else
    {
      v74 = 0i64;
    }
    *(_QWORD *)(v71 + v44 - 16) = v74;
    if ( *(_QWORD *)(v71 + v44) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3290, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->aabbQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->aabbQueryRequestLists[bufferIdx]") )
      __debugbreak();
    v75 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v75 )
      v75 = hkMemoryRouter::s_fallbackRouter;
    v76 = (__int64)v75->m_heap->blockAlloc(v75->m_heap, 16i64);
    if ( v76 )
    {
      *(_QWORD *)v76 = 0i64;
      *(_DWORD *)(v76 + 8) = 0;
      *(_DWORD *)(v76 + 12) = 0x80000000;
    }
    else
    {
      v76 = 0i64;
    }
    *(_QWORD *)(v71 + v44) = v76;
    if ( *(_QWORD *)(v71 + v44 + 16) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3293, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->raycastRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->raycastRequestLists[bufferIdx]") )
      __debugbreak();
    v77 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v77 )
      v77 = hkMemoryRouter::s_fallbackRouter;
    v78 = (__int64)v77->m_heap->blockAlloc(v77->m_heap, 16i64);
    if ( v78 )
    {
      *(_QWORD *)v78 = 0i64;
      *(_DWORD *)(v78 + 8) = 0;
      *(_DWORD *)(v78 + 12) = 0x80000000;
    }
    else
    {
      v78 = 0i64;
    }
    *(_QWORD *)(v71 + v44 + 16) = v78;
    if ( *(_QWORD *)(v71 + v44 + 32) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3296, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->shapecastRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->shapecastRequestLists[bufferIdx]") )
      __debugbreak();
    v79 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v79 )
      v79 = hkMemoryRouter::s_fallbackRouter;
    v80 = (__int64)v79->m_heap->blockAlloc(v79->m_heap, 16i64);
    if ( v80 )
    {
      *(_QWORD *)v80 = 0i64;
      *(_DWORD *)(v80 + 8) = 0;
      *(_DWORD *)(v80 + 12) = 0x80000000;
    }
    else
    {
      v80 = 0i64;
    }
    *(_QWORD *)(v71 + v44 + 32) = v80;
    if ( *(_QWORD *)(v71 + v44 + 48) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3299, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->queryPointRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->queryPointRequestLists[bufferIdx]") )
      __debugbreak();
    v81 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v81 )
      v81 = hkMemoryRouter::s_fallbackRouter;
    v82 = (__int64)v81->m_heap->blockAlloc(v81->m_heap, 16i64);
    if ( v82 )
    {
      *(_QWORD *)v82 = 0i64;
      *(_DWORD *)(v82 + 8) = 0;
      *(_DWORD *)(v82 + 12) = 0x80000000;
    }
    else
    {
      v82 = 0i64;
    }
    *(_QWORD *)(v71 + v44 + 48) = v82;
    if ( *(_QWORD *)(v71 + v44 + 64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3302, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx])", (const char *)&queryFormat, "!havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx]") )
      __debugbreak();
    v83 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v83 )
      v83 = hkMemoryRouter::s_fallbackRouter;
    v84 = (__int64)v83->m_heap->blockAlloc(v83->m_heap, 16i64);
    if ( v84 )
    {
      *(_QWORD *)v84 = 0i64;
      *(_DWORD *)(v84 + 8) = 0;
      *(_DWORD *)(v84 + 12) = 0x80000000;
    }
    else
    {
      v84 = 0i64;
    }
    *(_QWORD *)(v71 + v44 + 64) = v84;
    v71 += 8i64;
    --v72;
  }
  while ( v72 );
  v85 = shapeSizeOut;
  v86 = (__int64)v166;
  if ( *(_QWORD *)(v44 + 416) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3306, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->capsuleRadii)", (const char *)&queryFormat, "!havokPhysicsWorld->capsuleRadii") )
    __debugbreak();
  v87 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v87 )
    v87 = hkMemoryRouter::s_fallbackRouter;
  v88 = (__int64)v87->m_heap->blockAlloc(v87->m_heap, 16i64);
  *(_QWORD *)listenPort = v88;
  if ( v88 )
  {
    *(_QWORD *)v88 = 0i64;
    *(_DWORD *)(v88 + 8) = 0;
    *(_DWORD *)(v88 + 12) = -1;
  }
  else
  {
    v88 = 0i64;
  }
  *(_QWORD *)(v44 + 416) = v88;
  if ( *(_QWORD *)(v44 + 424) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3309, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredKeyframeInstanceEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredKeyframeInstanceEntries") )
    __debugbreak();
  v89 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v89 )
    v89 = hkMemoryRouter::s_fallbackRouter;
  v90 = (__int64)v89->m_heap->blockAlloc(v89->m_heap, 16i64);
  if ( v90 )
  {
    *(_QWORD *)v90 = 0i64;
    *(_DWORD *)(v90 + 8) = 0;
    *(_DWORD *)(v90 + 12) = 0x80000000;
  }
  else
  {
    v90 = 0i64;
  }
  *(_QWORD *)(v44 + 424) = v90;
  if ( *(_QWORD *)(v44 + 432) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3312, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredBulletForceEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredBulletForceEntries") )
    __debugbreak();
  v91 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v91 )
    v91 = hkMemoryRouter::s_fallbackRouter;
  v92 = (__int64)v91->m_heap->blockAlloc(v91->m_heap, 16i64);
  if ( v92 )
  {
    *(_QWORD *)v92 = 0i64;
    *(_DWORD *)(v92 + 8) = 0;
    *(_DWORD *)(v92 + 12) = 0x80000000;
  }
  else
  {
    v92 = 0i64;
  }
  *(_QWORD *)(v44 + 432) = v92;
  if ( *(_QWORD *)(v44 + 440) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3315, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  v93 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v93 )
    v93 = hkMemoryRouter::s_fallbackRouter;
  v94 = (__int64)v93->m_heap->blockAlloc(v93->m_heap, 16i64);
  if ( v94 )
  {
    *(_QWORD *)v94 = 0i64;
    *(_DWORD *)(v94 + 8) = 0;
    *(_DWORD *)(v94 + 12) = 0x80000000;
  }
  else
  {
    v94 = 0i64;
  }
  *(_QWORD *)(v44 + 440) = v94;
  if ( *(_QWORD *)(v44 + 448) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3318, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->m_deferredBulletEffectEntries)", (const char *)&queryFormat, "!havokPhysicsWorld->m_deferredBulletEffectEntries") )
    __debugbreak();
  v95 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v95 )
    v95 = hkMemoryRouter::s_fallbackRouter;
  v96 = (__int64)v95->m_heap->blockAlloc(v95->m_heap, 16i64);
  if ( v96 )
  {
    *(_QWORD *)v96 = 0i64;
    *(_DWORD *)(v96 + 8) = 0;
    *(_DWORD *)(v96 + 12) = 0x80000000;
  }
  else
  {
    v96 = 0i64;
  }
  *(_QWORD *)(v44 + 448) = v96;
  *(_DWORD *)(v44 + 456) = 0;
  v97 = (_DWORD *)(v44 + 1704);
  v98 = 300i64;
  do
  {
    *(v97 - 300) = 0;
    *v97++ = 0;
    --v98;
  }
  while ( v98 );
  *(_DWORD *)(v44 + 2908) = 0;
  *(_QWORD *)(v44 + 2912) = 0i64;
  *(_QWORD *)(v44 + 2920) = 0i64;
  *(_QWORD *)(v44 + 2928) = 0i64;
  *(_QWORD *)(v44 + 2936) = 0i64;
  *(_QWORD *)(v44 + 2944) = 0i64;
  *(_QWORD *)(v44 + 2952) = 0i64;
  *(_DWORD *)(v44 + 2960) = 0;
  if ( *(_QWORD *)(v44 + 3192) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3336, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "!havokPhysicsWorld->debugLines") )
    __debugbreak();
  v99 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v99 )
    v99 = hkMemoryRouter::s_fallbackRouter;
  v100 = (__int64)v99->m_heap->blockAlloc(v99->m_heap, 16i64);
  if ( v100 )
  {
    *(_QWORD *)v100 = 0i64;
    *(_DWORD *)(v100 + 8) = 0;
    *(_DWORD *)(v100 + 12) = 0x80000000;
  }
  else
  {
    v100 = 0i64;
  }
  *(_QWORD *)(v44 + 3192) = v100;
  if ( !v100 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3338, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  v101 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v101 )
    v101 = hkMemoryRouter::s_fallbackRouter;
  v102 = (__int64)v101->m_heap->blockAlloc(v101->m_heap, 568i64);
  if ( v102 )
  {
    *(_DWORD *)(v102 + 20) = 0;
    memset_0((void *)(v102 + 48), 0, 0x208ui64);
    *(_QWORD *)(v102 + 8) = 0i64;
    *(_DWORD *)(v102 + 16) = 0x1FFFF;
    *(_QWORD *)(v102 + 32) = 0i64;
    *(_QWORD *)v102 = &hkCommonProcessContext::`vftable'{for `hkReferencedObject'};
    *(_QWORD *)(v102 + 24) = &hkCommonProcessContext::`vftable'{for `hkProcessContext'};
    *(_QWORD *)(v102 + 40) = v102 + 56;
    *(_DWORD *)(v102 + 48) = 0;
    *(_DWORD *)(v102 + 52) = -2147483616;
  }
  else
  {
    v102 = 0i64;
  }
  *(_QWORD *)(v44 + 480) = v102;
  v103 = (hkProcessContext *)(v102 + 24);
  if ( !v102 )
    v103 = NULL;
  v104 = hkMemHeapAllocator();
  m_size = array.m_size;
  if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v104, &array, 8);
    m_size = array.m_size;
  }
  array.m_data[m_size] = v103;
  ++array.m_size;
  v106 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v106 )
    v106 = hkMemoryRouter::s_fallbackRouter;
  v107 = (hknpProcessContext *)v106->m_heap->blockAlloc(v106->m_heap, 128i64);
  *(_QWORD *)listenPort = v107;
  if ( v107 )
    hknpProcessContext::hknpProcessContext(v107);
  else
    v108 = 0i64;
  *(_QWORD *)(v44 + 472) = v108;
  if ( !v108 )
  {
    LODWORD(levelA) = v85;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3346, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics CreateWorld %i: Visualization Context failed to create", "havokPhysicsWorld->visContext", levelA) )
      __debugbreak();
  }
  hknpProcessContext::registerAllProcesses();
  m_ptr = hkProcessFactory::singleton.m_ptr;
  hknpBodyIdViewer::registerViewer(hkProcessFactory::singleton.m_ptr);
  hknpMotionIdViewer::registerViewer(m_ptr);
  HavokPhysicsCollisionHeatmapViewer::registerViewer(m_ptr);
  HavokPhysicsDebugDrawViewer::registerViewer(m_ptr);
  HavokPhysicsCollisionTileViewer::registerViewer(m_ptr);
  HavokPhysicsShapeViewer::registerViewer(m_ptr);
  v110 = *(_QWORD *)(v44 + 472);
  v111 = (hkProcessContext *)(v110 + 24);
  if ( !v110 )
    v111 = NULL;
  v112 = hkMemHeapAllocator();
  v113 = array.m_size;
  if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v112, &array, 8);
    v113 = array.m_size;
  }
  array.m_data[v113] = v111;
  ++array.m_size;
  if ( *(_BYTE *)(v86 + 71) )
  {
    v114 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v114 )
      v114 = hkMemoryRouter::s_fallbackRouter;
    v115 = (hclClothContext *)v114->m_heap->blockAlloc(v114->m_heap, 416i64);
    *(_QWORD *)listenPort = v115;
    if ( v115 )
      hclClothContext::hclClothContext(v115);
    else
      v116 = 0i64;
    *(_QWORD *)(v44 + 488) = v116;
    if ( !v116 )
    {
      LODWORD(levelA) = v85;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3360, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->clothVisContext)", "%s\n\tHavokPhysics CreateWorld %i: Cloth Visualization Context failed to create", "havokPhysicsWorld->clothVisContext", levelA) )
        __debugbreak();
    }
    hclClothContext::registerAllClothProcesses();
    v117 = *(_QWORD *)(v44 + 488);
    v118 = (hkProcessContext *)(v117 + 24);
    if ( !v117 )
      v118 = NULL;
    v119 = hkMemHeapAllocator();
    v120 = array.m_size;
    if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v119, &array, 8);
      v120 = array.m_size;
    }
    array.m_data[v120] = v118;
    ++array.m_size;
  }
  hknpProcessContext::addWorld(*(hknpProcessContext **)(v44 + 472), *(hknpWorld **)(v44 + 24));
  v121 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v121 )
    v121 = hkMemoryRouter::s_fallbackRouter;
  v122 = (hkVisualDebugger *)v121->m_heap->blockAlloc(v121->m_heap, 240i64);
  *(_QWORD *)listenPort = v122;
  if ( v122 )
    hkVisualDebugger::hkVisualDebugger(v122, &array, NULL);
  else
    v123 = 0i64;
  *(_QWORD *)(v44 + 496) = v123;
  if ( !v123 )
  {
    LODWORD(levelA) = v85;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3370, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics CreateWorld %i: VDB Server failed to create", "havokPhysicsWorld->vdbServer", levelA) )
      __debugbreak();
  }
  hkVisualDebugger::clearDefaultAndRequiredProcesses(*(hkVisualDebugger **)(v44 + 496));
  hkVisualDebugger::addDefaultProcess(*(hkVisualDebugger **)(v44 + 496), "Physics/Rigid Bodies/Shapes");
  if ( ((unsigned __int8)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedIncrement(&s_errorPrintWarningOnly);
  hkVisualDebugger::serve(*(hkVisualDebugger **)(v44 + 496), (int)listenPort, v85 + 25001, (const char *)0x3A99, 0);
  if ( ((unsigned __int64)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedDecrement(&s_errorPrintWarningOnly);
  v124 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v124 )
    v124 = hkMemoryRouter::s_fallbackRouter;
  v125 = (__int64)v124->m_heap->blockAlloc(v124->m_heap, 16i64);
  if ( v125 )
  {
    *(_QWORD *)v125 = 0i64;
    *(_DWORD *)(v125 + 8) = 0;
    *(_DWORD *)(v125 + 12) = 0x80000000;
  }
  else
  {
    v125 = 0i64;
  }
  *(_QWORD *)(v44 + 2968) = v125;
  if ( !v125 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3379, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->monitorStreams)", (const char *)&queryFormat, "havokPhysicsWorld->monitorStreams") )
    __debugbreak();
  *(_QWORD *)listenPort = v44 + 2976;
  if ( v44 == -2976 )
    v126 = 0i64;
  else
    HavokPhysicsDisplayHandler::HavokPhysicsDisplayHandler((HavokPhysicsDisplayHandler *)(v44 + 2976), (Physics_WorldId)v85);
  *(_QWORD *)(v44 + 3144) = v126;
  v127 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v127 )
    v127 = hkMemoryRouter::s_fallbackRouter;
  v128 = (hkServerObjectSerializer *)v127->m_heap->blockAlloc(v127->m_heap, 192i64);
  *(_QWORD *)listenPort = v128;
  if ( v128 )
    hkServerObjectSerializer::hkServerObjectSerializer(v128, NULL, NULL, NULL);
  else
    v129 = 0i64;
  *(_QWORD *)(v44 + 3152) = v129;
  v130 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v130 )
    v130 = hkMemoryRouter::s_fallbackRouter;
  v131 = (hkServerObjectHandler *)v130->m_heap->blockAlloc(v130->m_heap, 112i64);
  *(_QWORD *)listenPort = v131;
  if ( v131 )
    hkServerObjectHandler::hkServerObjectHandler(v131, *(hkServerObjectSerializer **)(v44 + 3152));
  else
    v132 = 0i64;
  *(_QWORD *)(v44 + 3160) = v132;
  v133 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v133 )
    v133 = hkMemoryRouter::s_fallbackRouter;
  v134 = (HavokPhysicsProcessHandler *)v133->m_heap->blockAlloc(v133->m_heap, 48i64);
  *(_QWORD *)listenPort = v134;
  if ( v134 )
    HavokPhysicsProcessHandler::HavokPhysicsProcessHandler(v134, *(hclClothContext **)(v44 + 488), *(hkDebugDisplayHandler **)(v44 + 3144));
  else
    v135 = 0i64;
  *(_QWORD *)(v44 + 3168) = v135;
  v136 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v136 )
    v136 = hkMemoryRouter::s_fallbackRouter;
  v137 = (__int64)v136->m_heap->blockAlloc(v136->m_heap, 24i64);
  if ( v137 )
  {
    *(_QWORD *)v137 = 0i64;
    *(_DWORD *)(v137 + 8) = 0;
    *(_DWORD *)(v137 + 12) = 0x80000000;
    *(_DWORD *)(v137 + 16) = 0;
  }
  else
  {
    v137 = 0i64;
  }
  *(_QWORD *)(v44 + 3200) = v137;
  center.m_quad = 0i64;
  *(_DWORD *)(v44 + 3208) = 0;
  *(_WORD *)(v44 + 3212) = 0;
  v138 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
  *(_QWORD *)listenPort = v138;
  v167 = v138;
  if ( v138 )
  {
    hknpSphereShape::hknpSphereShape(v138, &center, 0.375);
    v140 = v139;
  }
  else
  {
    v140 = 0i64;
  }
  *(_WORD *)(v140 + 16) = shapeSizeOut;
  v141 = *(float *)(v140 + 32);
  if ( v141 != 0.375 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", v141, DOUBLE_0_375) )
    __debugbreak();
  *(_QWORD *)(v44 + 3416) = v140;
  v142 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &v164);
  *(_QWORD *)listenPort = v142;
  v167 = v142;
  if ( v142 )
  {
    hknpSphereShape::hknpSphereShape(v142, &center, 0.375);
    v144 = v143;
  }
  else
  {
    v144 = 0i64;
  }
  *(_WORD *)(v144 + 16) = v164;
  v145 = *(float *)(v144 + 32);
  if ( v145 != 0.375 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", v145, DOUBLE_0_375) )
    __debugbreak();
  *(_QWORD *)(v44 + 3592) = v144;
  s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v85] = -1;
  s_havokPhysicsWorldAABBQueryActiveIndices[v85] = -1;
  s_havokPhysicsWorldRayActiveIndices[v85] = -1;
  s_havokPhysicsWorldRayDetailActiveIndices[v85] = -1;
  s_havokPhysicsWorldShapeCastActiveIndices[v85] = -1;
  s_havokPhysicsWorldQueryPointActiveIndices[v85] = -1;
  s_havokPhysicsWorldGetClosestPointsActiveIndices[v85] = -1;
  for ( i = 0; i < 2; ++i )
  {
    v147 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v147 )
      v147 = hkMemoryRouter::s_fallbackRouter;
    v148 = (__int64)v147->m_heap->blockAlloc(v147->m_heap, 48i64);
    v149 = v148;
    if ( v148 )
    {
      *(_QWORD *)(v148 + 8) = 0i64;
      *(_DWORD *)(v148 + 16) = 0x1FFFF;
      *(_QWORD *)v148 = &HavokPhysics_BroadphaseCollisionQueryResult::`vftable';
      *(_QWORD *)(v148 + 24) = 0i64;
      *(_DWORD *)(v148 + 32) = 0;
      *(_DWORD *)(v148 + 36) = 0x80000000;
    }
    else
    {
      v149 = 0i64;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13561, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
        __debugbreak();
    }
    *(_DWORD *)(v149 + 40) = v85;
    s_havokPhysicsWorldAABBBroadphaseQueryData[(int)(i + 2 * v85)].result = (HavokPhysics_BroadphaseCollisionQueryResult *)v149;
    s_havokPhysicsWorldAABBQueryData[(int)(i + 2 * v85)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v85, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
    s_havokPhysicsWorldRayData[(int)(i + 2 * v85)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v85, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST);
    s_havokPhysicsWorldRayDetailData[(int)(i + 2 * v85)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v85, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST);
    WeaponPriorityMap = BG_GetWeaponPriorityMap(&NULL_WEAPON, 0);
    HavokPhysics_AddDetailTrace(s_havokPhysicsWorldRayDetailData[(int)(i + 2 * v85)].result, WeaponPriorityMap);
    s_havokPhysicsWorldShapeCastData[(int)(i + 2 * v85)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v85, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_CLOSEST);
    s_havokPhysicsWorldShapeCastData[(int)(i + 2 * v85)].startResult = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v85, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
    s_havokPhysicsWorldQueryPointData[(int)(i + 2 * v85)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v85, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
    s_havokPhysicsWorldGetClosestPointsData[(int)(i + 2 * v85)].result = HavokPhysics_AllocateCollisionQueryResult((Physics_WorldId)v85, PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL);
  }
  v151 = (__int64)v165;
  v152 = (__int64)v166;
  if ( (unsigned int)v85 > 7 )
  {
    LODWORD(levelA) = v85;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 0x4000, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to SubscribeToEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", levelA) )
      __debugbreak();
  }
  v153 = HavokPhysics_GetMutableWorld((Physics_WorldId)v85);
  if ( !v153->world )
  {
    LODWORD(levelA) = v85;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16388, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics SubscribeToEvent %i: world is NULL", "physicsWorld->world", levelA) )
      __debugbreak();
  }
  EventSignal = hknpWorld::getEventSignal(v153->world, BODY_EXITED_BROAD_PHASE, (hknpBodyId)0xFFFFFF);
  hkSignal2<hknpEventHandlerInput const &,hknpEvent const &>::subscribe<void (*)(hknpEventHandlerInput const &,hknpEvent const &)>(EventSignal, HavokPhysics_LeftBroadphase, "Left-Broadphase");
  if ( (unsigned int)v85 > 7 )
  {
    LODWORD(levelA) = v85;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11240, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Setup codec with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", levelA) )
      __debugbreak();
  }
  v155 = HavokPhysics_GetMutableWorld((Physics_WorldId)v85);
  p_critSection = &v155->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&v155->critSection);
  if ( !v155->world )
  {
    LODWORD(levelA) = v85;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11246, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetupCodec %i: world is NULL", "havokPhysicsWorld->world", levelA) )
      __debugbreak();
  }
  v155->world->setShapeTagCodec(&v155->world->hknpWorldWriter, s_shapeTagCodec);
  LeaveCriticalSection((LPCRITICAL_SECTION)&v155->critSection);
  *(_QWORD *)(v151 + 3792) = *(int *)(v152 + 24);
  hknpWorldCinfo::~hknpWorldCinfo(&v173);
  LeaveCriticalSection(lpCriticalSection);
  v156 = hkMemHeapAllocator();
  array.m_size = 0;
  if ( array.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v156, array.m_data, 8, array.m_capacityAndFlags & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DeactivateBody
==============
*/
void HavokPhysics_DeactivateBody(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13195, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to deactivate a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13196, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to deactivate a body with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationState)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
}

/*
==============
HavokPhysics_DebugSetVisualizeContents
==============
*/
void HavokPhysics_DebugSetVisualizeContents(int visualizeContents)
{
  HavokPhysicsShapeViewer::ms_contents = visualizeContents;
}

/*
==============
HavokPhysics_DebugSetVisualizeQuery
==============
*/
void HavokPhysics_DebugSetVisualizeQuery(bool showQueryBodies)
{
  HavokPhysicsShapeViewer::ms_ignoreQuery = !showQueryBodies;
}

/*
==============
HavokPhysics_DebugXModelGetIndex
==============
*/
__int64 HavokPhysics_DebugXModelGetIndex(XModel *xmodel)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v1; 
  __int64 m_size; 
  unsigned int v4; 
  XModel **m_data; 
  __int64 v6; 
  __int64 v7; 

  v1 = s_havokPhysicsXModels;
  if ( !s_havokPhysicsXModels )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7757, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
      __debugbreak();
    v1 = s_havokPhysicsXModels;
  }
  m_size = v1->m_size;
  v4 = 0;
  if ( (int)m_size <= 0 )
    return 0xFFFFFFFFi64;
  m_data = (XModel **)v1->m_data;
  v6 = m_size;
  v7 = 0i64;
  while ( *m_data != xmodel )
  {
    ++v4;
    ++v7;
    ++m_data;
    if ( v7 >= v6 )
      return 0xFFFFFFFFi64;
  }
  return v4;
}

/*
==============
HavokPhysics_DecodeShapeKeyIntoShapes
==============
*/
__int64 HavokPhysics_DecodeShapeKeyIntoShapes(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> key, const hknpShape **shapes)
{
  unsigned int v7; 
  const HavokPhysicsWorld *ConstWorld; 
  hkMatrix3Impl<float> *v10; 
  unsigned __int64 v11; 
  unsigned int v12; 
  const hknpShape **p_m_shape; 
  __int64 m_size; 
  float zero; 
  __int64 v27; 
  hknpShapeCollector v28; 
  hknpInplaceTriangleShape v29; 
  unsigned int m_value; 

  m_value = key.m_value;
  v27 = -2i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16191, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DecodeShapeKeyIntoShapes with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  v7 = 0;
  if ( m_value == -1 )
    return 0i64;
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v10 = (hkMatrix3Impl<float> *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v11 = v10[2].m_col0.m_quad.m128_u64[0];
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v29, 0.015);
  v28.m_internal.m_shapeBuffer.m_shape = NULL;
  v28.m_internal.m_shapeBuffer.m_buffer = v28.m_internal.m_shapeBuffer.m_storage;
  v28.m_internal.m_shapeBuffer.m_bufferSize = 2048;
  v28.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
  *(__m256i *)v28.m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
  *(__m256i *)v28.m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
  v28.m_internal.m_scale.m_quad = g_vectorfConstants[6];
  v28.m_internal.m_shapeTags[0] = -1;
  v28.m_internal.m_shape = NULL;
  v28.m_parentShape = NULL;
  v28.m_shapeTagPath.m_size = 0;
  *(_QWORD *)&v28.m_internal.m_flags.m_storage = 8i64;
  v28.m_transform.m_rotation.m_col0 = v10->m_col0;
  v28.m_transform.m_rotation.m_col1 = v10->m_col1;
  v28.m_transform.m_rotation.m_col2 = v10->m_col2;
  v28.m_transform.m_translation = v10[1].m_col0;
  zero = FLOAT_1_1920929eN7;
  if ( hkMatrix3Impl<float>::isApproximatelyEqual(v10, (const hkMatrix3Impl<float> *)&g_vectorfConstants[32], &zero) )
  {
    v12 = v28.m_internal.m_flags.m_storage | 4;
    v28.m_internal.m_flags.m_storage |= 4u;
    _XMM0 = v10[1].m_col0.m_quad;
    _mm128_sub_ps(_XMM0, g_vectorfConstants[5]);
    _XMM1 = *(_OWORD *)hkMath::hkSse_signMask;
    __asm
    {
      vandnps xmm3, xmm1, xmm2
      vcmpleps xmm4, xmm3, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
    }
    _XMM2 = 0i64;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vpcmpeqd xmm1, xmm0, xmm0
      vblendps xmm2, xmm2, xmm1, 7
      vpand   xmm0, xmm4, xmm2
      vptest  xmm0, xmm2
    }
    if ( _CF )
      v28.m_internal.m_flags.m_storage = v12 | 1;
  }
  v28.m_internal.m_shapeTags[0] = -1;
  (*(void (__fastcall **)(unsigned __int64, unsigned int *, __int64, hknpShapeCollector *))(*(_QWORD *)v11 + 176i64))(v11, &m_value, 1i64, &v28);
  if ( (v28.m_internal.m_flags.m_storage & 0x10) != 0 )
    hknpShapeCollector::getTriangleShape(&v28, 0, (hknpTriangleShape *)&v29);
  if ( v28.m_shapeTagPath.m_size > 0 )
  {
    p_m_shape = &v28.m_shapeTagPath.m_data[0].m_shape;
    m_size = (unsigned int)v28.m_shapeTagPath.m_size;
    do
    {
      if ( v7 < 8 )
        shapes[v7++] = *p_m_shape;
      p_m_shape += 4;
      --m_size;
    }
    while ( m_size );
  }
  v28.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
  if ( v28.m_internal.m_shapeBuffer.m_shape )
    ((void (__fastcall *)(hknpShape *, _QWORD))v28.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v28.m_internal.m_shapeBuffer.m_shape, 0i64);
  return v7;
}

/*
==============
HavokPhysics_DecodeSubShapeKey
==============
*/
void HavokPhysics_DecodeSubShapeKey(Physics_WorldId worldId, unsigned int instanceId, unsigned __int64 key, int *bodyIdx, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> *shapeInstanceId)
{
  HavokPhysicsWorld *MutableWorld; 
  const PhysicsAsset *PhysicsAsset; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hkHashMapDetail::Entry *Entry; 
  __int64 idx; 
  int m_1; 
  unsigned __int64 item; 

  item = key;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16158, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics EnableShapeInstance %i: world is NULL", "havokPhysicsWorld->world", worldId) )
    __debugbreak();
  *bodyIdx = -1;
  PhysicsAsset = HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId);
  if ( PhysicsAsset )
  {
    HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(PhysicsAsset);
    if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16172, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
      __debugbreak();
    Entry = hkHashBase<hkHashMapDetail::MapTuple<unsigned __int64,int>>::_findEntry(&HavokPhysicsAsset->m_mutableShapeLookup, &item);
    if ( Entry )
    {
      idx = Entry->idx;
      if ( (int)idx >= 0 )
      {
        m_1 = HavokPhysicsAsset->m_mutableShapeLookup.m_items.m_data[idx].m_1;
        *bodyIdx = m_1 >> 16;
        shapeInstanceId->m_value = m_1;
      }
    }
  }
}

/*
==============
HavokPhysics_DeferredAABBBroadphaseQuery
==============
*/
void HavokPhysics_DeferredAABBBroadphaseQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBBroadphaseQueryExtendedData *extendedData, Physics_DeferredBroadphaseCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_AABBBroadphaseQueryRequest,hkContainerHeapAllocator> *v10; 
  hkMemoryAllocator *v11; 
  int m_size; 
  int v13; 
  HavokPhysics_AABBBroadphaseQueryRequest *m_data; 
  __int64 v15; 
  HavokPhysics_AABBBroadphaseQueryRequest *v16; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13721, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13722, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred aabb broadphase query with invalid data", "data") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13723, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred aabb broadphase query with invalid extended data", "extendedData") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v10 = MutableWorld->aabbBroadphaseQueryRequestLists[1 - MutableWorld->activeQueryRequestList];
  v11 = hkMemHeapAllocator();
  m_size = v10->m_size;
  v13 = m_size;
  if ( m_size == (v10->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v11, v10, 64);
    m_size = v10->m_size;
    v13 = m_size;
  }
  m_data = v10->m_data;
  v15 = (__int64)&v10->m_data[(__int64)m_size];
  if ( v15 )
  {
    *(_DWORD *)(v15 + 32) = -1;
    *(_QWORD *)(v15 + 40) = 0i64;
    *(_DWORD *)(v15 + 48) = 0;
    v13 = v10->m_size;
    m_data = v10->m_data;
  }
  v16 = &m_data[(__int64)v13];
  v10->m_size = v13 + 1;
  v16->aabb.m_min = aabb->m_min;
  v16->aabb.m_max = aabb->m_max;
  *(_OWORD *)&v16->extendedData.contents = *(_OWORD *)&extendedData->contents;
  *(double *)&v16->extendedData.phaseSelection = *(double *)&extendedData->phaseSelection;
  v16->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/
void HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, hknpBodyId bodyId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_AABBQueryRequest,hkContainerHeapAllocator> *v11; 
  hkMemoryAllocator *v12; 
  int m_size; 
  int v14; 
  HavokPhysics_AABBQueryRequest *m_data; 
  __int64 v16; 
  HavokPhysics_AABBQueryRequest *v17; 
  __int64 v18; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14536, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v18) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14537, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid body id %i", "bodyId.isValid()", v18) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14538, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14539, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14540, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with simplify - not currently supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14541, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v11 = MutableWorld->aabbQueryRequestLists[1 - MutableWorld->activeQueryRequestList];
  v12 = hkMemHeapAllocator();
  m_size = v11->m_size;
  v14 = m_size;
  if ( m_size == (v11->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v12, v11, 80);
    m_size = v11->m_size;
    v14 = m_size;
  }
  m_data = v11->m_data;
  v16 = (__int64)&v11->m_data[m_size];
  if ( v16 )
  {
    *(_DWORD *)(v16 + 48) = -1;
    *(_BYTE *)(v16 + 52) = 0;
    *(_QWORD *)(v16 + 56) = 0i64;
    *(_QWORD *)(v16 + 64) = 0i64;
    v14 = v11->m_size;
    m_data = v11->m_data;
  }
  v17 = &m_data[v14];
  v11->m_size = v14 + 1;
  v17->bodyId = bodyId;
  v17->aabb.m_min = aabb->m_min;
  v17->aabb.m_max = aabb->m_max;
  *(_OWORD *)&v17->extendedData.contents = *(_OWORD *)&extendedData->contents;
  *(double *)&v17->extendedData.collisionBuffer = *(double *)&extendedData->collisionBuffer;
  v17->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredAABBQuery
==============
*/
void HavokPhysics_DeferredAABBQuery(Physics_WorldId worldId, const hkAabb *aabb, Physics_AABBQueryExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_AABBQueryRequest,hkContainerHeapAllocator> *v10; 
  hkMemoryAllocator *v11; 
  int m_size; 
  int v13; 
  HavokPhysics_AABBQueryRequest *m_data; 
  __int64 v15; 
  HavokPhysics_AABBQueryRequest *v16; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13789, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13790, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13791, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred aabb query with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v10 = MutableWorld->aabbQueryRequestLists[1 - MutableWorld->activeQueryRequestList];
  v11 = hkMemHeapAllocator();
  m_size = v10->m_size;
  v13 = m_size;
  if ( m_size == (v10->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v11, v10, 80);
    m_size = v10->m_size;
    v13 = m_size;
  }
  m_data = v10->m_data;
  v15 = (__int64)&v10->m_data[m_size];
  if ( v15 )
  {
    *(_DWORD *)(v15 + 48) = -1;
    *(_BYTE *)(v15 + 52) = 0;
    *(_QWORD *)(v15 + 56) = 0i64;
    *(_QWORD *)(v15 + 64) = 0i64;
    v13 = v10->m_size;
    m_data = v10->m_data;
  }
  v16 = &m_data[v13];
  v10->m_size = v13 + 1;
  v16->bodyId.m_serialAndIndex = 0xFFFFFF;
  v16->aabb.m_min = aabb->m_min;
  v16->aabb.m_max = aabb->m_max;
  *(_OWORD *)&v16->extendedData.contents = *(_OWORD *)&extendedData->contents;
  *(double *)&v16->extendedData.collisionBuffer = *(double *)&extendedData->collisionBuffer;
  v16->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/
void HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_GetClosestPointsRequest,hkContainerHeapAllocator> *v12; 
  hkMemoryAllocator *v13; 
  int m_size; 
  int v15; 
  HavokPhysics_GetClosestPointsRequest *m_data; 
  __int64 v17; 
  HavokPhysics_GetClosestPointsRequest *v18; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14393, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14394, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14395, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14396, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v12 = MutableWorld->getClosestPointsRequestLists[1 - MutableWorld->activeQueryRequestList];
  v13 = hkMemHeapAllocator();
  m_size = v12->m_size;
  v15 = m_size;
  if ( m_size == (v12->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v13, v12, 112);
    m_size = v12->m_size;
    v15 = m_size;
  }
  m_data = v12->m_data;
  v17 = (__int64)&v12->m_data[m_size];
  if ( v17 )
  {
    *(_DWORD *)(v17 + 56) = -1;
    *(_BYTE *)(v17 + 60) = 0;
    *(_QWORD *)(v17 + 64) = 0i64;
    *(_DWORD *)(v17 + 72) = 0;
    *(_QWORD *)(v17 + 80) = 0i64;
    *(_DWORD *)(v17 + 88) = 0;
    v15 = v12->m_size;
    m_data = v12->m_data;
  }
  v18 = &m_data[v15];
  v12->m_size = v15 + 1;
  v18->bodyId.m_serialAndIndex = 0xFFFFFF;
  v18->shape = shape;
  hkReferencedObject::addReference(shape);
  v18->point = (hkVector4f)point->m_quad;
  v18->rotation = (hkQuaternionf)rotation->m_vec.m_quad;
  v18->maxDistance = maxDistance;
  v18->extendedData = *extendedData;
  v18->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredGetClosestPoints
==============
*/
void HavokPhysics_DeferredGetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_GetClosestPointsRequest,hkContainerHeapAllocator> *v13; 
  hkMemoryAllocator *v14; 
  int m_size; 
  int v16; 
  HavokPhysics_GetClosestPointsRequest *m_data; 
  __int64 v18; 
  HavokPhysics_GetClosestPointsRequest *v19; 
  __int64 v20; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15166, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred get closest points with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15167, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred getclosest points with body with invalid body id %i", "bodyId.isValid()", v20) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15168, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15169, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15170, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15171, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15172, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred get closets points with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v13 = MutableWorld->getClosestPointsRequestLists[1 - MutableWorld->activeQueryRequestList];
  v14 = hkMemHeapAllocator();
  m_size = v13->m_size;
  v16 = m_size;
  if ( m_size == (v13->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v14, v13, 112);
    m_size = v13->m_size;
    v16 = m_size;
  }
  m_data = v13->m_data;
  v18 = (__int64)&v13->m_data[m_size];
  if ( v18 )
  {
    *(_DWORD *)(v18 + 56) = -1;
    *(_BYTE *)(v18 + 60) = 0;
    *(_QWORD *)(v18 + 64) = 0i64;
    *(_DWORD *)(v18 + 72) = 0;
    *(_QWORD *)(v18 + 80) = 0i64;
    *(_DWORD *)(v18 + 88) = 0;
    v16 = v13->m_size;
    m_data = v13->m_data;
  }
  v19 = &m_data[v16];
  v13->m_size = v16 + 1;
  v19->bodyId = bodyId;
  v19->shape = shape;
  hkReferencedObject::addReference(shape);
  v19->point = (hkVector4f)point->m_quad;
  v19->rotation = (hkQuaternionf)rotation->m_vec.m_quad;
  v19->maxDistance = maxDistance;
  v19->extendedData = *extendedData;
  v19->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/
void HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_QueryPointRequest,hkContainerHeapAllocator> *v10; 
  hkMemoryAllocator *v11; 
  int m_size; 
  int v13; 
  HavokPhysics_QueryPointRequest *m_data; 
  __int64 v15; 
  HavokPhysics_QueryPointRequest *v16; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14261, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14262, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14263, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v10 = MutableWorld->queryPointRequestLists[1 - MutableWorld->activeQueryRequestList];
  v11 = hkMemHeapAllocator();
  m_size = v10->m_size;
  v13 = m_size;
  if ( m_size == (v10->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v11, v10, 80);
    m_size = v10->m_size;
    v13 = m_size;
  }
  m_data = v10->m_data;
  v15 = (__int64)&v10->m_data[m_size];
  if ( v15 )
  {
    *(_DWORD *)(v15 + 40) = -1;
    *(_BYTE *)(v15 + 44) = 0;
    *(_QWORD *)(v15 + 48) = 0i64;
    *(_QWORD *)(v15 + 56) = 1i64;
    *(_DWORD *)(v15 + 64) = 0;
    v13 = v10->m_size;
    m_data = v10->m_data;
  }
  v16 = &m_data[v13];
  v10->m_size = v13 + 1;
  v16->bodyId.m_serialAndIndex = 0xFFFFFF;
  v16->point = (hkVector4f)point->m_quad;
  v16->maxDistance = maxDistance;
  v16->extendedData = *extendedData;
  v16->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredQueryPoint
==============
*/
void HavokPhysics_DeferredQueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_QueryPointRequest,hkContainerHeapAllocator> *v11; 
  hkMemoryAllocator *v12; 
  int m_size; 
  int v14; 
  HavokPhysics_QueryPointRequest *m_data; 
  __int64 v16; 
  HavokPhysics_QueryPointRequest *v17; 
  __int64 v18; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15047, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v18) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15048, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid body id %i", "bodyId.isValid()", v18) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15049, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15050, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15051, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15052, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred querypoint with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v11 = MutableWorld->queryPointRequestLists[1 - MutableWorld->activeQueryRequestList];
  v12 = hkMemHeapAllocator();
  m_size = v11->m_size;
  v14 = m_size;
  if ( m_size == (v11->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v12, v11, 80);
    m_size = v11->m_size;
    v14 = m_size;
  }
  m_data = v11->m_data;
  v16 = (__int64)&v11->m_data[m_size];
  if ( v16 )
  {
    *(_DWORD *)(v16 + 40) = -1;
    *(_BYTE *)(v16 + 44) = 0;
    *(_QWORD *)(v16 + 48) = 0i64;
    *(_QWORD *)(v16 + 56) = 1i64;
    *(_DWORD *)(v16 + 64) = 0;
    v14 = v11->m_size;
    m_data = v11->m_data;
  }
  v17 = &m_data[v14];
  v11->m_size = v14 + 1;
  v17->bodyId = bodyId;
  v17->point = (hkVector4f)point->m_quad;
  v17->maxDistance = maxDistance;
  v17->extendedData = *extendedData;
  v17->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/
void HavokPhysics_DeferredRaycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_RaycastRequest,hkContainerHeapAllocator> *v11; 
  hkMemoryAllocator *v12; 
  int m_size; 
  int v14; 
  HavokPhysics_RaycastRequest *m_data; 
  __int64 v16; 
  HavokPhysics_RaycastRequest *v17; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13916, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13917, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13918, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v11 = MutableWorld->raycastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v12 = hkMemHeapAllocator();
  m_size = v11->m_size;
  v14 = m_size;
  if ( m_size == (v11->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v12, v11, 96);
    m_size = v11->m_size;
    v14 = m_size;
  }
  m_data = v11->m_data;
  v16 = (__int64)&v11->m_data[m_size];
  if ( v16 )
  {
    *(_DWORD *)(v16 + 48) = -1;
    *(_QWORD *)(v16 + 56) = 0i64;
    *(_QWORD *)(v16 + 64) = 1i64;
    *(_DWORD *)(v16 + 72) = 0;
    *(_DWORD *)(v16 + 76) = 1;
    *(_WORD *)(v16 + 80) = 256;
    v14 = v11->m_size;
    m_data = v11->m_data;
  }
  v17 = &m_data[v14];
  v11->m_size = v14 + 1;
  v17->bodyId.m_serialAndIndex = 0xFFFFFF;
  v17->start = (hkVector4f)start->m_quad;
  v17->end = (hkVector4f)end->m_quad;
  *(__m256i *)&v17->extendedData.contents = *(__m256i *)&extendedData->contents;
  *(double *)&v17->extendedData.collectInsideHits = *(double *)&extendedData->collectInsideHits;
  v17->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredRaycast
==============
*/
void HavokPhysics_DeferredRaycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_RaycastRequest,hkContainerHeapAllocator> *v12; 
  hkMemoryAllocator *v13; 
  int m_size; 
  int v15; 
  HavokPhysics_RaycastRequest *m_data; 
  __int64 v17; 
  HavokPhysics_RaycastRequest *v18; 
  __int64 v19; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14648, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v19) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14649, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid body id %i", "bodyId.isValid()", v19) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14650, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14651, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14652, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred raycast with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v12 = MutableWorld->raycastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v13 = hkMemHeapAllocator();
  m_size = v12->m_size;
  v15 = m_size;
  if ( m_size == (v12->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v13, v12, 96);
    m_size = v12->m_size;
    v15 = m_size;
  }
  m_data = v12->m_data;
  v17 = (__int64)&v12->m_data[m_size];
  if ( v17 )
  {
    *(_DWORD *)(v17 + 48) = -1;
    *(_QWORD *)(v17 + 56) = 0i64;
    *(_QWORD *)(v17 + 64) = 1i64;
    *(_DWORD *)(v17 + 72) = 0;
    *(_DWORD *)(v17 + 76) = 1;
    *(_WORD *)(v17 + 80) = 256;
    v15 = v12->m_size;
    m_data = v12->m_data;
  }
  v18 = &m_data[v15];
  v12->m_size = v15 + 1;
  v18->bodyId = bodyId;
  v18->start = (hkVector4f)start->m_quad;
  v18->end = (hkVector4f)end->m_quad;
  v18->extendedData = *extendedData;
  v18->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/
void HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_ShapecastRequest,hkContainerHeapAllocator> *v12; 
  hkMemoryAllocator *v13; 
  int m_size; 
  int v15; 
  HavokPhysics_ShapecastRequest *m_data; 
  __int64 v17; 
  HavokPhysics_ShapecastRequest *v18; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14087, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14088, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14089, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v12 = MutableWorld->shapecastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v13 = hkMemHeapAllocator();
  m_size = v12->m_size;
  v15 = m_size;
  if ( m_size == (v12->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v13, v12, 128);
    m_size = v12->m_size;
    v15 = m_size;
  }
  m_data = v12->m_data;
  v17 = (__int64)&v12->m_data[(__int64)m_size];
  if ( v17 )
  {
    *(_DWORD *)(v17 + 64) = -1;
    *(_DWORD *)(v17 + 68) = 0;
    *(_DWORD *)(v17 + 72) = 1015222895;
    *(_BYTE *)(v17 + 76) = 0;
    *(_QWORD *)(v17 + 80) = 0i64;
    *(_DWORD *)(v17 + 88) = 0;
    *(_QWORD *)(v17 + 96) = 0i64;
    *(_QWORD *)(v17 + 104) = 0i64;
    *(_DWORD *)(v17 + 112) = 0;
    *(_BYTE *)(v17 + 116) = 0;
    v15 = v12->m_size;
    m_data = v12->m_data;
  }
  v18 = &m_data[(__int64)v15];
  v12->m_size = v15 + 1;
  v18->bodyId.m_serialAndIndex = 0xFFFFFF;
  v18->shape = shape;
  hkReferencedObject::addReference(shape);
  v18->start = (hkVector4f)start->m_quad;
  v18->end = (hkVector4f)end->m_quad;
  v18->rotation = (hkQuaternionf)rotation->m_vec.m_quad;
  v18->extendedData = *extendedData;
  v18->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DeferredShapecast
==============
*/
void HavokPhysics_DeferredShapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, Physics_DeferredCollisionQueryData *data)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_deferredQueryCritSection; 
  hkArray<HavokPhysics_ShapecastRequest,hkContainerHeapAllocator> *v13; 
  hkMemoryAllocator *v14; 
  int m_size; 
  int v16; 
  HavokPhysics_ShapecastRequest *m_data; 
  __int64 v18; 
  HavokPhysics_ShapecastRequest *v19; 
  __int64 v20; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14783, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14784, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid body id %i", "bodyId.isValid()", v20) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14785, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid extendedData", "extendedData") )
    __debugbreak();
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14786, ASSERT_TYPE_ASSERT, "(data)", "%s\n\tHavok Physics: Trying to fire Deferred shapecast with body with invalid data", "data") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  data->isComplete = 0;
  p_deferredQueryCritSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->deferredQueryCritSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  v13 = MutableWorld->shapecastRequestLists[1 - MutableWorld->activeQueryRequestList];
  v14 = hkMemHeapAllocator();
  m_size = v13->m_size;
  v16 = m_size;
  if ( m_size == (v13->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v14, v13, 128);
    m_size = v13->m_size;
    v16 = m_size;
  }
  m_data = v13->m_data;
  v18 = (__int64)&v13->m_data[(__int64)m_size];
  if ( v18 )
  {
    *(_DWORD *)(v18 + 64) = -1;
    *(_DWORD *)(v18 + 68) = 0;
    *(_DWORD *)(v18 + 72) = 1015222895;
    *(_BYTE *)(v18 + 76) = 0;
    *(_QWORD *)(v18 + 80) = 0i64;
    *(_DWORD *)(v18 + 88) = 0;
    *(_QWORD *)(v18 + 96) = 0i64;
    *(_QWORD *)(v18 + 104) = 0i64;
    *(_DWORD *)(v18 + 112) = 0;
    *(_BYTE *)(v18 + 116) = 0;
    v16 = v13->m_size;
    m_data = v13->m_data;
  }
  v19 = &m_data[(__int64)v16];
  v13->m_size = v16 + 1;
  v19->bodyId = bodyId;
  v19->shape = shape;
  hkReferencedObject::addReference(shape);
  v19->start = (hkVector4f)start->m_quad;
  v19->end = (hkVector4f)end->m_quad;
  v19->rotation = (hkQuaternionf)rotation->m_vec.m_quad;
  v19->extendedData = *extendedData;
  v19->deferredData = data;
  LeaveCriticalSection(p_deferredQueryCritSection);
}

/*
==============
HavokPhysics_DestroyBody
==============
*/
void HavokPhysics_DestroyBody(Physics_WorldId worldId, HavokPhysicsWorld *world, hknpBodyId bodyId, bool activate)
{
  hknpWorld *v7; 
  __int64 v8; 
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *v10; 
  __int64 v11; 
  int v12; 
  Physics_RefSystem RefSystem; 
  __int64 v14; 
  unsigned int v15; 
  hknpUnaryAction *v16; 
  hknpUnaryAction *v17; 
  unsigned __int16 m_refCount; 
  hknpActionManager *ActionManager; 
  signed __int32 v20[8]; 
  __int64 v21; 
  __int64 v22; 
  unsigned int bodyIda; 
  __int64 v24; 

  bodyIda = bodyId.m_serialAndIndex;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8931, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8932, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( (bodyIda & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8933, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", (const char *)&queryFormat, "bodyId.isValid()") )
    __debugbreak();
  v7 = world->world;
  v8 = v7->m_bodyManager.m_scheduledBodyChangeIndices.m_data[bodyIda & 0xFFFFFF];
  if ( (_DWORD)v8 != -1 && v7->m_bodyManager.m_scheduledBodyChanges.m_data[v8].m_pendingAddIndex != -1 )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v22) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10905, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Add Pending Bodies to invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v22) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    if ( !MutableWorld->world )
    {
      LODWORD(v22) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10909, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavok Physics: Trying to Add Pending Bodies where index %i doesn't have a world yet", "havokPhysicsWorld->world", v22) )
        __debugbreak();
    }
    v10 = MutableWorld->world;
    if ( v10->m_bodyManager.m_bodiesToAddAsActive.m_size || v10->m_bodyManager.m_bodiesToAddAsInactive.m_size )
    {
      v10->commitAddBodies(&v10->hknpWorldWriter);
      MutableWorld->world->updateBroadPhase(&MutableWorld->world->hknpWorldWriter);
    }
  }
  v11 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->world->getBody)(&world->world->hknpWorldReader, bodyIda);
  v12 = truncate_cast<int,unsigned __int64>(*(unsigned int *)(v11 + 160));
  RefSystem = Physics_GetRefSystem(v12);
  v14 = RefSystem;
  if ( (unsigned int)RefSystem >= Physics_RefSystem_Count )
  {
    LODWORD(v22) = 13;
    LODWORD(v21) = RefSystem;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8948, ASSERT_TYPE_ASSERT, "(unsigned)( refSystem ) < (unsigned)( Physics_RefSystem_Count )", "refSystem doesn't index Physics_RefSystem_Count\n\t%i not in [0, %i)", v21, v22) )
      __debugbreak();
  }
  --world->refSystemCounts[v14];
  v15 = bodyIda;
  if ( !Physics_IsQueryWorld(worldId) && !Physics_IsPredictiveWorld(worldId) )
  {
    v16 = PhysicsForceAction_Get(worldId, v15);
    v17 = v16;
    if ( v16 )
    {
      _InterlockedOr(v20, 0);
      m_refCount = v16->m_refCount;
      _InterlockedOr(v20, 0);
      if ( m_refCount != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8960, ASSERT_TYPE_ASSERT, "(forceAction->getReferenceCount() == 2)", (const char *)&queryFormat, "forceAction->getReferenceCount() == 2") )
        __debugbreak();
      ActionManager = hknpWorld::getActionManager(world->world);
      hknpActionManager::removeAction(ActionManager, (hknpAction *)&v24);
      PhysicsForceAction_Destroy(v17);
    }
  }
  world->bodySFXEventAssets->m_data[bodyIda & 0xFFFFFF] = NULL;
  world->bodyVFXEventAssets->m_data[bodyIda & 0xFFFFFF] = NULL;
  Sys_EnterCriticalSection(CRITSECT_PHYS_BODY_CREATE);
  world->world->destroyBodies(&world->world->hknpWorldWriter, (const hknpBodyId *)&bodyIda, 1, (hknpWorldWriter::ActivationMode)!activate);
  Sys_LeaveCriticalSection(CRITSECT_PHYS_BODY_CREATE);
}

/*
==============
HavokPhysics_DestroyConstraint
==============
*/
void HavokPhysics_DestroyConstraint(HavokPhysicsWorld *world, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId)
{
  unsigned int m_value; 

  m_value = constraintId.m_value;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9031, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  if ( !world->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9032, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
    __debugbreak();
  if ( m_value == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9033, ASSERT_TYPE_ASSERT, "(constraintId.isValid())", (const char *)&queryFormat, "constraintId.isValid()") )
    __debugbreak();
  ((void (__fastcall *)(hknpWorldWriter *, unsigned int *, __int64))world->world->destroyConstraints)(&world->world->hknpWorldWriter, &m_value, 1i64);
}

/*
==============
HavokPhysics_DestroyConstraint
==============
*/
void HavokPhysics_DestroyConstraint(Physics_WorldId worldId, unsigned int instanceId, int constraintIdx, bool activate)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v8; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10867, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Destroy constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10868, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Destroy constraint in invalid Instance in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10873, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DestroyInstance %i: world is NULL", "havokPhysicsWorld->world", v8) )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_GetConstraintId(&result, &MutableWorld->instanceManager, instanceId, constraintIdx);
  HavokPhysics_DestroyConstraint(MutableWorld, result);
  HavokPhysicsInstanceManager_RemoveConstraint(&MutableWorld->instanceManager, instanceId, constraintIdx);
}

/*
==============
HavokPhysics_DestroyInstance
==============
*/
void HavokPhysics_DestroyInstance(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  __int64 v3; 
  bool v4; 
  Physics_WorldId v5; 
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  signed int v8; 
  __int64 v9; 
  signed int v10; 
  __int64 i; 
  __int64 v12; 

  v3 = instanceId;
  v4 = activate;
  v5 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10814, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Destroy Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v3 == -1 )
  {
    LODWORD(v12) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10815, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Destroy invalid Instance in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v12) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(v5);
  if ( !MutableWorld->world )
  {
    LODWORD(v12) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10822, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DestroyInstance %i: world is NULL", "havokPhysicsWorld->world", v12) )
      __debugbreak();
  }
  p_instanceManager = &MutableWorld->instanceManager;
  v8 = HavokPhysicsInstanceManager_GetConstraintCount(&MutableWorld->instanceManager, v3) - 1;
  v9 = v8;
  if ( v8 >= 0 )
  {
    do
    {
      if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 92, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
        __debugbreak();
      if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 93, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
        __debugbreak();
      HavokPhysics_DestroyConstraint(MutableWorld, p_instanceManager->buffer[v3].constraints.m_data[v9--]);
    }
    while ( v9 >= 0 );
    v5 = worldId;
    v4 = activate;
  }
  HavokPhysicsInstanceManager_ClearConstraints(&MutableWorld->instanceManager, v3);
  v10 = HavokPhysicsInstanceManager_GetBodyCount(&MutableWorld->instanceManager, v3) - 1;
  for ( i = v10; i >= 0; HavokPhysics_DestroyBody(v5, MutableWorld, p_instanceManager->buffer[v3].bodies.m_data[i--], v4) )
  {
    if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 49, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 50, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_ClearBodies(&MutableWorld->instanceManager, v3);
  HavokPhysicsInstanceManager_DestroyInstance(&MutableWorld->instanceManager, v3);
}

/*
==============
HavokPhysics_DestroyWorld
==============
*/
void HavokPhysics_DestroyWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *m_ragdollConstraintGroupId; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *i; 
  hkMemoryAllocator *v5; 
  int m_capacityAndFlags; 
  hkMemoryRouter *Value; 
  hknpWorld *world; 
  hknpBodyManager *p_m_bodyManager; 
  unsigned int m_peakIndex; 
  const char *WorldName; 
  const char *v12; 
  hknpShape *debugGetClosestPointsShape; 
  hknpShape *debugShapecastShape; 
  int v15; 
  __int64 v16; 
  hkProcess *v17; 
  hkMemoryAllocator *v18; 
  int v19; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v21; 
  int v22; 
  hkMemoryRouter *v23; 
  hkSet<unsigned int,hkContainerHeapAllocator,hkMapOperations<unsigned int> > *detailDrawBodies; 
  __int64 m_size; 
  __int64 j; 
  hkSet<unsigned int,hkContainerHeapAllocator,hkMapOperations<unsigned int> > *v27; 
  hkMemoryAllocator *v28; 
  int v29; 
  hkMemoryRouter *v30; 
  HavokPhysicsProcessHandler *processHandler; 
  hkServerObjectHandler *serverObjectHandler; 
  hkServerObjectSerializer *vdbObjectSerializer; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMemoryAllocator *v35; 
  int v36; 
  hkMemoryRouter *v37; 
  hkVisualDebugger *vdbServer; 
  hkVisualDebugger *v39; 
  hclClothContext *clothVisContext; 
  unsigned __int16 m_refCount; 
  hclClothContext *v42; 
  hknpProcessContext *visContext; 
  hknpProcessContext *v44; 
  unsigned int k; 
  __int64 v46; 
  __int64 v47; 
  __int64 v48; 
  HavokPhysics_BroadphaseCollisionQueryResult *v49; 
  unsigned __int16 v50; 
  __int64 v51; 
  HavokPhysicsWorld *v52; 
  hknpEventSignal *EventSignal; 
  HavokPhysicsWorld *v54; 
  __int64 v55; 
  hkMemoryAllocator *v56; 
  int v57; 
  hkMemoryRouter *v58; 
  __int64 v59; 
  hkMemoryAllocator *v60; 
  int v61; 
  hkMemoryRouter *v62; 
  __int64 v63; 
  hkMemoryAllocator *v64; 
  int v65; 
  hkMemoryRouter *v66; 
  __int64 v67; 
  hkMemoryAllocator *v68; 
  int v69; 
  hkMemoryRouter *v70; 
  __int64 v71; 
  hkMemoryAllocator *v72; 
  int v73; 
  hkMemoryRouter *v74; 
  __int64 v75; 
  hkMemoryAllocator *v76; 
  int v77; 
  hkMemoryRouter *v78; 
  void *v79; 
  hkMemoryRouter *v80; 
  __int64 *v81; 
  __int64 v82; 
  __int64 *v83; 
  __int64 v84; 
  hkReferencedObject *v85; 
  __int64 *v86; 
  __int64 v87; 
  hkReferencedObject *v88; 
  __int64 v89; 
  hkMemoryAllocator *v90; 
  int v91; 
  hkMemoryRouter *v92; 
  __int64 v93; 
  hkMemoryAllocator *v94; 
  int v95; 
  hkMemoryRouter *v96; 
  __int64 v97; 
  hkMemoryAllocator *v98; 
  int v99; 
  hkMemoryRouter *v100; 
  __int64 v101; 
  hkMemoryAllocator *v102; 
  int v103; 
  hkMemoryRouter *v104; 
  __int64 v105; 
  hkMemoryAllocator *v106; 
  int v107; 
  hkMemoryRouter *v108; 
  __int64 v109; 
  hkMemoryAllocator *v110; 
  int v111; 
  hkMemoryRouter *v112; 
  bool IsQueryWorld; 
  __int64 v114; 
  __int64 v115; 
  __int64 v116; 
  __int64 v117; 
  hkReferencedObject *v118; 
  hkReferencedObject *v119; 
  __int64 v120; 
  __int64 v121; 
  __int64 v122; 
  __int64 v123; 
  signed __int32 v124[8]; 
  __int64 v125; 
  __int64 v126; 
  LPCRITICAL_SECTION p_critSection; 
  __int64 v128; 
  hkCriticalSection *v129; 
  hkBool result; 
  HavokPhysicsWorld *v132; 
  void (__fastcall *method)(const hknpEventHandlerInput *, const hknpEvent *); 

  v128 = -2i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3463, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DestroyWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v125) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v132 = MutableWorld;
  p_critSection = (LPCRITICAL_SECTION)&MutableWorld->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  m_ragdollConstraintGroupId = MutableWorld->m_ragdollConstraintGroupId;
  if ( m_ragdollConstraintGroupId )
  {
    for ( i = m_ragdollConstraintGroupId->m_data; i != &m_ragdollConstraintGroupId->m_data[m_ragdollConstraintGroupId->m_size]; m_ragdollConstraintGroupId = MutableWorld->m_ragdollConstraintGroupId )
    {
      if ( i->m_value != 0x7FFFFFFF && hknpConstraintManager::isGroupValid(MutableWorld->world->m_constraintManager, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)i->m_value) )
      {
        hknpConstraintManager::destroyConstraintGroup(MutableWorld->world->m_constraintManager, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)i->m_value);
        i->m_value = 0x7FFFFFFF;
      }
      ++i;
    }
    if ( m_ragdollConstraintGroupId )
    {
      v5 = hkMemHeapAllocator();
      m_ragdollConstraintGroupId->m_size = 0;
      m_capacityAndFlags = m_ragdollConstraintGroupId->m_capacityAndFlags;
      if ( m_capacityAndFlags >= 0 )
        hkMemoryAllocator::bufFree2(v5, m_ragdollConstraintGroupId->m_data, 4, m_capacityAndFlags & 0x3FFFFFFF);
      m_ragdollConstraintGroupId->m_data = NULL;
      m_ragdollConstraintGroupId->m_capacityAndFlags = 0x80000000;
      Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !Value )
        Value = hkMemoryRouter::s_fallbackRouter;
      Value->m_heap->blockFree(Value->m_heap, m_ragdollConstraintGroupId, 16);
    }
    MutableWorld->m_ragdollConstraintGroupId = NULL;
  }
  world = MutableWorld->world;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3489, ASSERT_TYPE_ASSERT, "(world)", (const char *)&queryFormat, "world") )
    __debugbreak();
  p_m_bodyManager = &world->m_bodyManager;
  if ( !p_m_bodyManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3492, ASSERT_TYPE_ASSERT, "(havokBodyManager)", (const char *)&queryFormat, "havokBodyManager") )
    __debugbreak();
  m_peakIndex = p_m_bodyManager->m_bodies.m_peakIndex;
  WorldName = Physics_GetWorldName(worldId);
  Com_Printf(12, "Physics World '%s' Body Count Peak %i\n", WorldName, m_peakIndex);
  v12 = Physics_GetWorldName(worldId);
  HavokPhysicsInstanceManager_CheckEmpty(v12, worldId, &MutableWorld->instanceManager);
  debugGetClosestPointsShape = MutableWorld->debugGetClosestPointsShape;
  if ( debugGetClosestPointsShape )
  {
    HavokPhysics_ReleaseShape(worldId, debugGetClosestPointsShape, 1);
    MutableWorld->debugGetClosestPointsShape = NULL;
  }
  debugShapecastShape = MutableWorld->debugShapecastShape;
  if ( debugShapecastShape )
  {
    HavokPhysics_ReleaseShape(worldId, debugShapecastShape, 1);
    MutableWorld->debugShapecastShape = NULL;
  }
  if ( MutableWorld->visProcesses.m_size )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3512, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visProcesses.getSize() == 0)", "%s\n\tHavokPhysics DestroyWorld %i: visProcesses is not empty", "havokPhysicsWorld->visProcesses.getSize() == 0", v125) )
      __debugbreak();
  }
  v15 = 0;
  if ( MutableWorld->visProcesses.m_size > 0 )
  {
    v16 = 0i64;
    do
    {
      v17 = MutableWorld->visProcesses.m_data[v16];
      if ( v17 )
        ((void (__fastcall *)(hkProcess *, __int64))v17->~hkProcess)(v17, 1i64);
      ++v15;
      ++v16;
    }
    while ( v15 < MutableWorld->visProcesses.m_size );
  }
  v18 = hkMemHeapAllocator();
  MutableWorld->visProcesses.m_size = 0;
  v19 = MutableWorld->visProcesses.m_capacityAndFlags;
  if ( v19 >= 0 )
    hkMemoryAllocator::bufFree2(v18, MutableWorld->visProcesses.m_data, 8, v19 & 0x3FFFFFFF);
  MutableWorld->visProcesses.m_data = NULL;
  MutableWorld->visProcesses.m_capacityAndFlags = 0x80000000;
  if ( !MutableWorld->debugLines && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3522, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  debugLines = MutableWorld->debugLines;
  if ( debugLines )
  {
    v21 = hkMemHeapAllocator();
    debugLines->m_size = 0;
    v22 = debugLines->m_capacityAndFlags;
    if ( v22 >= 0 )
      hkMemoryAllocator::bufFree2(v21, debugLines->m_data, 48, v22 & 0x3FFFFFFF);
    debugLines->m_data = NULL;
    debugLines->m_capacityAndFlags = 0x80000000;
    v23 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v23 )
      v23 = hkMemoryRouter::s_fallbackRouter;
    v23->m_heap->blockFree(v23->m_heap, debugLines, 16);
  }
  MutableWorld->debugLines = NULL;
  detailDrawBodies = MutableWorld->detailDrawBodies;
  m_size = detailDrawBodies->m_elem.m_size;
  if ( m_size > 0 )
  {
    for ( j = 0i64; j < m_size; ++j )
      detailDrawBodies->m_elem.m_data[j] = -1;
  }
  detailDrawBodies->m_numElems = 0;
  v27 = MutableWorld->detailDrawBodies;
  if ( v27 )
  {
    v28 = hkMemHeapAllocator();
    v27->m_elem.m_size = 0;
    v29 = v27->m_elem.m_capacityAndFlags;
    if ( v29 >= 0 )
      hkMemoryAllocator::bufFree2(v28, v27->m_elem.m_data, 4, v29 & 0x3FFFFFFF);
    v27->m_elem.m_data = NULL;
    v27->m_elem.m_capacityAndFlags = 0x80000000;
    v30 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v30 )
      v30 = hkMemoryRouter::s_fallbackRouter;
    v30->m_heap->blockFree(v30->m_heap, v27, 24);
  }
  MutableWorld->detailDrawBodies = NULL;
  if ( !MutableWorld->processHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3531, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->processHandler)", (const char *)&queryFormat, "havokPhysicsWorld->processHandler") )
    __debugbreak();
  processHandler = MutableWorld->processHandler;
  if ( processHandler )
    ((void (__fastcall *)(HavokPhysicsProcessHandler *, __int64))processHandler->~hkProcessHandler)(processHandler, 1i64);
  MutableWorld->processHandler = NULL;
  serverObjectHandler = MutableWorld->serverObjectHandler;
  _InterlockedOr(v124, 0);
  LOWORD(serverObjectHandler) = serverObjectHandler->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)serverObjectHandler != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3534, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->serverObjectHandler->getReferenceCount() == 1)", (const char *)&queryFormat, "havokPhysicsWorld->serverObjectHandler->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(MutableWorld->serverObjectHandler);
  MutableWorld->serverObjectHandler = NULL;
  vdbObjectSerializer = MutableWorld->vdbObjectSerializer;
  _InterlockedOr(v124, 0);
  LOWORD(vdbObjectSerializer) = vdbObjectSerializer->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)vdbObjectSerializer != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3539, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbObjectSerializer->getReferenceCount() == 1)", (const char *)&queryFormat, "havokPhysicsWorld->vdbObjectSerializer->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(MutableWorld->vdbObjectSerializer);
  MutableWorld->vdbObjectSerializer = NULL;
  ((void (__fastcall *)(HavokPhysicsDisplayHandler *, _QWORD))MutableWorld->displayHandler->~hkBaseObject)(MutableWorld->displayHandler, 0i64);
  MutableWorld->displayHandler = NULL;
  if ( !MutableWorld->monitorStreams && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3550, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->monitorStreams)", (const char *)&queryFormat, "havokPhysicsWorld->monitorStreams") )
    __debugbreak();
  monitorStreams = MutableWorld->monitorStreams;
  if ( monitorStreams )
  {
    v35 = hkMemHeapAllocator();
    monitorStreams->m_size = 0;
    v36 = monitorStreams->m_capacityAndFlags;
    if ( v36 >= 0 )
      hkMemoryAllocator::bufFree2(v35, monitorStreams->m_data, 8, v36 & 0x3FFFFFFF);
    monitorStreams->m_data = NULL;
    monitorStreams->m_capacityAndFlags = 0x80000000;
    v37 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v37 )
      v37 = hkMemoryRouter::s_fallbackRouter;
    v37->m_heap->blockFree(v37->m_heap, monitorStreams, 16);
  }
  MutableWorld->monitorStreams = NULL;
  if ( !MutableWorld->vdbServer )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3555, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics DestroyWorld %i: vdbServer is NULL", "havokPhysicsWorld->vdbServer", v125) )
      __debugbreak();
  }
  hkVisualDebugger::shutdown(MutableWorld->vdbServer);
  hkVisualDebugger::clearDefaultAndRequiredProcesses(MutableWorld->vdbServer);
  vdbServer = MutableWorld->vdbServer;
  _InterlockedOr(v124, 0);
  LOWORD(vdbServer) = vdbServer->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)vdbServer != 1 )
  {
    v39 = MutableWorld->vdbServer;
    _InterlockedOr(v124, 0);
    LODWORD(v39) = v39->m_refCount;
    _InterlockedOr(v124, 0);
    LODWORD(v126) = (_DWORD)v39;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3558, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: vdbServer has %i references - should be 1", "havokPhysicsWorld->vdbServer->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(MutableWorld->vdbServer);
  MutableWorld->vdbServer = NULL;
  clothVisContext = MutableWorld->clothVisContext;
  if ( clothVisContext )
  {
    _InterlockedOr(v124, 0);
    m_refCount = clothVisContext->m_refCount;
    _InterlockedOr(v124, 0);
    if ( m_refCount != 1 )
    {
      v42 = MutableWorld->clothVisContext;
      _InterlockedOr(v124, 0);
      LODWORD(v42) = v42->m_refCount;
      _InterlockedOr(v124, 0);
      LODWORD(v126) = (_DWORD)v42;
      LODWORD(v125) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3565, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->clothVisContext->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: cloth visContext has %i references - should be 1", "havokPhysicsWorld->clothVisContext->getReferenceCount() == 1", v125, v126) )
        __debugbreak();
    }
    hkReferencedObject::removeReference(MutableWorld->clothVisContext);
    MutableWorld->clothVisContext = NULL;
  }
  if ( !MutableWorld->visContext )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3569, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics DestroyWorld %i: visContext is NULL", "havokPhysicsWorld->visContext", v125) )
      __debugbreak();
  }
  visContext = MutableWorld->visContext;
  _InterlockedOr(v124, 0);
  LOWORD(visContext) = visContext->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)visContext != 1 )
  {
    v44 = MutableWorld->visContext;
    _InterlockedOr(v124, 0);
    LODWORD(v44) = v44->m_refCount;
    _InterlockedOr(v124, 0);
    LODWORD(v126) = (_DWORD)v44;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3570, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: visContext has %i references - should be 1", "havokPhysicsWorld->visContext->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(MutableWorld->visContext);
  MutableWorld->visContext = NULL;
  hkReferencedObject::removeReference(MutableWorld->comContext);
  MutableWorld->comContext = NULL;
  for ( k = 0; k < 2; ++k )
  {
    v46 = (int)(2 * worldId + k);
    v47 = v46;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldGetClosestPointsData[v46].result);
    s_havokPhysicsWorldGetClosestPointsData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldQueryPointData[v46].result);
    s_havokPhysicsWorldQueryPointData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldShapeCastData[v46].startResult);
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldShapeCastData[v46].result);
    s_havokPhysicsWorldShapeCastData[v47].startResult = NULL;
    s_havokPhysicsWorldShapeCastData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldRayDetailData[v46].result);
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldRayData[v46].result);
    s_havokPhysicsWorldRayDetailData[v47].result = NULL;
    s_havokPhysicsWorldRayData[v47].result = NULL;
    HavokPhysics_FreeCollisionQueryResult(s_havokPhysicsWorldAABBQueryData[v46].result);
    s_havokPhysicsWorldAABBQueryData[v47].result = NULL;
    v48 = v46;
    v49 = s_havokPhysicsWorldAABBBroadphaseQueryData[v48].result;
    if ( !v49 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13575, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    _InterlockedOr(v124, 0);
    v50 = v49->m_refCount;
    _InterlockedOr(v124, 0);
    if ( v50 != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13578, ASSERT_TYPE_ASSERT, "(result->getReferenceCount() == 1)", (const char *)&queryFormat, "result->getReferenceCount() == 1") )
      __debugbreak();
    hkReferencedObject::removeReference(v49);
    s_havokPhysicsWorldAABBBroadphaseQueryData[v48].result = NULL;
  }
  v51 = (__int64)v132;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16407, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to UnsubscribeFromEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v125) )
      __debugbreak();
  }
  v52 = HavokPhysics_GetMutableWorld(worldId);
  if ( !v52->world )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16411, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics UnsubscribeFromEvent %i: world is NULL", "physicsWorld->world", v125) )
      __debugbreak();
  }
  EventSignal = hknpWorld::getEventSignal(v52->world, BODY_EXITED_BROAD_PHASE, (hknpBodyId)0xFFFFFF);
  method = HavokPhysics_LeftBroadphase;
  hkSignal::unsubscribeInternal(EventSignal, &result, NULL, &method, 8);
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11259, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Clear codec with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v125) )
      __debugbreak();
  }
  v54 = HavokPhysics_GetMutableWorld(worldId);
  v129 = &v54->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&v54->critSection);
  if ( !v54->world )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11265, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics ClearCodec %i: world is NULL", "havokPhysicsWorld->world", v125) )
      __debugbreak();
  }
  if ( !s_shapeTagCodec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11268, ASSERT_TYPE_ASSERT, "(s_shapeTagCodec)", (const char *)&queryFormat, "s_shapeTagCodec") )
    __debugbreak();
  v54->world->setShapeTagCodec(&v54->world->hknpWorldWriter, NULL);
  LeaveCriticalSection((LPCRITICAL_SECTION)&v54->critSection);
  if ( !*(_QWORD *)(v51 + 248) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3613, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->bodySFXEventAssets)", (const char *)&queryFormat, "havokPhysicsWorld->bodySFXEventAssets") )
    __debugbreak();
  v55 = *(_QWORD *)(v51 + 248);
  if ( v55 )
  {
    v56 = hkMemHeapAllocator();
    *(_DWORD *)(v55 + 8) = 0;
    v57 = *(_DWORD *)(v55 + 12);
    if ( v57 >= 0 )
      hkMemoryAllocator::bufFree2(v56, *(void **)v55, 8, v57 & 0x3FFFFFFF);
    *(_QWORD *)v55 = 0i64;
    *(_DWORD *)(v55 + 12) = 0x80000000;
    v58 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v58 )
      v58 = hkMemoryRouter::s_fallbackRouter;
    v58->m_heap->blockFree(v58->m_heap, (void *)v55, 16);
  }
  *(_QWORD *)(v51 + 248) = 0i64;
  if ( !*(_QWORD *)(v51 + 256) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3616, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->bodyVFXEventAssets)", (const char *)&queryFormat, "havokPhysicsWorld->bodyVFXEventAssets") )
    __debugbreak();
  v59 = *(_QWORD *)(v51 + 256);
  if ( v59 )
  {
    v60 = hkMemHeapAllocator();
    *(_DWORD *)(v59 + 8) = 0;
    v61 = *(_DWORD *)(v59 + 12);
    if ( v61 >= 0 )
      hkMemoryAllocator::bufFree2(v60, *(void **)v59, 8, v61 & 0x3FFFFFFF);
    *(_QWORD *)v59 = 0i64;
    *(_DWORD *)(v59 + 12) = 0x80000000;
    v62 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v62 )
      v62 = hkMemoryRouter::s_fallbackRouter;
    v62->m_heap->blockFree(v62->m_heap, (void *)v59, 16);
  }
  *(_QWORD *)(v51 + 256) = 0i64;
  if ( !*(_QWORD *)(v51 + 448) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3621, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredBulletEffectEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredBulletEffectEntries") )
    __debugbreak();
  v63 = *(_QWORD *)(v51 + 448);
  if ( v63 )
  {
    v64 = hkMemHeapAllocator();
    *(_DWORD *)(v63 + 8) = 0;
    v65 = *(_DWORD *)(v63 + 12);
    if ( v65 >= 0 )
      hkMemoryAllocator::bufFree2(v64, *(void **)v63, 136, v65 & 0x3FFFFFFF);
    *(_QWORD *)v63 = 0i64;
    *(_DWORD *)(v63 + 12) = 0x80000000;
    v66 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v66 )
      v66 = hkMemoryRouter::s_fallbackRouter;
    v66->m_heap->blockFree(v66->m_heap, (void *)v63, 16);
  }
  *(_QWORD *)(v51 + 448) = 0i64;
  if ( !*(_QWORD *)(v51 + 440) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3625, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredRadiusForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredRadiusForceEntries") )
    __debugbreak();
  v67 = *(_QWORD *)(v51 + 440);
  if ( v67 )
  {
    v68 = hkMemHeapAllocator();
    *(_DWORD *)(v67 + 8) = 0;
    v69 = *(_DWORD *)(v67 + 12);
    if ( v69 >= 0 )
      hkMemoryAllocator::bufFree2(v68, *(void **)v67, 48, v69 & 0x3FFFFFFF);
    *(_QWORD *)v67 = 0i64;
    *(_DWORD *)(v67 + 12) = 0x80000000;
    v70 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v70 )
      v70 = hkMemoryRouter::s_fallbackRouter;
    v70->m_heap->blockFree(v70->m_heap, (void *)v67, 16);
  }
  *(_QWORD *)(v51 + 440) = 0i64;
  if ( !*(_QWORD *)(v51 + 432) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3629, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredBulletForceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredBulletForceEntries") )
    __debugbreak();
  v71 = *(_QWORD *)(v51 + 432);
  if ( v71 )
  {
    v72 = hkMemHeapAllocator();
    *(_DWORD *)(v71 + 8) = 0;
    v73 = *(_DWORD *)(v71 + 12);
    if ( v73 >= 0 )
      hkMemoryAllocator::bufFree2(v72, *(void **)v71, 104, v73 & 0x3FFFFFFF);
    *(_QWORD *)v71 = 0i64;
    *(_DWORD *)(v71 + 12) = 0x80000000;
    v74 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v74 )
      v74 = hkMemoryRouter::s_fallbackRouter;
    v74->m_heap->blockFree(v74->m_heap, (void *)v71, 16);
  }
  *(_QWORD *)(v51 + 432) = 0i64;
  if ( !*(_QWORD *)(v51 + 424) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3633, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_deferredKeyframeInstanceEntries)", (const char *)&queryFormat, "havokPhysicsWorld->m_deferredKeyframeInstanceEntries") )
    __debugbreak();
  v75 = *(_QWORD *)(v51 + 424);
  if ( v75 )
  {
    v76 = hkMemHeapAllocator();
    *(_DWORD *)(v75 + 8) = 0;
    v77 = *(_DWORD *)(v75 + 12);
    if ( v77 >= 0 )
      hkMemoryAllocator::bufFree2(v76, *(void **)v75, 32, v77 & 0x3FFFFFFF);
    *(_QWORD *)v75 = 0i64;
    *(_DWORD *)(v75 + 12) = 0x80000000;
    v78 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v78 )
      v78 = hkMemoryRouter::s_fallbackRouter;
    v78->m_heap->blockFree(v78->m_heap, (void *)v75, 16);
  }
  *(_QWORD *)(v51 + 424) = 0i64;
  if ( !*(_QWORD *)(v51 + 416) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3637, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->capsuleRadii)", (const char *)&queryFormat, "havokPhysicsWorld->capsuleRadii") )
    __debugbreak();
  v79 = *(void **)(v51 + 416);
  if ( v79 )
  {
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(*(hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> **)(v51 + 416));
    v80 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v80 )
      v80 = hkMemoryRouter::s_fallbackRouter;
    v80->m_heap->blockFree(v80->m_heap, v79, 16);
  }
  *(_QWORD *)(v51 + 416) = 0i64;
  v81 = (__int64 *)(v51 + 296);
  v82 = 2i64;
  do
  {
    if ( !*(v81 - 2) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3643, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->aabbBroadphaseQueryRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !*v81 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3644, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->aabbQueryRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->aabbQueryRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3645, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->raycastRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->raycastRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3646, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->shapecastRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->shapecastRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3647, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->queryPointRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->queryPointRequestLists[bufferIdx]") )
      __debugbreak();
    if ( !v81[8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3648, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx])", (const char *)&queryFormat, "havokPhysicsWorld->getClosestPointsRequestLists[bufferIdx]") )
      __debugbreak();
    v83 = (__int64 *)v81[4];
    v84 = *v83;
    if ( *v83 != *v83 + ((__int64)*((int *)v83 + 2) << 7) )
    {
      do
      {
        v85 = *(hkReferencedObject **)(v84 + 8);
        if ( v85 )
        {
          hkReferencedObject::removeReference(v85);
          *(_QWORD *)(v84 + 8) = 0i64;
        }
        v84 += 128i64;
      }
      while ( v84 != *(_QWORD *)v81[4] + ((__int64)*(int *)(v81[4] + 8) << 7) );
    }
    v86 = (__int64 *)v81[8];
    v87 = *v86;
    if ( *v86 != *v86 + 112i64 * *((int *)v86 + 2) )
    {
      do
      {
        v88 = *(hkReferencedObject **)(v87 + 8);
        if ( v88 )
        {
          hkReferencedObject::removeReference(v88);
          *(_QWORD *)(v87 + 8) = 0i64;
        }
        v87 += 112i64;
      }
      while ( v87 != *(_QWORD *)v81[8] + 112i64 * *(int *)(v81[8] + 8) );
    }
    v89 = *(v81 - 2);
    if ( v89 )
    {
      v90 = hkMemHeapAllocator();
      *(_DWORD *)(v89 + 8) = 0;
      v91 = *(_DWORD *)(v89 + 12);
      if ( v91 >= 0 )
        hkMemoryAllocator::bufFree2(v90, *(void **)v89, 64, v91 & 0x3FFFFFFF);
      *(_QWORD *)v89 = 0i64;
      *(_DWORD *)(v89 + 12) = 0x80000000;
      v92 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v92 )
        v92 = hkMemoryRouter::s_fallbackRouter;
      v92->m_heap->blockFree(v92->m_heap, (void *)v89, 16);
    }
    *(v81 - 2) = 0i64;
    v93 = *v81;
    if ( *v81 )
    {
      v94 = hkMemHeapAllocator();
      *(_DWORD *)(v93 + 8) = 0;
      v95 = *(_DWORD *)(v93 + 12);
      if ( v95 >= 0 )
        hkMemoryAllocator::bufFree2(v94, *(void **)v93, 80, v95 & 0x3FFFFFFF);
      *(_QWORD *)v93 = 0i64;
      *(_DWORD *)(v93 + 12) = 0x80000000;
      v96 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v96 )
        v96 = hkMemoryRouter::s_fallbackRouter;
      v96->m_heap->blockFree(v96->m_heap, (void *)v93, 16);
    }
    *v81 = 0i64;
    v97 = v81[2];
    if ( v97 )
    {
      v98 = hkMemHeapAllocator();
      *(_DWORD *)(v97 + 8) = 0;
      v99 = *(_DWORD *)(v97 + 12);
      if ( v99 >= 0 )
        hkMemoryAllocator::bufFree2(v98, *(void **)v97, 96, v99 & 0x3FFFFFFF);
      *(_QWORD *)v97 = 0i64;
      *(_DWORD *)(v97 + 12) = 0x80000000;
      v100 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v100 )
        v100 = hkMemoryRouter::s_fallbackRouter;
      v100->m_heap->blockFree(v100->m_heap, (void *)v97, 16);
    }
    v81[2] = 0i64;
    v101 = v81[4];
    if ( v101 )
    {
      v102 = hkMemHeapAllocator();
      *(_DWORD *)(v101 + 8) = 0;
      v103 = *(_DWORD *)(v101 + 12);
      if ( v103 >= 0 )
        hkMemoryAllocator::bufFree2(v102, *(void **)v101, 128, v103 & 0x3FFFFFFF);
      *(_QWORD *)v101 = 0i64;
      *(_DWORD *)(v101 + 12) = 0x80000000;
      v104 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v104 )
        v104 = hkMemoryRouter::s_fallbackRouter;
      v104->m_heap->blockFree(v104->m_heap, (void *)v101, 16);
    }
    v81[4] = 0i64;
    v105 = v81[6];
    if ( v105 )
    {
      v106 = hkMemHeapAllocator();
      *(_DWORD *)(v105 + 8) = 0;
      v107 = *(_DWORD *)(v105 + 12);
      if ( v107 >= 0 )
        hkMemoryAllocator::bufFree2(v106, *(void **)v105, 80, v107 & 0x3FFFFFFF);
      *(_QWORD *)v105 = 0i64;
      *(_DWORD *)(v105 + 12) = 0x80000000;
      v108 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v108 )
        v108 = hkMemoryRouter::s_fallbackRouter;
      v108->m_heap->blockFree(v108->m_heap, (void *)v105, 16);
    }
    v81[6] = 0i64;
    v109 = v81[8];
    if ( v109 )
    {
      v110 = hkMemHeapAllocator();
      *(_DWORD *)(v109 + 8) = 0;
      v111 = *(_DWORD *)(v109 + 12);
      if ( v111 >= 0 )
        hkMemoryAllocator::bufFree2(v110, *(void **)v109, 112, v111 & 0x3FFFFFFF);
      *(_QWORD *)v109 = 0i64;
      *(_DWORD *)(v109 + 12) = 0x80000000;
      v112 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v112 )
        v112 = hkMemoryRouter::s_fallbackRouter;
      v112->m_heap->blockFree(v112->m_heap, (void *)v109, 16);
    }
    v81[8] = 0i64;
    ++v81;
    --v82;
  }
  while ( v82 );
  HavokPhysics_RemoveMotionPropertiesLibraryFromWorld(&s_havokPhysicsMotionPropertiesLibrary, worldId);
  HavokPhysics_RemoveMaterialLibraryFromWorld(&s_havokPhysicsMaterialLibrary, worldId);
  IsQueryWorld = Physics_IsQueryWorld(worldId);
  v114 = (__int64)v132;
  if ( IsQueryWorld )
  {
    if ( v132->gravityModifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3699, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->gravityModifier == 0)", (const char *)&queryFormat, "havokPhysicsWorld->gravityModifier == NULL") )
      __debugbreak();
  }
  else
  {
    if ( !v132->gravityModifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3703, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->gravityModifier != 0)", (const char *)&queryFormat, "havokPhysicsWorld->gravityModifier != NULL") )
      __debugbreak();
    hknpModifierManager::removeModifier(*(hknpModifierManager **)(*(_QWORD *)(v114 + 24) + 1200i64), *(hknpModifier **)(v114 + 264));
    PhysicsGravityModifier_Destroy(*(hknpModifier **)(v114 + 264));
    *(_QWORD *)(v114 + 264) = 0i64;
  }
  if ( !*(_QWORD *)(v114 + 24) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3710, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DestroyWorld %i: world is NULL", "havokPhysicsWorld->world", v125) )
      __debugbreak();
  }
  v115 = *(_QWORD *)(v114 + 24);
  _InterlockedOr(v124, 0);
  LOWORD(v115) = *(_WORD *)(v115 + 18);
  _InterlockedOr(v124, 0);
  if ( (_WORD)v115 != 1 )
  {
    v116 = *(_QWORD *)(v114 + 24);
    _InterlockedOr(v124, 0);
    LODWORD(v116) = *(unsigned __int16 *)(v116 + 18);
    _InterlockedOr(v124, 0);
    LODWORD(v126) = v116;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3711, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: world has %i references - should be 1", "havokPhysicsWorld->world->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(*(hkReferencedObject **)(v114 + 24));
  *(_QWORD *)(v114 + 24) = 0i64;
  HavokPhysicsInstanceManager_Shutdown((HavokPhysicsInstanceManager *)(v114 + 192));
  if ( (*(_BYTE *)(v114 + 136) || *(_BYTE *)(v114 + 137)) && !*(_QWORD *)(v114 + 144) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3719, ASSERT_TYPE_ASSERT, "(!( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics DestroyWorld %i: task queue is NULL", "!( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || havokPhysicsWorld->taskQueue", v125) )
      __debugbreak();
  }
  if ( *(_BYTE *)(v114 + 136) )
    goto LABEL_265;
  if ( !*(_BYTE *)(v114 + 137) )
  {
    if ( *(_QWORD *)(v114 + 144) )
    {
      LODWORD(v125) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3720, ASSERT_TYPE_ASSERT, "(( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics DestroyWorld %i: task queue is not NULL", "( havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->hasFXSupport ) || !havokPhysicsWorld->taskQueue", v125) )
        __debugbreak();
    }
  }
  if ( *(_BYTE *)(v114 + 136) )
  {
LABEL_265:
    v117 = *(_QWORD *)(v114 + 144);
    if ( v117 )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v117 + 8i64))(v117, 1i64);
    *(_QWORD *)(v114 + 144) = 0i64;
  }
  if ( !*(_QWORD *)v114 )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3728, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->traceCollisionFilter)", "%s\n\tHavokPhysics DestroyWorld %i: trace collision filter is NULL", "havokPhysicsWorld->traceCollisionFilter", v125) )
      __debugbreak();
  }
  v118 = *(hkReferencedObject **)v114;
  _InterlockedOr(v124, 0);
  LOWORD(v118) = v118->m_refCount;
  _InterlockedOr(v124, 0);
  if ( (_WORD)v118 != 1 )
  {
    v119 = *(hkReferencedObject **)v114;
    _InterlockedOr(v124, 0);
    LODWORD(v119) = v119->m_refCount;
    _InterlockedOr(v124, 0);
    LODWORD(v126) = (_DWORD)v119;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3729, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->traceCollisionFilter->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: trace collision filter has %i references - should be 1", "havokPhysicsWorld->traceCollisionFilter->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(*(hkReferencedObject **)v114);
  *(_QWORD *)v114 = 0i64;
  if ( !*(_QWORD *)(v114 + 8) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3732, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->simulationCollisionFilter)", "%s\n\tHavokPhysics DestroyWorld %i: simulation collision filter is NULL", "havokPhysicsWorld->simulationCollisionFilter", v125) )
      __debugbreak();
  }
  v120 = *(_QWORD *)(v114 + 8);
  _InterlockedOr(v124, 0);
  LOWORD(v120) = *(_WORD *)(v120 + 18);
  _InterlockedOr(v124, 0);
  if ( (_WORD)v120 != 1 )
  {
    v121 = *(_QWORD *)(v114 + 8);
    _InterlockedOr(v124, 0);
    LODWORD(v121) = *(unsigned __int16 *)(v121 + 18);
    _InterlockedOr(v124, 0);
    LODWORD(v126) = v121;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3733, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->simulationCollisionFilter->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: simulation collision filter has %i references - should be 1", "havokPhysicsWorld->simulationCollisionFilter->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(*(hkReferencedObject **)(v114 + 8));
  *(_QWORD *)(v114 + 8) = 0i64;
  if ( !*(_QWORD *)(v114 + 16) )
  {
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3738, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics DestroyWorld %i: persistent stream allocator is NULL", "havokPhysicsWorld->persistentStreamAllocator", v125) )
      __debugbreak();
  }
  v122 = *(_QWORD *)(v114 + 16);
  _InterlockedOr(v124, 0);
  LOWORD(v122) = *(_WORD *)(v122 + 18);
  _InterlockedOr(v124, 0);
  if ( (_WORD)v122 != 1 )
  {
    v123 = *(_QWORD *)(v114 + 16);
    _InterlockedOr(v124, 0);
    LODWORD(v123) = *(unsigned __int16 *)(v123 + 18);
    _InterlockedOr(v124, 0);
    LODWORD(v126) = v123;
    LODWORD(v125) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3739, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator->getReferenceCount() == 1)", "%s\n\tHavokPhysics DestroyWorld %i: persistent stream allocator has %i references - should be 1", "havokPhysicsWorld->persistentStreamAllocator->getReferenceCount() == 1", v125, v126) )
      __debugbreak();
  }
  if ( hkFixedBlockStreamAllocator::getCapacity(*(hkFixedBlockStreamAllocator **)(v114 + 16)) > 0 )
    hkFixedBlockStreamAllocator::clear(*(hkFixedBlockStreamAllocator **)(v114 + 16));
  hkReferencedObject::removeReference(*(hkReferencedObject **)(v114 + 16));
  *(_QWORD *)(v114 + 16) = 0i64;
  LeaveCriticalSection(p_critSection);
}

/*
==============
HavokPhysics_DirtyBroadphase
==============
*/
void HavokPhysics_DirtyBroadphase(Physics_WorldId worldId, const hkArray<hknpBodyId,hkContainerHeapAllocator> *array)
{
  HavokPhysicsWorld *MutableWorld; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  MutableWorld->world->m_broadPhase->markBodiesDirty(MutableWorld->world->m_broadPhase, array->m_data, array->m_size, 4);
}

/*
==============
HavokPhysics_DisableShapeCache
==============
*/
void HavokPhysics_DisableShapeCache(unsigned int threadId, bool disable)
{
  __int64 v2; 
  bool *v4; 

  v2 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15855, ASSERT_TYPE_ASSERT, "(threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS)", (const char *)&queryFormat, "threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS") )
    __debugbreak();
  v4 = &s_havokPhysicsShapeCachesDisabled[v2];
  if ( *v4 == disable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15856, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCachesDisabled[threadId] != disable)", (const char *)&queryFormat, "s_havokPhysicsShapeCachesDisabled[threadId] != disable") )
    __debugbreak();
  *v4 = disable;
}

/*
==============
HavokPhysics_DoDeferredQueries
==============
*/
void HavokPhysics_DoDeferredQueries(Physics_WorldId worldId)
{
  __int128 v2; 
  __int128 v3; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 activeQueryRequestList; 
  hkArray<HavokPhysics_AABBBroadphaseQueryRequest,hkContainerHeapAllocator> *v7; 
  hkAabb *p_aabb; 
  unsigned __int64 v12; 
  __int64 v13; 
  const HavokPhysicsWorld *ConstWorld; 
  __int64 traceCollisionFilter; 
  hkMonitorStream *Value; 
  hkMonitorStream *v18; 
  _BYTE *v19; 
  hkArray<HavokPhysics_AABBQueryRequest,hkContainerHeapAllocator> *v20; 
  hknpBodyId *p_bodyId; 
  hknpBodyId *v22; 
  int v23; 
  _BYTE *v24; 
  hkArray<HavokPhysics_RaycastRequest,hkContainerHeapAllocator> *v25; 
  hknpBodyId *v26; 
  hknpBodyId *v27; 
  _BYTE *v28; 
  hkArray<HavokPhysics_ShapecastRequest,hkContainerHeapAllocator> *v29; 
  hknpBodyId *v30; 
  hknpBodyId *v31; 
  __int64 v32; 
  hknpShape *v33; 
  HavokPhysics_CollisionQueryResult *startResult; 
  HavokPhysics_CollisionQueryResult *v35; 
  _BYTE *v36; 
  hkArray<HavokPhysics_QueryPointRequest,hkContainerHeapAllocator> *v37; 
  HavokPhysics_QueryPointRequest *m_data; 
  float maxDistance; 
  Physics_DeferredCollisionQueryData *deferredData; 
  hkArray<HavokPhysics_GetClosestPointsRequest,hkContainerHeapAllocator> *v41; 
  HavokPhysics_GetClosestPointsRequest *v42; 
  float v43; 
  hknpShape *shape; 
  Physics_DeferredCollisionQueryData *v45; 
  Physics_ShapecastExtendedData *extendedData; 
  __m256i v47; 
  float v48; 
  __int64 v49; 
  int v50; 
  __int128 v51; 
  int v52; 
  HavokPhysicsShapeTagCodec *v53; 
  __int64 v54; 
  __int16 v55; 
  int v56; 
  float *v57; 
  int v58; 
  char v59; 
  __m256i v60; 
  __int128 v61; 
  __int128 v62; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15404, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DoDeferredQueries with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  activeQueryRequestList = (unsigned int)MutableWorld->activeQueryRequestList;
  v7 = MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList];
  p_aabb = &v7->m_data->aabb;
  if ( v7->m_data != &v7->m_data[(__int64)v7->m_size] )
  {
    v62 = v2;
    __asm { vpxor   xmm0, xmm0, xmm0 }
    v61 = v3;
    __asm
    {
      vpinsrw xmm0, xmm0, eax, 1
      vpshufd xmm6, xmm0, 0
    }
    do
    {
      v12 = p_aabb[1].m_max.m_quad.m128_u64[1];
      v49 = 0i64;
      v50 = 1;
      v52 = 0;
      v13 = *(_QWORD *)(v12 + 8);
      v55 = -1;
      v56 = 0;
      v57 = NULL;
      v54 = 0i64;
      v53 = NULL;
      v58 = 2;
      v59 = -5;
      v47 = *(__m256i *)p_aabb;
      __asm { vpxor   xmm0, xmm0, xmm0 }
      v51 = _XMM0;
      *(__m128 *)v60.m256i_i8 = g_vectorfConstants[36];
      _XMM0 = *(_OWORD *)&g_vectorfConstants[36] ^ _XMM6;
      *(_OWORD *)&v60.m256i_u64[2] = *(_OWORD *)&g_vectorfConstants[36] ^ _XMM6;
      v48 = 0.0;
      if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        LODWORD(extendedData) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13758, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", extendedData) )
          __debugbreak();
      }
      if ( p_aabb == (hkAabb *)-32i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13759, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid extended data", "extendedData") )
        __debugbreak();
      if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13760, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire aabb broadphase query with invalid result", "result") )
        __debugbreak();
      ConstWorld = HavokPhysics_GetConstWorld(worldId);
      v49 = p_aabb[1].m_min.m_quad.m128_i64[1];
      v52 = p_aabb[1].m_max.m_quad.m128_i32[0];
      v53 = s_shapeTagCodec;
      v60 = v47;
      traceCollisionFilter = (__int64)ConstWorld->traceCollisionFilter;
      v55 = -1;
      v56 = p_aabb[1].m_min.m_quad.m128_i32[0];
      v54 = traceCollisionFilter;
      v57 = &v48;
      v58 = 0;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      if ( Value )
        hkMonitorStream::timerBegin(Value, "TtQueryBroadphaseAABB_HK");
      ConstWorld->world->queryAabb(&ConstWorld->world->hknpWorldReader, (const hknpAabbQuery *)&v53, (hkArray<hknpBodyId,hkContainerHeapAllocator> *)(v13 + 24));
      v18 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      if ( v18 )
        hkMonitorStream::timerEnd(v18, "Et");
      v19 = (_BYTE *)p_aabb[1].m_max.m_quad.m128_u64[1];
      p_aabb += 2;
      *v19 = 1;
    }
    while ( p_aabb != &MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList]->m_data[(__int64)MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList]->m_size].aabb );
  }
  v20 = MutableWorld->aabbQueryRequestLists[activeQueryRequestList];
  p_bodyId = &v20->m_data->bodyId;
  if ( v20->m_data != &v20->m_data[v20->m_size] )
  {
    v22 = p_bodyId + 12;
    do
    {
      v23 = p_bodyId->m_serialAndIndex & 0xFFFFFF;
      v47 = *(__m256i *)&v22[-8].m_serialAndIndex;
      if ( v23 == 0xFFFFFF )
        HavokPhysics_AABBQuery(worldId, (const hkAabb *)&v47, (Physics_AABBQueryExtendedData *)v22, *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&v22[6].m_serialAndIndex + 8i64));
      else
        HavokPhysics_AABBQuery(worldId, (hknpBodyId)p_bodyId->m_serialAndIndex, (const hkAabb *)&v47, (Physics_AABBQueryExtendedData *)v22, *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&v22[6].m_serialAndIndex + 8i64));
      v24 = *(_BYTE **)&v22[6].m_serialAndIndex;
      p_bodyId += 20;
      v22 += 20;
      *v24 = 1;
    }
    while ( p_bodyId != &MutableWorld->aabbQueryRequestLists[activeQueryRequestList]->m_data[MutableWorld->aabbQueryRequestLists[activeQueryRequestList]->m_size].bodyId );
  }
  v25 = MutableWorld->raycastRequestLists[activeQueryRequestList];
  v26 = &v25->m_data->bodyId;
  if ( v25->m_data != &v25->m_data[v25->m_size] )
  {
    v27 = v26 + 8;
    do
    {
      if ( (v26->m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
        HavokPhysics_Raycast(worldId, (const hkVector4f *)&v27[-4], (const hkVector4f *)v27, (Physics_RaycastExtendedData *)&v27[4], *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&v27[14].m_serialAndIndex + 8i64));
      else
        HavokPhysics_Raycast(worldId, (hknpBodyId)v26->m_serialAndIndex, (const hkVector4f *)&v27[-4], (const hkVector4f *)v27, (Physics_RaycastExtendedData *)&v27[4], *(HavokPhysics_CollisionQueryResult **)(*(_QWORD *)&v27[14].m_serialAndIndex + 8i64));
      v28 = *(_BYTE **)&v27[14].m_serialAndIndex;
      v26 += 24;
      v27 += 24;
      *v28 = 1;
    }
    while ( v26 != &MutableWorld->raycastRequestLists[activeQueryRequestList]->m_data[MutableWorld->raycastRequestLists[activeQueryRequestList]->m_size].bodyId );
  }
  v29 = MutableWorld->shapecastRequestLists[activeQueryRequestList];
  v30 = &v29->m_data->bodyId;
  if ( v29->m_data != &v29->m_data[(__int64)v29->m_size] )
  {
    v31 = v30 + 12;
    do
    {
      v32 = *(_QWORD *)&v31[18].m_serialAndIndex;
      v33 = *(hknpShape **)&v31[-10].m_serialAndIndex;
      startResult = *(HavokPhysics_CollisionQueryResult **)(v32 + 16);
      v35 = *(HavokPhysics_CollisionQueryResult **)(v32 + 8);
      if ( (v30->m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
        HavokPhysics_Shapecast(worldId, v33, (const hkVector4f *)&v31[-8], (const hkVector4f *)&v31[-4], (const hkQuaternionf *)v31, (Physics_ShapecastExtendedData *)&v31[4], v35, startResult);
      else
        HavokPhysics_Shapecast(worldId, (hknpBodyId)v30->m_serialAndIndex, v33, (const hkVector4f *)&v31[-8], (const hkVector4f *)&v31[-4], (const hkQuaternionf *)v31, (Physics_ShapecastExtendedData *)&v31[4], v35, startResult);
      if ( !*(_QWORD *)&v31[-10].m_serialAndIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15470, ASSERT_TYPE_ASSERT, "(request.shape)", (const char *)&queryFormat, "request.shape") )
        __debugbreak();
      hkReferencedObject::removeReference(*(hkReferencedObject **)&v31[-10].m_serialAndIndex);
      v36 = *(_BYTE **)&v31[18].m_serialAndIndex;
      v30 += 32;
      *(_QWORD *)&v31[-10].m_serialAndIndex = 0i64;
      v31 += 32;
      *v36 = 1;
    }
    while ( v30 != &MutableWorld->shapecastRequestLists[activeQueryRequestList]->m_data[(__int64)MutableWorld->shapecastRequestLists[activeQueryRequestList]->m_size].bodyId );
  }
  v37 = MutableWorld->queryPointRequestLists[activeQueryRequestList];
  m_data = v37->m_data;
  if ( v37->m_data != &v37->m_data[v37->m_size] )
  {
    do
    {
      maxDistance = m_data->maxDistance;
      if ( (m_data->bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
        HavokPhysics_QueryPoint(worldId, &m_data->point, maxDistance, &m_data->extendedData, m_data->deferredData->result);
      else
        HavokPhysics_QueryPoint(worldId, m_data->bodyId, &m_data->point, maxDistance, &m_data->extendedData, m_data->deferredData->result);
      deferredData = m_data->deferredData;
      ++m_data;
      deferredData->isComplete = 1;
    }
    while ( m_data != &MutableWorld->queryPointRequestLists[activeQueryRequestList]->m_data[MutableWorld->queryPointRequestLists[activeQueryRequestList]->m_size] );
  }
  v41 = MutableWorld->getClosestPointsRequestLists[activeQueryRequestList];
  v42 = v41->m_data;
  if ( v41->m_data != &v41->m_data[v41->m_size] )
  {
    do
    {
      v43 = v42->maxDistance;
      shape = v42->shape;
      if ( (v42->bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
        HavokPhysics_GetClosestPoints(worldId, shape, &v42->point, &v42->rotation, v43, &v42->extendedData, v42->deferredData->result);
      else
        HavokPhysics_GetClosestPoints(worldId, v42->bodyId, shape, &v42->point, &v42->rotation, v43, &v42->extendedData, v42->deferredData->result);
      if ( !v42->shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15508, ASSERT_TYPE_ASSERT, "(request.shape)", (const char *)&queryFormat, "request.shape") )
        __debugbreak();
      hkReferencedObject::removeReference(v42->shape);
      v45 = v42->deferredData;
      v42->shape = NULL;
      ++v42;
      v45->isComplete = 1;
    }
    while ( v42 != &MutableWorld->getClosestPointsRequestLists[activeQueryRequestList]->m_data[MutableWorld->getClosestPointsRequestLists[activeQueryRequestList]->m_size] );
  }
  MutableWorld->aabbBroadphaseQueryRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->aabbQueryRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->raycastRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->shapecastRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->queryPointRequestLists[activeQueryRequestList]->m_size = 0;
  MutableWorld->getClosestPointsRequestLists[activeQueryRequestList]->m_size = 0;
}

/*
==============
HavokPhysics_DoGarbageCollectionClient
==============
*/
void HavokPhysics_DoGarbageCollectionClient(void)
{
  unsigned int i; 

  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok GarbageCollection Client");
  if ( s_memoryRouter )
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  if ( s_threadMemoryRouters[Physics_GetRendererThreadId()] )
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  for ( i = 0; i < 3; ++i )
  {
    if ( s_threadMemoryRouters[Physics_GetWorkerThreadId(i + 2)] )
      ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  }
  s_havokPhysicsMemorySystem->garbageCollectShared(s_havokPhysicsMemorySystem);
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_DoGarbageCollectionServer
==============
*/
void HavokPhysics_DoGarbageCollectionServer(void)
{
  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok GarbageCollection Server");
  if ( s_threadMemoryRouters[Physics_GetServerThreadId()] )
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *))s_havokPhysicsMemorySystem->garbageCollectThread)(s_havokPhysicsMemorySystem);
  s_havokPhysicsMemorySystem->garbageCollectShared(s_havokPhysicsMemorySystem);
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_DrawDebugAABBBroadphaseWorldQuery
==============
*/
void HavokPhysics_DrawDebugAABBBroadphaseWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v8; 
  unsigned int v10; 
  __int64 v11; 
  HavokPhysicsWorld *MutableWorld; 
  bool v13; 
  int v14; 
  int v15; 
  __int64 v16; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  HavokPhysics_BroadphaseCollisionQueryResult *result; 
  __int64 m_size; 
  float v25; 
  __int64 v26; 
  unsigned int m_serialAndIndex; 
  __int64 v28; 
  const char *v29; 
  int v33; 
  hkMemoryAllocator *v34; 
  int v35; 
  int v36; 
  hknpBodyId *v37; 
  char *fmt; 
  __int64 forceColor; 
  __int64 shadow; 
  __int64 charHeighta; 
  unsigned int contentsa; 
  int numInOut[2]; 
  int v45[2]; 
  ScreenPlacement *scrPlacea; 
  __int64 v47; 
  __int128 v48; 
  double v49; 
  vec3_t center; 
  vec3_t origin; 
  Bounds bounds; 
  char dest[256]; 

  v47 = -2i64;
  v8 = scrPlace;
  scrPlacea = (ScreenPlacement *)scrPlace;
  v10 = collisionFilterInfo;
  v11 = worldId;
  LODWORD(v49) = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22346, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugAABBBroadphaseWorldQuery with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v11);
  if ( dword_150D5FA4C > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA4C);
    if ( dword_150D5FA4C == -1 )
    {
      numInOut[0] = 0;
      hkMemHeapAllocator();
      v33 = 0x80000000;
      ignoreBodies.m_ignoreEntities.m_data = NULL;
      ignoreBodies.m_ignoreEntities.m_size = 0;
      ignoreBodies.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies.m_ignoreBodies.m_data = NULL;
      ignoreBodies.m_ignoreBodies.m_size = 0;
      ignoreBodies.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      v45[0] = 0;
      v34 = hkMemHeapAllocator();
      v35 = v45[0];
      v36 = v45[0];
      if ( v45[0] )
      {
        v37 = (hknpBodyId *)hkMemoryAllocator::bufAlloc2(v34, 4, v45);
        v35 = v45[0];
      }
      else
      {
        v37 = NULL;
      }
      if ( v35 )
        v33 = v35;
      ignoreBodies.m_ignoreBodies.m_data = v37;
      ignoreBodies.m_ignoreBodies.m_size = v36;
      ignoreBodies.m_ignoreBodies.m_capacityAndFlags = v33;
      *(_QWORD *)&ignoreBodies.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies.m_isClutter = 0;
      ignoreBodies.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugAABBBroadphaseWorldQuery_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA4C);
      v8 = scrPlacea;
      v10 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v13 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v13) )
    ignoreBodies.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  LODWORD(v48) = v10;
  *((_QWORD *)&v48 + 1) = &ignoreBodies;
  v14 = s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v11];
  if ( v14 == -1 )
  {
    if ( MutableWorld->requestDebugAABBBroadphaseQuery && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22362, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugAABBBroadphaseQuery)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugAABBBroadphaseQuery") )
      __debugbreak();
    s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v11] = 0;
    MutableWorld->debugAABBBroadphaseQueryAABB.m_min = aabb->m_min;
    MutableWorld->debugAABBBroadphaseQueryAABB.m_max = aabb->m_max;
    *(_OWORD *)&MutableWorld->debugAABBBroadphaseQueryExtendedData.contents = v48;
    *(double *)&MutableWorld->debugAABBBroadphaseQueryExtendedData.phaseSelection = v49;
    MutableWorld->requestDebugAABBBroadphaseQuery = 1;
  }
  else
  {
    if ( !MutableWorld->requestDebugAABBBroadphaseQuery && s_havokPhysicsWorldAABBBroadphaseQueryData[2 * (int)v11 + v14].isComplete )
    {
      v14 = 1 - v14;
      s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v11] = v14;
      s_havokPhysicsWorldAABBBroadphaseQueryData[2 * (int)v11 + v14].result->m_hits.m_size = 0;
      MutableWorld->debugAABBBroadphaseQueryAABB.m_min = aabb->m_min;
      MutableWorld->debugAABBBroadphaseQueryAABB.m_max = aabb->m_max;
      *(_OWORD *)&MutableWorld->debugAABBBroadphaseQueryExtendedData.contents = v48;
      *(double *)&MutableWorld->debugAABBBroadphaseQueryExtendedData.phaseSelection = v49;
      MutableWorld->requestDebugAABBBroadphaseQuery = 1;
    }
    v15 = 2 * v11 - v14;
    if ( v14 != -1 )
    {
      v16 = v15 + 1i64;
      if ( s_havokPhysicsWorldAABBBroadphaseQueryData[v16].isComplete )
      {
        Com_sprintf<256>((char (*)[256])dest, "AABB Broadphase Query");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        *x = tabWidth + *x;
        HavokPhysics_DrawPhysicsContents(collisionFilterInfo, v8, x, y, tabWidth, charHeight);
        *x = *x - tabWidth;
        v17 = 32.0 * aabb->m_min.m_quad.m128_f32[0];
        v18 = 32.0 * aabb->m_min.m_quad.m128_f32[1];
        v19 = 32.0 * aabb->m_min.m_quad.m128_f32[2];
        v20 = 32.0 * aabb->m_max.m_quad.m128_f32[0];
        v21 = 32.0 * aabb->m_max.m_quad.m128_f32[1];
        v22 = 32.0 * aabb->m_max.m_quad.m128_f32[2];
        LODWORD(charHeighta) = (int)v22;
        LODWORD(shadow) = (int)v21;
        LODWORD(forceColor) = (int)v20;
        LODWORD(fmt) = (int)v19;
        Com_sprintf<256>((char (*)[256])dest, "AABB min(%i %i %i) max(%i %i %i)", (unsigned int)(int)v17, (unsigned int)(int)v18, fmt, forceColor, shadow, charHeighta);
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        origin.v[0] = 0.0;
        origin.v[1] = 0.0;
        origin.v[2] = 0.0;
        bounds.midPoint.v[0] = (float)(v20 + v17) * 0.5;
        bounds.halfSize.v[0] = (float)(v20 - v17) * 0.5;
        bounds.midPoint.v[1] = (float)(v21 + v18) * 0.5;
        bounds.halfSize.v[1] = (float)(v21 - v18) * 0.5;
        bounds.midPoint.v[2] = (float)(v22 + v19) * 0.5;
        bounds.halfSize.v[2] = (float)(v22 - v19) * 0.5;
        CG_DebugBox(&origin, &bounds, 0.0, &colorYellow, 0, 0);
        result = s_havokPhysicsWorldAABBBroadphaseQueryData[v16].result;
        *(_QWORD *)numInOut = result;
        m_size = result->m_hits.m_size;
        Com_sprintf<256>((char (*)[256])dest, "Result %i Hits", (unsigned int)result->m_hits.m_size);
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        v25 = tabWidth + *x;
        *x = v25;
        contentsa = 0;
        *(_QWORD *)v45 = m_size;
        if ( (int)m_size > 0 )
        {
          v26 = 0i64;
          do
          {
            m_serialAndIndex = result->m_hits.m_data[v26].m_serialAndIndex;
            v28 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, m_serialAndIndex);
            v29 = (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
            _XMM6 = *(__m128 *)(v28 + 48);
            Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s", contentsa, m_serialAndIndex, v29);
            Physics_DrawDebugString(scrPlacea, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
            *y = charHeight + *y;
            __asm
            {
              vmaxps  xmm1, xmm6, xmmword ptr [r14]
              vminps  xmm2, xmm1, xmmword ptr [r14+10h]
            }
            *(float *)&v48 = _XMM6.m128_f32[0] * 32.0;
            *((float *)&v48 + 1) = _mm_shuffle_ps(_XMM6, _XMM6, 85).m128_f32[0] * 32.0;
            *((float *)&v48 + 2) = _mm_shuffle_ps(_XMM6, _XMM6, 170).m128_f32[0] * 32.0;
            center.v[0] = _XMM2.m128_f32[0] * 32.0;
            center.v[1] = _mm_shuffle_ps(_XMM2, _XMM2, 85).m128_f32[0] * 32.0;
            center.v[2] = _mm_shuffle_ps(_XMM2, _XMM2, 170).m128_f32[0] * 32.0;
            CG_DebugSphere(&center, 5.0, &colorYellow, 0, 0);
            CG_DebugLine((const vec3_t *)&v48, &center, &colorYellow, 0, 0);
            CL_AddDebugString((const vec3_t *)&v48, &colorYellow, 1.0, v29, 0, 0);
            ++contentsa;
            ++v26;
            result = *(HavokPhysics_BroadphaseCollisionQueryResult **)numInOut;
          }
          while ( v26 < *(__int64 *)v45 );
          v25 = *x;
        }
        *x = v25 - tabWidth;
      }
    }
  }
}

/*
==============
HavokPhysics_DrawDebugAABBWorldQuery
==============
*/
void HavokPhysics_DrawDebugAABBWorldQuery(Physics_WorldId worldId, unsigned int collisionFilterInfo, const hkAabb *aabb, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v10; 
  __int64 v11; 
  HavokPhysicsWorld *MutableWorld; 
  bool v13; 
  int v14; 
  int v15; 
  __int64 v16; 
  int integer; 
  float *v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  unsigned int v25; 
  HavokPhysics_CollisionQueryResult *v26; 
  float v27; 
  unsigned int AABBQueryHitBodyId; 
  __int64 v29; 
  unsigned int m_collisionFilterInfo; 
  unsigned int AABBQueryHitSurfFlags; 
  hknpBodyId v33; 
  char *v34; 
  char *fmt; 
  __int64 forceColora; 
  __int64 forceColor; 
  __int64 shadowa; 
  __int64 shadow; 
  __int64 charHeightb; 
  __int64 charHeighta; 
  __int64 adjust; 
  __int64 v45; 
  int m_value; 
  int numInOut; 
  unsigned int contents[2]; 
  float *xa; 
  ScreenPlacement *scrPlacea; 
  char *text; 
  const hkAabb *v52; 
  __int64 v53; 
  __int128 v54; 
  double v55; 
  vec3_t center; 
  vec3_t origin; 
  Bounds bounds; 
  char dest[256]; 

  v53 = -2i64;
  scrPlacea = (ScreenPlacement *)scrPlace;
  v52 = aabb;
  v10 = collisionFilterInfo;
  contents[0] = collisionFilterInfo;
  v11 = worldId;
  contents[1] = worldId;
  xa = x;
  v55 = 0.0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22477, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugAABBWorldQuery with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v11);
  if ( dword_150D5FA50 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA50);
    if ( dword_150D5FA50 == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      ignoreBodies_0.m_ignoreEntities.m_data = NULL;
      ignoreBodies_0.m_ignoreEntities.m_size = 0;
      ignoreBodies_0.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_0.m_ignoreBodies.m_data = NULL;
      ignoreBodies_0.m_ignoreBodies.m_size = 0;
      ignoreBodies_0.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      m_value = 0;
      hkMemHeapAllocator();
      ignoreBodies_0.m_ignoreBodies.m_data = NULL;
      ignoreBodies_0.m_ignoreBodies.m_size = 0;
      ignoreBodies_0.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_0.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_0.m_isClutter = 0;
      ignoreBodies_0.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugAABBWorldQuery_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA50);
      v10 = contents[0];
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v13 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_0.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v13) )
    ignoreBodies_0.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  LODWORD(v54) = v10;
  BYTE4(v54) = 1;
  *((_QWORD *)&v54 + 1) = &ignoreBodies_0;
  v14 = s_havokPhysicsWorldAABBQueryActiveIndices[v11];
  if ( v14 == -1 )
  {
    if ( MutableWorld->requestDebugAABBQuery && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22494, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugAABBQuery)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugAABBQuery") )
      __debugbreak();
    s_havokPhysicsWorldAABBQueryActiveIndices[v11] = 0;
    MutableWorld->debugAABBQueryAABB.m_min = aabb->m_min;
    MutableWorld->debugAABBQueryAABB.m_max = aabb->m_max;
    *(_OWORD *)&MutableWorld->debugAABBQueryExtendedData.contents = v54;
    *(double *)&MutableWorld->debugAABBQueryExtendedData.collisionBuffer = v55;
    MutableWorld->requestDebugAABBQuery = 1;
  }
  else
  {
    v15 = s_havokPhysicsWorldAABBQueryActiveIndices[v11];
    if ( !MutableWorld->requestDebugAABBQuery && s_havokPhysicsWorldAABBQueryData[2 * (int)v11 + v14].isComplete )
    {
      s_havokPhysicsWorldAABBQueryActiveIndices[v11] = 1 - v14;
      HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldAABBQueryData[2 * (int)v11 + 1 - v14].result, 1);
      MutableWorld->debugAABBQueryAABB.m_min = aabb->m_min;
      MutableWorld->debugAABBQueryAABB.m_max = aabb->m_max;
      *(_OWORD *)&MutableWorld->debugAABBQueryExtendedData.contents = v54;
      *(double *)&MutableWorld->debugAABBQueryExtendedData.collisionBuffer = v55;
      MutableWorld->requestDebugAABBQuery = 1;
      v15 = s_havokPhysicsWorldAABBQueryActiveIndices[v11];
    }
    if ( v15 != -1 )
    {
      v16 = 3i64 * (2 * (int)v11 - v15) + 3;
      if ( *(&s_havokPhysicsWorldAABBQueryData[0].isComplete + 8 * v16) )
      {
        integer = physics_debugQueryBody->current.integer;
        if ( integer < 0 )
        {
          m_value = 0xFFFFFF;
          integer = 0xFFFFFF;
        }
        else
        {
          m_value = physics_debugQueryBody->current.integer;
        }
        if ( (integer & 0xFFFFFF) == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader, (unsigned int)integer) )
          Com_sprintf<256>((char (*)[256])dest, "AABB  Query");
        else
          Com_sprintf<256>((char (*)[256])dest, "AABB  Query for Body Id %i %s", (unsigned int)integer, (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        v18 = xa;
        Physics_DrawDebugString(scrPlace, *xa, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        *v18 = tabWidth + *v18;
        HavokPhysics_DrawPhysicsContents(contents[0], scrPlace, v18, y, tabWidth, charHeight);
        *v18 = *v18 - tabWidth;
        v19 = 32.0 * aabb->m_min.m_quad.m128_f32[0];
        v20 = 32.0 * aabb->m_min.m_quad.m128_f32[1];
        v21 = 32.0 * aabb->m_min.m_quad.m128_f32[2];
        v22 = 32.0 * aabb->m_max.m_quad.m128_f32[0];
        v23 = 32.0 * aabb->m_max.m_quad.m128_f32[1];
        v24 = 32.0 * aabb->m_max.m_quad.m128_f32[2];
        LODWORD(charHeightb) = (int)v24;
        LODWORD(shadowa) = (int)v23;
        LODWORD(forceColora) = (int)v22;
        LODWORD(fmt) = (int)v21;
        Com_sprintf<256>((char (*)[256])dest, "AABB min(%i %i %i) max(%i %i %i)", (unsigned int)(int)v19, (unsigned int)(int)v20, fmt, forceColora, shadowa, charHeightb);
        v25 = 0;
        Physics_DrawDebugString(scrPlace, *v18, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        origin.v[0] = 0.0;
        origin.v[1] = 0.0;
        origin.v[2] = 0.0;
        bounds.midPoint.v[0] = (float)(v22 + v19) * 0.5;
        bounds.halfSize.v[0] = (float)(v22 - v19) * 0.5;
        bounds.midPoint.v[1] = (float)(v23 + v20) * 0.5;
        bounds.halfSize.v[1] = (float)(v23 - v20) * 0.5;
        bounds.midPoint.v[2] = (float)(v24 + v21) * 0.5;
        bounds.halfSize.v[2] = (float)(v24 - v21) * 0.5;
        CG_DebugBox(&origin, &bounds, 0.0, &colorGreen, 0, 0);
        v26 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldAABBQueryData[0].result + v16);
        contents[0] = HavokPhysics_CollisionQueryResult::GetNumHits(v26);
        Com_sprintf<256>((char (*)[256])dest, "Result %i Hits", contents[0]);
        Physics_DrawDebugString(scrPlace, *v18, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        v27 = tabWidth + *v18;
        *v18 = v27;
        if ( (int)contents[0] > 0 )
        {
          do
          {
            AABBQueryHitBodyId = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(v26, v25);
            if ( Physics_IsRigidBodyValid((Physics_WorldId)v11, AABBQueryHitBodyId) )
            {
              v29 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, AABBQueryHitBodyId);
              text = (char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[AABBQueryHitBodyId & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
              _XMM6 = *(__m128 *)(v29 + 48);
              if ( v25 >= HavokPhysics_CollisionQueryResult::GetNumHits(v26) )
              {
                LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v26);
                LODWORD(forceColor) = v25;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 918, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
                  __debugbreak();
              }
              m_value = HavokPhysics_CollisionQueryResult::GetHit(v26, v25)->m_hitBodyInfo.m_shapeKey.m_value;
              if ( v25 >= HavokPhysics_CollisionQueryResult::GetNumHits(v26) )
              {
                LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v26);
                LODWORD(forceColor) = v25;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 925, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
                  __debugbreak();
              }
              LOWORD(numInOut) = HavokPhysics_CollisionQueryResult::GetHit(v26, v25)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
              if ( v25 >= HavokPhysics_CollisionQueryResult::GetNumHits(v26) )
              {
                LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v26);
                LODWORD(forceColor) = v25;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 932, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
                  __debugbreak();
              }
              m_collisionFilterInfo = HavokPhysics_CollisionQueryResult::GetHit(v26, v25)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
              AABBQueryHitSurfFlags = HavokPhysics_CollisionQueryResult::GetAABBQueryHitSurfFlags(v26, v25);
              v33.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetAABBQueryHitBodyId(v26, v25);
              LODWORD(v45) = HavokPhysics_GetRef(v26->m_worldId, v33);
              LODWORD(adjust) = AABBQueryHitSurfFlags;
              LODWORD(charHeighta) = m_collisionFilterInfo;
              LODWORD(shadow) = (unsigned __int16)numInOut;
              LODWORD(forceColor) = m_value;
              v34 = text;
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v25, AABBQueryHitBodyId, text, forceColor, shadow, charHeighta, adjust, v45);
              Physics_DrawDebugString(scrPlacea, *xa, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              __asm
              {
                vmaxps  xmm1, xmm6, xmmword ptr [rax]
                vminps  xmm2, xmm1, xmmword ptr [rax+10h]
              }
              *(float *)&v54 = _XMM6.m128_f32[0] * 32.0;
              *((float *)&v54 + 1) = _mm_shuffle_ps(_XMM6, _XMM6, 85).m128_f32[0] * 32.0;
              *((float *)&v54 + 2) = _mm_shuffle_ps(_XMM6, _XMM6, 170).m128_f32[0] * 32.0;
              center.v[0] = _XMM2.m128_f32[0] * 32.0;
              center.v[1] = _mm_shuffle_ps(_XMM2, _XMM2, 85).m128_f32[0] * 32.0;
              center.v[2] = _mm_shuffle_ps(_XMM2, _XMM2, 170).m128_f32[0] * 32.0;
              CG_DebugSphere(&center, 5.0, &colorGreen, 0, 0);
              CG_DebugLine((const vec3_t *)&v54, &center, &colorGreen, 0, 0);
              CL_AddDebugString((const vec3_t *)&v54, &colorGreen, 1.0, v34, 0, 0);
              LODWORD(v11) = contents[1];
              v18 = xa;
            }
            else
            {
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v25, AABBQueryHitBodyId);
              Physics_DrawDebugString(scrPlacea, *v18, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
            }
            ++v25;
          }
          while ( (int)v25 < (int)contents[0] );
          v27 = *v18;
        }
        *v18 = v27 - tabWidth;
      }
    }
  }
}

/*
==============
HavokPhysics_DrawDebugBadColLods
==============
*/
void HavokPhysics_DrawDebugBadColLods(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v7; 
  int v8; 
  __int64 v9; 
  const XModel *v10; 
  hkMemoryAllocator *v11; 
  int v12; 
  float v13; 
  unsigned int v14; 
  int v15; 
  char *v16; 
  char *v17; 
  __int64 v18; 
  float v19; 
  unsigned int v20; 
  char *v21; 
  char *v22; 
  int v23; 
  __int64 v24; 
  __int64 v25; 
  int v26; 
  unsigned int v27; 
  float v28; 
  unsigned int v29; 
  int v30; 
  char *v31; 
  char *v32; 
  __int64 v33; 
  __int64 v34; 
  int v35; 
  unsigned int v36; 
  hkMemoryAllocator *v37; 
  char *fmt; 
  char *fmta; 
  __int64 forceColor; 
  char *array; 
  __int64 v42; 
  const ScreenPlacement *v43; 
  __int64 v44; 
  char dest[256]; 

  v44 = -2i64;
  v7 = scrPlace;
  v43 = scrPlace;
  array = NULL;
  v42 = 0x8000000000000000ui64;
  v8 = 0;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v9 = 0i64;
    do
    {
      v10 = s_havokPhysicsXModels->m_data[v9];
      if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23720, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      if ( v10->physicsAsset && strncmp(v10->name, "vfx", 3ui64) && strncmp(v10->name, "fx", 2ui64) && strncmp(v10->name, "weapon", 6ui64) )
      {
        v11 = hkMemHeapAllocator();
        v12 = v42;
        if ( (_DWORD)v42 == (HIDWORD(v42) & 0x3FFFFFFF) )
        {
          hkArrayUtil::_reserveMore(v11, &array, 8);
          v12 = v42;
        }
        *(_QWORD *)&array[8 * v12] = v10;
        LODWORD(v42) = v42 + 1;
      }
      ++v8;
      ++v9;
    }
    while ( v8 < s_havokPhysicsXModels->m_size );
    v7 = v43;
  }
  Com_sprintf<256>((char (*)[256])dest, "XModels with ColLod not set");
  Physics_DrawDebugString(v7, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  v13 = tabWidth + *x;
  *x = v13;
  v14 = 0;
  v15 = v42;
  if ( (int)v42 > 1 )
  {
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)array, 0, v42 - 1, HavokPhysics_XModelsSortByName);
    v13 = *x;
    v15 = v42;
  }
  v16 = array;
  v17 = array;
  if ( array != &array[8 * v15] )
  {
    do
    {
      v18 = *(_QWORD *)v17;
      if ( (*(_BYTE *)(*(_QWORD *)v17 + 15i64) & 0xFD) != 0 && *(_BYTE *)(v18 + 11) != 8 )
      {
        Com_sprintf<256>((char (*)[256])dest, "%4i: XModel %s unexpectedly has no collLod", v14, *(const char **)v18);
        Physics_DrawDebugString(v7, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        ++v14;
        v15 = v42;
        v16 = array;
      }
      v17 += 8;
    }
    while ( v17 != &v16[8 * v15] );
    v13 = *x;
  }
  *x = v13 - tabWidth;
  Com_sprintf<256>((char (*)[256])dest, "XModels with collLod set to 0 - could be okay for very simple models, but usually should be a higher LOD");
  Physics_DrawDebugString(v7, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  v19 = tabWidth + *x;
  *x = v19;
  v20 = 0;
  v21 = array;
  v22 = array;
  v23 = v42;
  if ( array != &array[8 * (int)v42] )
  {
    do
    {
      v24 = *(_QWORD *)v22;
      v25 = *(_QWORD *)(*(_QWORD *)v22 + 640i64);
      if ( v25 )
        v26 = *(_DWORD *)(v25 + 8);
      else
        v26 = 0;
      v27 = v26 + 12;
      if ( !*(_BYTE *)(v24 + 11) && v27 > 0x400 )
      {
        LODWORD(fmt) = v27;
        Com_sprintf<256>((char (*)[256])dest, "%4i: XModel %s has collLod set to 0 using %i bytes", v20, *(const char **)v24, fmt);
        Physics_DrawDebugString(v7, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        ++v20;
        v23 = v42;
        v21 = array;
      }
      v22 += 8;
    }
    while ( v22 != &v21[8 * v23] );
    v19 = *x;
  }
  *x = v19 - tabWidth;
  Com_sprintf<256>((char (*)[256])dest, "XModels with expensive collLods - could be okay for vehicles or complex objects, but usually should be lower memory/triangle usage");
  Physics_DrawDebugString(v7, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  v28 = tabWidth + *x;
  *x = v28;
  v29 = 0;
  v30 = v42;
  if ( (int)v42 > 1 )
  {
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)array, 0, v42 - 1, HavokPhysics_XModelsSortByMemory);
    v28 = *x;
    v30 = v42;
  }
  v31 = array;
  v32 = array;
  if ( array != &array[8 * v30] )
  {
    do
    {
      v33 = *(_QWORD *)v32;
      v34 = *(_QWORD *)(*(_QWORD *)v32 + 640i64);
      if ( v34 )
        v35 = *(_DWORD *)(v34 + 8);
      else
        v35 = 0;
      v36 = v35 + 12;
      if ( v36 >= 0x19000 )
      {
        LODWORD(forceColor) = v36;
        LODWORD(fmta) = *(unsigned __int8 *)(v33 + 11);
        Com_sprintf<256>((char (*)[256])dest, "%4i: XModel %s has collLod %u with very large memory usage %i", v29, *(const char **)v33, fmta, forceColor);
        Physics_DrawDebugString(v7, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        ++v29;
        v30 = v42;
        v31 = array;
      }
      v32 += 8;
    }
    while ( v32 != &v31[8 * v30] );
    v28 = *x;
  }
  *x = v28 - tabWidth;
  v37 = hkMemHeapAllocator();
  LODWORD(v42) = 0;
  if ( v42 >= 0 )
    hkMemoryAllocator::bufFree2(v37, array, 8, HIDWORD(v42) & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawDebugDetailModel
==============
*/
void HavokPhysics_DrawDebugDetailModel(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  cg_t *LocalClientGlobals; 
  float v9; 
  float v10; 
  float v11; 
  XModel *adjust; 
  hkMemoryAllocator *v13; 
  void *v14; 
  int v15; 
  hkMemoryAllocator *v16; 
  int v17; 
  int v18; 
  void *v19; 
  unsigned int v20; 
  _BYTE *v21; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  unsigned __int8 *WeaponPriorityMap; 
  unsigned int RaycastHitBodyId; 
  const hknpCollisionResult *Hit; 
  const hknpCollisionResult *v26; 
  float v27; 
  float v28; 
  float v29; 
  const hknpCollisionResult *v30; 
  Physics_RefSystem RefSystem; 
  const Physics_DetailHitData *DetailHitData; 
  HavokPhysicsHitCollector_DetailTraceModifier *Modifier; 
  __int32 v34; 
  __int32 v35; 
  LocalClientNum_t LocalClientForWorld; 
  unsigned int RefId; 
  unsigned __int16 v38; 
  __int64 v39; 
  unsigned int v40; 
  char *v41; 
  DynEntityBasis v42; 
  __int64 v43; 
  unsigned __int16 v44; 
  unsigned __int16 v45; 
  DynEntityClient *v46; 
  float v47; 
  const char *name; 
  const char **p_name; 
  int partGroup; 
  const char *v51; 
  hkMemoryAllocator *v52; 
  hkMemoryAllocator *v53; 
  __int64 forceColor; 
  __int64 forceColora; 
  __int64 shadow; 
  DynEntityBasis basisOut[2]; 
  int ref; 
  unsigned __int16 clientIdOut[2]; 
  int numInOut; 
  int v61; 
  __int64 v62; 
  void *v63; 
  int v64; 
  int v65; 
  void *p; 
  int v67; 
  int v68; 
  __int64 v69; 
  __int16 v70; 
  int v71; 
  Physics_RaycastExtendedData extendedData; 
  __int64 v73; 
  vec3_t center; 
  vec3_t outPos; 
  vec3_t v76; 
  hkVector4f end; 
  hkVector4f start; 
  Weapon weapon; 
  char dest[256]; 

  v73 = -2i64;
  LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  v9 = LocalClientGlobals->refdef.view.axis.m[0].v[0];
  v10 = LocalClientGlobals->refdef.view.axis.m[0].v[1];
  v11 = LocalClientGlobals->refdef.view.axis.m[0].v[2];
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  start.m_quad.m128_f32[0] = 0.03125 * outPos.v[0];
  start.m_quad.m128_f32[1] = 0.03125 * outPos.v[1];
  start.m_quad.m128_f32[2] = 0.03125 * outPos.v[2];
  start.m_quad.m128_f32[3] = 0.0;
  end.m_quad.m128_f32[0] = (float)((float)(3000.0 * v9) + outPos.v[0]) * 0.03125;
  end.m_quad.m128_f32[1] = (float)((float)(3000.0 * v10) + outPos.v[1]) * 0.03125;
  end.m_quad.m128_f32[2] = (float)((float)(3000.0 * v11) + outPos.v[2]) * 0.03125;
  end.m_quad.m128_f32[3] = 0.0;
  adjust = NULL;
  LODWORD(v62) = 0;
  v63 = NULL;
  v64 = 0;
  v65 = 0x80000000;
  numInOut = 1;
  v13 = hkMemHeapAllocator();
  v14 = hkMemoryAllocator::bufAlloc2(v13, 8, &numInOut);
  v15 = 0x80000000;
  if ( numInOut )
    v15 = numInOut;
  v63 = v14;
  v64 = 1;
  v65 = v15;
  p = NULL;
  v67 = 0;
  v68 = 0x80000000;
  v61 = 0;
  v16 = hkMemHeapAllocator();
  v17 = v61;
  v18 = v61;
  if ( v61 )
  {
    v19 = hkMemoryAllocator::bufAlloc2(v16, 4, &v61);
    v17 = v61;
  }
  else
  {
    v19 = NULL;
  }
  v20 = 0x80000000;
  if ( v17 )
    v20 = v17;
  p = v19;
  v67 = v18;
  v68 = v20;
  v69 = 0i64;
  v70 = 0;
  v71 = 32;
  if ( !v64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 801, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( m_ignoreEntities.getSize() )", "index doesn't index m_ignoreEntities.getSize()\n\t%i not in [0, %i)", 0, 0) )
    __debugbreak();
  v21 = v63;
  *(_DWORD *)v63 = 0;
  v21[4] |= 0x1Fu;
  extendedData.collisionBuffer = 0.0;
  extendedData.phaseSelection = All;
  extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
  *(_WORD *)&extendedData.collectInsideHits = 256;
  extendedData.contents = -1;
  extendedData.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_DETAIL;
  extendedData.ignoreBodies = (HavokPhysics_IgnoreBodies *)&v62;
  ClosestResult = PhysicsQuery_GetClosestResult(PHYSICS_WORLD_ID_CLIENT0_DETAIL);
  if ( !ClosestResult->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 890, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::Reset(ClosestResult->m_collector, 1);
  memset(&weapon, 0, 48);
  *(double *)&weapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
  *(_DWORD *)&weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  weapon.weaponIdx = 0;
  WeaponPriorityMap = BG_GetWeaponPriorityMap(&weapon, 0);
  HavokPhysics_AddDetailTrace(ClosestResult, WeaponPriorityMap);
  HavokPhysics_Raycast(PHYSICS_WORLD_ID_CLIENT0_DETAIL, &start, &end, &extendedData, ClosestResult);
  if ( !HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) || (RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(ClosestResult, 0), !Physics_IsRigidBodyValid(PHYSICS_WORLD_ID_CLIENT0_DETAIL, RaycastHitBodyId)) )
  {
    Com_sprintf<256>((char (*)[256])dest, "No Hits");
    goto LABEL_78;
  }
  if ( !HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult) )
  {
    LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult);
    LODWORD(forceColor) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1051, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
      __debugbreak();
  }
  Hit = HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0);
  center.v[0] = 32.0 * Hit->m_position.m_quad.m128_f32[0];
  center.v[1] = 32.0 * Hit->m_position.m_quad.m128_f32[1];
  center.v[2] = 32.0 * Hit->m_position.m_quad.m128_f32[2];
  if ( !HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult) )
  {
    LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult);
    LODWORD(forceColor) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1058, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
      __debugbreak();
  }
  v26 = HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0);
  v27 = v26->m_normal.m_quad.m128_f32[0];
  v28 = v26->m_normal.m_quad.m128_f32[1];
  v29 = v26->m_normal.m_quad.m128_f32[2];
  if ( !HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult) )
  {
    LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(ClosestResult);
    LODWORD(forceColor) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1075, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
      __debugbreak();
  }
  v30 = HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0);
  ref = HavokPhysics_GetRef(ClosestResult->m_worldId, v30->m_hitBodyInfo.m_bodyId);
  RefSystem = Physics_GetRefSystem(ref);
  DetailHitData = NULL;
  if ( HavokPhysicsHitCollector::HasModifiers(ClosestResult->m_collector) )
  {
    Modifier = (HavokPhysicsHitCollector_DetailTraceModifier *)HavokPhysicsHitCollector::GetModifier(ClosestResult->m_collector, 0);
    if ( !Modifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23557, ASSERT_TYPE_ASSERT, "(dtModifier)", (const char *)&queryFormat, "dtModifier") )
      __debugbreak();
    DetailHitData = HavokPhysicsHitCollector_DetailTraceModifier::GetDetailHitData(Modifier, 0);
  }
  CG_DebugSphere(&center, 5.0, &colorGreen, 0, 0);
  v76.v[0] = (float)(v27 * 12.0) + center.v[0];
  v76.v[1] = (float)(v28 * 12.0) + center.v[1];
  v76.v[2] = (float)(v29 * 12.0) + center.v[2];
  CG_DebugLine(&center, &v76, &colorGreen, 0, 0);
  if ( RefSystem == Physics_RefSystem_WorldGeo )
  {
    Com_sprintf<256>((char (*)[256])dest, "World Geo or Misc Model");
    adjust = NULL;
    v47 = charHeight;
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
LABEL_76:
    Com_sprintf<256>((char (*)[256])dest, "No Model found");
    goto LABEL_79;
  }
  v34 = RefSystem - 1;
  if ( v34 )
  {
    v35 = v34 - 3;
    if ( v35 )
    {
      if ( v35 != 6 )
      {
        Com_sprintf<256>((char (*)[256])dest, "Model extraction failed");
        adjust = NULL;
LABEL_78:
        v47 = charHeight;
        goto LABEL_79;
      }
      LocalClientForWorld = Physics_GetLocalClientForWorld(PHYSICS_WORLD_ID_CLIENT0_DETAIL);
      if ( LocalClientForWorld == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23644, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      RefId = Physics_GetRefId(ref);
      adjust = (XModel *)CG_ClientModel_GetModel(LocalClientForWorld, RefId, 0);
      Com_sprintf<256>((char (*)[256])dest, "Client Model %u", RefId);
    }
    else
    {
      v38 = Physics_GetRefId(ref);
      v39 = v38;
      if ( v38 >= 0x9E5u )
      {
        LODWORD(shadow) = v38;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 55, ASSERT_TYPE_ASSERT, "( ( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) ) )", "%s\n\t( handle ) = %i", "( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) )", shadow) )
          __debugbreak();
      }
      if ( (unsigned int)v39 >= 0x13CA )
      {
        LODWORD(shadow) = v39;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 62, ASSERT_TYPE_ASSERT, "( ( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) ) )", "%s\n\t( handle ) = %i", "( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) )", shadow) )
          __debugbreak();
      }
      v40 = clientObjMap[v39];
      if ( clientObjMap[v39] )
      {
        if ( v40 >= (unsigned int)s_objCount )
        {
          LODWORD(shadow) = clientObjMap[v39];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 64, ASSERT_TYPE_ASSERT, "( ( !objIndex || ( (unsigned)objIndex < s_objCount ) ) )", "%s\n\t( objIndex ) = %i", "( !objIndex || ( (unsigned)objIndex < s_objCount ) )", shadow) )
            __debugbreak();
        }
        v41 = s_objBuf[v40];
        if ( v41 && v41[15] )
          adjust = (XModel *)**((_QWORD **)v41 + 30);
      }
      Com_sprintf<256>((char (*)[256])dest, "CEntity %u", (unsigned int)v39);
    }
  }
  else
  {
    DynEnt_GetBasisAndDynEntClientId(ref, basisOut, clientIdOut);
    v42 = basisOut[0];
    LOWORD(ref) = clientIdOut[0];
    if ( basisOut[0] >= DYNENT_BASIS_COUNT )
    {
      LODWORD(shadow) = 2;
      LODWORD(forceColor) = (unsigned __int8)basisOut[0];
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 323, ASSERT_TYPE_ASSERT, "(unsigned)( basis ) < (unsigned)( DYNENT_BASIS_COUNT )", "basis doesn't index DYNENT_BASIS_COUNT\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    v43 = (unsigned __int8)v42;
    v44 = g_dynEntClientEntsAllocCount[0][(unsigned __int8)v42];
    v45 = ref;
    if ( (unsigned __int16)ref >= v44 )
    {
      LODWORD(shadow) = v44;
      LODWORD(forceColor) = (unsigned __int16)ref;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 324, ASSERT_TYPE_ASSERT, "(unsigned)( clientId ) < (unsigned)( g_dynEntClientEntsAllocCount[localClientNum][basis] )", "clientId doesn't index g_dynEntClientEntsAllocCount[localClientNum][basis]\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( !g_dynEntClientLists[0][v43] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\dynentity\\dynentity_client.h", 325, ASSERT_TYPE_ASSERT, "(g_dynEntClientLists[localClientNum][basis])", (const char *)&queryFormat, "g_dynEntClientLists[localClientNum][basis]") )
      __debugbreak();
    v46 = &g_dynEntClientLists[0][v43][v45];
    if ( !v46 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23613, ASSERT_TYPE_ASSERT, "(dynEntClient)", (const char *)&queryFormat, "dynEntClient") )
      __debugbreak();
    adjust = (XModel *)v46->activeModel;
    Com_sprintf<256>((char (*)[256])dest, "Dynent %i %u", (unsigned __int8)basisOut[0], v46->dynEntDefId);
  }
  v47 = charHeight;
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  if ( !adjust )
    goto LABEL_76;
  name = adjust->name;
  if ( adjust->detailCollision )
  {
    Com_sprintf<256>((char (*)[256])dest, "XModel %s with colLod %i", name, adjust->collLod);
  }
  else
  {
    p_name = &adjust->physicsAsset->name;
    if ( p_name )
      Com_sprintf<256>((char (*)[256])dest, "XModel %s with physasset %s", name, *p_name);
    else
      Com_sprintf<256>((char (*)[256])dest, "XModel %s from unknown source", name);
  }
  adjust = NULL;
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  if ( DetailHitData && DetailHitData->isValid )
  {
    partGroup = DetailHitData->partGroup;
    v51 = SL_ConvertToString(DetailHitData->partName);
    LODWORD(forceColora) = partGroup;
    Com_sprintf<256>((char (*)[256])dest, "ModelIndex %i, PartName %i %s, PartGroup %i", DetailHitData->modelIndex, (unsigned int)DetailHitData->partName, v51, forceColora);
LABEL_79:
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, (int)adjust, 1, v47, (int)adjust);
    *y = v47 + *y;
  }
  v52 = hkMemHeapAllocator();
  v67 = (int)adjust;
  if ( v68 >= 0 )
    hkMemoryAllocator::bufFree2(v52, p, 4, v68 & 0x3FFFFFFF);
  p = adjust;
  v68 = 0x80000000;
  v53 = hkMemHeapAllocator();
  v64 = (int)adjust;
  if ( v65 >= 0 )
    hkMemoryAllocator::bufFree2(v53, v63, 8, v65 & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawDebugGeneralCPU
==============
*/
void HavokPhysics_DrawDebugGeneralCPU(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  char dest[256]; 

  Com_sprintf<256>((char (*)[256])dest, "General:    No current data");
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
}

/*
==============
HavokPhysics_DrawDebugGeneralMemory
==============
*/
void HavokPhysics_DrawDebugGeneralMemory(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v8; 
  unsigned int v9; 
  HavokPhysicsLargeBlockAllocator *v10; 
  unsigned int v11; 
  char v12[32]; 
  char v13[32]; 
  char buffer[32]; 
  char dest[256]; 

  if ( !s_havokPhysicsGeneralLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17002, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralLargeBlockAllocator)", "%s\n\tHavokPhysics DrawDebugGeneralMemory: general memory allocator is NULL", "s_havokPhysicsGeneralLargeBlockAllocator") )
    __debugbreak();
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17003, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMapLocalLargeBlockAllocator)", "%s\n\tHavokPhysics DrawDebugGeneralMemory: map local memory allocator is NULL", "s_havokPhysicsMapLocalLargeBlockAllocator") )
    __debugbreak();
  v8 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  v9 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  Physics_DebugIntToString(buffer, 32, v8);
  Physics_DebugIntToString(v13, 32, s_generalMemoryPeakInUse);
  Physics_DebugIntToString(v12, 32, s_generalMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "General:    Current:%10s Max:%10s Capacity:%10s", buffer, v13, v12);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Physics_DebugIntToString(buffer, 32, v9);
  Physics_DebugIntToString(v13, 32, s_mapLocalMemoryPeakInUse);
  Physics_DebugIntToString(v12, 32, s_mapLocalMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "Map Local:  Current:%10s Max:%10s Capacity:%10s", buffer, v13, v12);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  v10 = s_havokPhysicsDebugMemoryAllocator;
  v11 = 0;
  *y = charHeight + *y;
  if ( v10 )
    v11 = v10->getApproxTotalAllocated(&v10->hkMemoryAllocator::ExtendedInterface);
  Physics_DebugIntToString(buffer, 32, v11);
  Physics_DebugIntToString(v13, 32, s_debugMemoryPeakInUse);
  Physics_DebugIntToString(v12, 32, s_debugMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "Debug:      Current:%10s Max:%10s Capacity:%10s", buffer, v13, v12);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
}

/*
==============
HavokPhysics_DrawDebugGetClosestPoints
==============
*/
void HavokPhysics_DrawDebugGetClosestPoints(Physics_WorldId worldId, const hkVector4f *position, float maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v9; 
  __int64 v11; 
  const ScreenPlacement *v12; 
  float *v13; 
  HavokPhysicsWorld *MutableWorld; 
  bool v15; 
  int v16; 
  int v17; 
  __int64 v18; 
  float v19; 
  float v20; 
  float v21; 
  int integer; 
  int v23; 
  unsigned int v24; 
  HavokPhysics_CollisionQueryResult *v25; 
  const vec4_t *v26; 
  float v27; 
  float v28; 
  unsigned int ClosestPointHitBodyId; 
  const char *v30; 
  HavokPhysics_CollisionQueryResult *v31; 
  double ClosestPointHitDistance; 
  unsigned int ClosestPointHitHitShapeKey; 
  int ClosestPointHitHitMaterialId; 
  unsigned int ClosestPointHitHitContents; 
  hknpBodyId v36; 
  __int64 forceColor; 
  __int64 shadow; 
  __int64 v39; 
  __int64 adjust; 
  __int64 v41; 
  signed int contentsa; 
  HavokPhysics_CollisionQueryResult *v44; 
  int numInOut; 
  unsigned int v46; 
  Physics_WorldId v47; 
  ScreenPlacement *v48; 
  float *v49; 
  HavokPhysicsWorld *v50; 
  __m256i v51; 
  double v52; 
  __int64 v53; 
  vec3_t center; 
  vec3_t pos; 
  vec3_t end; 
  char dest[256]; 
  char text[256]; 

  v53 = -2i64;
  v9 = collisionFilterInfo;
  v11 = worldId;
  v47 = worldId;
  v12 = scrPlace;
  v48 = (ScreenPlacement *)scrPlace;
  v13 = x;
  v49 = x;
  *(float *)&v51.m256i_i32[4] = 0.0;
  v51.m256i_i64[3] = 0i64;
  LODWORD(v52) = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23353, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugGetClosestPoints with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v11);
  v50 = MutableWorld;
  if ( dword_150D5FA60 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA60);
    if ( dword_150D5FA60 == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      ignoreBodies_4.m_ignoreEntities.m_data = NULL;
      ignoreBodies_4.m_ignoreEntities.m_size = 0;
      ignoreBodies_4.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_4.m_ignoreBodies.m_data = NULL;
      ignoreBodies_4.m_ignoreBodies.m_size = 0;
      ignoreBodies_4.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      LODWORD(v44) = 0;
      hkMemHeapAllocator();
      v46 = 0;
      ignoreBodies_4.m_ignoreBodies.m_data = NULL;
      ignoreBodies_4.m_ignoreBodies.m_size = 0;
      ignoreBodies_4.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_4.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_4.m_isClutter = 0;
      ignoreBodies_4.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugGetClosestPoints_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA60);
      v9 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v15 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_4.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v15) )
    ignoreBodies_4.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  v51.m256i_i32[0] = v9;
  v51.m256i_i8[4] = 1;
  v51.m256i_i64[1] = (__int64)&ignoreBodies_4;
  v16 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v11];
  if ( v16 == -1 )
  {
    if ( MutableWorld->requestDebugGetClosestPoints && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23370, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugGetClosestPoints)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugGetClosestPoints") )
      __debugbreak();
    s_havokPhysicsWorldGetClosestPointsActiveIndices[v11] = 0;
    MutableWorld->debugGetClosestPointsPoint = (hkVector4f)position->m_quad;
    MutableWorld->debugGetClosestPointsRotation.m_vec.m_quad = g_vectorfConstants[35];
    MutableWorld->debugGetClosestMaxDistance = maxDistance;
    *(__m256i *)&MutableWorld->debugGetClosestPointsExtendedData.contents = v51;
    *(double *)&MutableWorld->debugGetClosestPointsExtendedData.phaseSelection = v52;
    MutableWorld->requestDebugGetClosestPoints = 1;
    return;
  }
  v17 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v11];
  if ( !MutableWorld->requestDebugGetClosestPoints && s_havokPhysicsWorldGetClosestPointsData[2 * (int)v11 + v16].isComplete )
  {
    s_havokPhysicsWorldGetClosestPointsActiveIndices[v11] = 1 - v16;
    HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldGetClosestPointsData[2 * (int)v11 + 1 - v16].result, 1);
    MutableWorld->debugGetClosestPointsPoint = (hkVector4f)position->m_quad;
    MutableWorld->debugGetClosestPointsRotation.m_vec.m_quad = g_vectorfConstants[35];
    MutableWorld->debugGetClosestMaxDistance = maxDistance;
    *(__m256i *)&MutableWorld->debugGetClosestPointsExtendedData.contents = v51;
    *(double *)&MutableWorld->debugGetClosestPointsExtendedData.phaseSelection = v52;
    MutableWorld->requestDebugGetClosestPoints = 1;
    v17 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v11];
  }
  if ( v17 != -1 )
  {
    v18 = 3i64 * (2 * (int)v11 - v17) + 3;
    if ( *(&s_havokPhysicsWorldGetClosestPointsData[0].isComplete + 8 * v18) )
    {
      v19 = position->m_quad.m128_f32[0] * 32.0;
      center.v[0] = v19;
      v20 = position->m_quad.m128_f32[1] * 32.0;
      center.v[1] = v20;
      v21 = position->m_quad.m128_f32[2] * 32.0;
      center.v[2] = v21;
      integer = 0xFFFFFF;
      if ( physics_debugQueryBody->current.integer >= 0 )
        integer = physics_debugQueryBody->current.integer;
      if ( (integer & 0xFFFFFF) != 0xFFFFFF )
      {
        v23 = ((__int64 (__fastcall *)(hknpWorldReader *))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader);
        v19 = center.v[0];
        if ( v23 )
        {
          Com_sprintf<256>((char (*)[256])dest, "Get Closest Points in body %i %s against sphere of radius %.2f at (%.2f, %.2f, %.2f) with maxDistance %.2f", physics_debugQueryBody->current.unsignedInt, (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), DOUBLE_12_0, center.v[0], center.v[1], center.v[2], maxDistance);
LABEL_25:
          v24 = 0;
          Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
          *y = charHeight + *y;
          *x = tabWidth + *x;
          HavokPhysics_DrawPhysicsContents(collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
          *x = *x - tabWidth;
          v25 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldGetClosestPointsData[0].result + v18);
          v44 = v25;
          CG_DebugSphere(&center, 12.0, &colorRed, 0, 0);
          if ( (float)(maxDistance * 32.0) <= 0.5 )
          {
            v26 = &colorYellow;
            v27 = FLOAT_5_0;
          }
          else
          {
            v26 = &colorGreen;
            v27 = maxDistance * 32.0;
          }
          CG_DebugSphere(&center, v27, v26, 0, 0);
          contentsa = HavokPhysics_CollisionQueryResult::GetNumHits(v25);
          Com_sprintf<256>((char (*)[256])dest, "Results - %i hits", (unsigned int)contentsa);
          Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
          *y = charHeight + *y;
          v28 = tabWidth + *x;
          *x = v28;
          if ( contentsa > 0 )
          {
            do
            {
              ClosestPointHitBodyId = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v25, v24);
              v46 = ClosestPointHitBodyId;
              if ( Physics_IsRigidBodyValid((Physics_WorldId)v11, ClosestPointHitBodyId) )
              {
                v30 = (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[ClosestPointHitBodyId & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
                v31 = v44;
                HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(v44, v24, &pos);
                HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(v31, v24, &end);
                ClosestPointHitDistance = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(v31, v24);
                ClosestPointHitHitShapeKey = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(v31, v24);
                ClosestPointHitHitMaterialId = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(v31, v24);
                ClosestPointHitHitContents = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(v31, v24);
                LODWORD(v31) = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(v31, v24);
                v36.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v44, v24);
                LODWORD(v41) = HavokPhysics_GetRef(v44->m_worldId, v36);
                LODWORD(adjust) = (_DWORD)v31;
                LODWORD(v39) = ClosestPointHitHitContents;
                LODWORD(shadow) = ClosestPointHitHitMaterialId;
                LODWORD(forceColor) = ClosestPointHitHitShapeKey;
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v24, v46, v30, forceColor, shadow, v39, adjust, v41);
                v13 = v49;
                Physics_DrawDebugString(v48, *v49, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
                CG_DebugSphere(&pos, 5.0, &colorRed, 0, 0);
                CG_DebugLine(&pos, &end, &colorRed, 0, 0);
                Com_sprintf(text, 0x100ui64, "%s %.2f", v30, *(float *)&ClosestPointHitDistance);
                CL_AddDebugString(&pos, &colorRed, 1.0, text, 0, 0);
                MutableWorld = v50;
                LODWORD(v11) = v47;
                v12 = v48;
              }
              else
              {
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v24, ClosestPointHitBodyId);
                Physics_DrawDebugString(v12, *v13, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              ++v24;
              v25 = v44;
            }
            while ( (int)v24 < contentsa );
            v28 = *v13;
          }
          *v13 = v28 - tabWidth;
          return;
        }
        v21 = center.v[2];
        v20 = center.v[1];
      }
      Com_sprintf<256>((char (*)[256])dest, "Get Closest Points against sphere of radius %.2f at (%.2f, %.2f, %.2f) with maxDistance %.2f", DOUBLE_12_0, v19, v20, v21, maxDistance);
      goto LABEL_25;
    }
  }
}

/*
==============
HavokPhysics_DrawDebugMutableShapesInWorld
==============
*/
void HavokPhysics_DrawDebugMutableShapesInWorld(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, Physics_WorldId worldId, float detailRange)
{
  Physics_WorldId v7; 
  unsigned int v8; 
  unsigned int v9; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  float v11; 
  float v12; 
  float v13; 
  __int64 v14; 
  const char **p_name; 
  char v16; 
  unsigned int NumRigidBodys; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *v19; 
  unsigned int m_serialAndIndex; 
  _BYTE *v21; 
  bool v22; 
  const HavokPhysicsWorld *v23; 
  const HavokPhysicsInstanceManager *v24; 
  unsigned int v25; 
  const char *v26; 
  unsigned int v27; 
  const HavokPhysicsWorld *v28; 
  const HavokPhysicsInstanceManager *v29; 
  unsigned int v30; 
  __int64 v31; 
  const hkTransformf *v32; 
  __int64 v33; 
  __int64 v34; 
  hknpWorld *world; 
  const tmat34_t<vec4_t> *v36; 
  const char *v37; 
  int v38; 
  int v39; 
  unsigned __int16 v40; 
  unsigned int v41; 
  const vec4_t *v42; 
  const vec4_t *v43; 
  const hkStringPtr *m_data; 
  hkHashBase<hkHashMapDetail::MapTuple<unsigned __int64,int> > *p_m_mutableShapeLookup; 
  const char *v46; 
  hkHashMapDetail::Entry *Entry; 
  int v48; 
  int v49; 
  int m_1; 
  int v51; 
  __int64 v52; 
  __int64 v53; 
  __int64 v54; 
  unsigned int i; 
  unsigned int v56; 
  unsigned int v57; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v59; 
  unsigned __int16 v60; 
  unsigned __int16 v61; 
  hknpBodyId result; 
  hknpBodyId bodyId; 
  hknpBodyId v64; 
  Physics_WorldId v65; 
  hkStringPtr v66; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const char *v68; 
  __int64 v69; 
  __int64 v70; 
  unsigned __int64 item; 
  const hkTransformf *v72; 
  __int64 v73; 
  vec3_t outPos; 
  vec3_t xyz; 
  vec3_t position; 
  vec4_t orientation; 
  vec4_t out; 
  hkTransformf v79; 
  hkTransformf transformOut; 

  v73 = -2i64;
  v7 = worldId;
  v65 = worldId;
  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23804, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to DrawDebugMutableShapesInWorld when system is not initialized", "g_physicsInitialized") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23805, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to DrawDebugMutableShapesInWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v53) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23809, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics DrawDebugMutableShapesInWorld %i: world is NULL", "havokPhysicsWorld->world", v53) )
      __debugbreak();
  }
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  v8 = 0;
  v9 = 0;
  v57 = 0;
  if ( MutableWorld->instanceManager.capacity )
  {
    p_instanceManager = &MutableWorld->instanceManager;
    v11 = outPos.v[2];
    v12 = outPos.v[1];
    v13 = outPos.v[0];
    do
    {
      if ( HavokPhysicsInstanceManager_IsInstanceInUse(p_instanceManager, v9) )
      {
        v14 = v9;
        v69 = v14 * 80;
        p_name = &p_instanceManager->buffer[v14].physicsAsset->name;
        if ( p_name )
        {
          HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(p_instanceManager->buffer[v14].physicsAsset);
          if ( HavokPhysicsAsset )
          {
            v16 = 0;
            if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 71, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies when system is not initialized", "g_physicsInitialized") )
              __debugbreak();
            if ( (unsigned int)v7 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
            {
              LODWORD(v53) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 72, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v53) )
                __debugbreak();
            }
            if ( v9 == -1 )
            {
              LODWORD(v53) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 73, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies with invalid Instance in world %i", "instanceId != PHYSICSINSTANCEID_INVALID", v53) )
                __debugbreak();
            }
            if ( !g_physicsClientWorldsCreated && (unsigned int)(v7 - 2) <= 5 )
            {
              LODWORD(v53) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 74, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v53) )
                __debugbreak();
            }
            if ( !g_physicsServerWorldsCreated && (unsigned int)v7 <= PHYSICS_WORLD_ID_SERVER_DETAIL )
            {
              LODWORD(v53) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 75, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Number of Rigid Bodies in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v53) )
                __debugbreak();
            }
            NumRigidBodys = HavokPhysics_GetNumRigidBodys(v7, v9);
            v56 = NumRigidBodys;
            do
            {
              if ( v8 >= NumRigidBodys )
              {
                v8 = 0;
                goto LABEL_173;
              }
              if ( (unsigned int)v7 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
              {
                LODWORD(v53) = v7;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v53) )
                  __debugbreak();
              }
              if ( v9 == -1 )
              {
                LODWORD(v53) = v7;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v53) )
                  __debugbreak();
              }
              ConstWorld = HavokPhysics_GetConstWorld(v7);
              if ( !ConstWorld->world )
              {
                LODWORD(v53) = v7;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v53) )
                  __debugbreak();
              }
              v19 = &ConstWorld->instanceManager;
              if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
                __debugbreak();
              if ( v9 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
                __debugbreak();
              if ( v8 >= v19->buffer[v14].bodies.m_size )
              {
                LODWORD(v54) = v7;
                LODWORD(v53) = v8;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v53, v54) )
                  __debugbreak();
              }
              HavokPhysicsInstanceManager_GetBodyId(&result, v19, v9, v8);
              m_serialAndIndex = result.m_serialAndIndex;
              if ( !HavokPhysics_IsRigidBodyValid(v7, result) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23843, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsRigidBodyValid( worldId, bodyId ))", (const char *)&queryFormat, "HavokPhysics_IsRigidBodyValid( worldId, bodyId )") )
                __debugbreak();
              v21 = *(_BYTE **)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, m_serialAndIndex) + 96);
              v22 = v21[26] == 18 && (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)v21 + 24i64))(v21);
              ++v8;
              v16 |= v22;
              NumRigidBodys = v56;
            }
            while ( !v16 );
            if ( (unsigned int)v7 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
            {
              LODWORD(v53) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v53) )
                __debugbreak();
            }
            if ( v9 == -1 )
            {
              LODWORD(v53) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v53) )
                __debugbreak();
            }
            v23 = HavokPhysics_GetConstWorld(v7);
            if ( !v23->world )
            {
              LODWORD(v53) = v7;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v53) )
                __debugbreak();
            }
            v24 = &v23->instanceManager;
            if ( !v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
              __debugbreak();
            if ( v9 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
              __debugbreak();
            v8 = 0;
            if ( !v24->buffer[v14].bodies.m_size )
            {
              LODWORD(v54) = v7;
              LODWORD(v53) = 0;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v53, v54) )
                __debugbreak();
            }
            HavokPhysicsInstanceManager_GetBodyId(&bodyId, v24, v9, 0);
            v25 = bodyId.m_serialAndIndex;
            if ( !HavokPhysics_IsRigidBodyValid(v7, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23859, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsRigidBodyValid( worldId, body0Id ))", (const char *)&queryFormat, "HavokPhysics_IsRigidBodyValid( worldId, body0Id )") )
              __debugbreak();
            Physics_GetRigidBodyTransform(v7, v25, &position, &orientation);
            if ( (float)(detailRange * detailRange) <= (float)((float)((float)((float)(position.v[1] - v12) * (float)(position.v[1] - v12)) + (float)((float)(position.v[0] - v13) * (float)(position.v[0] - v13))) + (float)((float)(position.v[2] - v11) * (float)(position.v[2] - v11))) )
            {
              CL_AddDebugString(&position, &colorCyan, 0.25, *p_name, 0, 0);
            }
            else
            {
              v26 = *p_name;
              v68 = v26;
              v27 = 0;
              for ( i = 0; v27 < v56; v9 = v57 )
              {
                if ( (unsigned int)v7 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
                {
                  LODWORD(v53) = v7;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v53) )
                    __debugbreak();
                }
                if ( v9 == -1 )
                {
                  LODWORD(v53) = v7;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v53) )
                    __debugbreak();
                }
                v28 = HavokPhysics_GetConstWorld(v7);
                if ( !v28->world )
                {
                  LODWORD(v53) = v7;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v53) )
                    __debugbreak();
                }
                v29 = &v28->instanceManager;
                if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
                  __debugbreak();
                if ( v9 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
                  __debugbreak();
                if ( v27 >= *(int *)((char *)&v29->buffer->bodies.m_size + v69) )
                {
                  LODWORD(v54) = v7;
                  LODWORD(v53) = v27;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v53, v54) )
                    __debugbreak();
                }
                HavokPhysicsInstanceManager_GetBodyId(&v64, v29, v9, v27);
                v30 = v64.m_serialAndIndex;
                if ( !HavokPhysics_IsRigidBodyValid(v7, v64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23876, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsRigidBodyValid( worldId, bodyId ))", (const char *)&queryFormat, "HavokPhysics_IsRigidBodyValid( worldId, bodyId )") )
                  __debugbreak();
                v31 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, v30);
                v32 = (const hkTransformf *)v31;
                v72 = (const hkTransformf *)v31;
                v33 = *(_QWORD *)(v31 + 96);
                if ( *(_BYTE *)(v33 + 26) == 18 && (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v33 + 24i64))(*(_QWORD *)(v31 + 96)) )
                {
                  v34 = *(_QWORD *)(v33 + 56);
                  v59 = v34;
                  if ( *(_BYTE *)(v34 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23890, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
                    __debugbreak();
                  v70 = *(_QWORD *)(v33 + 64);
                  if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 260, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body Transform when system is not initialized", "g_physicsInitialized") )
                    __debugbreak();
                  if ( (unsigned int)v7 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
                  {
                    LODWORD(v53) = v7;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 261, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v53) )
                      __debugbreak();
                  }
                  if ( (v30 & 0xFFFFFF) == 0xFFFFFF )
                  {
                    LODWORD(v53) = v7;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 262, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyId ))", "%s\n\tPhysics: Trying to Get Rigid Body Transform with invalid Body in world %i", "Physics_IsRigidBodyIdValid( bodyId )", v53) )
                      __debugbreak();
                  }
                  if ( !g_physicsClientWorldsCreated && (unsigned int)(v7 - 2) <= 5 )
                  {
                    LODWORD(v53) = v7;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 263, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Transform in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", v53) )
                      __debugbreak();
                  }
                  if ( !g_physicsServerWorldsCreated && (unsigned int)v7 <= PHYSICS_WORLD_ID_SERVER_DETAIL )
                  {
                    LODWORD(v53) = v7;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 264, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body Transform in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", v53) )
                      __debugbreak();
                  }
                  if ( (unsigned int)v7 > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
                  {
                    LODWORD(v53) = v7;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 345, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v53) )
                      __debugbreak();
                  }
                  if ( (v30 & 0xFFFFFF) == 0xFFFFFF )
                  {
                    LODWORD(v53) = v7;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 346, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid body id for world %i", "bodyId.isValid()", v53) )
                      __debugbreak();
                  }
                  world = HavokPhysics_GetConstWorld(v7)->world;
                  if ( !world )
                  {
                    LODWORD(v53) = v7;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 350, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v53) )
                      __debugbreak();
                  }
                  v36 = (const tmat34_t<vec4_t> *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, v30);
                  xyz.v[0] = 32.0 * v36[1].m[0].v[0];
                  xyz.v[1] = 32.0 * v36[1].m[0].v[1];
                  xyz.v[2] = 32.0 * v36[1].m[0].v[2];
                  Axis34ToQuat(v36, &out);
                  v37 = j_va("%s:%s", v26, (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[v30 & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                  v8 = 0;
                  CL_AddDebugString(&xyz, &colorWhite, 0.25, v37, 0, 0);
                  if ( v27 )
                    CL_AddDebugLine(&xyz, &position, &colorWhite, 0, 0, 0);
                  v38 = *(_DWORD *)(v34 + 80);
                  v39 = 0;
                  v60 = 0;
                  if ( v38 <= 0 )
                  {
LABEL_142:
                    v39 = -1;
                    v40 = -1;
                  }
                  else
                  {
                    while ( 1 )
                    {
                      v40 = v60;
                      if ( !*(_BYTE *)(112i64 * v60 + *(_QWORD *)(v34 + 72) + 92) )
                        break;
                      v60 = ++v39;
                      if ( v39 >= v38 )
                        goto LABEL_142;
                    }
                  }
                  if ( v39 != -1 )
                  {
                    do
                    {
                      hknpShapeInstance::getFullTransform((hknpShapeInstance *)(*(_QWORD *)(v34 + 72) + 112i64 * v40), &transformOut);
                      hkTransformf::setMul(&v79, v32, &transformOut);
                      outPos.v[0] = 32.0 * v79.m_translation.m_quad.m128_f32[0];
                      outPos.v[1] = 32.0 * v79.m_translation.m_quad.m128_f32[1];
                      outPos.v[2] = 32.0 * v79.m_translation.m_quad.m128_f32[2];
                      v41 = v40;
                      v42 = &colorRed;
                      v43 = &colorRedFaded;
                      if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v70 + 32i64))(v70, (0xFFFFFFFF >> *(_BYTE *)(v34 + 27)) | (v40 << (32 - *(_BYTE *)(v34 + 27)))) )
                      {
                        v42 = &colorGreen;
                        v43 = &colorGreenFaded;
                      }
                      m_data = HavokPhysicsAsset->m_mutableShapeNames.m_data;
                      if ( m_data == &m_data[HavokPhysicsAsset->m_mutableShapeNames.m_size] )
                        goto LABEL_156;
                      p_m_mutableShapeLookup = &HavokPhysicsAsset->m_mutableShapeLookup;
                      while ( 1 )
                      {
                        hkStringPtr::hkStringPtr(&v66, m_data);
                        v46 = (const char *)((unsigned __int64)v66.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
                        item = hkHash::computeFNV1Hash32((const char *)((unsigned __int64)v66.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                        Entry = hkHashBase<hkHashMapDetail::MapTuple<unsigned __int64,int>>::_findEntry(p_m_mutableShapeLookup, &item);
                        v48 = Entry ? Entry->idx : -1;
                        if ( v48 >= 0 )
                        {
                          v49 = p_m_mutableShapeLookup->m_items.m_data[v48].m_1 >> 16;
                          m_1 = (unsigned __int16)p_m_mutableShapeLookup->m_items.m_data[v48].m_1;
                          if ( v49 == i && m_1 == v41 )
                            break;
                        }
                        hkStringPtr::~hkStringPtr(&v66);
                        if ( ++m_data == &HavokPhysicsAsset->m_mutableShapeNames.m_data[HavokPhysicsAsset->m_mutableShapeNames.m_size] )
                          goto LABEL_155;
                      }
                      hkStringPtr::~hkStringPtr(&v66);
                      if ( !v46 )
                      {
LABEL_155:
                        v34 = v59;
                        goto LABEL_156;
                      }
                      v52 = -1i64;
                      do
                        ++v52;
                      while ( v46[v52] );
                      v34 = v59;
                      if ( !v52 )
LABEL_156:
                        v46 = j_va("%i", v41);
                      v8 = 0;
                      CL_AddDebugString(&outPos, v42, 0.25, v46, 0, 0);
                      CL_AddDebugLine(&outPos, &xyz, v43, 0, 0, 0);
                      v51 = *(_DWORD *)(v34 + 80);
                      v61 = ++v39;
                      if ( v39 >= v51 )
                      {
LABEL_160:
                        v39 = -1;
                        v40 = -1;
                      }
                      else
                      {
                        while ( 1 )
                        {
                          v40 = v61;
                          if ( !*(_BYTE *)(112i64 * v61 + *(_QWORD *)(v34 + 72) + 92) )
                            break;
                          v61 = ++v39;
                          if ( v39 >= v51 )
                            goto LABEL_160;
                        }
                      }
                      v32 = v72;
                    }
                    while ( v39 != -1 );
                    v7 = v65;
                    v27 = i;
                  }
                  v26 = v68;
                }
                else
                {
                  v8 = 0;
                }
                i = ++v27;
              }
            }
LABEL_173:
            p_instanceManager = &MutableWorld->instanceManager;
          }
        }
      }
      v57 = ++v9;
    }
    while ( v9 < MutableWorld->instanceManager.capacity );
  }
}

/*
==============
HavokPhysics_DrawDebugPhysicsRefSystemCounts
==============
*/
void HavokPhysics_DrawDebugPhysicsRefSystemCounts(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int *refSystemCounts; 
  const char **v12; 
  char dest[256]; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17193, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DebugDrawPhysicsRefSystemCounts with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  *x = tabWidth + *x;
  refSystemCounts = (unsigned int *)MutableWorld->refSystemCounts;
  v12 = refSystemNames_0;
  do
  {
    Com_sprintf<256>((char (*)[256])dest, "%i %s", *refSystemCounts, *v12);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    ++v12;
    ++refSystemCounts;
    *y = charHeight + *y;
  }
  while ( (__int64)v12 < (__int64)&unk_147F9A828 );
  *x = *x - tabWidth;
}

/*
==============
HavokPhysics_DrawDebugQueryPoint
==============
*/
void HavokPhysics_DrawDebugQueryPoint(Physics_WorldId worldId, const hkVector4f *position, float maxDistance, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned int v9; 
  __int64 v11; 
  const ScreenPlacement *v12; 
  float *v13; 
  HavokPhysicsWorld *MutableWorld; 
  bool v15; 
  int v16; 
  int v17; 
  __int64 v18; 
  float v19; 
  float v20; 
  float v21; 
  int integer; 
  unsigned int v23; 
  HavokPhysics_CollisionQueryResult *v24; 
  const vec4_t *v25; 
  float v26; 
  float v27; 
  unsigned int ClosestPointHitBodyId; 
  const char *v29; 
  HavokPhysics_CollisionQueryResult *v30; 
  double ClosestPointHitDistance; 
  unsigned int ClosestPointHitHitShapeKey; 
  int ClosestPointHitHitMaterialId; 
  unsigned int ClosestPointHitHitContents; 
  hknpBodyId v35; 
  __int64 forceColor; 
  __int64 shadow; 
  __int64 v38; 
  __int64 adjust; 
  __int64 v40; 
  signed int contentsa; 
  HavokPhysics_CollisionQueryResult *v43; 
  int numInOut; 
  unsigned int v45; 
  Physics_WorldId v46; 
  ScreenPlacement *v47; 
  float *v48; 
  HavokPhysicsWorld *v49; 
  Physics_QueryPointExtendedData v50; 
  __int64 v51; 
  vec3_t center; 
  vec3_t pos; 
  vec3_t end; 
  char dest[256]; 
  char text[256]; 

  v51 = -2i64;
  v9 = collisionFilterInfo;
  v11 = worldId;
  v46 = worldId;
  v12 = scrPlace;
  v47 = (ScreenPlacement *)scrPlace;
  v13 = x;
  v48 = x;
  v50.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  v50.collisionBuffer = 0.0;
  v50.phaseSelection = All;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23203, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugQueryPoint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v11);
  v49 = MutableWorld;
  if ( dword_150D5FA5C > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA5C);
    if ( dword_150D5FA5C == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      ignoreBodies_3.m_ignoreEntities.m_data = NULL;
      ignoreBodies_3.m_ignoreEntities.m_size = 0;
      ignoreBodies_3.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_3.m_ignoreBodies.m_data = NULL;
      ignoreBodies_3.m_ignoreBodies.m_size = 0;
      ignoreBodies_3.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      LODWORD(v43) = 0;
      hkMemHeapAllocator();
      v45 = 0;
      ignoreBodies_3.m_ignoreBodies.m_data = NULL;
      ignoreBodies_3.m_ignoreBodies.m_size = 0;
      ignoreBodies_3.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_3.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_3.m_isClutter = 0;
      ignoreBodies_3.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugQueryPoint_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA5C);
      v9 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v15 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_3.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v15) )
    ignoreBodies_3.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  v50.contents = v9;
  v50.simplify = 1;
  v50.ignoreBodies = &ignoreBodies_3;
  v16 = s_havokPhysicsWorldQueryPointActiveIndices[v11];
  if ( v16 == -1 )
  {
    if ( MutableWorld->requestDebugQueryPoint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23220, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugQueryPoint)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugQueryPoint") )
      __debugbreak();
    s_havokPhysicsWorldQueryPointActiveIndices[v11] = 0;
    MutableWorld->debugQueryPointPoint = (hkVector4f)position->m_quad;
    MutableWorld->debugQueryPointMaxDistance = maxDistance;
    MutableWorld->debugQueryPointExtendedData = v50;
    MutableWorld->requestDebugQueryPoint = 1;
    return;
  }
  v17 = s_havokPhysicsWorldQueryPointActiveIndices[v11];
  if ( !MutableWorld->requestDebugQueryPoint && s_havokPhysicsWorldQueryPointData[2 * (int)v11 + v16].isComplete )
  {
    s_havokPhysicsWorldQueryPointActiveIndices[v11] = 1 - v16;
    HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldQueryPointData[2 * (int)v11 + 1 - v16].result, 1);
    MutableWorld->debugQueryPointPoint = (hkVector4f)position->m_quad;
    MutableWorld->debugQueryPointMaxDistance = maxDistance;
    MutableWorld->debugQueryPointExtendedData = v50;
    MutableWorld->requestDebugQueryPoint = 1;
    v17 = s_havokPhysicsWorldQueryPointActiveIndices[v11];
  }
  if ( v17 != -1 )
  {
    v18 = 3i64 * (2 * (int)v11 - v17) + 3;
    if ( *(&s_havokPhysicsWorldQueryPointData[0].isComplete + 8 * v18) )
    {
      v19 = position->m_quad.m128_f32[0] * 32.0;
      center.v[0] = v19;
      v20 = position->m_quad.m128_f32[1] * 32.0;
      center.v[1] = v20;
      v21 = position->m_quad.m128_f32[2] * 32.0;
      center.v[2] = v21;
      integer = 0xFFFFFF;
      if ( physics_debugQueryBody->current.integer >= 0 )
        integer = physics_debugQueryBody->current.integer;
      if ( (integer & 0xFFFFFF) != 0xFFFFFF )
      {
        if ( ((unsigned int (__fastcall *)(hknpWorldReader *))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader) )
        {
          Com_sprintf<256>((char (*)[256])dest, "Query Point for Body %i %s at (%.2f, %.2f, %.2f) with maxDistance %.2f", physics_debugQueryBody->current.unsignedInt, (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), center.v[0], center.v[1], center.v[2], maxDistance);
LABEL_25:
          v23 = 0;
          Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
          *y = charHeight + *y;
          *x = tabWidth + *x;
          HavokPhysics_DrawPhysicsContents(collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
          *x = *x - tabWidth;
          v24 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldQueryPointData[0].result + v18);
          v43 = v24;
          if ( (float)(maxDistance * 32.0) <= 0.5 )
          {
            v25 = &colorYellow;
            v26 = FLOAT_5_0;
          }
          else
          {
            v25 = &colorGreen;
            v26 = maxDistance * 32.0;
          }
          CG_DebugSphere(&center, v26, v25, 0, 0);
          contentsa = HavokPhysics_CollisionQueryResult::GetNumHits(v24);
          Com_sprintf<256>((char (*)[256])dest, "Results - %i hits", (unsigned int)contentsa);
          Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
          *y = charHeight + *y;
          v27 = tabWidth + *x;
          *x = v27;
          if ( contentsa > 0 )
          {
            do
            {
              ClosestPointHitBodyId = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v24, v23);
              v45 = ClosestPointHitBodyId;
              if ( Physics_IsRigidBodyValid((Physics_WorldId)v11, ClosestPointHitBodyId) )
              {
                v29 = (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[ClosestPointHitBodyId & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
                v30 = v43;
                HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(v43, v23, &pos);
                HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(v30, v23, &end);
                ClosestPointHitDistance = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(v30, v23);
                ClosestPointHitHitShapeKey = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(v30, v23);
                ClosestPointHitHitMaterialId = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(v30, v23);
                ClosestPointHitHitContents = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(v30, v23);
                LODWORD(v30) = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(v30, v23);
                v35.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v43, v23);
                LODWORD(v40) = HavokPhysics_GetRef(v43->m_worldId, v35);
                LODWORD(adjust) = (_DWORD)v30;
                LODWORD(v38) = ClosestPointHitHitContents;
                LODWORD(shadow) = ClosestPointHitHitMaterialId;
                LODWORD(forceColor) = ClosestPointHitHitShapeKey;
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v23, v45, v29, forceColor, shadow, v38, adjust, v40);
                v13 = v48;
                Physics_DrawDebugString(v47, *v48, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
                CG_DebugSphere(&pos, 5.0, &colorRed, 0, 0);
                CG_DebugLine(&pos, &end, &colorRed, 0, 0);
                Com_sprintf(text, 0x100ui64, "%s %.2f", v29, *(float *)&ClosestPointHitDistance);
                CL_AddDebugString(&pos, &colorRed, 1.0, text, 0, 0);
                MutableWorld = v49;
                LODWORD(v11) = v46;
                v12 = v47;
              }
              else
              {
                Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v23, ClosestPointHitBodyId);
                Physics_DrawDebugString(v12, *v13, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              ++v23;
              v24 = v43;
            }
            while ( (int)v23 < contentsa );
            v27 = *v13;
          }
          *v13 = v27 - tabWidth;
          return;
        }
        v21 = center.v[2];
        v20 = center.v[1];
        v19 = center.v[0];
      }
      Com_sprintf<256>((char (*)[256])dest, "Query Point at (%.2f, %.2f, %.2f) with maxDistance %.2f", v19, v20, v21, maxDistance);
      goto LABEL_25;
    }
  }
}

/*
==============
HavokPhysics_DrawDebugRaycast
==============
*/
void HavokPhysics_DrawDebugRaycast(Physics_WorldId worldId, unsigned int collisionFilterInfo, bool isClutter, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  bool v9; 
  unsigned int v10; 
  __int64 v11; 
  HavokPhysicsWorld *MutableWorld; 
  cg_t *LocalClientGlobals; 
  float v14; 
  float v15; 
  float v16; 
  int v18; 
  __int64 v19; 
  int v20; 
  HavokPhysics_CollisionQueryResult *result; 
  __m256i v22; 
  double v23; 
  int v24; 
  int v25; 
  int v26; 
  int integer; 
  HavokPhysics_CollisionQueryResult *v28; 
  unsigned int RaycastHitBodyId; 
  float m_fraction; 
  float v31; 
  hknpBodyId v32; 
  unsigned __int16 GlassIdFromUserData; 
  const hknpCollisionResult *Hit; 
  const hknpCollisionResult *v35; 
  const hknpCollisionResult *v36; 
  const hknpCollisionResult *v37; 
  unsigned int v38; 
  unsigned int v39; 
  const Physics_DetailHitData *DetailHitData; 
  HavokPhysicsHitCollector_DetailTraceModifier *Modifier; 
  const char *v42; 
  hkMatrix3Impl<float> *v43; 
  unsigned int v44; 
  const hknpTriangleShape *TriangleShape; 
  float v56; 
  int v57; 
  const hknpShape **p_m_shape; 
  float v59; 
  const char *v60; 
  const char *v61; 
  int v62; 
  int partGroup; 
  const char *v64; 
  int v65; 
  hkMemoryAllocator *v66; 
  int v67; 
  int v68; 
  hknpBodyId *v69; 
  char *fmt; 
  __int64 forceColor; 
  __int64 forceColora; 
  __int64 forceColorb; 
  __int64 shadow; 
  bool DecalTypeFromUserData; 
  bool BrushBasisFromUserData; 
  char v78; 
  int numInOut; 
  int v80; 
  unsigned int contents; 
  int surfFlags; 
  float zero[2]; 
  int Ref; 
  unsigned int v85; 
  Physics_WorldId v86; 
  unsigned int m_collisionFilterInfo; 
  const Physics_DetailHitData *v88; 
  __m256i v89; 
  double v90; 
  hkMatrix3Impl<float> *v91; 
  __int64 v92; 
  vec3_t outPos; 
  hkVector4f v94; 
  hkVector4f v95; 
  hknpShapeCollector v96; 
  hknpInplaceTriangleShape v97; 
  char dest[256]; 

  v92 = -2i64;
  v9 = isClutter;
  v10 = collisionFilterInfo;
  contents = collisionFilterInfo;
  v11 = worldId;
  v86 = worldId;
  v89.m256i_i32[0] = -1;
  v89.m256i_i64[1] = 0i64;
  v89.m256i_i32[4] = 1;
  *(float *)&v89.m256i_i32[5] = 0.0;
  v89.m256i_i64[3] = 0x100000000i64;
  LOWORD(v90) = 256;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22631, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugRaycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (unsigned int)v11 <= 1 && !Physics_AreServerWorldsCreated() )
    return;
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v11);
  LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  v14 = LocalClientGlobals->refdef.view.axis.m[0].v[0];
  v15 = LocalClientGlobals->refdef.view.axis.m[0].v[1];
  v16 = LocalClientGlobals->refdef.view.axis.m[0].v[2];
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  v95.m_quad.m128_f32[0] = 0.03125 * outPos.v[0];
  v95.m_quad.m128_f32[1] = 0.03125 * outPos.v[1];
  v95.m_quad.m128_f32[2] = 0.03125 * outPos.v[2];
  v95.m_quad.m128_f32[3] = 0.0;
  v94.m_quad.m128_f32[0] = (float)((float)(rayDist * v14) + outPos.v[0]) * 0.03125;
  v94.m_quad.m128_f32[1] = (float)((float)(rayDist * v15) + outPos.v[1]) * 0.03125;
  v94.m_quad.m128_f32[2] = (float)((float)(rayDist * v16) + outPos.v[2]) * 0.03125;
  v94.m_quad.m128_f32[3] = 0.0;
  if ( dword_150D5FA54 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA54);
    if ( dword_150D5FA54 == -1 )
    {
      numInOut = 0;
      hkMemHeapAllocator();
      v65 = 0x80000000;
      ignoreBodies_1.m_ignoreEntities.m_data = NULL;
      ignoreBodies_1.m_ignoreEntities.m_size = 0;
      ignoreBodies_1.m_ignoreEntities.m_capacityAndFlags = 0x80000000;
      ignoreBodies_1.m_ignoreBodies.m_data = NULL;
      ignoreBodies_1.m_ignoreBodies.m_size = 0;
      ignoreBodies_1.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      v80 = 0;
      v66 = hkMemHeapAllocator();
      v67 = v80;
      v68 = v80;
      if ( v80 )
      {
        v69 = (hknpBodyId *)hkMemoryAllocator::bufAlloc2(v66, 4, &v80);
        v67 = v80;
      }
      else
      {
        v69 = NULL;
      }
      if ( v67 )
        v65 = v67;
      ignoreBodies_1.m_ignoreBodies.m_data = v69;
      ignoreBodies_1.m_ignoreBodies.m_size = v68;
      ignoreBodies_1.m_ignoreBodies.m_capacityAndFlags = v65;
      *(_QWORD *)&ignoreBodies_1.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_1.m_isClutter = 0;
      ignoreBodies_1.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugRaycast_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA54);
      v9 = isClutter;
      v10 = contents;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (_ZF = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_1.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, _ZF) )
    ignoreBodies_1.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  ignoreBodies_1.m_isClutter = v9;
  v89.m256i_i32[0] = v10;
  v89.m256i_i32[4] = !physics_debugRayDetail->current.enabled;
  v89.m256i_i64[1] = (__int64)&ignoreBodies_1;
  v18 = s_havokPhysicsWorldRayActiveIndices[v11];
  if ( v18 == -1 && s_havokPhysicsWorldRayDetailActiveIndices[v11] == -1 )
  {
    if ( MutableWorld->requestDebugRaycast && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22668, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugRaycast)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugRaycast") )
      __debugbreak();
    v18 = 0;
    s_havokPhysicsWorldRayActiveIndices[v11] = 0;
    s_havokPhysicsWorldRayDetailActiveIndices[v11] = 0;
    v19 = 2i64 * (_DWORD)v11;
    s_havokPhysicsWorldRayData[v19].isComplete = 1;
    s_havokPhysicsWorldRayDetailData[v19].isComplete = 1;
  }
  if ( !MutableWorld->requestDebugRaycast )
  {
    if ( physics_debugRayDetail->current.enabled )
    {
      v20 = s_havokPhysicsWorldRayDetailActiveIndices[v11];
      if ( s_havokPhysicsWorldRayDetailData[2 * (int)v11 + v20].isComplete )
      {
        s_havokPhysicsWorldRayDetailActiveIndices[v11] = 1 - v20;
        result = s_havokPhysicsWorldRayDetailData[2 * (int)v11 + 1 - v20].result;
LABEL_22:
        HavokPhysics_CollisionQueryResult::Reset(result, 0);
        MutableWorld->debugRaycastStart = (hkVector4f)v95.m_quad;
        v22 = v89;
        MutableWorld->debugRaycastEnd = (hkVector4f)v94.m_quad;
        *(__m256i *)&MutableWorld->debugRaycastExtendedData.contents = v22;
        v23 = v90;
        MutableWorld->requestDebugRaycast = 1;
        *(double *)&MutableWorld->debugRaycastExtendedData.collectInsideHits = v23;
      }
    }
    else if ( s_havokPhysicsWorldRayData[2 * (int)v11 + v18].isComplete )
    {
      s_havokPhysicsWorldRayActiveIndices[v11] = 1 - v18;
      result = s_havokPhysicsWorldRayData[2 * (int)v11 + 1 - v18].result;
      goto LABEL_22;
    }
  }
  v24 = s_havokPhysicsWorldRayActiveIndices[v11];
  numInOut = 2 * v11 - v24;
  v25 = s_havokPhysicsWorldRayDetailActiveIndices[v11];
  v26 = 2 * v11 - v25;
  if ( physics_debugRayDetail->current.enabled )
  {
    if ( v25 == -1 || !s_havokPhysicsWorldRayDetailData[v26 + 1].isComplete )
      return;
  }
  else if ( v24 == -1 || !s_havokPhysicsWorldRayData[2 * (int)v11 - v24 + 1].isComplete )
  {
    return;
  }
  integer = physics_debugQueryBody->current.integer;
  if ( integer < 0 )
  {
    surfFlags = 0xFFFFFF;
    integer = 0xFFFFFF;
  }
  else
  {
    surfFlags = physics_debugQueryBody->current.integer;
  }
  if ( (integer & 0xFFFFFF) == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader) )
    Com_sprintf<256>((char (*)[256])dest, "RayCast");
  else
    Com_sprintf<256>((char (*)[256])dest, "RayCast for body %i:%i %s", HIBYTE(physics_debugQueryBody->current.integer), physics_debugQueryBody->current.integer & 0xFFFFFF, (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  HavokPhysics_DrawPhysicsContents(contents, scrPlace, x, y, tabWidth, charHeight);
  *x = *x - tabWidth;
  if ( physics_debugRayDetail->current.enabled )
    v28 = s_havokPhysicsWorldRayDetailData[v26 + 1].result;
  else
    v28 = s_havokPhysicsWorldRayData[numInOut + 1].result;
  Com_sprintf<256>((char (*)[256])dest, "Result");
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  Physics_LockWorld((Physics_WorldId)v11);
  if ( HavokPhysics_CollisionQueryResult::HasHit(v28) && (RaycastHitBodyId = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(v28, 0), Physics_IsRigidBodyValid((Physics_WorldId)v11, RaycastHitBodyId)) )
  {
    HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(v28, 0, &outPos);
    HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(v28, 0, (vec3_t *)&v94);
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1068, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    m_fraction = HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_fraction;
    v31 = m_fraction * rayDist;
    v32.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetRaycastHitBodyId(v28, 0);
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1082, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    contents = HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_hitBodyInfo.m_shapeKey.m_value;
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1089, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    LOWORD(numInOut) = HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1096, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    m_collisionFilterInfo = HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
    surfFlags = HavokPhysics_CollisionQueryResult::GetRaycastHitSurfFlags(v28, 0);
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1197, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    {
      GlassIdFromUserData = 0;
    }
    else
    {
      Hit = HavokPhysics_CollisionQueryResult::GetHit(v28, 0);
      GlassIdFromUserData = Physics_GetGlassIdFromUserData(Hit->m_hitBodyInfo.m_filterData.m_userData);
    }
    LOWORD(v80) = GlassIdFromUserData;
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1214, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    {
      BrushBasisFromUserData = 0;
    }
    else
    {
      v35 = HavokPhysics_CollisionQueryResult::GetHit(v28, 0);
      BrushBasisFromUserData = Physics_GetBrushBasisFromUserData(v35->m_hitBodyInfo.m_filterData.m_userData);
    }
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1231, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    if ( HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_hitBodyInfo.m_shapeKey.m_value == -1 )
    {
      DecalTypeFromUserData = 0;
    }
    else
    {
      v36 = HavokPhysics_CollisionQueryResult::GetHit(v28, 0);
      DecalTypeFromUserData = Physics_GetDecalTypeFromUserData(v36->m_hitBodyInfo.m_filterData.m_userData);
    }
    if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v28) )
    {
      LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v28);
      LODWORD(forceColor) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1075, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", forceColor, shadow) )
        __debugbreak();
    }
    v37 = HavokPhysics_CollisionQueryResult::GetHit(v28, 0);
    Ref = HavokPhysics_GetRef(v28->m_worldId, v37->m_hitBodyInfo.m_bodyId);
    v91 = (hkMatrix3Impl<float> *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, v32.m_serialAndIndex);
    v38 = HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_rayCastResult.m_value >> 1;
    LOBYTE(v38) = v38 & 1;
    LODWORD(zero[0]) = v38;
    v78 = HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_rayCastResult.m_value & 1;
    v39 = HavokPhysics_CollisionQueryResult::GetHit(v28, 0)->m_rayCastResult.m_value >> 2;
    LOBYTE(v39) = v39 & 1;
    v85 = v39;
    DetailHitData = NULL;
    v88 = NULL;
    if ( physics_debugRayDetail->current.enabled && HavokPhysicsHitCollector::HasModifiers(v28->m_collector) )
    {
      Modifier = (HavokPhysicsHitCollector_DetailTraceModifier *)HavokPhysicsHitCollector::GetModifier(v28->m_collector, 0);
      if ( !Modifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22803, ASSERT_TYPE_ASSERT, "(dtModifier)", (const char *)&queryFormat, "dtModifier") )
        __debugbreak();
      DetailHitData = HavokPhysicsHitCollector_DetailTraceModifier::GetDetailHitData(Modifier, 0);
      v88 = DetailHitData;
    }
    CG_DebugSphere(&outPos, 5.0, &colorGreen, 0, 0);
    v95.m_quad.m128_f32[0] = (float)(12.0 * v94.m_quad.m128_f32[0]) + outPos.v[0];
    v95.m_quad.m128_f32[1] = (float)(12.0 * v94.m_quad.m128_f32[1]) + outPos.v[1];
    v95.m_quad.m128_f32[2] = (float)(12.0 * v94.m_quad.m128_f32[2]) + outPos.v[2];
    CG_DebugLine(&outPos, (const vec3_t *)&v95, &colorGreen, 0, 0);
    Com_sprintf<256>((char (*)[256])dest, "Fraction:%f Distance %.2f", m_fraction, v31);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    Com_sprintf<256>((char (*)[256])dest, "Position:%.5f %.5f %.5f ", outPos.v[0], outPos.v[1], outPos.v[2]);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    LODWORD(forceColora) = Ref;
    LODWORD(fmt) = contents;
    Com_sprintf<256>((char (*)[256])dest, "Body Id:%i:%i ShapeKey %x Ref %x", HIBYTE(v32.m_serialAndIndex), v32.m_serialAndIndex & 0xFFFFFF, fmt, forceColora);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    if ( (_BYTE)v85 )
    {
      Com_sprintf<256>((char (*)[256])dest, "Internal Hit");
    }
    else if ( v78 )
    {
      Com_sprintf<256>((char (*)[256])dest, "Backface Hit");
    }
    else
    {
      v42 = "Frontface Hit";
      if ( !LOBYTE(zero[0]) )
        v42 = "Unknown Hit Type";
      Com_sprintf<256>((char (*)[256])dest, v42);
    }
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    *x = tabWidth + *x;
    HavokPhysics_DrawPhysicsBody((Physics_WorldId)v11, v32, 0, scrPlace, x, y, tabWidth, charHeight);
    hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v97, 0.015);
    v96.m_internal.m_shapeBuffer.m_shape = NULL;
    v96.m_internal.m_shapeBuffer.m_buffer = v96.m_internal.m_shapeBuffer.m_storage;
    v96.m_internal.m_shapeBuffer.m_bufferSize = 2048;
    v96.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpInplaceShapeBuffer<2048>::`vftable';
    *(__m256i *)v96.m_transform.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
    *(__m256i *)v96.m_transform.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
    v96.m_internal.m_scale.m_quad = g_vectorfConstants[6];
    v96.m_internal.m_shapeTags[0] = -1;
    v96.m_internal.m_shape = NULL;
    v96.m_parentShape = NULL;
    v96.m_shapeTagPath.m_size = 0;
    *(_QWORD *)&v96.m_internal.m_flags.m_storage = 8i64;
    v43 = v91;
    v96.m_transform.m_rotation = (hkRotationImpl<float>)*v91;
    v96.m_transform.m_translation = v91[1].m_col0;
    zero[0] = FLOAT_1_1920929eN7;
    if ( hkMatrix3Impl<float>::isApproximatelyEqual(v91, (const hkMatrix3Impl<float> *)&g_vectorfConstants[32], zero) )
    {
      v44 = v96.m_internal.m_flags.m_storage | 4;
      v96.m_internal.m_flags.m_storage |= 4u;
      _XMM0 = v43[1].m_col0.m_quad;
      _mm128_sub_ps(_XMM0, g_vectorfConstants[5]);
      _XMM1 = *(_OWORD *)hkMath::hkSse_signMask;
      __asm
      {
        vandnps xmm3, xmm1, xmm2
        vcmpleps xmm4, xmm3, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
      }
      _XMM2 = 0i64;
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vpcmpeqd xmm1, xmm0, xmm0
        vblendps xmm2, xmm2, xmm1, 7
        vpand   xmm0, xmm4, xmm2
        vptest  xmm0, xmm2
      }
      if ( _CF )
        v96.m_internal.m_flags.m_storage = v44 | 1;
    }
    v96.m_internal.m_shapeTags[0] = -1;
    if ( contents == -1 )
    {
      v59 = *x;
    }
    else
    {
      (*(void (__fastcall **)(unsigned __int64, unsigned int *, __int64, hknpShapeCollector *))(*(_QWORD *)v43[2].m_col0.m_quad.m128_u64[0] + 176i64))(v43[2].m_col0.m_quad.m128_u64[0], &contents, 1i64, &v96);
      if ( (v96.m_internal.m_flags.m_storage & 0x10) != 0 )
        TriangleShape = hknpShapeCollector::getTriangleShape(&v96, 0, (hknpTriangleShape *)&v97);
      else
        TriangleShape = (const hknpTriangleShape *)v96.m_internal.m_shape;
      *(_QWORD *)zero = TriangleShape;
      Com_sprintf<256>((char (*)[256])dest, "Sub-Shape Path:");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      v56 = tabWidth + *x;
      *x = v56;
      v57 = 0;
      if ( v96.m_shapeTagPath.m_size > 0 )
      {
        p_m_shape = &v96.m_shapeTagPath.m_data[0].m_shape;
        do
        {
          Com_sprintf<256>((char (*)[256])dest, "Entry %i:", (unsigned int)v57);
          Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
          *y = charHeight + *y;
          *x = tabWidth + *x;
          HavokPhysics_DrawPhysicsShape(*p_m_shape, scrPlace, x, y, tabWidth, charHeight);
          v56 = *x - tabWidth;
          *x = v56;
          ++v57;
          p_m_shape += 4;
        }
        while ( v57 < v96.m_shapeTagPath.m_size );
        LODWORD(v11) = v86;
        DetailHitData = v88;
      }
      *x = v56 - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "Leaf-Shape:");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      HavokPhysics_DrawPhysicsShape(*(const hknpShape **)zero, scrPlace, x, y, tabWidth, charHeight);
      v59 = *x - tabWidth;
    }
    *x = v59 - tabWidth;
    HavokPhysics_DrawPhysicsContents(m_collisionFilterInfo, scrPlace, x, y, tabWidth, charHeight);
    HavokPhysics_DrawPhysicsSurfaceFlags(surfFlags, scrPlace, x, y, tabWidth, charHeight);
    if ( (_WORD)v80 )
    {
      Com_sprintf<256>((char (*)[256])dest, "Glass ID:%i", (unsigned __int16)v80);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
    }
    v60 = "Not Brush based";
    if ( BrushBasisFromUserData )
      v60 = "Brush based";
    Com_sprintf<256>((char (*)[256])dest, v60);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v61 = "Base";
    if ( DecalTypeFromUserData )
      v61 = "Decal";
    Com_sprintf<256>((char (*)[256])dest, v61);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v62 = (unsigned __int16)numInOut;
    Com_sprintf<256>((char (*)[256])dest, "Material ID:%i", (unsigned __int16)numInOut);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    *x = tabWidth + *x;
    HavokPhysics_DrawPhysicsLibraryMaterialId(v62, scrPlace, x, y, tabWidth, charHeight);
    *x = *x - tabWidth;
    if ( DetailHitData && DetailHitData->isValid )
    {
      Com_sprintf<256>((char (*)[256])dest, "Detail data");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      partGroup = DetailHitData->partGroup;
      v64 = SL_ConvertToString(DetailHitData->partName);
      LODWORD(forceColorb) = partGroup;
      Com_sprintf<256>((char (*)[256])dest, "ModelIndex %i, PartName %i %s, PartGroup %i", DetailHitData->modelIndex, (unsigned int)DetailHitData->partName, v64, forceColorb);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      HavokPhysics_DrawPhysicsSurfaceFlags(DetailHitData->surfaceflags, scrPlace, x, y, tabWidth, charHeight);
      *x = *x - tabWidth;
    }
    v96.m_internal.m_shapeBuffer.__vftable = (hknpInplaceShapeBuffer<2048>_vtbl *)hknpShapeBuffer::`vftable';
    if ( v96.m_internal.m_shapeBuffer.m_shape )
      ((void (__fastcall *)(hknpShape *, _QWORD))v96.m_internal.m_shapeBuffer.m_shape->~hkBaseObject)(v96.m_internal.m_shapeBuffer.m_shape, 0i64);
    Physics_UnlockWorld((Physics_WorldId)v11);
    *x = *x - tabWidth;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Hits");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    Physics_UnlockWorld((Physics_WorldId)v11);
  }
}

/*
==============
HavokPhysics_DrawDebugShapecast
==============
*/
void HavokPhysics_DrawDebugShapecast(Physics_WorldId worldId, unsigned int collisionFilterInfo, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  float *v8; 
  unsigned int v10; 
  unsigned __int64 v11; 
  float *v12; 
  HavokPhysicsWorld *MutableWorld; 
  cg_t *LocalClientGlobals; 
  float v16; 
  float v17; 
  float v18; 
  cg_t *v19; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  bool v25; 
  int v26; 
  int v27; 
  __m128 v28; 
  int v29; 
  __int64 v30; 
  int integer; 
  HavokPhysics_CollisionQueryResult *v32; 
  HavokPhysics_CollisionQueryResult *v33; 
  float v34; 
  unsigned int v35; 
  unsigned int m_serialAndIndex; 
  double ClosestPointHitDistance; 
  unsigned int ClosestPointHitHitShapeKey; 
  int ClosestPointHitHitMaterialId; 
  unsigned int ClosestPointHitHitContents; 
  unsigned int ClosestPointHitHitSurfFlags; 
  hknpBodyId v42; 
  unsigned int ShapecastHitBodyId; 
  const hknpCollisionResult *Hit; 
  const hknpCollisionResult *v45; 
  float v46; 
  float v47; 
  float v48; 
  float m_fraction; 
  __m128 v50; 
  unsigned int m_collisionFilterInfo; 
  int ShapecastHitHitSurfFlags; 
  const hknpCollisionResult *v53; 
  int Ref; 
  int v55; 
  hkMemoryAllocator *v56; 
  float v57; 
  int v58; 
  HavokPhysics_IgnoreBodies::IgnoreEntity *v59; 
  int v60; 
  char *fmt; 
  char *fmt_8; 
  char *fmt_8a; 
  __int64 shadow; 
  __int64 shadowa; 
  __int64 v66; 
  __int64 adjust; 
  __int64 v68; 
  unsigned int numInOut; 
  signed int contentsa; 
  unsigned int contentsb; 
  unsigned int m_value; 
  __m256i v76; 
  double v77; 
  vec3_t start; 
  vec3_t outPos; 
  vec3_t v80; 
  vec3_t pos; 
  __m128 v82; 
  __m128 v83; 
  vec3_t center; 
  vec3_t v85; 
  char dest[256]; 
  char text[256]; 
  __int128 v88; 

  v88 = _XMM14;
  v8 = x;
  *(_QWORD *)v80.v = x;
  v10 = collisionFilterInfo;
  v11 = worldId;
  v12 = y;
  *(float *)&v76.m256i_i32[1] = 0.0;
  *(float *)&v76.m256i_i32[2] = FLOAT_0_016000001;
  *(float *)&v76.m256i_i32[6] = 0.0;
  __asm { vpxor   xmm14, xmm14, xmm14 }
  LODWORD(v77) = 0;
  BYTE4(v77) = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22967, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugShapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v11);
  *(_QWORD *)start.v = MutableWorld;
  LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  v16 = LocalClientGlobals->refdef.view.axis.m[0].v[0];
  v17 = LocalClientGlobals->refdef.view.axis.m[0].v[1];
  v18 = LocalClientGlobals->refdef.view.axis.m[0].v[2];
  v19 = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
  v20 = v19->refdef.view.axis.m[1].v[0];
  v21 = v19->refdef.view.axis.m[1].v[1];
  v22 = v19->refdef.view.axis.m[1].v[2];
  CL_GetViewPos(LOCAL_CLIENT_0, &outPos);
  v23 = (float)(240.0 * v18) + outPos.v[2];
  v24 = (float)(v20 * 120.0) + (float)((float)(240.0 * v16) + outPos.v[0]);
  center.v[0] = v24;
  center.v[1] = (float)(v21 * 120.0) + (float)((float)(240.0 * v17) + outPos.v[1]);
  center.v[2] = (float)(v22 * 120.0) + v23;
  v85.v[0] = v24 - (float)(v20 * 240.0);
  v85.v[1] = center.v[1] - (float)(v21 * 240.0);
  v85.v[2] = center.v[2] - (float)(v22 * 240.0);
  v82.m128_f32[0] = v24 * 0.03125;
  v82.m128_f32[1] = center.v[1] * 0.03125;
  v82.m128_f32[2] = center.v[2] * 0.03125;
  v82.m128_f32[3] = 0.0;
  v83.m128_f32[0] = v85.v[0] * 0.03125;
  v83.m128_f32[1] = v85.v[1] * 0.03125;
  v83.m128_f32[2] = v85.v[2] * 0.03125;
  v83.m128_f32[3] = 0.0;
  if ( dword_150D5FA58 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_150D5FA58);
    if ( dword_150D5FA58 == -1 )
    {
      outPos.v[0] = 0.0;
      v56 = hkMemHeapAllocator();
      v57 = outPos.v[0];
      v58 = LODWORD(outPos.v[0]);
      if ( LODWORD(outPos.v[0]) )
      {
        v59 = (HavokPhysics_IgnoreBodies::IgnoreEntity *)hkMemoryAllocator::bufAlloc2(v56, 8, (int *)&outPos);
        v57 = outPos.v[0];
      }
      else
      {
        v59 = NULL;
      }
      v60 = 0x80000000;
      if ( v57 != 0.0 )
        v60 = LODWORD(v57);
      ignoreBodies_2.m_ignoreEntities.m_data = v59;
      ignoreBodies_2.m_ignoreEntities.m_size = v58;
      ignoreBodies_2.m_ignoreEntities.m_capacityAndFlags = v60;
      ignoreBodies_2.m_ignoreBodies.m_data = NULL;
      ignoreBodies_2.m_ignoreBodies.m_size = 0;
      ignoreBodies_2.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      hkMemHeapAllocator();
      ignoreBodies_2.m_ignoreBodies.m_data = NULL;
      ignoreBodies_2.m_ignoreBodies.m_size = 0;
      ignoreBodies_2.m_ignoreBodies.m_capacityAndFlags = 0x80000000;
      *(_QWORD *)&ignoreBodies_2.m_ignorePhysicsVolumes = 0i64;
      *(_WORD *)&ignoreBodies_2.m_isClutter = 0;
      ignoreBodies_2.m_ignoreLayers = 32;
      j_atexit(HavokPhysics_DrawDebugShapecast_::_2_::_dynamic_atexit_destructor_for__ignoreBodies__);
      j__Init_thread_footer(&dword_150D5FA58);
      v10 = collisionFilterInfo;
    }
  }
  if ( !physics_debugQuery_IgnoreVolumes || (v25 = !physics_debugQuery_IgnoreVolumes->current.enabled, ignoreBodies_2.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_NoVolumes, v25) )
    ignoreBodies_2.m_ignorePhysicsVolumes = Physics_IgnoreVolumeOption_All;
  v76.m256i_i32[0] = v10;
  v76.m256i_i8[12] = 1;
  v76.m256i_i64[2] = (__int64)&ignoreBodies_2;
  v26 = s_havokPhysicsWorldShapeCastActiveIndices[v11];
  if ( v26 == -1 )
  {
    if ( MutableWorld->requestDebugShapecast && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 23001, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->requestDebugShapecast)", (const char *)&queryFormat, "!havokPhysicsWorld->requestDebugShapecast") )
      __debugbreak();
    s_havokPhysicsWorldShapeCastActiveIndices[v11] = 0;
    MutableWorld->debugShapecastStart.m_quad = v82;
    MutableWorld->debugShapecastEnd.m_quad = v83;
    MutableWorld->debugShapecastRotation.m_vec.m_quad = g_vectorfConstants[35];
    *(__m256i *)&MutableWorld->debugShapecastExtendedData.contents = v76;
    *(_OWORD *)&MutableWorld->debugShapecastExtendedData.nonBrushShape = _XMM14;
    *(double *)&MutableWorld->debugShapecastExtendedData.phaseSelection = v77;
    MutableWorld->requestDebugShapecast = 1;
  }
  else
  {
    v27 = s_havokPhysicsWorldShapeCastActiveIndices[v11];
    v28 = v82;
    if ( !MutableWorld->requestDebugShapecast )
    {
      v29 = 2 * v11;
      if ( s_havokPhysicsWorldShapeCastData[2 * (int)v11 + v26].isComplete )
      {
        s_havokPhysicsWorldShapeCastActiveIndices[v11] = 1 - v26;
        HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldShapeCastData[v29 + 1 - v26].result, 1);
        HavokPhysics_CollisionQueryResult::Reset(s_havokPhysicsWorldShapeCastData[v29 + s_havokPhysicsWorldShapeCastActiveIndices[v11]].startResult, 1);
        MutableWorld->debugShapecastStart.m_quad = v28;
        MutableWorld->debugShapecastEnd.m_quad = v83;
        MutableWorld->debugShapecastRotation.m_vec.m_quad = g_vectorfConstants[35];
        *(__m256i *)&MutableWorld->debugShapecastExtendedData.contents = v76;
        *(_OWORD *)&MutableWorld->debugShapecastExtendedData.nonBrushShape = _XMM14;
        *(double *)&MutableWorld->debugShapecastExtendedData.phaseSelection = v77;
        MutableWorld->requestDebugShapecast = 1;
        v27 = s_havokPhysicsWorldShapeCastActiveIndices[v11];
      }
    }
    if ( v27 != -1 )
    {
      v30 = 3i64 * (2 * (int)v11 - v27) + 3;
      if ( *(&s_havokPhysicsWorldShapeCastData[0].isComplete + 8 * v30) )
      {
        integer = physics_debugQueryBody->current.integer;
        if ( integer < 0 )
          integer = 0xFFFFFF;
        if ( (integer & 0xFFFFFF) == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader) )
          Com_sprintf<256>((char (*)[256])dest, "ShapeCast of a sphere of radius %.2f with start tolerance of %.2f", DOUBLE_12_0, DOUBLE_12_0);
        else
          Com_sprintf<256>((char (*)[256])dest, "ShapeCast for Body %i %s of a sphere of radius %.2f with start tolerance of %.2f", physics_debugQueryBody->current.unsignedInt, (const char *)((unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[physics_debugQueryBody->current.integer & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), *(double *)&_xmm, *((double *)&_xmm + 1));
        Physics_DrawDebugString(scrPlace, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        *v8 = tabWidth + *v8;
        HavokPhysics_DrawPhysicsContents(collisionFilterInfo, scrPlace, v8, y, tabWidth, charHeight);
        *v8 = *v8 - tabWidth;
        v32 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldShapeCastData[0].result + v30);
        *(_QWORD *)outPos.v = v32;
        v33 = (HavokPhysics_CollisionQueryResult *)*((_QWORD *)&s_havokPhysicsWorldShapeCastData[0].startResult + v30);
        contentsa = HavokPhysics_CollisionQueryResult::GetNumHits(v33);
        Com_sprintf<256>((char (*)[256])dest, "Start Results - %i hits", (unsigned int)contentsa);
        Physics_DrawDebugString(scrPlace, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        v34 = tabWidth + *v8;
        *v8 = v34;
        v35 = 0;
        if ( contentsa > 0 )
        {
          do
          {
            if ( v35 >= HavokPhysics_CollisionQueryResult::GetNumHits(v33) )
            {
              LODWORD(shadow) = HavokPhysics_CollisionQueryResult::GetNumHits(v33);
              LODWORD(fmt_8) = v35;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8, shadow) )
                __debugbreak();
            }
            m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetHit(v33, v35)->m_hitBodyInfo.m_bodyId.m_serialAndIndex;
            numInOut = m_serialAndIndex;
            if ( Physics_IsRigidBodyValid((Physics_WorldId)v11, m_serialAndIndex) )
            {
              v11 = (unsigned __int64)MutableWorld->world->m_bodyManager.m_bodyNames.m_data[m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64;
              HavokPhysics_CollisionQueryResult::GetClosestPointHitHitPosition(v33, v35, &pos);
              HavokPhysics_CollisionQueryResult::GetClosestPointHitQueryPosition(v33, v35, (vec3_t *)&v82);
              ClosestPointHitDistance = HavokPhysics_CollisionQueryResult::GetClosestPointHitDistance(v33, v35);
              ClosestPointHitHitShapeKey = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitShapeKey(v33, v35);
              ClosestPointHitHitMaterialId = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitMaterialId(v33, v35);
              ClosestPointHitHitContents = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitContents(v33, v35);
              ClosestPointHitHitSurfFlags = HavokPhysics_CollisionQueryResult::GetClosestPointHitHitSurfFlags(v33, v35);
              v42.m_serialAndIndex = HavokPhysics_CollisionQueryResult::GetClosestPointHitBodyId(v33, v35);
              LODWORD(v68) = HavokPhysics_GetRef(v33->m_worldId, v42);
              LODWORD(adjust) = ClosestPointHitHitSurfFlags;
              LODWORD(v66) = ClosestPointHitHitContents;
              LODWORD(shadow) = ClosestPointHitHitMaterialId;
              LODWORD(fmt_8) = ClosestPointHitHitShapeKey;
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Name %s ShapeKey %i MaterialId %i Contents %x Surface %x ref %x", v35, numInOut, (const char *)v11, fmt_8, shadow, v66, adjust, v68);
              v12 = y;
              v8 = *(float **)v80.v;
              Physics_DrawDebugString(scrPlace, **(float **)v80.v, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              CG_DebugSphere(&pos, 5.0, &colorRed, 0, 0);
              CG_DebugLine(&pos, (const vec3_t *)&v82, &colorRed, 0, 0);
              Com_sprintf(text, 0x100ui64, "%s %.2f", (const char *)v11, *(float *)&ClosestPointHitDistance);
              CL_AddDebugString(&pos, &colorRed, 1.0, text, 0, 0);
              MutableWorld = *(HavokPhysicsWorld **)start.v;
              LODWORD(v11) = worldId;
            }
            else
            {
              Com_sprintf<256>((char (*)[256])dest, "Hit %i BodyId %i Invalid", v35, m_serialAndIndex);
              Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
              *v12 = charHeight + *v12;
            }
            ++v35;
          }
          while ( (int)v35 < contentsa );
          v34 = *v8;
          v32 = *(HavokPhysics_CollisionQueryResult **)outPos.v;
        }
        *v8 = v34 - tabWidth;
        CG_DebugSphere(&center, 12.0, &colorGreen, 0, 0);
        CG_DebugSphere(&v85, 12.0, &colorRed, 0, 0);
        Com_sprintf<256>((char (*)[256])dest, "Result");
        Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
        *v12 = charHeight + *v12;
        *v8 = tabWidth + *v8;
        if ( HavokPhysics_CollisionQueryResult::HasHit(v32) && (ShapecastHitBodyId = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(v32, 0), Physics_IsRigidBodyValid((Physics_WorldId)v11, ShapecastHitBodyId)) )
        {
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v32) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v32);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1274, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          Hit = HavokPhysics_CollisionQueryResult::GetHit(v32, 0);
          start.v[0] = 32.0 * Hit->m_position.m_quad.m128_f32[0];
          start.v[1] = 32.0 * Hit->m_position.m_quad.m128_f32[1];
          start.v[2] = 32.0 * Hit->m_position.m_quad.m128_f32[2];
          if ( !v32->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1281, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
            __debugbreak();
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v32) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v32);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1282, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          v45 = HavokPhysics_CollisionQueryResult::GetHit(v32, 0);
          v46 = v45->m_normal.m_quad.m128_f32[0];
          v47 = v45->m_normal.m_quad.m128_f32[1];
          v48 = v45->m_normal.m_quad.m128_f32[2];
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v32) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v32);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1445, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          m_fraction = HavokPhysics_CollisionQueryResult::GetHit(v32, 0)->m_fraction;
          v50 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(v83, v28), _mm_shuffle_ps((__m128)LODWORD(m_fraction), (__m128)LODWORD(m_fraction), 0)), v28);
          v80.v[0] = v50.m128_f32[0] * 32.0;
          v80.v[1] = _mm_shuffle_ps(v50, v50, 85).m128_f32[0] * 32.0;
          v80.v[2] = _mm_shuffle_ps(v50, v50, 170).m128_f32[0] * 32.0;
          contentsb = HavokPhysics_CollisionQueryResult::GetShapecastHitBodyId(v32, 0);
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v32) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v32);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1459, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          m_value = HavokPhysics_CollisionQueryResult::GetHit(v32, 0)->m_hitBodyInfo.m_shapeKey.m_value;
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v32) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v32);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1473, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          LOWORD(outPos.v[0]) = HavokPhysics_CollisionQueryResult::GetHit(v32, 0)->m_hitBodyInfo.m_filterData.m_materialId.m_value;
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v32) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v32);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1487, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          m_collisionFilterInfo = HavokPhysics_CollisionQueryResult::GetHit(v32, 0)->m_hitBodyInfo.m_filterData.m_collisionFilterInfo;
          ShapecastHitHitSurfFlags = HavokPhysics_CollisionQueryResult::GetShapecastHitHitSurfFlags(v32, 0);
          if ( !HavokPhysics_CollisionQueryResult::GetNumHits(v32) )
          {
            LODWORD(shadowa) = HavokPhysics_CollisionQueryResult::GetNumHits(v32);
            LODWORD(fmt_8a) = 0;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1452, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", fmt_8a, shadowa) )
              __debugbreak();
          }
          v53 = HavokPhysics_CollisionQueryResult::GetHit(v32, 0);
          Ref = HavokPhysics_GetRef(v32->m_worldId, v53->m_hitBodyInfo.m_bodyId);
          CG_DebugSphere(&v80, 12.0, &colorYellow, 0, 0);
          CG_DebugSphere(&start, 5.0, &colorBlue, 0, 0);
          pos.v[0] = (float)(v46 * 12.0) + start.v[0];
          pos.v[1] = (float)(v47 * 12.0) + start.v[1];
          pos.v[2] = (float)(v48 * 12.0) + start.v[2];
          CG_DebugLine(&start, &pos, &colorBlue, 0, 0);
          Com_sprintf<256>((char (*)[256])dest, "Fraction:%.4f Distance %.2f", m_fraction, (float)(m_fraction * 240.0));
          Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
          *v12 = charHeight + *v12;
          Com_sprintf<256>((char (*)[256])dest, "Hit Position:  %.4f %.4f %.4f ", start.v[0], start.v[1], start.v[2]);
          Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
          *v12 = charHeight + *v12;
          Com_sprintf<256>((char (*)[256])dest, "Shape Position:%.4f %.4f %.4f ", v80.v[0], v80.v[1], v80.v[2]);
          Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
          *v12 = charHeight + *v12;
          LODWORD(fmt) = Ref;
          Com_sprintf<256>((char (*)[256])dest, "Body Id:%i ShapeKey %x Ref %x", contentsb, m_value, fmt);
          Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
          *v12 = charHeight + *v12;
          *v8 = tabWidth + *v8;
          HavokPhysics_DrawPhysicsBody((Physics_WorldId)v11, (hknpBodyId)contentsb, 0, scrPlace, v8, v12, tabWidth, charHeight);
          *v8 = *v8 - tabWidth;
          HavokPhysics_DrawPhysicsContents(m_collisionFilterInfo, scrPlace, v8, v12, tabWidth, charHeight);
          HavokPhysics_DrawPhysicsSurfaceFlags(ShapecastHitHitSurfFlags, scrPlace, v8, v12, tabWidth, charHeight);
          v55 = LOWORD(outPos.v[0]);
          Com_sprintf<256>((char (*)[256])dest, "Material ID:%i", LOWORD(outPos.v[0]));
          Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
          *v12 = charHeight + *v12;
          *v8 = tabWidth + *v8;
          HavokPhysics_DrawPhysicsLibraryMaterialId(v55, scrPlace, v8, v12, tabWidth, charHeight);
          *v8 = (float)(*v8 - tabWidth) - tabWidth;
        }
        else
        {
          Com_sprintf<256>((char (*)[256])dest, "No Hits");
          Physics_DrawDebugString(scrPlace, *v8, *v12, dest, &colorWhite, 0, 1, charHeight, 0);
          *v12 = charHeight + *v12;
        }
      }
    }
  }
}

/*
==============
HavokPhysics_DrawDebugWorld
==============
*/
void HavokPhysics_DrawDebugWorld(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  HavokPhysicsWorld *MutableWorld; 
  int v11; 
  __int64 v12; 
  __int64 shadow; 
  char dest[256]; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17414, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  if ( MutableWorld->world )
  {
    v11 = 0;
    if ( MutableWorld->visProcesses.m_size > 0 )
    {
      v12 = 0i64;
      do
      {
        ((void (__fastcall *)(hkProcess *))MutableWorld->visProcesses.m_data[v12]->step)(MutableWorld->visProcesses.m_data[v12]);
        ++v11;
        ++v12;
      }
      while ( v11 < MutableWorld->visProcesses.m_size );
    }
    HavokPhysicsProcessHandler::step(MutableWorld->processHandler, MutableWorld->defaultTimeStep);
    if ( physics_debugVisualizeWorldCollisionHeatmap->current.enabled )
    {
      Com_sprintf<256>((char (*)[256])dest, "Heatmap entries");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      HavokPhysicsCollisionHeatmapViewer::debugDraw(scrPlace, x, y, tabWidth, charHeight);
      *x = *x - tabWidth;
    }
    if ( !MutableWorld->displayHandler )
    {
      LODWORD(shadow) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17447, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->displayHandler)", "%s\n\tHavokPhysics: DrawDebugWorld has invalid display handler for world %i", "havokPhysicsWorld->displayHandler", shadow) )
        __debugbreak();
    }
    HavokPhysicsDisplayHandler::step(MutableWorld->displayHandler);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_DrawDebugWorldCPU
==============
*/
void HavokPhysics_DrawDebugWorldCPU(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  HavokPhysicsWorld *MutableWorld; 
  int stepCPUIndex; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  float v16; 
  float v17; 
  char dest[256]; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17110, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorldMemory with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  stepCPUIndex = MutableWorld->stepCPUIndex;
  v12 = 0.0;
  if ( stepCPUIndex <= 0 )
    v13 = 0.0;
  else
    v13 = MutableWorld->stepCPUTimes[0];
  if ( stepCPUIndex <= 1 )
    v14 = 0.0;
  else
    v14 = MutableWorld->stepCPUTimes[1];
  if ( stepCPUIndex <= 2 )
    v15 = 0.0;
  else
    v15 = MutableWorld->stepCPUTimes[2];
  if ( stepCPUIndex <= 3 )
    v16 = 0.0;
  else
    v16 = MutableWorld->stepCPUTimes[3];
  if ( stepCPUIndex <= 4 )
    v17 = 0.0;
  else
    v17 = MutableWorld->stepCPUTimes[4];
  if ( stepCPUIndex > 5 )
    v12 = MutableWorld->stepCPUTimes[5];
  Com_sprintf<256>((char (*)[256])dest, "Step:%5.2f %5.2f %5.2f %5.2f %5.2f %5.2f Frame:%5.2f MaxStep:%5.2f MaxFrame:%5.2f", v13, v14, v15, v16, v17, v12, MutableWorld->lastFrameCPUTime, MutableWorld->maxStepCPUTime, MutableWorld->maxFrameCPUTime);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  if ( g_havokPhysicsThreadPool )
    HavokPhysicsThreadPool::DrawDebug(g_havokPhysicsThreadPool, scrPlace, x, y, tabWidth, charHeight);
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_DrawDebugWorldMemory
==============
*/
void HavokPhysics_DrawDebugWorldMemory(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  HavokPhysicsWorld *MutableWorld; 
  char v12[32]; 
  char v13[32]; 
  char buffer[32]; 
  char dest[256]; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17061, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorldMemory with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  Physics_DebugIntToString(buffer, 32, MutableWorld->persistentMemoryStats.m_allocatorStats.m_inUse);
  Physics_DebugIntToString(v13, 32, MutableWorld->persistentMemoryStats.m_allocatorStats.m_peakInUse);
  Physics_DebugIntToString(v12, 32, MutableWorld->persistentMemoryCapacity);
  Com_sprintf<256>((char (*)[256])dest, "Persistent: Current:%10s Max:%10s Capacity:%10s", buffer, v13, v12);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_DrawDebugWorldTimestep
==============
*/
void HavokPhysics_DrawDebugWorldTimestep(Physics_WorldId worldId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool drawFrame)
{
  __int64 v10; 
  HavokPhysicsWorld *MutableWorld; 
  const vec4_t *color; 

  v10 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawDebugWorldTimestep with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v10);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  color = &s_havokPhysicsDebugWorldColors[v10];
  Physics_DebugDrawGraphLine(scrPlace, *x, *y + 100.0, 200.0, 100.0, 0.0, 0.050000001, MutableWorld->timeStepDebugHistoryRaw, 300, MutableWorld->timeStepDebugHistoryStart, color);
  Physics_DebugDrawGraphLine(scrPlace, *x + 210.0, *y + 100.0, 200.0, 100.0, 0.0, 0.050000001, MutableWorld->timeStepDebugHistoryUsed, 300, MutableWorld->timeStepDebugHistoryStart, color);
  if ( drawFrame )
  {
    Physics_DebugDrawGraphAxes(scrPlace, *x, *y + 100.0, 200.0, 100.0, 0.0, 0.050000001);
    Physics_DebugDrawGraphAxes(scrPlace, *x + 210.0, *y + 100.0, 200.0, 100.0, 0.0, 0.050000001);
    *y = *y + 100.0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_DrawPhysicsAssetId
==============
*/
void HavokPhysics_DrawPhysicsAssetId(bool sortByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v8; 
  __int64 v9; 
  bool v10; 
  int v11; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v12; 
  __int64 m_hashMod; 
  __int64 v14; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 key; 
  hkMemoryAllocator *v17; 
  int v18; 
  __int64 v19; 
  __int64 v20; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v21; 
  hkBool *(__fastcall *v22)(hkBool *, const PhysicsAsset *, const PhysicsAsset *); 
  const PhysicsAsset *v23; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  float v25; 
  __int64 v26; 
  __int64 m_size; 
  float v28; 
  unsigned int v29; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment *v30; 
  __int64 v31; 
  __int64 v32; 
  const char *v33; 
  unsigned __int16 m_value; 
  unsigned __int8 v35; 
  const char *v36; 
  unsigned __int16 v37; 
  HavokPhysicsMotionPropertiesList *list; 
  const char *v39; 
  __int64 v40; 
  unsigned __int64 m_userData_high; 
  float m_mass; 
  hkRefCountedProperties *m_ptr; 
  hkReferencedObject *v44; 
  __int64 v45; 
  int m_storage; 
  const char *v47; 
  const char *v48; 
  int v49; 
  int v50; 
  int v51; 
  float v52; 
  __int64 v53; 
  float v54; 
  char *v55; 
  const char *v56; 
  const char *v57; 
  unsigned int v58; 
  bool v59; 
  __int64 v60; 
  const char *v61; 
  __int64 v62; 
  __int64 v63; 
  float v64; 
  unsigned int v65; 
  float *v66; 
  float *v67; 
  unsigned __int8 v68; 
  float v69; 
  float *v74; 
  float *v75; 
  const char *v76; 
  float *v77; 
  __int64 v78; 
  float v79; 
  const char *v80; 
  float *v81; 
  float *v82; 
  const char *v83; 
  float *v84; 
  const char *v85; 
  const char *v86; 
  __int64 v87; 
  float *v88; 
  float *v89; 
  const char *v90; 
  const char *v91; 
  const char *v92; 
  float *v93; 
  const char *v94; 
  const char *v95; 
  float *v96; 
  float *v97; 
  const char *v98; 
  __int64 v99; 
  __int64 v100; 
  __int64 v101; 
  float *v102; 
  float *v103; 
  float *v104; 
  const char *v105; 
  float *v106; 
  float *v107; 
  const char *v108; 
  float *v109; 
  float v110; 
  float v111; 
  float v112; 
  float v113; 
  float *v114; 
  float *v115; 
  float *v116; 
  float *v117; 
  const char *v118; 
  float v119; 
  float v120; 
  float v121; 
  hkMemoryAllocator *v122; 
  char *fmt; 
  __int64 shadow; 
  int v126; 
  unsigned int v127; 
  int v128; 
  unsigned int v129; 
  char *v130; 
  PhysicsAsset **array; 
  int v132; 
  int v133; 
  int v134; 
  const char *v135; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  const ScreenPlacement *v137; 
  const HavokPhysicsAsset *v138; 
  __int64 v139; 
  hkDiagonalizedMassProperties props; 
  char dest[256]; 

  v139 = -2i64;
  v8 = scrPlace;
  v137 = scrPlace;
  v9 = assetId;
  v10 = sortByName;
  array = NULL;
  v132 = 0;
  v133 = 0x80000000;
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v11 = 0;
  v12 = s_havokPhysicsAssets;
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    v14 = 0i64;
    m_elem = s_havokPhysicsAssets->m_map.m_elem;
    do
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v11;
      ++v14;
      ++m_elem;
    }
    while ( v14 <= m_hashMod );
  }
  if ( v11 <= (int)m_hashMod )
  {
    do
    {
      key = v12->m_map.m_elem[v11].key;
      if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18340, ASSERT_TYPE_ASSERT, "(physAsset)", (const char *)&queryFormat, "physAsset") )
        __debugbreak();
      v17 = hkMemHeapAllocator();
      v18 = v132;
      if ( v132 == (v133 & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v17, &array, 8);
        v18 = v132;
      }
      array[v18] = (PhysicsAsset *)key;
      ++v132;
      ++v11;
      v12 = s_havokPhysicsAssets;
      v19 = s_havokPhysicsAssets->m_map.m_hashMod;
      if ( v11 > (int)v19 )
        break;
      v20 = v11;
      v21 = &s_havokPhysicsAssets->m_map.m_elem[v11];
      do
      {
        if ( v21->key != -1i64 )
          break;
        ++v11;
        ++v20;
        ++v21;
      }
      while ( v20 <= v19 );
    }
    while ( v11 <= (int)v19 );
    v8 = v137;
    v10 = sortByName;
  }
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  Com_sprintf<256>((char (*)[256])dest, "%i Assets found", (unsigned int)v132);
  Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  if ( (int)v9 < 0 || (int)v9 >= v132 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset %i is invalid index", (unsigned int)v9);
    Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    goto LABEL_226;
  }
  if ( v10 )
  {
    if ( v132 > 1 )
    {
      v22 = HavokPhysics_PhysicsAssetSortByName;
LABEL_24:
      hkAlgorithm::quickSortRecursive<PhysicsAsset *,hkBool (*)(PhysicsAsset const *,PhysicsAsset const *)>(array, 0, v132 - 1, v22);
    }
  }
  else if ( v132 > 1 )
  {
    v22 = HavokPhysics_PhysicsAssetSortByMemory;
    goto LABEL_24;
  }
  v23 = array[v9];
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(v23);
  v138 = HavokPhysicsAsset;
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  Com_sprintf<256>((char (*)[256])dest, "Asset %s - %zu bytes", v23->name, v23->havokDataSize + 88i64);
  Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  v25 = tabWidth + *x;
  *x = v25;
  v26 = (__int64)m_physicsSystemData;
  m_size = (unsigned int)m_physicsSystemData->m_bodyCinfos.m_size;
  if ( (int)m_size > 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i BodyCinfos", m_size);
    Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v25 = *x;
  }
  v28 = v25 + tabWidth;
  *x = v28;
  v29 = 0;
  v128 = 0;
  v30 = *(hknpPhysicsSystemData::bodyCinfoWithAttachment **)(v26 + 56);
  if ( v30 != &v30[*(int *)(v26 + 64)] )
  {
    v31 = 0i64;
    do
    {
      v32 = v29;
      v33 = "BodyCinfo %i name:%s MUTABLE";
      if ( !HavokPhysicsAsset->m_mutable.m_data[v31] )
        v33 = "BodyCinfo %i name:%s";
      Com_sprintf<256>((char (*)[256])dest, v33, v32, (unsigned __int64)v30->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "SimulationCategory: %s", s_physicsAssetSimulationCategoryNames[HavokPhysicsAsset->m_simulationCategories.m_data[v31]]);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      Com_sprintf<256>((char (*)[256])dest, "Shape:");
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      HavokPhysics_DrawPhysicsShape(v30->m_shape.m_ptr, v8, x, y, tabWidth, charHeight);
      *x = *x - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "Collision Filter Info: %i", v30->m_collisionFilterInfo);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      m_value = v30->m_materialId.m_value;
      if ( m_value == 0xFFFF )
        v129 = -1;
      else
        v129 = m_value;
      if ( m_value == 0xFFFF )
        v135 = "Invalid";
      else
        v135 = (const char *)((unsigned __int64)s_havokPhysicsMaterialLibrary.list->m_materials.m_data[m_value - (unsigned __int64)s_havokPhysicsMaterialLibrary.firstId.m_value].m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      v35 = v30->m_qualityId.m_value;
      if ( v35 == 0xFF )
        v134 = -1;
      else
        v134 = v35;
      if ( v35 == 0xFF )
        v36 = "Invalid";
      else
        v36 = (const char *)((unsigned __int64)s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data[v35 - 16].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      v37 = v30->m_motionPropertiesId.m_value;
      if ( v37 == 0xFFFF )
        v126 = -1;
      else
        v126 = v37;
      if ( v37 == 0xFFFF )
      {
        v39 = "Invalid";
      }
      else
      {
        list = s_havokPhysicsMotionPropertiesLibrary.list;
        v39 = (const char *)((unsigned __int64)list->m_motionPropertiesNames.m_data[HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId(v30->m_motionPropertiesId)].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      }
      LODWORD(shadow) = v126;
      LODWORD(fmt) = v134;
      Com_sprintf<256>((char (*)[256])dest, "Material: %i %s Quality: %i %s MotionProperties: %i %s", v129, v135, fmt, v36, shadow, v39);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      v40 = v30->m_userData & 0x20;
      m_userData_high = HIDWORD(v30->m_userData);
      if ( m_userData_high > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)m_userData_high, "unsigned", HIDWORD(v30->m_userData)) )
        __debugbreak();
      Com_sprintf<256>((char (*)[256])dest, "UserData: %x %x", (unsigned int)m_userData_high, (unsigned int)v40);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "MotionType: %s", motionTypeNames[v30->m_motionType.m_storage]);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Position:    (%.3f, %.3f, %.3f, %.3f)", v30->m_position.m_quad.m128_f32[0], v30->m_position.m_quad.m128_f32[1], v30->m_position.m_quad.m128_f32[2], v30->m_position.m_quad.m128_f32[3]);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Orientation: (%.3f, %.3f, %.3f, %.3f)", v30->m_orientation.m_vec.m_quad.m128_f32[0], v30->m_orientation.m_vec.m_quad.m128_f32[1], v30->m_orientation.m_vec.m_quad.m128_f32[2], v30->m_orientation.m_vec.m_quad.m128_f32[3]);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      m_mass = v30->m_mass;
      if ( m_mass < 0.0 && v30->m_shape.m_ptr )
      {
        m_ptr = v30->m_shape.m_ptr->m_properties.m_ptr;
        if ( m_ptr )
        {
          v44 = hkRefCountedProperties::accessProperty(m_ptr, 0xF100u);
          if ( v44 )
            hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v44[1], &props);
        }
        m_mass = props.m_mass;
      }
      Com_sprintf<256>((char (*)[256])dest, "Mass: %.2f", m_mass);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      if ( (v30->m_desiredBodyId.m_serialAndIndex & 0xFFFFFF) != 0xFFFFFF )
      {
        Com_sprintf<256>((char (*)[256])dest, "DesiredBodyId: %i", v30->m_desiredBodyId.m_serialAndIndex);
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v45 = v30->m_motionId.m_value;
      if ( (_DWORD)v45 != 0x7FFFFFFF )
      {
        Com_sprintf<256>((char (*)[256])dest, "MotionCinfo Id: %i", v45);
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      Com_sprintf<256>((char (*)[256])dest, "Activation Priority %i", (unsigned int)v30->m_activationPriority);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Flags: %i CollisionControl: %i", (unsigned int)v30->m_flags.m_storage, v30->m_collisionCntrl.m_storage);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      m_storage = v30->m_flags.m_storage;
      if ( (m_storage & 1) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_STATIC");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 2) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_DYNAMIC");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 4) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_KEYFRAMED");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 8) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_ACTIVE");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x10) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_TRIGGER_EVENTS");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x40) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_MANIFOLD_EVENTS");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x80u) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONTACT_IMPULSE_EVENTS");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x100) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_COLLIDE");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x200) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_BUILD_CONTACT_JACOBIANS");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x4000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_NON_RUNTIME");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x8000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_BREAKABLE");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        m_storage = v30->m_flags.m_storage;
      }
      if ( (m_storage & 0x10000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IW_MOTION_USES_GRAVITY");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      *x = *x - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "Collision Look Ahead: %.3f", v30->m_collisionLookAheadDistance);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      HavokPhysicsAsset = v138;
      v47 = (const char *)((unsigned __int64)v138->m_bodySFXAssetNames.m_data[v31].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      if ( v47 && *v47 )
      {
        Com_sprintf<256>((char (*)[256])dest, "SFX Asset Name: %s", v47);
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v48 = (const char *)((unsigned __int64)HavokPhysicsAsset->m_bodyVFXAssetNames.m_data[v31].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      if ( v48 && *v48 )
      {
        Com_sprintf<256>((char (*)[256])dest, "VFX Asset Name: %s", v48);
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v49 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v31];
      if ( v49 )
      {
        v50 = v49 - 1;
        if ( v50 )
        {
          if ( v50 == 1 )
            Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Force Client Dynamic");
          else
            Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Unknown - Error");
        }
        else
        {
          Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Force Server Dynamic");
        }
      }
      else
      {
        Com_sprintf<256>((char (*)[256])dest, "ServerUsage: Default");
      }
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      v51 = HavokPhysicsAsset->m_bodyDrivers.m_data[v31];
      if ( v51 )
      {
        if ( v51 == 1 )
          Com_sprintf<256>((char (*)[256])dest, "Body Driver: Animation");
        else
          Com_sprintf<256>((char (*)[256])dest, "Body Driver: Unknown - Error");
      }
      else
      {
        Com_sprintf<256>((char (*)[256])dest, "Body Driver: Fixed Offset");
      }
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      v28 = *x - tabWidth;
      *x = v28;
      v29 = ++v128;
      ++v31;
      ++v30;
      v26 = (__int64)m_physicsSystemData;
    }
    while ( v30 != &m_physicsSystemData->m_bodyCinfos.m_data[m_physicsSystemData->m_bodyCinfos.m_size] );
  }
  v52 = v28 - tabWidth;
  *x = v28 - tabWidth;
  v53 = *(unsigned int *)(v26 + 80);
  if ( (int)v53 > 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i ConstraintCinfos", v53);
    Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v52 = *x;
  }
  v54 = v52 + tabWidth;
  *x = v52 + tabWidth;
  v127 = 0;
  v55 = *(char **)(v26 + 72);
  v130 = v55;
  if ( v55 != &v55[40 * *(int *)(v26 + 80)] )
  {
    do
    {
      props.m_centerOfMass.m_quad.m128_i32[3] = 0;
      (*(void (__fastcall **)(_QWORD, hkDiagonalizedMassProperties *))(**(_QWORD **)v55 + 32i64))(*(_QWORD *)v55, &props);
      v56 = (const char *)props.m_centerOfMass.m_quad.m128_u64[0];
      v57 = (const char *)(props.m_centerOfMass.m_quad.m128_u64[0] + props.m_centerOfMass.m_quad.m128_u32[2]);
      v135 = v57;
      v58 = 0;
      if ( props.m_centerOfMass.m_quad.m128_u64[0] < (unsigned __int64)v57 )
      {
        do
        {
          switch ( *(_WORD *)v56 )
          {
            case 0:
              v56 = (const char *)((unsigned __int64)(v56 + 15) & 0xFFFFFFFFFFFFFFF0ui64);
              break;
            case 2:
              v56 += 144;
              break;
            case 3:
            case 0x1C:
              v56 += 48;
              break;
            case 4:
              v56 += 112;
              break;
            case 5:
            case 6:
            case 9:
            case 0xB:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x12:
              v56 += 32;
              break;
            case 7:
            case 0xA:
            case 0xC:
            case 0xD:
            case 0x11:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
              v56 += 16;
              break;
            case 0x13:
            case 0x19:
            case 0x1A:
              v56 += 96;
              break;
            case 0x14:
              v56 += 64;
              break;
            default:
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18802, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Constraint") )
                __debugbreak();
              break;
          }
          ++v58;
        }
        while ( v56 < v57 );
        v8 = v137;
        v55 = v130;
      }
      v59 = (*(int (__fastcall **)(_QWORD))(**(_QWORD **)v55 + 24i64))(*(_QWORD *)v55) < 100;
      v60 = (*(int (**)(void))(**(_QWORD **)v55 + 24i64))();
      if ( v59 )
        v61 = constraintTypeNames[v60];
      else
        v61 = shapeTypeNames_0[v60 + 2];
      Com_sprintf<256>((char (*)[256])dest, "ConstraintCinfo %i type:%s", v127, v61);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      Com_sprintf<256>((char (*)[256])dest, "Flags %x", *((unsigned __int16 *)v55 + 8));
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      if ( (v55[16] & 1) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_EXPORTABLE");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (v55[16] & 2) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_IMMEDIATE");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (v55[16] & 4) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_ADDED");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (v55[16] & 8) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_DESTRUCTION_INTERNAL");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (v55[16] & 0x10) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "AUTO_REMOVE_ON_DESTRUCTION_RESET");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (v55[16] & 0x20) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "AUTO_REMOVE_ON_DESTRUCTION");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (v55[16] & 0x40) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONSTRAINT_FORCE_EVENTS");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( v55[16] < 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONSTRAINT_FORCE_EXCEEDED_EVENTS");
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      *x = *x - tabWidth;
      v62 = 0xFFFFFFFFi64;
      if ( (*((_DWORD *)v55 + 3) & 0xFFFFFF) != 0xFFFFFF )
        v62 = *((unsigned int *)v55 + 3);
      v63 = 0xFFFFFFFFi64;
      if ( (*((_DWORD *)v55 + 2) & 0xFFFFFF) != 0xFFFFFF )
        v63 = *((unsigned int *)v55 + 2);
      Com_sprintf<256>((char (*)[256])dest, "Bodies A: %i B: %i", v63, v62);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Atoms: %i", v58);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      v64 = (float)(tabWidth + *x) - tabWidth;
      *x = v64;
      v65 = 0;
      v66 = (float *)props.m_centerOfMass.m_quad.m128_u64[0];
      if ( props.m_centerOfMass.m_quad.m128_u64[0] < (unsigned __int64)v135 )
      {
        do
        {
          Com_sprintf<256>((char (*)[256])dest, "Atom: %i %s", v65, atomTypesNames[*(unsigned __int16 *)v66]);
          Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
          *y = charHeight + *y;
          *x = tabWidth + *x;
          switch ( *(_WORD *)v66 )
          {
            case 0:
              v66 = (float *)(((unsigned __int64)v66 + 15) & 0xFFFFFFFFFFFFFFF0ui64);
              break;
            case 2:
              v109 = v66;
              v66 += 36;
              Com_sprintf<256>((char (*)[256])dest, "Transform A");
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v109[4], v109[8], v109[12]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v109[5], v109[9], v109[13]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v109[6], v109[10], v109[14]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f %.3f", v109[16], v109[17], v109[18], v109[19]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Transform B");
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v109[20], v109[24], v109[28]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v109[21], v109[25], v109[29]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v109[22], v109[26], v109[30]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v110 = v109[35];
              v111 = v109[34];
              v112 = v109[33];
              v113 = v109[32];
              goto LABEL_208;
            case 3:
              v116 = v66;
              v66 += 12;
              Com_sprintf<256>((char (*)[256])dest, "Translation A");
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f %.3f", v116[4], v116[5], v116[6], v116[7]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Translation B");
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v110 = v116[11];
              v111 = v116[10];
              v112 = v116[9];
              v113 = v116[8];
LABEL_208:
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f %.3f", v113, v112, v111, v110);
              goto LABEL_155;
            case 4:
              v114 = v66;
              v115 = v66;
              v66 += 28;
              Com_sprintf<256>((char (*)[256])dest, "Rotation A");
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v114[4], v115[8], v115[12]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v115[5], v115[9], v115[13]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v115[6], v115[10], v115[14]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Rotation B");
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v114[16], v115[20], v115[24]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v115[17], v115[21], v115[25]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v115[18], v115[22], v115[26]);
              goto LABEL_155;
            case 5:
              v67 = v66;
              v66 += 8;
              Com_sprintf<256>((char (*)[256])dest, "Solving Method: %s", atomSolvingMethodsNames[*((unsigned __int8 *)v67 + 2)]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v68 = *((_BYTE *)v67 + 3);
              if ( v68 )
              {
                Com_sprintf<256>((char (*)[256])dest, "BodiesToNotify: %i", v68);
                Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              if ( *((_BYTE *)v67 + 5) )
              {
                Com_sprintf<256>((char (*)[256])dest, "LinearImpulseLimit Enabled");
                Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              v69 = v67[2];
              if ( v69 != 3.40282e38 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Breach Impulse %.3f", v69);
                Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", v67[3]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Damping %.3f", v67[4]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              _XMM0 = hkUFloat8::s_encodedFloats[*((unsigned __int8 *)v67 + 4)];
              __asm { vpcmpeqd xmm2, xmm0, xmm1 }
              _XMM1 = ((unsigned int)hkUFloat8::s_encodedFloats[*((unsigned __int8 *)v67 + 4)] + 243712) << 12;
              __asm { vblendvps xmm0, xmm1, xmm10, xmm2 }
              Com_sprintf<256>((char (*)[256])dest, "Stabilization - Velocity:%.3f Inertia:%.3f", *(float *)&_XMM0, v67[5]);
              goto LABEL_155;
            case 6:
              v75 = v66;
              v66 += 8;
              Com_sprintf<256>((char (*)[256])dest, "Length     %.3f", v75[4]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Max Length %.3f", v75[5]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Spring Constant %.3f", v75[6]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Damping %.3f", v75[7]);
              goto LABEL_155;
            case 7:
              v76 = "Axis Index %i";
              goto LABEL_160;
            case 9:
              v81 = v66;
              v66 += 8;
              Com_sprintf<256>((char (*)[256])dest, "Axis Index %i", *((unsigned __int8 *)v81 + 2));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Min %.3f Max %.3f", v81[1], v81[2]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", v81[3]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Damping %.3f", v81[4]);
              goto LABEL_155;
            case 0xA:
              v82 = v66;
              v66 += 4;
              v83 = "Disabled";
              if ( *((_BYTE *)v82 + 2) )
                v83 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v83);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Friction Axis Index %i", *((unsigned __int8 *)v82 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Max Friction Force %.3f", v82[1]);
              goto LABEL_155;
            case 0xB:
              v84 = v66;
              v66 += 8;
              v85 = "Disabled";
              if ( *((_BYTE *)v84 + 2) )
                v85 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v85);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Motor Axis Index %i", *((unsigned __int8 *)v84 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              v86 = "Target Position %.3f";
              goto LABEL_170;
            case 0xC:
              v76 = "Free Rotation Axis Index %i";
LABEL_160:
              v77 = v66;
              v78 = *((unsigned __int8 *)v66 + 2);
              v66 += 4;
              Com_sprintf<256>((char (*)[256])dest, v76, v78);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", v77[1]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v79 = v77[2];
              goto LABEL_161;
            case 0xD:
              v88 = v66;
              v66 += 4;
              Com_sprintf<256>((char (*)[256])dest, "First Axis Index %i", *((unsigned __int8 *)v88 + 2));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Second Axis Index %i", *((unsigned __int8 *)v88 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Third Axis Index %i", *((unsigned __int8 *)v88 + 4));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Number of Axes %i", *((unsigned __int8 *)v88 + 5));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", v88[2]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v79 = v88[3];
              goto LABEL_161;
            case 0xE:
              v89 = v66;
              v66 += 8;
              v90 = "Disabled";
              if ( *((_BYTE *)v89 + 2) )
                v90 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v90);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Limit Axis Index %i", *((unsigned __int8 *)v89 + 3));
              goto LABEL_178;
            case 0xF:
              v89 = v66;
              v66 += 8;
              v92 = "Disabled";
              if ( *((_BYTE *)v89 + 2) )
                v92 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v92);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Twist Axis in A - Index %i", *((unsigned __int8 *)v89 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Ref Axis in B   - Index %i", *((unsigned __int8 *)v89 + 4));
              goto LABEL_178;
            case 0x10:
              v89 = v66;
              v66 += 8;
              v91 = "Disabled";
              if ( *((_BYTE *)v89 + 2) )
                v91 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v91);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Twist Axis in A - Index %i", *((unsigned __int8 *)v89 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Ref Axis in B   - Index %i", *((unsigned __int8 *)v89 + 4));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Angle Measurement: %s", coneLimitMeasurementModeNames[*((unsigned __int8 *)v89 + 5)]);
LABEL_178:
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Angles Min:%.3f Max:%.3f", v89[2], v89[3]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Tau %.3f", v89[4]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v79 = v89[5];
LABEL_161:
              v80 = "Damping %.3f";
              goto LABEL_162;
            case 0x11:
              v93 = v66;
              v66 += 4;
              v94 = "Disabled";
              if ( *((_BYTE *)v93 + 2) )
                v94 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v94);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "First Friction Axis Index %i", *((unsigned __int8 *)v93 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Number of Friction Axes %i", *((unsigned __int8 *)v93 + 4));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v79 = v93[2];
              v80 = "Max Friction Torque %.3f";
              goto LABEL_162;
            case 0x12:
              v84 = v66;
              v66 += 8;
              v95 = "Disabled";
              if ( *((_BYTE *)v84 + 2) )
                v95 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v95);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Motor Axis Index %i", *((unsigned __int8 *)v84 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              v86 = "Target Angle %.3f";
LABEL_170:
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, v86, v84[4]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v87 = *((_QWORD *)v84 + 1);
              if ( v87 )
                Com_sprintf<256>((char (*)[256])dest, "Motor Type %s", motorTypeNames[*(char *)(v87 + 24)]);
              else
                Com_sprintf<256>((char (*)[256])dest, "No Motor set");
              goto LABEL_155;
            case 0x13:
              v96 = v66;
              v97 = v66;
              v66 += 24;
              v98 = "Disabled";
              if ( *((_BYTE *)v97 + 2) )
                v98 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v98);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Target Matrix");
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v97[4], v97[8], v97[12]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v97[5], v97[9], v97[13]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, " %.3f %.3f %.3f", v97[6], v97[10], v97[14]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v99 = *((_QWORD *)v96 + 8);
              if ( v99 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Motor Type 0: %s", motorTypeNames[*(char *)(v99 + 24)]);
                Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              v100 = *((_QWORD *)v96 + 9);
              if ( v100 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Motor Type 1: %s", motorTypeNames[*(char *)(v100 + 24)]);
                Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              v101 = *((_QWORD *)v96 + 10);
              if ( !v101 )
                break;
              Com_sprintf<256>((char (*)[256])dest, "Motor Type 2: %s", motorTypeNames[*(char *)(v101 + 24)]);
              goto LABEL_155;
            case 0x14:
              v102 = v66;
              v103 = v66;
              v66 += 16;
              Com_sprintf<256>((char (*)[256])dest, "PivotA (%.3f, %.3f, %.3f, %.3f)", v103[4], v103[5], v103[6], v103[7]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "PivotB (%.3f, %.3f, %.3f, %.3f)", v103[8], v103[9], v103[10], v103[11]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Rope Length %.3f", v102[12]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Leverage on B %.3f", v102[13]);
              goto LABEL_155;
            case 0x15:
              v104 = v66;
              v66 += 4;
              v105 = "Screw Pitch %.3f";
              if ( !*((_BYTE *)v104 + 8) )
                v105 = "Pinion Radius %.3f";
              Com_sprintf<256>((char (*)[256])dest, v105, v104[1]);
              goto LABEL_155;
            case 0x16:
              v106 = v66;
              v66 += 4;
              Com_sprintf<256>((char (*)[256])dest, "Wheel A Radius %.3f", v106[1]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v79 = v106[2];
              v80 = "Wheel B Radius %.3f";
              goto LABEL_162;
            case 0x17:
              v117 = v66;
              v66 += 4;
              v118 = "Disabled";
              if ( *((_BYTE *)v117 + 2) )
                v118 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v118);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v119 = v117[1];
              if ( v119 != 3.40282e38 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Max Linear Impulse:%.3f", v119);
                Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              v120 = v117[2];
              if ( v120 != 3.40282e38 )
              {
                Com_sprintf<256>((char (*)[256])dest, "Max Angular Impulse:%.3f", v120);
                Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              v121 = v117[3];
              if ( v121 == 1.8446726e19 )
                break;
              Com_sprintf<256>((char (*)[256])dest, "Max Angle: %.3f", v121);
              goto LABEL_155;
            case 0x18:
              v66 += 4;
              break;
            case 0x19:
            case 0x1A:
              v74 = v66;
              v66 += 24;
              Com_sprintf<256>((char (*)[256])dest, "Offset (%.3f, %.3f, %.3f, %.3f)", v74[4], v74[5], v74[6], v74[7]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Yield Strength Diag     (%.3f, %.3f, %.3f, %.3f)", v74[8], v74[9], v74[10], v74[11]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Yield Strength Off Diag (%.3f, %.3f, %.3f, %.3f)", v74[12], v74[13], v74[14], v74[15]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Ultimate Strength Diag     (%.3f, %.3f, %.3f, %.3f)", v74[16], v74[17], v74[18], v74[19]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Ultimate Strength Off Diag (%.3f, %.3f, %.3f, %.3f)", v74[20], v74[21], v74[22], v74[23]);
              goto LABEL_155;
            case 0x1C:
              v107 = v66;
              v66 += 12;
              v108 = "Disabled";
              if ( *((_BYTE *)v107 + 2) )
                v108 = "Enabled";
              Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, v108);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Forward Axis Index %i", *((unsigned __int8 *)v107 + 3));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Side Axis Index %i", *((unsigned __int8 *)v107 + 4));
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Max Friction Force %.3f", v107[6]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              Com_sprintf<256>((char (*)[256])dest, "Torque %.3f", v107[7]);
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              v79 = v107[2];
              v80 = "Wheel Radius %.3f";
LABEL_162:
              Com_sprintf<256>((char (*)[256])dest, v80, v79);
LABEL_155:
              Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
              *y = charHeight + *y;
              break;
            default:
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19478, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Constraint") )
                __debugbreak();
              break;
          }
          v64 = *x - tabWidth;
          *x = v64;
          ++v65;
        }
        while ( v66 < (float *)v135 );
        v55 = v130;
      }
      v54 = v64 - tabWidth;
      *x = v54;
      ++v127;
      v55 += 40;
      v130 = v55;
    }
    while ( v55 != (char *)&m_physicsSystemData->m_constraintCinfos.m_data[m_physicsSystemData->m_constraintCinfos.m_size] );
  }
  *x = (float)(v54 - tabWidth) - tabWidth;
LABEL_226:
  v122 = hkMemHeapAllocator();
  v132 = 0;
  if ( v133 >= 0 )
    hkMemoryAllocator::bufFree2(v122, array, 8, v133 & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawPhysicsAssets
==============
*/
void HavokPhysics_DrawPhysicsAssets(bool sortByName, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v8; 
  bool v9; 
  unsigned int v10; 
  int v11; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v12; 
  __int64 m_hashMod; 
  __int64 v14; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 key; 
  hkMemoryAllocator *v17; 
  int v18; 
  __int64 v19; 
  __int64 v20; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v21; 
  __int64 m_numElems; 
  int v23; 
  hkBool *(__fastcall *v24)(hkBool *, const PhysicsAsset *, const PhysicsAsset *); 
  float v25; 
  unsigned int v26; 
  const char ***v27; 
  hkMemoryAllocator *v28; 
  PhysicsAsset **array; 
  __int64 v31; 
  const ScreenPlacement *v32; 
  __int64 v33; 
  char dest[256]; 

  v33 = -2i64;
  v8 = scrPlace;
  v32 = scrPlace;
  v9 = sortByName;
  array = NULL;
  v31 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18260, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tDebug rendering Havok Physics Assets, but the pointermap is NULL", "s_havokPhysicsAssets") )
    __debugbreak();
  v10 = 0;
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v11 = 0;
  v12 = s_havokPhysicsAssets;
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    v14 = 0i64;
    m_elem = s_havokPhysicsAssets->m_map.m_elem;
    do
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v11;
      ++v14;
      ++m_elem;
    }
    while ( v14 <= m_hashMod );
  }
  if ( v11 <= (int)m_hashMod )
  {
    do
    {
      key = v12->m_map.m_elem[v11].key;
      if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18269, ASSERT_TYPE_ASSERT, "(physAsset)", (const char *)&queryFormat, "physAsset") )
        __debugbreak();
      v10 += *(_DWORD *)(key + 16) + 88;
      v17 = hkMemHeapAllocator();
      v18 = v31;
      if ( (_DWORD)v31 == (HIDWORD(v31) & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v17, &array, 8);
        v18 = v31;
      }
      array[v18] = (PhysicsAsset *)key;
      LODWORD(v31) = v31 + 1;
      ++v11;
      v12 = s_havokPhysicsAssets;
      v19 = s_havokPhysicsAssets->m_map.m_hashMod;
      if ( v11 > (int)v19 )
        break;
      v20 = v11;
      v21 = &s_havokPhysicsAssets->m_map.m_elem[v11];
      do
      {
        if ( v21->key != -1i64 )
          break;
        ++v11;
        ++v20;
        ++v21;
      }
      while ( v20 <= v19 );
    }
    while ( v11 <= (int)v19 );
    v8 = v32;
    v9 = sortByName;
  }
  m_numElems = (unsigned int)v12->m_map.m_numElems;
  LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
  Com_sprintf<256>((char (*)[256])dest, "%i Assets - %i bytes", m_numElems, v10);
  Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  v23 = v31;
  if ( v9 )
  {
    if ( (int)v31 <= 1 )
      goto LABEL_26;
    v24 = HavokPhysics_PhysicsAssetSortByName;
  }
  else
  {
    if ( (int)v31 <= 1 )
      goto LABEL_26;
    v24 = HavokPhysics_PhysicsAssetSortByMemory;
  }
  hkAlgorithm::quickSortRecursive<PhysicsAsset *,hkBool (*)(PhysicsAsset const *,PhysicsAsset const *)>(array, 0, v31 - 1, v24);
  v23 = v31;
LABEL_26:
  v25 = tabWidth + *x;
  *x = v25;
  v26 = 0;
  v27 = (const char ***)array;
  if ( array != &array[v23] )
  {
    do
    {
      Com_sprintf<256>((char (*)[256])dest, "%i: size:%6i name:%s", v26, *((unsigned int *)*v27 + 4), **v27);
      Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      ++v26;
      ++v27;
    }
    while ( v27 != (const char ***)&array[(int)v31] );
    v25 = *x;
  }
  *x = v25 - tabWidth;
  v28 = hkMemHeapAllocator();
  LODWORD(v31) = 0;
  if ( v31 >= 0 )
    hkMemoryAllocator::bufFree2(v28, array, 8, HIDWORD(v31) & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawPhysicsBody
==============
*/
void HavokPhysics_DrawPhysicsBody(Physics_WorldId worldId, hknpBodyId bodyId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  hknpWorld *world; 
  unsigned int v13; 
  hknpThreadSafeObjectPoolElement<hknpBody> *m_data; 
  __int64 v15; 
  int v16; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v17; 
  char *v18; 
  unsigned int m_value; 
  hknpShape *m_shape; 
  unsigned int m_storage; 
  unsigned __int8 v22; 
  __int128 *v23; 
  __int128 v24; 
  const char **p_name; 
  const char **v36; 
  double v37; 
  double v38; 
  double v39; 
  double v40; 
  __int64 v41; 
  __int64 v42; 
  __int64 v43; 
  float v44; 
  double fmt; 
  double fmta; 
  double fmtb; 
  double forceColor; 
  double forceColora; 
  double forceColorb; 
  unsigned __int16 v52; 
  unsigned int m_activationPriority; 
  unsigned int contents; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v58; 
  unsigned __int64 userData; 
  hknpShape *shape; 
  char v61; 
  unsigned __int16 v62; 
  float v63; 
  float v64; 
  float v65; 
  float v66; 
  float v67; 
  float v68; 
  __int128 v69; 
  char dest[256]; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 22051, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawPhysicsBody with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  world = MutableWorld->world;
  if ( world && (v13 = bodyId.m_serialAndIndex & 0xFFFFFF, (bodyId.m_serialAndIndex & 0xFFFFFF) != 0xFFFFFF) && v13 < world->m_bodyManager.m_bodies.m_objects.m_size && (m_data = world->m_bodyManager.m_bodies.m_objects.m_data, v15 = v13, (m_data[v15].m_pod.m_flags.m_storage & 3) != 0) && m_data[v15].m_pod.m_id.m_serialAndIndex == bodyId.m_serialAndIndex )
  {
    v16 = 8;
    v17 = &m_data[bodyId.m_serialAndIndex & 0xFFFFFF];
    v18 = &v61;
    m_value = v17->m_pod.m_motionId.m_value;
    m_shape = (hknpShape *)v17->m_pod.m_shape;
    m_storage = v17->m_pod.m_flags.m_storage;
    v22 = v17->m_pod.m_qualityId.m_value;
    userData = v17->m_pod.m_userData;
    v23 = (__int128 *)&world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)m_value];
    shape = m_shape;
    do
    {
      v24 = *v23;
      --v16;
      ++v23;
      *(_OWORD *)v18 = v24;
      v18 += 16;
    }
    while ( v16 > 0 );
    contents = v17->m_pod.m_collisionFilterInfo;
    v52 = v17->m_pod.m_materialId.m_value;
    m_activationPriority = v17->m_pod.m_activationPriority;
    __asm
    {
      vpxor   xmm1, xmm1, xmm1
      vpunpcklwd xmm5, xmm1, xmm2
    }
    _XMM0 = _mm_shuffle_ps(_XMM5, _XMM5, 255);
    __asm { vrcpps  xmm1, xmm0 }
    _XMM3 = 0i64;
    __asm { vcmpeqps xmm2, xmm3, xmm0 }
    _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM1, _XMM0)), _XMM1);
    __asm
    {
      vandnps xmm8, xmm2, xmm1
      vrcpps  xmm2, xmm5
    }
    _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM2, _XMM5)), _XMM2);
    __asm
    {
      vcmpeqps xmm3, xmm3, xmm5
      vandnps xmm3, xmm3, xmm2
    }
    v69 = _XMM3;
    if ( m_shape )
    {
      v58 = bodyId.m_serialAndIndex & 0xFFFFFF;
      Com_sprintf<256>((char (*)[256])dest, "Name: %s", (const char *)((unsigned __int64)world->m_bodyManager.m_bodyNames.m_data[v58].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      p_name = &MutableWorld->bodySFXEventAssets->m_data[v58]->name;
      if ( p_name )
      {
        Com_sprintf<256>((char (*)[256])dest, "SFX Event Asset: %s", *p_name);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v36 = &MutableWorld->bodyVFXEventAssets->m_data[v58]->name;
      if ( v36 )
      {
        Com_sprintf<256>((char (*)[256])dest, "VFX Event Asset: %s", *v36);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      Com_sprintf<256>((char (*)[256])dest, "UserData:");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      HavokPhysics_DrawPhysicsBodyUserData(worldId, userData, scrPlace, x, y, tabWidth, charHeight);
      *x = *x - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "Shape:");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      HavokPhysics_DrawPhysicsShape(shape, scrPlace, x, y, tabWidth, charHeight);
      *x = *x - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "Flags: %x", m_storage);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      if ( (m_storage & 1) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_STATIC");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 2) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_DYNAMIC");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 4) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_KEYFRAMED");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 8) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_ACTIVE");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x100) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_COLLIDE");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x200) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DONT_BUILD_CONTACT_JACOBIANS");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x10) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_TRIGGER_EVENTS");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x40) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_MANIFOLD_STATUS_EVENTS");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x80u) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "RAISE_CONTACT_IMPULSE_EVENTS");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x100000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_RESTITUTION");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x200000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIGGER_MODIFIER");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x400000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_IMPULSE_CLIPPING");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x800000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_MASS_CHANGER");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x1000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_SOFT_CONTACTS");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x2000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_SURFACE_VELOCITY");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x4000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_TIME_FACTOR");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x8000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_ANIMATED_SHAPE_VELOCITY");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x10000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "DISABLE_PENETRATION_RECOVERY");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x2000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "FLIP_BACKFACE_COLLISIONS");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x4000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_NON_RUNTIME");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x8000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IS_BREAKABLE");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      if ( (m_storage & 0x10000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "IW_MOTION_USES_GRAVITY");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      *x = *x - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "Body Quality id %i:", v22);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      if ( fullDisplay )
      {
        *x = tabWidth + *x;
        HavokPhysics_DrawPhysicsLibraryBodyQualityId(v22, scrPlace, x, y, tabWidth, charHeight);
        *x = *x - tabWidth;
      }
      Com_sprintf<256>((char (*)[256])dest, "Motion id %i:", m_value);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      if ( m_value )
      {
        *x = tabWidth + *x;
        Com_sprintf<256>((char (*)[256])dest, "Mass %.2f", *(float *)&_XMM8);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        v37 = *((float *)&v69 + 1);
        v38 = *(float *)&v69;
        forceColor = *((float *)&v69 + 3);
        fmt = *((float *)&v69 + 2);
        *y = charHeight + *y;
        Com_sprintf<256>((char (*)[256])dest, "Inertia Tensor Local (%.2f %.2f %.2f %.2f)", v38, v37, fmt, forceColor);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        Com_sprintf<256>((char (*)[256])dest, "Activation Priority %i", m_activationPriority);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        v39 = v63;
        forceColora = v65;
        fmta = v64;
        *y = charHeight + *y;
        Com_sprintf(dest, 0x100ui64, "LinVel (%.2f %.2f %.2f)", v39, fmta, forceColora);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        v40 = v66;
        forceColorb = v68;
        fmtb = v67;
        *y = charHeight + *y;
        Com_sprintf(dest, 0x100ui64, "AngVel (%.2f %.2f %.2f)", v40, fmtb, forceColorb);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        v41 = v62;
        v42 = v62;
        *y = charHeight + *y;
        Com_sprintf<256>((char (*)[256])dest, "Motion Properties Id %i", v42);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        *x = tabWidth + *x;
        v43 = (__int64)MutableWorld->world->getMotionPropertiesLibrary(&MutableWorld->world->hknpWorldReader);
        HavokPhysics_DrawPhysicsLibraryMotionPropertiesId((const hknpMotionProperties *)(*(_QWORD *)(v43 + 64) + 112 * v41), v41, scrPlace, x, y, tabWidth, charHeight);
        *x = *x - tabWidth;
      }
      HavokPhysics_DrawPhysicsContents(contents, scrPlace, x, y, tabWidth, charHeight);
      if ( fullDisplay )
      {
        Com_sprintf<256>((char (*)[256])dest, "Material ID:%i", v52);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        *x = tabWidth + *x;
        HavokPhysics_DrawPhysicsLibraryMaterialId(v52, scrPlace, x, y, tabWidth, charHeight);
        v44 = *x - tabWidth;
      }
      else
      {
        v44 = *x;
      }
      *x = v44 - tabWidth;
    }
    else
    {
      Com_sprintf<256>((char (*)[256])dest, "Not-yet setup body %i in world %i", bodyId.m_serialAndIndex, (unsigned int)worldId);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Couldn't find body %i in world %i", bodyId.m_serialAndIndex, (unsigned int)worldId);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsBodyUserData
==============
*/
void HavokPhysics_DrawPhysicsBodyUserData(Physics_WorldId worldId, unsigned __int64 userData, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v9; 
  bool RefDetailFlag; 
  unsigned __int8 RefSubSystem; 
  __int64 v12; 
  const char *v13; 
  unsigned int v14; 
  const char *WorldTransientName; 
  unsigned int v16; 
  LocalClientNum_t LocalClientForWorld; 
  __int64 v18; 
  DObj *ServerDObjForEntnum; 
  const char **v20; 
  LocalClientNum_t v21; 
  __int64 v22; 
  CgEntitySystem *v23; 
  __int64 v24; 
  int v25; 
  const char *v26; 
  const char *v27; 
  LocalClientNum_t v28; 
  const XModel *Model; 
  unsigned __int64 v30; 
  char FilterSubGroupIdFromUserData; 
  char FilterSubGroupIdNoCollideIdFromUserData; 
  bool IsClutterFromUserData; 
  bool DontCollideWithClutterFromUserData; 
  vec4_t *setColor; 
  __int64 forceColor; 
  __int64 shadow; 
  DynEntityBasis basisOut[4]; 
  unsigned int dynEntIdOut; 
  Physics_WorldId worldIda; 
  unsigned __int64 userDataa; 
  char dest[256]; 

  worldIda = worldId;
  userDataa = userData;
  v9 = truncate_cast<int,unsigned __int64>((unsigned int)userData);
  RefDetailFlag = Physics_GetRefDetailFlag(v9);
  dynEntIdOut = Physics_GetRefSystem(v9);
  RefSubSystem = Physics_GetRefSubSystem(v9);
  LOWORD(v12) = Physics_GetRefId(v9);
  v13 = (char *)&queryFormat.fmt + 3;
  if ( RefDetailFlag )
    v13 = "Detail ";
  Com_sprintf<256>((char (*)[256])dest, "%s%s", v13, refSystemNames[dynEntIdOut]);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  v14 = dynEntIdOut;
  *y = charHeight + *y;
  switch ( v14 )
  {
    case 0u:
      switch ( RefSubSystem )
      {
        case 0u:
          if ( (_WORD)v12 )
            Com_sprintf<256>((char (*)[256])dest, "General World Geometry, Terrain, Patches and Entity 0 brushes in collision tile %i", (unsigned int)(unsigned __int16)v12 - 1);
          else
            Com_sprintf<256>((char (*)[256])dest, "General World Geometry, Terrain, Patches and Entity 0 brushes");
          goto LABEL_8;
        case 1u:
          if ( (unsigned __int16)v12 >= 0x20u )
          {
            v16 = (unsigned __int16)v12 - 32;
            if ( v16 >= 0x400 )
            {
              LODWORD(shadow) = 1024;
              LODWORD(forceColor) = (unsigned __int16)v12 - 32;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16560, ASSERT_TYPE_ASSERT, "(unsigned)( tileIdx ) < (unsigned)( COLLISION_TILE_MAX_TILES )", "tileIdx doesn't index COLLISION_TILE_MAX_TILES\n\t%i not in [0, %i)", forceColor, shadow) )
                __debugbreak();
            }
            LODWORD(setColor) = v16 >> 5;
            Com_sprintf<256>((char (*)[256])dest, "Static Model Shape Geometry for tile %i grid %i,%i", v16, v16 & 0x1F, setColor);
          }
          else
          {
            if ( (unsigned __int16)v12 >= 0x20u )
            {
              LODWORD(shadow) = 32;
              LODWORD(forceColor) = (unsigned __int16)v12;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16475, ASSERT_TYPE_ASSERT, "(unsigned)( havokZoneIdx ) < (unsigned)( HAVOK_PHYSICS_MAX_ZONES )", "havokZoneIdx doesn't index HAVOK_PHYSICS_MAX_ZONES\n\t%i not in [0, %i)", forceColor, shadow) )
                __debugbreak();
            }
            if ( (_WORD)v12 )
              WorldTransientName = DB_Transients_GetWorldTransientName((unsigned __int16)v12);
            else
              WorldTransientName = "main";
            Com_sprintf<256>((char (*)[256])dest, "Static Model Shape Geometry for zone %i %s", (unsigned __int16)v12, WorldTransientName);
          }
          goto LABEL_28;
        case 2u:
          Com_sprintf<256>((char (*)[256])dest, "Patch Collision Shape Geometry");
          goto LABEL_8;
      }
      break;
    case 1u:
      LocalClientForWorld = Physics_GetLocalClientForWorld(worldIda);
      if ( LocalClientForWorld == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16607, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      DynEnt_GetBasisAndDynEntId(v9, LocalClientForWorld, basisOut, &dynEntIdOut);
      Com_sprintf<256>((char (*)[256])dest, "Basis:%s", dynEntityBasisNames[(unsigned __int8)basisOut[0]]);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Type: %s", dynEntityTypeNames[RefSubSystem >> 1]);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      v18 = dynEntIdOut;
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Id: %i", v18);
      goto LABEL_28;
    case 2u:
    case 9u:
      Com_sprintf<256>((char (*)[256])dest, "Model Type: %s", modelTypeNames[RefSubSystem]);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Entity Id: %i", (unsigned __int16)v12);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      ServerDObjForEntnum = Com_GetServerDObjForEntnum((unsigned __int16)v12);
      if ( !ServerDObjForEntnum )
        break;
      if ( !ServerDObjForEntnum->numModels )
        break;
      v20 = (const char **)*ServerDObjForEntnum->models;
      if ( !v20 )
        break;
      Com_sprintf<256>((char (*)[256])dest, "Using Model: %s", *v20);
LABEL_28:
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      break;
    case 3u:
    case 5u:
      Com_sprintf<256>((char (*)[256])dest, "Character Proxy - Entity Id: %i", (unsigned __int16)v12);
      goto LABEL_8;
    case 4u:
      v21 = Physics_GetLocalClientForWorld(worldIda);
      v22 = v21;
      if ( v21 == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16667, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      v12 = (unsigned __int16)v12;
      if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
      {
        LODWORD(shadow) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", shadow) )
          __debugbreak();
      }
      if ( (unsigned int)v22 >= CgEntitySystem::ms_allocatedCount )
      {
        LODWORD(shadow) = CgEntitySystem::ms_allocatedCount;
        LODWORD(forceColor) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      if ( !CgEntitySystem::ms_entitySystemArray[v22] )
      {
        LODWORD(shadow) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", shadow) )
          __debugbreak();
      }
      v23 = CgEntitySystem::ms_entitySystemArray[v22];
      if ( (unsigned int)v12 >= 0x800 )
      {
        LODWORD(shadow) = 2048;
        LODWORD(forceColor) = v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      v24 = (__int64)&v23->m_entities[v12];
      if ( !v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16670, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
        __debugbreak();
      v25 = *(_DWORD *)(v24 + 292);
      if ( v25 == 11 )
      {
        v26 = "Client Auth";
      }
      else
      {
        v26 = "Server Auth";
        if ( v25 != 12 )
          v26 = "Server General";
      }
      v27 = "Normal";
      if ( RefSubSystem != 1 )
        v27 = "Solid Brush Model";
      Com_sprintf<256>((char (*)[256])dest, v27);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Entity Id: %i %s", (unsigned int)v12, v26);
      goto LABEL_28;
    case 6u:
      Com_sprintf<256>((char (*)[256])dest, "Ragdoll %i body %i", RefSubSystem, (unsigned __int16)v12);
      goto LABEL_8;
    case 7u:
      if ( RefSubSystem >> 6 )
      {
        if ( RefSubSystem >> 6 == 1 )
          Com_sprintf<256>((char (*)[256])dest, "Func Glass Piece %i", (unsigned __int16)v12 | ((unsigned __int8)(RefSubSystem & 0x3F) << 16));
        else
          Com_sprintf<256>((char (*)[256])dest, "Unknown particle subsystem %i %i", RefSubSystem, (unsigned __int16)v12);
      }
      else
      {
        Com_sprintf<256>((char (*)[256])dest, "FX Particle Element %i", (unsigned __int16)v12 | ((unsigned __int8)(RefSubSystem & 0x3F) << 16));
      }
      goto LABEL_8;
    case 8u:
      Com_sprintf<256>((char (*)[256])dest, "Scriptable Collision for Scriptable %i", v9 & 0x3FFFFF);
      goto LABEL_8;
    case 0xAu:
      v28 = Physics_GetLocalClientForWorld(worldIda);
      if ( v28 == LOCAL_CLIENT_INVALID && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16761, ASSERT_TYPE_ASSERT, "(localClientNum != LOCAL_CLIENT_INVALID)", "%s\n\tInvalid local client for CG physics query", "localClientNum != LOCAL_CLIENT_INVALID") )
        __debugbreak();
      Model = CG_ClientModel_GetModel(v28, (unsigned __int16)v12, 0);
      if ( !Model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16764, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      Com_sprintf<256>((char (*)[256])dest, "Client Model %i %s", (unsigned __int16)v12, Model->name);
      goto LABEL_28;
    case 0xBu:
      Com_sprintf<256>((char (*)[256])dest, "Cloth Proxy %i:%i", (unsigned __int16)v12, RefSubSystem);
      goto LABEL_8;
    case 0xCu:
      Com_sprintf<256>((char (*)[256])dest, "Lightweight particle proxy %i:%i", (unsigned __int16)v12, RefSubSystem);
LABEL_8:
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      break;
    default:
      break;
  }
  v30 = userDataa;
  FilterSubGroupIdFromUserData = Physics_GetFilterSubGroupIdFromUserData(userDataa);
  FilterSubGroupIdNoCollideIdFromUserData = Physics_GetFilterSubGroupIdNoCollideIdFromUserData(v30);
  if ( FilterSubGroupIdFromUserData )
  {
    Com_sprintf<256>((char (*)[256])dest, "SubGroup %i flagged as not colliding with SubGroup %i", (unsigned int)FilterSubGroupIdFromUserData, (unsigned int)FilterSubGroupIdNoCollideIdFromUserData);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  IsClutterFromUserData = Physics_GetIsClutterFromUserData(v30);
  DontCollideWithClutterFromUserData = Physics_GetDontCollideWithClutterFromUserData(v30);
  if ( IsClutterFromUserData )
  {
    Com_sprintf<256>((char (*)[256])dest, "Flagged as Clutter");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( DontCollideWithClutterFromUserData )
  {
    Com_sprintf<256>((char (*)[256])dest, "Doesn't collide with bodies flagged as Clutter");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsContents
==============
*/
void HavokPhysics_DrawPhysicsContents(unsigned int contents, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  char dest[256]; 

  Com_sprintf<256>((char (*)[256])dest, "Contents %x", contents);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  if ( (contents & 1) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SOLID");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_FOLIAGE");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_VEHICLETRIGGER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x10) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_GLASS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x20) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_WATER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_AI_NOSHOOT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_MISSILECLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_ITEM");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_VEHICLECLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_ITEMCLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SKY");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_AI_NOSIGHT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_CLIPSHOT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_ACTOR");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x10000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYERCLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x8000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYER_NOSIGHT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_AI_CLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x40000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SENTIENTTRIGGER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x100000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_EXPLOSIONCLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x200000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SOUNDCLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x4000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_SOUND_REFLECT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x400000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_NONSENTIENTTRIGGER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x800000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_VEHICLE");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x1000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_MANTLE");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x2000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x20000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_USECLIP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (contents & 0x40000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CONTENTS_PLAYERTRIGGER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  *x = *x - tabWidth;
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualityId
==============
*/
void HavokPhysics_DrawPhysicsLibraryBodyQualityId(int bodyQualityId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  hknpBodyQuality *m_data; 
  __int64 v10; 
  int v11; 
  int v12; 
  char dest[256]; 

  if ( !s_havokPhysicsBodyQualityLibrary.asset )
  {
    Com_sprintf<256>((char (*)[256])dest, "No Body Quality Library Loaded");
LABEL_71:
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    return;
  }
  if ( bodyQualityId < 16 || bodyQualityId >= s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size + 16 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Body Quality Id");
    goto LABEL_71;
  }
  m_data = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_data;
  v10 = 2 * (3i64 * bodyQualityId - 48);
  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, (unsigned __int64)s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data[bodyQualityId - 16].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  Com_sprintf<256>((char (*)[256])dest, "Priority: %i", *((unsigned int *)&m_data->m_priority + 2 * v10));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "Supported Flags: %x", *(&m_data->m_supportedFlags.m_storage + 2 * v10));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  if ( (v11 & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_EXECUTION");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 4) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_SINGLE_POINT_MANIFOLD");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ALLOW_INTERIOR_TRIANGLE_COLLISIONS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_HIGHER_QUALITY_CONTACT_SOLVING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_NEIGHBOR_WELDING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_MOTION_WELDING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIANGLE_WELDING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_CONTACT_CACHING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "REQUEST_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_FRICTION_ESTIMATION");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "MERGE_FRICTION_JACOBIANS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x10000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CLIP_ANGULAR_VELOCITY");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_DISCRETE_AABB_EXPANSION");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x8000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "DO_ONE_INACTIVE_COLLIDE_STEP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v11 = *(&m_data->m_supportedFlags.m_storage + 2 * v10);
  }
  if ( (v11 & 0x80000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "POST_SOLVE_LINEAR_CAST");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  *x = *x - tabWidth;
  Com_sprintf<256>((char (*)[256])dest, "Requested Flags: %x", *(&m_data->m_requestedFlags.m_storage + 2 * v10));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  if ( (v12 & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_EXECUTION");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 4) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_GSK_SINGLE_POINT_MANIFOLD");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ALLOW_INTERIOR_TRIANGLE_COLLISIONS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_HIGHER_QUALITY_CONTACT_SOLVING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_NEIGHBOR_WELDING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_MOTION_WELDING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIANGLE_WELDING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_CONTACT_CACHING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "REQUEST_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "FORCE_LINEAR_ONLY_COLLISION_LOOK_AHEAD");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_FRICTION_ESTIMATION");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "MERGE_FRICTION_JACOBIANS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x10000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "CLIP_ANGULAR_VELOCITY");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "USE_DISCRETE_AABB_EXPANSION");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x8000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "DO_ONE_INACTIVE_COLLIDE_STEP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v12 = *(&m_data->m_requestedFlags.m_storage + 2 * v10);
  }
  if ( (v12 & 0x80000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "POST_SOLVE_LINEAR_CAST");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  *x = *x - tabWidth;
  Com_sprintf<256>((char (*)[256])dest, "Contact Caching Relative Movement Threshold:%.3f", *(&m_data->m_contactCachingRelativeMovementThreshold + 2 * v10));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "MotionRangeBreachPolicy: %s", motionRangeBreachPolicies[*((int *)&m_data->m_motionRangeBreachPolicy + 2 * v10)]);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "MotionWeldBreachPolicy: %s", motionRangeBreachPolicies[*((int *)&m_data->m_motionWeldBreachPolicy + 2 * v10)]);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = *x - tabWidth;
}

/*
==============
HavokPhysics_DrawPhysicsLibraryBodyQualitys
==============
*/
void HavokPhysics_DrawPhysicsLibraryBodyQualitys(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  float v8; 
  unsigned int v9; 
  hkStringPtr *m_data; 
  __int64 v11; 
  unsigned __int8 *v12; 
  unsigned int v13; 
  __int64 v14; 
  int setColora; 
  vec4_t *setColor; 
  char dest[256]; 

  if ( s_havokPhysicsBodyQualityLibrary.asset )
  {
    setColora = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualitys.m_size;
    Com_sprintf<256>((char (*)[256])dest, "Body Quality Library: %s - %zu bytes - %i materials", s_havokPhysicsBodyQualityLibrary.asset->name, s_havokPhysicsBodyQualityLibrary.asset->havokDataSize + 24i64, setColora);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v8 = tabWidth + *x;
    *x = v8;
    v9 = 0;
    m_data = s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data;
    if ( m_data != &m_data[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_size] )
    {
      do
      {
        v11 = -1i64;
        v12 = (unsigned __int8 *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
        v13 = -1;
        do
          ++v11;
        while ( *(_BYTE *)(((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64) + v11) );
        for ( ; v11; --v11 )
        {
          v14 = *v12++;
          v13 = (v13 >> 8) ^ g_crc32Table[v14 ^ (unsigned __int8)v13];
        }
        LODWORD(setColor) = ~v13;
        Com_sprintf<256>((char (*)[256])dest, "%i: id:%i crc:%x name:%s", v9, v9 + 16, setColor, (const char *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        ++v9;
        ++m_data;
      }
      while ( m_data != &s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_data[s_havokPhysicsBodyQualityLibrary.list->m_bodyQualityNames.m_size] );
      v8 = *x;
    }
    *x = v8 - tabWidth;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Body Quality Library Loaded");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterialId
==============
*/
void HavokPhysics_DrawPhysicsLibraryMaterialId(int materialId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  unsigned __int64 v9; 
  hknpMaterial *m_data; 
  int m_storage; 
  unsigned __int8 v12; 
  unsigned __int8 v17; 
  __int64 m_value; 
  const char *v23; 
  vec4_t *setColor; 
  char dest[256]; 

  if ( !s_havokPhysicsMaterialLibrary.asset )
  {
    Com_sprintf<256>((char (*)[256])dest, "No Material Library Loaded");
LABEL_27:
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    return;
  }
  if ( materialId < s_havokPhysicsMaterialLibrary.firstId.m_value || materialId > s_havokPhysicsMaterialLibrary.lastId.m_value )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Material Id");
    goto LABEL_27;
  }
  v9 = materialId - s_havokPhysicsMaterialLibrary.firstId.m_value;
  m_data = s_havokPhysicsMaterialLibrary.list->m_materials.m_data;
  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, (unsigned __int64)s_havokPhysicsMaterialLibrary.list->m_materials.m_data[v9].m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  Com_sprintf<256>((char (*)[256])dest, "Flags: %x", (unsigned int)m_data[v9].m_flags.m_storage);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  m_storage = m_data[v9].m_flags.m_storage;
  if ( (m_storage & 0x100000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_RESTITUTION");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    m_storage = m_data[v9].m_flags.m_storage;
  }
  if ( (m_storage & 0x200000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_TRIGGER_MODIFIER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    m_storage = m_data[v9].m_flags.m_storage;
  }
  if ( (m_storage & 0x400000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_IMPULSE_CLIPPING");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    m_storage = m_data[v9].m_flags.m_storage;
  }
  if ( (m_storage & 0x800000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_MASS_CHANGER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    m_storage = m_data[v9].m_flags.m_storage;
  }
  if ( (m_storage & 0x1000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_SOFT_CONTACTS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    m_storage = m_data[v9].m_flags.m_storage;
  }
  if ( (m_storage & 0x2000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "ENABLE_SURFACE_VELOCITY");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  *x = *x - tabWidth;
  v12 = m_data[v9].m_triggerType.m_storage;
  if ( (unsigned __int8)(v12 - 2) <= 1u )
  {
    _XMM0 = hkUFloat8::s_encodedFloats[m_data[v9].m_triggerManifoldTolerance.m_value];
    __asm { vpcmpeqd xmm2, xmm0, xmm1 }
    _XMM1 = ((unsigned int)hkUFloat8::s_encodedFloats[m_data[v9].m_triggerManifoldTolerance.m_value] + 243712) << 12;
    __asm { vblendvps xmm0, xmm1, xmm8, xmm2 }
    Com_sprintf<256>((char (*)[256])dest, "Trigger Type: %s Manifold Tolerance: %.3f", triggerTypes[v12], *(float *)&_XMM0);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Trigger Type: %s", triggerTypes[v12]);
  }
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "Dynamic/Static Friction: %s %.3f %.3f", combinePolicys[m_data[v9].m_frictionCombinePolicy.m_storage], COERCE_FLOAT(m_data[v9].m_dynamicFriction.m_value << 16), COERCE_FLOAT(m_data[v9].m_staticFriction.m_value << 16));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "Restitution: %s %.3f", combinePolicys[m_data[v9].m_restitutionCombinePolicy.m_storage], COERCE_FLOAT(m_data[v9].m_restitution.m_value << 16));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "Welding Tolerance: %.3f", m_data[v9].m_weldingTolerance);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "Max Contact Impulse: %.3f Fraction to Apply:%.3f", m_data[v9].m_maxContactImpulse, m_data[v9].m_fractionOfClippedImpulseToApply);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  v17 = m_data[v9].m_massChangerCategory.m_storage;
  if ( v17 == 2 )
    Com_sprintf<256>((char (*)[256])dest, "Mass changer category: %s Factor:%.3f", massChangerCategorys[2], COERCE_FLOAT(m_data[v9].m_massChangerHeavyObjectFactor.m_value << 16));
  else
    Com_sprintf<256>((char (*)[256])dest, "Mass changer category: %s", massChangerCategorys[v17]);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  m_value = (unsigned int)m_data[v9].m_softContactDampFactor.m_value;
  _XMM0 = hkUFloat8::s_encodedFloats[m_data[v9].m_softContactSeparationVelocity.m_value];
  __asm { vpcmpeqd xmm2, xmm0, xmm1 }
  _XMM1 = ((unsigned int)hkUFloat8::s_encodedFloats[m_data[v9].m_softContactSeparationVelocity.m_value] + 243712) << 12;
  __asm { vblendvps xmm0, xmm1, xmm8, xmm2 }
  LODWORD(setColor) = m_data[v9].m_softContactDampFactor.m_value;
  Com_sprintf<256>((char (*)[256])dest, "SoftContact Force: %i %.3f Damp: %i %.3f Separation %.3f", m_value, COERCE_FLOAT((_DWORD)m_value << 16), setColor, COERCE_FLOAT((_DWORD)m_value << 16), *(float *)&_XMM0);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  v23 = "Surface Velocity is set";
  if ( !m_data[v9].m_surfaceVelocity )
    v23 = "Surface Velocity not set";
  Com_sprintf<256>((char (*)[256])dest, v23);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "Disable Distance: %i %.3f", (unsigned int)m_data[v9].m_disablingCollisionsBetweenCvxCvxDynamicObjectsDistance.m_value, COERCE_FLOAT(m_data[v9].m_disablingCollisionsBetweenCvxCvxDynamicObjectsDistance.m_value << 16));
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "User Data: %llu", m_data[v9].m_userData);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = *x - tabWidth;
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMaterials
==============
*/
void HavokPhysics_DrawPhysicsLibraryMaterials(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  float v8; 
  unsigned int v9; 
  hknpMaterial *m_data; 
  __int64 v11; 
  __int64 v12; 
  unsigned int v13; 
  unsigned __int8 *v14; 
  __int64 v15; 
  int setColora; 
  vec4_t *setColor; 
  char dest[256]; 

  if ( s_havokPhysicsMaterialLibrary.asset )
  {
    setColora = s_havokPhysicsMaterialLibrary.list->m_materials.m_size;
    Com_sprintf<256>((char (*)[256])dest, "Material Library: %s - %zu bytes - %i materials", s_havokPhysicsMaterialLibrary.asset->name, s_havokPhysicsMaterialLibrary.asset->havokDataSize + 24i64, setColora);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v8 = tabWidth + *x;
    *x = v8;
    v9 = 0;
    m_data = s_havokPhysicsMaterialLibrary.list->m_materials.m_data;
    if ( s_havokPhysicsMaterialLibrary.list->m_materials.m_data != &s_havokPhysicsMaterialLibrary.list->m_materials.m_data[s_havokPhysicsMaterialLibrary.list->m_materials.m_size] )
    {
      do
      {
        if ( s_havokPhysicsMaterialLibrary.firstId.m_value == 0xFFFF )
          v11 = 0xFFFFFFFFi64;
        else
          v11 = v9 + s_havokPhysicsMaterialLibrary.firstId.m_value;
        v12 = -1i64;
        v13 = -1;
        v14 = (unsigned __int8 *)((unsigned __int64)m_data->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
        do
          ++v12;
        while ( *(_BYTE *)(((unsigned __int64)m_data->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64) + v12) );
        for ( ; v12; --v12 )
        {
          v15 = *v14++;
          v13 = (v13 >> 8) ^ g_crc32Table[v15 ^ (unsigned __int8)v13];
        }
        LODWORD(setColor) = ~v13;
        Com_sprintf<256>((char (*)[256])dest, "%i: id:%i CRC:%x name:%s", v9, v11, setColor, (const char *)((unsigned __int64)m_data->m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        ++v9;
        ++m_data;
      }
      while ( m_data != &s_havokPhysicsMaterialLibrary.list->m_materials.m_data[s_havokPhysicsMaterialLibrary.list->m_materials.m_size] );
      v8 = *x;
    }
    *x = v8 - tabWidth;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Material Library Loaded");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionProperties
==============
*/
void HavokPhysics_DrawPhysicsLibraryMotionProperties(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  float v8; 
  unsigned int v9; 
  hkStringPtr *m_data; 
  __int64 m_value; 
  __int64 v12; 
  unsigned int v13; 
  unsigned __int8 *v14; 
  __int64 v15; 
  int setColora; 
  vec4_t *setColor; 
  hknpMotionPropertiesId result; 
  char dest[256]; 

  if ( s_havokPhysicsMotionPropertiesLibrary.asset )
  {
    setColora = s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_size;
    Com_sprintf<256>((char (*)[256])dest, "Motion Properties Library: %s - %zu bytes - %i materials", s_havokPhysicsMotionPropertiesLibrary.asset->name, s_havokPhysicsMotionPropertiesLibrary.asset->havokDataSize + 24i64, setColora);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v8 = tabWidth + *x;
    *x = v8;
    v9 = 0;
    m_data = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_data;
    if ( m_data != &m_data[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_size] )
    {
      do
      {
        if ( s_havokPhysicsMotionPropertiesLibrary.firstId.m_value == 0xFFFF )
          m_value = 0xFFFFFFFFi64;
        else
          m_value = HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, 0, v9)->m_value;
        v12 = -1i64;
        v13 = -1;
        v14 = (unsigned __int8 *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
        do
          ++v12;
        while ( *(_BYTE *)(((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64) + v12) );
        for ( ; v12; --v12 )
        {
          v15 = *v14++;
          v13 = (v13 >> 8) ^ g_crc32Table[v15 ^ (unsigned __int8)v13];
        }
        LODWORD(setColor) = ~v13;
        Com_sprintf<256>((char (*)[256])dest, "%i: id:%i crc:%x name:%s", v9, m_value, setColor, (const char *)((unsigned __int64)m_data->m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        ++v9;
        ++m_data;
      }
      while ( m_data != &s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_data[s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_size] );
      v8 = *x;
    }
    *x = v8 - tabWidth;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Motion Properties Library Loaded");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsLibraryMotionPropertiesId
==============
*/
void HavokPhysics_DrawPhysicsLibraryMotionPropertiesId(const hknpMotionProperties *worldMotionProperties, int motionPropertiesId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int64 MotionPropertiesListIndexFromMotionPropertiesId; 
  float v11; 
  vec4_t *setColor; 
  char dest[256]; 

  if ( s_havokPhysicsMotionPropertiesLibrary.asset )
  {
    if ( motionPropertiesId >= s_havokPhysicsMotionPropertiesLibrary.firstId.m_value )
    {
      MotionPropertiesListIndexFromMotionPropertiesId = (int)HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId((const hknpMotionPropertiesId)motionPropertiesId);
      Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, (unsigned __int64)s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNames.m_data[MotionPropertiesListIndexFromMotionPropertiesId].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      if ( !worldMotionProperties )
        worldMotionProperties = &s_havokPhysicsMotionPropertiesLibrary.list->m_motionProperties.m_data[MotionPropertiesListIndexFromMotionPropertiesId];
      *x = tabWidth + *x;
      Com_sprintf<256>((char (*)[256])dest, "Flags: %x", (unsigned int)worldMotionProperties->m_flags.m_storage);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      v11 = tabWidth + *x;
      *x = v11;
      if ( (worldMotionProperties->m_flags.m_storage & 0x4000000) != 0 )
      {
        Com_sprintf<256>((char (*)[256])dest, "ENABLE_TIME_FACTOR");
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        v11 = *x;
      }
      *x = v11 - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "Factors - Gravity: %.3f Time: %.3f", worldMotionProperties->m_gravityFactor, worldMotionProperties->m_timeFactor);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Max Speeds - Linear: %.3f Angular: %.3f", worldMotionProperties->m_maxLinearSpeed, worldMotionProperties->m_maxAngularSpeed);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Damping - Linear: %.3f Angular: %.3f", worldMotionProperties->m_linearDamping, worldMotionProperties->m_angularDamping);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Solver Stabilization - Threshold: %.3f Reduction: %.3f", worldMotionProperties->m_solverStabilizationSpeedThreshold, worldMotionProperties->m_solverStabilizationSpeedReduction);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Deactivation");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      Com_sprintf<256>((char (*)[256])dest, "DistSqr: %.3f RotSqr: %.3f InvBlockSize: %.3f", worldMotionProperties->m_deactivationSettings.m_maxDistSqrd, worldMotionProperties->m_deactivationSettings.m_maxRotSqrd, worldMotionProperties->m_deactivationSettings.m_invBlockSize);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      LODWORD(setColor) = worldMotionProperties->m_deactivationSettings.m_pathingLowerThreshold;
      Com_sprintf<256>((char (*)[256])dest, "Pathing Thresholds - Upper: %i %.3f Lower: %i %.3f", (unsigned int)worldMotionProperties->m_deactivationSettings.m_pathingUpperThreshold, (float)((float)worldMotionProperties->m_deactivationSettings.m_pathingUpperThreshold * 0.000030518509), setColor, (float)((float)(int)setColor * 0.000030518509));
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Num Deactivation FrequencyPasses: %i", worldMotionProperties->m_deactivationSettings.m_numDeactivationFrequencyPasses);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Deactivation Velocity Scale Squares - Intermediate: %i Final: %i", worldMotionProperties->m_deactivationSettings.m_deactivationVelocityScaleSquare, worldMotionProperties->m_deactivationSettings.m_minimumPathingVelocityScaleSquare);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Spiking - Threshold: %i Minimum Velocity Scale Squared: %i", worldMotionProperties->m_deactivationSettings.m_spikingVelocityScaleThresholdSquared, worldMotionProperties->m_deactivationSettings.m_minimumSpikingVelocityScaleSquared);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = *x - tabWidth;
      Com_sprintf<256>((char (*)[256])dest, "FullCast");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = tabWidth + *x;
      Com_sprintf<256>((char (*)[256])dest, "Min Separation: %.3f Extra: %.3f", worldMotionProperties->m_fullCastSettings.m_minSeparation, worldMotionProperties->m_fullCastSettings.m_minExtraSeparation);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "TOI Separation: %.3f Extra: %.3f Accuracy: %.3f", worldMotionProperties->m_fullCastSettings.m_toiSeparation, worldMotionProperties->m_fullCastSettings.m_toiExtraSeparation, worldMotionProperties->m_fullCastSettings.m_toiAccuracy);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Safe Delta Relative: %.3f Absolute: %.6f", worldMotionProperties->m_fullCastSettings.m_relativeSafeDeltaTime, worldMotionProperties->m_fullCastSettings.m_absoluteSafeDeltaTime);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Keep Time: %.3f Distance: %.6f", worldMotionProperties->m_fullCastSettings.m_keepTime, worldMotionProperties->m_fullCastSettings.m_keepDistance);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      Com_sprintf<256>((char (*)[256])dest, "Max Iterations: %i", (unsigned int)worldMotionProperties->m_fullCastSettings.m_maxIterations);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
      *x = (float)(*x - tabWidth) - tabWidth;
    }
    else
    {
      Com_sprintf<256>((char (*)[256])dest, "Invalid Motion Properties Id");
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No Motion Properties Library Loaded");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetId
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v10; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  int v14; 
  int v15; 
  int v16; 
  __int64 v17; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v18; 
  PhysicsSFXEventAsset *val; 
  char dest[256]; 

  if ( !g_physicsSFXEventAssets )
  {
    Com_sprintf<256>((char (*)[256])dest, "No SFX Event Array");
LABEL_3:
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    return;
  }
  if ( assetId < 0 || assetId >= (g_physicsSFXEventAssets->m_numElems & 0x7FFFFFFF) )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Entry %i", (unsigned int)assetId);
    goto LABEL_3;
  }
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v10 = 0;
  m_hashMod = g_physicsSFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsSFXEventAssets->m_elem;
    for ( i = 0i64; i <= m_hashMod; ++i )
    {
      if ( m_elem->key != -1 )
        break;
      ++v10;
      ++m_elem;
    }
  }
  v14 = v10;
  v15 = 0;
  if ( assetId > 0 )
  {
    while ( v14 <= (int)m_hashMod )
    {
      v16 = v14 + 1;
      if ( v14 + 1 <= (int)m_hashMod )
      {
        v17 = v16;
        v18 = &g_physicsSFXEventAssets->m_elem[v16];
        do
        {
          if ( v18->key != -1 )
            break;
          ++v16;
          ++v17;
          ++v18;
        }
        while ( v17 <= m_hashMod );
      }
      ++v15;
      v14 = v16;
      if ( v15 >= assetId )
        goto LABEL_17;
    }
    goto LABEL_18;
  }
LABEL_17:
  if ( v14 > (int)m_hashMod )
  {
LABEL_18:
    Com_sprintf<256>((char (*)[256])dest, "Invalid SFX Asset Id");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    return;
  }
  val = g_physicsSFXEventAssets->m_elem[v14].val;
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( val )
  {
    Com_sprintf<256>((char (*)[256])dest, "SFXEventAsset %i Name %s Priority %i", (unsigned int)assetId, val->name, val->priority);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    HavokPhysics_DrawPhysicsSFXEventAssetIdRules(&val->rules, scrPlace, x, y, tabWidth, charHeight);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Missing Entry %i", (unsigned int)assetId);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetIdRule
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssetIdRule(PhysicsSFXEventAssetRule *rule, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  char *hitSoundAlias; 
  char *scrapeSoundAlias; 
  __int64 numentries; 
  float v13; 
  float v14; 
  int v15; 
  __int64 v16; 
  char *v17; 
  __int64 v18; 
  int v19; 
  __int64 v20; 
  char *v21; 
  __int64 v22; 
  int v23; 
  __int64 v24; 
  char *v25; 
  __int64 v26; 
  int v27; 
  __int64 v28; 
  char *v29; 
  __int64 v30; 
  int v31; 
  __int64 v32; 
  char *v33; 
  const char *v34; 
  __int64 v35; 
  int v36; 
  __int64 v37; 
  char *v38; 
  const char *v39; 
  __int64 v40; 
  int v41; 
  __int64 v42; 
  char *v43; 
  __int64 v44; 
  int v45; 
  __int64 v46; 
  char *v47; 
  char v48[256]; 
  char v49[256]; 
  char dest[256]; 

  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, ruleNames[rule->type]);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  switch ( rule->type )
  {
    case Types_PhysicsSFXEventSoundRule:
      hitSoundAlias = rule->u.soundRule.hitSoundAlias;
      if ( hitSoundAlias )
      {
        Com_sprintf<256>((char (*)[256])v48, "HitSound: %s", hitSoundAlias);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      scrapeSoundAlias = rule->u.soundRule.scrapeSoundAlias;
      if ( scrapeSoundAlias )
      {
        Com_sprintf<256>((char (*)[256])v48, "ScrapeSound: %s", scrapeSoundAlias);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        Com_sprintf<256>((char (*)[256])v48, "Scrape Volume Threshold: %.2f %.2f", rule->u.soundRule.scrapeSoundVolumeSpeedThresholdMin, rule->u.soundRule.scrapeSoundVolumeSpeedThresholdMax);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      return;
    case Types_PhysicsSFXEventMaterialRule:
      numentries = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)numentries > 1 )
      {
        Com_sprintf<256>((char (*)[256])v48, "%i %s", numentries, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v15 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v16 = 0i64;
      do
      {
        v17 = rule->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v49, "Surface: %s", off_147F9ABD0[*(int *)&v17[v16]]);
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v17[v16 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v15;
        v16 += 24i64;
      }
      while ( v15 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsSFXEventAngleRule:
      v18 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v18 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v18, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v19 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v20 = 0i64;
      do
      {
        v21 = rule->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v48, "Angle from Perpendicular: %.2f", *(float *)&v21[v20]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v21[v20 + 24], scrPlace, x, y, tabWidth, charHeight);
        ++v19;
        v20 += 40i64;
      }
      while ( v19 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsSFXEventSpeedRule:
      v22 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v22 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v22, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v23 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v24 = 0i64;
      do
      {
        v25 = rule->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v48, "Above Speed: %.2f", *(float *)&v25[v24]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v25[v24 + 24], scrPlace, x, y, tabWidth, charHeight);
        ++v23;
        v24 += 40i64;
      }
      while ( v23 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsSFXEventMassRule:
      v26 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v26 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v26, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v27 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v28 = 0i64;
      do
      {
        v29 = rule->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v48, "Above Mass: %.2f", *(float *)&v29[v28]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v29[v28 + 24], scrPlace, x, y, tabWidth, charHeight);
        ++v27;
        v28 += 40i64;
      }
      while ( v27 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsSFXEventGravityRule:
      v30 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v30 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v30, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v31 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v32 = 0i64;
      do
      {
        v33 = rule->u.soundRule.scrapeSoundAlias;
        v34 = "Off";
        if ( v33[v32] )
          v34 = "On";
        Com_sprintf<256>((char (*)[256])v48, "Gravity: %s", v34);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v33[v32 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v31;
        v32 += 24i64;
      }
      while ( v31 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsSFXEventAtmosphereRule:
      v35 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v35 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v35, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v36 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v37 = 0i64;
      do
      {
        v38 = rule->u.soundRule.scrapeSoundAlias;
        v39 = "Vacuum";
        if ( v38[v37] )
          v39 = "Air";
        Com_sprintf<256>((char (*)[256])v48, "Atmosphere: %s", v39);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v38[v37 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v36;
        v37 += 24i64;
      }
      while ( v36 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsSFXEventCameraDistanceRule:
      v40 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v40 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v40, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v41 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v42 = 0i64;
      do
      {
        v43 = rule->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v48, "CameraDistance: %.2f", *(float *)&v43[v42]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v43[v42 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v41;
        v42 += 24i64;
      }
      while ( v41 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsSFXEventFrequencyRule:
      v44 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v44 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v44, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v45 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v46 = 0i64;
      do
      {
        v47 = rule->u.soundRule.scrapeSoundAlias;
        Com_sprintf<256>((char (*)[256])v48, "Max Events: %i", *(unsigned int *)&v47[v46]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsSFXEventAssetIdRules((PhysicsSFXEventAssetRules *)&v47[v46 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v45;
        v46 += 24i64;
      }
      while ( v45 < rule->u.materialRule.numentries );
      break;
    default:
      return;
  }
  v14 = *x;
LABEL_58:
  *x = v14 - v13;
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssetIdRules
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssetIdRules(PhysicsSFXEventAssetRules *rules, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v7; 
  __int64 numrules; 
  float v12; 
  char dest[256]; 

  v7 = 0;
  numrules = (unsigned int)rules->numrules;
  if ( (int)numrules > 1 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i %s", numrules, "Rules");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  v12 = tabWidth + *x;
  *x = v12;
  if ( rules->numrules > 0 )
  {
    do
      HavokPhysics_DrawPhysicsSFXEventAssetIdRule(&rules->rules[v7++], scrPlace, x, y, tabWidth, charHeight);
    while ( v7 < rules->numrules );
    v12 = *x;
  }
  *x = v12 - tabWidth;
}

/*
==============
HavokPhysics_DrawPhysicsSFXEventAssets
==============
*/
void HavokPhysics_DrawPhysicsSFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int64 m_numElems; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v9; 
  unsigned int v10; 
  int v11; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  const char **p_name; 
  __int64 v16; 
  __int64 v17; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v18; 
  char dest[256]; 

  if ( g_physicsSFXEventAssets )
  {
    Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
    AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    m_numElems = (unsigned int)g_physicsSFXEventAssets->m_numElems;
    LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
    Com_sprintf<256>((char (*)[256])dest, "%i SFX Events", m_numElems);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v9 = g_physicsSFXEventAssets;
    v10 = 0;
    v11 = 0;
    m_hashMod = g_physicsSFXEventAssets->m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = g_physicsSFXEventAssets->m_elem;
      for ( i = 0i64; i <= m_hashMod; ++i )
      {
        if ( m_elem->key != -1 )
          break;
        ++v11;
        ++m_elem;
      }
    }
    if ( v11 <= (int)m_hashMod )
    {
      do
      {
        p_name = &v9->m_elem[v11].val->name;
        if ( p_name )
          Com_sprintf<256>((char (*)[256])dest, "%i: %s", v10, *p_name);
        else
          Com_sprintf<256>((char (*)[256])dest, "%i: No Asset Found", v10);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        v9 = g_physicsSFXEventAssets;
        ++v10;
        ++v11;
        v16 = g_physicsSFXEventAssets->m_hashMod;
        if ( v11 > (int)v16 )
          break;
        v17 = v11;
        v18 = &g_physicsSFXEventAssets->m_elem[v11];
        do
        {
          if ( v18->key != -1 )
            break;
          ++v11;
          ++v17;
          ++v18;
        }
        while ( v17 <= v16 );
      }
      while ( v11 <= (int)v16 );
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No SFX Event Array");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsShape
==============
*/
void HavokPhysics_DrawPhysicsShape(const hknpShape *shape, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int128 v6; 
  hknpShapeSignals *v11; 
  const char *v12; 
  unsigned __int8 m_storage; 
  __m128 v14; 
  hknpShape_vtbl *v15; 
  unsigned int v16; 
  unsigned int v17; 
  signed int i; 
  const char *MapEntsShapeName; 
  const char *NameForShape; 
  const char *v21; 
  char dest[256]; 
  __int128 v23; 

  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16830, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  v11 = shape->getMutationSignals(shape);
  v12 = "Type:%s MUTABLE";
  if ( !v11 )
    v12 = "Type:%s";
  Com_sprintf<256>((char (*)[256])dest, v12, shapeTypeNames_0[shape->m_type.m_storage]);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  m_storage = shape->m_type.m_storage;
  if ( m_storage <= 1u )
  {
    Com_sprintf<256>((char (*)[256])dest, "Radius:%.2f", shape->m_convexRadius);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v16 = shape->getNumberOfFaces((hknpShape *)shape);
    v17 = shape->getNumberOfSupportSpheres((hknpShape *)shape);
    Com_sprintf<256>((char (*)[256])dest, "Spheres:%i Faces:%i", v17, v16);
    goto LABEL_12;
  }
  if ( m_storage <= 3u )
  {
    Com_sprintf<256>((char (*)[256])dest, "Radius:%.2f", shape->m_convexRadius);
LABEL_12:
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    goto LABEL_13;
  }
  if ( m_storage == 17 )
  {
    v14 = *(__m128 *)&shape[1].m_propertyBag.m_bag;
    v15 = shape[1].__vftable;
    v23 = v6;
    Com_sprintf<256>((char (*)[256])dest, "Scale:%.2f %.2f %.2f", v14.m128_f32[0], _mm_shuffle_ps(v14, v14, 85).m128_f32[0], _mm_shuffle_ps(v14, v14, 170).m128_f32[0]);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    Com_sprintf<256>((char (*)[256])dest, "Core Shape:");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    *x = tabWidth + *x;
    HavokPhysics_DrawPhysicsShape((const hknpShape *)v15, scrPlace, x, y, tabWidth, charHeight);
    *x = *x - tabWidth;
  }
LABEL_13:
  for ( i = 0; i < WorldCollision_GetMapEntsShapeCount(); ++i )
  {
    if ( WorldCollision_GetMapEntsShape(i) == shape )
    {
      MapEntsShapeName = WorldCollision_GetMapEntsShapeName(i);
      Com_sprintf<256>((char (*)[256])dest, "MapEnts Shape: %s", MapEntsShapeName);
      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
      *y = charHeight + *y;
    }
  }
  NameForShape = StaticModels_Debug_GetNameForShape(shape);
  if ( NameForShape )
  {
    Com_sprintf<256>((char (*)[256])dest, "Static Model: %s", NameForShape);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  v21 = PatchCollision_Debug_GetNameForShape(shape);
  if ( v21 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Patch Collision: %s", v21);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsSurfaceFlags
==============
*/
void HavokPhysics_DrawPhysicsSurfaceFlags(int surfFlags, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  char v10; 
  char dest[256]; 

  Com_sprintf<256>((char (*)[256])dest, "Surface Flags %x", (unsigned int)surfFlags);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  Com_sprintf<256>((char (*)[256])dest, "Flags");
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  if ( !surfFlags )
  {
    Com_sprintf<256>((char (*)[256])dest, "Default");
LABEL_45:
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    goto LABEL_46;
  }
  if ( surfFlags == -1 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid");
    goto LABEL_45;
  }
  if ( (surfFlags & 1) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NODAMAGE");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 2) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_SLICK");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 4) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_SKY");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 8) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_LADDER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x10) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOIMPACT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x20) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOMARKS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x40) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_HDR_PORTAL");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x80u) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NODRAW");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x100) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NO_PENETRATE");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x200) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_STAIRS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x400) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOLIGHTMAP");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x800) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_GLASS_EXPOSED");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x1000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_SOFT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x2000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOSTEPS");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x4000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NONSOLID");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x20000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NODLIGHT");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x40000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_NOCASTSHADOW");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x2000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_MANTLE_ON");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( (surfFlags & 0x4000000) != 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_MANTLE_OVER");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  if ( surfFlags < 0 )
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_PORTAL");
    goto LABEL_45;
  }
LABEL_46:
  *x = *x - tabWidth;
  Com_sprintf<256>((char (*)[256])dest, "Types");
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = tabWidth + *x;
  v10 = (surfFlags >> 19) & 0x3F;
  if ( v10 )
  {
    switch ( v10 )
    {
      case 1:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_BARK");
        break;
      case 2:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_BRICK");
        break;
      case 3:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CARPET_SOLID");
        break;
      case 4:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CLOTH");
        break;
      case 5:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CONCRETE_DRY");
        break;
      case 6:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_DIRT");
        break;
      case 7:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FLESH");
        break;
      case 8:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FOLIAGE_DRY");
        break;
      case 9:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_PANE");
        break;
      case 10:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GRASS_SHORT");
        break;
      case 11:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GRAVEL");
        break;
      case 12:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ICE_SOLID");
        break;
      case 13:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_THICK");
        break;
      case 14:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_GRATE");
        break;
      case 15:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_MUD");
        break;
      case 16:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_PAPER");
        break;
      case 17:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_PLASTER");
        break;
      case 18:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ROCK");
        break;
      case 19:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_SAND");
        break;
      case 20:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_SNOW");
        break;
      case 21:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WATER");
        break;
      case 22:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WOOD_SOLID");
        break;
      case 23:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ASPHALT_DRY");
        break;
      case 24:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CERAMIC");
        break;
      case 25:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_PLASTIC");
        break;
      case 26:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_RUBBER");
        break;
      case 27:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FRUIT");
        break;
      case 28:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_CAR");
        break;
      case 29:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_RIOTSHIELD");
        break;
      case 30:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_SLUSH");
        break;
      case 31:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ASPHALT_WET");
        break;
      case 32:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CARPET_WOOD");
        break;
      case 33:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CARPET_METAL");
        break;
      case 34:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CONCRETE_WET");
        break;
      case 35:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CUSHION");
        break;
      case 36:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_DEFAULT");
        break;
      case 37:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_FOLIAGE_WET");
        break;
      case 38:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_BROKEN");
        break;
      case 39:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_SOLID");
        break;
      case 40:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GLASS_VEHICLE");
        break;
      case 41:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_GRASS_TALL");
        break;
      case 42:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_ICE_THIN");
        break;
      case 43:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_THIN");
        break;
      case 44:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_HELICOPTER");
        break;
      case 45:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_TILE");
        break;
      case 46:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_METAL_TANK");
        break;
      case 47:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_BODY_ARMOR");
        break;
      case 48:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_DRYWALL");
        break;
      case 49:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_MUD_RIVERBED");
        break;
      case 50:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WATER_KNEE");
        break;
      case 51:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WATER_WAIST");
        break;
      case 52:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_WOOD_FLOOR");
        break;
      case 53:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN1");
        break;
      case 54:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN2");
        break;
      case 55:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN3");
        break;
      case 56:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN4");
        break;
      case 57:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN5");
        break;
      case 58:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN6");
        break;
      case 59:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN7");
        break;
      case 60:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN8");
        break;
      case 61:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_USER_TERRAIN9");
        break;
      case 62:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CINDERBLOCK");
        break;
      default:
        Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_CODE_RESERVED");
        break;
    }
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "SURF_TYPE_NONE");
  }
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  *x = (float)(*x - tabWidth) - tabWidth;
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetId
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssetId(int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v10; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  int v14; 
  int v15; 
  int v16; 
  __int64 v17; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v18; 
  PhysicsVFXEventAsset *val; 
  char dest[256]; 

  if ( !g_physicsVFXEventAssets )
  {
    Com_sprintf<256>((char (*)[256])dest, "No VFX Event Array");
LABEL_3:
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    return;
  }
  if ( assetId < 0 || assetId >= (g_physicsVFXEventAssets->m_numElems & 0x7FFFFFFF) )
  {
    Com_sprintf<256>((char (*)[256])dest, "Invalid Entry %i", (unsigned int)assetId);
    goto LABEL_3;
  }
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v10 = 0;
  m_hashMod = g_physicsVFXEventAssets->m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = g_physicsVFXEventAssets->m_elem;
    for ( i = 0i64; i <= m_hashMod; ++i )
    {
      if ( m_elem->key != -1 )
        break;
      ++v10;
      ++m_elem;
    }
  }
  v14 = v10;
  v15 = 0;
  if ( assetId > 0 )
  {
    while ( v14 <= (int)m_hashMod )
    {
      v16 = v14 + 1;
      if ( v14 + 1 <= (int)m_hashMod )
      {
        v17 = v16;
        v18 = &g_physicsVFXEventAssets->m_elem[v16];
        do
        {
          if ( v18->key != -1 )
            break;
          ++v16;
          ++v17;
          ++v18;
        }
        while ( v17 <= m_hashMod );
      }
      ++v15;
      v14 = v16;
      if ( v15 >= assetId )
        goto LABEL_17;
    }
    goto LABEL_18;
  }
LABEL_17:
  if ( v14 > (int)m_hashMod )
  {
LABEL_18:
    Com_sprintf<256>((char (*)[256])dest, "Invalid VFX Asset Id");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    return;
  }
  val = g_physicsVFXEventAssets->m_elem[v14].val;
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( val )
  {
    Com_sprintf<256>((char (*)[256])dest, "VFXEventAsset %i Name %s Priority %i", (unsigned int)assetId, val->name, val->priority);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    HavokPhysics_DrawPhysicsVFXEventAssetIdRules(&val->rules, scrPlace, x, y, tabWidth, charHeight);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Missing Entry %i", (unsigned int)assetId);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetIdRule
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssetIdRule(PhysicsVFXEventAssetRule *rule, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  char *hitParticleEffectAlias; 
  char *scrapeParticleEffectAlias; 
  __int64 numentries; 
  float v13; 
  float v14; 
  int v15; 
  __int64 v16; 
  char *v17; 
  __int64 v18; 
  int v19; 
  __int64 v20; 
  char *v21; 
  __int64 v22; 
  int v23; 
  __int64 v24; 
  char *v25; 
  __int64 v26; 
  int v27; 
  __int64 v28; 
  char *v29; 
  __int64 v30; 
  int v31; 
  __int64 v32; 
  char *v33; 
  const char *v34; 
  __int64 v35; 
  int v36; 
  __int64 v37; 
  char *v38; 
  const char *v39; 
  __int64 v40; 
  int v41; 
  __int64 v42; 
  char *v43; 
  __int64 v44; 
  int v45; 
  __int64 v46; 
  char *v47; 
  char v48[256]; 
  char v49[256]; 
  char dest[256]; 

  Com_sprintf<256>((char (*)[256])dest, (const char *)&queryFormat, ruleNames_0[rule->type]);
  Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  switch ( rule->type )
  {
    case Types_PhysicsVFXEventParticleEffectRule:
      hitParticleEffectAlias = rule->u.particleEffectRule.hitParticleEffectAlias;
      if ( hitParticleEffectAlias )
      {
        Com_sprintf<256>((char (*)[256])v48, "Hit Particle Effect: %s", hitParticleEffectAlias);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      scrapeParticleEffectAlias = rule->u.particleEffectRule.scrapeParticleEffectAlias;
      if ( scrapeParticleEffectAlias )
      {
        Com_sprintf<256>((char (*)[256])v48, "Scrape Particle Effect: %s", scrapeParticleEffectAlias);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      return;
    case Types_PhysicsVFXEventMaterialRule:
      numentries = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)numentries > 1 )
      {
        Com_sprintf<256>((char (*)[256])v48, "%i %s", numentries, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v15 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v16 = 0i64;
      do
      {
        v17 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v49, "Surface: %s", off_147F9AEA0[*(int *)&v17[v16]]);
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v17[v16 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v15;
        v16 += 24i64;
      }
      while ( v15 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsVFXEventAngleRule:
      v18 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v18 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v18, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v19 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v20 = 0i64;
      do
      {
        v21 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v48, "Angle from Perpendicular: %.2f", *(float *)&v21[v20]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v21[v20 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v19;
        v20 += 24i64;
      }
      while ( v19 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsVFXEventSpeedRule:
      v22 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v22 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v22, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v23 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v24 = 0i64;
      do
      {
        v25 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v48, "Above Speed: %.2f", *(float *)&v25[v24]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v25[v24 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v23;
        v24 += 24i64;
      }
      while ( v23 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsVFXEventMassRule:
      v26 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v26 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v26, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v27 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v28 = 0i64;
      do
      {
        v29 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v48, "Above Mass: %.2f", *(float *)&v29[v28]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v29[v28 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v27;
        v28 += 24i64;
      }
      while ( v27 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsVFXEventGravityRule:
      v30 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v30 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v30, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v31 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v32 = 0i64;
      do
      {
        v33 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        v34 = "Off";
        if ( v33[v32] )
          v34 = "On";
        Com_sprintf<256>((char (*)[256])v48, "Gravity: %s", v34);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v33[v32 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v31;
        v32 += 24i64;
      }
      while ( v31 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsVFXEventAtmosphereRule:
      v35 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v35 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v35, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v36 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v37 = 0i64;
      do
      {
        v38 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        v39 = "Vacuum";
        if ( v38[v37] )
          v39 = "Air";
        Com_sprintf<256>((char (*)[256])v48, "Atmosphere: %s", v39);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v38[v37 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v36;
        v37 += 24i64;
      }
      while ( v36 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsVFXEventCameraDistanceRule:
      v40 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v40 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v40, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v41 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v42 = 0i64;
      do
      {
        v43 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v48, "CameraDistance: %.2f", *(float *)&v43[v42]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v43[v42 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v41;
        v42 += 24i64;
      }
      while ( v41 < rule->u.materialRule.numentries );
      break;
    case Types_PhysicsVFXEventFrequencyRule:
      v44 = (unsigned int)rule->u.materialRule.numentries;
      if ( (int)v44 > 1 )
      {
        Com_sprintf<256>((char (*)[256])v49, "%i %s", v44, "Entries");
        Physics_DrawDebugString(scrPlace, *x, *y, v49, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
      }
      v13 = tabWidth;
      v14 = tabWidth + *x;
      *x = v14;
      v45 = 0;
      if ( rule->u.materialRule.numentries <= 0 )
        goto LABEL_58;
      v46 = 0i64;
      do
      {
        v47 = rule->u.particleEffectRule.scrapeParticleEffectAlias;
        Com_sprintf<256>((char (*)[256])v48, "Max Events: %i", *(unsigned int *)&v47[v46]);
        Physics_DrawDebugString(scrPlace, *x, *y, v48, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        HavokPhysics_DrawPhysicsVFXEventAssetIdRules((PhysicsVFXEventAssetRules *)&v47[v46 + 8], scrPlace, x, y, tabWidth, charHeight);
        ++v45;
        v46 += 24i64;
      }
      while ( v45 < rule->u.materialRule.numentries );
      break;
    default:
      return;
  }
  v14 = *x;
LABEL_58:
  *x = v14 - v13;
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssetIdRules
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssetIdRules(PhysicsVFXEventAssetRules *rules, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  int v7; 
  __int64 numrules; 
  float v12; 
  char dest[256]; 

  v7 = 0;
  numrules = (unsigned int)rules->numrules;
  if ( (int)numrules > 1 )
  {
    Com_sprintf<256>((char (*)[256])dest, "%i %s", numrules, "Rules");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
  v12 = tabWidth + *x;
  *x = v12;
  if ( rules->numrules > 0 )
  {
    do
      HavokPhysics_DrawPhysicsVFXEventAssetIdRule(&rules->rules[v7++], scrPlace, x, y, tabWidth, charHeight);
    while ( v7 < rules->numrules );
    v12 = *x;
  }
  *x = v12 - tabWidth;
}

/*
==============
HavokPhysics_DrawPhysicsVFXEventAssets
==============
*/
void HavokPhysics_DrawPhysicsVFXEventAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int64 m_numElems; 
  unsigned int v9; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v10; 
  int v11; 
  __int64 m_hashMod; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  __int64 i; 
  const char **p_name; 
  __int64 v16; 
  __int64 v17; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v18; 
  char dest[256]; 

  if ( g_physicsVFXEventAssets )
  {
    m_numElems = (unsigned int)g_physicsVFXEventAssets->m_numElems;
    LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
    Com_sprintf<256>((char (*)[256])dest, "%i VFX Events", m_numElems);
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    v9 = 0;
    *y = charHeight + *y;
    Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
    AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    v10 = g_physicsVFXEventAssets;
    v11 = 0;
    m_hashMod = g_physicsVFXEventAssets->m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = g_physicsVFXEventAssets->m_elem;
      for ( i = 0i64; i <= m_hashMod; ++i )
      {
        if ( m_elem->key != -1 )
          break;
        ++v11;
        ++m_elem;
      }
    }
    if ( v11 <= (int)m_hashMod )
    {
      do
      {
        p_name = &v10->m_elem[v11].val->name;
        if ( p_name )
          Com_sprintf<256>((char (*)[256])dest, "%i: %s", v9, *p_name);
        else
          Com_sprintf<256>((char (*)[256])dest, "%i: No Asset Found", v9);
        Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        v10 = g_physicsVFXEventAssets;
        ++v9;
        ++v11;
        v16 = g_physicsVFXEventAssets->m_hashMod;
        if ( v11 > (int)v16 )
          break;
        v17 = v11;
        v18 = &g_physicsVFXEventAssets->m_elem[v11];
        do
        {
          if ( v18->key != -1 )
            break;
          ++v11;
          ++v17;
          ++v18;
        }
        while ( v17 <= v16 );
      }
      while ( v11 <= (int)v16 );
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "No VFX Event Array");
    Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
  }
}

/*
==============
HavokPhysics_DrawPhysicsXModelId
==============
*/
void HavokPhysics_DrawPhysicsXModelId(bool indexByName, int assetId, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  const ScreenPlacement *v8; 
  int v9; 
  bool v10; 
  __int64 v11; 
  int v12; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v13; 
  __int64 v14; 
  const XModel *v15; 
  hkMemoryAllocator *v16; 
  int v17; 
  hkBool *(__fastcall *v18)(hkBool *, const XModel *, const XModel *); 
  const XModel *v19; 
  XModelDetailCollision *detailCollision; 
  unsigned int physicsLODDataSize; 
  __int64 v22; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  const HavokPhysicsXModelLOD *v24; 
  float v25; 
  int v26; 
  hknpShape *v27; 
  float v28; 
  int v29; 
  __int64 v30; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *m_data; 
  int m_surfaceFlags; 
  unsigned int m_collisionFilterInfo; 
  hkMemoryAllocator *v34; 
  char *fmt; 
  const vec4_t *fmta; 
  char *fmtb; 
  __int64 forceColor; 
  float v39; 
  const XModel **array; 
  __int64 v42; 
  ScreenPlacement *scrPlacea; 
  __int64 v44; 
  __int64 v45; 
  char dest[256]; 

  v45 = -2i64;
  v8 = scrPlace;
  scrPlacea = (ScreenPlacement *)scrPlace;
  v9 = assetId;
  LODWORD(v44) = assetId;
  v10 = indexByName;
  v11 = 0i64;
  array = NULL;
  v42 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19854, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tDebug rendering Havok Physics XModel LOD ID, but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
    __debugbreak();
  v12 = 0;
  v13 = s_havokPhysicsXModels;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v14 = 0i64;
    do
    {
      v15 = v13->m_data[v14];
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19860, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      v16 = hkMemHeapAllocator();
      v17 = v42;
      if ( (_DWORD)v42 == (HIDWORD(v42) & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v16, &array, 8);
        v17 = v42;
      }
      array[v17] = v15;
      LODWORD(v42) = v42 + 1;
      ++v12;
      ++v14;
      v13 = s_havokPhysicsXModels;
    }
    while ( v12 < s_havokPhysicsXModels->m_size );
    v9 = v44;
    v8 = scrPlacea;
    v10 = indexByName;
    v11 = 0i64;
  }
  Com_sprintf<256>((char (*)[256])dest, "%i Assets found", (unsigned int)v42);
  Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  if ( v9 < 0 || v9 >= (int)v42 )
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset %i is invalid index", (unsigned int)v9);
    Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    goto LABEL_43;
  }
  if ( v10 )
  {
    if ( (int)v42 <= 1 )
      goto LABEL_21;
    v18 = HavokPhysics_XModelsSortByName;
  }
  else
  {
    if ( (int)v42 <= 1 )
      goto LABEL_21;
    v18 = HavokPhysics_XModelsSortByMemory;
  }
  hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v42 - 1, v18);
LABEL_21:
  v19 = array[v9];
  if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19888, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
    __debugbreak();
  detailCollision = v19->detailCollision;
  if ( detailCollision )
    physicsLODDataSize = detailCollision->physicsLODDataSize;
  else
    physicsLODDataSize = 0;
  v22 = physicsLODDataSize + 12;
  LODWORD(forceColor) = v19->collLod;
  fmt = (char *)v19->name;
  if ( v19->physicsAsset )
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset %i: size:%6i name:%s collLod:%i", (unsigned int)v9, v22, fmt, forceColor);
    v39 = charHeight;
    fmta = &colorWhite;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Asset without physics asset %i: size:%6i name:%s collLod:%i", (unsigned int)v9, v22, fmt, forceColor);
    v39 = charHeight;
    fmta = &colorRed;
  }
  Physics_DrawDebugString(v8, *x, *y, dest, fmta, 0, 1, v39, 0);
  *y = charHeight + *y;
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v19->detailCollision);
  v24 = HavokPhysicsXModelLODFromDetailCol;
  if ( HavokPhysicsXModelLODFromDetailCol )
  {
    *x = tabWidth + *x;
    Com_sprintf<256>((char (*)[256])dest, "%i Shapes", (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size);
    Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v25 = tabWidth + *x;
    *x = v25;
    v26 = 0;
    if ( v24->m_shapes.m_size > 0 )
    {
      do
      {
        v27 = v24->m_shapes.m_data[v11];
        if ( !v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19916, ASSERT_TYPE_ASSERT, "(compressedMeshShape)", (const char *)&queryFormat, "compressedMeshShape") )
          __debugbreak();
        LODWORD(fmtb) = v27[1].m_properties.m_ptr;
        Com_sprintf<256>((char (*)[256])dest, "Shape %i: Bone:%s Tris:%i", (unsigned int)v26, (const char *)((unsigned __int64)v24->m_bodyNames.m_data[v11].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), fmtb);
        Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        ++v26;
        ++v11;
      }
      while ( v26 < v24->m_shapes.m_size );
      v25 = *x;
    }
    *x = v25 - tabWidth;
    Com_sprintf<256>((char (*)[256])dest, "%i Shape Tag Datas", (unsigned int)v24->m_shapeTagData.m_size);
    Physics_DrawDebugString(v8, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v28 = tabWidth + *x;
    *x = v28;
    v29 = 0;
    if ( v24->m_shapeTagData.m_size > 0 )
    {
      v30 = 0i64;
      do
      {
        m_data = v24->m_shapeTagData.m_data;
        m_surfaceFlags = m_data[v30].m_surfaceFlags;
        m_collisionFilterInfo = m_data[v30].m_collisionFilterInfo;
        Com_sprintf<256>((char (*)[256])dest, "Shape Tag %i", (unsigned int)v29);
        Physics_DrawDebugString(scrPlacea, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
        *y = charHeight + *y;
        *x = tabWidth + *x;
        HavokPhysics_DrawPhysicsSurfaceFlags(m_surfaceFlags, scrPlacea, x, y, tabWidth, charHeight);
        HavokPhysics_DrawPhysicsContents(m_collisionFilterInfo, scrPlacea, x, y, tabWidth, charHeight);
        v28 = *x - tabWidth;
        *x = v28;
        ++v29;
        ++v30;
      }
      while ( v29 < v24->m_shapeTagData.m_size );
    }
    *x = (float)(v28 - tabWidth) - tabWidth;
  }
  else
  {
    *x = *x - tabWidth;
  }
LABEL_43:
  v34 = hkMemHeapAllocator();
  LODWORD(v42) = 0;
  if ( v42 >= 0 )
    hkMemoryAllocator::bufFree2(v34, array, 8, HIDWORD(v42) & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawPhysicsXModels
==============
*/
void HavokPhysics_DrawPhysicsXModels(Physics_DebugXModelSortType sortType, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  float *v7; 
  unsigned int v8; 
  int v9; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v10; 
  __int64 v11; 
  const XModel *v12; 
  XModelDetailCollision *detailCollision; 
  unsigned int physicsLODDataSize; 
  hkMemoryAllocator *v15; 
  int v16; 
  __int64 m_numElems; 
  ScreenPlacement *v18; 
  Physics_DebugXModelSortType v19; 
  int v20; 
  hkBool *(__fastcall *v21)(hkBool *, const XModel *, const XModel *); 
  float v22; 
  unsigned int v23; 
  const char ***v24; 
  const char **v25; 
  char v26; 
  bool v27; 
  const XModelDetailCollision *v28; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  const char *v30; 
  const vec4_t *v31; 
  const PhysicsAsset *v32; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const HavokPhysicsXModelLOD *v34; 
  hkMemoryAllocator *v35; 
  char *fmt; 
  __int64 forceColor; 
  __int64 shadow; 
  const XModel **array; 
  __int64 v41; 
  ScreenPlacement *scrPlacea; 
  float *v43; 
  __int64 v44; 
  char dest[256]; 

  v44 = -2i64;
  v7 = x;
  v43 = x;
  scrPlacea = (ScreenPlacement *)scrPlace;
  array = NULL;
  v41 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19739, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tDebug rendering Havok Physics XModel LODs, but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
    __debugbreak();
  v8 = 0;
  v9 = 0;
  v10 = s_havokPhysicsXModels;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v11 = 0i64;
    do
    {
      v12 = v10->m_data[v11];
      if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19746, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      detailCollision = v12->detailCollision;
      if ( detailCollision )
        physicsLODDataSize = detailCollision->physicsLODDataSize;
      else
        physicsLODDataSize = 0;
      v8 += physicsLODDataSize + 12;
      v15 = hkMemHeapAllocator();
      v16 = v41;
      if ( (_DWORD)v41 == (HIDWORD(v41) & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v15, &array, 8);
        v16 = v41;
      }
      array[v16] = v12;
      LODWORD(v41) = v41 + 1;
      ++v9;
      ++v11;
      v10 = s_havokPhysicsXModels;
    }
    while ( v9 < s_havokPhysicsXModels->m_size );
    v7 = v43;
  }
  m_numElems = (unsigned int)s_havokPhysicsXModelLODs->m_map.m_numElems;
  LODWORD(m_numElems) = m_numElems & 0x7FFFFFFF;
  Com_sprintf<256>((char (*)[256])dest, "%i Assets - %i bytes of colLod data", m_numElems, v8);
  v18 = scrPlacea;
  Physics_DrawDebugString(scrPlacea, *v7, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  Com_sprintf<256>((char (*)[256])dest, "Red text if there is no PhysicsAsset and not marked as ShouldNotHavePhysics");
  Physics_DrawDebugString(v18, *v7, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  *y = charHeight + *y;
  v19 = sortType;
  switch ( sortType )
  {
    case Physics_DebugXModelSortType_ByName:
      v20 = v41;
      if ( (int)v41 <= 1 )
        break;
      v21 = HavokPhysics_XModelsSortByName;
      goto LABEL_25;
    case Physics_DebugXModelSortType_ByMemory:
      v20 = v41;
      if ( (int)v41 <= 1 )
        break;
      v21 = HavokPhysics_XModelsSortByMemory;
      goto LABEL_25;
    case Physics_DebugXModelSortType_ByDetailBodyCount:
      v20 = v41;
      if ( (int)v41 > 1 )
      {
        v21 = HavokPhysics_XModelsSortByDetailBodyCount;
LABEL_25:
        hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v20 - 1, v21);
        v19 = sortType;
      }
      break;
  }
  v22 = tabWidth + *v7;
  *v7 = v22;
  v23 = 0;
  v24 = (const char ***)array;
  if ( array == &array[(int)v41] )
    goto LABEL_59;
  do
  {
    v25 = *v24;
    v26 = *((_BYTE *)*v24 + 15);
    v27 = !v26 || v26 == 3;
    v28 = (const XModelDetailCollision *)v25[80];
    if ( v19 == Physics_DebugXModelSortType_ByDetailBodyCount )
    {
      if ( v28 )
      {
        HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v28);
        if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19788, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
          __debugbreak();
        v30 = *v25;
        if ( HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_size == 1 )
        {
          LODWORD(fmt) = *((unsigned __int8 *)v25 + 11);
          Com_sprintf<256>((char (*)[256])dest, "%4i: %s with collod %i with single body", v23, v30, fmt);
        }
        else
        {
          LODWORD(forceColor) = HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_size;
          LODWORD(fmt) = *((unsigned __int8 *)v25 + 11);
          Com_sprintf<256>((char (*)[256])dest, "%4i: %s with collod %i with %i bodies + 1 bounding body", v23, v30, fmt, forceColor);
        }
LABEL_38:
        if ( v25[78] || (v31 = &colorRed, v27) )
          v31 = &colorWhite;
        v18 = scrPlacea;
        goto LABEL_52;
      }
      v32 = (const PhysicsAsset *)v25[78];
      if ( !v32 )
        goto LABEL_57;
      HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(v32);
      if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19806, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
        __debugbreak();
      LODWORD(fmt) = HavokPhysicsAsset->m_bodyServerUsage.m_size;
      Com_sprintf<256>((char (*)[256])dest, "%4i: %s with no collod with %i bodies", v23, *v25, fmt);
LABEL_51:
      v31 = &colorWhite;
      goto LABEL_52;
    }
    if ( v28 )
    {
      v34 = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v28);
      if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19826, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
        __debugbreak();
      LODWORD(shadow) = v34->m_shapes.m_size;
      LODWORD(fmt) = *((_DWORD *)v25[80] + 2) + 12;
      Com_sprintf<256>((char (*)[256])dest, "%4i:\t colLod \t%i\t size:\t%6i \tname:\t%s\t numBodies:\t%i ", v23, *((unsigned __int8 *)v25 + 11), fmt, *v25, shadow);
      goto LABEL_38;
    }
    Com_sprintf<256>((char (*)[256])dest, "%4i:\t no colLod\t\t size:\t%6i \tname:\t%s", v23, 12i64, *v25);
    if ( v25[78] )
      goto LABEL_51;
    v31 = &colorRed;
    if ( v27 )
      goto LABEL_51;
LABEL_52:
    Physics_DrawDebugString(v18, *v7, *y, dest, v31, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v19 = sortType;
LABEL_57:
    ++v23;
    ++v24;
  }
  while ( v24 != (const char ***)&array[(int)v41] );
  v22 = *v7;
LABEL_59:
  *v7 = v22 - tabWidth;
  v35 = hkMemHeapAllocator();
  LODWORD(v41) = 0;
  if ( v41 >= 0 )
    hkMemoryAllocator::bufFree2(v35, array, 8, HIDWORD(v41) & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithColLods
==============
*/
void HavokPhysics_DrawPhysicsXModelsWithColLods(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool excludeDoNotUse)
{
  float *v6; 
  float *v7; 
  const ScreenPlacement *v8; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v9; 
  int v10; 
  __int64 v11; 
  __int64 v12; 
  unsigned int numsurfs; 
  const XModelLodInfo *LodInfo; 
  unsigned __int16 surfIndex; 
  unsigned __int16 v16; 
  const char ***v17; 
  unsigned int v18; 
  hkMemoryAllocator *v19; 
  int v20; 
  hkMemoryAllocator *v21; 
  int v22; 
  hkMemoryAllocator *v23; 
  int v24; 
  unsigned int v25; 
  XModel **i; 
  const char ***v27; 
  XModel **j; 
  hkMemoryAllocator *v29; 
  hkMemoryAllocator *v30; 
  hkMemoryAllocator *v31; 
  char *fmt; 
  __int64 forceColor; 
  __int64 shadow; 
  XModel **v35; 
  __int64 v36; 
  XModel **pArr; 
  __int64 v38; 
  const XModel **array; 
  int v40; 
  int v41; 
  __int64 v42; 
  float *v43; 
  float *v44; 
  const ScreenPlacement *v45; 
  __int64 v46; 
  char dest[256]; 

  v46 = -2i64;
  v6 = y;
  v43 = y;
  v7 = x;
  v44 = x;
  v8 = scrPlace;
  v45 = scrPlace;
  array = NULL;
  v40 = 0;
  v41 = 0x80000000;
  pArr = NULL;
  v38 = 0x8000000000000000ui64;
  v35 = NULL;
  v36 = 0x8000000000000000ui64;
  v9 = s_havokPhysicsXModels;
  if ( !s_havokPhysicsXModels )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19624, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tDebug rendering Havok Physics XModels, but the array is NULL", "s_havokPhysicsXModels") )
      __debugbreak();
    v9 = s_havokPhysicsXModels;
  }
  v10 = 0;
  if ( v9->m_size > 0 )
  {
    v11 = 0i64;
    v42 = 0i64;
    do
    {
      v12 = *(__int64 *)((char *)v9->m_data + v11);
      if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19630, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      if ( !excludeDoNotUse )
        goto LABEL_26;
      if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 247, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      numsurfs = XModelGetLodInfo((const XModel *)v12, 0)->numsurfs;
      if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 257, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      LodInfo = XModelGetLodInfo((const XModel *)v12, 0);
      surfIndex = LodInfo->surfIndex;
      v16 = *(_WORD *)(v12 + 8);
      if ( surfIndex >= v16 )
      {
        LODWORD(shadow) = v16;
        LODWORD(forceColor) = surfIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 261, ASSERT_TYPE_ASSERT, "(unsigned)( lodInfo->surfIndex ) < (unsigned)( model->numsurfs )", "lodInfo->surfIndex doesn't index model->numsurfs\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      v17 = (const char ***)(*(_QWORD *)(v12 + 216) + 8i64 * LodInfo->surfIndex);
      if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19637, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
        __debugbreak();
      v18 = 0;
      if ( numsurfs )
      {
        while ( !I_stristr(**v17, "do_not_use") )
        {
          ++v18;
          ++v17;
          if ( v18 >= numsurfs )
            goto LABEL_26;
        }
      }
      else
      {
LABEL_26:
        if ( (*(_BYTE *)(v12 + 15) & 0xFD) != 0 )
        {
          if ( *(_BYTE *)(v12 + 11) == 8 )
          {
            v21 = hkMemHeapAllocator();
            v22 = v38;
            if ( (_DWORD)v38 == (HIDWORD(v38) & 0x3FFFFFFF) )
            {
              hkArrayUtil::_reserveMore(v21, &pArr, 8);
              v22 = v38;
            }
            pArr[v22] = (XModel *)v12;
            LODWORD(v38) = v38 + 1;
          }
          else
          {
            v23 = hkMemHeapAllocator();
            v24 = v36;
            if ( (_DWORD)v36 == (HIDWORD(v36) & 0x3FFFFFFF) )
            {
              hkArrayUtil::_reserveMore(v23, &v35, 8);
              v24 = v36;
            }
            v35[v24] = (XModel *)v12;
            LODWORD(v36) = v36 + 1;
          }
        }
        else
        {
          v19 = hkMemHeapAllocator();
          v20 = v40;
          if ( v40 == (v41 & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v19, &array, 8);
            v20 = v40;
          }
          array[v20] = (const XModel *)v12;
          ++v40;
        }
      }
      ++v10;
      v11 = v42 + 8;
      v42 += 8i64;
      v9 = s_havokPhysicsXModels;
    }
    while ( v10 < s_havokPhysicsXModels->m_size );
    v6 = v43;
    v7 = v44;
    v8 = v45;
  }
  if ( v40 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v40 - 1, HavokPhysics_XModelsSortByName);
  if ( (int)v38 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)pArr, 0, v38 - 1, HavokPhysics_XModelsSortByName);
  if ( (int)v36 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)v35, 0, v36 - 1, HavokPhysics_XModelsSortByName);
  Com_sprintf<256>((char (*)[256])dest, "Red text if we expect a ColLod and don't find one, white otherwise.");
  Physics_DrawDebugString(v8, *v7, *v6, dest, &colorWhite, 0, 1, charHeight, 0);
  *v6 = charHeight + *v6;
  *v7 = tabWidth + *v7;
  v25 = 0;
  for ( i = pArr; i != &pArr[(int)v38]; ++i )
  {
    Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s has no collod, but isn't flagged to expect that.", v25, (*i)->name);
    Physics_DrawDebugString(v8, *v7, *v6, dest, &colorRed, 0, 1, charHeight, 0);
    *v6 = charHeight + *v6;
    ++v25;
  }
  v27 = (const char ***)array;
  if ( array != &array[v40] )
  {
    do
    {
      Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s has no collod, but this is expected.", v25, **v27);
      Physics_DrawDebugString(v8, *v7, *v6, dest, &colorRed, 0, 1, charHeight, 0);
      *v6 = charHeight + *v6;
      ++v25;
      ++v27;
    }
    while ( v27 != (const char ***)&array[v40] );
  }
  for ( j = v35; j != &v35[(int)v36]; ++j )
  {
    LODWORD(fmt) = (*j)->detailCollision->physicsLODDataSize + 12;
    Com_sprintf<256>((char (*)[256])dest, "%4i: colLod:%i colLod size:%i name:%s", v25, (*j)->collLod, fmt, (*j)->name);
    Physics_DrawDebugString(v8, *v7, *v6, dest, &colorWhite, 0, 1, charHeight, 0);
    *v6 = charHeight + *v6;
    ++v25;
  }
  *v7 = *v7 - tabWidth;
  v29 = hkMemHeapAllocator();
  LODWORD(v36) = 0;
  if ( v36 >= 0 )
    hkMemoryAllocator::bufFree2(v29, v35, 8, HIDWORD(v36) & 0x3FFFFFFF);
  v35 = NULL;
  HIDWORD(v36) = 0x80000000;
  v30 = hkMemHeapAllocator();
  LODWORD(v38) = 0;
  if ( v38 >= 0 )
    hkMemoryAllocator::bufFree2(v30, pArr, 8, HIDWORD(v38) & 0x3FFFFFFF);
  pArr = NULL;
  HIDWORD(v38) = 0x80000000;
  v31 = hkMemHeapAllocator();
  v40 = 0;
  if ( v41 >= 0 )
    hkMemoryAllocator::bufFree2(v31, array, 8, v41 & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets
==============
*/
void HavokPhysics_DrawPhysicsXModelsWithoutPhysicsAssets(const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight, bool excludeDoNotUse)
{
  float *v6; 
  float *v7; 
  const ScreenPlacement *v8; 
  int v9; 
  __int64 v10; 
  __int64 v11; 
  unsigned int numsurfs; 
  const XModelLodInfo *LodInfo; 
  unsigned __int16 surfIndex; 
  unsigned __int16 v15; 
  const char ***v16; 
  unsigned int v17; 
  char v18; 
  hkMemoryAllocator *v19; 
  int v20; 
  hkMemoryAllocator *v21; 
  int v22; 
  int v23; 
  float v24; 
  unsigned int v25; 
  const XModel **v26; 
  const char ***v27; 
  XModel **v28; 
  XModel **v29; 
  hkMemoryAllocator *v30; 
  hkMemoryAllocator *v31; 
  __int64 forceColor; 
  __int64 shadow; 
  const XModel **array; 
  __int64 v35; 
  XModel **pArr; 
  __int64 v37; 
  __int64 v38; 
  float *v39; 
  float *v40; 
  const ScreenPlacement *v41; 
  __int64 v42; 
  char dest[256]; 

  v42 = -2i64;
  v6 = y;
  v39 = y;
  v7 = x;
  v40 = x;
  v8 = scrPlace;
  v41 = scrPlace;
  pArr = NULL;
  v37 = 0x8000000000000000ui64;
  array = NULL;
  v35 = 0x8000000000000000ui64;
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19515, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tDebug rendering Havok Physics XModels, but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  v9 = 0;
  if ( s_havokPhysicsXModels->m_size > 0 )
  {
    v10 = 0i64;
    v38 = 0i64;
    do
    {
      v11 = *(__int64 *)((char *)s_havokPhysicsXModels->m_data + v10);
      if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19521, ASSERT_TYPE_ASSERT, "(xmodel)", (const char *)&queryFormat, "xmodel") )
        __debugbreak();
      if ( !excludeDoNotUse )
        goto LABEL_25;
      if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 247, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      numsurfs = XModelGetLodInfo((const XModel *)v11, 0)->numsurfs;
      if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 257, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
        __debugbreak();
      LodInfo = XModelGetLodInfo((const XModel *)v11, 0);
      surfIndex = LodInfo->surfIndex;
      v15 = *(_WORD *)(v11 + 8);
      if ( surfIndex >= v15 )
      {
        LODWORD(shadow) = v15;
        LODWORD(forceColor) = surfIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 261, ASSERT_TYPE_ASSERT, "(unsigned)( lodInfo->surfIndex ) < (unsigned)( model->numsurfs )", "lodInfo->surfIndex doesn't index model->numsurfs\n\t%i not in [0, %i)", forceColor, shadow) )
          __debugbreak();
      }
      v16 = (const char ***)(*(_QWORD *)(v11 + 216) + 8i64 * LodInfo->surfIndex);
      if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 19528, ASSERT_TYPE_ASSERT, "(material)", (const char *)&queryFormat, "material") )
        __debugbreak();
      v17 = 0;
      if ( numsurfs )
      {
        while ( !I_stristr(**v16, "do_not_use") )
        {
          ++v17;
          ++v16;
          if ( v17 >= numsurfs )
            goto LABEL_25;
        }
      }
      else
      {
LABEL_25:
        v18 = *(_BYTE *)(v11 + 15);
        if ( !v18 || v18 == 3 )
        {
          v21 = hkMemHeapAllocator();
          v22 = v37;
          if ( (_DWORD)v37 == (HIDWORD(v37) & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v21, &pArr, 8);
            v22 = v37;
          }
          pArr[v22] = (XModel *)v11;
          LODWORD(v37) = v37 + 1;
        }
        else if ( !*(_QWORD *)(v11 + 624) )
        {
          v19 = hkMemHeapAllocator();
          v20 = v35;
          if ( (_DWORD)v35 == (HIDWORD(v35) & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v19, &array, 8);
            v20 = v35;
          }
          array[v20] = (const XModel *)v11;
          LODWORD(v35) = v35 + 1;
        }
      }
      ++v9;
      v10 = v38 + 8;
      v38 += 8i64;
    }
    while ( v9 < s_havokPhysicsXModels->m_size );
    v6 = v39;
    v7 = v40;
    v8 = v41;
  }
  Com_sprintf<256>((char (*)[256])dest, "Red text if we expect a PhysicsAsset and don't find one, white if physicsUseCategory implies there shouldn't be one");
  Physics_DrawDebugString(v8, *v7, *v6, dest, &colorWhite, 0, 1, charHeight, 0);
  *v6 = charHeight + *v6;
  if ( (int)v37 > 1 )
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>((const XModel **)pArr, 0, v37 - 1, HavokPhysics_XModelsSortByName);
  v23 = v35;
  if ( (int)v35 > 1 )
  {
    hkAlgorithm::quickSortRecursive<XModel const *,hkBool (*)(XModel const *,XModel const *)>(array, 0, v35 - 1, HavokPhysics_XModelsSortByName);
    v23 = v35;
  }
  v24 = tabWidth + *v7;
  *v7 = v24;
  v25 = 0;
  v26 = array;
  v27 = (const char ***)array;
  if ( array != &array[v23] )
  {
    do
    {
      if ( !(*v27)[78] )
      {
        Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s", v25, **v27);
        Physics_DrawDebugString(v8, *v7, *v6, dest, &colorRed, 0, 1, charHeight, 0);
        *v6 = charHeight + *v6;
        v23 = v35;
        v26 = array;
      }
      ++v25;
      ++v27;
    }
    while ( v27 != (const char ***)&v26[v23] );
    v24 = *v7;
  }
  v28 = pArr;
  v29 = pArr;
  if ( pArr != &pArr[(int)v37] )
  {
    do
    {
      if ( !(*v29)->physicsAsset )
      {
        Com_sprintf<256>((char (*)[256])dest, "%4i: name:%s", v25, (*v29)->name);
        Physics_DrawDebugString(v8, *v7, *v6, dest, &colorWhite, 0, 1, charHeight, 0);
        *v6 = charHeight + *v6;
        v28 = pArr;
      }
      ++v25;
      ++v29;
    }
    while ( v29 != &v28[(int)v37] );
    v24 = *v7;
  }
  *v7 = v24 - tabWidth;
  v30 = hkMemHeapAllocator();
  LODWORD(v35) = 0;
  if ( v35 >= 0 )
    hkMemoryAllocator::bufFree2(v30, array, 8, HIDWORD(v35) & 0x3FFFFFFF);
  array = NULL;
  HIDWORD(v35) = 0x80000000;
  v31 = hkMemHeapAllocator();
  LODWORD(v37) = 0;
  if ( v37 >= 0 )
    hkMemoryAllocator::bufFree2(v31, pArr, 8, HIDWORD(v37) & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_DrawWorld
==============
*/
void HavokPhysics_DrawWorld(Physics_WorldId worldId, bool fullDisplay, const ScreenPlacement *scrPlace, float *x, float *y, float tabWidth, float charHeight)
{
  __int128 v7; 
  float *v8; 
  const ScreenPlacement *v9; 
  hknpWorld *world; 
  float v13; 
  __m128 v14; 
  float v15; 
  float v16; 
  hknpWorld *v17; 
  hknpThreadSafeObjectPoolElement<hknpBody> *m_data; 
  unsigned int v19; 
  unsigned int v20; 
  __int64 v21; 
  int v22; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v23; 
  unsigned int v24; 
  unsigned int v25; 
  unsigned int v26; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v27; 
  unsigned int v28; 
  int v29; 
  int v30; 
  Physics_RefSystem RefSystem; 
  unsigned __int16 RefId; 
  DObj *ServerDObjForEntnum; 
  float *v34; 
  __int64 v35; 
  __int64 v36; 
  int v37; 
  unsigned int v38; 
  int v39; 
  char *fmtb; 
  char *fmt; 
  char *fmta; 
  char v43; 
  char v44; 
  __int16 i; 
  hknpWorld *v46; 
  __int64 v49; 
  unsigned int *m_constraintManager; 
  char dest[256]; 
  __int128 v52; 

  v8 = x;
  v9 = scrPlace;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 21176, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to DrawWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  v46 = world;
  if ( world )
  {
    m_constraintManager = (unsigned int *)world->m_constraintManager;
    v14 = *(__m128 *)world->getGravity(&world->hknpWorldReader);
    v15 = _mm_shuffle_ps(v14, v14, 85).m128_f32[0];
    v16 = _mm_shuffle_ps(v14, v14, 170).m128_f32[0];
    Com_sprintf<256>((char (*)[256])dest, "Broadphase (%.2f, %.2f, %.2f) (%.2f, %.2f, %.2f)", cm.broadphaseMin.v[0], cm.broadphaseMin.v[1], cm.broadphaseMin.v[2], cm.broadphaseMax.v[0], cm.broadphaseMax.v[1], cm.broadphaseMax.v[2]);
    v13 = charHeight;
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    LODWORD(fmtb) = world->m_bodyManager.m_bodies.m_peakIndex;
    Com_sprintf<256>((char (*)[256])dest, "%i bodies allocated - max %i - peak %i", world->m_bodyManager.m_bodies.m_numAllocated, (unsigned int)world->m_bodyManager.m_bodies.m_objects.m_size, fmtb);
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    v17 = world;
    *y = charHeight + *y;
    if ( fullDisplay )
    {
      v52 = v7;
      *v8 = tabWidth + *v8;
      m_data = world->m_bodyManager.m_bodies.m_objects.m_data;
      v19 = world->m_bodyManager.m_bodies.m_peakIndex + 1;
      v20 = 0;
      if ( v17->m_bodyManager.m_bodies.m_numAllocated )
      {
        if ( (m_data->m_pod.m_flags.m_storage & 0xF) != 0 )
          goto LABEL_72;
        v20 = 1;
        if ( v19 > 1 )
        {
          while ( (m_data[v20].m_pod.m_flags.m_storage & 0xF) == 0 )
          {
            if ( ++v20 >= v19 )
              goto LABEL_22;
          }
          if ( v20 != -1 )
          {
LABEL_72:
            do
            {
              v21 = v20;
              v22 = truncate_cast<int,unsigned __int64>(LODWORD(v17->m_bodyManager.m_bodies.m_objects.m_data[m_data[v21].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData));
              if ( Physics_GetRefSystem(v22) == Physics_RefSystem_WorldGeo )
              {
                Com_sprintf<256>((char (*)[256])dest, "World Geo Body %x %s", m_data[v21].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v46->m_bodyManager.m_bodyNames.m_data[m_data[v21].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                Physics_DrawDebugString(scrPlace, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                *y = charHeight + *y;
              }
              if ( ++v20 >= v19 )
                break;
              while ( (m_data[v20].m_pod.m_flags.m_storage & 0xF) == 0 )
              {
                if ( ++v20 >= v19 )
                  goto LABEL_21;
              }
              v17 = v46;
            }
            while ( v20 != -1 );
LABEL_21:
            v17 = v46;
          }
        }
      }
LABEL_22:
      for ( i = 0; i < 2048; ++i )
      {
        v23 = v17->m_bodyManager.m_bodies.m_objects.m_data;
        v24 = v17->m_bodyManager.m_bodies.m_peakIndex + 1;
        v25 = 0;
        v43 = 0;
        v44 = 0;
        if ( v17->m_bodyManager.m_bodies.m_numAllocated )
        {
          if ( (v23->m_pod.m_flags.m_storage & 0xF) != 0 )
            goto LABEL_73;
          v25 = 1;
          if ( v24 > 1 )
          {
            while ( (v23[v25].m_pod.m_flags.m_storage & 0xF) == 0 )
            {
              if ( ++v25 >= v24 )
                goto LABEL_28;
            }
            if ( v25 != -1 )
            {
LABEL_73:
              do
              {
                v49 = v25;
                v30 = truncate_cast<int,unsigned __int64>(LODWORD(v17->m_bodyManager.m_bodies.m_objects.m_data[v23[v49].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData));
                RefSystem = Physics_GetRefSystem(v30);
                RefId = Physics_GetRefId(v30);
                if ( (RefSystem == Physics_RefSystem_GEntities || RefSystem == Physics_RefSystem_GItems) && RefId == i )
                {
                  if ( v43 )
                  {
                    v34 = x;
                    v35 = v25;
                  }
                  else
                  {
                    ServerDObjForEntnum = Com_GetServerDObjForEntnum(i);
                    if ( ServerDObjForEntnum && ServerDObjForEntnum->numModels )
                    {
                      Com_sprintf<256>((char (*)[256])dest, "Server Entity %i with model %s", (unsigned int)i, **(const char ***)ServerDObjForEntnum->models);
                      v34 = x;
                      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                      v35 = v25;
                      v44 = 1;
                    }
                    else
                    {
                      v35 = v25;
                      Com_sprintf<256>((char (*)[256])dest, "Server Entity %i with body %x %s", (unsigned int)i, v23[v49].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v46->m_bodyManager.m_bodyNames.m_data[v23[v49].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                      v34 = x;
                      Physics_DrawDebugString(scrPlace, *x, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                    }
                    *y = charHeight + *y;
                    *v34 = tabWidth + *v34;
                    v43 = 1;
                  }
                  if ( v44 )
                  {
                    Com_sprintf<256>((char (*)[256])dest, "%x %s", v23[v35].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v46->m_bodyManager.m_bodyNames.m_data[v23[v35].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
                    Physics_DrawDebugString(scrPlace, *v34, *y, dest, &colorWhite, 0, 1, charHeight, 0);
                    *y = charHeight + *y;
                  }
                }
                if ( ++v25 >= v24 )
                  break;
                while ( (v23[v25].m_pod.m_flags.m_storage & 0xF) == 0 )
                {
                  if ( ++v25 >= v24 )
                    goto LABEL_57;
                }
                v17 = v46;
              }
              while ( v25 != -1 );
LABEL_57:
              v8 = x;
              v17 = v46;
              if ( v43 )
                *x = *x - tabWidth;
            }
          }
        }
LABEL_28:
        ;
      }
      v26 = 0;
      *v8 = *v8 - tabWidth;
      v27 = v17->m_bodyManager.m_bodies.m_objects.m_data;
      v28 = v17->m_bodyManager.m_bodies.m_peakIndex + 1;
      if ( !v17->m_bodyManager.m_bodies.m_numAllocated )
        goto LABEL_34;
      if ( (v27->m_pod.m_flags.m_storage & 0xF) != 0 )
        goto LABEL_74;
      v26 = 1;
      if ( v28 <= 1 )
        goto LABEL_34;
      while ( (v27[v26].m_pod.m_flags.m_storage & 0xF) == 0 )
      {
        if ( ++v26 >= v28 )
          goto LABEL_34;
      }
      if ( v26 != -1 )
      {
LABEL_74:
        do
        {
          v36 = v26;
          v37 = truncate_cast<int,unsigned __int64>(LODWORD(v17->m_bodyManager.m_bodies.m_objects.m_data[v27[v36].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData));
          v38 = Physics_GetRefSystem(v37);
          if ( v38 <= 9 && (v39 = 517, _bittest(&v39, v38)) )
          {
            v9 = scrPlace;
          }
          else
          {
            Com_sprintf<256>((char (*)[256])dest, "General Body %x %s", v27[v36].m_pod.m_id.m_serialAndIndex, (const char *)((unsigned __int64)v46->m_bodyManager.m_bodyNames.m_data[v27[v36].m_pod.m_id.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64));
            v9 = scrPlace;
            Physics_DrawDebugString(scrPlace, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
            *y = charHeight + *y;
          }
          if ( ++v26 >= v28 )
            break;
          while ( (v27[v26].m_pod.m_flags.m_storage & 0xF) == 0 )
          {
            if ( ++v26 >= v28 )
            {
              v17 = v46;
              goto LABEL_35;
            }
          }
          v17 = v46;
        }
        while ( v26 != -1 );
        v17 = v46;
      }
      else
      {
LABEL_34:
        v9 = scrPlace;
      }
    }
LABEL_35:
    LODWORD(fmt) = v17->m_motionManager.m_motions.m_peakIndex;
    Com_sprintf<256>((char (*)[256])dest, "%i motions allocated - max %i - peak %i", v17->m_motionManager.m_motions.m_numAllocated, (unsigned int)v17->m_motionManager.m_motions.m_objects.m_size, fmt);
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    v29 = 0x7FFFFFFF;
    if ( m_constraintManager[8] != -1 )
      v29 = m_constraintManager[8];
    LODWORD(fmta) = v29;
    Com_sprintf<256>((char (*)[256])dest, "%i constraints - max %i - peak %i", m_constraintManager[7], m_constraintManager[4], fmta);
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    Com_sprintf<256>((char (*)[256])dest, "hkGravity (%.2f, %.2f, %.2f)", v14.m128_f32[0], v15, v16);
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    Com_sprintf<256>((char (*)[256])dest, "iwGravity (%.2f, %.2f, %.2f)", (float)(v14.m128_f32[0] * 32.0), (float)(v15 * 32.0), (float)(v16 * 32.0));
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
    *y = charHeight + *y;
    Com_sprintf<256>((char (*)[256])dest, "gravity scalars: ragdoll:%.2f dynent:%.2f particle:%.2f", g_physicsClientWorldGravityScalars[6][0], g_physicsClientWorldGravityScalars[1][0], g_physicsClientWorldGravityScalars[7][0]);
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "Couldn't find world %i", (unsigned int)worldId);
    v13 = charHeight;
    Physics_DrawDebugString(v9, *v8, *y, dest, &colorWhite, 0, 1, charHeight, 0);
  }
  *y = v13 + *y;
}

/*
==============
HavokPhysics_EnableDeactivationForBody
==============
*/
void HavokPhysics_EnableDeactivationForBody(Physics_WorldId worldId, hknpBodyId bodyId, bool enableDeactivation)
{
  hknpWorld *world; 
  __int64 v7; 
  hknpWorld *v8; 
  hknpDeactivationManager *m_deactivationManager; 
  __int64 v10; 
  __int64 v11; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13214, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to enable deactivation for a body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13215, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to enable deactivation for a body with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 181, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Motion ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 182, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Motion ID with invalid body id in world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 186, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get Motion Id %i: world is NULL", "world", v11) )
      __debugbreak();
  }
  v7 = *(unsigned int *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex) + 64);
  if ( (_DWORD)v7 == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13219, ASSERT_TYPE_ASSERT, "(motionId.isValid())", (const char *)&queryFormat, "motionId.isValid()") )
    __debugbreak();
  v8 = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13223, ASSERT_TYPE_ASSERT, "(hkWorld)", (const char *)&queryFormat, "hkWorld") )
    __debugbreak();
  m_deactivationManager = v8->m_deactivationManager;
  if ( !m_deactivationManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13227, ASSERT_TYPE_ASSERT, "(deactivationManager)", (const char *)&queryFormat, "deactivationManager") )
    __debugbreak();
  v10 = (__int64)&m_deactivationManager->m_deactivationStates.m_data[v7];
  if ( enableDeactivation )
  {
    if ( *(_BYTE *)(v10 + 11) == 0xFF )
      *(_BYTE *)(v10 + 11) = 0;
  }
  else
  {
    *(_BYTE *)(v10 + 11) = -1;
  }
}

/*
==============
HavokPhysics_EnableShapeInstance
==============
*/
void HavokPhysics_EnableShapeInstance(Physics_WorldId worldId, hknpBodyId bodyId, hkHandle<unsigned short,65535,hknpShapeInstanceIdDiscriminant> shapeInstanceId, bool enabled)
{
  hknpWorld *world; 
  const hknpShape *m_shape; 
  hknpShape_vtbl *v10; 

  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16120, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics EnableShapeInstance %i: world is NULL", "world", worldId) )
    __debugbreak();
  m_shape = world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_shape;
  if ( !m_shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16127, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  if ( (m_shape->m_type.m_storage != 18 || !m_shape->getMutationSignals(m_shape)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16131, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::MASKED && shape->isMutable())", (const char *)&queryFormat, "shape->getType() == hknpShapeType::MASKED && shape->isMutable()") )
    __debugbreak();
  v10 = m_shape[1].__vftable;
  if ( BYTE2(v10->getMutationSignals) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16140, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
    __debugbreak();
  (*(void (__fastcall **)(unsigned __int16 *, _QWORD, bool))(*(_QWORD *)&m_shape[1].m_memSizeAndFlags + 16i64))(&m_shape[1].m_memSizeAndFlags, (0xFFFFFFFF >> BYTE3(v10->getMutationSignals)) | (shapeInstanceId.m_value << (32 - BYTE3(v10->getMutationSignals))), enabled);
  m_shape->__vftable[1].deleteThisReferencedObject(&m_shape->hkReferencedObject);
}

/*
==============
HavokPhysics_FindMaterialId
==============
*/
hknpMaterialId *HavokPhysics_FindMaterialId(hknpMaterialId *result, const char *physicsMaterial)
{
  const char *v2; 
  __int64 v4; 
  unsigned int v5; 
  __int64 v6; 
  int v7; 
  int v8; 
  int m_size; 

  v2 = physicsMaterial;
  if ( !physicsMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8644, ASSERT_TYPE_ASSERT, "(physicsMaterial)", (const char *)&queryFormat, "physicsMaterial") )
    __debugbreak();
  v4 = -1i64;
  v5 = -1;
  do
    ++v4;
  while ( v2[v4] );
  for ( ; v4; --v4 )
  {
    v6 = *(unsigned __int8 *)v2++;
    v5 = (v5 >> 8) ^ g_crc32Table[v6 ^ (unsigned __int8)v5];
  }
  v7 = 0;
  v8 = ~v5;
  m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
  if ( m_size > 0 )
  {
    do
    {
      if ( v8 == s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v7] )
        break;
      ++v7;
    }
    while ( v7 < m_size );
  }
  if ( v7 >= m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8660, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", (const char *)&queryFormat, "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()") )
    __debugbreak();
  result->m_value = v7 + s_havokPhysicsMaterialLibrary.firstId.m_value;
  return result;
}

/*
==============
HavokPhysics_FindShapeTag
==============
*/
unsigned __int16 HavokPhysics_FindShapeTag(HavokPhysicsShapeList::ShapeTagData *shapeTagData)
{
  return HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, shapeTagData);
}

/*
==============
HavokPhysics_FlushMovedStatics
==============
*/
void HavokPhysics_FlushMovedStatics(Physics_WorldId worldId)
{
  hknpWorld *world; 
  hkMemoryAllocator *v2; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v3; 
  __int64 m_size; 
  __int64 v5; 
  hknpBodyManager::ScheduledBodyChange *v6; 
  __int64 m_bodyIndex; 
  unsigned int m_serialAndIndex; 
  hkMemoryAllocator *v9; 
  int v10; 
  __int64 v11; 
  signed int v12; 
  __int64 v13; 
  __int64 v14; 
  hkAabb24_16_24 *v15; 
  __int64 v16; 
  signed int v17; 
  __int64 v18; 
  __int64 v19; 
  hkAabb24_16_24 *v20; 
  hkMemoryAllocator *v21; 
  __int64 v22; 
  hknpThreadSafeObjectPoolElement<hknpBody> *v23; 
  hkAabb24_16_24 *m_data; 
  hknpBroadPhase *m_broadPhase; 
  hknpBodyId *array; 
  unsigned int v27; 
  int v28; 

  v22 = -2i64;
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  m_data = world->m_bodyManager.m_previousAabbs.m_data;
  v23 = world->m_bodyManager.m_bodies.m_objects.m_data;
  m_broadPhase = world->m_broadPhase;
  array = NULL;
  v27 = 0;
  v28 = 0x80000000;
  v2 = hkMemHeapAllocator();
  hkArrayUtil::_reserve(v2, &array, 256, 4);
  v3 = world->m_bodyManager.m_bodies.m_objects.m_data;
  m_size = world->m_bodyManager.m_scheduledBodyChanges.m_size;
  if ( m_size > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = world->m_bodyManager.m_scheduledBodyChanges.m_data;
      if ( (v6[v5].m_scheduledBodyFlags.m_storage & 4) != 0 )
      {
        m_bodyIndex = v6[v5].m_bodyIndex;
        if ( (unsigned int)m_bodyIndex < world->m_bodyManager.m_bodies.m_objects.m_size && (v3[m_bodyIndex].m_pod.m_flags.m_storage & 3) != 0 && (v3[m_bodyIndex].m_pod.m_flags.m_storage & 1) != 0 )
        {
          m_serialAndIndex = v3[m_bodyIndex].m_pod.m_id.m_serialAndIndex;
          v9 = hkMemHeapAllocator();
          v10 = v27;
          if ( v27 == (v28 & 0x3FFFFFFF) )
          {
            hkArrayUtil::_reserveMore(v9, &array, 4);
            v10 = v27;
          }
          array[v10].m_serialAndIndex = m_serialAndIndex;
          v11 = v27 + 1;
          v27 = v11;
          if ( (_DWORD)v11 == (v28 & 0x3FFFFFFF) )
          {
            v12 = 0;
            if ( (int)v11 > 0 )
            {
              v13 = 0i64;
              do
              {
                v14 = array[v13].m_serialAndIndex & 0xFFFFFF;
                v15 = (hkAabb24_16_24 *)&v23[v14];
                v15[4].m_max.m_xxxyyzzz = 0i64;
                m_data[v14] = v15[5];
                ++v12;
                ++v13;
                v11 = v27;
              }
              while ( v12 < (int)v27 );
            }
            ((void (__fastcall *)(hknpBroadPhase *, hknpBodyId *, __int64, __int64, __int64))m_broadPhase->markBodiesDirty)(m_broadPhase, array, v11, 4i64, v22);
            hkMemHeapAllocator();
            v27 = 0;
          }
        }
      }
      ++v5;
      --m_size;
    }
    while ( m_size );
  }
  hknpBodyManager::clearAllScheduledBodyChanges(&world->m_bodyManager);
  v16 = v27;
  if ( v27 )
  {
    v17 = 0;
    if ( (int)v27 > 0 )
    {
      v18 = 0i64;
      do
      {
        v19 = array[v18].m_serialAndIndex & 0xFFFFFF;
        v20 = (hkAabb24_16_24 *)&v23[v19];
        v20[4].m_max.m_xxxyyzzz = 0i64;
        m_data[v19] = v20[5];
        ++v17;
        ++v18;
        v16 = v27;
      }
      while ( v17 < (int)v27 );
    }
    m_broadPhase->markBodiesDirty(m_broadPhase, array, v16, 4);
    hkMemHeapAllocator();
    v27 = 0;
  }
  v21 = hkMemHeapAllocator();
  v27 = 0;
  if ( v28 >= 0 )
    hkMemoryAllocator::bufFree2(v21, array, 4, v28 & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_FreeBroadphaseCollisionQueryResult
==============
*/
void HavokPhysics_FreeBroadphaseCollisionQueryResult(HavokPhysics_BroadphaseCollisionQueryResult *result)
{
  unsigned __int16 m_refCount; 
  signed __int32 v3[8]; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13575, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  _InterlockedOr(v3, 0);
  m_refCount = result->m_refCount;
  _InterlockedOr(v3, 0);
  if ( m_refCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13578, ASSERT_TYPE_ASSERT, "(result->getReferenceCount() == 1)", (const char *)&queryFormat, "result->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(result);
}

/*
==============
HavokPhysics_FreeCollisionQueryResult
==============
*/
void HavokPhysics_FreeCollisionQueryResult(HavokPhysics_CollisionQueryResult *result)
{
  HavokPhysicsHitCollector *m_collector; 
  unsigned __int16 m_refCount; 
  signed __int32 v4[8]; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13674, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13677, ASSERT_TYPE_ASSERT, "(result->m_collector)", (const char *)&queryFormat, "result->m_collector") )
    __debugbreak();
  m_collector = result->m_collector;
  if ( m_collector )
    ((void (__fastcall *)(HavokPhysicsHitCollector *, __int64))m_collector->~HavokPhysicsHitCollectorDummy)(m_collector, 1i64);
  result->m_collector = NULL;
  _InterlockedOr(v4, 0);
  m_refCount = result->m_refCount;
  _InterlockedOr(v4, 0);
  if ( m_refCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13682, ASSERT_TYPE_ASSERT, "(result->getReferenceCount() == 1)", (const char *)&queryFormat, "result->getReferenceCount() == 1") )
    __debugbreak();
  hkReferencedObject::removeReference(result);
}

/*
==============
HavokPhysics_FreeIgnoreBodies
==============
*/
void HavokPhysics_FreeIgnoreBodies(HavokPhysics_IgnoreBodies *ignoreBodies)
{
  hkMemoryRouter *Value; 

  if ( ignoreBodies )
  {
    HavokPhysics_IgnoreBodies::~HavokPhysics_IgnoreBodies(ignoreBodies);
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    Value->m_heap->blockFree(Value->m_heap, ignoreBodies, 56);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13705, ASSERT_TYPE_ASSERT, "(ignoreBodies)", (const char *)&queryFormat, "ignoreBodies", -2i64) )
  {
    __debugbreak();
  }
}

/*
==============
HavokPhysics_GetAssetByName
==============
*/
const PhysicsAsset *HavokPhysics_GetAssetByName(const char *name)
{
  int v2; 
  __int64 m_hashMod; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  __int64 i; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v6; 
  const char **key; 
  int v8; 
  __int64 v9; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v10; 

  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  v2 = 0;
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( (int)m_hashMod >= 0 )
  {
    m_elem = s_havokPhysicsAssets->m_map.m_elem;
    for ( i = 0i64; i <= m_hashMod; ++i )
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v2;
      ++m_elem;
    }
  }
  if ( v2 > (int)m_hashMod )
  {
LABEL_13:
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11051, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_GetAssetByName couldn't find asset %s", name) )
      __debugbreak();
    return 0i64;
  }
  else
  {
    v6 = s_havokPhysicsAssets->m_map.m_elem;
    while ( 1 )
    {
      key = (const char **)v6[v2].key;
      if ( !strcmp(name, *key) )
        break;
      v8 = v2 + 1;
      if ( v2 + 1 <= (int)m_hashMod )
      {
        v9 = v8;
        v10 = &v6[v8];
        do
        {
          if ( v10->key != -1i64 )
            break;
          ++v8;
          ++v9;
          ++v10;
        }
        while ( v9 <= m_hashMod );
      }
      v2 = v8;
      if ( v8 > (int)m_hashMod )
        goto LABEL_13;
    }
    ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
    Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
    return (const PhysicsAsset *)key;
  }
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/
void HavokPhysics_GetClosestPoints(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 v12; 
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *v18; 
  __int64 v19; 
  const hknpBody *v20; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v23; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  hknpCollisionQueryContext queryContext; 
  hkQuaternionf *qi; 
  const HavokPhysicsWorld *ConstWorld; 
  __int16 v28; 
  int contents; 
  float *v30; 
  float v31; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v33; 
  __int128 v34; 
  Physics_QueryPhaseSelection phaseSelection; 
  hknpClosestPointsQuery queryIn; 
  __int64 v37; 
  hknpShapeQueryInfo queryShapeInfo; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v40[64]; 
  hknpInplaceTriangleShape v41; 

  v37 = -2i64;
  v12 = numBodies;
  qi = (hkQuaternionf *)rotation;
  _XMM1 = 0i64;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v41, 0.0);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v41;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v41;
  queryContext.m_initialCastFractionHint = 0.0;
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfo.m_shapeKeyPath.m_size = 0;
  queryShapeInfo.m_body = NULL;
  queryShapeInfo.m_parentShape = NULL;
  queryShapeInfo.m_shapeKeyMask = NULL;
  queryShapeInfo.m_scalingInternals.m_isScaled = 0;
  queryShapeInfo.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  queryShapeInfo.m_scalingInternals.m_mode = 0;
  queryShapeInfo.m_scalingInternals.m_offset = 0i64;
  queryShapeInfo.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&targetShapeInfo.m_body = _XMM0;
  targetShapeInfo.m_parentShape = NULL;
  __asm { vpxor   xmm1, xmm1, xmm1 }
  *(_OWORD *)&targetShapeInfo.m_shapeToWorld = _XMM1;
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  targetShapeInfo.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  targetShapeInfo.m_scalingInternals.m_offset = 0i64;
  targetShapeInfo.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  v31 = 0.0;
  ignoreBodies = NULL;
  v33 = 1;
  v34 = _XMM0;
  phaseSelection = All;
  queryIn.m_broadPhaseFilterMask = -5;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15321, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15322, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15323, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15324, ASSERT_TYPE_ASSERT, "(extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies without ignore bodies", "extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15325, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15326, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15327, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire get closest points with bodies with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15330, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v31 = extendedData->collisionBuffer * 0.03125;
  *(_QWORD *)&v34 = extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  ignoreBodies = extendedData->ignoreBodies;
  v28 = -1;
  contents = extendedData->contents;
  v30 = &v31;
  queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
  *(__m256i *)v40 = *(__m256i *)g_vectorfConstants[32].m128_f32;
  *(__m256i *)&v40[32] = *(__m256i *)g_vectorfConstants[34].m128_f32;
  hkRotationImpl<float>::set((hkRotationImpl<float> *)v40, qi);
  *(hkVector4f *)&v40[48] = (hkVector4f)point->m_quad;
  queryShapeInfo.m_rootShape = shape;
  queryShapeInfo.m_shapeToWorld = (const hkTransformf *)v40;
  queryIn.m_shape = shape;
  queryIn.m_maxDistance = maxDistance;
  queryIn.m_body = NULL;
  queryIn.m_shapeTagCodec = s_shapeTagCodec;
  v18 = ConstWorld;
  queryIn.m_filter = ConstWorld->traceCollisionFilter;
  queryIn.m_filterData.m_materialId.m_value = -1;
  queryIn.m_filterData.m_collisionFilterInfo = extendedData->contents;
  queryIn.m_filterData.m_userData = (unsigned __int64)&v31;
  *(_DWORD *)queryIn.m_levelOfDetail = 0;
  if ( (_DWORD)v12 )
  {
    v19 = v12;
    do
    {
      if ( (*bodyIds & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15371, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] )") )
        __debugbreak();
      v20 = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v18->world->getBody)(&v18->world->hknpWorldReader, *bodyIds);
      m_shape = v20->m_shape;
      if ( v18->traceCollisionFilter->isCollisionEnabled(v18->traceCollisionFilter, GET_CLOSEST_POINTS, (const hknpQueryFilterData *)&v28, v20) )
      {
        targetShapeInfo.m_body = v20;
        targetShapeInfo.m_rootShape = v20->m_shape;
        targetShapeInfo.m_parentShape = NULL;
        targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
        targetShapeInfo.m_shapeKeyPath.m_size = 0;
        targetShapeInfo.m_shapeToWorld = &v20->m_transform;
        targetShapeInfo.m_shapeKeyMask = NULL;
        targetShapeFilterDataIn.m_materialId.m_value = v20->m_materialId.m_value;
        targetShapeFilterDataIn.m_collisionFilterInfo = v20->m_collisionFilterInfo;
        targetShapeFilterDataIn.m_userData = v20->m_userData;
        s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, v20, m_shape, &targetShapeFilterDataIn);
        Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( Value )
          hkMonitorStream::timerBegin(Value, "TtGetClosestPoints_Body_HK");
        hknpShapeQueryInterface::getClosestPoints(&queryContext, &queryIn, &queryShapeInfo, m_shape, &targetShapeFilterDataIn, &targetShapeInfo, Collector);
        v23 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( v23 )
          hkMonitorStream::timerEnd(v23, "Et");
      }
      ++bodyIds;
      --v19;
    }
    while ( v19 );
  }
  if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/
void HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 *ConstWorld; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v14; 
  __int64 NumHits; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v17; 
  int v18; 
  int v19; 
  hknpCollisionResult *v20; 
  __m256i *v21; 
  __int64 v22; 
  signed __int64 v23; 
  hknpBodyId *v24; 
  int Ref; 
  int v26; 
  unsigned int v27; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v29; 
  __int64 v30; 
  __int64 v31; 
  hknpCollisionResult *array; 
  int v33; 
  int v34; 
  float v35; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v37; 
  __int128 v38; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v40[2]; 
  __int16 v41; 
  int contents; 
  float *v43; 
  int v44; 
  char v45; 
  hknpShape *v46; 
  float v47; 
  __int64 v48; 
  __int64 v49; 
  hkRotationImpl<float> v50; 
  __m128 m_quad; 

  v49 = -2i64;
  v35 = 0.0;
  ignoreBodies = NULL;
  v37 = 1;
  v38 = 0i64;
  phaseSelection = All;
  v45 = -5;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14441, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14442, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14443, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid result", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14444, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid result", "result") )
    __debugbreak();
  ConstWorld = (__int64 *)HavokPhysics_GetConstWorld(worldId);
  ignoreBodies = extendedData->ignoreBodies;
  v35 = extendedData->collisionBuffer * 0.03125;
  *(_QWORD *)&v38 = extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  v46 = shape;
  v47 = maxDistance;
  v48 = 0i64;
  v40[0] = (__int64)s_shapeTagCodec;
  v40[1] = *ConstWorld;
  v41 = -1;
  contents = extendedData->contents;
  v43 = &v35;
  v44 = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14466, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14469, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid havok collector", "collector") )
    __debugbreak();
  hkRotationImpl<float>::set(&v50, rotation);
  m_quad = point->m_quad;
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtGetClosestPoints_HK");
  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok GetClosestPoints");
  (*(void (__fastcall **)(__int64, __int64 *, hkRotationImpl<float> *, hknpCollisionQueryCollector *))(*(_QWORD *)(ConstWorld[3] + 32) + 344i64))(ConstWorld[3] + 32, v40, &v50, Collector);
  Sys_ProfEndNamedEvent();
  v14 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v14 )
    hkMonitorStream::timerEnd(v14, "Et");
  if ( extendedData->simplify )
  {
    array = NULL;
    v33 = 0;
    v34 = 0x80000000;
    NumHits = (int)HavokPhysics_CollisionQueryResult::GetNumHits(result);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(result);
    v17 = hkMemHeapAllocator();
    v18 = 0;
    if ( (int)NumHits > 0 )
    {
      v19 = NumHits;
      if ( (int)NumHits < 0 )
        v19 = 0;
      hkArrayUtil::_reserve(v17, &array, v19, 112);
      v18 = v33;
    }
    v20 = array;
    v21 = (__m256i *)&array[v18];
    v22 = NumHits;
    if ( (int)NumHits > 0 )
    {
      v23 = (char *)Hits - (char *)v21;
      do
      {
        if ( v21 )
        {
          *v21 = *(__m256i *)((char *)v21 + v23);
          v21[1] = *(__m256i *)((char *)&v21[1] + v23);
          v21[2] = *(__m256i *)((char *)&v21[2] + v23);
          *(_OWORD *)v21[3].m256i_i8 = *(_OWORD *)&v21[3].m256i_i8[v23];
        }
        v21 = (__m256i *)((char *)v21 + 112);
        --v22;
      }
      while ( v22 );
      v20 = array;
    }
    v33 = NumHits;
    if ( (int)NumHits > 1 )
      hkAlgorithm::quickSortRecursive<hknpCollisionResult,hkBool (*)(hknpCollisionResult &,hknpCollisionResult &)>(v20, 0, NumHits - 1, HavokPhysics_QueryHitSort);
    Collector->reset(Collector);
    v24 = (hknpBodyId *)array;
    if ( array != &array[v33] )
    {
      do
      {
        Ref = HavokPhysics_GetRef(result->m_worldId, v24[18]);
        v26 = HavokPhysics_CollisionQueryResult::GetNumHits(result);
        v27 = 0;
        if ( v26 <= 0 )
        {
LABEL_43:
          Collector->addHit(Collector, (const hknpCollisionResult *)v24);
        }
        else
        {
          while ( 1 )
          {
            if ( v27 >= HavokPhysics_CollisionQueryResult::GetNumHits(result) )
            {
              LODWORD(v31) = HavokPhysics_CollisionQueryResult::GetNumHits(result);
              LODWORD(v30) = v27;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v30, v31) )
                __debugbreak();
            }
            Hit = HavokPhysics_CollisionQueryResult::GetHit(result, v27);
            if ( HavokPhysics_GetRef(result->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
              break;
            if ( (int)++v27 >= v26 )
              goto LABEL_43;
          }
        }
        v24 += 28;
      }
      while ( v24 != (hknpBodyId *)&array[v33] );
    }
    v29 = hkMemHeapAllocator();
    v33 = 0;
    if ( v34 >= 0 )
      hkMemoryAllocator::bufFree2(v29, array, 112, v34 & 0x3FFFFFFF);
  }
}

/*
==============
HavokPhysics_GetClosestPoints
==============
*/
void HavokPhysics_GetClosestPoints(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *point, const hkQuaternionf *rotation, float maxDistance, Physics_GetClosestPointsExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *ConstWorld; 
  const hknpBody *v18; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v21; 
  __int64 v22; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  __int16 v24; 
  int contents; 
  float *v26; 
  hknpCollisionQueryContext queryContext; 
  hknpClosestPointsQuery queryIn; 
  hkQuaternionf *qi; 
  float v30; 
  __int64 v31; 
  int v32; 
  __int128 v33; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v35; 
  hknpShapeQueryInfo queryShapeInfo; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v38[64]; 
  hknpInplaceTriangleShape v39; 

  v35 = -2i64;
  qi = (hkQuaternionf *)rotation;
  v24 = -1;
  contents = 0;
  v26 = NULL;
  _XMM1 = 0i64;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v39, 0.0);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v39;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v39;
  queryContext.m_initialCastFractionHint = 0.0;
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&queryShapeInfo.m_body = _XMM0;
  queryShapeInfo.m_parentShape = NULL;
  __asm { vpxor   xmm1, xmm1, xmm1 }
  *(_OWORD *)&queryShapeInfo.m_shapeToWorld = _XMM1;
  queryShapeInfo.m_scalingInternals.m_isScaled = 0;
  queryShapeInfo.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  queryShapeInfo.m_scalingInternals.m_mode = 0;
  queryShapeInfo.m_scalingInternals.m_offset = 0i64;
  queryShapeInfo.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  *(_OWORD *)&targetShapeInfo.m_body = _XMM0;
  targetShapeInfo.m_parentShape = NULL;
  *(_OWORD *)&targetShapeInfo.m_shapeToWorld = _XMM1;
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  targetShapeInfo.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  targetShapeInfo.m_scalingInternals.m_offset = 0i64;
  targetShapeInfo.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  v30 = 0.0;
  v31 = 0i64;
  v32 = 1;
  v33 = _XMM0;
  phaseSelection = All;
  queryIn.m_filterData.m_materialId.m_value = -1;
  queryIn.m_filterData.m_collisionFilterInfo = 0;
  queryIn.m_filterData.m_userData = 0i64;
  queryIn.m_filter = NULL;
  queryIn.m_shapeTagCodec = NULL;
  *(_DWORD *)queryIn.m_levelOfDetail = 2;
  queryIn.m_broadPhaseFilterMask = -5;
  queryIn.m_shape = NULL;
  queryIn.m_maxDistance = 0.0;
  queryIn.m_body = NULL;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15227, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15228, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire getclosest points with body with invalid body id %i", "bodyId.isValid()", v22) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15229, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15230, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15231, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire get closest points with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15232, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire get closest points with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15233, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15234, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire get closest points with body with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15237, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire get closest points with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v18 = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  m_shape = v18->m_shape;
  v30 = extendedData->collisionBuffer * 0.03125;
  *(_QWORD *)&v33 = extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  v24 = -1;
  contents = extendedData->contents;
  v26 = &v30;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, GET_CLOSEST_POINTS, (const hknpQueryFilterData *)&v24, v18) )
  {
    queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    *(__m256i *)v38 = *(__m256i *)g_vectorfConstants[32].m128_f32;
    *(__m256i *)&v38[32] = *(__m256i *)g_vectorfConstants[34].m128_f32;
    hkRotationImpl<float>::set((hkRotationImpl<float> *)v38, qi);
    *(hkVector4f *)&v38[48] = (hkVector4f)point->m_quad;
    queryShapeInfo.m_rootShape = shape;
    queryShapeInfo.m_shapeToWorld = (const hkTransformf *)v38;
    targetShapeInfo.m_body = v18;
    targetShapeInfo.m_rootShape = v18->m_shape;
    targetShapeInfo.m_shapeToWorld = &v18->m_transform;
    targetShapeFilterDataIn.m_materialId.m_value = v18->m_materialId.m_value;
    targetShapeFilterDataIn.m_collisionFilterInfo = v18->m_collisionFilterInfo;
    targetShapeFilterDataIn.m_userData = v18->m_userData;
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, v18, m_shape, &targetShapeFilterDataIn);
    queryIn.m_shape = shape;
    queryIn.m_maxDistance = maxDistance;
    queryIn.m_shapeTagCodec = s_shapeTagCodec;
    queryIn.m_filter = ConstWorld->traceCollisionFilter;
    queryIn.m_filterData.m_collisionFilterInfo = extendedData->contents;
    queryIn.m_filterData.m_userData = (unsigned __int64)&v30;
    *(_DWORD *)queryIn.m_levelOfDetail = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtGetClosestPoints_Body_HK");
    hknpShapeQueryInterface::getClosestPoints(&queryContext, &queryIn, &queryShapeInfo, m_shape, &targetShapeFilterDataIn, &targetShapeInfo, Collector);
    v21 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v21 )
      hkMonitorStream::timerEnd(v21, "Et");
    if ( !queryContext.m_externallyAllocatedTriangles )
    {
      hkReferencedObject::removeReference(queryContext.m_queryTriangle);
      hkReferencedObject::removeReference(queryContext.m_targetTriangle);
    }
  }
  else if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
}

/*
==============
HavokPhysics_GetClothVisContexts
==============
*/
void HavokPhysics_GetClothVisContexts(const unsigned int clothIdx, unsigned int *numContexts, hclClothContext **clothContexts)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v7; 
  hclClothContext *clothVisContext; 
  hclClothContext *v9; 

  if ( !numContexts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3833, ASSERT_TYPE_ASSERT, "(numContexts)", (const char *)&queryFormat, "numContexts") )
    __debugbreak();
  if ( !clothContexts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3834, ASSERT_TYPE_ASSERT, "(clothContexts)", (const char *)&queryFormat, "clothContexts") )
    __debugbreak();
  *numContexts = 0;
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)(3 * clothIdx + 3));
  v7 = HavokPhysics_GetMutableWorld((Physics_WorldId)(3 * clothIdx + 4));
  clothVisContext = MutableWorld->clothVisContext;
  if ( clothVisContext )
    clothContexts[(*numContexts)++] = clothVisContext;
  v9 = v7->clothVisContext;
  if ( v9 )
    clothContexts[(*numContexts)++] = v9;
}

/*
==============
HavokPhysics_GetConstraintBodyIds
==============
*/
void HavokPhysics_GetConstraintBodyIds(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, hknpBodyId *bodyIdA, hknpBodyId *bodyIdB)
{
  const HavokPhysicsWorld *ConstWorld; 
  unsigned int *v9; 
  __int64 v10; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11522, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get ConstraintBodyIds with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( constraintId.m_value == 0x7FFFFFFF )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11523, ASSERT_TYPE_ASSERT, "(constraintId.isValid())", "%s\n\tHavok Physics: Trying to Get ConstraintBodyIds with invalid constraint id for world %i", "constraintId.isValid()", v10) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11528, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetConstraintBodyIds %i: world is NULL", "havokPhysicsWorld->world", v10) )
      __debugbreak();
  }
  v9 = (unsigned int *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getConstraint)(&ConstWorld->world->hknpWorldReader, constraintId.m_value);
  bodyIdA->m_serialAndIndex = *v9;
  bodyIdB->m_serialAndIndex = v9[1];
}

/*
==============
HavokPhysics_GetContentsFromShapeList
==============
*/
__int64 HavokPhysics_GetContentsFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_shapeContents.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetDebugLines
==============
*/
hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *HavokPhysics_GetDebugLines(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v2; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v2 = MutableWorld;
  if ( MutableWorld->debugLines )
    return MutableWorld->debugLines;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24033, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->debugLines)", (const char *)&queryFormat, "havokPhysicsWorld->debugLines") )
    __debugbreak();
  return v2->debugLines;
}

/*
==============
HavokPhysics_GetDebugWorldPersistantMemoryPeak
==============
*/
__int64 HavokPhysics_GetDebugWorldPersistantMemoryPeak(Physics_WorldId worldId)
{
  return LODWORD(HavokPhysics_GetMutableWorld(worldId)->persistentMemoryStats.m_allocatorStats.m_peakInUse);
}

/*
==============
HavokPhysics_GetDetailBoundingSphereMax
==============
*/
float HavokPhysics_GetDetailBoundingSphereMax(Physics_WorldId worldId)
{
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsWorld *v3; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11093, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get bounding sphere max with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v3 = ConstWorld;
  if ( ConstWorld->world )
    return ConstWorld->m_detailBoundingSphereMax;
  LODWORD(v5) = worldId;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11097, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetDetailBoundingSphereMax %i: world is NULL", "havokPhysicsWorld->world", v5) )
    __debugbreak();
  return v3->m_detailBoundingSphereMax;
}

/*
==============
HavokPhysics_GetDetailCollisionContents
==============
*/
__int64 HavokPhysics_GetDetailCollisionContents(const XModelDetailCollision *detailCollision)
{
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *m_data; 
  __int64 result; 
  HavokPhysicsXModelLOD::XModelCollisionTagData *i; 

  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8268, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get detail collision contents with invalid detail collision", "detailCollision") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8272, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionContents %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  m_data = HavokPhysicsXModelLODFromDetailCol->m_shapeTagData.m_data;
  result = 0i64;
  for ( i = &m_data[HavokPhysicsXModelLODFromDetailCol->m_shapeTagData.m_size]; m_data != i; ++m_data )
    result = m_data->m_collisionFilterInfo | (unsigned int)result;
  return result;
}

/*
==============
HavokPhysics_GetDetailCollisionShape
==============
*/
hknpShape *HavokPhysics_GetDetailCollisionShape(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  __int64 v2; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 

  v2 = shapeIdx;
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8455, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get detail collision shape with invalid detail collision", "detailCollision") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetDetailCollisionShapeCount(detailCollision)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8456, ASSERT_TYPE_ASSERT, "(shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision ))", "%s\n\tHavokPhysics: Trying to get detail collision shape with invalid shape index", "shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision )") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8460, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionShape %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  return HavokPhysicsXModelLODFromDetailCol->m_shapes.m_data[v2];
}

/*
==============
HavokPhysics_GetDetailCollisionShapeCount
==============
*/
__int64 HavokPhysics_GetDetailCollisionShapeCount(const XModelDetailCollision *detailCollision)
{
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 

  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8307, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get detail collision shape count with invalid detail collision", "detailCollision") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( HavokPhysicsXModelLODFromDetailCol )
    return (unsigned int)HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8311, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionShapeCount %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  return MEMORY[8];
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTag
==============
*/
__int64 HavokPhysics_GetDetailCollisionShapeTag(const XModelDetailCollision *detailCollision, int shapeIdx)
{
  return 0i64;
}

/*
==============
HavokPhysics_GetDetailCollisionShapeTransform
==============
*/
void HavokPhysics_GetDetailCollisionShapeTransform(const XModelDetailCollision *detailCollision, int shapeIdx, hkVector4f *shapePosition, hkQuaternionf *shapeOrientationAsQuat)
{
  __int64 v4; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  const hkRotationImpl<float> *p_m_rotation; 

  v4 = shapeIdx;
  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8362, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavokPhysics: Trying to get DetailCollisionShapeTransform with invalid physics asset", "detailCollision") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetDetailCollisionShapeCount(detailCollision)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8363, ASSERT_TYPE_ASSERT, "(shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision ))", "%s\n\tHavokPhysics: Trying to get DetailCollisionShapeTransform with invalid shape index", "shapeIdx >= 0 && shapeIdx < HavokPhysics_GetDetailCollisionShapeCount( detailCollision )") )
    __debugbreak();
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8367, ASSERT_TYPE_ASSERT, "(havokPhysicsDetailCollision)", "%s\n\tHavokPhysics GetDetailCollisionShapeTransform %s: couldn't find havok asset", "havokPhysicsDetailCollision", detailCollision->name) )
    __debugbreak();
  p_m_rotation = &HavokPhysicsXModelLODFromDetailCol->m_bodyBindPoses.m_data[v4].m_rotation;
  *shapePosition = p_m_rotation[1].m_col0;
  hkQuaternionf::setAndNormalize(shapeOrientationAsQuat, p_m_rotation);
}

/*
==============
HavokPhysics_GetDetailHitData
==============
*/
const Physics_DetailHitData *HavokPhysics_GetDetailHitData(const HavokPhysics_CollisionQueryResult *result, int modifierIndex, int hitIndex)
{
  HavokPhysicsHitCollector_DetailTraceModifier *Modifier; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13653, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13654, ASSERT_TYPE_ASSERT, "(result->m_collector)", (const char *)&queryFormat, "result->m_collector") )
    __debugbreak();
  Modifier = (HavokPhysicsHitCollector_DetailTraceModifier *)HavokPhysicsHitCollector::GetModifier(result->m_collector, modifierIndex);
  if ( !Modifier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13657, ASSERT_TYPE_ASSERT, "(modifier)", (const char *)&queryFormat, "modifier") )
    __debugbreak();
  if ( hitIndex < HavokPhysicsHitCollector_DetailTraceModifier::GetNumDetailHitDatas(Modifier) )
    return HavokPhysicsHitCollector_DetailTraceModifier::GetDetailHitData(Modifier, hitIndex);
  else
    return 0i64;
}

/*
==============
HavokPhysics_GetErrorString
==============
*/
const char *HavokPhysics_GetErrorString()
{
  return s_errorExtraString;
}

/*
==============
HavokPhysics_GetFixedMemoryPoolUsage
==============
*/
float HavokPhysics_GetFixedMemoryPoolUsage(Physics_WorldId worldId)
{
  const HavokPhysicsWorld *ConstWorld; 
  float v3; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16459, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to GetFixedMemoryPoolUsage with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v3 = (float)ConstWorld->persistentStreamAllocator->getBytesUsed(ConstWorld->persistentStreamAllocator);
  return v3 / (float)hkFixedBlockStreamAllocator::getCapacity(ConstWorld->persistentStreamAllocator);
}

/*
==============
HavokPhysics_GetHavokPhysicsAsset
==============
*/
const HavokPhysicsAsset *HavokPhysics_GetHavokPhysicsAsset(const PhysicsAsset *physicsAsset)
{
  int m_hashMod; 
  unsigned __int32 v3; 
  unsigned __int32 v4; 
  int v5; 
  int v6; 
  const PhysicsAsset *key; 
  __int64 v8; 
  int v9; 
  unsigned __int64 val; 
  unsigned __int64 v12; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8031, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Get Havok Physics Asset from NULL Physics Asset", "physicsAsset") )
    __debugbreak();
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8034, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", (const char *)&queryFormat, "s_havokPhysicsAssets") )
    __debugbreak();
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  m_hashMod = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v3 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset)), v4 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset), v5 = m_hashMod & (v3 ^ ((v4 >> 2) + v4 + (v3 << 6) - 1640531527)), v6 = v5, key = (const PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v5].key, key == (const PhysicsAsset *)-1i64) )
  {
LABEL_11:
    v6 = m_hashMod + 1;
  }
  else
  {
    while ( key != physicsAsset )
    {
      v5 = m_hashMod & (v5 + 1);
      v6 = v5;
      key = (const PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v5].key;
      if ( key == (const PhysicsAsset *)-1i64 )
        goto LABEL_11;
    }
  }
  v8 = 0i64;
  if ( v6 > m_hashMod )
  {
    val = v12;
    v9 = -2147220992;
  }
  else
  {
    v9 = 0;
    val = s_havokPhysicsAssets->m_map.m_elem[v6].val;
  }
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( v9 >= 0 )
    return (const HavokPhysicsAsset *)val;
  return (const HavokPhysicsAsset *)v8;
}

/*
==============
HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol
==============
*/
const HavokPhysicsXModelLOD *HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(const XModelDetailCollision *const detailCollision)
{
  int m_hashMod; 
  unsigned __int32 v3; 
  unsigned __int32 v4; 
  int v5; 
  int v6; 
  const XModelDetailCollision *key; 
  __int64 v8; 
  int v9; 
  unsigned __int64 val; 
  unsigned __int64 v12; 

  if ( !detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8068, ASSERT_TYPE_ASSERT, "(detailCollision)", "%s\n\tHavok Physics: Trying to Get Havok Physics XModel LOD from NULL XModelDetailCollision", "detailCollision") )
    __debugbreak();
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v3 = _byteswap_ulong(-1640531535 * HIDWORD(detailCollision)), v4 = _byteswap_ulong(-1640531535 * (_DWORD)detailCollision), v5 = m_hashMod & (v3 ^ ((v4 >> 2) + v4 + (v3 << 6) - 1640531527)), v6 = v5, key = (const XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v5].key, key == (const XModelDetailCollision *)-1i64) )
  {
LABEL_8:
    v6 = m_hashMod + 1;
  }
  else
  {
    while ( key != detailCollision )
    {
      v5 = m_hashMod & (v5 + 1);
      v6 = v5;
      key = (const XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v5].key;
      if ( key == (const XModelDetailCollision *)-1i64 )
        goto LABEL_8;
    }
  }
  v8 = 0i64;
  if ( v6 > m_hashMod )
  {
    val = v12;
    v9 = -2147220992;
  }
  else
  {
    v9 = 0;
    val = s_havokPhysicsXModelLODs->m_map.m_elem[v6].val;
  }
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  if ( v9 >= 0 )
    return (const HavokPhysicsXModelLOD *)val;
  return (const HavokPhysicsXModelLOD *)v8;
}

/*
==============
HavokPhysics_GetInstanceAsset
==============
*/
const PhysicsAsset *HavokPhysics_GetInstanceAsset(Physics_WorldId worldId, unsigned int instanceId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10931, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10932, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Instance Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10937, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetInstanceAsset %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_GetInstanceDetailModel
==============
*/
const XModel *HavokPhysics_GetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10954, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance detail Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10955, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get detailInstance Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10960, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetDetailModel %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_GetDetailModel(&ConstWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_GetInstanceXModel
==============
*/
const XModel *HavokPhysics_GetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10977, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10978, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get model Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10983, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetXModel %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_GetXModel(&ConstWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_GetInstantiatiationPenetrationDepthForAsset
==============
*/
float HavokPhysics_GetInstantiatiationPenetrationDepthForAsset(Physics_WorldId worldId, const PhysicsAsset *physicsAsset, const hkVector4f *position, const hkQuaternionf *orientation, Physics_InstantiateShapeOverride *shapeOverride, int ignoreSystems)
{
  int v10; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  hknpShape **m_data; 
  hknpShape *customShape; 
  hknpShape *v18; 
  __m128 v23; 
  hkMemoryAllocator *v30; 
  hkMemoryAllocator *v31; 
  HavokPhysics_CollisionQueryResult *result; 
  int v34; 
  int numInOut; 
  Physics_WorldId worldIda; 
  int v37; 
  void *v38; 
  int v39; 
  int v40; 
  void *p; 
  int v42; 
  int v43; 
  __int64 v44; 
  __int16 v45; 
  int v46; 
  hkQuaternionf *quat; 
  const hkVector4f *v48; 
  const PhysicsAsset *v49; 
  Physics_GetClosestPointsExtendedData extendedData; 
  __int64 v51; 
  hkVector4f point; 
  hkQuaternionf rotation; 

  v51 = -2i64;
  quat = (hkQuaternionf *)orientation;
  v48 = position;
  v49 = physicsAsset;
  worldIda = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9953, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !physicsAsset )
  {
    LODWORD(result) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9954, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for NULL Physics Asset in world %i", "physicsAsset", result) )
      __debugbreak();
  }
  v34 = position->m_quad.m128_i32[0];
  if ( (v34 & 0x7F800000) == 2139095040 || (v34 = position->m_quad.m128_i32[1], (v34 & 0x7F800000) == 2139095040) || (v34 = position->m_quad.m128_i32[2], (v34 & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9955, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for PhysicsAsset with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
      __debugbreak();
  }
  v34 = orientation->m_vec.m_quad.m128_i32[0];
  if ( (v34 & 0x7F800000) == 2139095040 || (v34 = orientation->m_vec.m_quad.m128_i32[1], (v34 & 0x7F800000) == 2139095040) || (v34 = orientation->m_vec.m_quad.m128_i32[2], (v34 & 0x7F800000) == 2139095040) || (v34 = orientation->m_vec.m_quad.m128_i32[3], (v34 & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9956, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for PhysicsAsset with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
      __debugbreak();
  }
  if ( !shapeOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9957, ASSERT_TYPE_ASSERT, "(shapeOverride)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with NULL shape override struct", "shapeOverride") )
    __debugbreak();
  if ( shapeOverride->shapeOverride != -1 && shapeOverride->customShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9958, ASSERT_TYPE_ASSERT, "(shapeOverride->shapeOverride == -1 || !shapeOverride->customShape)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with shape override and custom shape - pick one", "shapeOverride->shapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || !shapeOverride->customShape") )
    __debugbreak();
  if ( !shapeOverride->physicsAssetAddendum && shapeOverride->shapeAddendum != -1 )
  {
    LODWORD(result) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9959, ASSERT_TYPE_ASSERT, "(shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == -1)", "%s\n\tHavok Physics: Trying to get instantiation penetration depth for Physics Asset with addendum shape but no addendumasset - world index %i", "shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == PHYSICSSHAPE_OVERRIDEID_INVALID", result) )
      __debugbreak();
  }
  v10 = shapeOverride->shapeOverride;
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9965, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetInstantiatiationPenetrationDepthForAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  LODWORD(_XMM9) = 0;
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  if ( v10 != -1 )
  {
    if ( m_physicsSystemData->m_bodyCinfos.m_size > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9974, ASSERT_TYPE_ASSERT, "(localShapeOverride == -1 || bodyCInfos->getSize() <= 1)", "%s\n\tHavok Physics: Shape overrides only implemented for single body assets", "localShapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || bodyCInfos->getSize() <= 1") )
      __debugbreak();
    if ( v10 >= WorldCollision_GetMapEntsShapeCount() )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 146i64);
  }
  v37 = 0;
  numInOut = 0;
  hkMemHeapAllocator();
  v38 = NULL;
  v39 = 0;
  v40 = 0x80000000;
  p = NULL;
  v42 = 0;
  v43 = 0x80000000;
  v34 = 0;
  hkMemHeapAllocator();
  p = NULL;
  v42 = 0;
  v43 = 0x80000000;
  v44 = 0i64;
  v45 = 0;
  v46 = 32;
  v37 = ignoreSystems;
  extendedData.simplify = 0;
  extendedData.collisionBuffer = 0.0;
  extendedData.nonBrushShape = NULL;
  extendedData.phaseSelection = All;
  extendedData.contents = 8389905;
  extendedData.ignoreBodies = (HavokPhysics_IgnoreBodies *)&v37;
  ClosestResult = PhysicsQuery_GetClosestResult(worldId);
  m_data = (hknpShape **)m_physicsSystemData->m_bodyCinfos.m_data;
  if ( m_data != &m_data[24 * m_physicsSystemData->m_bodyCinfos.m_size] )
  {
    _R13 = (__m128 *)(m_data + 8);
    while ( 1 )
    {
      customShape = *m_data;
      if ( v10 == -1 || !WorldCollision_GetMapEntsShape(v10) )
      {
        if ( shapeOverride->customShape )
          customShape = shapeOverride->customShape;
      }
      else
      {
        customShape = WorldCollision_GetMapEntsShape(v10);
      }
      v18 = customShape;
      if ( (customShape->m_flags.m_storage & 1) == 0 )
        v18 = NULL;
      if ( !v18 )
        break;
      hkVector4f::setRotatedDir(&point, quat, (const hkVector4f *)&_R13[-1]);
      point.m_quad = _mm128_add_ps(point.m_quad, v48->m_quad);
      _XMM8 = *_R13;
      _RAX = quat;
      __asm
      {
        vbroadcastss xmm6, dword ptr [r13+0Ch]
        vbroadcastss xmm5, dword ptr [rax+0Ch]
      }
      v23 = _mm128_sub_ps(_mm128_mul_ps(*_R13, _mm_shuffle_ps(quat->m_vec.m_quad, quat->m_vec.m_quad, 201)), _mm128_mul_ps(quat->m_vec.m_quad, _mm_shuffle_ps(_XMM8, _XMM8, 201)));
      _XMM4 = _mm128_add_ps(_mm128_add_ps(_mm_shuffle_ps(v23, v23, 201), _mm128_mul_ps(quat->m_vec.m_quad, _XMM6)), _mm128_mul_ps(*_R13, _XMM5));
      __asm { vdpps   xmm0, xmm8, xmm7, 7Fh }
      _mm128_sub_ps(_mm128_mul_ps(_XMM5, _XMM6), _XMM0);
      __asm
      {
        vblendps xmm5, xmm4, xmm1, 8
        vdpps   xmm3, xmm5, xmm5, 0FFh
        vrsqrtps xmm2, xmm3
      }
      rotation.m_vec.m_quad = _mm128_mul_ps(_XMM5, _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM2, _XMM3), _XMM2)), _mm128_mul_ps(_XMM2, *(__m128 *)hkMath::hkSse_floatHalf)));
      if ( !ClosestResult->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 890, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
        __debugbreak();
      HavokPhysicsHitCollector::Reset(ClosestResult->m_collector, 1);
      HavokPhysics_GetClosestPoints(worldIda, customShape, &point, &rotation, 0.0, &extendedData, ClosestResult);
      if ( HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
      {
        _XMM1 = LODWORD(HavokPhysics_CollisionQueryResult::GetHit(ClosestResult, 0)->m_fraction) ^ (unsigned __int128)(unsigned int)_xmm;
        __asm { vmaxss  xmm9, xmm1, xmm9 }
      }
      m_data += 24;
      _R13 += 12;
      if ( m_data == (hknpShape **)&m_physicsSystemData->m_bodyCinfos.m_data[m_physicsSystemData->m_bodyCinfos.m_size] )
        goto LABEL_56;
    }
    Com_PrintWarning(20, "Physics: Havok shape from asset %s is not a simple convex, which may lead to the object not spawning/rendering", v49->name);
    *(float *)&_XMM9 = FLOAT_N1_0;
  }
LABEL_56:
  v30 = hkMemHeapAllocator();
  v42 = 0;
  if ( v43 >= 0 )
    hkMemoryAllocator::bufFree2(v30, p, 4, v43 & 0x3FFFFFFF);
  p = NULL;
  v43 = 0x80000000;
  v31 = hkMemHeapAllocator();
  v39 = 0;
  if ( v40 >= 0 )
    hkMemoryAllocator::bufFree2(v31, v38, 8, v40 & 0x3FFFFFFF);
  return *(float *)&_XMM9;
}

/*
==============
HavokPhysics_GetLandscapeShapeHelper
==============
*/
void HavokPhysics_GetLandscapeShapeHelper(const hknpShape **shape, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant> *meshShapeKey, int *shapeKeyPathSizeOut, hknpShapeCollector *shapeCollector)
{
  if ( (*shape)->m_type.m_storage != 22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 734, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::USER_0)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::USER_0") )
    __debugbreak();
  StaticModels_HavokShape_GetLandscapeShapeHelper(shape, meshShapeKey, shapeKeyPathSizeOut, shapeCollector);
}

/*
==============
HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex
==============
*/
hknpMotionPropertiesId *HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(hknpMotionPropertiesId *result, const unsigned int gravityPropertyIndex, const unsigned int motionPropertiesNameCRC32Index)
{
  unsigned int v6; 
  __int64 v8; 
  int m_size; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  int v13; 

  if ( !s_havokPhysicsMotionPropertiesLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5538, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list)", (const char *)&queryFormat, "s_havokPhysicsMotionPropertiesLibrary.list") )
    __debugbreak();
  if ( motionPropertiesNameCRC32Index >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size )
  {
    m_size = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
    LODWORD(v8) = motionPropertiesNameCRC32Index;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5539, ASSERT_TYPE_ASSERT, "(unsigned)( motionPropertiesNameCRC32Index ) < (unsigned)( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize() )", "motionPropertiesNameCRC32Index doesn't index s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize()\n\t%i not in [0, %i)", v8, m_size) )
      __debugbreak();
  }
  if ( gravityPropertyIndex > 4 )
  {
    v13 = 4;
    v11 = gravityPropertyIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5540, ASSERT_TYPE_ASSERT, "( gravityPropertyIndex ) <= ( Physics_GravityType_Count )", "%s <= %s\n\t%u, %u", "gravityPropertyIndex", "Physics_GravityType_Count", v11, v13) )
      __debugbreak();
  }
  if ( !s_motionPropertiesAreReorderedForSPGold )
  {
    v6 = gravityPropertyIndex * s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
    goto LABEL_18;
  }
  if ( motionPropertiesNameCRC32Index < 0xB )
  {
    LOWORD(v6) = 11 * gravityPropertyIndex;
LABEL_18:
    LOWORD(v6) = motionPropertiesNameCRC32Index + v6;
    goto LABEL_19;
  }
  if ( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size < 0xBu )
  {
    LODWORD(v12) = 11;
    LODWORD(v10) = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5553, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize() ) >= ( SP_GOLD_MOTION_PROPERTIES_LIST_COUNT )", "%s >= %s\n\t%u, %u", "s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize()", "SP_GOLD_MOTION_PROPERTIES_LIST_COUNT", v10, v12) )
      __debugbreak();
  }
  v6 = gravityPropertyIndex * (s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size - 11) + motionPropertiesNameCRC32Index + 44;
LABEL_19:
  result->m_value = v6 + s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
  return result;
}

/*
==============
HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId
==============
*/
__int64 HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId(const hknpMotionPropertiesId id)
{
  unsigned __int16 m_value; 
  unsigned int v3; 
  int v5; 
  int v6; 

  if ( !s_motionPropertiesAreReorderedForSPGold )
    return (unsigned int)((id.m_value - s_havokPhysicsMotionPropertiesLibrary.firstId.m_value) % s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size);
  m_value = s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
  if ( id.m_value < s_havokPhysicsMotionPropertiesLibrary.firstId.m_value )
  {
    v6 = s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
    v5 = id.m_value;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5573, ASSERT_TYPE_ASSERT, "( id.value() ) >= ( s_havokPhysicsMotionPropertiesLibrary.firstId.value() )", "%s >= %s\n\t%u, %u", "id.value()", "s_havokPhysicsMotionPropertiesLibrary.firstId.value()", v5, v6) )
      __debugbreak();
    m_value = s_havokPhysicsMotionPropertiesLibrary.firstId.m_value;
  }
  v3 = id.m_value - m_value;
  if ( v3 >= 0x37 )
    return (v3 - 55) % (s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size - 11) + 11;
  else
    return v3 % 0xB;
}

/*
==============
HavokPhysics_GetNumContentsInShapeList
==============
*/
__int64 HavokPhysics_GetNumContentsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_shapeContents.m_size;
}

/*
==============
HavokPhysics_GetNumConvexCountsInShapeList
==============
*/
__int64 HavokPhysics_GetNumConvexCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_convexCounts.m_size;
}

/*
==============
HavokPhysics_GetNumServerRigidBodysInAsset
==============
*/
__int64 HavokPhysics_GetNumServerRigidBodysInAsset(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  int *m_data; 
  unsigned int v4; 
  int *i; 
  int v6; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8504, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset server body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8508, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetNumServerRigidBodysInAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8509, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetNumServerRigidBodysInAsset %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_data = HavokPhysicsAsset->m_bodyServerUsage.m_data;
  v4 = 0;
  for ( i = &m_data[HavokPhysicsAsset->m_bodyServerUsage.m_size]; m_data != i; ++m_data )
  {
    v6 = v4++;
    if ( (unsigned int)*m_data > 1 )
      v4 = v6;
  }
  return v4;
}

/*
==============
HavokPhysics_GetNumShapeNamesInShapeList
==============
*/
__int64 HavokPhysics_GetNumShapeNamesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_shapeNames.m_size;
}

/*
==============
HavokPhysics_GetNumShapesInShapeList
==============
*/
__int64 HavokPhysics_GetNumShapesInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_shapes.m_size;
}

/*
==============
HavokPhysics_GetNumTriCountsInShapeList
==============
*/
__int64 HavokPhysics_GetNumTriCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_triCounts.m_size;
}

/*
==============
HavokPhysics_GetNumVertCountsInShapeList
==============
*/
__int64 HavokPhysics_GetNumVertCountsInShapeList(HavokPhysicsShapeList *shapeList)
{
  return (unsigned int)shapeList->m_vertCounts.m_size;
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyBounds
==============
*/
void HavokPhysics_GetPhysicsAssetBodyBounds(const PhysicsAsset *physicsAsset, int bodyIdx, hkTransformf *transform, hkAabb *aabb)
{
  __int64 v4; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const hknpShape *m_ptr; 

  v4 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8419, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset body bounds with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8420, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset body bounds with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8424, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8425, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_ptr = HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v4].m_shape.m_ptr;
  m_ptr->calcAabb((hknpShape *)m_ptr, transform, aabb);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyCount
==============
*/
__int64 HavokPhysics_GetPhysicsAssetBodyCount(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8291, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8295, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyCount %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8296, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetBodyCount %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return (unsigned int)HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size;
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyName
==============
*/
const char *HavokPhysics_GetPhysicsAssetBodyName(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8322, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset body count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8323, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset body count with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8327, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8328, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetBodyName %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return (const char *)((unsigned __int64)HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v2].m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
}

/*
==============
HavokPhysics_GetPhysicsAssetBodyTransform
==============
*/
void HavokPhysics_GetPhysicsAssetBodyTransform(const PhysicsAsset *physicsAsset, int bodyIdx, hkVector4f *bodyPosition, hkQuaternionf *bodyOrientationAsQuat)
{
  __int64 v4; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hkQuaternionf *v9; 

  v4 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8342, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get PhysicsAssetBodyTransform with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8343, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get PhysicsAssetBodyTransform with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8347, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetBodyTransform %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  v9 = (hkQuaternionf *)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v4];
  *bodyPosition = v9[3].m_vec;
  *bodyOrientationAsQuat = (hkQuaternionf)v9[4].m_vec.m_quad;
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintBodyIds
==============
*/
void HavokPhysics_GetPhysicsAssetConstraintBodyIds(const PhysicsAsset *physicsAsset, int constraintIdx, int *bodyId1, int *bodyId2)
{
  __int64 v4; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpConstraintCinfo *m_data; 

  v4 = constraintIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8398, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset constraint body ids with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v4 < 0 || (int)v4 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8399, ASSERT_TYPE_ASSERT, "(constraintIdx >= 0 && constraintIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset constraint body ids with invalid constraint index", "constraintIdx >= 0 && constraintIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8403, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintBodyIds %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8404, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintBodyIds %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_data = HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_data;
  *bodyId1 = m_data[v4].m_bodyA.m_serialAndIndex;
  *bodyId2 = m_data[v4].m_bodyB.m_serialAndIndex;
}

/*
==============
HavokPhysics_GetPhysicsAssetConstraintCount
==============
*/
__int64 HavokPhysics_GetPhysicsAssetConstraintCount(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8382, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset constraint count with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8386, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintCount %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8387, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetConstraintCount %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return (unsigned int)HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_size;
}

/*
==============
HavokPhysics_GetPhysicsAssetContents
==============
*/
__int64 HavokPhysics_GetPhysicsAssetContents(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned int v4; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment *m_data; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment *i; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8235, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset contents with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8239, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetContents %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8240, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetContents %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  v4 = 0;
  m_data = m_physicsSystemData->m_bodyCinfos.m_data;
  for ( i = &m_data[m_physicsSystemData->m_bodyCinfos.m_size]; m_data != i; ++m_data )
    v4 |= m_data->m_collisionFilterInfo;
  return v4;
}

/*
==============
HavokPhysics_GetPhysicsAssetShape
==============
*/
const hknpShape *HavokPhysics_GetPhysicsAssetShape(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8439, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset shape with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8440, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset shape with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8444, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetShape %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8445, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetShape %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  return HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v2].m_shape.m_ptr;
}

/*
==============
HavokPhysics_GetPhysicsAssetShapeTag
==============
*/
unsigned __int16 HavokPhysics_GetPhysicsAssetShapeTag(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v5; 
  unsigned int v6; 
  HavokPhysicsShapeList::ShapeTagData shapeTagData; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8470, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to get physics asset shapeTag with invalid physics asset", "physicsAsset") )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysics_GetPhysicsAssetBodyCount(physicsAsset)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8471, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavokPhysics: Trying to get physics asset shapeTag with invalid body index", "bodyIdx >= 0 && bodyIdx < HavokPhysics_GetPhysicsAssetBodyCount( physicsAsset )") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8475, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics GetPhysicsAssetShapeTag %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8476, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics GetPhysicsAssetShapeTag %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  v5 = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v2];
  v6 = *(_DWORD *)(v5 + 16);
  shapeTagData.m_materialCRC = 0;
  shapeTagData.m_collisionFilterInfo = v6;
  LOWORD(v6) = *(_WORD *)(v5 + 20);
  shapeTagData.m_userData = 0i64;
  shapeTagData.m_materialId.m_value = v6;
  return HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
}

/*
==============
HavokPhysics_GetRef
==============
*/
int HavokPhysics_GetRef(const hknpBody *body)
{
  return truncate_cast<int,unsigned __int64>(LODWORD(body->m_userData));
}

/*
==============
HavokPhysics_GetRef
==============
*/
int HavokPhysics_GetRef(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v5; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11075, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get ref with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11076, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Ref with invalid body id for world %i", "bodyId.isValid()", v7) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11080, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRef %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  v5 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  return truncate_cast<int,unsigned __int64>(*(unsigned int *)(v5 + 160));
}

/*
==============
HavokPhysics_GetRigidBodyAABB
==============
*/
void HavokPhysics_GetRigidBodyAABB(Physics_WorldId worldId, hknpBodyId bodyId, hkAabb *aabb, bool worldSpace)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v9; 
  hknpWorld *world; 
  __m128 m_quad; 
  __m128 v18; 
  __m128 v19; 
  __int64 v21; 
  __int64 v22; 
  _BYTE v23[64]; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11678, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11679, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid body id for world %i", "bodyId.isValid()", v22) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v22) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11684, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v22) )
      __debugbreak();
  }
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( worldSpace )
  {
    world = ConstWorld->world;
    _XMM3 = *(_OWORD *)(v9 + 80);
    __asm
    {
      vpshufb xmm0, xmm3, xmmword ptr [rcx+590h]
      vpand   xmm1, xmm0, xmm4
      vpaddd  xmm2, xmm1, xmmword ptr [rcx+600h]
      vpshufb xmm0, xmm3, xmmword ptr [rcx+5A0h]
    }
    m_quad = world->m_intSpaceUtil.m_bitScale24Inv.m_quad;
    __asm { vpand   xmm1, xmm0, xmm4 }
    v18 = world->m_intSpaceUtil.m_bitOffset24.m_quad;
    v19 = _mm_cvtepi32_ps(_XMM2);
    __asm { vpaddd  xmm2, xmm1, xmmword ptr [rcx+5F0h] }
    aabb->m_max.m_quad = _mm128_sub_ps(_mm128_mul_ps(m_quad, _mm_cvtepi32_ps(_XMM2)), v18);
    aabb->m_min.m_quad = _mm128_sub_ps(_mm128_mul_ps(m_quad, v19), v18);
  }
  else
  {
    v21 = *(_QWORD *)(v9 + 96);
    *(__m256i *)v23 = *(__m256i *)g_vectorfConstants[32].m128_f32;
    *(__m256i *)&v23[32] = *(__m256i *)g_vectorfConstants[34].m128_f32;
    (*(void (__fastcall **)(__int64, _BYTE *, hkAabb *))(*(_QWORD *)v21 + 32i64))(v21, v23, aabb);
  }
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMass
==============
*/
void HavokPhysics_GetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMass)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v7; 
  __int64 v8; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11632, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11633, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass with invalid body id for world %i", "bodyId.isValid()", v8) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11638, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyCenterOfMass %i: world is NULL", "havokPhysicsWorld->world", v8) )
      __debugbreak();
  }
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v7 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11644, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  *centerOfMass = *(hkVector4f *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v7 + 64));
}

/*
==============
HavokPhysics_GetRigidBodyCenterOfMassLocal
==============
*/
void HavokPhysics_GetRigidBodyCenterOfMassLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *centerOfMassLocal)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v14; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11657, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass (Local) with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11658, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Center of Mass (Local) with invalid body id for world %i", "bodyId.isValid()", v14) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11663, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyCenterOfMassLocal %i: world is NULL", "havokPhysicsWorld->world", v14) )
      __debugbreak();
  }
  _RAX = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  __asm
  {
    vbroadcastss xmm0, dword ptr [rax+1Ch]
    vbroadcastss xmm4, dword ptr [rax+2Ch]
    vbroadcastss xmm2, dword ptr [rax+0Ch]
    vunpcklps xmm3, xmm2, xmm0
    vunpcklps xmm1, xmm4, xmm4
    vmovlhps xmm0, xmm3, xmm1
  }
  *centerOfMassLocal = (hkVector4f)_XMM0.m_quad;
}

/*
==============
HavokPhysics_GetRigidBodyContents
==============
*/
__int64 HavokPhysics_GetRigidBodyContents(const Physics_WorldId worldId, const hknpBodyId bodyId)
{
  hknpWorld *world; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11910, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11911, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get RigidBody contents with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11916, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics GetRigidBodyContents %i: world is NULL", "world", v6) )
      __debugbreak();
  }
  return world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_collisionFilterInfo;
}

/*
==============
HavokPhysics_GetRigidBodyDefaultMass
==============
*/
float HavokPhysics_GetRigidBodyDefaultMass(Physics_WorldId worldId, const PhysicsAsset *physAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  float *m_data; 
  hkRefCountedProperties *v5; 
  hkReferencedObject *v6; 
  hkDiagonalizedMassProperties props; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11572, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Default Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11576, ASSERT_TYPE_ASSERT, "(havokAsset)", (const char *)&queryFormat, "havokAsset") )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11577, ASSERT_TYPE_ASSERT, "(havokAsset->m_physicsSystemData)", (const char *)&queryFormat, "havokAsset->m_physicsSystemData") )
    __debugbreak();
  if ( HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11578, ASSERT_TYPE_ASSERT, "(havokAsset->m_physicsSystemData->m_bodyCinfos.getSize() > 0)", (const char *)&queryFormat, "havokAsset->m_physicsSystemData->m_bodyCinfos.getSize() > 0") )
    __debugbreak();
  m_data = (float *)HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data;
  if ( m_data[28] >= 0.0 )
    return m_data[28];
  v5 = *(hkRefCountedProperties **)(*(_QWORD *)m_data + 48i64);
  if ( v5 )
  {
    v6 = hkRefCountedProperties::accessProperty(v5, 0xF100u);
    if ( v6 )
      hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v6[1], &props);
  }
  return props.m_mass;
}

/*
==============
HavokPhysics_GetRigidBodyDynamicMass
==============
*/
void HavokPhysics_GetRigidBodyDynamicMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 
  __int64 v9; 
  __int64 v16; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11599, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11600, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid body id for world %i", "bodyId.isValid()", v16) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11605, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v16) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v9 = v8;
  if ( (*(_BYTE *)(v8 + 68) & 5) != 0 )
  {
    if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF )
    {
      *mass = 0.0;
      return;
    }
  }
  else if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11618, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
  {
    __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v9 + 64));
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vpunpcklwd xmm0, xmm1, xmm2
  }
  _XMM4 = _mm_shuffle_ps(_XMM0, _XMM0, 255);
  __asm
  {
    vrcpps  xmm5, xmm4
    vcmpeqps xmm3, xmm4, xmm0
  }
  _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM5, _XMM4)), _XMM5);
  __asm { vandnps xmm3, xmm3, xmm2 }
  *mass = *(float *)&_XMM3;
}

/*
==============
HavokPhysics_GetRigidBodyInverseInertiaLocal
==============
*/
void HavokPhysics_GetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, hkVector4f *invInertia)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 
  __int64 v11; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11752, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Inverse Inertia matrix with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11753, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Inverse Inertia matrix  with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11758, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyInverseInertiaWorld %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11761, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  ((void (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v8 + 64));
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vpunpcklwd xmm0, xmm1, xmm2
  }
  *invInertia = (hkVector4f)_XMM0.m_quad;
}

/*
==============
HavokPhysics_GetRigidBodyMass
==============
*/
void HavokPhysics_GetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, float *mass)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 
  __int64 v9; 
  __int64 v16; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11543, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11544, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Mass with invalid body id for world %i", "bodyId.isValid()", v16) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11549, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v16) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v9 = v8;
  if ( (*(_BYTE *)(v8 + 68) & 5) != 0 )
  {
    *mass = 0.0;
  }
  else
  {
    if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11562, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
      __debugbreak();
    ((void (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v9 + 64));
    __asm
    {
      vpxor   xmm1, xmm1, xmm1
      vpunpcklwd xmm0, xmm1, xmm2
    }
    _XMM4 = _mm_shuffle_ps(_XMM0, _XMM0, 255);
    __asm
    {
      vrcpps  xmm5, xmm4
      vcmpeqps xmm3, xmm4, xmm0
    }
    _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM5, _XMM4)), _XMM5);
    __asm { vandnps xmm3, xmm3, xmm2 }
    *mass = *(float *)&_XMM3;
  }
}

/*
==============
HavokPhysics_GetRigidBodyMaxAngSpeed
==============
*/
void HavokPhysics_GetRigidBodyMaxAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxAngSpeed)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11449, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxAngSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11450, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxAngSpeed with invalid body id for world %i", "bodyId.isValid()", v7) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11455, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  *maxAngSpeed = ConstWorld->world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_motionId.m_value].m_pod.m_angularVelocityLocalAndSpeedLimit.m_quad.m128_f32[3];
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinAngSpeed
==============
*/
void HavokPhysics_GetRigidBodyMaxLinAngSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed, float *maxAngSpeed)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11474, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinAngSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11475, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinAngSpeed with invalid body id for world %i", "bodyId.isValid()", v12) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11480, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v12) )
      __debugbreak();
  }
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getMotion)(&ConstWorld->world->hknpWorldReader, *(unsigned int *)(v9 + 64));
  v11 = (__int64)&ConstWorld->world->getMotionPropertiesLibrary(&ConstWorld->world->hknpWorldReader)->m_motionProperties.m_objects.m_data[*(unsigned __int16 *)(v10 + 56)];
  *maxLinSpeed = *(float *)(v11 + 16);
  *maxAngSpeed = *(float *)(v11 + 20);
}

/*
==============
HavokPhysics_GetRigidBodyMaxLinSpeed
==============
*/
void HavokPhysics_GetRigidBodyMaxLinSpeed(Physics_WorldId worldId, hknpBodyId bodyId, float *maxLinSpeed)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11424, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11425, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinSpeed with invalid body id for world %i", "bodyId.isValid()", v7) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11430, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  *maxLinSpeed = ConstWorld->world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_motionId.m_value].m_pod.m_linearVelocityAndSpeedLimit.m_quad.m128_f32[3];
}

/*
==============
HavokPhysics_GetRigidBodyName
==============
*/
const char *HavokPhysics_GetRigidBodyName(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11503, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Name with invalid body id for world %i", "bodyId.isValid()", worldId) )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11508, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyName %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (const char *)((unsigned __int64)ConstWorld->world->m_bodyManager.m_bodyNames.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
}

/*
==============
HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo
==============
*/
void HavokPhysics_GetRigidBodyTransformAfterWarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, hknpBodyId bodyId, const hkVector4f *hkInstancePosition, const hkQuaternionf *hkInstanceOrientation, hkVector4f *hkBodyPosition, hkQuaternionf *hkBodyOrientation)
{
  unsigned int m_serialAndIndex; 
  hkQuaternionf *v12; 
  hknpWorld *v13; 
  __m256i *v14; 
  __m256i v15; 
  hkVector4f v16; 
  hkTransformf *p_bTc; 
  __int64 v18; 
  hknpBodyId result; 
  const hkQuaternionf *v20; 
  hknpWorld *world; 
  hkTransformf t; 
  hkTransformf bTc; 
  hkTransformf v24; 
  hkTransformf v25; 
  hkTransformf aTb; 
  hkTransformf v27; 

  v20 = hkInstanceOrientation;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12704, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform After Warp Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v18) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12705, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform After Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v18) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v18) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12710, ASSERT_TYPE_ASSERT, "(hkWorld)", "%s\n\tHavokPhysics Get Rigid Body Transform After Warp Instance %i: world is NULL", "hkWorld", v18) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v24.m_rotation, hkInstanceOrientation);
  v24.m_translation = (hkVector4f)hkInstancePosition->m_quad;
  HavokPhysics_GetRigidBodyID(&result, worldId, instanceId, 0);
  m_serialAndIndex = result.m_serialAndIndex;
  if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12717, ASSERT_TYPE_ASSERT, "(body0Id.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform After Warp Instance with invalid body id for body %i in instance %i world %i", "body0Id.isValid()", 0i64, instanceId, worldId) )
    __debugbreak();
  if ( m_serialAndIndex == bodyId.m_serialAndIndex )
  {
    v12 = (hkQuaternionf *)v20;
    *hkBodyPosition = (hkVector4f)hkInstancePosition->m_quad;
    *hkBodyOrientation = (hkQuaternionf)v12->m_vec.m_quad;
  }
  else
  {
    v13 = world;
    t = *(hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, m_serialAndIndex);
    hkTransformf::setInverse(&aTb, &t);
    v14 = (__m256i *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v13->getBodyTransform)(&v13->hknpWorldReader, bodyId.m_serialAndIndex);
    *(__m256i *)bTc.m_rotation.m_col0.m_quad.m128_f32 = *v14;
    v15 = v14[1];
    *(float *)&result.m_serialAndIndex = FLOAT_0_001;
    *(__m256i *)bTc.m_rotation.m_col2.m_quad.m128_f32 = v15;
    if ( hkTransformf::isApproximatelyEqual(&t, &v24, (const float *)&result.m_serialAndIndex) )
    {
      v16.m_quad = (__m128)bTc.m_translation;
      p_bTc = &bTc;
    }
    else
    {
      hkTransformf::setMul(&v27, &aTb, &bTc);
      hkTransformf::setMul(&v25, &v24, &v27);
      v16.m_quad = (__m128)v25.m_translation;
      p_bTc = &v25;
    }
    *hkBodyPosition = (hkVector4f)v16.m_quad;
    hkQuaternionf::set(hkBodyOrientation, &p_bTc->m_rotation);
  }
}

/*
==============
HavokPhysics_GetSFXEventAsset
==============
*/
_BOOL8 HavokPhysics_GetSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsSFXEventAsset **asset)
{
  hkArray<PhysicsSFXEventAsset *,hkContainerHeapAllocator> *bodySFXEventAssets; 
  PhysicsSFXEventAsset *v9; 
  PhysicsSFXEventAsset *v10; 
  _BOOL8 result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8558, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetSFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  bodySFXEventAssets = HavokPhysics_GetMutableWorld(worldId)->bodySFXEventAssets;
  v9 = bodySFXEventAssets->m_data[bodyId0.m_serialAndIndex & 0xFFFFFF];
  v10 = bodySFXEventAssets->m_data[bodyId1.m_serialAndIndex & 0xFFFFFF];
  result = v9 && v10 || v9 == NULL;
  if ( !result )
    v10 = v9;
  *asset = v10;
  return result;
}

/*
==============
HavokPhysics_GetShape
==============
*/
hknpShape *HavokPhysics_GetShape(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15532, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to GetShape with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15533, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavokPhysics: Trying to GetShape with invalid body index in world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15537, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetShape %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return *(hknpShape **)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 96);
}

/*
==============
HavokPhysics_GetShapeConvexCountFromShapeList
==============
*/
__int64 HavokPhysics_GetShapeConvexCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_convexCounts.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetShapeFromShapeList
==============
*/
hknpShape *HavokPhysics_GetShapeFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return shapeList->m_shapes.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetShapeNameFromShapeList
==============
*/
const char *HavokPhysics_GetShapeNameFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (const char *)((unsigned __int64)shapeList->m_shapeNames.m_data[shapeIdx].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
}

/*
==============
HavokPhysics_GetShapeOverrideContents
==============
*/
int HavokPhysics_GetShapeOverrideContents(int shapeOverride)
{
  if ( shapeOverride == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9042, ASSERT_TYPE_ASSERT, "(shapeOverride != -1)", "%s\n\tHavok Physics: Trying to GetShapeOverrideContents with unsupported shape override", "shapeOverride != PHYSICSSHAPE_OVERRIDEID_INVALID") )
    __debugbreak();
  if ( shapeOverride >= WorldCollision_GetMapEntsShapeCount() )
    return -33570817;
  else
    return WorldCollision_GetMapEntsShapeContents(shapeOverride);
}

/*
==============
HavokPhysics_GetShapeTriCountFromShapeList
==============
*/
__int64 HavokPhysics_GetShapeTriCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_triCounts.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetShapeTypeName
==============
*/
const char *HavokPhysics_GetShapeTypeName(const hknpShape *shape)
{
  return shapeTypeNames[shape->m_type.m_storage];
}

/*
==============
HavokPhysics_GetShapeUserData
==============
*/
unsigned __int64 HavokPhysics_GetShapeUserData(hknpShape *inShape)
{
  return inShape->m_userData;
}

/*
==============
HavokPhysics_GetShapeVertCountFromShapeList
==============
*/
__int64 HavokPhysics_GetShapeVertCountFromShapeList(HavokPhysicsShapeList *shapeList, unsigned int shapeIdx)
{
  return (unsigned int)shapeList->m_vertCounts.m_data[shapeIdx];
}

/*
==============
HavokPhysics_GetStepInput
==============
*/
hknpStepInput *HavokPhysics_GetStepInput(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3822, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get step input with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return &HavokPhysics_GetMutableWorld(worldId)->stepInput;
}

/*
==============
HavokPhysics_GetTaskQueue
==============
*/
hkDefaultTaskQueue *HavokPhysics_GetTaskQueue(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3807, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to get task queue with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetMutableWorld(worldId)->taskQueue;
}

/*
==============
HavokPhysics_GetThreadId
==============
*/
LPVOID HavokPhysics_GetThreadId()
{
  return TlsGetValue(hkThreadNumber.m_slotID);
}

/*
==============
HavokPhysics_GetThreadPool
==============
*/
HavokPhysicsThreadPool *HavokPhysics_GetThreadPool()
{
  return g_havokPhysicsThreadPool;
}

/*
==============
HavokPhysics_GetVFXEventAsset
==============
*/
_BOOL8 HavokPhysics_GetVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId0, hknpBodyId bodyId1, PhysicsVFXEventAsset **asset)
{
  hkArray<PhysicsVFXEventAsset *,hkContainerHeapAllocator> *bodyVFXEventAssets; 
  PhysicsVFXEventAsset *v9; 
  PhysicsVFXEventAsset *v10; 
  _BOOL8 result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8591, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetVFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  bodyVFXEventAssets = HavokPhysics_GetMutableWorld(worldId)->bodyVFXEventAssets;
  v9 = bodyVFXEventAssets->m_data[bodyId0.m_serialAndIndex & 0xFFFFFF];
  v10 = bodyVFXEventAssets->m_data[bodyId1.m_serialAndIndex & 0xFFFFFF];
  result = v9 && v10 || v9 == NULL;
  if ( !result )
    v10 = v9;
  *asset = v10;
  return result;
}

/*
==============
HavokPhysics_GetWireframeGeometry
==============
*/
void HavokPhysics_GetWireframeGeometry(hknpShape *shape, vec3_t *pointArray, int pointArraySize, int *numLines)
{
  __int64 v5; 
  int v7; 
  hkReferencedObject **m_data; 
  __int64 v9; 
  hkReferencedObject *v10; 
  void (__fastcall *v11)(hkBaseObject *); 
  hkMemoryAllocator *v12; 
  float *v13; 
  char *v14; 
  float *v15; 
  hkMemoryAllocator *v16; 
  hkMemoryAllocator *v17; 
  void *p; 
  int v19; 
  int v20; 
  hkArray<hkDisplayGeometry *,hkContainerHeapAllocator> v21; 

  v5 = pointArraySize;
  v7 = 0;
  v21.m_data = NULL;
  v21.m_size = 0;
  v21.m_capacityAndFlags = 0x80000000;
  hknpShapeUtil::buildShapeDisplayGeometries(shape, CONVEX_RADIUS_DISPLAY_PLANAR, &v21, 0);
  m_data = v21.m_data;
  if ( v21.m_data != &v21.m_data[v21.m_size] )
  {
    v9 = 0i64;
    do
    {
      p = NULL;
      v19 = 0;
      v20 = 0x80000000;
      v10 = *m_data;
      v11 = (*m_data)->__vftable[1].~hkBaseObject;
      v12 = hkMemHeapAllocator();
      ((void (__fastcall *)(hkReferencedObject *, void **, hkMemoryAllocator *))v11)(v10, &p, v12);
      v13 = (float *)p;
      v14 = (char *)p + 16 * v19;
      if ( p != v14 )
      {
        v15 = &pointArray[v9].v[2];
        do
        {
          if ( v9 < v5 )
          {
            *(v15 - 2) = 32.0 * *v13;
            *(v15 - 1) = 32.0 * v13[1];
            *v15 = 32.0 * v13[2];
            ++v7;
            ++v9;
            v15 += 3;
          }
          v13 += 4;
        }
        while ( v13 != (float *)v14 );
      }
      hkReferencedObject::removeReference(*m_data);
      v16 = hkMemHeapAllocator();
      v19 = 0;
      if ( v20 >= 0 )
        hkMemoryAllocator::bufFree2(v16, p, 16, v20 & 0x3FFFFFFF);
      p = NULL;
      v20 = 0x80000000;
      ++m_data;
    }
    while ( m_data != &v21.m_data[v21.m_size] );
  }
  *numLines = v7 / 2;
  v17 = hkMemHeapAllocator();
  v21.m_size = 0;
  if ( v21.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v17, v21.m_data, 8, v21.m_capacityAndFlags & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_GetWorld
==============
*/
hknpWorld *HavokPhysics_GetWorld(Physics_WorldId worldId)
{
  return HavokPhysics_GetMutableWorld(worldId)->world;
}

/*
==============
HavokPhysics_GetWorldId
==============
*/
__int64 HavokPhysics_GetWorldId(const hknpWorld *world)
{
  __int64 result; 
  hknpWorld **i; 

  result = 0i64;
  for ( i = &g_havokPhysicsWorlds[0].world; *i != world; i += 480 )
  {
    result = (unsigned int)(result + 1);
    if ( (unsigned int)result >= 8 )
      return 0xFFFFFFFFi64;
  }
  return result;
}

/*
==============
HavokPhysics_GroupRagdollConstraint
==============
*/
void HavokPhysics_GroupRagdollConstraint(HavokPhysicsWorld *havokPhysicsWorld, const PhysicsAsset *physicsAsset, int ref, hknpConstraintCinfo *cInfo)
{
  __int64 RefSubSystem; 
  hkArray<hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>,hkContainerHeapAllocator> *m_ragdollConstraintGroupId; 
  bool v10; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> *v11; 
  unsigned int m_value; 
  __int64 v13; 
  __int64 v14; 
  Physics_RefSystem RefSystem; 
  hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant> result; 

  if ( !havokPhysicsWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9350, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld)", (const char *)&queryFormat, "havokPhysicsWorld") )
    __debugbreak();
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9351, ASSERT_TYPE_ASSERT, "(physicsAsset)", (const char *)&queryFormat, "physicsAsset") )
    __debugbreak();
  if ( !cInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9352, ASSERT_TYPE_ASSERT, "(cInfo)", (const char *)&queryFormat, "cInfo") )
    __debugbreak();
  if ( Physics_IsAssetRagdoll(physicsAsset) )
  {
    if ( !havokPhysicsWorld->m_ragdollConstraintGroupId && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9356, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->m_ragdollConstraintGroupId)", (const char *)&queryFormat, "havokPhysicsWorld->m_ragdollConstraintGroupId") )
      __debugbreak();
    if ( Physics_GetRefSystem(ref) != Physics_RefSystem_Ragdoll )
    {
      RefSystem = Physics_GetRefSystem(ref);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9357, ASSERT_TYPE_ASSERT, "( Physics_GetRefSystem( ref ) ) == ( Physics_RefSystem_Ragdoll )", "%s == %s\n\t%i, %i", "Physics_GetRefSystem( ref )", "Physics_RefSystem_Ragdoll", RefSystem, 6) )
        __debugbreak();
    }
    RefSubSystem = Physics_GetRefSubSystem(ref);
    if ( (unsigned int)RefSubSystem >= havokPhysicsWorld->m_ragdollConstraintGroupId->m_size )
    {
      LODWORD(v14) = havokPhysicsWorld->m_ragdollConstraintGroupId->m_size;
      LODWORD(v13) = RefSubSystem;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9359, ASSERT_TYPE_ASSERT, "(unsigned)( ragdollId ) < (unsigned)( havokPhysicsWorld->m_ragdollConstraintGroupId->getSize() )", "ragdollId doesn't index havokPhysicsWorld->m_ragdollConstraintGroupId->getSize()\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    m_ragdollConstraintGroupId = havokPhysicsWorld->m_ragdollConstraintGroupId;
    v10 = m_ragdollConstraintGroupId->m_data[RefSubSystem].m_value == 0x7FFFFFFF;
    v11 = &m_ragdollConstraintGroupId->m_data[RefSubSystem];
    if ( v10 || !hknpConstraintManager::isGroupValid(havokPhysicsWorld->world->m_constraintManager, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)v11->m_value) )
    {
      m_value = hknpConstraintManager::allocateConstraintGroup(havokPhysicsWorld->world->m_constraintManager, &result, 8u, (hkHandle<unsigned int,2147483647,hknpConstraintGroupIdDiscriminant>)0x7FFFFFFF)->m_value;
      v11->m_value = m_value;
    }
    else
    {
      m_value = v11->m_value;
    }
    cInfo->m_constraintGroupId.m_value = m_value;
  }
}

/*
==============
HavokPhysics_HasSFXEventAsset
==============
*/
bool HavokPhysics_HasSFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8623, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetVFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetMutableWorld(worldId)->bodySFXEventAssets->m_data[bodyId.m_serialAndIndex & 0xFFFFFF] != NULL;
}

/*
==============
HavokPhysics_HasTriggerEvent
==============
*/
bool HavokPhysics_HasTriggerEvent(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11357, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11358, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11363, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics HasTriggerEvent %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (*(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68) & 0x10) != 0;
}

/*
==============
HavokPhysics_HasVFXEventAsset
==============
*/
bool HavokPhysics_HasVFXEventAsset(Physics_WorldId worldId, hknpBodyId bodyId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8633, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to GetVFXEventAsset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetMutableWorld(worldId)->bodyVFXEventAssets->m_data[bodyId.m_serialAndIndex & 0xFFFFFF] != NULL;
}

/*
==============
HavokPhysics_Init
==============
*/
void HavokPhysics_Init(char *generalMemoryBuffer, int generalMemoryBufferSize, int generalMemoryBufferWarningThreshold, char *debugMemoryBuffer, int debugMemoryBufferSize)
{
  __int64 v5; 
  signed int MainThreadId; 
  int v9; 
  HavokPhysicsLargeBlockAllocator *v10; 
  HavokPhysicsLargeBlockAllocator *v11; 
  HavokPhysicsLargeBlockAllocator *v12; 
  hkMemoryAllocator::ExtendedInterface *v13; 
  HavokPhysicsFreeListAllocator *v14; 
  hkMemoryAllocator::ExtendedInterface *v15; 
  HavokPhysicsFreeListAllocator *v16; 
  hkMemoryAllocator::ExtendedInterface *mapLocalHeapExtended; 
  hkMemoryAllocator::ExtendedInterface *v18; 
  HavokPhysicsFreeListMemorySystem *v19; 
  hkBaseSystem::InitNode *v20; 
  hkBaseSystem::InitNode *m_next; 
  int *v22; 
  int *v23; 
  int *v24; 
  int *v25; 
  int *v26; 
  int *v27; 
  hkMemoryRouter *Value; 
  IWHavokError *v29; 
  hkError *v30; 
  hkError *v31; 
  hkError *m_ptr; 
  hkMonitorStream *v33; 
  hkMemoryRouter *v34; 
  HavokPhysicsThreadPool *v35; 
  HavokPhysicsThreadPool *v36; 
  hkMemoryRouter *v37; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v38; 
  __int64 v39; 
  hkMemoryRouter *v40; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v41; 
  hkMemoryRouter *v42; 
  hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *v43; 
  hkMemoryRouter *v44; 
  hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *v45; 
  hkMemoryRouter *v46; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v47; 
  hkMemoryRouter *v48; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v49; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **v50; 
  hkMemoryRouter *v51; 
  __int64 v52; 
  const char *v53; 
  __int64 v54; 
  unsigned int v55; 
  unsigned int i; 
  const char *v57; 
  __int64 v58; 
  unsigned int j; 
  const char *v60; 
  __int64 v61; 
  unsigned int k; 
  const char *v63; 
  __int64 v64; 
  unsigned int m; 
  const char *v66; 
  hkMemoryRouter *v67; 
  HavokPhysicsShapeTagCodec *v68; 
  HavokPhysicsShapeTagCodec *v69; 
  hkMemoryRouter *v70; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v71; 
  hkMemorySystem::FrameInfo v72; 
  __int64 v73; 

  v73 = -2i64;
  v5 = generalMemoryBufferWarningThreshold;
  InitializeSRWLock((PSRWLOCK)&s_havokPhysicsAssetLock);
  s_havokPhysicsAssetLock.initialized = -1412623820;
  s_havokPhysicsAssetLock.acquireLock = 0;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  MainThreadId = Physics_GetMainThreadId();
  TlsSetValue(hkThreadNumber.m_slotID, (LPVOID)MainThreadId);
  v9 = debugMemoryBufferSize + generalMemoryBufferSize;
  HavokPhysicsLargeBlockAllocator::HavokPhysicsLargeBlockAllocator(&s_havokPhysicsGeneralLargeBlockAllocatorBuffer, generalMemoryBuffer, v9);
  s_havokPhysicsGeneralLargeBlockAllocator = v10;
  HavokPhysicsLargeBlockAllocator::HavokPhysicsLargeBlockAllocator(&s_havokPhysicsMapLocalLargeBlockAllocatorBuffer, v10);
  s_havokPhysicsMapLocalLargeBlockAllocator = v11;
  v12 = s_havokPhysicsGeneralLargeBlockAllocator;
  s_havokPhysicsGeneralLargeBlockAllocator->m_limitedListener = &s_havokPhysicsLimitedMemoryListener;
  if ( !v11 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2479, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMapLocalLargeBlockAllocator)", "%s\n\tHavokPhysics Init: failed to create map local memory allocator", "s_havokPhysicsMapLocalLargeBlockAllocator") )
      __debugbreak();
    v12 = s_havokPhysicsGeneralLargeBlockAllocator;
  }
  v13 = &v12->hkMemoryAllocator::ExtendedInterface;
  if ( !v12 )
    v13 = NULL;
  HavokPhysicsFreeListAllocator::HavokPhysicsFreeListAllocator(&s_havokPhysicsGeneralFreeListAllocatorBuffer, v12, v13, NULL);
  s_havokPhysicsGeneralFreeListAllocator = v14;
  v15 = &s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface;
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator )
    v15 = NULL;
  HavokPhysicsFreeListAllocator::HavokPhysicsFreeListAllocator(&s_havokPhysicsMapLocalFreeListAllocatorBuffer, s_havokPhysicsMapLocalLargeBlockAllocator, v15, NULL);
  s_havokPhysicsMapLocalFreeListAllocator = v16;
  if ( !s_havokPhysicsGeneralFreeListAllocator )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2486, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralFreeListAllocator)", "%s\n\tHavokPhysics Init: failed to create general free list allocator", "s_havokPhysicsGeneralFreeListAllocator") )
      __debugbreak();
    v16 = s_havokPhysicsMapLocalFreeListAllocator;
  }
  if ( !v16 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2487, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMapLocalFreeListAllocator)", "%s\n\tHavokPhysics Init: failed to create map local free list allocator", "s_havokPhysicsMapLocalFreeListAllocator") )
      __debugbreak();
    v16 = s_havokPhysicsMapLocalFreeListAllocator;
  }
  mapLocalHeapExtended = &v16->hkMemoryAllocator::ExtendedInterface;
  if ( !v16 )
    mapLocalHeapExtended = NULL;
  v18 = &s_havokPhysicsGeneralFreeListAllocator->hkMemoryAllocator::ExtendedInterface;
  if ( !s_havokPhysicsGeneralFreeListAllocator )
    v18 = NULL;
  HavokPhysicsFreeListMemorySystem::HavokPhysicsFreeListMemorySystem(&s_havokPhysicsMemorySystemBuffer, s_havokPhysicsGeneralLargeBlockAllocator, s_havokPhysicsGeneralFreeListAllocator, v18, v16, mapLocalHeapExtended, DEFAULT_SETUP_FLAGS);
  s_havokPhysicsMemorySystem = v19;
  if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2489, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMemorySystem)", "%s\n\tHavokPhysics Init: failed to create memory system allocator", "s_havokPhysicsMemorySystem") )
    __debugbreak();
  hkMemorySystem::replaceInstance(s_havokPhysicsMemorySystem);
  hkMemorySystem::FrameInfo::FrameInfo(&v72, 0, 0x8000);
  s_memoryRouter = (hkMemoryRouter *)((__int64 (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemorySystem::FrameInfo *, __int64))s_havokPhysicsMemorySystem->mainInit)(s_havokPhysicsMemorySystem, &v72, 3i64);
  hknpThreadSafetyCheck::s_enableCriticalSection = 1;
  s_memoryDebugRouter = NULL;
  HavokPhysicsDisplayHandler::setDebugMemoryRouter(s_memoryRouter);
  *(_QWORD *)&s_generalMemoryCapacity = v9;
  s_generalMemoryThreshold = v5;
  *(_QWORD *)&s_generalMemoryPeakInUse = 0i64;
  *(_QWORD *)&s_mapLocalMemoryCapacity = 0i64;
  *(_QWORD *)&s_mapLocalMemoryPeakInUse = 0i64;
  *(_QWORD *)&s_debugMemoryCapacity = debugMemoryBufferSize;
  *(_QWORD *)&s_debugMemoryPeakInUse = 0i64;
  if ( ((unsigned __int8)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedIncrement(&s_errorPrintWarningOnly);
  v20 = hkBaseSystem::InitNode::s_listHead;
  if ( hkBaseSystem::InitNode::s_listHead != &hknpGlobals::singletonEntry && hkBaseSystem::InitNode::s_listHead )
  {
    while ( 1 )
    {
      m_next = v20->m_next;
      if ( m_next == &hknpGlobals::singletonEntry )
        break;
      v20 = v20->m_next;
      if ( !m_next )
        goto LABEL_33;
    }
    v20->m_next = m_next->m_next;
    hknpGlobals::singletonEntry.m_next = hkBaseSystem::InitNode::s_listHead;
    hkBaseSystem::InitNode::s_listHead = &hknpGlobals::singletonEntry;
  }
LABEL_33:
  hkBaseSystem::init(s_memoryRouter, HavokPhysics_InitialErrorReportFunction, NULL);
  if ( ((unsigned __int64)&s_errorPrintWarningOnly & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)&s_errorPrintWarningOnly) )
    __debugbreak();
  _InterlockedDecrement(&s_errorPrintWarningOnly);
  LODWORD(v22) = hkOptionalComponent::request(&hkProductFeatures::Common::Patcher::s_optionalComponent);
  if ( *v22 >= 0 )
  {
    LODWORD(v23) = hkOptionalComponent::request(&hkProductFeatures::Common::ReadFormatBinaryTagfile::s_optionalComponent);
    if ( *v23 >= 0 )
    {
      LODWORD(v24) = hkOptionalComponent::request(&hkProductFeatures::Common::WriteFormatBinaryTagfile::s_optionalComponent);
      if ( *v24 >= 0 )
      {
        LODWORD(v25) = hkOptionalComponent::request(&hkProductFeatures::Common::ReadFormatXmlTagfile::s_optionalComponent);
        if ( *v25 >= 0 )
        {
          LODWORD(v26) = hkOptionalComponent::request(&hkProductFeatures::Common::WriteFormatXmlTagfile::s_optionalComponent);
          if ( *v26 >= 0 )
          {
            LODWORD(v27) = hkOptionalComponent::request(&hkProductFeatures::Physics::SimdTreeBroadPhase::s_optionalComponent);
            if ( *v27 >= 0 )
              hkOptionalComponent::request(&hkProductFeatures::Physics::HybridBroadPhase::s_optionalComponent);
          }
        }
      }
    }
  }
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v29 = (IWHavokError *)Value->m_heap->blockAlloc(Value->m_heap, 120i64);
  if ( v29 )
  {
    IWHavokError::IWHavokError(v29, NULL, NULL);
    v31 = v30;
  }
  else
  {
    v31 = NULL;
  }
  m_ptr = hkError::singleton.m_ptr;
  if ( v31 != hkError::singleton.m_ptr )
  {
    if ( hkError::singleton.m_ptr )
      hkReferencedObject::removeReference(hkError::singleton.m_ptr);
    m_ptr = v31;
    hkError::singleton.m_ptr = v31;
  }
  ((void (__fastcall *)(hkError *, __int64, _QWORD))m_ptr->setEnabled)(m_ptr, 4043243525i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1976984315i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1468004382i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2950766898i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2950766897i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4029997037i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 311668207i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 311668200i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2173329443i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1115809886i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1115809887i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 806834473i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1280117224i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4010873767i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2654475628i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2967172809i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 3646206815i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1513100751i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 806855191i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4033798112i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 361947194i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 806844336i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2951401808i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2937381426i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2937381427i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1726877882i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 2672362952i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1641175483i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1862252909i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 4029953228i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1140510869i64, 0i64);
  ((void (__fastcall *)(hkError *, __int64, _QWORD))hkError::singleton.m_ptr->setEnabled)(hkError::singleton.m_ptr, 1273485998i64, 0i64);
  v33 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  hkMonitorStream::resize(v33, 102400);
  if ( s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2581, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", s_havokPhysicsGlobalTypeCompendiumData, NULL) )
    __debugbreak();
  if ( s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2582, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", s_havokPhysicsGlobalTypeCompendiumTypes, NULL) )
    __debugbreak();
  if ( s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2583, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", s_havokPhysicsInPlaceLoad, NULL) )
    __debugbreak();
  v34 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v34 )
    v34 = hkMemoryRouter::s_fallbackRouter;
  v35 = (HavokPhysicsThreadPool *)v34->m_heap->blockAlloc(v34->m_heap, 2664i64);
  if ( v35 )
    HavokPhysicsThreadPool::HavokPhysicsThreadPool(v35);
  else
    v36 = NULL;
  g_havokPhysicsThreadPool = v36;
  if ( s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2590, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets == nullptr)", "%s\n\tHavokPhysics Init: havok physics assets should be NULL", "s_havokPhysicsAssets == HK_NULL") )
    __debugbreak();
  v37 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v37 )
    v37 = hkMemoryRouter::s_fallbackRouter;
  v38 = (hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *)v37->m_heap->blockAlloc(v37->m_heap, 16i64);
  v39 = -1i64;
  if ( v38 )
  {
    v38->m_map.m_elem = NULL;
    v38->m_map.m_numElems = 0;
    v38->m_map.m_hashMod = -1;
  }
  else
  {
    v38 = NULL;
  }
  s_havokPhysicsAssets = v38;
  if ( s_havokPhysicsXModelLODs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2593, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs == nullptr)", "%s\n\tHavokPhysics Init: havok physics lods should be NULL", "s_havokPhysicsXModelLODs == HK_NULL") )
    __debugbreak();
  v40 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v40 )
    v40 = hkMemoryRouter::s_fallbackRouter;
  v41 = (hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *)v40->m_heap->blockAlloc(v40->m_heap, 16i64);
  if ( v41 )
  {
    v41->m_map.m_elem = NULL;
    v41->m_map.m_numElems = 0;
    v41->m_map.m_hashMod = -1;
  }
  else
  {
    v41 = NULL;
  }
  s_havokPhysicsXModelLODs = v41;
  if ( s_havokPhysicsXModelLODShapeTagLookup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2600, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODShapeTagLookup == nullptr)", "%s\n\tHavokPhysics Init: havok physics xmodel lod shape tag lookup should be NULL", "s_havokPhysicsXModelLODShapeTagLookup == HK_NULL") )
    __debugbreak();
  v42 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v42 )
    v42 = hkMemoryRouter::s_fallbackRouter;
  v43 = (hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *)v42->m_heap->blockAlloc(v42->m_heap, 16i64);
  if ( v43 )
  {
    v43->m_map.m_elem = NULL;
    v43->m_map.m_numElems = 0;
    v43->m_map.m_hashMod = -1;
  }
  else
  {
    v43 = NULL;
  }
  s_havokPhysicsXModelLODShapeTagLookup = v43;
  if ( g_havokPhysicsXModelLODShapeTagDatas && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2603, ASSERT_TYPE_ASSERT, "(g_havokPhysicsXModelLODShapeTagDatas == nullptr)", "%s\n\tHavokPhysics Init: havok physics xmodel lod shape tag datas should be NULL", "g_havokPhysicsXModelLODShapeTagDatas == HK_NULL") )
    __debugbreak();
  v44 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v44 )
    v44 = hkMemoryRouter::s_fallbackRouter;
  v45 = (hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *)v44->m_heap->blockAlloc(v44->m_heap, 16i64);
  if ( v45 )
  {
    v45->m_data = NULL;
    v45->m_size = 0;
    v45->m_capacityAndFlags = 0x80000000;
  }
  else
  {
    v45 = NULL;
  }
  g_havokPhysicsXModelLODShapeTagDatas = v45;
  if ( g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2608, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets == nullptr)", "%s\n\tHavokPhysics Init: havok physics sfx event assets should be NULL", "g_physicsSFXEventAssets == HK_NULL") )
    __debugbreak();
  v46 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v46 )
    v46 = hkMemoryRouter::s_fallbackRouter;
  v47 = (hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *)v46->m_heap->blockAlloc(v46->m_heap, 16i64);
  if ( v47 )
  {
    v47->m_elem = NULL;
    v47->m_numElems = 0;
    v47->m_hashMod = -1;
  }
  else
  {
    v47 = NULL;
  }
  g_physicsSFXEventAssets = v47;
  if ( g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2611, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets == nullptr)", "%s\n\tHavokPhysics Init: havok physics vfx event assets should be NULL", "g_physicsVFXEventAssets == HK_NULL") )
    __debugbreak();
  v48 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v48 )
    v48 = hkMemoryRouter::s_fallbackRouter;
  v49 = (hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *)v48->m_heap->blockAlloc(v48->m_heap, 16i64);
  if ( v49 )
  {
    v49->m_elem = NULL;
    v49->m_numElems = 0;
    v49->m_hashMod = -1;
  }
  else
  {
    v49 = NULL;
  }
  g_physicsVFXEventAssets = v49;
  v50 = s_havokPhysicsShapeCaches;
  do
  {
    if ( *v50 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2618, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCaches[threadId] == nullptr)", "%s\n\tHavokPhysics Init: havok physics shape caches should be NULL", "s_havokPhysicsShapeCaches[threadId] == HK_NULL") )
      __debugbreak();
    v51 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v51 )
      v51 = hkMemoryRouter::s_fallbackRouter;
    v52 = (__int64)v51->m_heap->blockAlloc(v51->m_heap, 16i64);
    if ( v52 )
    {
      *(_QWORD *)v52 = 0i64;
      *(_DWORD *)(v52 + 8) = 0;
      *(_DWORD *)(v52 + 12) = -1;
    }
    else
    {
      v52 = 0i64;
    }
    *v50++ = (hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> *)v52;
  }
  while ( (__int64)v50 < (__int64)s_havokPhysicsShapeCachesDisabled );
  v53 = s_staticBodyQualityName;
  v54 = -1i64;
  do
    ++v54;
  while ( s_staticBodyQualityName[v54] );
  v55 = -1;
  for ( i = -1; v54; --v54 )
    i = (i >> 8) ^ g_crc32Table[*(unsigned __int8 *)v53++ ^ (unsigned __int64)(unsigned __int8)i];
  s_staticBodyQualityCRC = ~i;
  v57 = s_dynamicBodyQualityName;
  v58 = -1i64;
  do
    ++v58;
  while ( s_dynamicBodyQualityName[v58] );
  for ( j = -1; v58; --v58 )
    j = (j >> 8) ^ g_crc32Table[*(unsigned __int8 *)v57++ ^ (unsigned __int64)(unsigned __int8)j];
  s_dynamicBodyQualityCRC = ~j;
  v60 = s_vehicleBodyQualityName;
  v61 = -1i64;
  do
    ++v61;
  while ( s_vehicleBodyQualityName[v61] );
  for ( k = -1; v61; --v61 )
    k = (k >> 8) ^ g_crc32Table[*(unsigned __int8 *)v60++ ^ (unsigned __int64)(unsigned __int8)k];
  s_vehicleBodyQualityCRC = ~k;
  v63 = s_staticMotionPropertiesName;
  v64 = -1i64;
  do
    ++v64;
  while ( s_staticMotionPropertiesName[v64] );
  for ( m = -1; v64; --v64 )
    m = (m >> 8) ^ g_crc32Table[*(unsigned __int8 *)v63++ ^ (unsigned __int64)(unsigned __int8)m];
  s_staticMotionPropertiesCRC = ~m;
  v66 = s_keyframedMotionPropertiesName;
  do
    ++v39;
  while ( s_keyframedMotionPropertiesName[v39] );
  for ( ; v39; --v39 )
    v55 = (v55 >> 8) ^ g_crc32Table[*(unsigned __int8 *)v66++ ^ (unsigned __int64)(unsigned __int8)v55];
  s_keyframedMotionPropertiesCRC = ~v55;
  hknpBroadPhase::ms_iwBroadphaseBodiesChangedCallback = HavokPhysics_BroadphaseBodiesChanged;
  SetIwIsMeshShape(HavokPhysics_IsMeshShape);
  SetIwGetLandscapeShapeHelperCallback(HavokPhysics_GetLandscapeShapeHelper);
  if ( s_shapeTagCodec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2640, ASSERT_TYPE_ASSERT, "( s_shapeTagCodec ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_shapeTagCodec", "HK_NULL", s_shapeTagCodec, NULL) )
    __debugbreak();
  v67 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v67 )
    v67 = hkMemoryRouter::s_fallbackRouter;
  v68 = (HavokPhysicsShapeTagCodec *)v67->m_heap->blockAlloc(v67->m_heap, 56i64);
  if ( v68 )
    HavokPhysicsShapeTagCodec::HavokPhysicsShapeTagCodec(v68);
  else
    v69 = NULL;
  s_shapeTagCodec = v69;
  if ( !v69 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2642, ASSERT_TYPE_ASSERT, "( s_shapeTagCodec ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_shapeTagCodec", "HK_NULL", NULL, NULL) )
    __debugbreak();
  if ( s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2646, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels == nullptr)", "%s\n\tHavokPhysics Init: havok physics xmodel array should be NULL", "s_havokPhysicsXModels == HK_NULL") )
    __debugbreak();
  v70 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v70 )
    v70 = hkMemoryRouter::s_fallbackRouter;
  v71 = (hkArray<XModel const *,hkContainerHeapAllocator> *)v70->m_heap->blockAlloc(v70->m_heap, 16i64);
  v72 = (hkMemorySystem::FrameInfo)v71;
  if ( v71 )
  {
    v71->m_data = NULL;
    v71->m_size = 0;
    v71->m_capacityAndFlags = 0x80000000;
    s_havokPhysicsXModels = v71;
  }
  else
  {
    s_havokPhysicsXModels = NULL;
  }
}

/*
==============
HavokPhysics_InitialErrorReportFunction
==============
*/
void HavokPhysics_InitialErrorReportFunction(const char *msg, void *__formal)
{
  if ( s_errorPrintWarningOnly )
    Com_PrintWarning(20, "HavokPhysics: Initial Error as warning: %s (%s)", msg, s_errorExtraString);
  else
    Com_Error_impl(ERR_FATAL, (const ObfuscateErrorText)&stru_1442436B8, 143i64, msg, s_errorExtraString);
}

/*
==============
HavokPhysics_InplaceUnload
==============
*/
void HavokPhysics_InplaceUnload(void *buffer, const unsigned __int64 size)
{
  ;
}

/*
==============
HavokPhysics_InstantiateAsset
==============
*/
__int64 HavokPhysics_InstantiateAsset(Physics_WorldId worldId, const XModel *xModel, const PhysicsAsset *physicsAsset, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool forceAddImmediate, bool tryStartDeactivated, Physics_InstantiateShapeOverride *shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  Physics_WorldId v15; 
  Physics_InstantiationForceType v16; 
  Physics_InstantiateShapeOverride *v17; 
  int v18; 
  HavokPhysicsWorld *MutableWorld; 
  const PhysicsAsset *physicsAssetAddendum; 
  const HavokPhysicsAsset *v21; 
  const PhysicsAsset *v22; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int Instance; 
  __int64 m_physicsSystemData; 
  unsigned __int64 v26; 
  __int64 v27; 
  Physics_InstantiationFilterType v28; 
  hkMemoryAllocator *v29; 
  int v30; 
  hkReferencedObject *v31; 
  hkReferencedObject *v32; 
  hkReferencedObject *v33; 
  hknpShape *MapEntsShape; 
  const hknpShape *v35; 
  const char *MapEntsShapeName; 
  char *v37; 
  int i; 
  const hknpShape *customShape; 
  char v40; 
  __int64 v41; 
  const hknpShape *v42; 
  int shapeAddendum; 
  int ShapeOverrideContents; 
  unsigned __int16 ShapeTag; 
  unsigned __int16 v46; 
  hkMemoryAllocator *v47; 
  int v48; 
  int v49; 
  char *v50; 
  int v51; 
  hkMemoryRouter *Value; 
  hknpCompoundShape *v53; 
  hknpShape *v54; 
  hknpShape *v55; 
  hkMemoryAllocator *v56; 
  __int64 v57; 
  hkReferencedObject **v58; 
  Physics_RefSystem RefSystem; 
  HavokPhysicsWorld *v60; 
  unsigned int v61; 
  unsigned int m_serialAndIndex; 
  unsigned int v63; 
  hkMemoryAllocator *v64; 
  int v65; 
  __int64 v66; 
  __int64 v67; 
  unsigned int v68; 
  const HavokPhysicsAsset *v69; 
  __int64 v70; 
  __int64 v71; 
  HavokPhysicsWorld *v72; 
  unsigned int m_value; 
  hkMemoryAllocator *v74; 
  __int64 v76; 
  int v77; 
  bool v78; 
  char v79; 
  int *array; 
  int v81; 
  int v82; 
  int numInOut; 
  int v84; 
  unsigned int instanceId; 
  int refa; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpConstraintCinfo shapeTagData; 
  Physics_WorldId v89; 
  PhysicsAsset *physicsAsseta; 
  __int64 v91; 
  HavokPhysicsWorld *havokPhysicsWorld; 
  __int64 v93; 
  int v94; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> result; 
  const HavokPhysicsAsset *v96; 
  HavokPhysicsInstanceManager *manager; 
  hkQuaternionf *v98; 
  hkVector4f *v99; 
  char *v100; 
  int v101; 
  int v102; 
  hkVector4f v103; 
  hkQuaternionf v104; 
  Physics_InstantiateShapeOverride *v105; 
  __int64 v106; 
  hknpCompoundShapeCinfo cinfo; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v108; 
  char dest[512]; 

  v106 = -2i64;
  refa = ref;
  physicsAsseta = (PhysicsAsset *)physicsAsset;
  v15 = worldId;
  v89 = worldId;
  v16 = forceType;
  v17 = shapeOverride;
  v105 = shapeOverride;
  v99 = (hkVector4f *)position;
  v98 = (hkQuaternionf *)orientation;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9425, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !physicsAsset )
  {
    LODWORD(v76) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9426, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset in world %i", "physicsAsset", v76) )
      __debugbreak();
  }
  if ( ((position->m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[2] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9427, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
    __debugbreak();
  if ( ((orientation->m_vec.m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[2] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[3] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9428, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
    __debugbreak();
  if ( !shapeOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9429, ASSERT_TYPE_ASSERT, "(shapeOverride)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with NULL shape override struct", "shapeOverride") )
    __debugbreak();
  if ( shapeOverride->shapeOverride != -1 && shapeOverride->customShape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9430, ASSERT_TYPE_ASSERT, "(shapeOverride->shapeOverride == -1 || !shapeOverride->customShape)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with shape override and custom shape - pick one", "shapeOverride->shapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || !shapeOverride->customShape") )
    __debugbreak();
  if ( !shapeOverride->physicsAssetAddendum && shapeOverride->shapeAddendum != -1 )
  {
    LODWORD(v76) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9431, ASSERT_TYPE_ASSERT, "(shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == -1)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset with addendum shape but no addendumasset - world index %i", "shapeOverride->physicsAssetAddendum || shapeOverride->shapeAddendum == PHYSICSSHAPE_OVERRIDEID_INVALID", v76) )
      __debugbreak();
  }
  v18 = shapeOverride->shapeOverride;
  v94 = v18;
  MutableWorld = HavokPhysics_GetMutableWorld(v15);
  havokPhysicsWorld = MutableWorld;
  if ( !MutableWorld->world )
  {
    LODWORD(v76) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9439, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v76) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9444, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  physicsAssetAddendum = shapeOverride->physicsAssetAddendum;
  if ( physicsAssetAddendum )
  {
    v21 = HavokPhysics_GetHavokPhysicsAsset(physicsAssetAddendum);
    v96 = v21;
    v22 = shapeOverride->physicsAssetAddendum;
    if ( v22 && !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9446, ASSERT_TYPE_ASSERT, "(!shapeOverride->physicsAssetAddendum || havokPhysicsAddendumAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok addendum asset", "!shapeOverride->physicsAssetAddendum || havokPhysicsAddendumAsset", v22->name) )
      __debugbreak();
  }
  else
  {
    v96 = NULL;
  }
  p_instanceManager = &MutableWorld->instanceManager;
  manager = &MutableWorld->instanceManager;
  Instance = HavokPhysicsInstanceManager_AllocateInstance(&MutableWorld->instanceManager);
  instanceId = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9451, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID", physicsAsseta->name) )
    __debugbreak();
  HavokPhysicsInstanceManager_SetXModel(p_instanceManager, Instance, xModel);
  HavokPhysicsInstanceManager_SetPhysicsAsset(p_instanceManager, Instance, physicsAsseta);
  HavokPhysicsInstanceManager_SetPhysicsAssetAddendum(p_instanceManager, Instance, shapeOverride->physicsAssetAddendum);
  m_physicsSystemData = (__int64)HavokPhysicsAsset->m_physicsSystemData;
  v93 = m_physicsSystemData;
  if ( v18 != -1 && *(int *)(m_physicsSystemData + 64) > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9463, ASSERT_TYPE_ASSERT, "(localShapeOverride == -1 || bodyCInfos->getSize() <= 1)", "%s\n\tHavok Physics: Shape overrides only implemented for single body assets", "localShapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || bodyCInfos->getSize() <= 1") )
    __debugbreak();
  if ( Physics_IsQueryWorld(v15) || Physics_IsPredictiveWorld(v15) || *(int *)(m_physicsSystemData + 80) <= 0 )
  {
    v79 = 0;
    if ( !add || !forceAddImmediate )
    {
      v78 = 0;
      goto LABEL_58;
    }
  }
  else
  {
    v79 = 1;
  }
  v78 = 1;
  if ( !add && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9470, ASSERT_TYPE_ASSERT, "(!immediateAdd || add)", "%s\n\tHavok Physics: 
    __debugbreak();
LABEL_58:
  if ( v18 != -1 && v18 >= WorldCollision_GetMapEntsShapeCount() )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 144i64);
  v77 = 0;
  v84 = 0;
  array = NULL;
  v81 = 0;
  v82 = 0x80000000;
  v26 = *(_QWORD *)(m_physicsSystemData + 56);
  v104.m_vec.m_quad.m128_u64[0] = v26;
  if ( v26 != v26 + 192i64 * *(int *)(m_physicsSystemData + 64) )
  {
    v27 = 0i64;
    v91 = 0i64;
    v28 = filterType;
    while ( 1 )
    {
      hknpBodyCinfo::hknpBodyCinfo(&v108);
      v108.m_attachedBody = -1;
      if ( v28 != Physics_InstantiationFilterTypeServer && v28 != Physics_InstantiationFilterTypeClientReplication )
        break;
      if ( HavokPhysicsAsset->m_bodyServerUsage.m_data[v27] <= 1u )
        break;
      v29 = hkMemHeapAllocator();
      v30 = v81;
      if ( v81 == (v82 & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v29, &array, 4);
        v30 = v81;
      }
      array[v30] = -1;
      ++v81;
      if ( v108.m_localFrame.m_ptr )
        hkReferencedObject::removeReference(v108.m_localFrame.m_ptr);
      if ( v108.m_dragProperties.m_ptr )
        hkReferencedObject::removeReference(v108.m_dragProperties.m_ptr);
      if ( v108.m_massDistribution.m_ptr )
        hkReferencedObject::removeReference(v108.m_massDistribution.m_ptr);
      hkStringPtr::~hkStringPtr(&v108.m_name);
      if ( v108.m_shape.m_ptr )
        hkReferencedObject::removeReference(&v108.m_shape.m_ptr->hkReferencedObject);
LABEL_192:
      v26 += 192i64;
      v104.m_vec.m_quad.m128_u64[0] = v26;
      ++v84;
      v91 = ++v27;
      if ( v26 == *(_QWORD *)(v93 + 56) + 192i64 * *(int *)(v93 + 64) )
      {
        p_instanceManager = manager;
        m_physicsSystemData = v93;
        goto LABEL_194;
      }
    }
    if ( *(_QWORD *)v26 )
      hkReferencedObject::addReference(*(hkReferencedObject **)v26);
    if ( v108.m_shape.m_ptr )
      hkReferencedObject::removeReference(&v108.m_shape.m_ptr->hkReferencedObject);
    v108.m_shape.m_ptr = *(const hknpShape **)v26;
    v108.m_flags.m_storage = *(_DWORD *)(v26 + 8);
    v108.m_collisionCntrl.m_storage = *(_WORD *)(v26 + 12);
    v108.m_collisionFilterInfo = *(_DWORD *)(v26 + 16);
    v108.m_materialId.m_value = *(_WORD *)(v26 + 20);
    v108.m_qualityId.m_value = *(_BYTE *)(v26 + 22);
    hkStringPtr::operator=(&v108.m_name, (const hkStringPtr *)(v26 + 24));
    v108.m_userData = *(_QWORD *)(v26 + 32);
    v108.m_motionType.m_storage = *(_BYTE *)(v26 + 40);
    *(__m256i *)v108.m_position.m_quad.m128_f32 = *(__m256i *)(v26 + 48);
    *(__m256i *)v108.m_linearVelocity.m_quad.m128_f32 = *(__m256i *)(v26 + 80);
    v108.m_mass = *(float *)(v26 + 112);
    v31 = *(hkReferencedObject **)(v26 + 120);
    if ( v31 )
      hkReferencedObject::addReference(v31);
    if ( v108.m_massDistribution.m_ptr )
      hkReferencedObject::removeReference(v108.m_massDistribution.m_ptr);
    v108.m_massDistribution.m_ptr = *(hknpRefMassDistribution **)(v26 + 120);
    v32 = *(hkReferencedObject **)(v26 + 128);
    if ( v32 )
      hkReferencedObject::addReference(v32);
    if ( v108.m_dragProperties.m_ptr )
      hkReferencedObject::removeReference(v108.m_dragProperties.m_ptr);
    v108.m_dragProperties.m_ptr = *(hknpRefDragProperties **)(v26 + 128);
    v108.m_motionPropertiesId.m_value = *(_WORD *)(v26 + 136);
    v108.m_desiredBodyId.m_serialAndIndex = *(_DWORD *)(v26 + 140);
    v108.m_motionId.m_value = *(_DWORD *)(v26 + 144);
    v108.m_collisionLookAheadDistance = *(float *)(v26 + 148);
    v33 = *(hkReferencedObject **)(v26 + 152);
    if ( v33 )
      hkReferencedObject::addReference(v33);
    if ( v108.m_localFrame.m_ptr )
      hkReferencedObject::removeReference(v108.m_localFrame.m_ptr);
    v108.m_localFrame.m_ptr = *(hkLocalFrame **)(v26 + 152);
    v108.m_activationPriority = *(_BYTE *)(v26 + 160);
    v108.m_attachedBody = *(_DWORD *)(v26 + 176);
    if ( v18 == -1 || !WorldCollision_GetMapEntsShape(v18) )
    {
      customShape = v17->customShape;
      if ( v17->customShape )
      {
        hkReferencedObject::addReference(v17->customShape);
        if ( v108.m_shape.m_ptr )
          hkReferencedObject::removeReference(&v108.m_shape.m_ptr->hkReferencedObject);
        v108.m_shape.m_ptr = customShape;
      }
    }
    else
    {
      MapEntsShape = WorldCollision_GetMapEntsShape(v18);
      v35 = MapEntsShape;
      if ( MapEntsShape )
        hkReferencedObject::addReference(MapEntsShape);
      if ( v108.m_shape.m_ptr )
        hkReferencedObject::removeReference(&v108.m_shape.m_ptr->hkReferencedObject);
      v108.m_shape.m_ptr = v35;
      MapEntsShapeName = WorldCollision_GetMapEntsShapeName(v18);
      Com_sprintf<512>((char (*)[512])dest, "%s:%s", (const char *)((unsigned __int64)v108.m_name.m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), MapEntsShapeName);
      v37 = dest;
      for ( i = dest[0]; *v37; i = *v37 )
        *v37++ = i + ((unsigned int)(i - 65) < 0x1A ? 0x20 : 0);
      hkStringPtr::set(&v108.m_name, dest, -1);
    }
    if ( Physics_IsQueryWorld(v15) )
    {
      v108.m_motionId.m_value = 0x7FFFFFFF;
      v108.m_motionType.m_storage = 0;
    }
    v40 = 0;
    if ( v26 == *(_QWORD *)(v93 + 56) )
    {
      v41 = (__int64)v96;
      if ( v96 )
      {
        if ( v96->m_physicsSystemData->m_bodyCinfos.m_size != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9523, ASSERT_TYPE_ASSERT, "(havokPhysicsAddendumAsset->m_physicsSystemData->m_bodyCinfos.getSize() == 1)", "%s\n\tHavokPhysics InstantiateAsset %s: havok addendum assets only support 1 body at the minute", "havokPhysicsAddendumAsset->m_physicsSystemData->m_bodyCinfos.getSize() == 1", v17->physicsAssetAddendum->name) )
          __debugbreak();
        v42 = **(const hknpShape ***)(*(_QWORD *)(v41 + 8) + 56i64);
        shapeAddendum = v17->shapeAddendum;
        ShapeOverrideContents = 0;
        if ( shapeAddendum != -1 )
        {
          if ( shapeAddendum >= WorldCollision_GetMapEntsShapeCount() )
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 145i64);
          if ( WorldCollision_GetMapEntsShape(shapeAddendum) )
          {
            v42 = WorldCollision_GetMapEntsShape(shapeAddendum);
            ShapeOverrideContents = HavokPhysics_GetShapeOverrideContents(shapeAddendum);
          }
        }
        shapeTagData.m_constraintData.m_ptr = (hkpConstraintData *)v108.m_collisionFilterInfo;
        LOWORD(shapeTagData.m_bodyA.m_serialAndIndex) = v108.m_materialId.m_value;
        *(_QWORD *)&shapeTagData.m_flags.m_storage = v108.m_userData;
        ShapeTag = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, (HavokPhysicsShapeList::ShapeTagData *)&shapeTagData);
        LODWORD(shapeTagData.m_constraintData.m_ptr) = ShapeOverrideContents;
        v46 = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, (HavokPhysicsShapeList::ShapeTagData *)&shapeTagData);
        v108.m_collisionFilterInfo |= ShapeOverrideContents;
        numInOut = 2;
        v47 = hkMemHeapAllocator();
        v48 = numInOut;
        v49 = numInOut;
        if ( numInOut )
        {
          v50 = (char *)hkMemoryAllocator::bufAlloc2(v47, 112, &numInOut);
          v48 = numInOut;
        }
        else
        {
          v50 = NULL;
        }
        v51 = 0x80000000;
        if ( v48 )
          v51 = v48;
        v100 = v50;
        v101 = v49;
        v102 = v51;
        if ( v50 )
        {
          *(__m256i *)v50 = *(__m256i *)g_vectorfConstants[32].m128_f32;
          *((__m256i *)v50 + 1) = *(__m256i *)g_vectorfConstants[34].m128_f32;
          *((__m128 *)v50 + 4) = g_vectorfConstants[6];
          *((_QWORD *)v50 + 10) = 0i64;
          *((_DWORD *)v50 + 22) = -1;
          v50[92] = 0;
          *((_DWORD *)v50 + 24) = 0;
          *((_WORD *)v50 + 50) = -1;
          *((_QWORD *)v50 + 13) = 0i64;
          v103.m_quad.m128_i32[0] = 64;
          *((_DWORD *)v50 + 3) = 1056964672;
        }
        if ( v50 != (char *)-112i64 )
        {
          *(__m256i *)(v50 + 112) = *(__m256i *)g_vectorfConstants[32].m128_f32;
          *(__m256i *)(v50 + 144) = *(__m256i *)g_vectorfConstants[34].m128_f32;
          *((__m128 *)v50 + 11) = g_vectorfConstants[6];
          *((_QWORD *)v50 + 24) = 0i64;
          *((_DWORD *)v50 + 50) = -1;
          v50[204] = 0;
          *((_DWORD *)v50 + 52) = 0;
          *((_WORD *)v50 + 106) = -1;
          *((_QWORD *)v50 + 27) = 0i64;
          v103.m_quad.m128_i32[0] = 64;
          *((_DWORD *)v50 + 31) = 1056964672;
        }
        hknpShapeInstance::setShape((hknpShapeInstance *)v50, v108.m_shape.m_ptr);
        hknpShapeInstance::setShape((hknpShapeInstance *)v50 + 1, v42);
        *((_WORD *)v50 + 44) = ShapeTag;
        *((_WORD *)v50 + 100) = v46;
        hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&cinfo);
        cinfo.m_instances = (const hknpShapeInstance *)v50;
        cinfo.m_numInstances = v49;
        Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
        if ( !Value )
          Value = hkMemoryRouter::s_fallbackRouter;
        v53 = (hknpCompoundShape *)Value->m_heap->blockAlloc(Value->m_heap, 288i64);
        v103.m_quad.m128_u64[0] = (unsigned __int64)v53;
        if ( v53 )
        {
          hknpCompoundShape::hknpCompoundShape(v53, &cinfo);
          v55 = v54;
        }
        else
        {
          v55 = NULL;
        }
        if ( v55 )
          hkReferencedObject::addReference(v55);
        if ( v108.m_shape.m_ptr )
          hkReferencedObject::removeReference(&v108.m_shape.m_ptr->hkReferencedObject);
        v108.m_shape.m_ptr = v55;
        v40 = 1;
        v56 = hkMemHeapAllocator();
        v57 = v49 - 1;
        if ( v49 - 1 >= 0 )
        {
          v58 = (hkReferencedObject **)&v50[112 * v57 + 80];
          do
          {
            if ( *v58 )
              hkReferencedObject::removeReference(*v58);
            v58 -= 14;
            --v57;
          }
          while ( v57 >= 0 );
        }
        v101 = 0;
        if ( v51 >= 0 )
          hkMemoryAllocator::bufFree2(v56, v50, 112, v51 & 0x3FFFFFFF);
        v100 = NULL;
        v102 = 0x80000000;
        v26 = v104.m_vec.m_quad.m128_u64[0];
        v15 = v89;
        v17 = v105;
        v16 = forceType;
        v28 = filterType;
      }
    }
    v108.m_flags.m_storage |= forQueryOnly << 8;
    RefSystem = Physics_GetRefSystem(refa);
    v60 = havokPhysicsWorld;
    HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(v15, havokPhysicsWorld, RefSystem, &v108);
    if ( Physics_IsQueryWorld(v15) )
      goto LABEL_149;
    v61 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v91];
    if ( v28 == Physics_InstantiationFilterTypeServer )
    {
      if ( v61 )
        goto LABEL_149;
    }
    else if ( (v28 == Physics_InstantiationFilterTypeClientReplication || v28 == Physics_InstantiationFilterTypeClientSimulation) && v61 > 1 )
    {
      goto LABEL_149;
    }
    if ( v16 == Physics_InstantiationForceTypeKeyframed )
      goto LABEL_164;
    if ( v16 != Physics_InstantiationForceTypeKeyframedAtMost )
    {
      if ( v16 == Physics_InstantiationForceTypeStatic )
      {
        v108.m_flags.m_storage &= 0xFFFFFFF8;
        v108.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
        v108.m_motionType.m_storage = 0;
        goto LABEL_152;
      }
      goto LABEL_149;
    }
    if ( v108.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
    {
LABEL_164:
      v108.m_flags.m_storage &= 0xFFFFFFF8;
      v108.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
      v108.m_motionType.m_storage = 1;
      goto LABEL_152;
    }
LABEL_149:
    if ( v108.m_motionType.m_storage >= 2u && v16 != Physics_InstantiationForceTypeStatic )
      v108.m_flags.m_storage |= 0x10u;
LABEL_152:
    v104.m_vec.m_quad = v98->m_vec.m_quad;
    v103.m_quad = v99->m_quad;
    m_serialAndIndex = HavokPhysics_CreateRigidBody((hknpBodyId *)&result, v15, v60, physicsAsseta, v84, &v108, refa, &v103, &v104, 0, tryStartDeactivated, 1)->m_serialAndIndex;
    if ( Physics_IsQueryWorld(v15) )
      goto LABEL_175;
    v63 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v91];
    if ( v28 == Physics_InstantiationFilterTypeServer )
    {
      if ( v63 )
        goto LABEL_173;
    }
    else if ( (v28 == Physics_InstantiationFilterTypeClientReplication || v28 == Physics_InstantiationFilterTypeClientSimulation) && v63 > 1 )
    {
LABEL_173:
      if ( v108.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
        HavokPhysics_SetRigidBodyKeyframed(v15, (hknpBodyId)m_serialAndIndex);
      goto LABEL_175;
    }
    if ( v16 != Physics_InstantiationForceTypeKeyframed )
    {
      if ( v16 != Physics_InstantiationForceTypeKeyframedAtMost )
      {
        if ( v16 == Physics_InstantiationForceTypeStatic )
          HavokPhysics_SetRigidBodyStatic(v15, (hknpBodyId)m_serialAndIndex);
LABEL_172:
        if ( v16 == Physics_InstantiationForceTypeNone )
          goto LABEL_173;
LABEL_175:
        if ( v40 )
          hkReferencedObject::removeReference(&v108.m_shape.m_ptr->hkReferencedObject);
        HavokPhysicsInstanceManager_AddBody(manager, instanceId, (hknpBodyId)m_serialAndIndex);
        v64 = hkMemHeapAllocator();
        v65 = v81;
        if ( v81 == (v82 & 0x3FFFFFFF) )
        {
          hkArrayUtil::_reserveMore(v64, &array, 4);
          v65 = v81;
        }
        array[v65] = v77;
        ++v81;
        if ( HavokPhysics_HasTriggerEvent(v15, (hknpBodyId)m_serialAndIndex) && HavokPhysics_IsRigidBodyStatic(v15, (hknpBodyId)m_serialAndIndex) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9695, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
          __debugbreak();
        ++v77;
        if ( v108.m_localFrame.m_ptr )
          hkReferencedObject::removeReference(v108.m_localFrame.m_ptr);
        if ( v108.m_dragProperties.m_ptr )
          hkReferencedObject::removeReference(v108.m_dragProperties.m_ptr);
        if ( v108.m_massDistribution.m_ptr )
          hkReferencedObject::removeReference(v108.m_massDistribution.m_ptr);
        hkStringPtr::~hkStringPtr(&v108.m_name);
        if ( v108.m_shape.m_ptr )
          hkReferencedObject::removeReference(&v108.m_shape.m_ptr->hkReferencedObject);
        v18 = v94;
        v27 = v91;
        goto LABEL_192;
      }
      if ( (*(_BYTE *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))havokPhysicsWorld->world->getBody)(&havokPhysicsWorld->world->hknpWorldReader, m_serialAndIndex) + 68) & 5) != 0 )
        goto LABEL_172;
    }
    HavokPhysics_SetRigidBodyKeyframed(v15, (hknpBodyId)m_serialAndIndex);
    goto LABEL_172;
  }
LABEL_194:
  if ( add )
  {
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    v66 = instanceId;
    if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    HavokPhysics_AddRigidBodies(havokPhysicsWorld, p_instanceManager->buffer[v66].bodies.m_data, p_instanceManager->buffer[v66].bodies.m_size, v78, tryStartDeactivated);
    HavokPhysicsInstanceManager_SetAddedToWorld(v15, p_instanceManager, v66, v78, !v78);
  }
  else
  {
    LODWORD(v66) = instanceId;
  }
  if ( v79 )
  {
    v67 = *(_QWORD *)(m_physicsSystemData + 72);
    v68 = 0;
    if ( v67 != v67 + 40i64 * *(int *)(m_physicsSystemData + 80) )
    {
      do
      {
        shapeTagData.m_constraintData.m_ptr = NULL;
        shapeTagData.m_bodyA.m_serialAndIndex = 0xFFFFFF;
        shapeTagData.m_bodyB.m_serialAndIndex = 0xFFFFFF;
        shapeTagData.m_flags.m_storage = 0;
        shapeTagData.m_name.m_stringAndFlag = NULL;
        shapeTagData.m_desiredConstraintId.m_value = 0x7FFFFFFF;
        shapeTagData.m_constraintGroupId.m_value = 0x7FFFFFFF;
        if ( *(_QWORD *)v67 )
        {
          hkReferencedObject::addReference(*(hkReferencedObject **)v67);
          if ( shapeTagData.m_constraintData.m_ptr )
            hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
        }
        shapeTagData.m_constraintData.m_ptr = *(hkpConstraintData **)v67;
        shapeTagData.m_bodyA.m_serialAndIndex = *(_DWORD *)(v67 + 8);
        shapeTagData.m_bodyB.m_serialAndIndex = *(_DWORD *)(v67 + 12);
        shapeTagData.m_flags.m_storage = *(_WORD *)(v67 + 16);
        hkStringPtr::operator=(&shapeTagData.m_name, (const hkStringPtr *)(v67 + 24));
        shapeTagData.m_desiredConstraintId.m_value = *(_DWORD *)(v67 + 32);
        shapeTagData.m_constraintGroupId.m_value = *(_DWORD *)(v67 + 36);
        if ( (shapeTagData.m_bodyA.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9732, ASSERT_TYPE_ASSERT, "(cInfo.m_bodyA.isValid())", "%s\n\tHavokPhysics InstantiateAsset %s: constraint bodyA is invalid - implies we are trying to use the world as a child", "cInfo.m_bodyA.isValid()", physicsAsseta->name) )
          __debugbreak();
        if ( array[shapeTagData.m_bodyA.m_serialAndIndex] == -1 )
        {
          hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
          if ( shapeTagData.m_constraintData.m_ptr )
            hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
        }
        else if ( (shapeTagData.m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF || array[shapeTagData.m_bodyB.m_serialAndIndex] != -1 )
        {
          v69 = HavokPhysicsAsset;
          if ( v68 >= HavokPhysicsAsset->m_constraintServerUsage.m_size )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9746, ASSERT_TYPE_ASSERT, "(index < (uint)havokPhysicsAsset->m_constraintServerUsage.getSize())", (const char *)&queryFormat, "index < (uint)havokPhysicsAsset->m_constraintServerUsage.getSize()") )
              __debugbreak();
            v69 = HavokPhysicsAsset;
          }
          if ( (unsigned int)v15 > PHYSICS_WORLD_ID_SERVER_DETAIL || v69->m_constraintServerUsage.m_data[v68] )
          {
            v70 = array[shapeTagData.m_bodyA.m_serialAndIndex];
            if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 49, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
              __debugbreak();
            if ( (_DWORD)v66 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 50, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
              __debugbreak();
            shapeTagData.m_bodyA.m_serialAndIndex = p_instanceManager->buffer[(unsigned int)v66].bodies.m_data[v70].m_serialAndIndex;
            if ( (shapeTagData.m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
            {
              shapeTagData.m_bodyB.m_serialAndIndex = 0xFFFFFF;
            }
            else
            {
              v71 = array[shapeTagData.m_bodyB.m_serialAndIndex];
              if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 49, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
                __debugbreak();
              if ( (_DWORD)v66 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 50, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
                __debugbreak();
              shapeTagData.m_bodyB.m_serialAndIndex = p_instanceManager->buffer[(unsigned int)v66].bodies.m_data[v71].m_serialAndIndex;
            }
            v72 = havokPhysicsWorld;
            HavokPhysics_GroupRagdollConstraint(havokPhysicsWorld, physicsAsseta, refa, &shapeTagData);
            m_value = HavokPhysics_CreateConstraint(&result, v72, &shapeTagData, v99, v98)->m_value;
            *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v72->world->getConstraint)(&v72->world->hknpWorldReader, m_value) + 64) = (unsigned int)v66 | ((unsigned __int64)v68 << 32);
            HavokPhysicsInstanceManager_AddConstraint(p_instanceManager, v66, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)m_value);
            hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
            if ( shapeTagData.m_constraintData.m_ptr )
              hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
            v15 = v89;
            m_physicsSystemData = v93;
          }
          else
          {
            hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
            if ( shapeTagData.m_constraintData.m_ptr )
              hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
          }
        }
        else
        {
          hkStringPtr::~hkStringPtr(&shapeTagData.m_name);
          if ( shapeTagData.m_constraintData.m_ptr )
            hkReferencedObject::removeReference(shapeTagData.m_constraintData.m_ptr);
        }
        v67 += 40i64;
        ++v68;
      }
      while ( v67 != *(_QWORD *)(m_physicsSystemData + 72) + 40i64 * *(int *)(m_physicsSystemData + 80) );
    }
  }
  v74 = hkMemHeapAllocator();
  v81 = 0;
  if ( v82 >= 0 )
    hkMemoryAllocator::bufFree2(v74, array, 4, v82 & 0x3FFFFFFF);
  return (unsigned int)v66;
}

/*
==============
HavokPhysics_InstantiateAssetBody
==============
*/
__int64 HavokPhysics_InstantiateAssetBody(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, int shapeOverride, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned __int8 v21; 
  hknpShape *MapEntsShape; 
  const hknpShape *v23; 
  Physics_RefSystem RefSystem; 
  unsigned int v25; 
  Physics_InstantiationForceType v26; 
  unsigned int v27; 
  int v28; 
  unsigned int v29; 
  __int64 v31; 
  hknpBodyId bodyId; 
  int v33; 
  int v34; 
  unsigned int instanceIda; 
  hkQuaternionf v36; 
  hkVector4f v37; 
  const PhysicsAsset *v38; 
  __int64 v39; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v40; 

  v39 = -2i64;
  v33 = bodyIdx;
  v38 = physicsAsset;
  instanceIda = instanceId;
  v34 = ref;
  v37.m_quad.m128_u64[0] = (unsigned __int64)position;
  v36.m_vec.m_quad.m128_u64[0] = (unsigned __int64)orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v40);
  v40.m_attachedBody = -1;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10049, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v31) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10050, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v31) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v31) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10051, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset body in world %i", "physicsAsset", v31) )
      __debugbreak();
  }
  if ( bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(v31) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10052, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body in world %i with invalid body index %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", v31, bodyIdx) )
      __debugbreak();
  }
  if ( ((position->m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[2] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10053, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
    __debugbreak();
  if ( ((orientation->m_vec.m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[2] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[3] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10054, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v31) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10058, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v31) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10063, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) && HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10067, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == 0 || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == NULL || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, instanceId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10068, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  HavokPhysicsInstanceManager_SetPhysicsAsset(&MutableWorld->instanceManager, instanceId, physicsAsset);
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  if ( shapeOverride != -1 && m_physicsSystemData->m_bodyCinfos.m_size > 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10074, ASSERT_TYPE_ASSERT, "(shapeOverride == -1 || bodyCInfos->getSize() <= 1)", "%s\n\tHavok Physics: Shape overrides only implemented for single body assets", "shapeOverride == PHYSICSSHAPE_OVERRIDEID_INVALID || bodyCInfos->getSize() <= 1") )
    __debugbreak();
  if ( (filterType == Physics_InstantiationFilterTypeServer || filterType == Physics_InstantiationFilterTypeClientReplication) && HavokPhysicsAsset->m_bodyServerUsage.m_data[v33] > 1u )
  {
    v21 = 0;
    goto LABEL_103;
  }
  if ( shapeOverride != -1 && shapeOverride >= WorldCollision_GetMapEntsShapeCount() )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_144251AB0, 147i64);
  hknpPhysicsSystemData::bodyCinfoWithAttachment::operator=(&v40, &m_physicsSystemData->m_bodyCinfos.m_data[v33]);
  if ( shapeOverride != -1 && WorldCollision_GetMapEntsShape(shapeOverride) )
  {
    MapEntsShape = WorldCollision_GetMapEntsShape(shapeOverride);
    v23 = MapEntsShape;
    if ( MapEntsShape )
      hkReferencedObject::addReference(MapEntsShape);
    if ( v40.m_shape.m_ptr )
      hkReferencedObject::removeReference(&v40.m_shape.m_ptr->hkReferencedObject);
    v40.m_shape.m_ptr = v23;
  }
  if ( Physics_IsQueryWorld(worldId) )
  {
    v40.m_motionId.m_value = 0x7FFFFFFF;
    v40.m_motionType.m_storage = 0;
  }
  v40.m_flags.m_storage |= forQueryOnly << 8;
  RefSystem = Physics_GetRefSystem(v34);
  HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(worldId, MutableWorld, RefSystem, &v40);
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_63;
  v25 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v33];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v25 )
    {
LABEL_63:
      v26 = forceType;
      goto LABEL_64;
    }
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v25 > 1 )
  {
    goto LABEL_63;
  }
  v26 = forceType;
  if ( forceType == Physics_InstantiationForceTypeKeyframed )
    goto LABEL_79;
  if ( forceType != Physics_InstantiationForceTypeKeyframedAtMost )
  {
    if ( forceType == Physics_InstantiationForceTypeStatic )
    {
      v40.m_flags.m_storage &= 0xFFFFFFF8;
      v40.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
      v40.m_motionType.m_storage = 0;
      goto LABEL_67;
    }
    goto LABEL_64;
  }
  if ( v40.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
  {
LABEL_79:
    v40.m_flags.m_storage &= 0xFFFFFFF8;
    v40.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
    v40.m_motionType.m_storage = 1;
    goto LABEL_67;
  }
LABEL_64:
  if ( v40.m_motionType.m_storage >= 2u && v26 != Physics_InstantiationForceTypeStatic )
    v40.m_flags.m_storage |= 0x10u;
LABEL_67:
  v36.m_vec.m_quad = *(__m128 *)v36.m_vec.m_quad.m128_u64[0];
  v37.m_quad = *(__m128 *)v37.m_quad.m128_u64[0];
  bodyId.m_serialAndIndex = HavokPhysics_CreateRigidBody((hknpBodyId *)&v34, worldId, MutableWorld, v38, v33, &v40, v34, &v37, &v36, 0, tryStartDeactivated, 0)->m_serialAndIndex;
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_91;
  v27 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v33];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v27 )
      goto LABEL_89;
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v27 > 1 )
  {
LABEL_89:
    if ( v40.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
    goto LABEL_91;
  }
  switch ( v26 )
  {
    case Physics_InstantiationForceTypeKeyframed:
      goto LABEL_87;
    case Physics_InstantiationForceTypeKeyframedAtMost:
      v28 = *(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68);
      if ( (v28 & 1) != 0 || (v28 & 4) != 0 )
        break;
LABEL_87:
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
      break;
    case Physics_InstantiationForceTypeStatic:
      HavokPhysics_SetRigidBodyStatic(worldId, bodyId);
      break;
  }
  if ( v26 == Physics_InstantiationForceTypeNone )
    goto LABEL_89;
LABEL_91:
  if ( neverDeactivate )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationControl)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
  v29 = instanceIda;
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, instanceIda, bodyId);
  if ( HavokPhysics_HasTriggerEvent(worldId, bodyId) && HavokPhysics_IsRigidBodyStatic(worldId, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10224, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
    __debugbreak();
  if ( add )
  {
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
      __debugbreak();
    ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))MutableWorld->world->addBodies)(&MutableWorld->world->hknpWorldWriter, &bodyId, 1i64);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v29, 1, 0);
  }
  v21 = 1;
LABEL_103:
  if ( v40.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v40.m_localFrame.m_ptr);
  if ( v40.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v40.m_dragProperties.m_ptr);
  if ( v40.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v40.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v40.m_name);
  if ( v40.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v40.m_shape.m_ptr->hkReferencedObject);
  return v21;
}

/*
==============
HavokPhysics_InstantiateAssetBodyCylinder
==============
*/
__int64 HavokPhysics_InstantiateAssetBodyCylinder(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, float height, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned __int8 v22; 
  hknpShape *v23; 
  hknpShape *v24; 
  Physics_RefSystem RefSystem; 
  int v26; 
  unsigned int v27; 
  Physics_InstantiationForceType v28; 
  unsigned int v29; 
  int v30; 
  unsigned int v31; 
  __int64 v33; 
  hknpBodyId v34; 
  BOOL v35; 
  hknpBodyId bodyId; 
  int v37; 
  unsigned int instanceIda[2]; 
  const hkQuaternionf *v39; 
  hkVector4f v40; 
  __int64 v41; 
  hkVector4f center; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v43; 

  v41 = -2i64;
  v37 = bodyIdx;
  instanceIda[1] = instanceId;
  LOBYTE(v35) = tryStartDeactivated;
  instanceIda[0] = ref;
  v40.m_quad.m128_u64[0] = (unsigned __int64)position;
  v39 = orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v43);
  v43.m_attachedBody = -1;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10468, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v33) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10469, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v33) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v33) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10470, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset body cylinder in world %i", "physicsAsset", v33) )
      __debugbreak();
  }
  if ( bodyIdx < 0 || bodyIdx >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(v33) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10471, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder in world %i with invalid body index %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", v33, bodyIdx) )
      __debugbreak();
  }
  v34.m_serialAndIndex = position->m_quad.m128_i32[0];
  if ( (v34.m_serialAndIndex & 0x7F800000) == 2139095040 || (v34.m_serialAndIndex = position->m_quad.m128_u32[1], (v34.m_serialAndIndex & 0x7F800000) == 2139095040) || (v34.m_serialAndIndex = position->m_quad.m128_u32[2], (v34.m_serialAndIndex & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10472, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body cylinder with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
      __debugbreak();
  }
  v34.m_serialAndIndex = orientation->m_vec.m_quad.m128_i32[0];
  if ( (v34.m_serialAndIndex & 0x7F800000) == 2139095040 || (v34.m_serialAndIndex = orientation->m_vec.m_quad.m128_u32[1], (v34.m_serialAndIndex & 0x7F800000) == 2139095040) || (v34.m_serialAndIndex = orientation->m_vec.m_quad.m128_u32[2], (v34.m_serialAndIndex & 0x7F800000) == 2139095040) || (v34.m_serialAndIndex = orientation->m_vec.m_quad.m128_u32[3], (v34.m_serialAndIndex & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10473, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body cylinder with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v33) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10477, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v33) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10482, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) && HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10486, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == 0 || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == NULL || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, instanceId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10487, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  HavokPhysicsInstanceManager_SetPhysicsAsset(&MutableWorld->instanceManager, instanceId, physicsAsset);
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  if ( (filterType == Physics_InstantiationFilterTypeServer || filterType == Physics_InstantiationFilterTypeClientReplication) && HavokPhysicsAsset->m_bodyServerUsage.m_data[v37] > 1u )
  {
    v22 = 0;
    goto LABEL_103;
  }
  if ( radius <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10500, ASSERT_TYPE_ASSERT, "(radius > 0)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid radius", "radius > 0") )
    __debugbreak();
  if ( height <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10501, ASSERT_TYPE_ASSERT, "(height > 0)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body cylinder with invalid height", "height > 0") )
    __debugbreak();
  hknpPhysicsSystemData::bodyCinfoWithAttachment::operator=(&v43, &m_physicsSystemData->m_bodyCinfos.m_data[v37]);
  center.m_quad = 0i64;
  center.m_quad.m128_f32[2] = (float)(height * 0.5) + 0.0;
  v23 = HavokPhysics_CreateShapeCylinder(&center, height * 0.5, radius, 32, 0);
  v24 = v23;
  if ( v23 )
  {
    hkReferencedObject::addReference(v23);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10509, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
  {
    __debugbreak();
  }
  if ( v43.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v43.m_shape.m_ptr->hkReferencedObject);
  v43.m_shape.m_ptr = v24;
  if ( Physics_IsQueryWorld(worldId) )
  {
    v43.m_motionId.m_value = 0x7FFFFFFF;
    v43.m_motionType.m_storage = 0;
  }
  v43.m_flags.m_storage |= forQueryOnly << 8;
  RefSystem = Physics_GetRefSystem(instanceIda[0]);
  HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(worldId, MutableWorld, RefSystem, &v43);
  if ( Physics_IsQueryWorld(worldId) )
  {
    v26 = v37;
    goto LABEL_70;
  }
  v26 = v37;
  v27 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v37];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( !v27 )
      goto LABEL_63;
LABEL_70:
    v28 = forceType;
    goto LABEL_71;
  }
  if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v27 > 1 )
    goto LABEL_70;
LABEL_63:
  v28 = forceType;
  if ( forceType == Physics_InstantiationForceTypeKeyframed )
    goto LABEL_68;
  if ( forceType != Physics_InstantiationForceTypeKeyframedAtMost )
  {
    if ( forceType == Physics_InstantiationForceTypeStatic )
    {
      v43.m_flags.m_storage &= 0xFFFFFFF8;
      v43.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
      v43.m_motionType.m_storage = 0;
      goto LABEL_74;
    }
    goto LABEL_71;
  }
  if ( v43.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
  {
LABEL_68:
    v43.m_flags.m_storage &= 0xFFFFFFF8;
    v43.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
    v43.m_motionType.m_storage = 1;
    goto LABEL_74;
  }
LABEL_71:
  if ( v43.m_motionType.m_storage >= 2u && v28 != Physics_InstantiationForceTypeStatic )
    v43.m_flags.m_storage |= 0x10u;
LABEL_74:
  center.m_quad = v39->m_vec.m_quad;
  v40.m_quad = *(__m128 *)v40.m_quad.m128_u64[0];
  bodyId.m_serialAndIndex = HavokPhysics_CreateRigidBody(&v34, worldId, MutableWorld, physicsAsset, v26, &v43, instanceIda[0], &v40, (hkQuaternionf *)&center, 0, v35, 0)->m_serialAndIndex;
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_91;
  v29 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v37];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v29 )
      goto LABEL_89;
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v29 > 1 )
  {
LABEL_89:
    if ( v43.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
    goto LABEL_91;
  }
  switch ( forceType )
  {
    case Physics_InstantiationForceTypeKeyframed:
      goto LABEL_87;
    case Physics_InstantiationForceTypeKeyframedAtMost:
      v30 = *(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68);
      if ( (v30 & 1) != 0 || (v30 & 4) != 0 )
        break;
LABEL_87:
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
      break;
    case Physics_InstantiationForceTypeStatic:
      HavokPhysics_SetRigidBodyStatic(worldId, bodyId);
      break;
  }
  if ( forceType == Physics_InstantiationForceTypeNone )
    goto LABEL_89;
LABEL_91:
  if ( neverDeactivate )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationControl)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
  v31 = instanceIda[1];
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, instanceIda[1], bodyId);
  if ( HavokPhysics_HasTriggerEvent(worldId, bodyId) && HavokPhysics_IsRigidBodyStatic(worldId, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10641, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
    __debugbreak();
  if ( add )
  {
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
      __debugbreak();
    ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))MutableWorld->world->addBodies)(&MutableWorld->world->hknpWorldWriter, &bodyId, 1i64);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v31, 1, 0);
  }
  hkReferencedObject::removeReference(v24);
  v22 = 1;
LABEL_103:
  if ( v43.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v43.m_localFrame.m_ptr);
  if ( v43.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v43.m_dragProperties.m_ptr);
  if ( v43.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v43.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v43.m_name);
  if ( v43.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v43.m_shape.m_ptr->hkReferencedObject);
  return v22;
}

/*
==============
HavokPhysics_InstantiateAssetBodySphere
==============
*/
__int64 HavokPhysics_InstantiateAssetBodySphere(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int bodyIdx, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool neverDeactivate, float radius, Physics_InstantiationForceType forceType, Physics_InstantiationFilterType filterType, bool forQueryOnly)
{
  __int64 v14; 
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData *m_physicsSystemData; 
  unsigned __int8 v21; 
  hknpSphereShape *v22; 
  hknpShape *v23; 
  hknpShape *v24; 
  Physics_RefSystem RefSystem; 
  unsigned int v26; 
  Physics_InstantiationForceType v27; 
  unsigned int v28; 
  int v29; 
  unsigned int v30; 
  __int64 v32; 
  int shapeSizeOut; 
  bool v34; 
  hknpBodyId bodyId; 
  int v36; 
  hknpBodyId v37; 
  unsigned int instanceIda; 
  const hkQuaternionf *v39; 
  const hkVector4f *v40; 
  hkVector4f v41; 
  hkQuaternionf v42; 
  __int64 v43; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v44; 
  hkVector4f center; 

  v43 = -2i64;
  v14 = bodyIdx;
  v37.m_serialAndIndex = bodyIdx;
  instanceIda = instanceId;
  v34 = tryStartDeactivated;
  v36 = ref;
  v40 = position;
  v39 = orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v44);
  v44.m_attachedBody = -1;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10260, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10261, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v32) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10262, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset body sphere in world %i", "physicsAsset", v32) )
      __debugbreak();
  }
  if ( (int)v14 < 0 || (int)v14 >= Physics_GetPhysicsAssetBodyCount(physicsAsset) )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10263, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere in world %i with invalid body index %i", "bodyIdx >= 0 && bodyIdx < Physics_GetPhysicsAssetBodyCount( physicsAsset )", v32, v14) )
      __debugbreak();
  }
  shapeSizeOut = position->m_quad.m128_i32[0];
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 || (shapeSizeOut = position->m_quad.m128_i32[1], (shapeSizeOut & 0x7F800000) == 2139095040) || (shapeSizeOut = position->m_quad.m128_i32[2], (shapeSizeOut & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10264, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body sphere with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
      __debugbreak();
  }
  shapeSizeOut = orientation->m_vec.m_quad.m128_i32[0];
  if ( (shapeSizeOut & 0x7F800000) == 2139095040 || (shapeSizeOut = orientation->m_vec.m_quad.m128_i32[1], (shapeSizeOut & 0x7F800000) == 2139095040) || (shapeSizeOut = orientation->m_vec.m_quad.m128_i32[2], (shapeSizeOut & 0x7F800000) == 2139095040) || (shapeSizeOut = orientation->m_vec.m_quad.m128_i32[3], (shapeSizeOut & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10265, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset body sphere with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v32) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10269, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v32) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10274, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAsset %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) && HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, instanceId) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10278, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == 0 || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == NULL || HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, instanceId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10279, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  HavokPhysicsInstanceManager_SetPhysicsAsset(&MutableWorld->instanceManager, instanceId, physicsAsset);
  m_physicsSystemData = HavokPhysicsAsset->m_physicsSystemData;
  if ( (filterType == Physics_InstantiationFilterTypeServer || filterType == Physics_InstantiationFilterTypeClientReplication) && HavokPhysicsAsset->m_bodyServerUsage.m_data[v14] > 1u )
  {
    v21 = 0;
    goto LABEL_97;
  }
  if ( radius <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10292, ASSERT_TYPE_ASSERT, "(radius > 0)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset body sphere with invalid radius", "radius > 0") )
    __debugbreak();
  hknpPhysicsSystemData::bodyCinfoWithAttachment::operator=(&v44, &m_physicsSystemData->m_bodyCinfos.m_data[v14]);
  center.m_quad = 0i64;
  v22 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
  v41.m_quad.m128_u64[0] = (unsigned __int64)v22;
  v42.m_vec.m_quad.m128_u64[0] = (unsigned __int64)v22;
  if ( v22 )
  {
    hknpSphereShape::hknpSphereShape(v22, &center, radius);
    v24 = v23;
  }
  else
  {
    v24 = NULL;
  }
  v24->m_memSizeAndFlags = shapeSizeOut;
  hkReferencedObject::addReference(v24);
  if ( v44.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v44.m_shape.m_ptr->hkReferencedObject);
  v44.m_shape.m_ptr = v24;
  if ( Physics_IsQueryWorld(worldId) )
  {
    v44.m_motionId.m_value = 0x7FFFFFFF;
    v44.m_motionType.m_storage = 0;
  }
  v44.m_flags.m_storage |= forQueryOnly << 8;
  RefSystem = Physics_GetRefSystem(v36);
  HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(worldId, MutableWorld, RefSystem, &v44);
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_57;
  v26 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v14];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v26 )
    {
LABEL_57:
      v27 = forceType;
      goto LABEL_58;
    }
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v26 > 1 )
  {
    goto LABEL_57;
  }
  v27 = forceType;
  if ( forceType == Physics_InstantiationForceTypeKeyframed )
    goto LABEL_73;
  if ( forceType != Physics_InstantiationForceTypeKeyframedAtMost )
  {
    if ( forceType == Physics_InstantiationForceTypeStatic )
    {
      v44.m_flags.m_storage &= 0xFFFFFFF8;
      v44.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
      v44.m_motionType.m_storage = 0;
      goto LABEL_61;
    }
    goto LABEL_58;
  }
  if ( v44.m_qualityId.m_value != s_staticBodyQualityIdx + 16 )
  {
LABEL_73:
    v44.m_flags.m_storage &= 0xFFFFFFF8;
    v44.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
    v44.m_motionType.m_storage = 1;
    goto LABEL_61;
  }
LABEL_58:
  if ( v44.m_motionType.m_storage >= 2u && v27 != Physics_InstantiationForceTypeStatic )
    v44.m_flags.m_storage |= 0x10u;
LABEL_61:
  v42.m_vec.m_quad = v39->m_vec.m_quad;
  v41.m_quad = v40->m_quad;
  bodyId.m_serialAndIndex = HavokPhysics_CreateRigidBody(&v37, worldId, MutableWorld, physicsAsset, v37.m_serialAndIndex, &v44, v36, &v41, &v42, 0, v34, 0)->m_serialAndIndex;
  if ( Physics_IsQueryWorld(worldId) )
    goto LABEL_85;
  v28 = HavokPhysicsAsset->m_bodyServerUsage.m_data[v14];
  if ( filterType == Physics_InstantiationFilterTypeServer )
  {
    if ( v28 )
      goto LABEL_83;
  }
  else if ( (filterType == Physics_InstantiationFilterTypeClientReplication || filterType == Physics_InstantiationFilterTypeClientSimulation) && v28 > 1 )
  {
LABEL_83:
    if ( v44.m_motionPropertiesId.m_value == s_keyframedMotionPropertiesIdx + 5 )
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
    goto LABEL_85;
  }
  switch ( forceType )
  {
    case Physics_InstantiationForceTypeKeyframed:
      goto LABEL_81;
    case Physics_InstantiationForceTypeKeyframedAtMost:
      v29 = *(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68);
      if ( (v29 & 1) != 0 || (v29 & 4) != 0 )
        break;
LABEL_81:
      HavokPhysics_SetRigidBodyKeyframed(worldId, bodyId);
      break;
    case Physics_InstantiationForceTypeStatic:
      HavokPhysics_SetRigidBodyStatic(worldId, bodyId);
      break;
  }
  if ( forceType == Physics_InstantiationForceTypeNone )
    goto LABEL_83;
LABEL_85:
  if ( neverDeactivate )
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyActivationControl)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
  v30 = instanceIda;
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, instanceIda, bodyId);
  if ( HavokPhysics_HasTriggerEvent(worldId, bodyId) && HavokPhysics_IsRigidBodyStatic(worldId, bodyId) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10431, ASSERT_TYPE_ASSERT, "(!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId )))", (const char *)&queryFormat, "!(HavokPhysics_HasTriggerEvent( worldId, bodyId ) && HavokPhysics_IsRigidBodyStatic( worldId, bodyId ))") )
    __debugbreak();
  if ( add )
  {
    if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
      __debugbreak();
    ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))MutableWorld->world->addBodies)(&MutableWorld->world->hknpWorldWriter, &bodyId, 1i64);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v30, 1, 0);
  }
  hkReferencedObject::removeReference(v24);
  v21 = 1;
LABEL_97:
  if ( v44.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v44.m_localFrame.m_ptr);
  if ( v44.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v44.m_dragProperties.m_ptr);
  if ( v44.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v44.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v44.m_name);
  if ( v44.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v44.m_shape.m_ptr->hkReferencedObject);
  return v21;
}

/*
==============
HavokPhysics_InstantiateAssetConstraint
==============
*/
char HavokPhysics_InstantiateAssetConstraint(unsigned int instanceId, Physics_WorldId worldId, const PhysicsAsset *physicsAsset, int constraintIdx, int instanceRef, bool deepCloneConstraintData)
{
  __int64 v6; 
  __int64 v9; 
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v12; 
  hkpConstraintData *v13; 
  hkpConstraintData *v14; 
  unsigned int m_value; 
  __int64 v17; 
  hknpBodyId result; 
  hknpConstraintCinfo cInfo; 
  __int64 v20; 
  hkVector4f position; 
  hkQuaternionf orientation; 

  v20 = -2i64;
  v6 = constraintIdx;
  v9 = instanceId;
  cInfo.m_constraintData.m_ptr = NULL;
  cInfo.m_bodyA.m_serialAndIndex = 0xFFFFFF;
  cInfo.m_bodyB.m_serialAndIndex = 0xFFFFFF;
  cInfo.m_flags.m_storage = 0;
  cInfo.m_name.m_stringAndFlag = NULL;
  cInfo.m_desiredConstraintId.m_value = 0x7FFFFFFF;
  cInfo.m_constraintGroupId.m_value = 0x7FFFFFFF;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10679, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset constraint with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v17) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10680, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v17) )
      __debugbreak();
  }
  if ( !physicsAsset )
  {
    LODWORD(v17) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10681, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavok Physics: Trying to Instantiate NULL Physics Asset constraint in world %i", "physicsAsset", v17) )
      __debugbreak();
  }
  if ( (int)v6 < 0 || (int)v6 >= Physics_GetPhysicsAssetConstraintCount(physicsAsset) )
  {
    LODWORD(v17) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10682, ASSERT_TYPE_ASSERT, "(constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetConstraintCount( physicsAsset ))", "%s\n\tHavok Physics: Trying to Instantiate Physics Asset constraint in world %i with invalid constraint index %i", "constraintIdx >= 0 && constraintIdx < Physics_GetPhysicsAssetConstraintCount( physicsAsset )", v17, v6) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v17) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10686, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAssetConstraint %i: world is NULL", "havokPhysicsWorld->world", v17) )
      __debugbreak();
  }
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10691, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics InstantiateAssetConstraint %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAsset(&MutableWorld->instanceManager, v9) != physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10695, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAsset( &havokPhysicsWorld->instanceManager, instanceId ) == physicsAsset") )
    __debugbreak();
  if ( HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(&MutableWorld->instanceManager, v9) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10696, ASSERT_TYPE_ASSERT, "(HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == 0)", (const char *)&queryFormat, "HavokPhysicsInstanceManager_GetPhysicsAssetAddendum( &havokPhysicsWorld->instanceManager, instanceId ) == NULL") )
    __debugbreak();
  v12 = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_data[v6];
  if ( *(_QWORD *)v12 )
    hkReferencedObject::addReference(*(hkReferencedObject **)v12);
  cInfo.m_constraintData.m_ptr = *(hkpConstraintData **)v12;
  cInfo.m_bodyA.m_serialAndIndex = *(_DWORD *)(v12 + 8);
  cInfo.m_bodyB.m_serialAndIndex = *(_DWORD *)(v12 + 12);
  cInfo.m_flags.m_storage = *(_WORD *)(v12 + 16);
  hkStringPtr::operator=(&cInfo.m_name, (const hkStringPtr *)(v12 + 24));
  cInfo.m_desiredConstraintId.m_value = *(_DWORD *)(v12 + 32);
  cInfo.m_constraintGroupId.m_value = *(_DWORD *)(v12 + 36);
  if ( (cInfo.m_bodyA.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10706, ASSERT_TYPE_ASSERT, "(cInfo.m_bodyA.isValid())", "%s\n\tHavokPhysics InstantiateAsset %s: constraint bodyA is invalid - implies we are trying to use the world as a child", "cInfo.m_bodyA.isValid()", physicsAsset->name) )
    __debugbreak();
  HavokPhysics_GroupRagdollConstraint(MutableWorld, physicsAsset, instanceRef, &cInfo);
  cInfo.m_bodyA = (hknpBodyId)HavokPhysicsInstanceManager_GetBodyId(&result, &MutableWorld->instanceManager, v9, cInfo.m_bodyA.m_serialAndIndex)->m_serialAndIndex;
  if ( (cInfo.m_bodyB.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    cInfo.m_bodyB.m_serialAndIndex = 0xFFFFFF;
  else
    cInfo.m_bodyB = (hknpBodyId)HavokPhysicsInstanceManager_GetBodyId(&result, &MutableWorld->instanceManager, v9, cInfo.m_bodyB.m_serialAndIndex)->m_serialAndIndex;
  if ( deepCloneConstraintData )
  {
    v13 = hkpConstraintDataUtils::cloneIfCanHaveMotors(cInfo.m_constraintData.m_ptr);
    v14 = v13;
    if ( v13 )
      hkReferencedObject::addReference(v13);
    if ( cInfo.m_constraintData.m_ptr )
      hkReferencedObject::removeReference(cInfo.m_constraintData.m_ptr);
    cInfo.m_constraintData.m_ptr = v14;
    if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10727, ASSERT_TYPE_ASSERT, "(cInfo.m_constraintData.val())", "%s\n\tTrying to clone a non-motorized constraint - this could be caused by unexpected data, or by code", "cInfo.m_constraintData.val()") )
      __debugbreak();
    hkReferencedObject::removeReference(cInfo.m_constraintData.m_ptr);
  }
  position.m_quad = 0i64;
  orientation.m_vec.m_quad = g_vectorfConstants[35];
  m_value = HavokPhysics_CreateConstraint((hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> *)&result, MutableWorld, &cInfo, &position, &orientation)->m_value;
  *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, m_value) + 64) = v9 | (v6 << 32);
  HavokPhysicsInstanceManager_AddConstraint(&MutableWorld->instanceManager, v9, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)m_value);
  hkStringPtr::~hkStringPtr(&cInfo.m_name);
  if ( cInfo.m_constraintData.m_ptr )
    hkReferencedObject::removeReference(cInfo.m_constraintData.m_ptr);
  return 1;
}

/*
==============
HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId
==============
*/
void HavokPhysics_InstantiateAsset_OverrideMotionPropertiesId(const Physics_WorldId worldId, const HavokPhysicsWorld *havokPhysicsWorld, const Physics_RefSystem refSystem, hknpPhysicsSystemData::bodyCinfoWithAttachment *bodyCInfo)
{
  __int64 v4; 
  Physics_GravityType v7; 
  unsigned int v8; 
  unsigned int MotionPropertiesListIndexFromMotionPropertiesId; 
  __int64 v10; 
  hknpMotionPropertiesId result; 

  v4 = refSystem;
  if ( !havokPhysicsWorld && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9376, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld)", (const char *)&queryFormat, "havokPhysicsWorld") )
    __debugbreak();
  v7 = s_physicsGravityTypes[v4];
  if ( (unsigned int)v7 <= Physics_GravityType_Item )
  {
    v8 = v7 + 1;
    if ( havokPhysicsWorld->world->getMotionPropertiesLibrary(&havokPhysicsWorld->world->hknpWorldReader)->m_motionProperties.m_objects.m_data[bodyCInfo->m_motionPropertiesId.m_value].m_pod.m_gravityFactor != 0.0 )
    {
      MotionPropertiesListIndexFromMotionPropertiesId = HavokPhysics_GetMotionPropertiesListIndexFromMotionPropertiesId(bodyCInfo->m_motionPropertiesId);
      if ( MotionPropertiesListIndexFromMotionPropertiesId >= s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size )
      {
        LODWORD(v10) = MotionPropertiesListIndexFromMotionPropertiesId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9386, ASSERT_TYPE_ASSERT, "(unsigned)( motionIndex ) < (unsigned)( s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize() )", "motionIndex doesn't index s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.getSize()\n\t%i not in [0, %i)", v10, s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size) )
          __debugbreak();
      }
      bodyCInfo->m_motionPropertiesId = (hknpMotionPropertiesId)HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, v8, MotionPropertiesListIndexFromMotionPropertiesId)->m_value;
    }
  }
}

/*
==============
HavokPhysics_InstantiateDetailModel
==============
*/
__int64 HavokPhysics_InstantiateDetailModel(Physics_WorldId worldId, const XModel *detailModel, int ref, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly, bool allowSingleBodyAddToWorld)
{
  const hkQuaternionf *v12; 
  HavokPhysicsWorld *MutableWorld; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  unsigned int Instance; 
  __int64 m_size; 
  int v17; 
  __int64 v18; 
  const char *v19; 
  scr_string_t String; 
  unsigned int v21; 
  __int64 v22; 
  DObjAnimMat *baseMat; 
  const hknpShape *v24; 
  int v25; 
  __m128 m_quad; 
  hknpBodyId *v35; 
  float v36; 
  hknpSphereShape *ConvexShape; 
  hknpShape *v40; 
  hknpShape *v41; 
  hknpBodyId *p_bodyId; 
  float m_convexRadius; 
  __int64 v45; 
  hknpBodyId v46; 
  char v47; 
  unsigned __int8 index[3]; 
  int v49; 
  unsigned int instanceId; 
  int v51; 
  hknpBodyId bodyId; 
  const hkQuaternionf *v53; 
  int v54; 
  const HavokPhysicsXModelLOD *v55; 
  const hkVector4f *v56; 
  __int64 v57; 
  hkVector4f v58; 
  hkVector4f v59; 
  hknpBodyId v60; 
  hknpBodyId v61; 
  __int64 v62; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v63; 
  hkVector4f center; 
  char dest[256]; 

  v62 = -2i64;
  v56 = position;
  v49 = ref;
  v12 = orientation;
  v53 = orientation;
  hknpBodyCinfo::hknpBodyCinfo(&v63);
  v63.m_attachedBody = -1;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9827, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Detail Model with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !detailModel )
  {
    LODWORD(v45) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9828, ASSERT_TYPE_ASSERT, "(detailModel)", "%s\n\tHavok Physics: Trying to Instantiate NULL Detail Model in world %i", "detailModel", v45) )
      __debugbreak();
  }
  if ( !detailModel->detailCollision && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9829, ASSERT_TYPE_ASSERT, "(detailModel->detailCollision)", "%s\n\tHavok Physics: Trying to Instantiate Detail Model %s with no detail physics data in world %i", "detailModel->detailCollision", detailModel->name, worldId) )
    __debugbreak();
  v46.m_serialAndIndex = position->m_quad.m128_i32[0];
  if ( (v46.m_serialAndIndex & 0x7F800000) == 2139095040 || (v46.m_serialAndIndex = position->m_quad.m128_u32[1], (v46.m_serialAndIndex & 0x7F800000) == 2139095040) || (v46.m_serialAndIndex = position->m_quad.m128_u32[2], (v46.m_serialAndIndex & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9830, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
      __debugbreak();
  }
  v46.m_serialAndIndex = orientation->m_vec.m_quad.m128_i32[0];
  if ( (v46.m_serialAndIndex & 0x7F800000) == 2139095040 || (v46.m_serialAndIndex = orientation->m_vec.m_quad.m128_u32[1], (v46.m_serialAndIndex & 0x7F800000) == 2139095040) || (v46.m_serialAndIndex = orientation->m_vec.m_quad.m128_u32[2], (v46.m_serialAndIndex & 0x7F800000) == 2139095040) || (v46.m_serialAndIndex = orientation->m_vec.m_quad.m128_u32[3], (v46.m_serialAndIndex & 0x7F800000) == 2139095040) )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9831, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate PhysicsAsset with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
      __debugbreak();
  }
  if ( !Physics_IsDetailWorld(worldId) && add )
  {
    LODWORD(v45) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9833, ASSERT_TYPE_ASSERT, "(Physics_IsDetailWorld( worldId ) || !add)", "%s\n\tHavok Physics: Trying to Instantiate Detail Model in non detail world %i", "Physics_IsDetailWorld( worldId ) || !add", v45) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v45) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9837, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateAsset %i: world is NULL", "havokPhysicsWorld->world", v45) )
      __debugbreak();
  }
  HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailModel->detailCollision);
  v55 = HavokPhysicsXModelLODFromDetailCol;
  if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9842, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", "%s\n\tHavokPhysics InstantiateDetailModel %s: couldn't find havok XModel LOD", "havokPhysicsXModelLOD", detailModel->name) )
    __debugbreak();
  if ( HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9843, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD->m_shapes.getSize() > 0)", "%s\n\tHavokPhysics InstantiateDetailModel %s: no shapes in the collLod - is this model soft skinned or otherwise missing rigid geo?", "havokPhysicsXModelLOD->m_shapes.getSize() > 0", detailModel->name) )
    __debugbreak();
  Instance = HavokPhysicsInstanceManager_AllocateInstance(&MutableWorld->instanceManager);
  instanceId = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9848, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics InstantiateDetailModel %s: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID", detailModel->name) )
    __debugbreak();
  HavokPhysicsInstanceManager_SetDetailModel(&MutableWorld->instanceManager, Instance, detailModel);
  v63.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
  v63.m_collisionFilterInfo = 1;
  m_size = HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size;
  if ( (_DWORD)m_size != 1 || (v47 = 1, !allowSingleBodyAddToWorld) )
    v47 = 0;
  v17 = 0;
  v51 = 0;
  v57 = m_size;
  if ( m_size <= 0 )
  {
LABEL_63:
    center.m_quad = 0i64;
    v36 = detailModel->radius * 0.03125;
    _XMM0 = LODWORD(MutableWorld->m_detailBoundingSphereMax);
    __asm { vmaxss  xmm1, xmm0, xmm6 }
    MutableWorld->m_detailBoundingSphereMax = *(float *)&_XMM1;
    ConvexShape = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, (int *)&instanceId);
    v57 = (__int64)ConvexShape;
    v53 = (const hkQuaternionf *)ConvexShape;
    if ( ConvexShape )
    {
      hknpSphereShape::hknpSphereShape(ConvexShape, &center, v36);
      v41 = v40;
    }
    else
    {
      v41 = NULL;
    }
    v41->m_memSizeAndFlags = instanceId;
    m_convexRadius = v41->m_convexRadius;
    if ( m_convexRadius != v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15559, ASSERT_TYPE_ASSERT, "( sphereShape->m_convexRadius ) == ( radius )", "%s == %s\n\t%g, %g", "sphereShape->m_convexRadius", "radius", m_convexRadius, v36) )
      __debugbreak();
    hkReferencedObject::addReference(v41);
    if ( v63.m_shape.m_ptr )
      hkReferencedObject::removeReference(&v63.m_shape.m_ptr->hkReferencedObject);
    v63.m_shape.m_ptr = v41;
    v63.m_flags.m_storage = forQueryOnly << 8;
    hkStringPtr::operator=(&v63.m_name, detailModel->name);
    v63.m_position = 0i64;
    v63.m_orientation.m_vec.m_quad = g_vectorfConstants[35];
    v63.m_motionType.m_storage = 0;
    v59.m_quad = v12->m_vec.m_quad;
    v58.m_quad = v56->m_quad;
    HavokPhysics_CreateRigidBody(&bodyId, worldId, MutableWorld, NULL, v17, &v63, v49 | 0x40000000, &v58, (hkQuaternionf *)&v59, 0, tryStartDeactivated, 0);
    HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, Instance, bodyId);
    hkReferencedObject::removeReference(&v63.m_shape.m_ptr->hkReferencedObject);
    if ( add )
    {
      if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
        __debugbreak();
      p_bodyId = &bodyId;
LABEL_81:
      ((void (__fastcall *)(hknpWorldWriter *, hknpBodyId *, __int64))MutableWorld->world->addBodies)(&MutableWorld->world->hknpWorldWriter, p_bodyId, 1i64);
      HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, Instance, 0, 1);
    }
  }
  else
  {
    v18 = 0i64;
    v54 = forQueryOnly << 8;
    while ( 1 )
    {
      v19 = (const char *)((unsigned __int64)HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_data[v18].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64);
      if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9787, ASSERT_TYPE_ASSERT, "(boneName)", (const char *)&queryFormat, "boneName") )
        __debugbreak();
      Core_strcpy(dest, 0x100ui64, v19);
      I_strlwr(dest);
      String = SL_FindString(dest);
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9797, ASSERT_TYPE_ASSERT, "(scrName != ( static_cast< scr_string_t >( 0 ) ))", "%s\n\tCouldn't find script string for bone %s in model %s", "scrName != NULL_SCR_STRING", v19, detailModel->name) )
        __debugbreak();
      index[0] = 0;
      if ( XModelGetBoneIndex(detailModel, String, 0, index) )
      {
        v21 = index[0];
      }
      else
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9801, ASSERT_TYPE_ASSERT, "(success)", "%s\n\tCouldn't find bone %s in detail model %s.  Any chance this is a client bone?", "success", v19, detailModel->name) )
          __debugbreak();
        v21 = 255;
      }
      v22 = v21;
      baseMat = detailModel->baseMat;
      v24 = v55->m_shapes.m_data[v18];
      if ( v24 )
        hkReferencedObject::addReference(v55->m_shapes.m_data[v18]);
      if ( v63.m_shape.m_ptr )
        hkReferencedObject::removeReference(&v63.m_shape.m_ptr->hkReferencedObject);
      v63.m_shape.m_ptr = v24;
      v63.m_flags.m_storage = v54;
      v25 = v51;
      hkStringPtr::operator=(&v63.m_name, &v55->m_bodyNames.m_data[v51]);
      _XMM1 = 0i64;
      __asm
      {
        vinsertps xmm1, xmm1, xmm2, 0
        vinsertps xmm1, xmm1, xmm3, 10h
        vinsertps xmm1, xmm1, xmm4, 20h ; ' '
      }
      v63.m_position = (hkVector4f)_XMM1.m_quad;
      _XMM1 = LODWORD(baseMat[v22].quat.v[0]);
      __asm
      {
        vinsertps xmm1, xmm1, dword ptr [rbx+r14+4], 10h
        vinsertps xmm1, xmm1, dword ptr [rbx+r14+8], 20h ; ' '
        vinsertps xmm1, xmm1, dword ptr [rbx+r14+0Ch], 30h ; '0'
      }
      v63.m_orientation = (hkQuaternionf)_XMM1.m_vec.m_quad;
      v63.m_motionType.m_storage = 0;
      m_quad = v56->m_quad;
      if ( v47 )
      {
        v58.m_quad = v53->m_vec.m_quad;
        v59.m_quad = m_quad;
        v35 = HavokPhysics_CreateRigidBody(&v60, worldId, MutableWorld, NULL, v25, &v63, v49, &v59, (hkQuaternionf *)&v58, 0, tryStartDeactivated, 0);
      }
      else
      {
        v59.m_quad = v53->m_vec.m_quad;
        v58.m_quad = m_quad;
        v35 = HavokPhysics_CreateRigidBody(&v61, worldId, MutableWorld, NULL, v25, &v63, v49, &v58, (hkQuaternionf *)&v59, 0, tryStartDeactivated, 0);
      }
      v46.m_serialAndIndex = v35->m_serialAndIndex;
      Instance = instanceId;
      HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, instanceId, v46);
      if ( v47 )
        break;
      v17 = v25 + 1;
      v51 = v17;
      ++v18;
      HavokPhysicsXModelLODFromDetailCol = v55;
      if ( v18 >= v57 )
      {
        v12 = v53;
        goto LABEL_63;
      }
    }
    if ( add )
    {
      if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8915, ASSERT_TYPE_ASSERT, "(world->world)", (const char *)&queryFormat, "world->world") )
        __debugbreak();
      p_bodyId = &v46;
      goto LABEL_81;
    }
  }
  if ( v63.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v63.m_localFrame.m_ptr);
  if ( v63.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v63.m_dragProperties.m_ptr);
  if ( v63.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v63.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v63.m_name);
  if ( v63.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v63.m_shape.m_ptr->hkReferencedObject);
  return Instance;
}

/*
==============
HavokPhysics_InstantiateHingeConstraint
==============
*/
char HavokPhysics_InstantiateHingeConstraint(Physics_WorldId worldId, unsigned int instanceId, unsigned int bodyIndex, hkVector4f *pos, hkVector4f *dir, float friction, float minAngle, float maxAngle, float breakingThreshold, unsigned int *outConstraintId)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int m_serialAndIndex; 
  const hkTransformf *v16; 
  hkMemoryRouter *Value; 
  hkpLimitedHingeConstraintData *v18; 
  hkReferencedObject *v19; 
  __int64 v20; 
  __int64 v21; 
  float v22; 
  hkMemoryRouter *v23; 
  hknpBreakableConstraintData *v24; 
  __int64 v25; 
  unsigned int m_value; 
  __int64 v28; 
  hkReferencedObject *v29; 
  unsigned int v30; 
  int v31; 
  __int16 v32; 
  hkStringPtr v33; 
  int v34; 
  int v35; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId; 
  hknpBodyId result; 

  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10752, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Instantiate Hinge constraint with invalid instance id for world %i", "instanceId != PHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v28) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10753, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Hinge constraint with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v28) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v28) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10757, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics InstantiateHingeConstraint %i: world is NULL", "havokPhysicsWorld->world", v28) )
      __debugbreak();
  }
  HavokPhysics_GetRigidBodyID(&result, worldId, instanceId, bodyIndex);
  m_serialAndIndex = result.m_serialAndIndex;
  if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10761, ASSERT_TYPE_ASSERT, "(childBodyId.isValid())", (const char *)&queryFormat, "childBodyId.isValid()") )
    __debugbreak();
  v16 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, m_serialAndIndex);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v18 = (hkpLimitedHingeConstraintData *)Value->m_heap->blockAlloc(Value->m_heap, 320i64);
  v19 = NULL;
  if ( v18 )
  {
    hkpLimitedHingeConstraintData::hkpLimitedHingeConstraintData(v18);
    v21 = v20;
  }
  else
  {
    v21 = 0i64;
  }
  if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10765, ASSERT_TYPE_ASSERT, "(ctDataHinge)", (const char *)&queryFormat, "ctDataHinge") )
    __debugbreak();
  *(float *)(v21 + 248) = minAngle;
  *(float *)(v21 + 252) = maxAngle;
  hkpLimitedHingeConstraintData::setInWorldSpace((hkpLimitedHingeConstraintData *)v21, v16, (const hkTransformf *)&g_vectorfConstants[32], pos, dir);
  *(float *)(v21 + 232) = friction;
  v22 = breakingThreshold;
  if ( breakingThreshold >= 0.0 && breakingThreshold < 3.4028235e38 )
  {
    v23 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v23 )
      v23 = hkMemoryRouter::s_fallbackRouter;
    v24 = (hknpBreakableConstraintData *)v23->m_heap->blockAlloc(v23->m_heap, 48i64);
    if ( v24 )
    {
      hknpBreakableConstraintData::hknpBreakableConstraintData(v24, (hkpConstraintData *)v21);
      v21 = v25;
    }
    else
    {
      v21 = 0i64;
    }
    if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10775, ASSERT_TYPE_ASSERT, "(ctDataBreakableHinge)", (const char *)&queryFormat, "ctDataBreakableHinge") )
      __debugbreak();
    hknpBreakableConstraintData::setBreakingThreshold((hknpBreakableConstraintData *)v21, v22);
  }
  v32 = 0;
  v33.m_stringAndFlag = NULL;
  v34 = 0x7FFFFFFF;
  v35 = 0x7FFFFFFF;
  if ( v21 )
    v19 = (hkReferencedObject *)v21;
  v29 = v19;
  v30 = m_serialAndIndex;
  v31 = 0xFFFFFF;
  hkStringPtr::operator=(&v33, "Code Created Hinge");
  MutableWorld->world->allocateConstraint(&MutableWorld->world->hknpWorldWriter, &constraintId, (const hknpConstraintCinfo *)&v29);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->addConstraint)(&MutableWorld->world->hknpWorldWriter, constraintId.m_value, 1i64);
  m_value = constraintId.m_value;
  if ( outConstraintId )
    *outConstraintId = constraintId.m_value;
  HavokPhysicsInstanceManager_AddConstraint(&MutableWorld->instanceManager, instanceId, (hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant>)m_value);
  hkStringPtr::~hkStringPtr(&v33);
  if ( v29 )
    hkReferencedObject::removeReference(v29);
  return 1;
}

/*
==============
HavokPhysics_InstantiateKeyframedBody
==============
*/
__int64 HavokPhysics_InstantiateKeyframedBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  __int64 v14; 
  const char *v15; 
  HavokPhysicsWorld *MutableWorld; 
  unsigned int v17; 
  int v18; 
  int v19; 
  int m_size; 
  unsigned int Instance; 
  __int64 v22; 
  hknpBodyId *v23; 
  __int64 v25; 
  hknpBodyId v26; 
  char *string[2]; 
  hkVector4f v28; 
  __int64 v29; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v30; 

  v29 = -2i64;
  string[0] = (char *)name;
  v26.m_serialAndIndex = ref;
  v28.m_quad.m128_u64[0] = (unsigned __int64)position;
  hknpBodyCinfo::hknpBodyCinfo(&v30);
  v14 = -1i64;
  v30.m_attachedBody = -1;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9093, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape )
  {
    LODWORD(v25) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9094, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with NULL Shape in world %i", "shape", v25) )
      __debugbreak();
  }
  if ( !name )
  {
    LODWORD(v25) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9095, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with NULL Name in world %i", (const char *)&stru_143C9A1A4, v25) )
      __debugbreak();
  }
  v15 = physicsMaterial;
  if ( !physicsMaterial )
  {
    LODWORD(v25) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9096, ASSERT_TYPE_ASSERT, "(physicsMaterial)", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with NULL Physics Material in world %i", "physicsMaterial", v25) )
      __debugbreak();
  }
  if ( ((position->m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[2] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9097, ASSERT_TYPE_ASSERT, "(!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) ))", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with invalid position", "!IS_NAN( position(0) ) && !IS_NAN( position(1) ) && !IS_NAN( position(2) )") )
    __debugbreak();
  if ( ((orientation->m_vec.m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[2] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[3] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9098, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) ))", "%s\n\tHavok Physics: Trying to Instantiate Keyframed Body with invalid orientation", "!IS_NAN( orientation(0) ) && !IS_NAN( orientation(1) ) && !IS_NAN( orientation(2) ) && !IS_NAN( orientation(3) )") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v25) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9105, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Instantiate Keyframed Body %i: world is NULL", "havokPhysicsWorld->world", v25) )
      __debugbreak();
  }
  v17 = -1;
  do
    ++v14;
  while ( physicsMaterial[v14] );
  for ( ; v14; --v14 )
    v17 = (v17 >> 8) ^ g_crc32Table[*(unsigned __int8 *)v15++ ^ (unsigned __int64)(unsigned __int8)v17];
  v18 = ~v17;
  v19 = 0;
  m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
  if ( m_size <= 0 )
    goto LABEL_36;
  while ( v18 != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v19] )
  {
    if ( ++v19 >= m_size )
      goto LABEL_36;
  }
  if ( v19 >= m_size )
  {
LABEL_36:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9120, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", (const char *)&queryFormat, "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()") )
      __debugbreak();
  }
  Instance = HavokPhysicsInstanceManager_AllocateInstance(&MutableWorld->instanceManager);
  v22 = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9125, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics Keyframed Body: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  if ( shape )
    hkReferencedObject::addReference(&shape->hkReferencedObject);
  if ( v30.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v30.m_shape.m_ptr->hkReferencedObject);
  v30.m_shape.m_ptr = shape;
  v30.m_desiredBodyId.m_serialAndIndex = 0xFFFFFF;
  v30.m_motionId.m_value = 0x7FFFFFFF;
  v30.m_qualityId.m_value = s_dynamicBodyQualityIdx + 16;
  v30.m_materialId.m_value = s_havokPhysicsMaterialLibrary.firstId.m_value + v19;
  v30.m_collisionFilterInfo = collisionFilterInfo;
  v30.m_flags.m_storage = forQueryOnly << 8;
  v30.m_collisionLookAheadDistance = 0.0;
  hkStringPtr::operator=(&v30.m_name, string[0]);
  v30.m_motionType.m_storage = !Physics_IsQueryWorld(worldId);
  v30.m_userData = 0i64;
  v30.m_activationPriority = s_havokPhysicsDefaultActivationPriority;
  v30.m_position = 0i64;
  v30.m_orientation.m_vec.m_quad = g_vectorfConstants[35];
  *(hkQuaternionf *)string = (hkQuaternionf)orientation->m_vec.m_quad;
  v28.m_quad = *(__m128 *)v28.m_quad.m128_u64[0];
  v23 = HavokPhysics_CreateRigidBody(&v26, worldId, MutableWorld, NULL, 0, &v30, v26.m_serialAndIndex, &v28, (hkQuaternionf *)string, 0, tryStartDeactivated, 0);
  HavokPhysicsInstanceManager_AddBody(&MutableWorld->instanceManager, v22, (hknpBodyId)v23->m_serialAndIndex);
  if ( add )
  {
    if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v22 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    HavokPhysics_AddRigidBodies(MutableWorld, MutableWorld->instanceManager.buffer[v22].bodies.m_data, MutableWorld->instanceManager.buffer[v22].bodies.m_size, 0, tryStartDeactivated);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, &MutableWorld->instanceManager, v22, 0, 1);
  }
  if ( v30.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v30.m_localFrame.m_ptr);
  if ( v30.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v30.m_dragProperties.m_ptr);
  if ( v30.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v30.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v30.m_name);
  if ( v30.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v30.m_shape.m_ptr->hkReferencedObject);
  return (unsigned int)v22;
}

/*
==============
HavokPhysics_InstantiateStaticBody
==============
*/
__int64 HavokPhysics_InstantiateStaticBody(Physics_WorldId worldId, const hknpShape *shape, int ref, const char *name, const char *physicsMaterial, int collisionFilterInfo, const hkVector4f *position, const hkQuaternionf *orientation, bool add, bool tryStartDeactivated, bool forQueryOnly)
{
  __int64 v14; 
  HavokPhysicsWorld *MutableWorld; 
  int v16; 
  const char *v17; 
  unsigned int v18; 
  int v19; 
  int m_size; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int Instance; 
  __int64 v23; 
  hknpBodyId *v24; 
  __int64 v26; 
  HavokPhysicsWorld *world; 
  hknpBodyId v28; 
  char *string[2]; 
  hkVector4f v30; 
  __int64 v31; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment v32; 

  v31 = -2i64;
  string[0] = (char *)name;
  v28.m_serialAndIndex = ref;
  v30.m_quad.m128_u64[0] = (unsigned __int64)position;
  hknpBodyCinfo::hknpBodyCinfo(&v32);
  v14 = -1i64;
  v32.m_attachedBody = -1;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9196, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Instantiate Static Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape )
  {
    LODWORD(v26) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9197, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to Instantiate Static Body with NULL Shape in world %i", "shape", v26) )
      __debugbreak();
  }
  if ( !name )
  {
    LODWORD(v26) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9198, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, "%s\n\tHavok Physics: Trying to Instantiate Static Body with NULL Name in world %i", (const char *)&stru_143C9A1A4, v26) )
      __debugbreak();
  }
  if ( ((position->m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (position->m_quad.m128_i32[2] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9199, ASSERT_TYPE_ASSERT, "(!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) ))", "%s\n\tHavok Physics: Trying to Instantiate Static Body with invalid position", "!IS_NAN( position( 0 ) ) && !IS_NAN( position( 1 ) ) && !IS_NAN( position( 2 ) )") )
    __debugbreak();
  if ( ((orientation->m_vec.m_quad.m128_i32[0] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[1] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[2] & 0x7F800000) == 2139095040 || (orientation->m_vec.m_quad.m128_i32[3] & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9200, ASSERT_TYPE_ASSERT, "(!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) ))", "%s\n\tHavok Physics: Trying to Instantiate Static Body with invalid orientation", "!IS_NAN( orientation( 0 ) ) && !IS_NAN( orientation( 1 ) ) && !IS_NAN( orientation( 2 ) ) && !IS_NAN( orientation( 3 ) )") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  world = MutableWorld;
  if ( !MutableWorld->world )
  {
    LODWORD(v26) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9207, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Instantiate Static Body %i: world is NULL", "havokPhysicsWorld->world", v26) )
      __debugbreak();
  }
  v16 = 0;
  if ( physicsMaterial )
  {
    v17 = physicsMaterial;
    v18 = -1;
    do
      ++v14;
    while ( physicsMaterial[v14] );
    for ( ; v14; --v14 )
      v18 = (v18 >> 8) ^ g_crc32Table[*(unsigned __int8 *)v17++ ^ (unsigned __int64)(unsigned __int8)v18];
    v19 = ~v18;
    m_size = s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_size;
    if ( m_size <= 0 )
      goto LABEL_34;
    while ( v19 != s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.m_data[v16] )
    {
      if ( ++v16 >= m_size )
        goto LABEL_34;
    }
    if ( v16 >= m_size )
    {
LABEL_34:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9225, ASSERT_TYPE_ASSERT, "(materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize())", (const char *)&queryFormat, "materialIdx < s_havokPhysicsMaterialLibrary.list->m_materialsNameCRC32s.getSize()") )
        __debugbreak();
    }
  }
  p_instanceManager = &MutableWorld->instanceManager;
  Instance = HavokPhysicsInstanceManager_AllocateInstance(p_instanceManager);
  v23 = Instance;
  if ( Instance == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9231, ASSERT_TYPE_ASSERT, "(havokPhysicsInstanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics Static Body: couldn't allocate havok physics instance id", "havokPhysicsInstanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  if ( shape )
    hkReferencedObject::addReference(&shape->hkReferencedObject);
  if ( v32.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v32.m_shape.m_ptr->hkReferencedObject);
  v32.m_shape.m_ptr = shape;
  v32.m_desiredBodyId.m_serialAndIndex = 0xFFFFFF;
  v32.m_motionId.m_value = 0x7FFFFFFF;
  v32.m_qualityId.m_value = s_staticBodyQualityIdx + 16;
  if ( physicsMaterial )
    v32.m_materialId.m_value = s_havokPhysicsMaterialLibrary.firstId.m_value + v16;
  v32.m_collisionFilterInfo = collisionFilterInfo;
  v32.m_flags.m_storage = forQueryOnly << 8;
  v32.m_collisionLookAheadDistance = 0.0;
  hkStringPtr::operator=(&v32.m_name, string[0]);
  v32.m_motionType.m_storage = 0;
  v32.m_userData = 0i64;
  v32.m_activationPriority = s_havokPhysicsDefaultActivationPriority;
  v32.m_position = 0i64;
  v32.m_orientation.m_vec.m_quad = g_vectorfConstants[35];
  *(hkQuaternionf *)string = (hkQuaternionf)orientation->m_vec.m_quad;
  v30.m_quad = *(__m128 *)v30.m_quad.m128_u64[0];
  v24 = HavokPhysics_CreateRigidBody(&v28, worldId, world, NULL, 0, &v32, v28.m_serialAndIndex, &v30, (hkQuaternionf *)string, 0, tryStartDeactivated, 0);
  HavokPhysicsInstanceManager_AddBody(p_instanceManager, v23, (hknpBodyId)v24->m_serialAndIndex);
  if ( add )
  {
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v23 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    HavokPhysics_AddRigidBodies(world, p_instanceManager->buffer[v23].bodies.m_data, p_instanceManager->buffer[v23].bodies.m_size, 0, tryStartDeactivated);
    HavokPhysicsInstanceManager_SetAddedToWorld(worldId, p_instanceManager, v23, 0, 1);
  }
  if ( v32.m_localFrame.m_ptr )
    hkReferencedObject::removeReference(v32.m_localFrame.m_ptr);
  if ( v32.m_dragProperties.m_ptr )
    hkReferencedObject::removeReference(v32.m_dragProperties.m_ptr);
  if ( v32.m_massDistribution.m_ptr )
    hkReferencedObject::removeReference(v32.m_massDistribution.m_ptr);
  hkStringPtr::~hkStringPtr(&v32.m_name);
  if ( v32.m_shape.m_ptr )
    hkReferencedObject::removeReference(&v32.m_shape.m_ptr->hkReferencedObject);
  return (unsigned int)v23;
}

/*
==============
HavokPhysics_IsAssetBodyAnimationDriven
==============
*/
bool HavokPhysics_IsAssetBodyAnimationDriven(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v2; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 

  v2 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8541, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to check if physics asset is a ragdollwith invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8545, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics IsAssetBodyAnimationDriven %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( ((int)v2 < 0 || (int)v2 >= HavokPhysicsAsset->m_bodyDrivers.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8547, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_bodyDrivers.getSize())", "%s\n\tHavokPhysics IsAssetBodyAnimationDriven %s: bodyIdx out of range", "bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_bodyDrivers.getSize()", physicsAsset->name) )
    __debugbreak();
  return HavokPhysicsAsset->m_bodyDrivers.m_data[v2] == 1;
}

/*
==============
HavokPhysics_IsChildOfShape
==============
*/
char HavokPhysics_IsChildOfShape(const hknpShape *possibleParent, const hknpShape *possibleChild)
{
  unsigned __int8 m_storage; 
  int v5; 
  int v6; 
  __int64 v7; 
  unsigned __int16 v8; 
  const hknpShape *v10; 
  int v11; 
  unsigned int v12; 
  int v13; 
  const hknpShape *CollisionTileModelShape; 
  unsigned __int16 v15; 
  unsigned __int16 v16; 

  m_storage = possibleParent->m_type.m_storage;
  if ( m_storage != 12 )
  {
    if ( m_storage == 22 )
    {
      v12 = *(_DWORD *)&possibleParent[1].m_memSizeAndFlags;
      v13 = 0;
      if ( SLODWORD(possibleParent[1].m_convexRadius) > 0 )
      {
        while ( 1 )
        {
          CollisionTileModelShape = (const hknpShape *)StaticModels_GetCollisionTileModelShape((*(_WORD *)(*(_QWORD *)&possibleParent[1].m_flags.m_storage + 4i64 * (unsigned __int16)v13) & 0x4000) != 0, v12, *(_WORD *)(*(_QWORD *)&possibleParent[1].m_flags.m_storage + 4i64 * (unsigned __int16)v13) & 0x3FFF);
          if ( CollisionTileModelShape == possibleChild || HavokPhysics_IsChildOfShape(CollisionTileModelShape, possibleChild) )
            break;
          if ( ++v13 >= SLODWORD(possibleParent[1].m_convexRadius) )
            return 0;
        }
        return 1;
      }
    }
    return 0;
  }
  v5 = *(_DWORD *)&possibleParent[1].m_flags.m_storage;
  v6 = 0;
  v15 = 0;
  if ( v5 <= 0 )
    return 0;
  v7 = *(_QWORD *)&possibleParent[1].m_memSizeAndFlags;
  while ( 1 )
  {
    v8 = v15;
    if ( !*(_BYTE *)(112i64 * v15 + v7 + 92) )
      break;
    v15 = ++v6;
    if ( v6 >= v5 )
      return 0;
  }
  if ( v6 == -1 )
    return 0;
  while ( 1 )
  {
    v10 = *(const hknpShape **)(112i64 * v8 + v7 + 80);
    if ( v10 == possibleChild || HavokPhysics_IsChildOfShape(v10, possibleChild) )
      break;
    v11 = *(_DWORD *)&possibleParent[1].m_flags.m_storage;
    v16 = ++v6;
    if ( v6 < v11 )
    {
      v7 = *(_QWORD *)&possibleParent[1].m_memSizeAndFlags;
      while ( 1 )
      {
        v8 = v16;
        if ( !*(_BYTE *)(112i64 * v16 + v7 + 92) )
          break;
        v16 = ++v6;
        if ( v6 >= v11 )
          return 0;
      }
      if ( v6 != -1 )
        continue;
    }
    return 0;
  }
  return 1;
}

/*
==============
HavokPhysics_IsInstanceDeactivated
==============
*/
char HavokPhysics_IsInstanceDeactivated(Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v2; 
  const HavokPhysicsWorld *ConstWorld; 
  unsigned int v5; 
  int NumRigidBodys; 
  const HavokPhysicsWorld *v7; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  __int64 v10; 
  __int64 v11; 
  hknpBodyId result; 

  v2 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11284, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to check if instance is deactvated with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v2 == -1 )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11285, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to check if instance is deactvated with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v10) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v10) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11290, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsInstanceDeactivated %i: world is NULL", "havokPhysicsWorld->world", v10) )
      __debugbreak();
  }
  v5 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v2);
  if ( NumRigidBodys <= 0 )
    return 1;
  while ( 1 )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v10) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v10) )
        __debugbreak();
    }
    if ( (_DWORD)v2 == -1 )
    {
      LODWORD(v10) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v10) )
        __debugbreak();
    }
    v7 = HavokPhysics_GetConstWorld(worldId);
    if ( !v7->world )
    {
      LODWORD(v10) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v10) )
        __debugbreak();
    }
    p_instanceManager = &v7->instanceManager;
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v2 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    if ( v5 >= p_instanceManager->buffer[v2].bodies.m_size )
    {
      LODWORD(v11) = worldId;
      LODWORD(v10) = v5;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v10, v11) )
        __debugbreak();
    }
    HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v2, v5);
    if ( (*(_BYTE *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, result.m_serialAndIndex) + 68) & 8) != 0 )
      break;
    if ( (int)++v5 >= NumRigidBodys )
      return 1;
  }
  return 0;
}

/*
==============
HavokPhysics_IsInstanceInUse
==============
*/
bool HavokPhysics_IsInstanceInUse(Physics_WorldId worldId, unsigned int instanceId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10889, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to test instance in use with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10890, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to test instance in use with invalid Instance in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  return HavokPhysicsInstanceManager_IsInstanceInUse(&ConstWorld->instanceManager, instanceId);
}

/*
==============
HavokPhysics_IsInstanceInWorld
==============
*/
bool HavokPhysics_IsInstanceInWorld(Physics_WorldId worldId, unsigned int instanceId, bool checkPending)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v8; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11110, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to test if instance is in world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11111, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to test if instance is in world with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v8) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11115, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsInstanceInWorld %i: world is NULL", "havokPhysicsWorld->world", v8) )
      __debugbreak();
  }
  return HavokPhysicsInstanceManager_IsAddedToWorld(&ConstWorld->instanceManager, instanceId, checkPending);
}

/*
==============
HavokPhysics_IsMeshShape
==============
*/
bool HavokPhysics_IsMeshShape(const hknpShape *shape)
{
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 725, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  if ( shape->m_type.m_storage != 22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 726, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::USER_0)", (const char *)&queryFormat, "shape->getType() == hknpShapeType::USER_0") )
    __debugbreak();
  return StaticModels_HavokShape_IsMeshShape(shape);
}

/*
==============
HavokPhysics_IsPhysicsAssetBodyDynamic
==============
*/
bool HavokPhysics_IsPhysicsAssetBodyDynamic(const PhysicsAsset *physicsAsset, int bodyIdx)
{
  __int64 v3; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v5; 
  int v6; 
  float m_mass; 
  hkRefCountedProperties *v8; 
  hkReferencedObject *v9; 
  hkDiagonalizedMassProperties props; 

  v3 = bodyIdx;
  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8181, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to test if a physics asset's body is dynamic with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8185, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics IsPhysicsAssetBodyDynamic %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8186, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics IsPhysicsAssetBodyDynamic %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  if ( ((int)v3 < 0 || (int)v3 >= HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8189, ASSERT_TYPE_ASSERT, "(bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.getSize())", (const char *)&queryFormat, "bodyIdx >= 0 && bodyIdx < havokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.getSize()") )
    __debugbreak();
  v5 = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v3];
  if ( *(_BYTE *)(v5 + 40) < 2u )
    return 0;
  if ( (*(_BYTE *)(v5 + 8) & 5) != 0 )
    return 0;
  v6 = *(unsigned __int16 *)(v5 + 136);
  if ( v6 == s_staticMotionPropertiesIdx + 5 || v6 == s_keyframedMotionPropertiesIdx + 5 )
    return 0;
  m_mass = *(float *)(v5 + 112);
  if ( m_mass < 0.0 )
  {
    v8 = *(hkRefCountedProperties **)(*(_QWORD *)v5 + 48i64);
    if ( v8 )
    {
      v9 = hkRefCountedProperties::accessProperty(v8, 0xF100u);
      if ( v9 )
        hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v9[1], &props);
    }
    m_mass = props.m_mass;
  }
  return m_mass != 0.0;
}

/*
==============
HavokPhysics_IsPhysicsAssetDynamic
==============
*/
bool HavokPhysics_IsPhysicsAssetDynamic(const PhysicsAsset *physicsAsset)
{
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpPhysicsSystemData::bodyCinfoWithAttachment *m_data; 
  int m_value; 
  float m_mass; 
  hkRefCountedProperties *m_ptr; 
  hkReferencedObject *v7; 
  hkDiagonalizedMassProperties props; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8127, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tHavokPhysics: Trying to test if a physics asset is dynamic with invalid physics asset", "physicsAsset") )
    __debugbreak();
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8131, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", "%s\n\tHavokPhysics IsPhysicsAssetDynamic %s: couldn't find havok asset", "havokPhysicsAsset", physicsAsset->name) )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8132, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset->m_physicsSystemData)", "%s\n\tHavokPhysics IsPhysicsAssetDynamic %s: couldn't find havok asset", "havokPhysicsAsset->m_physicsSystemData", physicsAsset->name) )
    __debugbreak();
  m_data = HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data;
  if ( m_data->m_motionType.m_storage < 2u )
    return 0;
  if ( (m_data->m_flags.m_storage & 5) != 0 )
    return 0;
  m_value = m_data->m_motionPropertiesId.m_value;
  if ( m_value == s_staticMotionPropertiesIdx + 5 || m_value == s_keyframedMotionPropertiesIdx + 5 )
    return 0;
  m_mass = m_data->m_mass;
  if ( m_mass < 0.0 )
  {
    m_ptr = m_data->m_shape.m_ptr->m_properties.m_ptr;
    if ( m_ptr )
    {
      v7 = hkRefCountedProperties::accessProperty(m_ptr, 0xF100u);
      if ( v7 )
        hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v7[1], &props);
    }
    m_mass = props.m_mass;
  }
  return m_mass != 0.0;
}

/*
==============
HavokPhysics_IsRigidBodyActive
==============
*/
bool HavokPhysics_IsRigidBodyActive(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11733, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body active state with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11734, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body active state with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11739, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetRigidBodyActive %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (*(_DWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68) & 8) != 0;
}

/*
==============
HavokPhysics_IsRigidBodyDynamic
==============
*/
bool HavokPhysics_IsRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11402, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11403, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Dynamic with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11408, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_flags.m_storage & 6) == 2;
}

/*
==============
HavokPhysics_IsRigidBodyKeyframed
==============
*/
bool HavokPhysics_IsRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11379, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Keyframed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11380, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Keyframed with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11385, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return (ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_flags.m_storage & 4) != 0;
}

/*
==============
HavokPhysics_IsRigidBodyStatic
==============
*/
bool HavokPhysics_IsRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11335, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11336, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Check if Rigid Body is Static with invalid body id for world %i", "bodyId.isValid()", v6) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11341, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyStatic %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return *(_BYTE *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) + 68) & 1;
}

/*
==============
HavokPhysics_IsRigidBodyValid
==============
*/
bool HavokPhysics_IsRigidBodyValid(Physics_WorldId worldId, hknpBodyId bodyId)
{
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11316, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Check if Rigid Body is valid with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v6) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11320, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyValid %i: world is NULL", "havokPhysicsWorld->world", v6) )
      __debugbreak();
  }
  return ((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->isBodyValid)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex) != 0;
}

/*
==============
HavokPhysics_IsShapeCacheDisabled
==============
*/
_BOOL8 HavokPhysics_IsShapeCacheDisabled(unsigned int threadId)
{
  __int64 v1; 

  v1 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15863, ASSERT_TYPE_ASSERT, "(threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS)", (const char *)&queryFormat, "threadId < PHYSICS_MAX_SUPPORTED_NUM_THREADS") )
    __debugbreak();
  return s_havokPhysicsShapeCachesDisabled[v1];
}

/*
==============
HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled
==============
*/
bool HavokPhysics_IsTimeStepFixForProperKeyFramedBodyVelocityEnabled(const Physics_WorldId worldId)
{
  const dvar_t *v2; 

  if ( Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x100) )
  {
    if ( Physics_IsAuthoritativeWorld(worldId) )
    {
      v2 = DVARBOOL_physics_killswitchEnableClientAuthWorldKeyFramedRigidBodyVelocityCalcFix;
      if ( !DVARBOOL_physics_killswitchEnableClientAuthWorldKeyFramedRigidBodyVelocityCalcFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableClientAuthWorldKeyFramedRigidBodyVelocityCalcFix") )
        __debugbreak();
LABEL_6:
      Dvar_CheckFrontendServerThread(v2);
      return v2->current.enabled;
    }
    if ( Physics_IsPredictiveWorld(worldId) )
    {
      v2 = DVARBOOL_physics_killswitchEnableClientPredWorldKeyFramedRigidBodyVelocityCalcFix;
      if ( !DVARBOOL_physics_killswitchEnableClientPredWorldKeyFramedRigidBodyVelocityCalcFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableClientPredWorldKeyFramedRigidBodyVelocityCalcFix") )
        __debugbreak();
      goto LABEL_6;
    }
  }
  return 0;
}

/*
==============
HavokPhysics_IsWorldMultithreaded
==============
*/
_BOOL8 HavokPhysics_IsWorldMultithreaded(Physics_WorldId worldId)
{
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3785, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to test if a world is multithreaded with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  return HavokPhysics_GetConstWorld(worldId)->isMultithreaded;
}

/*
==============
HavokPhysics_KeyframeInstanceTo
==============
*/
__int64 HavokPhysics_KeyframeInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  Physics_MovementType v8; 
  __int64 v9; 
  int NumRigidBodys; 
  unsigned int v14; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int m_serialAndIndex; 
  hkTransformf *v18; 
  hkTransformf *p_r; 
  Physics_MovementType v20; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  hknpBodyId result; 
  float zero; 
  HavokPhysicsWorld *MutableWorld; 
  hkQuaternionf hkOrientationa; 
  hkTransformf r; 
  hkTransformf aTb; 
  hkTransformf bTc; 
  hkTransformf v33; 

  v8 = Physics_MovementType_NoMove;
  v9 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12625, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Instance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v9 == -1 )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12626, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Keyframe Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v23) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12630, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Keyframe Instance %i: world is NULL", "havokPhysicsWorld->world", v23) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&r.m_rotation, hkOrientation);
  r.m_translation = (hkVector4f)hkPosition->m_quad;
  if ( !hkTransformf::isOk(&r) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12634, ASSERT_TYPE_ASSERT, "(body0NewTransform.isOk())", (const char *)&queryFormat, "body0NewTransform.isOk()") )
    __debugbreak();
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v9);
  v14 = 0;
  if ( NumRigidBodys <= 0 )
    return 0i64;
  do
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v23) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v23) )
        __debugbreak();
    }
    if ( (_DWORD)v9 == -1 )
    {
      LODWORD(v23) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v23) )
        __debugbreak();
    }
    ConstWorld = HavokPhysics_GetConstWorld(worldId);
    if ( !ConstWorld->world )
    {
      LODWORD(v23) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v23) )
        __debugbreak();
    }
    p_instanceManager = &ConstWorld->instanceManager;
    if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
      __debugbreak();
    if ( (_DWORD)v9 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
      __debugbreak();
    if ( v14 >= p_instanceManager->buffer[v9].bodies.m_size )
    {
      LODWORD(v24) = worldId;
      LODWORD(v23) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v23, v24) )
        __debugbreak();
    }
    HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v9, v14);
    m_serialAndIndex = result.m_serialAndIndex;
    if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(v25) = worldId;
      LODWORD(v24) = v9;
      LODWORD(v23) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12645, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v23, v24, v25) )
        __debugbreak();
    }
    v18 = (hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, m_serialAndIndex);
    if ( !hkTransformf::isOk(v18) )
    {
      LODWORD(v22) = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12649, ASSERT_TYPE_ASSERT, "( ( oldTransform.isOk() ) )", "( bodyIt ) = %i", v22) )
        __debugbreak();
    }
    if ( v14 )
    {
      hkTransformf::setMul(&bTc, &aTb, v18);
      hkTransformf::setMul(&v33, &r, &bTc);
      p_r = &v33;
    }
    else
    {
      zero = FLOAT_0_001;
      if ( hkTransformf::isApproximatelyEqual(v18, &r, &zero) )
        return (unsigned int)v8;
      hkTransformf::setInverse(&aTb, v18);
      p_r = &r;
    }
    hkQuaternionf::setAndNormalize(&hkOrientationa, &p_r->m_rotation);
    v20 = HavokPhysics_KeyframeRigidBodyTo(worldId, (hknpBodyId)m_serialAndIndex, &p_r->m_translation, &hkOrientationa, velocityScale, canWarp, updateBroadphaseIfWarping, stepTimeOverride);
    if ( v8 == Physics_MovementType_NoMove || v20 == Physics_MovementType_Warped )
      v8 = v20;
    ++v14;
  }
  while ( (int)v14 < NumRigidBodys );
  return (unsigned int)v8;
}

/*
==============
HavokPhysics_KeyframeRigidBodyTo
==============
*/
Physics_MovementType HavokPhysics_KeyframeRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  __int64 v14; 
  __m128 v15; 
  __m128 m_quad; 
  __m128 v21; 
  __m128 v22; 
  __m128 v23; 
  float timeStep; 
  int v38; 
  int v39; 
  int v41; 
  const HavokPhysicsWorld *ConstWorld; 
  float v52; 
  hknpWorld *v55; 
  hknpWorldWriter *v56; 
  const hknpWorldReader *v57; 
  __int64 v58; 
  hkVector4f *angularVelocityOut; 
  hkVector4f v60; 
  hkQuaternionf v61; 
  hkVector4f linearVelocityOut; 

  _R14 = (hkQuaternionf *)hkOrientation;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12437, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12438, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid body id for world %i", "bodyId.isValid()", angularVelocityOut) )
      __debugbreak();
  }
  if ( !hkQuaternionf::isOk(_R14, 0.001) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12446, ASSERT_TYPE_ASSERT, "(hkOrientation.isOk())", (const char *)&queryFormat, "hkOrientation.isOk()") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12450, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics KeyframeRigidBodyTo %i: world is NULL", "havokPhysicsWorld->world", angularVelocityOut) )
      __debugbreak();
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 363, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", angularVelocityOut) )
      __debugbreak();
  }
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 364, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid body id for world %i", "bodyId.isValid()", angularVelocityOut) )
      __debugbreak();
  }
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 368, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", angularVelocityOut) )
      __debugbreak();
  }
  v14 = (__int64)&world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF];
  v15 = *(__m128 *)(v14 + 48);
  hkQuaternionf::set(&v61, (const hkRotationImpl<float> *)v14);
  m_quad = v61.m_vec.m_quad;
  _XMM7 = _R14->m_vec.m_quad;
  _XMM9 = *(_OWORD *)hkMath::hkSse_signMask;
  __asm
  {
    vdpps   xmm5, xmm7, xmm6, 0FFh
    vbroadcastss xmm0, dword ptr [r14+0Ch]
  }
  v21 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM7, _XMM7, 201), v61.m_vec.m_quad), _mm128_mul_ps(_mm_shuffle_ps(m_quad, m_quad, 201), _R14->m_vec.m_quad));
  v22 = _mm128_sub_ps(_mm_shuffle_ps(v21, v21, 201), _mm128_mul_ps(_XMM0, v61.m_vec.m_quad));
  v23 = _mm_shuffle_ps(m_quad, m_quad, 255);
  timeStep = stepTimeOverride;
  _XMM1 = _mm128_add_ps(v22, _mm128_mul_ps(v23, _R14->m_vec.m_quad));
  __asm
  {
    vblendps xmm4, xmm1, xmm5, 8
    vpxor   xmm1, xmm1, xmm1
  }
  _mm128_sub_ps(v15, hkPosition->m_quad);
  __asm
  {
    vandnps xmm0, xmm9, xmm0
    vcmpleps xmm5, xmm0, cs:__xmm@38d1b71738d1b71738d1b71738d1b717
    vpcmpeqd xmm0, xmm1, xmm1
  }
  _XMM10 = 0i64;
  __asm { vblendps xmm3, xmm10, xmm0, 7 }
  _mm128_sub_ps(_XMM4, g_vectorfConstants[5]);
  __asm
  {
    vandnps xmm1, xmm9, xmm0
    vcmpleps xmm2, xmm1, cs:__xmm@38d1b71738d1b71738d1b71738d1b717
    vpand   xmm0, xmm2, xmm3
    vptest  xmm0, xmm3
  }
  v38 = 0;
  v39 = 0;
  if ( _CF )
    v38 = 1;
  __asm
  {
    vpand   xmm0, xmm5, xmm3
    vptest  xmm0, xmm3
  }
  if ( _CF )
    v39 = 1;
  v41 = v39 & v38 & 1;
  if ( stepTimeOverride <= 0.0 )
    timeStep = MutableWorld->timeStep;
  if ( v41 || velocityScale == 0.0 || timeStep == 0.0 )
  {
    v58 = (__int64)&MutableWorld->world->hknpWorldWriter;
    v60.m_quad = 0i64;
    (*(void (__fastcall **)(__int64, _QWORD, hkVector4f *, _QWORD))(*(_QWORD *)v58 + 160i64))(v58, bodyId.m_serialAndIndex, &v60, 0i64);
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, hkVector4f *, _QWORD))MutableWorld->world->setBodyAngularVelocity)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, &v60, 0i64);
    return 0;
  }
  if ( canWarp )
  {
    __asm { vandnps xmm4, xmm9, xmm0 }
    v60.m_quad = _mm128_sub_ps(hkPosition->m_quad, v15);
    __asm
    {
      vpshufd xmm1, xmm4, 55h ; 'U'
      vpshufd xmm0, xmm4, 0
      vpmaxsd xmm2, xmm0, xmm1
      vpshufd xmm1, xmm4, 0AAh ; ''
      vpmaxsd xmm3, xmm1, xmm2
      vcmpleps xmm0, xmm3, xmm4
      vmovmskps eax, xmm0
      vandnps xmm10, xmm9, xmm1
    }
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(angularVelocityOut) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11424, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinSpeed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", angularVelocityOut) )
        __debugbreak();
    }
    if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    {
      LODWORD(angularVelocityOut) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11425, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body MaxLinSpeed with invalid body id for world %i", "bodyId.isValid()", angularVelocityOut) )
        __debugbreak();
    }
    ConstWorld = HavokPhysics_GetConstWorld(worldId);
    if ( !ConstWorld->world )
    {
      LODWORD(angularVelocityOut) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11430, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics IsRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", angularVelocityOut) )
        __debugbreak();
    }
    v52 = ConstWorld->world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)ConstWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_motionId.m_value].m_pod.m_linearVelocityAndSpeedLimit.m_quad.m128_f32[3];
    if ( timeStep <= 0.0 )
    {
      __asm { vxorpd  xmm0, xmm0, xmm0 }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12505, ASSERT_TYPE_ASSERT, "( timeStep ) > ( 0.0f )", "%s > %s\n\t%g, %g", "timeStep", "0.0f", timeStep, *(double *)&_XMM0) )
        __debugbreak();
    }
    if ( (float)(*(float *)&_XMM10 / (float)(timeStep / velocityScale)) > v52 )
    {
      ((void (__fastcall *)(hknpWorldWriter *, _QWORD, const __m128 *, const __m128 *, _DWORD))MutableWorld->world->setBodyVelocity)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, &g_vectorfConstants[5], &g_vectorfConstants[5], 0);
      return HavokPhysics_WarpRigidBodyTo(worldId, bodyId, hkPosition, _R14, updateBroadphaseIfWarping, 1);
    }
  }
  if ( timeStep <= 0.0 )
    return 0;
  v55 = MutableWorld->world;
  v56 = &v55->hknpWorldWriter;
  v57 = &v55->hknpWorldReader;
  if ( !v55 )
    v56 = NULL;
  if ( !v55 )
    v57 = NULL;
  hknpKeyFrameUtil::calcRequiredVelocity(v57, bodyId, hkPosition, _R14, velocityScale / timeStep, &linearVelocityOut, &v60);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, hkVector4f *, hkVector4f *, _DWORD))v56->setBodyVelocity)(v56, bodyId.m_serialAndIndex, &linearVelocityOut, &v60, 0);
  return 1;
}

/*
==============
HavokPhysics_KeyframeRigidBodyToFast
==============
*/
__int64 HavokPhysics_KeyframeRigidBodyToFast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, float velocityScale, bool canWarp, bool updateBroadphaseIfWarping, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __m128 v16; 
  __m128 m_quad; 
  __m128 v21; 
  float timeStep; 
  hknpWorld *world; 
  __int64 result; 
  const hknpWorldReader *v50; 
  hknpMotion *p_m_pod; 
  __m128 v54; 
  unsigned __int64 v66; 
  hkVector4f *angularVelocityOut; 
  hkVector4f linearVelocityOut; 
  hkQuaternionf v72; 
  hkVector4f angVelocityWorld; 

  _RBP = hkOrientation;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12539, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12540, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid body id for world %i", "bodyId.isValid()", angularVelocityOut) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(angularVelocityOut) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12544, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics KeyframeRigidBodyTo %i: world is NULL", "havokPhysicsWorld->world", angularVelocityOut) )
      __debugbreak();
  }
  v13 = bodyId.m_serialAndIndex & 0xFFFFFF;
  v14 = v13;
  v15 = (__int64)&MutableWorld->world->m_bodyManager.m_bodies.m_objects.m_data[v13];
  v16 = *(__m128 *)(v15 + 48);
  hkQuaternionf::set(&v72, (const hkRotationImpl<float> *)v15);
  m_quad = v72.m_vec.m_quad;
  _XMM7 = _RBP->m_vec.m_quad;
  __asm
  {
    vdpps   xmm5, xmm7, xmm6, 0FFh
    vbroadcastss xmm0, dword ptr [rbp+0Ch]
  }
  v21 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM7, _XMM7, 201), v72.m_vec.m_quad), _mm128_mul_ps(_mm_shuffle_ps(m_quad, m_quad, 201), _RBP->m_vec.m_quad));
  _XMM7 = *(_OWORD *)hkMath::hkSse_signMask;
  _XMM1 = _mm128_add_ps(_mm128_sub_ps(_mm_shuffle_ps(v21, v21, 201), _mm128_mul_ps(_XMM0, v72.m_vec.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(m_quad, m_quad, 255), _RBP->m_vec.m_quad));
  __asm { vblendps xmm8, xmm1, xmm5, 8 }
  _XMM5 = g_vectorfConstants[5];
  _mm128_sub_ps(v16, hkPosition->m_quad);
  __asm
  {
    vandnps xmm0, xmm7, xmm0
    vcmpleps xmm3, xmm0, xmm6
  }
  _XMM0 = 0i64;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vpcmpeqd xmm2, xmm1, xmm1
    vblendps xmm4, xmm0, xmm2, 7
    vpand   xmm0, xmm3, xmm4
    vptest  xmm0, xmm4
  }
  if ( _CF )
  {
    _mm128_sub_ps(_XMM8, g_vectorfConstants[5]);
    __asm
    {
      vandnps xmm1, xmm7, xmm0
      vcmpleps xmm2, xmm1, xmm6
      vpand   xmm0, xmm2, xmm4
      vptest  xmm0, xmm4
    }
    if ( _CF )
      goto LABEL_26;
  }
  if ( velocityScale == 0.0 )
  {
LABEL_26:
    v66 = (unsigned __int64)&MutableWorld->world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)MutableWorld->world->m_bodyManager.m_bodies.m_objects.m_data[v14].m_pod.m_motionId.m_value];
    result = 0i64;
    __asm { vblendps xmm0, xmm5, xmmword ptr [rdx+40h], 8 }
    *(_OWORD *)(v66 + 64) = _XMM0;
    _XMM1 = g_vectorfConstants[5];
    __asm { vblendps xmm0, xmm1, xmmword ptr [rdx+50h], 8 }
    *(_OWORD *)(v66 + 80) = _XMM0;
  }
  else
  {
    timeStep = stepTimeOverride;
    if ( stepTimeOverride <= 0.0 )
      timeStep = MutableWorld->timeStep;
    world = MutableWorld->world;
    if ( !canWarp )
      goto LABEL_18;
    __asm { vandnps xmm4, xmm7, xmm0 }
    linearVelocityOut.m_quad = _mm128_sub_ps(hkPosition->m_quad, v16);
    __asm
    {
      vpshufd xmm1, xmm4, 55h ; 'U'
      vpshufd xmm0, xmm4, 0
      vpmaxsd xmm2, xmm0, xmm1
      vpshufd xmm1, xmm4, 0AAh ; ''
      vpmaxsd xmm3, xmm1, xmm2
      vcmpleps xmm0, xmm3, xmm4
      vmovmskps eax, xmm0
      vandnps xmm3, xmm7, xmm1
    }
    if ( (float)(*(float *)&_XMM3 / (float)(timeStep / velocityScale)) > world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)world->m_bodyManager.m_bodies.m_objects.m_data[v14].m_pod.m_motionId.m_value].m_pod.m_linearVelocityAndSpeedLimit.m_quad.m128_f32[3] )
    {
      return 3i64;
    }
    else
    {
LABEL_18:
      v50 = &world->hknpWorldReader;
      if ( !world )
        v50 = NULL;
      hknpKeyFrameUtil::calcRequiredVelocity(v50, bodyId, hkPosition, _RBP, velocityScale / timeStep, &linearVelocityOut, &angVelocityWorld);
      _XMM6 = linearVelocityOut.m_quad;
      __asm { vdpps   xmm2, xmm6, xmm6, 7Fh }
      p_m_pod = &MutableWorld->world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)MutableWorld->world->m_bodyManager.m_bodies.m_objects.m_data[v13].m_pod.m_motionId.m_value].m_pod;
      v54 = _mm_shuffle_ps(p_m_pod->m_linearVelocityAndSpeedLimit.m_quad, p_m_pod->m_linearVelocityAndSpeedLimit.m_quad, 255);
      _mm128_mul_ps(v54, v54);
      __asm
      {
        vcmpleps xmm1, xmm2, xmm0
        vmovmskps eax, xmm1
      }
      if ( _EAX )
      {
        __asm { vblendps xmm0, xmm6, xmm7, 8 }
        p_m_pod->m_linearVelocityAndSpeedLimit = (hkVector4f)_XMM0.m_quad;
        hknpMotion::setAngularVelocity(p_m_pod, &angVelocityWorld);
        return 1i64;
      }
      else
      {
        __asm
        {
          vcmpordps xmm0, xmm2, xmm2
          vmovmskps eax, xmm0
        }
        if ( _EAX )
        {
          __asm { vrsqrtps xmm4, xmm2 }
          _XMM5 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM4, _XMM2), _XMM4)), _mm128_mul_ps(_XMM4, *(__m128 *)hkMath::hkSse_floatHalf));
          __asm
          {
            vcmpordps xmm1, xmm5, xmm5
            vmovmskps eax, xmm1
          }
          if ( _EAX )
          {
            _XMM1 = _mm128_mul_ps(_mm128_mul_ps(_XMM5, v54), linearVelocityOut.m_quad);
            __asm { vblendps xmm2, xmm1, xmm7, 8 }
            p_m_pod->m_linearVelocityAndSpeedLimit = (hkVector4f)_XMM2.m_quad;
          }
        }
        hknpMotion::setAngularVelocity(p_m_pod, &angVelocityWorld);
        return 1i64;
      }
    }
  }
  return result;
}

/*
==============
HavokPhysics_LeftBroadphase
==============
*/
void HavokPhysics_LeftBroadphase(const hknpEventHandlerInput *input, const hknpEvent *event)
{
  __int128 v2; 
  __int128 v3; 
  __int128 v4; 
  __int64 v6; 
  hknpWorldReader *v8; 
  __int64 v9; 
  const dvar_t *v10; 
  __int64 v11; 
  __m128 v12; 
  float v13; 
  float v14; 
  __int64 v15; 
  unsigned int v16; 
  Physics_RefSystem RefSystem; 
  hknpWorld **p_world; 
  Physics_RefSystem v19; 
  Physics_WorldId v20; 
  char *MapEntsShapeName; 
  gentity_s *v22; 
  unsigned __int8 modelType; 
  const TriggerModel *TriggerModel; 
  unsigned __int16 model; 
  XModel *v26; 
  gentity_s *v27; 
  GWeaponMap *Instance; 
  const Weapon *Weapon; 
  int v30; 
  hknpConstraintManager *m_constraintManager; 
  hknpThreadSafeObjectPoolElement<hknpConstraint> *m_data; 
  unsigned int v33; 
  __m128 *v34; 
  __int64 v35; 
  hknpWorldWriter *v36; 
  int v37; 
  unsigned __int8 RefSubSystem; 
  __m128 v39; 
  char string[256]; 
  char output[512]; 
  __int128 v42; 
  __int128 v43; 
  __int128 v44; 

  v6 = *(unsigned int *)&event[1].m_filterBits;
  v8 = &input->m_world->hknpWorldReader;
  v44 = v2;
  v43 = v3;
  v42 = v4;
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, __int64))v8->getBody)(v8, v6);
  v10 = DVARBOOL_physics_disableSpammyWarnings;
  v11 = v9;
  v12 = *(__m128 *)(v9 + 48);
  v13 = _mm_shuffle_ps(v12, v12, 170).m128_f32[0] * 32.0;
  v14 = _mm_shuffle_ps(v12, v12, 85).m128_f32[0] * 32.0;
  if ( !DVARBOOL_physics_disableSpammyWarnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_disableSpammyWarnings") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( !v10->current.enabled )
  {
    v16 = *(_DWORD *)(v11 + 160);
    RefSystem = Physics_GetRefSystem(v16);
    p_world = &g_havokPhysicsWorlds[0].world;
    v19 = RefSystem;
    v20 = PHYSICS_WORLD_ID_FIRST;
    while ( *p_world != input->m_world )
    {
      ++v20;
      p_world += 480;
      if ( (unsigned int)v20 >= PHYSICS_WORLD_ID_COUNT )
      {
        v20 = PHYSICS_WORLD_ID_INVALID;
        break;
      }
    }
    Physics_ConvertRefSystemToString(v16, v20, string, 256);
    MapEntsShapeName = (char *)&queryFormat.fmt + 3;
    if ( v19 == Physics_RefSystem_GEntities )
    {
      v22 = &g_entities[Physics_GetRefId(v16)];
      modelType = v22->r.modelType;
      if ( modelType == 4 )
      {
        TriggerModel = CM_GetTriggerModel(v22->s.index.brushModel);
        MapEntsShapeName = (char *)WorldCollision_GetMapEntsShapeName(TriggerModel->physicsShapeOverrideIdx);
      }
      else
      {
        model = v22->model;
        if ( model )
        {
          v26 = G_Utils_GetModel(model);
          if ( v26 )
            MapEntsShapeName = (char *)v26->name;
        }
        else if ( modelType == 5 )
        {
          MapEntsShapeName = (char *)WorldCollision_GetMapEntsShapeName(cm.mapEnts->cmodels[v22->s.index.brushModel].physicsShapeOverrideIdx);
        }
      }
    }
    else if ( v19 == Physics_RefSystem_GItems )
    {
      v27 = &g_entities[Physics_GetRefId(v16)];
      if ( v27->s.weaponHandle.m_mapEntryId )
      {
        Instance = GWeaponMap::GetInstance();
        if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 438, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
          __debugbreak();
        Weapon = BgWeaponMap::GetWeapon(Instance, v27->s.weaponHandle);
        BG_GetWeaponName(Weapon, output, 0x200u);
        MapEntsShapeName = output;
      }
      else
      {
        MapEntsShapeName = "<null weapon>";
      }
    }
    Com_PrintWarning(1, "Physics body (ref:%x %s:%s) left the broadphase (fallen out of the world) - %s (%2.f, %.2f, %.2f).  Turn this message off with dvar physics_disableSpammyWarnings\n", v16, string, MapEntsShapeName, (const char *)((unsigned __int64)input->m_world->m_bodyManager.m_bodyNames.m_data[*(_DWORD *)&event[1].m_filterBits & 0xFFFFFF].m_stringAndFlag & 0xFFFFFFFFFFFFFFFEui64), (float)(v12.m128_f32[0] * 32.0), v14, v13);
  }
  v30 = *(_DWORD *)&event[1].m_filterBits;
  m_constraintManager = input->m_world->m_constraintManager;
  m_data = m_constraintManager->m_constraints.m_objects.m_data;
  if ( (v30 & 0xFFFFFFu) >= m_constraintManager->m_bodyIdToConstraintIdsMap.m_bodyIndexToFirstAttachedConstraintId.m_size )
    goto LABEL_34;
  v33 = m_constraintManager->m_bodyIdToConstraintIdsMap.m_bodyIndexToFirstAttachedConstraintId.m_data[v30 & 0xFFFFFF].m_serialAndIndex & 0xFFFFFF;
  if ( v33 == 0xFFFFFF )
    goto LABEL_34;
  while ( 1 )
  {
    v15 = 9i64 * v33;
    if ( m_data[v33].m_pod.m_bodyIdA.m_serialAndIndex == v30 || m_data[v33].m_pod.m_bodyIdB.m_serialAndIndex == v30 )
      break;
    v15 = (__int64)&m_constraintManager->m_bodyIdToConstraintIdsMap.m_constraintLinks.m_data[v33];
    if ( (m_data[v33].m_pod.m_bodyIdA.m_serialAndIndex & 0xFFFFFF) != (v30 & 0xFFFFFF) )
      v15 += 4i64;
    v33 = *(_DWORD *)v15;
    if ( *(_DWORD *)v15 == 0x7FFFFFFF )
      goto LABEL_34;
  }
  if ( v33 == 0x7FFFFFFF )
  {
LABEL_34:
    v34 = (__m128 *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD, __int64, hknpThreadSafeObjectPoolElement<hknpConstraint> *))input->m_world->getBodyTransform)(&input->m_world->hknpWorldReader, *(unsigned int *)&event[1].m_filterBits, v15, m_data);
    v35 = *(unsigned int *)&event[1].m_filterBits;
    v36 = &input->m_world->hknpWorldWriter;
    v39 = _mm128_mul_ps(v34[3], (__m128)_xmm);
    ((void (__fastcall *)(hknpWorldWriter *, __int64, __m128 *, _QWORD))v36->setBodyPosition)(v36, v35, &v39, 0i64);
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, const __m128 *, const __m128 *, _DWORD))input->m_world->setBodyVelocity)(&input->m_world->hknpWorldWriter, *(unsigned int *)&event[1].m_filterBits, &g_vectorfConstants[5], &g_vectorfConstants[5], 0);
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))input->m_world->setBodyMotionType)(&input->m_world->hknpWorldWriter, *(unsigned int *)&event[1].m_filterBits, 1i64);
  v37 = *(_DWORD *)(v11 + 160);
  if ( Physics_GetRefSystem(v37) == Physics_RefSystem_Ragdoll )
  {
    RefSubSystem = Physics_GetRefSubSystem(v37);
    Ragdoll_DisablePoseController(RefSubSystem + 1, 0.0);
  }
}

/*
==============
HavokPhysics_Load
==============
*/
void HavokPhysics_Load(SaveGame *save)
{
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  if ( !g_havokPhysicsWorlds[0].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5249, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Load serverworld main is NULL", "world->world") )
    __debugbreak();
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  HavokPhysicsInstanceManager_Clear(&g_havokPhysicsWorlds[0].instanceManager);
  HavokPhysicsInstanceManager_Load(save, &g_havokPhysicsWorlds[0].instanceManager);
  HavokPhysics_LoadSnapshot(save, PHYSICS_WORLD_ID_FIRST);
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  if ( !g_havokPhysicsWorlds[1].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5259, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Load serverworld detail is NULL", "world->world") )
    __debugbreak();
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  HavokPhysicsInstanceManager_Clear(&g_havokPhysicsWorlds[1].instanceManager);
  HavokPhysicsInstanceManager_Load(save, &g_havokPhysicsWorlds[1].instanceManager);
  HavokPhysics_LoadSnapshot(save, PHYSICS_WORLD_ID_SERVER_DETAIL);
}

/*
==============
HavokPhysics_LoadInstance
==============
*/
void HavokPhysics_LoadInstance(SaveGame *save, Physics_WorldId worldId, unsigned int instanceId, HavokPhysics_SnapshotFixup *snapshotFixup)
{
  const char *CString; 
  const char *v9; 
  const PhysicsAsset *AssetByName; 
  const PhysicsAsset *v11; 
  const char *v12; 
  const char *v13; 
  const PhysicsAsset *v14; 
  const char *v15; 
  XModel *physicsLibrary; 
  XAssetHeader v17; 
  const char *v18; 
  const XModel *model; 
  HavokPhysicsWorld *MutableWorld; 
  const PhysicsAsset *v21; 
  unsigned int v22; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  MemoryFile *v24; 
  int v25; 
  __int64 v26; 
  __int64 v27; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> > *p_bodyData; 
  unsigned __int64 m_serialAndIndex; 
  const char *v30; 
  __int64 v31; 
  hknpShape *v32; 
  hkReferencedObject *v33; 
  hkReferencedObject *v34; 
  hkReferencedObject *v35; 
  hknpShape *v36; 
  hkMemoryRouter *Value; 
  hknpMaskedShape *v38; 
  __int64 v39; 
  __int64 v40; 
  __int64 v41; 
  int v42; 
  int v43; 
  __int64 v44; 
  unsigned __int16 v45; 
  unsigned int v46; 
  int v47; 
  __int64 v48; 
  double v49; 
  float v50; 
  double v51; 
  hknpShape *MapEntsShape; 
  hknpSphereShape *v53; 
  hknpShape *v54; 
  hknpShape *v55; 
  unsigned int v56; 
  const hknpShape *m_ptr; 
  unsigned int v58; 
  unsigned __int16 ShapeTag; 
  hkMemoryAllocator *v60; 
  int v61; 
  int v62; 
  char *v63; 
  int v64; 
  hkMemoryRouter *v65; 
  hknpCompoundShape *v66; 
  hknpShape *v67; 
  hkMemoryAllocator *v68; 
  __int64 v69; 
  hkReferencedObject **v70; 
  hknpShape *v71; 
  double v72; 
  float v73; 
  hknpShape *ShapeData_PlayerClip; 
  double Float; 
  float v80; 
  double v85; 
  float v86; 
  bool v95; 
  unsigned __int16 m_refCount; 
  hkMemoryAllocator *v97; 
  __int64 EmptyPositionInternal; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *p_val; 
  __int64 *v100; 
  __int64 v101; 
  __int64 v102; 
  unsigned int v103; 
  signed __int32 v104[8]; 
  XModel *detailModel; 
  XModel *xModel; 
  __int64 v107; 
  hknpShape *v108; 
  char v109; 
  char v110[3]; 
  Physics_WorldId worldIda; 
  unsigned __int16 v112; 
  int numInOut; 
  unsigned int instanceIda; 
  int v115; 
  int p; 
  hknpBodyId bodyId; 
  int shapeSizeOut; 
  unsigned int index; 
  unsigned int v120; 
  int v121; 
  int v122; 
  int v123; 
  int v124; 
  int v125; 
  unsigned int v126; 
  hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId; 
  __int64 v128; 
  char *v129; 
  int v130; 
  int v131; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const HavokPhysicsAsset *v133; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  HavokPhysicsInstanceManager *manager; 
  int v136; 
  HavokPhysicsShapeList::ShapeTagData shapeTagData; 
  unsigned int wasNewKeyOut; 
  __int64 v139; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> > *v140; 
  unsigned __int64 key; 
  __int64 v142; 
  MemoryFile *p_memFile; 
  __int64 v144; 
  hknpSphereShape *v145; 
  hknpCompoundShapeCinfo cinfo; 
  __int64 v147[2]; 
  char dest[256]; 
  hkVector4f center; 
  hknpShape *shape; 
  int v151; 
  __int16 v152; 
  unsigned int v153; 
  unsigned __int16 v154; 
  char v155; 
  hkStringPtr v156; 
  unsigned __int64 v157; 
  char v158; 
  __int128 v159; 
  __int128 v160; 
  __int128 v161; 
  __int128 v162; 
  int v163; 
  hkReferencedObject *v164; 
  hkReferencedObject *v165; 
  __int16 v166; 
  int v167; 
  int v168; 
  int v169; 
  hkReferencedObject *v170; 
  char v171; 
  int v172; 
  hkVector4f v173; 
  hkVector4f v174; 
  hkVector4f v175; 
  hkVector4f v176; 
  hkVector4f a; 
  hkVector4f b; 

  v144 = -2i64;
  instanceIda = instanceId;
  worldIda = worldId;
  if ( !save && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4530, ASSERT_TYPE_ASSERT, "(save)", "%s\n\tHavokPhysics: LoadInstance has NULL save", "save") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(xModel) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4531, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to LoadInstance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", xModel) )
      __debugbreak();
  }
  if ( instanceId == -1 )
  {
    LODWORD(xModel) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4532, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics: Trying to LoadInstance with invalid instance id %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", xModel) )
      __debugbreak();
  }
  p_memFile = &save->memFile;
  CString = MemFile_ReadCString(&save->memFile);
  v9 = CString;
  if ( CString && *CString )
  {
    AssetByName = Physics_GetAssetByName(CString);
    v11 = AssetByName;
    if ( AssetByName )
    {
      HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(AssetByName);
      if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4539, ASSERT_TYPE_ASSERT, "(!physicsAsset || havokPhysicsAsset)", (const char *)&queryFormat, "!physicsAsset || havokPhysicsAsset") )
        __debugbreak();
      goto LABEL_21;
    }
  }
  else
  {
    v11 = NULL;
  }
  if ( !I_strempty(v9) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4537, ASSERT_TYPE_ASSERT, "(physicsAsset || I_strempty( physicsAssetName ))", (const char *)&queryFormat, "physicsAsset || I_strempty( physicsAssetName )") )
    __debugbreak();
  HavokPhysicsAsset = NULL;
LABEL_21:
  v12 = MemFile_ReadCString(&save->memFile);
  v13 = v12;
  if ( v12 && *v12 )
    v14 = Physics_GetAssetByName(v12);
  else
    v14 = NULL;
  if ( !v13 && !I_strempty(NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4542, ASSERT_TYPE_ASSERT, "(physicsAssetAddendumName || I_strempty( physicsAssetAddendumName ))", (const char *)&queryFormat, "physicsAssetAddendumName || I_strempty( physicsAssetAddendumName )") )
    __debugbreak();
  if ( v14 )
  {
    v133 = HavokPhysics_GetHavokPhysicsAsset(v14);
    if ( !v133 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4544, ASSERT_TYPE_ASSERT, "(!physicsAssetAddendum || havokPhysicsAssetAddendum)", (const char *)&queryFormat, "!physicsAssetAddendum || havokPhysicsAssetAddendum") )
      __debugbreak();
  }
  else
  {
    v133 = NULL;
  }
  v15 = MemFile_ReadCString(&save->memFile);
  physicsLibrary = NULL;
  HavokPhysicsXModelLODFromDetailCol = NULL;
  if ( v15 && *v15 )
  {
    v17.physicsLibrary = DB_FindXAssetHeader(ASSET_TYPE_XMODEL, v15, 0).physicsLibrary;
    physicsLibrary = (XModel *)v17.physicsLibrary;
    if ( (!v17.physicsLibrary || (HIDWORD(v17.physicsLibrary[1].name) & 0x8000) != 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4554, ASSERT_TYPE_ASSERT, "(detailModel && !XModelIsDefaultAsset( detailModel ))", (const char *)&queryFormat, "detailModel && !XModelIsDefaultAsset( detailModel )") )
      __debugbreak();
    if ( !physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 8083, ASSERT_TYPE_ASSERT, "(xmodel)", "%s\n\tHavok Physics: Trying to Get Havok Physics XModel LOD from NULL XModel", "xmodel") )
      __debugbreak();
    HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(physicsLibrary->detailCollision);
  }
  v18 = MemFile_ReadCString(&save->memFile);
  model = NULL;
  if ( v18 )
  {
    if ( *v18 )
    {
      model = DB_FindXAssetHeader(ASSET_TYPE_XMODEL, v18, 0).model;
      if ( !model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4565, ASSERT_TYPE_ASSERT, "(xModel)", (const char *)&queryFormat, "xModel") )
        __debugbreak();
    }
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(xModel) = worldIda;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4570, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics LoadInstance %i: world is NULL", "physicsWorld->world", xModel) )
      __debugbreak();
  }
  manager = &MutableWorld->instanceManager;
  detailModel = physicsLibrary;
  v21 = v11;
  v22 = instanceIda;
  p_instanceManager = &MutableWorld->instanceManager;
  HavokPhysicsInstanceManager_Load(save, &MutableWorld->instanceManager, instanceIda, v21, v14, detailModel, model);
  v24 = &save->memFile;
  MemFile_ReadData(&save->memFile, 4ui64, &p);
  v122 = p;
  v25 = 0;
  v115 = 0;
  v26 = p;
  v139 = p;
  if ( p > 0 )
  {
    v27 = 0i64;
    v128 = 0i64;
    p_bodyData = &snapshotFixup->bodyData;
    v140 = p_bodyData;
    while ( 1 )
    {
      MemFile_ReadData(v24, 4ui64, &bodyId);
      m_serialAndIndex = bodyId.m_serialAndIndex;
      MemFile_ReadData(v24, 8ui64, &v142);
      v147[1] = v142;
      v30 = MemFile_ReadCString(v24);
      Core_strcpy(dest, 0x100ui64, v30);
      HavokPhysicsInstanceManager_AddBody(manager, v22, (hknpBodyId)m_serialAndIndex);
      v108 = NULL;
      if ( HavokPhysicsAsset )
        break;
      if ( !HavokPhysicsXModelLODFromDetailCol )
      {
        MemFile_ReadData(v24, 4ui64, &v123);
        switch ( v123 )
        {
          case 1:
            MemFile_ReadData(v24, 4ui64, &v125);
            if ( v125 != 1 )
            {
              v95 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4816, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_LoadInstance: Unsupported convex shape");
              goto LABEL_164;
            }
            ShapeData_PlayerClip = PhysicsCoverWall_ReadShapeData_PlayerClip(v24);
            goto LABEL_160;
          case 2:
            Float = MemFile_ReadFloat(v24);
            v80 = *(float *)&Float;
            MemFile_ReadFloat(v24);
            MemFile_ReadFloat(v24);
            MemFile_ReadFloat(v24);
            _XMM1 = 0i64;
            __asm
            {
              vinsertps xmm1, xmm1, xmm7, 0
              vinsertps xmm1, xmm1, xmm6, 10h
              vinsertps xmm1, xmm1, xmm0, 20h ; ' '
            }
            v176.m_quad = _XMM1;
            ShapeData_PlayerClip = HavokPhysics_CreateShapeSphere(&v176, v80, NULL, 0);
            goto LABEL_160;
          case 3:
            v85 = MemFile_ReadFloat(v24);
            v86 = *(float *)&v85;
            MemFile_ReadFloat(v24);
            MemFile_ReadFloat(v24);
            MemFile_ReadFloat(v24);
            MemFile_ReadFloat(v24);
            MemFile_ReadFloat(v24);
            MemFile_ReadFloat(v24);
            _XMM1 = 0i64;
            __asm
            {
              vinsertps xmm1, xmm1, xmm10, 0
              vinsertps xmm1, xmm1, xmm9, 10h
              vinsertps xmm1, xmm1, xmm7, 20h ; ' '
            }
            a.m_quad = _XMM1;
            _XMM2 = 0i64;
            __asm
            {
              vinsertps xmm2, xmm2, xmm8, 0
              vinsertps xmm2, xmm2, xmm6, 10h
              vinsertps xmm2, xmm2, xmm0, 20h ; ' '
            }
            b.m_quad = _XMM2;
            ShapeData_PlayerClip = HavokPhysics_CreateShapeCapsulePoints(worldIda, &a, &b, v86, NULL, 0, Permanent);
            goto LABEL_160;
          case 9:
            ShapeData_PlayerClip = (hknpShape *)WorldCollision_GetShapeForLoad(worldIda, v22);
            goto LABEL_160;
          case 12:
          case 22:
            MemFile_ReadData(v24, 4ui64, &v124);
            switch ( v124 )
            {
              case 0:
                ShapeData_PlayerClip = (hknpShape *)StaticModels_GetShapeForLoad(worldIda, v22);
                goto LABEL_160;
              case 1:
                ShapeData_PlayerClip = PhysicsCoverWall_ReadShapeData(v24);
                goto LABEL_160;
              case 2:
                ShapeData_PlayerClip = (hknpShape *)PatchCollision_GetShapeForLoad(worldIda, v22);
                goto LABEL_160;
            }
            v95 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4801, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_LoadInstance: Unsupported compound/User_0 shape");
LABEL_164:
            if ( v95 )
              __debugbreak();
            v71 = v108;
            break;
          default:
            v95 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4830, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_LoadInstance: Unsupported shape");
            goto LABEL_164;
        }
LABEL_167:
        LODWORD(xModel) = m_serialAndIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4834, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tInvalid shape for body %d", "shape", xModel) )
          __debugbreak();
        goto LABEL_169;
      }
      if ( v25 == v122 - 1 && v26 > 1 )
      {
        v72 = MemFile_ReadFloat(v24);
        v73 = *(float *)&v72;
        MemFile_ReadFloat(v24);
        MemFile_ReadFloat(v24);
        MemFile_ReadFloat(v24);
        _XMM1 = 0i64;
        __asm
        {
          vinsertps xmm1, xmm1, xmm7, 0
          vinsertps xmm1, xmm1, xmm6, 10h
          vinsertps xmm1, xmm1, xmm0, 20h ; ' '
        }
        v174.m_quad = _XMM1;
        ShapeData_PlayerClip = HavokPhysics_CreateShapeSphere(&v174, v73, NULL, 0);
      }
      else
      {
        if ( v25 < HavokPhysicsXModelLODFromDetailCol->m_shapes.m_size )
        {
          v71 = HavokPhysicsXModelLODFromDetailCol->m_shapes.m_data[v27];
          goto LABEL_161;
        }
        Com_PrintWarning(20, "Savegame was expecting more rigid bodies than it found - creating a placeholder sphere\n");
        v175.m_quad = 0i64;
        ShapeData_PlayerClip = HavokPhysics_CreateShapeSphere(&v175, 0.000099999997, NULL, 0);
      }
LABEL_160:
      v71 = ShapeData_PlayerClip;
LABEL_161:
      if ( !v71 )
        goto LABEL_167;
LABEL_169:
      v147[0] = (__int64)v71;
      _InterlockedOr(v104, 0);
      m_refCount = v71->m_refCount;
      _InterlockedOr(v104, 0);
      if ( !m_refCount )
      {
        if ( *(_WORD *)(v147[0] + 16) )
        {
          LODWORD(v107) = m_serialAndIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4837, ASSERT_TYPE_ASSERT, "(data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0)", "%s\n\tNo references for Shape for body %s wiki id %d", "data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0", dest, v107) )
            __debugbreak();
        }
      }
      key = m_serialAndIndex;
      v97 = hkMemHeapAllocator();
      EmptyPositionInternal = hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64>>::_findEmptyPositionInternal(p_bodyData, v97, &key, &wasNewKeyOut);
      p_bodyData->m_elem[EmptyPositionInternal].key = m_serialAndIndex;
      p_val = &p_bodyData->m_elem[EmptyPositionInternal].val;
      if ( &p_bodyData->m_elem[EmptyPositionInternal] != (hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *)-8i64 )
      {
        v100 = v147;
        v101 = 2i64;
        do
        {
          *(_OWORD *)&p_val->shape = *(_OWORD *)v100;
          *(_OWORD *)p_val->name = *((_OWORD *)v100 + 1);
          *(_OWORD *)&p_val->name[16] = *((_OWORD *)v100 + 2);
          *(_OWORD *)&p_val->name[32] = *((_OWORD *)v100 + 3);
          *(_OWORD *)&p_val->name[48] = *((_OWORD *)v100 + 4);
          *(_OWORD *)&p_val->name[64] = *((_OWORD *)v100 + 5);
          *(_OWORD *)&p_val->name[80] = *((_OWORD *)v100 + 6);
          p_val = (HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *)((char *)p_val + 128);
          *(_OWORD *)&p_val[-1].name[240] = *((_OWORD *)v100 + 7);
          v100 += 16;
          --v101;
        }
        while ( v101 );
        *(_OWORD *)&p_val->shape = *(_OWORD *)v100;
      }
      v115 = ++v25;
      v128 = ++v27;
      v22 = instanceIda;
      if ( v27 >= v26 )
      {
        p_instanceManager = manager;
        goto LABEL_179;
      }
    }
    v31 = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v27];
    v32 = *(hknpShape **)v31;
    shape = v32;
    if ( v32 )
      hkReferencedObject::addReference(v32);
    v151 = *(_DWORD *)(v31 + 8);
    v152 = *(_WORD *)(v31 + 12);
    v153 = *(_DWORD *)(v31 + 16);
    v154 = *(_WORD *)(v31 + 20);
    v155 = *(_BYTE *)(v31 + 22);
    hkStringPtr::hkStringPtr(&v156, (const hkStringPtr *)(v31 + 24));
    v157 = *(_QWORD *)(v31 + 32);
    v158 = *(_BYTE *)(v31 + 40);
    v159 = *(_OWORD *)(v31 + 48);
    v160 = *(_OWORD *)(v31 + 64);
    v161 = *(_OWORD *)(v31 + 80);
    v162 = *(_OWORD *)(v31 + 96);
    v163 = *(_DWORD *)(v31 + 112);
    v33 = *(hkReferencedObject **)(v31 + 120);
    v164 = v33;
    if ( v33 )
      hkReferencedObject::addReference(v33);
    v34 = *(hkReferencedObject **)(v31 + 128);
    v165 = v34;
    if ( v34 )
      hkReferencedObject::addReference(v34);
    v166 = *(_WORD *)(v31 + 136);
    v167 = *(_DWORD *)(v31 + 140);
    v168 = *(_DWORD *)(v31 + 144);
    v169 = *(_DWORD *)(v31 + 148);
    v35 = *(hkReferencedObject **)(v31 + 152);
    v170 = v35;
    if ( v35 )
      hkReferencedObject::addReference(v35);
    v171 = *(_BYTE *)(v31 + 160);
    v172 = *(_DWORD *)(v31 + 176);
    v36 = shape;
    v108 = shape;
    MemFile_ReadData(v24, 1ui64, &v109);
    if ( v109 )
    {
      if ( (v36->m_type.m_storage != 12 || !v36->getMutationSignals(v36)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4605, ASSERT_TYPE_ASSERT, "(shape->getType() == hknpShapeType::COMPOUND && shape->isMutable())", (const char *)&queryFormat, "shape->getType() == hknpShapeType::COMPOUND && shape->isMutable()") )
        __debugbreak();
      Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !Value )
        Value = hkMemoryRouter::s_fallbackRouter;
      v38 = (hknpMaskedShape *)Value->m_heap->blockAlloc(Value->m_heap, 104i64);
      v108 = v38;
      if ( v38 )
      {
        hknpMaskedShape::hknpMaskedShape(v38, v36);
        v40 = v39;
      }
      else
      {
        v40 = 0i64;
      }
      v108 = (hknpShape *)v40;
      if ( !v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4611, ASSERT_TYPE_ASSERT, "(maskedShape)", (const char *)&queryFormat, "maskedShape") )
        __debugbreak();
      v41 = *(_QWORD *)(v40 + 56);
      if ( *(_BYTE *)(v41 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4615, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
        __debugbreak();
      v42 = *(_DWORD *)(v41 + 80);
      v43 = 0;
      v136 = 0;
      if ( v42 > 0 )
      {
        v44 = *(_QWORD *)(v41 + 72);
        while ( 1 )
        {
          v45 = v136;
          if ( !*(_BYTE *)(112i64 * (unsigned __int16)v136 + v44 + 92) )
            break;
          v136 = ++v43;
          if ( v43 >= v42 )
            goto LABEL_91;
        }
        while ( v43 != -1 )
        {
          v46 = (0xFFFFFFFF >> *(_BYTE *)(v41 + 27)) | (v45 << (32 - *(_BYTE *)(v41 + 27)));
          MemFile_ReadData(v24, 1ui64, v110);
          (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(v40 + 72) + 16i64))(v40 + 72, v46, (unsigned __int8)v110[0]);
          v47 = *(_DWORD *)(v41 + 80);
          v136 = ++v43;
          if ( v43 >= v47 )
            break;
          v48 = *(_QWORD *)(v41 + 72);
          while ( 1 )
          {
            v45 = v136;
            if ( !*(_BYTE *)(112i64 * (unsigned __int16)v136 + v48 + 92) )
              break;
            v136 = ++v43;
            if ( v43 >= v47 )
              goto LABEL_91;
          }
        }
      }
LABEL_91:
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 264i64))(v40);
      v27 = v128;
      goto LABEL_103;
    }
    MemFile_ReadData(v24, 4ui64, &index);
    v49 = MemFile_ReadFloat(v24);
    v50 = *(float *)&v49;
    v51 = MemFile_ReadFloat(v24);
    if ( v50 <= 0.0 )
    {
      v56 = index;
      if ( index == -1 || !WorldCollision_GetMapEntsShape(index) )
        goto LABEL_103;
      MapEntsShape = WorldCollision_GetMapEntsShape(v56);
    }
    else
    {
      if ( *(float *)&v51 == 0.0 )
      {
        v173.m_quad = 0i64;
        v53 = (hknpSphereShape *)hknpConvexShape::allocateConvexShape(1, 64, &shapeSizeOut);
        v145 = v53;
        v108 = v53;
        if ( v53 )
        {
          hknpSphereShape::hknpSphereShape(v53, &v173, v50);
          v55 = v54;
        }
        else
        {
          v55 = NULL;
        }
        v108 = v55;
        v55->m_memSizeAndFlags = shapeSizeOut;
        goto LABEL_103;
      }
      center.m_quad = 0i64;
      center.m_quad.m128_f32[2] = (float)(*(float *)&v51 * 0.5) + 0.0;
      MapEntsShape = HavokPhysics_CreateShapeCylinder(&center, *(float *)&v51 * 0.5, v50, 32, 0);
    }
    v108 = MapEntsShape;
LABEL_103:
    MemFile_ReadData(v24, 4ui64, &v120);
    if ( !v27 && v133 )
    {
      m_ptr = v133->m_physicsSystemData->m_bodyCinfos.m_data->m_shape.m_ptr;
      v58 = v120;
      if ( v120 != -1 && WorldCollision_GetMapEntsShape(v120) )
      {
        m_ptr = WorldCollision_GetMapEntsShape(v58);
        LODWORD(v27) = HavokPhysics_GetShapeOverrideContents(v58);
      }
      shapeTagData.m_collisionFilterInfo = v153;
      shapeTagData.m_materialCRC = 0;
      shapeTagData.m_materialId.m_value = v154;
      shapeTagData.m_userData = v157;
      ShapeTag = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
      shapeTagData.m_collisionFilterInfo = v27;
      v112 = HavokPhysicsShapeTagCodec::findShapeTag(s_shapeTagCodec, &shapeTagData);
      v153 |= v27;
      numInOut = 2;
      v60 = hkMemHeapAllocator();
      v61 = numInOut;
      v62 = numInOut;
      if ( numInOut )
      {
        v63 = (char *)hkMemoryAllocator::bufAlloc2(v60, 112, &numInOut);
        v61 = numInOut;
      }
      else
      {
        v63 = NULL;
      }
      v64 = 0x80000000;
      if ( v61 )
        v64 = v61;
      v129 = v63;
      v130 = v62;
      v131 = v64;
      if ( v63 )
      {
        *(__m256i *)v63 = *(__m256i *)g_vectorfConstants[32].m128_f32;
        *((__m256i *)v63 + 1) = *(__m256i *)g_vectorfConstants[34].m128_f32;
        *((__m128 *)v63 + 4) = g_vectorfConstants[6];
        *((_QWORD *)v63 + 10) = 0i64;
        *((_DWORD *)v63 + 22) = -1;
        v63[92] = 0;
        *((_DWORD *)v63 + 24) = 0;
        *((_WORD *)v63 + 50) = -1;
        *((_QWORD *)v63 + 13) = 0i64;
        v121 = 64;
        *((_DWORD *)v63 + 3) = 1056964672;
      }
      if ( v63 != (char *)-112i64 )
      {
        *(__m256i *)(v63 + 112) = *(__m256i *)g_vectorfConstants[32].m128_f32;
        *(__m256i *)(v63 + 144) = *(__m256i *)g_vectorfConstants[34].m128_f32;
        *((__m128 *)v63 + 11) = g_vectorfConstants[6];
        *((_QWORD *)v63 + 24) = 0i64;
        *((_DWORD *)v63 + 50) = -1;
        v63[204] = 0;
        *((_DWORD *)v63 + 52) = 0;
        *((_WORD *)v63 + 106) = -1;
        *((_QWORD *)v63 + 27) = 0i64;
        v121 = 64;
        *((_DWORD *)v63 + 31) = 1056964672;
      }
      hknpShapeInstance::setShape((hknpShapeInstance *)v63, v108);
      hknpShapeInstance::setShape((hknpShapeInstance *)v63 + 1, m_ptr);
      *((_WORD *)v63 + 44) = ShapeTag;
      *((_WORD *)v63 + 100) = v112;
      hknpCompoundShapeCinfo::hknpCompoundShapeCinfo(&cinfo);
      cinfo.m_instances = (const hknpShapeInstance *)v63;
      cinfo.m_numInstances = v62;
      v65 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v65 )
        v65 = hkMemoryRouter::s_fallbackRouter;
      v66 = (hknpCompoundShape *)v65->m_heap->blockAlloc(v65->m_heap, 288i64);
      v108 = v66;
      if ( v66 )
      {
        hknpCompoundShape::hknpCompoundShape(v66, &cinfo);
        v108 = v67;
      }
      else
      {
        v108 = NULL;
      }
      v68 = hkMemHeapAllocator();
      v69 = v62 - 1;
      if ( v62 - 1 >= 0 )
      {
        v70 = (hkReferencedObject **)&v63[112 * v69 + 80];
        do
        {
          if ( *v70 )
            hkReferencedObject::removeReference(*v70);
          v70 -= 14;
          --v69;
        }
        while ( v69 >= 0 );
      }
      v130 = 0;
      if ( v64 >= 0 )
        hkMemoryAllocator::bufFree2(v68, v63, 112, v64 & 0x3FFFFFFF);
      v129 = NULL;
      v131 = 0x80000000;
      v24 = p_memFile;
      v27 = v128;
    }
    if ( v170 )
      hkReferencedObject::removeReference(v170);
    if ( v165 )
      hkReferencedObject::removeReference(v165);
    if ( v164 )
      hkReferencedObject::removeReference(v164);
    hkStringPtr::~hkStringPtr(&v156);
    if ( shape )
      hkReferencedObject::removeReference(shape);
    v71 = v108;
    v25 = v115;
    v26 = v139;
    p_bodyData = v140;
    goto LABEL_161;
  }
LABEL_179:
  MemFile_ReadData(v24, 4ui64, &v126);
  if ( (int)v126 > 0 )
  {
    v102 = v126;
    v103 = instanceIda;
    do
    {
      MemFile_ReadData(v24, 4ui64, &constraintId);
      HavokPhysicsInstanceManager_AddConstraint(p_instanceManager, v103, constraintId);
      --v102;
    }
    while ( v102 );
  }
}

/*
==============
HavokPhysics_LoadSnapshot
==============
*/
void HavokPhysics_LoadSnapshot(SaveGame *save, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 
  unsigned __int64 v6; 
  hkMemoryAllocator *v7; 
  int EmptyPositionInternal; 
  __int64 v9; 
  hkMemoryRouter *Value; 
  unsigned __int64 v11; 
  void *v12; 
  hkMemoryRouter *v13; 
  hknpWorld *world; 
  hknpThreadSafeObjectPoolElement<hknpBody> *m_data; 
  unsigned int v16; 
  unsigned int v17; 
  __int64 v18; 
  __int64 m_serialAndIndex; 
  unsigned __int32 v20; 
  unsigned __int32 v21; 
  int v22; 
  int v23; 
  unsigned __int64 v24; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *p_val; 
  char *v26; 
  __int64 v27; 
  hkMemoryAllocator *v28; 
  int m_hashMod; 
  __int64 v30; 
  __int64 v31; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  signed int v33; 
  hkMemoryAllocator *v34; 
  int v35; 
  __int64 v36; 
  __int64 v37; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *v38; 
  signed int v39; 
  unsigned int instanceId; 
  unsigned int p; 
  HavokPhysics_SnapshotFixup snapshotFixup; 
  unsigned int v43; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint v44; 
  unsigned int wasNewKeyOut; 
  unsigned __int64 key[2]; 
  hkMemoryStreamReader v47; 
  char v48; 
  unsigned __int64 v49; 
  char string[256]; 

  key[1] = -2i64;
  snapshotFixup.__vftable = (HavokPhysics_SnapshotFixup_vtbl *)&HavokPhysics_SnapshotFixup::`vftable';
  snapshotFixup.bodyData.m_elem = NULL;
  snapshotFixup.bodyData.m_numElems = 0;
  snapshotFixup.bodyData.m_hashMod = -1;
  snapshotFixup.constraintData.m_elem = NULL;
  snapshotFixup.constraintData.m_numElems = 0;
  snapshotFixup.constraintData.m_hashMod = -1;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5077, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Load serverworld main is NULL", "world->world") )
    __debugbreak();
  hknpWorld::checkConsistency(MutableWorld->world);
  snapshotFixup.worldId = worldId;
  HavokPhysics_ReadWorld(save, worldId, &snapshotFixup);
  if ( !HavokPhysics_GetMutableWorld(worldId)->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4918, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Read serverworld main is NULL", "world->world") )
    __debugbreak();
  MemFile_ReadData(&save->memFile, 4ui64, &p);
  if ( (int)p > 0 )
  {
    v5 = p;
    do
    {
      MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
      MemFile_ReadData(&save->memFile, 4ui64, &p);
      v44.instanceId = p;
      MemFile_ReadData(&save->memFile, 4ui64, &v43);
      v44.constraintIdx = v43;
      v6 = (int)instanceId;
      key[0] = (int)instanceId;
      v7 = hkMemHeapAllocator();
      EmptyPositionInternal = hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64>>::_findEmptyPositionInternal(&snapshotFixup.constraintData, v7, key, &wasNewKeyOut);
      snapshotFixup.constraintData.m_elem[EmptyPositionInternal].key = v6;
      if ( &snapshotFixup.constraintData.m_elem[EmptyPositionInternal] != (hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *)-8i64 )
        snapshotFixup.constraintData.m_elem[EmptyPositionInternal].val = v44;
      --v5;
    }
    while ( v5 );
  }
  MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
  if ( instanceId )
  {
    v9 = instanceId;
    do
    {
      MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
      HavokPhysics_LoadInstance(save, worldId, instanceId, &snapshotFixup);
      --v9;
    }
    while ( v9 );
  }
  HavokPhysics_SnapshotFixup::Validate(&snapshotFixup, MutableWorld);
  MemFile_ReadData(&save->memFile, 4ui64, &instanceId);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v11 = (int)instanceId;
  v12 = Value->m_heap->blockAlloc(Value->m_heap, instanceId);
  MemFile_ReadData(&save->memFile, v11, v12);
  hkMemoryStreamReader::hkMemoryStreamReader(&v47, v12, v11, MEMORY_INPLACE, 0i64);
  NpSimulationSnapshot::importSimulationState(MutableWorld->world, &v47, &snapshotFixup);
  v13 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !v13 )
    v13 = hkMemoryRouter::s_fallbackRouter;
  v13->m_heap->blockFree(v13->m_heap, v12, v11);
  world = MutableWorld->world;
  m_data = world->m_bodyManager.m_bodies.m_objects.m_data;
  v16 = world->m_bodyManager.m_bodies.m_peakIndex + 1;
  v17 = 0;
  if ( world->m_bodyManager.m_bodies.m_numAllocated )
  {
    if ( (m_data->m_pod.m_flags.m_storage & 0xF) != 0 )
      goto LABEL_37;
    v17 = 1;
    if ( v16 > 1 )
    {
      while ( (m_data[v17].m_pod.m_flags.m_storage & 0xF) == 0 )
      {
        if ( ++v17 >= v16 )
          goto LABEL_38;
      }
      if ( v17 != -1 )
      {
LABEL_37:
        do
        {
          v18 = v17;
          m_serialAndIndex = m_data[v18].m_pod.m_id.m_serialAndIndex;
          if ( snapshotFixup.bodyData.m_hashMod <= 0 || (v20 = _byteswap_ulong(-1640531535 * m_serialAndIndex), v21 = _byteswap_ulong(0), v22 = snapshotFixup.bodyData.m_hashMod & (v21 ^ ((v20 >> 2) + v20 + (v21 << 6) - 1640531527)), v23 = v22, v24 = snapshotFixup.bodyData.m_elem[v22].key, v24 == -1i64) )
          {
LABEL_30:
            v23 = snapshotFixup.bodyData.m_hashMod + 1;
          }
          else
          {
            while ( v24 != m_serialAndIndex )
            {
              v22 = snapshotFixup.bodyData.m_hashMod & (v22 + 1);
              v23 = v22;
              v24 = snapshotFixup.bodyData.m_elem[v22].key;
              if ( v24 == -1i64 )
                goto LABEL_30;
            }
          }
          p_val = &snapshotFixup.bodyData.m_elem[v23].val;
          v26 = &v48;
          v27 = 2i64;
          do
          {
            *(_OWORD *)v26 = *(_OWORD *)&p_val->shape;
            *((_OWORD *)v26 + 1) = *(_OWORD *)p_val->name;
            *((_OWORD *)v26 + 2) = *(_OWORD *)&p_val->name[16];
            *((_OWORD *)v26 + 3) = *(_OWORD *)&p_val->name[32];
            *((_OWORD *)v26 + 4) = *(_OWORD *)&p_val->name[48];
            *((_OWORD *)v26 + 5) = *(_OWORD *)&p_val->name[64];
            *((_OWORD *)v26 + 6) = *(_OWORD *)&p_val->name[80];
            v26 += 128;
            *((_OWORD *)v26 - 1) = *(_OWORD *)&p_val->name[96];
            p_val = (HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *)((char *)p_val + 128);
            --v27;
          }
          while ( v27 );
          *(_OWORD *)v26 = *(_OWORD *)&p_val->shape;
          m_data[v18].m_pod.m_userData = v49;
          hkStringPtr::operator=(&MutableWorld->world->m_bodyManager.m_bodyNames.m_data[m_data[v18].m_pod.m_id.m_serialAndIndex & 0xFFFFFF], string);
          if ( ++v17 >= v16 )
          {
LABEL_36:
            v17 = -1;
          }
          else
          {
            while ( (m_data[v17].m_pod.m_flags.m_storage & 0xF) == 0 )
            {
              if ( ++v17 >= v16 )
                goto LABEL_36;
            }
          }
        }
        while ( v17 != -1 );
      }
    }
  }
LABEL_38:
  v28 = hkMemHeapAllocator();
  m_hashMod = snapshotFixup.bodyData.m_hashMod;
  if ( snapshotFixup.bodyData.m_hashMod && (v30 = snapshotFixup.bodyData.m_hashMod + 1, snapshotFixup.bodyData.m_hashMod + 1 > 0) )
  {
    v31 = 0i64;
    m_elem = snapshotFixup.bodyData.m_elem;
    do
    {
      if ( m_elem[v31].key != -1i64 )
      {
        m_elem[v31].key = -1i64;
        m_elem = snapshotFixup.bodyData.m_elem;
      }
      ++v31;
      --v30;
    }
    while ( v30 );
    m_hashMod = snapshotFixup.bodyData.m_hashMod;
  }
  else
  {
    m_elem = snapshotFixup.bodyData.m_elem;
  }
  v33 = snapshotFixup.bodyData.m_numElems & 0x80000000;
  snapshotFixup.bodyData.m_numElems &= 0x80000000;
  if ( m_elem && v33 >= 0 )
    v28->blockFree(v28, m_elem, 280 * (m_hashMod + 1));
  snapshotFixup.bodyData.m_elem = NULL;
  snapshotFixup.bodyData.m_numElems = 0;
  snapshotFixup.bodyData.m_hashMod = -1;
  v34 = hkMemHeapAllocator();
  v35 = snapshotFixup.constraintData.m_hashMod;
  if ( snapshotFixup.constraintData.m_hashMod && (v36 = snapshotFixup.constraintData.m_hashMod + 1, snapshotFixup.constraintData.m_hashMod + 1 > 0) )
  {
    v37 = 0i64;
    v38 = snapshotFixup.constraintData.m_elem;
    do
    {
      if ( v38[v37].key != -1i64 )
      {
        v38[v37].key = -1i64;
        v38 = snapshotFixup.constraintData.m_elem;
      }
      ++v37;
      --v36;
    }
    while ( v36 );
    v35 = snapshotFixup.constraintData.m_hashMod;
  }
  else
  {
    v38 = snapshotFixup.constraintData.m_elem;
  }
  v39 = snapshotFixup.constraintData.m_numElems & 0x80000000;
  snapshotFixup.constraintData.m_numElems &= 0x80000000;
  if ( v38 && v39 >= 0 )
    v34->blockFree(v34, v38, 16 * (v35 + 1));
  snapshotFixup.constraintData.m_elem = NULL;
  snapshotFixup.constraintData.m_numElems = 0;
  snapshotFixup.constraintData.m_hashMod = -1;
  hkMemoryStreamReader::~hkMemoryStreamReader(&v47);
}

/*
==============
HavokPhysics_LockAssetRead
==============
*/
void HavokPhysics_LockAssetRead(void)
{
  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_LockAssetWrite
==============
*/
void HavokPhysics_LockAssetWrite(void)
{
  int v0; 

  Sys_CheckAcquireLock(&s_havokPhysicsAssetLock);
  AcquireSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  s_havokPhysicsAssetLock.writeThreadId = Sys_GetCurrentThreadId();
  if ( !s_havokPhysicsAssetLock.writeThreadId )
  {
    v0 = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 177, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) != ( INVALID_THREAD_ID )", "%s != %s\n\t%i, %i", "lock->writeThreadId", "INVALID_THREAD_ID", v0, 0i64) )
      __debugbreak();
  }
}

/*
==============
HavokPhysics_LockWorld
==============
*/
void HavokPhysics_LockWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6423, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to lock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_LoosenConstraint
==============
*/
char HavokPhysics_LoosenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *result)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int *v6; 
  __int64 v7; 
  unsigned int v8; 
  const hkTransformf *v9; 
  __int64 v10; 
  const hkTransformf *v11; 
  int v12; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v6 = (unsigned int *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, constraintId.m_value);
  v7 = *((_QWORD *)v6 + 1);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13458, ASSERT_TYPE_ASSERT, "(constraintData)", (const char *)&queryFormat, "constraintData") )
    __debugbreak();
  v8 = v6[1];
  v9 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, *v6);
  v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, v8);
  *(_DWORD *)&result->coneChanged = 0;
  v11 = (const hkTransformf *)v10;
  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24i64))(v7);
  if ( v12 == 2 )
  {
    if ( result == (PhysicsConstraintLooseningResult *)-4i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13260, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    result->before.ragdoll.cone = *(float *)(v7 + 248);
    result->before.ragdoll.planeMin = *(float *)(v7 + 252);
    HavokPhysics_LoosenHingeConstraint((hkpLimitedHingeConstraintData::Atoms *)(v7 + 32), v9, v11, result);
  }
  else
  {
    if ( v12 != 7 )
      return 0;
    if ( result == (PhysicsConstraintLooseningResult *)-4i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13249, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
      __debugbreak();
    result->before.ragdoll.cone = *(float *)(v7 + 348);
    result->before.ragdoll.planeMin = *(float *)(v7 + 376);
    result->before.ragdoll.planeMax = *(float *)(v7 + 380);
    result->before.ragdoll.twistMin = *(float *)(v7 + 312);
    result->before.ragdoll.twistMax = *(float *)(v7 + 316);
    HavokPhysics_LoosenRagdollConstraint((hkpRagdollConstraintData::Atoms *)(v7 + 32), v9, v11, result);
  }
  return 1;
}

/*
==============
HavokPhysics_LoosenHingeConstraint
==============
*/
void HavokPhysics_LoosenHingeConstraint(hkpLimitedHingeConstraintData::Atoms *atoms, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  hkVector4f v8; 
  hkVector4f v9; 
  hkVector4f v10; 
  hkVector4f v11; 
  hkVector4f v12; 
  __m128 v22; 
  bool v29; 
  float v30; 
  char v31; 
  __m128 resulta; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13354, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  v8.m_quad = (__m128)atoms->m_transforms.m_transformA.m_rotation.m_col1;
  v9.m_quad = (__m128)bodyBTransform->m_rotation.m_col0;
  v10.m_quad = (__m128)bodyBTransform->m_rotation.m_col1;
  v11.m_quad = (__m128)bodyBTransform->m_rotation.m_col2;
  v12.m_quad = (__m128)atoms->m_transforms.m_transformB.m_rotation.m_col2;
  _XMM12 = LODWORD(result->before.ragdoll.cone);
  _XMM13 = LODWORD(result->before.ragdoll.planeMin);
  _XMM11 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v8.m_quad, v8.m_quad, 85), bodyATransform->m_rotation.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v8.m_quad, v8.m_quad, 0), bodyATransform->m_rotation.m_col0.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v8.m_quad, v8.m_quad, 170), bodyATransform->m_rotation.m_col2.m_quad));
  _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(atoms->m_transforms.m_transformB.m_rotation.m_col1.m_quad, atoms->m_transforms.m_transformB.m_rotation.m_col1.m_quad, 0), bodyBTransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(atoms->m_transforms.m_transformB.m_rotation.m_col1.m_quad, atoms->m_transforms.m_transformB.m_rotation.m_col1.m_quad, 85), v10.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(atoms->m_transforms.m_transformB.m_rotation.m_col1.m_quad, atoms->m_transforms.m_transformB.m_rotation.m_col1.m_quad, 170), v11.m_quad));
  _XMM1 = g_vectorfConstants[6];
  __asm
  {
    vdpps   xmm3, xmm11, xmm2, 7Fh
    vcmpltps xmm0, xmm3, xmm1
    vblendvps xmm2, xmm1, xmm3, xmm0
  }
  _XMM1 = g_vectorfConstants[4];
  __asm { vmaxps  xmm2, xmm1, xmm2 }
  resulta = _XMM2;
  hkMath::quadAsin(&resulta, &bodyATransform->m_rotation.m_col0.m_quad);
  v22 = _XMM0;
  _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v12.m_quad, v12.m_quad, 0), v9.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v12.m_quad, v12.m_quad, 85), v10.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v12.m_quad, v12.m_quad, 170), v11.m_quad));
  __asm
  {
    vdpps   xmm4, xmm11, xmm3, 7Fh
    vcmpltps xmm2, xmm4, xmm1
    vpsrld  xmm0, xmm2, 1Fh
    vpslld  xmm3, xmm0, 1Fh
  }
  if ( COERCE_FLOAT(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_piOver2, v22).m128_u32[0] ^ _XMM3) < 0.0 )
  {
    __asm { vminss  xmm3, xmm12, xmm1 }
    *((float *)&atoms->m_angLimit.m_type + 2) = *(float *)&_XMM3;
  }
  else
  {
    LODWORD(_XMM3) = *((_DWORD *)&atoms->m_angLimit.m_type + 2);
    __asm { vmaxss  xmm2, xmm13, xmm1 }
    *((float *)&atoms->m_angLimit.m_type + 3) = *(float *)&_XMM2;
  }
  v29 = *(float *)&_XMM3 == result->before.ragdoll.cone;
  result->after.ragdoll.cone = *(float *)&_XMM3;
  v30 = *((float *)&atoms->m_angLimit.m_type + 3);
  result->after.ragdoll.planeMin = v30;
  v31 = !v29;
  result->angChanged |= (v30 != result->before.ragdoll.planeMin) | v31;
}

/*
==============
HavokPhysics_LoosenRagdollConstraint
==============
*/
void HavokPhysics_LoosenRagdollConstraint(hkpRagdollConstraintData::Atoms *atoms, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  __m128 v8; 
  __int64 v9; 
  __m128 v10; 
  __int64 v11; 
  __m128 v12; 
  __m128 v13; 
  bool v23; 
  bool v24; 
  bool v25; 
  float v30; 
  char v31; 
  __int64 v32; 
  __m128 v33; 
  __m128 v34; 
  __int64 v35; 
  __m128 v36; 
  __m128 v37; 
  float v42; 
  char v43; 
  float twistAxisBinWorld; 
  hkVector4f twistAxisBinWorld_8; 
  hkVector4f twistAxisAinWorld_8; 
  __m128 result_8; 
  __m128 v48; 
  hkVector4f planeAxisBinWorld; 
  hkVector4f planeAxisAinWorld; 
  hkVector4f axisOut; 

  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13269, ASSERT_TYPE_ASSERT, "(result)", (const char *)&queryFormat, "result") )
    __debugbreak();
  v8 = *(&atoms->m_transforms.m_transformA.m_rotation.m_col0.m_quad + *((unsigned __int8 *)&atoms->m_coneLimit.m_type + 3));
  v9 = 2i64 * *((unsigned __int8 *)&atoms->m_coneLimit.m_type + 4);
  twistAxisAinWorld_8.m_quad = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v8, v8, 0), bodyATransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v8, v8, 85), bodyATransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v8, v8, 170), bodyATransform->m_rotation.m_col2.m_quad));
  v10 = *(__m128 *)((char *)&atoms->m_transforms.m_transformB.m_rotation.m_col0.m_quad + 8 * v9);
  v11 = 2i64 * *((unsigned __int8 *)&atoms->m_planesLimit.m_type + 4);
  twistAxisBinWorld_8.m_quad = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v10, v10, 0), bodyBTransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v10, v10, 85), bodyBTransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v10, v10, 170), bodyBTransform->m_rotation.m_col2.m_quad));
  v12 = *(__m128 *)((char *)&atoms->m_transforms.m_transformB.m_rotation.m_col0.m_quad + 8 * v11);
  _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v12, v12, 0), bodyBTransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v12, v12, 85), bodyBTransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v12, v12, 170), bodyBTransform->m_rotation.m_col2.m_quad));
  v13 = *(&atoms->m_transforms.m_transformA.m_rotation.m_col0.m_quad + *((unsigned __int8 *)&atoms->m_planesLimit.m_type + 3));
  _XMM1 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v13, v13, 0), bodyATransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v13, v13, 85), bodyATransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v13, v13, 170), bodyATransform->m_rotation.m_col2.m_quad));
  __asm
  {
    vdpps   xmm3, xmm1, xmm5, 7Fh
    vdpps   xmm0, xmm11, xmm10, 7Fh
    vunpcklps xmm2, xmm0, xmm3
  }
  _XMM0 = g_vectorfConstants[5];
  __asm
  {
    vunpcklps xmm1, xmm0, xmm0
    vmovlhps xmm0, xmm2, xmm1
  }
  result_8 = _XMM0;
  hkMath::quadAsin(&result_8, &bodyATransform->m_rotation.m_col0.m_quad);
  v48 = _mm128_sub_ps(*(__m128 *)hkMath::hkSse_piOver2, _XMM0);
  _XMM2 = LODWORD(result->before.ragdoll.cone);
  __asm { vmaxss  xmm2, xmm2, xmm1 }
  *((float *)&atoms->m_coneLimit.m_type + 3) = *(float *)&_XMM2;
  v23 = *(float *)&_XMM2 == result->before.ragdoll.cone;
  result->after.ragdoll.cone = *(float *)&_XMM2;
  v24 = !v23;
  v25 = v48.m128_f32[1] <= 1.5707964;
  _XMM2 = LODWORD(result->before.ragdoll.planeMin);
  result->coneChanged = v24;
  if ( v25 )
  {
    _XMM1 = LODWORD(result->before.ragdoll.planeMax);
    __asm { vmaxss  xmm3, xmm1, xmm2 }
    *((float *)&atoms->m_planesLimit.m_type + 3) = *(float *)&_XMM3;
  }
  else
  {
    LODWORD(_XMM3) = *((_DWORD *)&atoms->m_planesLimit.m_type + 3);
    __asm { vminss  xmm2, xmm2, xmm1 }
    *((float *)&atoms->m_planesLimit.m_type + 2) = *(float *)&_XMM2;
  }
  v23 = *(float *)&_XMM3 == result->before.ragdoll.planeMax;
  result->after.ragdoll.planeMax = *(float *)&_XMM3;
  v30 = *((float *)&atoms->m_planesLimit.m_type + 2);
  result->after.ragdoll.planeMin = v30;
  v31 = !v23;
  result->planeChanged |= (v30 != result->before.ragdoll.planeMin) | v31;
  v32 = 2i64 * *((unsigned __int8 *)&atoms->m_twistLimit.m_type + 3);
  v33 = *(&atoms->m_transforms.m_transformA.m_rotation.m_col0.m_quad + *((unsigned __int8 *)&atoms->m_twistLimit.m_type + 3));
  twistAxisAinWorld_8.m_quad = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v33, v33, 0), bodyATransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v33, v33, 85), bodyATransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v33, v33, 170), bodyATransform->m_rotation.m_col2.m_quad));
  v34 = *(__m128 *)((char *)&atoms->m_transforms.m_transformB.m_rotation.m_col0.m_quad + 8 * v32);
  v35 = *((unsigned __int8 *)&atoms->m_twistLimit.m_type + 4);
  twistAxisBinWorld_8.m_quad = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v34, v34, 0), bodyBTransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v34, v34, 85), bodyBTransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v34, v34, 170), bodyBTransform->m_rotation.m_col2.m_quad));
  v35 *= 2i64;
  v36 = *(__m128 *)((char *)&atoms->m_transforms.m_transformA.m_rotation.m_col0.m_quad + 8 * v35);
  planeAxisAinWorld.m_quad = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v36, v36, 0), bodyATransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v36, v36, 85), bodyATransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v36, v36, 170), bodyATransform->m_rotation.m_col2.m_quad));
  v37 = *(__m128 *)((char *)&atoms->m_transforms.m_transformB.m_rotation.m_col0.m_quad + 8 * v35);
  planeAxisBinWorld.m_quad = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v37, v37, 0), bodyBTransform->m_rotation.m_col0.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v37, v37, 85), bodyBTransform->m_rotation.m_col1.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v37, v37, 170), bodyBTransform->m_rotation.m_col2.m_quad));
  j_hkInternalConstraintUtils_calcRelativeAngle(&twistAxisAinWorld_8, &twistAxisBinWorld_8, &planeAxisAinWorld, &planeAxisBinWorld, &axisOut, &twistAxisBinWorld);
  _XMM2 = LODWORD(result->before.ragdoll.twistMin);
  if ( twistAxisBinWorld < 0.0 )
  {
    __asm { vminss  xmm3, xmm2, xmm1 }
    *((float *)&atoms->m_twistLimit.m_type + 2) = *(float *)&_XMM3;
  }
  else
  {
    _XMM1 = LODWORD(result->before.ragdoll.twistMax);
    __asm { vmaxss  xmm2, xmm1, xmm3 }
    LODWORD(_XMM3) = *((_DWORD *)&atoms->m_twistLimit.m_type + 2);
    *((float *)&atoms->m_twistLimit.m_type + 3) = *(float *)&_XMM2;
  }
  v23 = *(float *)&_XMM3 == result->before.ragdoll.twistMin;
  result->after.ragdoll.twistMin = *(float *)&_XMM3;
  v42 = *((float *)&atoms->m_twistLimit.m_type + 3);
  result->after.ragdoll.twistMax = v42;
  v43 = !v23;
  result->twistChanged |= v43 | (v42 != result->before.ragdoll.twistMax);
}

/*
==============
HavokPhysics_MovePhysicsAsset
==============
*/
void HavokPhysics_MovePhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v4; 
  int m_hashMod; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  Dummy *v9; 
  PhysicsAsset *key; 
  unsigned __int64 val; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v12; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  Dummy *v17; 
  PhysicsAsset *v18; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v19; 
  int v20; 
  int v21; 
  int v22; 
  unsigned __int32 v23; 
  unsigned __int32 v24; 
  unsigned int v25; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  PhysicsAsset *v27; 
  __int64 v28; 
  hkMemoryAllocator alloc; 

  HavokPhysics_LockAssetWrite();
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7534, ASSERT_TYPE_ASSERT, "(from)", "%s\n\tTrying to clone a NULL Physics Asset", "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7535, ASSERT_TYPE_ASSERT, "(to)", "%s\n\tTrying to clone a NULL Physics Asset", "to") )
    __debugbreak();
  v4 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7536, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Clone a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  m_hashMod = v4->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v6 = _byteswap_ulong(-1640531535 * (_DWORD)from), v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = m_hashMod & (v7 ^ ((v6 >> 2) + v6 + (v7 << 6) - 1640531527)), v9 = (Dummy *)v8, key = (PhysicsAsset *)v4->m_map.m_elem[v8].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_15:
    v9 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != from )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = (Dummy *)v8;
      key = (PhysicsAsset *)v4->m_map.m_elem[v8].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_15;
    }
  }
  if ( (int)v9 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7539, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( fromIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( fromIt )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  val = v4->m_map.m_elem[(int)v9].val;
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v4->m_map, v9);
  v12 = s_havokPhysicsAssets;
  v13 = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( v13 <= 0 || (v14 = _byteswap_ulong(-1640531535 * (_DWORD)to), v15 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v16 = v13 & (v15 ^ ((v14 >> 2) + v14 + (v15 << 6) - 1640531527)), v17 = (Dummy *)v16, v18 = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v16].key, v18 == (PhysicsAsset *)-1i64) )
  {
LABEL_24:
    v17 = (Dummy *)(v13 + 1);
  }
  else
  {
    while ( v18 != to )
    {
      v16 = v13 & (v16 + 1);
      v17 = (Dummy *)v16;
      v18 = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v16].key;
      if ( v18 == (PhysicsAsset *)-1i64 )
        goto LABEL_24;
    }
  }
  if ( (int)v17 > v13 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7544, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( toIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( toIt )") )
      __debugbreak();
    v12 = s_havokPhysicsAssets;
  }
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v12->m_map, v17);
  v19 = s_havokPhysicsAssets;
  *(__m256i *)&to->name = *(__m256i *)&from->name;
  *(__m256i *)&to->simulationCategories = *(__m256i *)&from->simulationCategories;
  *(_OWORD *)&to->vfxEventAssets = *(_OWORD *)&from->vfxEventAssets;
  *(double *)&to->usageCounter.dynEnt = *(double *)&from->usageCounter.dynEnt;
  v20 = (unsigned int)hkMemHeapAllocator();
  v21 = v19->m_map.m_hashMod;
  if ( 2 * v19->m_map.m_numElems > v21 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v19->m_map, &alloc, v20);
    v21 = v19->m_map.m_hashMod;
  }
  v22 = 1;
  v23 = _byteswap_ulong(-1640531535 * (_DWORD)to);
  v24 = _byteswap_ulong(-1640531535 * HIDWORD(to));
  v25 = v21 & (v24 ^ ((v23 >> 2) + v23 + (v24 << 6) - 1640531527));
  m_elem = v19->m_map.m_elem;
  v27 = (PhysicsAsset *)v19->m_map.m_elem[v25].key;
  if ( v27 != (PhysicsAsset *)-1i64 )
  {
    while ( v27 != to )
    {
      v25 = v19->m_map.m_hashMod & (v25 + 1);
      v27 = (PhysicsAsset *)m_elem[v25].key;
      if ( v27 == (PhysicsAsset *)-1i64 )
        goto LABEL_36;
    }
    v22 = 0;
  }
LABEL_36:
  v19->m_map.m_numElems += v22;
  v28 = (int)v25;
  m_elem[v28].key = (unsigned __int64)to;
  v19->m_map.m_elem[v28].val = val;
  if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7550, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->insert( to, assetPtr ))", (const char *)&queryFormat, "s_havokPhysicsAssets->insert( to, assetPtr )") )
    __debugbreak();
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MovePhysicsSFXEventAsset
==============
*/
void HavokPhysics_MovePhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  int v4; 
  unsigned int v5; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v6; 
  hkMemoryAllocator *v7; 
  unsigned int key; 
  PhysicsSFXEventAsset *val; 

  val = to;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7116, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7117, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7118, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", (const char *)&queryFormat, "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)from) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7121, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7122, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsSFXAssetInternal(to);
  *to = *from;
  v5 = v4;
  HavokPhysics_LockAssetWrite();
  key = v5;
  v6 = g_physicsSFXEventAssets;
  v7 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>>::insert(v6, v7, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MovePhysicsVFXEventAsset
==============
*/
void HavokPhysics_MovePhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  int v4; 
  unsigned int v5; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v6; 
  hkMemoryAllocator *v7; 
  unsigned int key; 
  PhysicsVFXEventAsset *val; 

  val = to;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7280, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7281, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7282, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", (const char *)&queryFormat, "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)from) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7285, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7286, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsVFXAssetInternal(to);
  *to = *from;
  v5 = v4;
  HavokPhysics_LockAssetWrite();
  key = v5;
  v6 = g_physicsVFXEventAssets;
  v7 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>>::insert(v6, v7, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MoveXModelAsset
==============
*/
void HavokPhysics_MoveXModelAsset(XModel *from, XModel *to)
{
  int Index; 
  __int64 v5; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v6; 
  __int64 m_size; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v8; 
  hkMemoryAllocator *v9; 
  int v10; 

  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7936, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  Index = HavokPhysics_DebugXModelGetIndex(from);
  v5 = Index;
  if ( Index < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7938, ASSERT_TYPE_ASSERT, "(xModelId >= 0)", "%s\n\txmodel doesn't exist in debug list", "xModelId >= 0") )
    __debugbreak();
  v6 = s_havokPhysicsXModels;
  m_size = s_havokPhysicsXModels->m_size;
  s_havokPhysicsXModels->m_size = m_size - 1;
  if ( (_DWORD)m_size - 1 != (_DWORD)v5 )
    v6->m_data[v5] = v6->m_data[m_size - 1];
  if ( (int)HavokPhysics_DebugXModelGetIndex(to) > 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7940, ASSERT_TYPE_ASSERT, "(HavokPhysics_DebugXModelGetIndex( to ) <= 0)", "%s\n\tdest xmodel already exists", "HavokPhysics_DebugXModelGetIndex( to ) <= 0") )
    __debugbreak();
  v8 = s_havokPhysicsXModels;
  v9 = hkMemHeapAllocator();
  v10 = v8->m_size;
  if ( v10 == (v8->m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v9, v8, 8);
    v10 = v8->m_size;
  }
  v8->m_data[v10] = to;
  ++v8->m_size;
}

/*
==============
HavokPhysics_MoveXModelDetailCollisionAsset
==============
*/
void HavokPhysics_MoveXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  unsigned __int64 val; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v5; 
  int m_hashMod; 
  unsigned __int32 v7; 
  unsigned __int32 v8; 
  unsigned int v9; 
  Dummy *v10; 
  XModelDetailCollision *key; 
  int v12; 
  unsigned __int32 v13; 
  unsigned __int32 v14; 
  unsigned int v15; 
  int v16; 
  XModelDetailCollision *v17; 
  int v18; 
  int v19; 
  int v20; 
  unsigned __int32 v21; 
  unsigned __int32 v22; 
  int v23; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v25; 
  XModelDetailCollision *v26; 
  __int64 v27; 
  hkMemoryAllocator alloc; 

  val = 0i64;
  HavokPhysics_LockAssetWrite();
  v5 = s_havokPhysicsXModelLODs;
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = _byteswap_ulong(-1640531535 * (_DWORD)from), v9 = m_hashMod & (v7 ^ ((v8 >> 2) + v8 + (v7 << 6) - 1640531527)), v10 = (Dummy *)v9, key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_5:
    v10 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != from )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = (Dummy *)v9;
      key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v9].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_5;
    }
  }
  if ( (int)v10 <= m_hashMod )
  {
    val = s_havokPhysicsXModelLODs->m_map.m_elem[(int)v10].val;
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&s_havokPhysicsXModelLODs->m_map, v10);
    v5 = s_havokPhysicsXModelLODs;
  }
  v12 = v5->m_map.m_hashMod;
  if ( v12 <= 0 || (v13 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v14 = _byteswap_ulong(-1640531535 * (_DWORD)to), v15 = v12 & (v13 ^ ((v14 >> 2) + v14 + (v13 << 6) - 1640531527)), v16 = v15, v17 = (XModelDetailCollision *)v5->m_map.m_elem[v15].key, v17 == (XModelDetailCollision *)-1i64) )
  {
LABEL_12:
    v16 = v12 + 1;
  }
  else
  {
    while ( v17 != to )
    {
      v15 = v12 & (v15 + 1);
      v16 = v15;
      v17 = (XModelDetailCollision *)v5->m_map.m_elem[v15].key;
      if ( v17 == (XModelDetailCollision *)-1i64 )
        goto LABEL_12;
    }
  }
  if ( v16 <= v12 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7968, ASSERT_TYPE_ASSERT, "(!s_havokPhysicsXModelLODs->hasKey( to ))", (const char *)&queryFormat, "!s_havokPhysicsXModelLODs->hasKey( to )") )
      __debugbreak();
    v5 = s_havokPhysicsXModelLODs;
  }
  if ( val )
  {
    v18 = (unsigned int)hkMemHeapAllocator();
    v19 = v5->m_map.m_hashMod;
    if ( 2 * v5->m_map.m_numElems > v19 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v5->m_map, &alloc, v18);
      v19 = v5->m_map.m_hashMod;
    }
    v20 = 1;
    v21 = _byteswap_ulong(-1640531535 * (_DWORD)to);
    v22 = _byteswap_ulong(-1640531535 * HIDWORD(to));
    v23 = v22 ^ ((v21 >> 2) + v21 + (v22 << 6) - 1640531527);
    m_elem = v5->m_map.m_elem;
    v25 = v19 & v23;
    v26 = (XModelDetailCollision *)v5->m_map.m_elem[v25].key;
    if ( v26 != (XModelDetailCollision *)-1i64 )
    {
      while ( v26 != to )
      {
        v25 = v5->m_map.m_hashMod & (v25 + 1);
        v26 = (XModelDetailCollision *)m_elem[v25].key;
        if ( v26 == (XModelDetailCollision *)-1i64 )
          goto LABEL_25;
      }
      v20 = 0;
    }
LABEL_25:
    v5->m_map.m_numElems += v20;
    v27 = (int)v25;
    m_elem[v27].key = (unsigned __int64)to;
    v5->m_map.m_elem[v27].val = val;
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_MyChangesInitAndLoad
==============
*/
void HavokPhysics_MyChangesInitAndLoad(void)
{
  ;
}

/*
==============
HavokPhysics_MyChangesSaveAndShutdown
==============
*/
void HavokPhysics_MyChangesSaveAndShutdown(void)
{
  ;
}

/*
==============
HavokPhysics_OnThreadInit
==============
*/
void HavokPhysics_OnThreadInit(unsigned int threadId)
{
  void *v1; 
  hkMemoryRouter *v2; 
  hkMemoryRouter *v3; 
  hkMemoryRouter *v4; 
  hkMonitorStream *Value; 

  v1 = (void *)(int)threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2812, ASSERT_TYPE_ASSERT, "(threadId < s_threadIdMax)", "%s\n\tHavokPhysics ThreadInit - we only support %u threads - increase the size of s_threadIdMax to support more", "threadId < s_threadIdMax", 28) )
    __debugbreak();
  if ( !TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID) )
  {
    v2 = (hkMemoryRouter *)&s_threadMemoryRouterBuffer[120 * (unsigned int)v1];
    if ( v2 )
    {
      hkMemoryRouter::hkMemoryRouter(v2);
      v4 = v3;
    }
    else
    {
      v4 = NULL;
    }
    s_threadMemoryRouters[(unsigned int)v1] = v4;
    ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemoryRouter *, const char *, __int64))s_havokPhysicsMemorySystem->threadInit)(s_havokPhysicsMemorySystem, v4, "hkWorkerThreadContext", 3i64);
    hkBaseSystem::initThread(v4);
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    hkMonitorStream::resize(Value, 102400);
    TlsSetValue(hkThreadNumber.m_slotID, v1);
  }
}

/*
==============
HavokPhysics_OnThreadShutdown
==============
*/
void HavokPhysics_OnThreadShutdown(unsigned int threadId)
{
  __int64 v1; 
  hkMemoryAllocator **v2; 
  hkMemoryAllocator *v3; 

  v1 = threadId;
  hkBaseSystem::quitThread();
  v2 = (hkMemoryAllocator **)&s_threadMemoryRouters[v1];
  v3 = *v2;
  if ( !*v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2847, ASSERT_TYPE_ASSERT, "(memoryRouter)", "%s\n\tHavokPhysics: Thread memory router is NULL", "memoryRouter") )
    __debugbreak();
  ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemoryAllocator *, __int64))s_havokPhysicsMemorySystem->threadQuit)(s_havokPhysicsMemorySystem, v3, 3i64);
  *v2 = NULL;
  hkMemoryAllocator::~hkMemoryAllocator(v3);
}

/*
==============
HavokPhysics_Particles_ConvexVsStaticModelTile
==============
*/
void HavokPhysics_Particles_ConvexVsStaticModelTile(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  StaticModels_HavokShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const StaticModels_HavokShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_PhysicsAssetSortByMemory
==============
*/
hkBool *HavokPhysics_PhysicsAssetSortByMemory(hkBool *result, const PhysicsAsset *a, const PhysicsAsset *b)
{
  result->m_bool = a->havokDataSize > b->havokDataSize;
  return result;
}

/*
==============
HavokPhysics_PhysicsAssetSortByName
==============
*/
hkBool *HavokPhysics_PhysicsAssetSortByName(hkBool *result, const PhysicsAsset *a, const PhysicsAsset *b)
{
  result->m_bool = I_stricmp(a->name, b->name) < 0;
  return result;
}

/*
==============
HavokPhysics_PreStepWorld
==============
*/
void HavokPhysics_PreStepWorld(Physics_WorldId worldId, float timeStep)
{
  __int64 v2; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 timeStepDebugHistoryStart; 
  int v5; 
  unsigned int unsignedInt; 
  Physics_DeferredBroadphaseCollisionQueryData *v7; 
  int v8; 
  int v9; 
  hkAabb debugAABBQueryAABB; 
  __int64 v11; 
  Physics_DeferredCollisionQueryData *data; 
  Physics_DeferredCollisionQueryData *v13; 
  int v14; 
  int v15; 
  float debugQueryPointMaxDistance; 
  int v17; 
  float debugGetClosestMaxDistance; 
  hkAabb debugAABBBroadphaseQueryAABB; 

  v2 = worldId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5693, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to PreStepWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld((Physics_WorldId)v2);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  MutableWorld->activeQueryRequestList = 1 - MutableWorld->activeQueryRequestList;
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->deferredQueryCritSection);
  timeStepDebugHistoryStart = MutableWorld->timeStepDebugHistoryStart;
  v5 = 2 * v2;
  MutableWorld->stepCPUIndex = 0;
  unsignedInt = 0xFFFFFF;
  MutableWorld->lastFrameCPUTime = 0.0;
  MutableWorld->timeStepDebugHistoryRaw[timeStepDebugHistoryStart] = MutableWorld->timeStepDebugLastRawTimeStep;
  MutableWorld->timeStepDebugHistoryUsed[MutableWorld->timeStepDebugHistoryStart] = timeStep;
  MutableWorld->timeStepDebugHistoryStart = (MutableWorld->timeStepDebugHistoryStart + 1) % 300;
  if ( physics_debugQueryBody->current.integer >= 0 )
    unsignedInt = physics_debugQueryBody->current.unsignedInt;
  if ( MutableWorld->requestDebugAABBBroadphaseQuery )
  {
    v7 = &s_havokPhysicsWorldAABBBroadphaseQueryData[v5 + s_havokPhysicsWorldAABBBroadphaseQueryActiveIndices[v2]];
    debugAABBBroadphaseQueryAABB = MutableWorld->debugAABBBroadphaseQueryAABB;
    HavokPhysics_DeferredAABBBroadphaseQuery((Physics_WorldId)v2, &debugAABBBroadphaseQueryAABB, &MutableWorld->debugAABBBroadphaseQueryExtendedData, v7);
    MutableWorld->requestDebugAABBBroadphaseQuery = 0;
  }
  v8 = unsignedInt & 0xFFFFFF;
  if ( MutableWorld->requestDebugAABBQuery )
  {
    if ( v8 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader, unsignedInt) )
    {
      v11 = v5 + s_havokPhysicsWorldAABBQueryActiveIndices[v2];
      debugAABBBroadphaseQueryAABB = MutableWorld->debugAABBQueryAABB;
      HavokPhysics_DeferredAABBQuery((Physics_WorldId)v2, &debugAABBBroadphaseQueryAABB, &MutableWorld->debugAABBQueryExtendedData, &s_havokPhysicsWorldAABBQueryData[v11]);
    }
    else
    {
      v9 = s_havokPhysicsWorldAABBQueryActiveIndices[v2];
      debugAABBQueryAABB = MutableWorld->debugAABBQueryAABB;
      MutableWorld->debugAABBQueryExtendedData.simplify = 0;
      debugAABBBroadphaseQueryAABB = debugAABBQueryAABB;
      HavokPhysics_DeferredAABBQuery((Physics_WorldId)v2, (hknpBodyId)unsignedInt, &debugAABBBroadphaseQueryAABB, &MutableWorld->debugAABBQueryExtendedData, &s_havokPhysicsWorldAABBQueryData[v5 + v9]);
    }
    MutableWorld->requestDebugAABBQuery = 0;
  }
  if ( MutableWorld->requestDebugRaycast )
  {
    if ( v8 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader, unsignedInt) )
    {
      if ( physics_debugRayDetail->current.enabled )
        v13 = &s_havokPhysicsWorldRayDetailData[v5 + s_havokPhysicsWorldRayDetailActiveIndices[v2]];
      else
        v13 = &s_havokPhysicsWorldRayData[v5 + s_havokPhysicsWorldRayActiveIndices[v2]];
      v13->isComplete = 0;
      HavokPhysics_DeferredRaycast((Physics_WorldId)v2, &MutableWorld->debugRaycastStart, &MutableWorld->debugRaycastEnd, &MutableWorld->debugRaycastExtendedData, v13);
    }
    else
    {
      if ( physics_debugRayDetail->current.enabled )
        data = &s_havokPhysicsWorldRayDetailData[v5 + s_havokPhysicsWorldRayDetailActiveIndices[v2]];
      else
        data = &s_havokPhysicsWorldRayData[v5 + s_havokPhysicsWorldRayActiveIndices[v2]];
      data->isComplete = 0;
      HavokPhysics_DeferredRaycast((Physics_WorldId)v2, (hknpBodyId)unsignedInt, &MutableWorld->debugRaycastStart, &MutableWorld->debugRaycastEnd, &MutableWorld->debugRaycastExtendedData, data);
    }
    MutableWorld->requestDebugRaycast = 0;
  }
  if ( MutableWorld->requestDebugShapecast )
  {
    if ( v8 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader, unsignedInt) )
    {
      HavokPhysics_DeferredShapecast((Physics_WorldId)v2, MutableWorld->debugShapecastShape, &MutableWorld->debugShapecastStart, &MutableWorld->debugShapecastEnd, &MutableWorld->debugShapecastRotation, &MutableWorld->debugShapecastExtendedData, &s_havokPhysicsWorldShapeCastData[v5 + s_havokPhysicsWorldShapeCastActiveIndices[v2]]);
    }
    else
    {
      v14 = s_havokPhysicsWorldShapeCastActiveIndices[v2];
      MutableWorld->debugShapecastExtendedData.simplifyStart = 0;
      HavokPhysics_DeferredShapecast((Physics_WorldId)v2, (hknpBodyId)unsignedInt, MutableWorld->debugShapecastShape, &MutableWorld->debugShapecastStart, &MutableWorld->debugShapecastEnd, &MutableWorld->debugShapecastRotation, &MutableWorld->debugShapecastExtendedData, &s_havokPhysicsWorldShapeCastData[v5 + v14]);
    }
    MutableWorld->requestDebugShapecast = 0;
  }
  if ( MutableWorld->requestDebugQueryPoint )
  {
    if ( v8 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader, unsignedInt) )
    {
      HavokPhysics_DeferredQueryPoint((Physics_WorldId)v2, &MutableWorld->debugQueryPointPoint, MutableWorld->debugQueryPointMaxDistance, &MutableWorld->debugQueryPointExtendedData, &s_havokPhysicsWorldQueryPointData[v5 + s_havokPhysicsWorldQueryPointActiveIndices[v2]]);
    }
    else
    {
      v15 = s_havokPhysicsWorldQueryPointActiveIndices[v2];
      debugQueryPointMaxDistance = MutableWorld->debugQueryPointMaxDistance;
      MutableWorld->debugQueryPointExtendedData.simplify = 0;
      HavokPhysics_DeferredQueryPoint((Physics_WorldId)v2, (hknpBodyId)unsignedInt, &MutableWorld->debugQueryPointPoint, debugQueryPointMaxDistance, &MutableWorld->debugQueryPointExtendedData, &s_havokPhysicsWorldQueryPointData[v5 + v15]);
    }
    MutableWorld->requestDebugQueryPoint = 0;
  }
  if ( MutableWorld->requestDebugGetClosestPoints )
  {
    if ( v8 == 0xFFFFFF || !((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->isBodyValid)(&MutableWorld->world->hknpWorldReader, unsignedInt) )
    {
      HavokPhysics_DeferredGetClosestPoints((Physics_WorldId)v2, MutableWorld->debugGetClosestPointsShape, &MutableWorld->debugGetClosestPointsPoint, &MutableWorld->debugGetClosestPointsRotation, MutableWorld->debugGetClosestMaxDistance, &MutableWorld->debugGetClosestPointsExtendedData, &s_havokPhysicsWorldGetClosestPointsData[v5 + s_havokPhysicsWorldGetClosestPointsActiveIndices[v2]]);
    }
    else
    {
      v17 = s_havokPhysicsWorldGetClosestPointsActiveIndices[v2];
      debugGetClosestMaxDistance = MutableWorld->debugGetClosestMaxDistance;
      MutableWorld->debugGetClosestPointsExtendedData.simplify = 0;
      HavokPhysics_DeferredGetClosestPoints((Physics_WorldId)v2, (hknpBodyId)unsignedInt, MutableWorld->debugGetClosestPointsShape, &MutableWorld->debugGetClosestPointsPoint, &MutableWorld->debugGetClosestPointsRotation, debugGetClosestMaxDistance, &MutableWorld->debugGetClosestPointsExtendedData, &s_havokPhysicsWorldGetClosestPointsData[v5 + v17]);
    }
    MutableWorld->requestDebugGetClosestPoints = 0;
  }
}

/*
==============
HavokPhysics_ProcessDeferredForce
==============
*/
void HavokPhysics_ProcessDeferredForce(const Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletForce,hkContainerHeapAllocator> *m_deferredBulletForceEntries; 
  HavokPhysicsDeferredBulletForce *i; 
  hkArray<HavokPhysicsDeferredRadiusForce,hkContainerHeapAllocator> *m_deferredRadiusForceEntries; 
  HavokPhysicsDeferredRadiusForce *m_data; 
  Physics_WorldId isAlternate; 

  Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredForce");
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    isAlternate = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13038, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to process deferred force with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", isAlternate) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  for ( i = m_deferredBulletForceEntries->m_data; i != &m_deferredBulletForceEntries->m_data[m_deferredBulletForceEntries->m_size]; ++i )
  {
    Physics_ApplyBulletForce(worldId, &i->start, &i->end, i->inflictorEntNum, i->isMelee, &i->weapon, i->isAlternate, i->mod, i->effectCallback);
    m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  }
  m_deferredRadiusForceEntries = MutableWorld->m_deferredRadiusForceEntries;
  m_data = m_deferredRadiusForceEntries->m_data;
  if ( m_deferredRadiusForceEntries->m_data != &m_deferredRadiusForceEntries->m_data[m_deferredRadiusForceEntries->m_size] )
  {
    do
    {
      Physics_ApplyRadiusForce(worldId, &m_data->position, m_data->radius, m_data->innerDamage, m_data->outerDamage, m_data->impulseOverride, &m_data->impulseVecOverride, m_data->randSeed, m_data->forceScalar);
      ++m_data;
    }
    while ( m_data != &MutableWorld->m_deferredRadiusForceEntries->m_data[MutableWorld->m_deferredRadiusForceEntries->m_size] );
    m_deferredBulletForceEntries = MutableWorld->m_deferredBulletForceEntries;
  }
  m_deferredBulletForceEntries->m_size = 0;
  MutableWorld->m_deferredRadiusForceEntries->m_size = 0;
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ProcessDeferredForceCallbacks
==============
*/
void HavokPhysics_ProcessDeferredForceCallbacks(const Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredBulletEffectCallback,hkContainerHeapAllocator> *m_deferredBulletEffectEntries; 
  HavokPhysicsDeferredBulletEffectCallback *i; 
  __int64 v5; 
  Physics_WorldId v6; 
  BOOL v7; 

  Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredForceCallbacks");
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v6 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13076, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to process deferred force callbackswith invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v6) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  m_deferredBulletEffectEntries = MutableWorld->m_deferredBulletEffectEntries;
  for ( i = m_deferredBulletEffectEntries->m_data; i != &m_deferredBulletEffectEntries->m_data[m_deferredBulletEffectEntries->m_size]; ++i )
  {
    Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredForceCallback");
    if ( ((LODWORD(i->start.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(i->start.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(i->start.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13089, ASSERT_TYPE_ASSERT, "(!IS_NAN( entry.start[0] ) && !IS_NAN( entry.start[1] ) && !IS_NAN( entry.start[2] ))", (const char *)&queryFormat, "!IS_NAN( entry.start[0] ) && !IS_NAN( entry.start[1] ) && !IS_NAN( entry.start[2] )") )
      __debugbreak();
    if ( ((LODWORD(i->hitPos.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(i->hitPos.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(i->hitPos.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13090, ASSERT_TYPE_ASSERT, "(!IS_NAN( entry.hitPos[0] ) && !IS_NAN( entry.hitPos[1] ) && !IS_NAN( entry.hitPos[2] ))", (const char *)&queryFormat, "!IS_NAN( entry.hitPos[0] ) && !IS_NAN( entry.hitPos[1] ) && !IS_NAN( entry.hitPos[2] )") )
      __debugbreak();
    if ( ((LODWORD(i->hitNormal.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(i->hitNormal.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(i->hitNormal.v[2]) & 0x7F800000) == 2139095040) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13091, ASSERT_TYPE_ASSERT, "(!IS_NAN( entry.hitNormal[0] ) && !IS_NAN( entry.hitNormal[1] ) && !IS_NAN( entry.hitNormal[2] ))", (const char *)&queryFormat, "!IS_NAN( entry.hitNormal[0] ) && !IS_NAN( entry.hitNormal[1] ) && !IS_NAN( entry.hitNormal[2] )") )
      __debugbreak();
    if ( !i->effectCallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13093, ASSERT_TYPE_ASSERT, "(entry.effectCallback)", (const char *)&queryFormat, "entry.effectCallback") )
      __debugbreak();
    LOBYTE(v7) = i->isAlternate;
    LODWORD(v5) = i->hitSurfaceFlags;
    i->effectCallback((const LocalClientNum_t)i->localClientNum, i->hitBodyId.m_serialAndIndex, i->shapeKey, &i->start, &i->hitPos, v5, &i->hitNormal, &i->partName, i->inflictorEntNum, &i->weapon, v7, i->mod);
    Sys_ProfEndNamedEvent();
    m_deferredBulletEffectEntries = MutableWorld->m_deferredBulletEffectEntries;
  }
  m_deferredBulletEffectEntries->m_size = 0;
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ProcessDeferredKeyframe
==============
*/
void HavokPhysics_ProcessDeferredKeyframe(const Physics_WorldId worldId, const float velocityScale)
{
  HavokPhysicsWorld *MutableWorld; 
  hkArray<HavokPhysicsDeferredKeyframeInstance,hkContainerHeapAllocator> *m_deferredKeyframeInstanceEntries; 
  HavokPhysicsDeferredKeyframeInstance *i; 
  Physics_WorldId updateBroadphaseIfWarping; 

  Sys_ProfBeginNamedEvent(0xFF008008, "HavokPhysics_ProcessDeferredKeyframe");
  if ( velocityScale <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13009, ASSERT_TYPE_ASSERT, "(velocityScale > 0.0f)", "%s\n\tHavok Physics: Trying to process deferred keyframe with invalid velocityScale", "velocityScale > 0.0f") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    updateBroadphaseIfWarping = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13010, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to process deferred keyframe with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", updateBroadphaseIfWarping) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  m_deferredKeyframeInstanceEntries = MutableWorld->m_deferredKeyframeInstanceEntries;
  for ( i = m_deferredKeyframeInstanceEntries->m_data; i != &m_deferredKeyframeInstanceEntries->m_data[m_deferredKeyframeInstanceEntries->m_size]; ++i )
  {
    Physics_KeyframeInstanceTo(worldId, i->instanceId, &i->origin, &i->orientationAsQuat, velocityScale, 1, 0, 0.0);
    m_deferredKeyframeInstanceEntries = MutableWorld->m_deferredKeyframeInstanceEntries;
  }
  m_deferredKeyframeInstanceEntries->m_size = 0;
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ProfileEnd
==============
*/
void HavokPhysics_ProfileEnd()
{
  ;
}

/*
==============
HavokPhysics_ProfileStart
==============
*/
void HavokPhysics_ProfileStart(const char *name)
{
  ;
}

/*
==============
HavokPhysics_QueryHitSort
==============
*/
hkBool *HavokPhysics_QueryHitSort(hkBool *result, hknpCollisionResult *a, hknpCollisionResult *b)
{
  result->m_bool = a->m_fraction < b->m_fraction;
  return result;
}

/*
==============
HavokPhysics_QueryPoint
==============
*/
void HavokPhysics_QueryPoint(Physics_WorldId worldId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  __int64 *ConstWorld; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v11; 
  __int64 NumHits; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v14; 
  int v15; 
  int v16; 
  hknpCollisionResult *v17; 
  __m256i *v18; 
  __int64 v19; 
  signed __int64 v20; 
  hknpBodyId *v21; 
  int Ref; 
  int v23; 
  unsigned int v24; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v26; 
  __int64 v27; 
  __int64 v28; 
  hknpCollisionResult *array; 
  int v30; 
  int v31; 
  float v32; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  Physics_CharacterProxy_Type characterProxyType; 
  __int128 v35; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v37; 
  __int64 v38[2]; 
  __int16 v39; 
  int contents; 
  float *v41; 
  int v42; 
  char v43; 
  __m128 m_quad; 
  float v45; 

  v37 = -2i64;
  v32 = 0.0;
  ignoreBodies = NULL;
  characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  v35 = 0i64;
  phaseSelection = All;
  v43 = -5;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14303, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire point query with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14304, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire point query with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14305, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire point query with invalid result", "result") )
    __debugbreak();
  ConstWorld = (__int64 *)HavokPhysics_GetConstWorld(worldId);
  ignoreBodies = extendedData->ignoreBodies;
  v32 = extendedData->collisionBuffer * 0.03125;
  characterProxyType = extendedData->characterProxyType;
  phaseSelection = extendedData->phaseSelection;
  m_quad = point->m_quad;
  v45 = maxDistance;
  v38[0] = (__int64)s_shapeTagCodec;
  v38[1] = *ConstWorld;
  v39 = -1;
  contents = extendedData->contents;
  v41 = &v32;
  v42 = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14326, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire point query with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14329, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire point query with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtQueryPoint_HK");
  Sys_ProfBeginNamedEvent(0xFFFF6347, "Havok QueryPoint");
  (*(void (__fastcall **)(__int64, __int64 *, hknpCollisionQueryCollector *))(*(_QWORD *)(ConstWorld[3] + 32) + 336i64))(ConstWorld[3] + 32, v38, Collector);
  Sys_ProfEndNamedEvent();
  v11 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v11 )
    hkMonitorStream::timerEnd(v11, "Et");
  if ( extendedData->simplify )
  {
    array = NULL;
    v30 = 0;
    v31 = 0x80000000;
    NumHits = (int)HavokPhysics_CollisionQueryResult::GetNumHits(result);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(result);
    v14 = hkMemHeapAllocator();
    v15 = 0;
    if ( (int)NumHits > 0 )
    {
      v16 = NumHits;
      if ( (int)NumHits < 0 )
        v16 = 0;
      hkArrayUtil::_reserve(v14, &array, v16, 112);
      v15 = v30;
    }
    v17 = array;
    v18 = (__m256i *)&array[v15];
    v19 = NumHits;
    if ( (int)NumHits > 0 )
    {
      v20 = (char *)Hits - (char *)v18;
      do
      {
        if ( v18 )
        {
          *v18 = *(__m256i *)((char *)v18 + v20);
          v18[1] = *(__m256i *)((char *)&v18[1] + v20);
          v18[2] = *(__m256i *)((char *)&v18[2] + v20);
          *(_OWORD *)v18[3].m256i_i8 = *(_OWORD *)&v18[3].m256i_i8[v20];
        }
        v18 = (__m256i *)((char *)v18 + 112);
        --v19;
      }
      while ( v19 );
      v17 = array;
    }
    v30 = NumHits;
    if ( (int)NumHits > 1 )
      hkAlgorithm::quickSortRecursive<hknpCollisionResult,hkBool (*)(hknpCollisionResult &,hknpCollisionResult &)>(v17, 0, NumHits - 1, HavokPhysics_QueryHitSort);
    Collector->reset(Collector);
    v21 = (hknpBodyId *)array;
    if ( array != &array[v30] )
    {
      do
      {
        Ref = HavokPhysics_GetRef(result->m_worldId, v21[18]);
        v23 = HavokPhysics_CollisionQueryResult::GetNumHits(result);
        v24 = 0;
        if ( v23 <= 0 )
        {
LABEL_40:
          Collector->addHit(Collector, (const hknpCollisionResult *)v21);
        }
        else
        {
          while ( 1 )
          {
            if ( v24 >= HavokPhysics_CollisionQueryResult::GetNumHits(result) )
            {
              LODWORD(v28) = HavokPhysics_CollisionQueryResult::GetNumHits(result);
              LODWORD(v27) = v24;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v27, v28) )
                __debugbreak();
            }
            Hit = HavokPhysics_CollisionQueryResult::GetHit(result, v24);
            if ( HavokPhysics_GetRef(result->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
              break;
            if ( (int)++v24 >= v23 )
              goto LABEL_40;
          }
        }
        v21 += 28;
      }
      while ( v21 != (hknpBodyId *)&array[v30] );
    }
    v26 = hkMemHeapAllocator();
    v30 = 0;
    if ( v31 >= 0 )
      hkMemoryAllocator::bufFree2(v26, array, 112, v31 & 0x3FFFFFFF);
  }
}

/*
==============
HavokPhysics_QueryPoint
==============
*/
void HavokPhysics_QueryPoint(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *point, float maxDistance, Physics_QueryPointExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *ConstWorld; 
  const hknpBody *v16; 
  const hknpShape *m_shape; 
  hkMonitorStream *Value; 
  hkMonitorStream *v19; 
  hkMonitorStream *v20; 
  hkMonitorStream *v24; 
  __int64 v25; 
  __int128 v26; 
  __int16 v27; 
  int contents; 
  float *v29; 
  hknpCollisionQueryDispatcher *m_collisionQueryDispatcher; 
  hkReferencedObject *v31; 
  hkReferencedObject *v32; 
  float v33; 
  int v34; 
  float v35; 
  __int64 v36; 
  Physics_CharacterProxy_Type characterProxyType; 
  __int128 v38; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int128 v40; 
  __int64 v41; 
  hkMonitorStream *v42; 
  HavokPhysicsShapeTagCodec *v43; 
  HavokPhysicsCollisionFilter *traceCollisionFilter; 
  __int16 v45; 
  int v46; 
  float *v47; 
  int v48; 
  char v49; 
  __m128 m_quad; 
  float v51; 
  __int128 v52; 
  __int64 v53; 
  int v54; 
  int v55; 
  __int128 v56; 
  char v57; 
  int v58; 
  float v59; 
  __int128 v60; 
  __int128 v61; 
  hknpInplaceTriangleShape v62; 

  v41 = -2i64;
  v27 = -1;
  contents = 0;
  v29 = NULL;
  _XMM1 = 0i64;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v62, 0.0);
  m_collisionQueryDispatcher = NULL;
  v31 = (hkReferencedObject *)&v62;
  v32 = (hkReferencedObject *)&v62;
  v33 = 0.0;
  v34 = 1;
  v54 = -1;
  v55 = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v52 = _XMM0;
  v53 = 0i64;
  __asm { vpxor   xmm1, xmm1, xmm1 }
  v56 = _XMM1;
  v57 = 0;
  v60 = _xmm;
  v58 = 0;
  v61 = _XMM1;
  v59 = 0.0;
  LOWORD(v26) = -1;
  DWORD1(v26) = 0;
  *((_QWORD *)&v26 + 1) = 0i64;
  v35 = 0.0;
  v36 = 0i64;
  characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v38 = _XMM0;
  phaseSelection = All;
  v45 = -1;
  v46 = 0;
  v47 = NULL;
  traceCollisionFilter = NULL;
  v43 = NULL;
  v48 = 2;
  v49 = -5;
  m_quad = (__m128)_XMM1;
  v51 = 0.0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15103, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v25) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15104, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire querypoint with body with invalid body id %i", "bodyId.isValid()", v25) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15105, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15106, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire point query with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplify && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15107, ASSERT_TYPE_ASSERT, "(!extendedData->simplify)", "%s\n\tHavok Physics: Trying to fire point query with body with simplify - not supported", "!extendedData->simplify") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15108, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15109, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire point query with body with invalid collector", "result->m_collector") )
    __debugbreak();
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15112, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire point query with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v16 = (const hknpBody *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  m_shape = v16->m_shape;
  v35 = extendedData->collisionBuffer * 0.03125;
  characterProxyType = extendedData->characterProxyType;
  phaseSelection = extendedData->phaseSelection;
  v27 = -1;
  contents = extendedData->contents;
  v29 = &v35;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, POINT_QUERY, (const hknpQueryFilterData *)&v27, v16) )
  {
    m_collisionQueryDispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    *(_QWORD *)&v52 = v16;
    *((_QWORD *)&v52 + 1) = v16->m_shape;
    *(_QWORD *)&v56 = v16;
    LOWORD(v26) = v16->m_materialId.m_value;
    DWORD1(v26) = v16->m_collisionFilterInfo;
    *((_QWORD *)&v26 + 1) = v16->m_userData;
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, POINT_QUERY, v16, m_shape, (hknpQueryFilterData *)&v26);
    m_quad = point->m_quad;
    v51 = maxDistance;
    v43 = s_shapeTagCodec;
    traceCollisionFilter = ConstWorld->traceCollisionFilter;
    v46 = extendedData->contents;
    v47 = &v35;
    v48 = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtQueryPoint_Body_HK");
    v19 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v20 = v19;
    if ( v19 )
      hkMonitorStream::timerBegin(v19, "TtQueryPoint");
    v42 = v20;
    v40 = v26;
    if ( v43 && (v43->m_hints.m_storage & 1) != 0 )
      v43->overrideInitialFilterData(v43, POINT_QUERY, (const hknpBody *)v52, m_shape, (hknpQueryFilterData *)&v40);
    __asm { vbroadcastss xmm3, [rbp+1E0h+var_1D0] }
    _XMM0.m_real = (__m128)Collector->m_earlyOutThreshold;
    __asm { vminps  xmm1, xmm0, xmm3 }
    Collector->m_earlyOutThreshold = (hkSimdFloat32)_XMM1.m_real;
    m_shape->queryPointImpl((hknpShape *)m_shape, (hknpCollisionQueryContext *)&m_collisionQueryDispatcher, (const hknpPointQuery *)&v43, (const hknpQueryFilterData *)&v40, (const hknpShapeQueryInfo *)&v52, Collector);
    if ( v20 )
      hkMonitorStream::timerEnd(v20, "Et");
    v24 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v24 )
      hkMonitorStream::timerEnd(v24, "Et");
    if ( !v34 )
    {
      hkReferencedObject::removeReference(v31);
      hkReferencedObject::removeReference(v32);
    }
  }
  else if ( !v34 )
  {
    hkReferencedObject::removeReference(v31);
    hkReferencedObject::removeReference(v32);
  }
}

/*
==============
HavokPhysics_Raycast
==============
*/
void HavokPhysics_Raycast(Physics_WorldId worldId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  const HavokPhysicsWorld *ConstWorld; 
  __m128 m_quad; 
  __m128 v13; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  const HavokPhysicsWorld *v15; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  unsigned int v26; 
  hknpCollisionQueryCollector *Collector; 
  hkMonitorStream *Value; 
  hkMonitorStream *v29; 
  float v30; 
  HavokPhysics_IgnoreBodies *v31; 
  int v32; 
  __int128 v33; 
  Physics_QueryPhaseSelection phaseSelection; 
  hknpRayCastQuery query; 

  query.m_broadPhaseFilterMask = -5;
  query.m_flags.m_storage = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v33 = _XMM0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13958, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire raycast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13959, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire raycast with invalid result", "result") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13960, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire raycast with invalid extended data", "extendedData") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  m_quad = end->m_quad;
  v13 = start->m_quad;
  ignoreBodies = extendedData->ignoreBodies;
  v15 = ConstWorld;
  v30 = extendedData->collisionBuffer * 0.03125;
  _XMM1 = _mm128_sub_ps(m_quad, v13);
  __asm { vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants }
  _XMM4 = 0i64;
  __asm
  {
    vcmpeqps xmm0, xmm4, xmm2
    vandnps xmm1, xmm0, xmm2
    vrcpps  xmm3, xmm1
    vcmpeqps xmm0, xmm4, xmm1
  }
  v31 = ignoreBodies;
  LODWORD(ignoreBodies) = extendedData->characterProxyType;
  query.m_ray.m_direction = (hkVector4f)_XMM1.m_quad;
  v32 = (int)ignoreBodies;
  _XMM3 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM3, _XMM1.m_quad)), _XMM3);
  phaseSelection = extendedData->phaseSelection;
  insideHitType = extendedData->insideHitType;
  __asm { vblendvps xmm1, xmm3, xmm4, xmm0 }
  query.m_ray.m_invDirection = (hkVector4f)_XMM1.m_quad;
  query.m_ray.m_origin.m_quad = v13;
  if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
  {
    v26 = 4;
  }
  else
  {
    v26 = 0;
    if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
      v26 = 8;
  }
  query.m_flags.m_storage = v26;
  if ( extendedData->disableBackFacingTriangleHits )
    query.m_flags.m_storage = v26 | 1;
  HavokPhysicsHitCollector::EnableInsideHits(result->m_collector, extendedData->collectInsideHits);
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = v15->traceCollisionFilter;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v30;
  *(_DWORD *)query.m_levelOfDetail = 0;
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13994, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire raycast with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetRaycastDataForModifiers(result->m_collector, start, end, &query);
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14000, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire raycast with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtRaytrace_HK");
  v15->world->castRay(&v15->world->hknpWorldReader, &query, Collector);
  v29 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v29 )
    hkMonitorStream::timerEnd(v29, "Et");
}

/*
==============
HavokPhysics_Raycast
==============
*/
void HavokPhysics_Raycast(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *start, const hkVector4f *end, Physics_RaycastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result)
{
  hknpCollisionQueryCollector *Collector; 
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v17; 
  const hknpShape *v18; 
  hkVector4f v25; 
  Physics_RaycastExtendedData::Physics_RaycastInsideHitType insideHitType; 
  unsigned int v38; 
  hkMonitorStream *Value; 
  __int128 *v43; 
  hkMonitorStream *v44; 
  __int64 v45; 
  __int128 v46; 
  __int16 v47; 
  int contents; 
  float *v49; 
  hknpCollisionQueryDispatcher *m_collisionQueryDispatcher; 
  hkReferencedObject *v51; 
  hkReferencedObject *v52; 
  float v53; 
  int v54; 
  __int128 v55; 
  float v56; 
  __int64 v57; 
  Physics_CharacterProxy_Type characterProxyType; 
  __int128 v59; 
  Physics_QueryPhaseSelection phaseSelection; 
  __int64 v61; 
  hknpRayCastQuery query; 
  __int128 v63; 
  __int64 v64; 
  int v65; 
  int v66; 
  __int128 v67; 
  char v68; 
  int v69; 
  float v70; 
  __int128 v71; 
  __int128 v72; 
  hknpInplaceTriangleShape v73; 

  v61 = -2i64;
  *(_QWORD *)&v55 = end;
  v47 = -1;
  contents = 0;
  v49 = NULL;
  _XMM1 = 0i64;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v73, 0.0);
  m_collisionQueryDispatcher = NULL;
  v51 = (hkReferencedObject *)&v73;
  v52 = (hkReferencedObject *)&v73;
  v53 = 0.0;
  v54 = 1;
  v65 = -1;
  v66 = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v63 = _XMM0;
  v64 = 0i64;
  __asm { vpxor   xmm1, xmm1, xmm1 }
  v67 = _XMM1;
  v68 = 0;
  v71 = _xmm;
  v69 = 0;
  v72 = 0i64;
  v70 = 0.0;
  LOWORD(v46) = -1;
  DWORD1(v46) = 0;
  *((_QWORD *)&v46 + 1) = 0i64;
  v56 = 0.0;
  v57 = 0i64;
  characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v59 = _XMM0;
  phaseSelection = All;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  query.m_shapeTagCodec = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  query.m_flags.m_storage = 0;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14702, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v45) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14703, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid body id %i", "bodyId.isValid()", v45) )
      __debugbreak();
  }
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14704, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14705, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire raycast with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14706, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14707, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire raycast with body with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetRaycastDataForModifiers(result->m_collector, start, end, &query);
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14713, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire raycast with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v17 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v18 = *(const hknpShape **)(v17 + 96);
  characterProxyType = extendedData->characterProxyType;
  v56 = extendedData->collisionBuffer * 0.03125;
  phaseSelection = extendedData->phaseSelection;
  v47 = -1;
  contents = extendedData->contents;
  v49 = &v56;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, RAY_CAST, (const hknpQueryFilterData *)&v47, (const hknpBody *)v17) )
  {
    m_collisionQueryDispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    *(_QWORD *)&v63 = v17;
    *((_QWORD *)&v63 + 1) = *(_QWORD *)(v17 + 96);
    *(_QWORD *)&v67 = v17;
    LOWORD(v46) = *(_WORD *)(v17 + 106);
    DWORD1(v46) = *(_DWORD *)(v17 + 108);
    *((_QWORD *)&v46 + 1) = *(_QWORD *)(v17 + 160);
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, RAY_CAST, (const hknpBody *)v17, v18, (hknpQueryFilterData *)&v46);
    _mm128_sub_ps(start->m_quad, *(__m128 *)(v17 + 48));
    _XMM3 = *(_OWORD *)v17;
    _XMM4 = *(_OWORD *)(v17 + 16);
    _XMM6 = *(_OWORD *)(v17 + 32);
    __asm
    {
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
    }
    v25.m_quad = (__m128)(_XMM1 | _XMM0 | _XMM2);
    _mm128_sub_ps(*(__m128 *)v55, *(__m128 *)(v17 + 48));
    __asm
    {
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
    }
    _XMM2 = _mm128_sub_ps((__m128)(_XMM1 | _XMM0 | _XMM2), v25.m_quad);
    __asm
    {
      vblendps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
      vcmpeqps xmm0, xmm3, xmm8
      vandnps xmm4, xmm0, xmm3
      vcmpeqps xmm0, xmm4, xmm8
      vrcpps  xmm3, xmm4
    }
    _XMM3 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM3, _XMM4.m_quad)), _XMM3);
    __asm { vblendvps xmm2, xmm3, xmm1, xmm0 }
    query.m_ray.m_direction = (hkVector4f)_XMM4.m_quad;
    query.m_ray.m_invDirection = (hkVector4f)_XMM2.m_quad;
    query.m_ray.m_origin = (hkVector4f)v25.m_quad;
    insideHitType = extendedData->insideHitType;
    if ( insideHitType == Physics_RaycastInsideHitType_InsideHits )
    {
      v38 = 4;
    }
    else
    {
      v38 = 0;
      if ( insideHitType == Physics_RaycastInsideHitType_InitialInsideHits )
        v38 = 8;
    }
    query.m_flags.m_storage = v38;
    if ( extendedData->disableBackFacingTriangleHits )
      query.m_flags.m_storage = v38 | 1;
    HavokPhysicsHitCollector::EnableInsideHits(result->m_collector, extendedData->collectInsideHits);
    query.m_shapeTagCodec = s_shapeTagCodec;
    query.m_filter = ConstWorld->traceCollisionFilter;
    query.m_filterData.m_materialId.m_value = -1;
    query.m_filterData.m_collisionFilterInfo = extendedData->contents;
    query.m_filterData.m_userData = (unsigned __int64)&v56;
    *(_DWORD *)query.m_levelOfDetail = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtRaycast_Body_HK");
    __asm { vbroadcastss xmm1, dword ptr [rbp+210h+query.m_ray.m_direction.m_quad+0Ch] }
    _XMM0.m_real = (__m128)Collector->m_earlyOutThreshold;
    __asm { vminps  xmm1, xmm0, xmm1 }
    Collector->m_earlyOutThreshold = (hkSimdFloat32)_XMM1.m_real;
    if ( query.m_shapeTagCodec && (query.m_shapeTagCodec->m_hints.m_storage & 1) != 0 )
    {
      v55 = v46;
      query.m_shapeTagCodec->overrideInitialFilterData((hknpShapeTagCodec *)query.m_shapeTagCodec, RAY_CAST, (const hknpBody *)v63, v18, (hknpQueryFilterData *)&v55);
      v43 = &v55;
    }
    else
    {
      v43 = &v46;
    }
    v18->castRayImpl((hknpShape *)v18, (hknpCollisionQueryContext *)&m_collisionQueryDispatcher, &query, (const hknpQueryFilterData *)v43, (const hknpShapeQueryInfo *)&v63, Collector);
    v44 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v44 )
      hkMonitorStream::timerEnd(v44, "Et");
    if ( !v54 )
    {
      hkReferencedObject::removeReference(v51);
      hkReferencedObject::removeReference(v52);
    }
  }
  else if ( !v54 )
  {
    hkReferencedObject::removeReference(v51);
    hkReferencedObject::removeReference(v52);
  }
}

/*
==============
HavokPhysics_ReadWorld
==============
*/
void HavokPhysics_ReadWorld(SaveGame *save, Physics_WorldId worldId, HavokPhysics_SnapshotFixup *snapshotFixup)
{
  unsigned int v5; 
  unsigned int v6; 
  unsigned int WorldTransientCount; 
  char v8; 
  MemoryFile *p_memFile; 
  const char *WorldTransientName; 
  const char *v11; 
  __int64 v12; 
  const char *v13; 
  signed __int64 v14; 
  int v15; 
  __int64 v16; 
  int v17; 
  int v18; 
  int v19; 
  __int64 v20; 
  __int64 v21; 
  char v22[16]; 
  bool p; 
  char v24; 
  bool v25; 

  if ( !save && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4148, ASSERT_TYPE_ASSERT, "(save)", "%s\n\tHavokPhysics: ReadWorld has NULL save", "save") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4149, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to ReadWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !HavokPhysics_GetMutableWorld(worldId)->world )
  {
    LODWORD(v20) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4153, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics WriteWorld %i: world is NULL", "physicsWorld->world", v20) )
      __debugbreak();
  }
  v5 = 0;
  v6 = 0;
  WorldTransientCount = 1;
  v8 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END|0x80);
  v24 = v8;
  if ( v8 )
  {
    v6 = 32;
    WorldTransientCount = DB_Transients_GetWorldTransientCount();
    v8 = v24;
  }
  if ( v6 )
  {
    p_memFile = &save->memFile;
    do
    {
      if ( v8 && v5 < WorldTransientCount )
      {
        WorldTransientName = DB_Transients_GetWorldTransientName(v5);
        if ( !WorldTransientName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4184, ASSERT_TYPE_ASSERT, "(zoneName)", (const char *)&queryFormat, "zoneName") )
          __debugbreak();
        MemFile_ReadData(p_memFile, 1ui64, &p);
        flag = p;
        if ( !p )
        {
          LODWORD(v20) = v5;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4188, ASSERT_TYPE_ASSERT, "(flag)", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i is valid, but wasn't at save time", "flag", v20) )
            __debugbreak();
        }
        name = MemFile_ReadCString(p_memFile);
        v11 = name;
        v12 = 0x7FFFFFFFi64;
        v13 = WorldTransientName;
        if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        if ( !WorldTransientName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
          __debugbreak();
        v14 = v11 - WorldTransientName;
        do
        {
          v15 = (unsigned __int8)v13[v14];
          v16 = v12;
          v17 = *(unsigned __int8 *)v13++;
          --v12;
          if ( !v16 )
            break;
          if ( v15 != v17 )
          {
            v18 = v15 + 32;
            if ( (unsigned int)(v15 - 65) > 0x19 )
              v18 = v15;
            v15 = v18;
            v19 = v17 + 32;
            if ( (unsigned int)(v17 - 65) > 0x19 )
              v19 = v17;
            if ( v15 != v19 )
            {
              LODWORD(v20) = v5;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4190, ASSERT_TYPE_ASSERT, "(!I_stricmp( name, zoneName ))", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i is %s, but was %s at save time", "!I_stricmp( name, zoneName )", v20, WorldTransientName, name) )
                __debugbreak();
              break;
            }
          }
        }
        while ( v15 );
        MemFile_ReadData(p_memFile, 1ui64, &v25);
        gameLoaded = v25;
        if ( gameLoaded == CL_TransientsSP_IsGameSystemTransientLoaded(v5) )
          goto LABEL_43;
        LODWORD(v21) = gameLoaded;
        LODWORD(v20) = v5;
        if ( !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4192, ASSERT_TYPE_ASSERT, "(gameLoaded == CL_TransientsSP_IsGameSystemTransientLoaded( zoneIt ))", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i gameloaded state is %i, but was different at save time", "gameLoaded == CL_TransientsSP_IsGameSystemTransientLoaded( zoneIt )", v20, v21) )
          goto LABEL_43;
      }
      else
      {
        MemFile_ReadData(p_memFile, 1ui64, v22);
        flag = v22[0];
        if ( !v22[0] )
          goto LABEL_43;
        LODWORD(v20) = v5;
        if ( !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4197, ASSERT_TYPE_ASSERT, "(!flag)", "%s\n\tPhysics load will fail because transients aren't deterministic - zone %i is invalid, but was valid at save time", "!flag", v20) )
          goto LABEL_43;
      }
      __debugbreak();
LABEL_43:
      v8 = v24;
      ++v5;
    }
    while ( v5 < v6 );
  }
}

/*
==============
HavokPhysics_ReleaseMapLocalAllocatorBuffer
==============
*/
void HavokPhysics_ReleaseMapLocalAllocatorBuffer(void)
{
  if ( !s_havokPhysicsMemorySystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2906, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMemorySystem ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsMemorySystem", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2907, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMapLocalLargeBlockAllocator ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsMapLocalLargeBlockAllocator", "nullptr", NULL, NULL) )
    __debugbreak();
  *(_QWORD *)&s_mapLocalMemoryCapacity = 0i64;
  HavokPhysicsFreeListMemorySystem::garbageCollectMapLocal(s_havokPhysicsMemorySystem, 1);
  HavokPhysicsLargeBlockAllocator::releaseBuffer(s_havokPhysicsMapLocalLargeBlockAllocator);
}

/*
==============
HavokPhysics_ReleasePhysicsAsset
==============
*/
void HavokPhysics_ReleasePhysicsAsset(PhysicsAsset *physicsAsset, bool unloadPackFileData)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v3; 
  int m_hashMod; 
  unsigned __int32 v5; 
  unsigned __int32 v6; 
  unsigned int v7; 
  Dummy *v8; 
  PhysicsAsset *key; 

  if ( !physicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7471, ASSERT_TYPE_ASSERT, "(physicsAsset)", "%s\n\tTrying to remove a NULL Physics Asset", "physicsAsset") )
    __debugbreak();
  if ( !physicsAsset->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7472, ASSERT_TYPE_ASSERT, "(physicsAsset->havokData)", "%s\n\tTrying to remove a Physics Asset with NULL data", "physicsAsset->havokData") )
    __debugbreak();
  if ( !physicsAsset->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7473, ASSERT_TYPE_ASSERT, "(physicsAsset->havokDataSize > 0)", "%s\n\tTrying to remove a Physics Asset with 0 data size", "physicsAsset->havokDataSize > 0") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  v3 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7478, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Release a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v3 = s_havokPhysicsAssets;
  }
  m_hashMod = v3->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v5 = _byteswap_ulong(-1640531535 * HIDWORD(physicsAsset)), v6 = _byteswap_ulong(-1640531535 * (_DWORD)physicsAsset), v7 = m_hashMod & (v5 ^ ((v6 >> 2) + v6 + (v5 << 6) - 1640531527)), v8 = (Dummy *)v7, key = (PhysicsAsset *)v3->m_map.m_elem[v7].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_18:
    v8 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != physicsAsset )
    {
      v7 = m_hashMod & (v7 + 1);
      v8 = (Dummy *)v7;
      key = (PhysicsAsset *)v3->m_map.m_elem[v7].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_18;
    }
  }
  if ( (int)v8 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7479, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->remove( physicsAsset ).isSuccess())", (const char *)&queryFormat, "s_havokPhysicsAssets->remove( physicsAsset ).isSuccess()") )
      __debugbreak();
  }
  else
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v3->m_map, v8);
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_ReleasePhysicsLibrary
==============
*/
void HavokPhysics_ReleasePhysicsLibrary(PhysicsLibrary *physicsLibrary)
{
  int i; 
  int j; 
  hkArray<char,hkContainerHeapAllocator> *v8; 
  hkMemoryAllocator *v9; 
  int m_capacityAndFlags; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "HavokPhysics_ReleasePhysicsLibrary");
  if ( !physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6907, ASSERT_TYPE_ASSERT, "(physicsLibrary)", "%s\n\tTrying to release a NULL Physics Library", "physicsLibrary") )
    __debugbreak();
  if ( !physicsLibrary->havokData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6908, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokData)", "%s\n\tTrying to release a Physics Library with NULL data", "physicsLibrary->havokData") )
    __debugbreak();
  if ( !physicsLibrary->havokDataSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6909, ASSERT_TYPE_ASSERT, "(physicsLibrary->havokDataSize > 0)", "%s\n\tTrying to release a Physics Library with 0 data size", "physicsLibrary->havokDataSize > 0") )
    __debugbreak();
  if ( physicsLibrary->isBodyQualityList )
  {
    if ( !s_havokPhysicsBodyQualityLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6914, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.list != nullptr)", "%s\n\tExpecting a Havok Body Quality library", "s_havokPhysicsBodyQualityLibrary.list != HK_NULL") )
      __debugbreak();
    if ( s_havokPhysicsBodyQualityLibrary.asset != physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6915, ASSERT_TYPE_ASSERT, "(s_havokPhysicsBodyQualityLibrary.asset == physicsLibrary)", "%s\n\tIncorrect Havok Body Quality library asset", "s_havokPhysicsBodyQualityLibrary.asset == physicsLibrary") )
      __debugbreak();
    __asm { vpxor   xmm0, xmm0, xmm0 }
    s_havokPhysicsBodyQualityLibrary = _XMM0;
  }
  else if ( physicsLibrary->isMaterialList )
  {
    if ( !s_havokPhysicsMaterialLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6927, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.list != nullptr)", "%s\n\tExpecting a Havok Material library", "s_havokPhysicsMaterialLibrary.list != HK_NULL") )
      __debugbreak();
    if ( s_havokPhysicsMaterialLibrary.asset != physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6928, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMaterialLibrary.asset == physicsLibrary)", "%s\n\tIncorrect Havok Material library asset", "s_havokPhysicsMaterialLibrary.asset == physicsLibrary") )
      __debugbreak();
    for ( i = 7; i >= 0; --i )
      HavokPhysics_RemoveMaterialLibraryFromWorld(&s_havokPhysicsMaterialLibrary, (Physics_WorldId)i);
    __asm { vpxor   xmm0, xmm0, xmm0 }
    *(_OWORD *)&s_havokPhysicsMaterialLibrary.asset = _XMM0;
    *(_DWORD *)&s_havokPhysicsMaterialLibrary.firstId.m_value = -1;
  }
  else if ( physicsLibrary->isMotionPropertiesList )
  {
    if ( !s_havokPhysicsMotionPropertiesLibrary.list && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6942, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.list != nullptr)", "%s\n\tExpecting a Havok Motion Properties library", "s_havokPhysicsMotionPropertiesLibrary.list != HK_NULL") )
      __debugbreak();
    if ( s_havokPhysicsMotionPropertiesLibrary.asset != physicsLibrary && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6943, ASSERT_TYPE_ASSERT, "(s_havokPhysicsMotionPropertiesLibrary.asset == physicsLibrary)", "%s\n\tIncorrect Havok Motion Properties library asset", "s_havokPhysicsMotionPropertiesLibrary.asset == physicsLibrary") )
      __debugbreak();
    for ( j = 7; j >= 0; --j )
      HavokPhysics_RemoveMotionPropertiesLibraryFromWorld(&s_havokPhysicsMotionPropertiesLibrary, (Physics_WorldId)j);
    __asm { vpxor   xmm0, xmm0, xmm0 }
    *(_OWORD *)&s_havokPhysicsMotionPropertiesLibrary.asset = _XMM0;
    *(_DWORD *)&s_havokPhysicsMotionPropertiesLibrary.firstId.m_value = -1;
  }
  else if ( physicsLibrary->isGlobalTypeCompendium )
  {
    if ( !s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6958, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", NULL, NULL) )
      __debugbreak();
    hkSerialize::InplaceLoad::~InplaceLoad(s_havokPhysicsInPlaceLoad);
    s_havokPhysicsInPlaceLoad = NULL;
    if ( !s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6964, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", NULL, NULL) )
      __debugbreak();
    s_havokPhysicsGlobalTypeCompendiumTypes = NULL;
    if ( !s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6969, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", NULL, NULL) )
      __debugbreak();
    v8 = s_havokPhysicsGlobalTypeCompendiumData;
    v9 = hkMemHeapAllocator();
    v8->m_size = 0;
    m_capacityAndFlags = v8->m_capacityAndFlags;
    if ( m_capacityAndFlags >= 0 )
      hkMemoryAllocator::bufFree2(v9, v8->m_data, 1, m_capacityAndFlags & 0x3FFFFFFF);
    v8->m_data = NULL;
    v8->m_capacityAndFlags = 0x80000000;
    s_havokPhysicsGlobalTypeCompendiumData = NULL;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6976, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid Physics Library - type unknown") )
  {
    __debugbreak();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
HavokPhysics_ReleasePhysicsSFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsSFXEventAsset(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  HavokPhysics_RemovePhysicsSFXAssetInternal(physicsSFXEventAsset);
}

/*
==============
HavokPhysics_ReleasePhysicsVFXEventAsset
==============
*/

void __fastcall HavokPhysics_ReleasePhysicsVFXEventAsset(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  HavokPhysics_RemovePhysicsVFXAssetInternal(physicsVFXEventAsset);
}

/*
==============
HavokPhysics_ReleaseShape
==============
*/
void HavokPhysics_ReleaseShape(Physics_WorldId worldId, hknpShape *shape, bool finalReference)
{
  unsigned __int16 m_refCount; 
  int v7; 
  HavokPhysicsWorld *MutableWorld; 
  hkPointerMap<hknpShape const *,float,hkContainerHeapAllocator> *capsuleRadii; 
  int m_hashMod; 
  unsigned __int32 v11; 
  unsigned __int32 v12; 
  unsigned int v13; 
  Dummy *v14; 
  hknpShape *key; 
  signed __int32 v16[8]; 
  __int64 v17; 

  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16093, ASSERT_TYPE_ASSERT, "(shape)", (const char *)&queryFormat, "shape") )
    __debugbreak();
  _InterlockedOr(v16, 0);
  m_refCount = shape->m_refCount;
  _InterlockedOr(v16, 0);
  if ( finalReference )
  {
    if ( m_refCount == 1 )
      goto LABEL_10;
  }
  else if ( m_refCount > 1u )
  {
    goto LABEL_22;
  }
  _InterlockedOr(v16, 0);
  v7 = shape->m_refCount;
  _InterlockedOr(v16, 0);
  LODWORD(v17) = v7;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16094, ASSERT_TYPE_ASSERT, "((finalReference && shape->getReferenceCount() == 1) || (!finalReference && shape->getReferenceCount() > 1))", "%s\n\tAttempting to release final reference for shape with bad refcount %i (0 - already released, >1 - still in use, corrupt - released and reused", "(finalReference && shape->getReferenceCount() == 1) || (!finalReference && shape->getReferenceCount() > 1)", v17) )
    __debugbreak();
LABEL_10:
  if ( finalReference && shape->m_type.m_storage == 3 )
  {
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    if ( !MutableWorld->world )
    {
      LODWORD(v17) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16100, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics ReleaseShape %i: world is NULL", "physicsWorld->world", v17) )
        __debugbreak();
    }
    capsuleRadii = MutableWorld->capsuleRadii;
    m_hashMod = capsuleRadii->m_map.m_hashMod;
    if ( m_hashMod <= 0 || (v11 = _byteswap_ulong(-1640531535 * HIDWORD(shape)), v12 = _byteswap_ulong(-1640531535 * (_DWORD)shape), v13 = m_hashMod & (v11 ^ ((v12 >> 2) + v12 + (v11 << 6) - 1640531527)), v14 = (Dummy *)v13, key = (hknpShape *)capsuleRadii->m_map.m_elem[v13].key, key == (hknpShape *)-1i64) )
    {
LABEL_19:
      v14 = (Dummy *)(m_hashMod + 1);
    }
    else
    {
      while ( key != shape )
      {
        v13 = m_hashMod & (v13 + 1);
        v14 = (Dummy *)v13;
        key = (hknpShape *)capsuleRadii->m_map.m_elem[v13].key;
        if ( key == (hknpShape *)-1i64 )
          goto LABEL_19;
      }
    }
    if ( (int)v14 <= m_hashMod )
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&MutableWorld->capsuleRadii->m_map, v14);
  }
LABEL_22:
  hkReferencedObject::removeReference(shape);
}

/*
==============
HavokPhysics_ReleaseXModelAsset
==============
*/
void HavokPhysics_ReleaseXModelAsset(XModel *xmodel)
{
  int Index; 
  __int64 v3; 
  hkArray<XModel const *,hkContainerHeapAllocator> *v4; 
  __int64 m_size; 

  if ( !xmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7858, ASSERT_TYPE_ASSERT, "(xmodel)", "%s\n\tTrying to remove a NULL XModel Asset", "xmodel") )
    __debugbreak();
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7861, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tTrying to Release an xmodel asset but the array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  Index = HavokPhysics_DebugXModelGetIndex(xmodel);
  v3 = Index;
  if ( Index < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7863, ASSERT_TYPE_ASSERT, "(xModelId >= 0)", "%s\n\txmodel doesn't exist in debug list", "xModelId >= 0") )
    __debugbreak();
  v4 = s_havokPhysicsXModels;
  m_size = s_havokPhysicsXModels->m_size;
  s_havokPhysicsXModels->m_size = m_size - 1;
  if ( (_DWORD)m_size - 1 != (_DWORD)v3 )
    v4->m_data[v3] = v4->m_data[m_size - 1];
}

/*
==============
HavokPhysics_ReleaseXModelDetailCollisionAsset
==============
*/
void HavokPhysics_ReleaseXModelDetailCollisionAsset(XModelDetailCollision *detailCollision, bool unloadPackFileData)
{
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v3; 
  int m_hashMod; 
  unsigned __int32 v5; 
  unsigned __int32 v6; 
  unsigned int v7; 
  Dummy *v8; 
  XModelDetailCollision *key; 

  HavokPhysics_LockAssetWrite();
  v3 = s_havokPhysicsXModelLODs;
  if ( !s_havokPhysicsXModelLODs )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7873, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tTrying to Release an detailCollision asset but the pointermap is NULL", "s_havokPhysicsXModelLODs") )
      __debugbreak();
    v3 = s_havokPhysicsXModelLODs;
  }
  m_hashMod = v3->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v5 = _byteswap_ulong(-1640531535 * HIDWORD(detailCollision)), v6 = _byteswap_ulong(-1640531535 * (_DWORD)detailCollision), v7 = m_hashMod & (v5 ^ ((v6 >> 2) + v6 + (v5 << 6) - 1640531527)), v8 = (Dummy *)v7, key = (XModelDetailCollision *)v3->m_map.m_elem[v7].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_9:
    v8 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != detailCollision )
    {
      v7 = m_hashMod & (v7 + 1);
      v8 = (Dummy *)v7;
      key = (XModelDetailCollision *)v3->m_map.m_elem[v7].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_9;
    }
  }
  if ( (int)v8 <= m_hashMod )
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v3->m_map, v8);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_RemoveClipMap
==============
*/
void HavokPhysics_RemoveClipMap(clipMap_t *clipMap)
{
  ;
}

/*
==============
HavokPhysics_RemoveInstanceFromWorld
==============
*/
void HavokPhysics_RemoveInstanceFromWorld(Physics_WorldId worldId, unsigned int instanceId, bool activate)
{
  __int64 v3; 
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsInstanceManager *p_instanceManager; 
  hknpBodyId *m_data; 
  int m_size; 
  int v10; 
  __int64 v11; 

  v3 = instanceId;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11183, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to remove instance from world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v3 == -1 )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11184, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to remove instance from world with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11189, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics RemoveInstanceFromWorld %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  p_instanceManager = &MutableWorld->instanceManager;
  if ( MutableWorld == (HavokPhysicsWorld *)-192i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  m_data = p_instanceManager->buffer[v3].bodies.m_data;
  m_size = p_instanceManager->buffer[v3].bodies.m_size;
  if ( HavokPhysics_IsInstanceDetailBounded(worldId, v3) )
  {
    v10 = m_size - 1;
    m_size = 1;
    m_data += v10;
  }
  HavokPhysics_RemoveRigidBodiesFromWorld(worldId, m_data, m_size, activate);
  HavokPhysicsInstanceManager_SetAddedToWorld(worldId, p_instanceManager, v3, 0, 0);
}

/*
==============
HavokPhysics_RemoveMaterialLibraryFromWorld
==============
*/
void HavokPhysics_RemoveMaterialLibraryFromWorld(HavokPhysicsMaterialLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  unsigned __int16 i; 
  __int64 v7; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6826, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Remove Material Library from world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v7) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6834, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Remove Material Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMaterialLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v7) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6846, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMaterialLibrary())", "%s\n\tHavokPhysics: Trying to Remove Material Library with world index %i, but can't find world library to remove from", "havokPhysicsWorld->world->getMaterialLibrary()", v7) )
          __debugbreak();
      }
      for ( i = library->lastId.m_value; i != 0xFFFF; hknpMaterialLibrary::removeEntry(MutableWorld->world->m_materialLibrary.m_ptr, (hknpMaterialId)i--) )
      {
        if ( i < library->firstId.m_value )
          break;
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  }
}

/*
==============
HavokPhysics_RemoveModifier
==============
*/
void HavokPhysics_RemoveModifier(Physics_WorldId worldId, hknpModifier *modifier)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16446, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to RemoveModifier with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16450, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics RemoveModifier %i: world is NULL", "physicsWorld->world", v5) )
      __debugbreak();
  }
  hknpModifierManager::removeModifier(MutableWorld->world->m_modifierManager, modifier);
}

/*
==============
HavokPhysics_RemoveMotionPropertiesLibraryFromWorld
==============
*/
void HavokPhysics_RemoveMotionPropertiesLibraryFromWorld(HavokPhysicsMotionPropertiesLibrary *library, Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  hknpWorld *world; 
  unsigned __int16 i; 
  __int64 v7; 

  if ( !library && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6868, ASSERT_TYPE_ASSERT, "(library)", "%s\n\tHavokPhysics: Trying to Remove MotionProperties Library from world %i with invalid library", "library", worldId) )
    __debugbreak();
  if ( library->list )
  {
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
    {
      LODWORD(v7) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6876, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Remove MotionProperties Library with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v7) )
        __debugbreak();
    }
    MutableWorld = HavokPhysics_GetMutableWorld(worldId);
    EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
    world = MutableWorld->world;
    if ( world )
    {
      if ( !world->getMotionPropertiesLibrary(&world->hknpWorldReader) )
      {
        LODWORD(v7) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6888, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world->getMotionPropertiesLibrary())", "%s\n\tHavokPhysics: Trying to Remove MotionProperties Library with world index %i, but can't find world library to remove from", "havokPhysicsWorld->world->getMotionPropertiesLibrary()", v7) )
          __debugbreak();
      }
      for ( i = library->lastId.m_value; i != 0xFFFF; hknpMotionPropertiesLibrary::removeEntry(MutableWorld->world->m_motionPropertiesLibrary.m_ptr, (hknpMotionPropertiesId)i--) )
      {
        if ( i < library->firstId.m_value )
          break;
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  }
}

/*
==============
HavokPhysics_RemovePhysicsSFXAssetInternal
==============
*/
__int64 HavokPhysics_RemovePhysicsSFXAssetInternal(PhysicsSFXEventAsset *physicsSFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  const char *v4; 
  unsigned int i; 
  __int64 v6; 
  unsigned int v7; 
  int m_hashMod; 
  unsigned __int32 v9; 
  unsigned int v10; 
  unsigned int key; 
  __int64 v12; 
  const char *v13; 
  signed __int64 v14; 
  char v15; 
  __int64 v16; 
  char v17; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v18; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  int v20; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned int v24; 
  __int64 v25; 
  unsigned __int32 v26; 
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v27; 

  if ( !physicsSFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7048, ASSERT_TYPE_ASSERT, "(physicsSFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsSFXEventAsset", "physicsSFXEventAsset") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7049, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", "%s\n\tTrying to add a physics SFXevent asset but the container is NULL", "g_physicsSFXEventAssets") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  name = physicsSFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  v4 = physicsSFXEventAsset->name;
  for ( i = -1; v3; --v3 )
  {
    v6 = *(unsigned __int8 *)v4++;
    i = (i >> 8) ^ g_crc32Table[v6 ^ (unsigned __int8)i];
  }
  v7 = ~i;
  m_hashMod = g_physicsSFXEventAssets->m_hashMod;
  if ( m_hashMod <= 0 || (v9 = m_hashMod & _byteswap_ulong(-1640531535 * v7), v10 = v9, key = g_physicsSFXEventAssets->m_elem[v9].key, key == -1) )
  {
LABEL_15:
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != v7 )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = g_physicsSFXEventAssets->m_elem[v9].key;
      if ( key == -1 )
        goto LABEL_15;
    }
  }
  if ( (signed int)v10 > g_physicsSFXEventAssets->m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7066, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "SFX event asset %s not found", name) )
      __debugbreak();
  }
  else
  {
    v12 = 0x7FFFFFFFi64;
    v13 = g_physicsSFXEventAssets->m_elem[v10].val->name;
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v14 = v13 - name;
    do
    {
      v15 = name[v14];
      v16 = v12;
      v17 = *name++;
      --v12;
      if ( !v16 )
        break;
      if ( v15 != v17 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7060, ASSERT_TYPE_ASSERT, "(I_strcmp( g_physicsSFXEventAssets->getValue( it )->name, physicsSFXEventAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( g_physicsSFXEventAssets->getValue( it )->name, physicsSFXEventAsset->name ) == 0", g_physicsSFXEventAssets->m_elem[v10].val->name, physicsSFXEventAsset->name) )
          __debugbreak();
        break;
      }
    }
    while ( v15 );
    if ( g_physicsSFXEventAssets->m_elem[v10].val != physicsSFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7061, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets->getValue( it ) == physicsSFXEventAsset)", (const char *)&queryFormat, "g_physicsSFXEventAssets->getValue( it ) == physicsSFXEventAsset") )
      __debugbreak();
    v18 = g_physicsSFXEventAssets;
    m_elem = g_physicsSFXEventAssets->m_elem;
    --g_physicsSFXEventAssets->m_numElems;
    m_elem[v10].key = -1;
    v20 = v18->m_hashMod;
    v21 = v18->m_elem;
    v22 = v20 & (v20 + v10);
    if ( v18->m_elem[v22].key != -1 )
    {
      do
        v22 = v20 & (v20 + v22);
      while ( v21[v22].key != -1 );
    }
    v23 = v20 & (v10 + 1);
    v24 = v20 & (v22 + 1);
    v25 = v23;
    if ( v21[v25].key != -1 )
    {
      do
      {
        v26 = v20 & _byteswap_ulong(-1640531535 * v21[v25].key);
        if ( v23 < v24 || (v27 = v21, v26 <= v10) )
        {
          if ( v23 >= v10 || v26 <= v10 && v26 > v23 )
          {
            if ( v26 <= v10 || (v27 = v21, v26 >= v24) )
            {
              hkMemUtil::memCpy(&v21[v10], &v21[v25], 16i64);
              v10 = v23;
              v18->m_elem[v25].key = -1;
              v20 = v18->m_hashMod;
              v27 = v18->m_elem;
            }
          }
          else
          {
            v27 = v21;
          }
        }
        v21 = v27;
        v23 = v20 & (v23 + 1);
        v25 = v23;
      }
      while ( v27[v25].key != -1 );
    }
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v7;
}

/*
==============
HavokPhysics_RemovePhysicsVFXAssetInternal
==============
*/
__int64 HavokPhysics_RemovePhysicsVFXAssetInternal(PhysicsVFXEventAsset *physicsVFXEventAsset)
{
  const char *name; 
  __int64 v3; 
  const char *v4; 
  unsigned int i; 
  __int64 v6; 
  unsigned int v7; 
  int m_hashMod; 
  unsigned __int32 v9; 
  unsigned int v10; 
  unsigned int key; 
  __int64 v12; 
  const char *v13; 
  signed __int64 v14; 
  char v15; 
  __int64 v16; 
  char v17; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v18; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *m_elem; 
  int v20; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned int v24; 
  __int64 v25; 
  unsigned __int32 v26; 
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int> >::Pair *v27; 

  if ( !physicsVFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7212, ASSERT_TYPE_ASSERT, "(physicsVFXEventAsset)", "%s\n\tTrying to add a NULL PhysicsVFXEventAsset", "physicsVFXEventAsset") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7213, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", "%s\n\tTrying to Add a physics VFXevent asset but the container is NULL", "g_physicsVFXEventAssets") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  name = physicsVFXEventAsset->name;
  v3 = -1i64;
  do
    ++v3;
  while ( name[v3] );
  v4 = physicsVFXEventAsset->name;
  for ( i = -1; v3; --v3 )
  {
    v6 = *(unsigned __int8 *)v4++;
    i = (i >> 8) ^ g_crc32Table[v6 ^ (unsigned __int8)i];
  }
  v7 = ~i;
  m_hashMod = g_physicsVFXEventAssets->m_hashMod;
  if ( m_hashMod <= 0 || (v9 = m_hashMod & _byteswap_ulong(-1640531535 * v7), v10 = v9, key = g_physicsVFXEventAssets->m_elem[v9].key, key == -1) )
  {
LABEL_15:
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != v7 )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = g_physicsVFXEventAssets->m_elem[v9].key;
      if ( key == -1 )
        goto LABEL_15;
    }
  }
  if ( (signed int)v10 > g_physicsVFXEventAssets->m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7230, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "VFX event asset %s not found", name) )
      __debugbreak();
  }
  else
  {
    v12 = 0x7FFFFFFFi64;
    v13 = g_physicsVFXEventAssets->m_elem[v10].val->name;
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v14 = v13 - name;
    do
    {
      v15 = name[v14];
      v16 = v12;
      v17 = *name++;
      --v12;
      if ( !v16 )
        break;
      if ( v15 != v17 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7224, ASSERT_TYPE_ASSERT, "(I_strcmp( g_physicsVFXEventAssets->getValue( it )->name, physicsVFXEventAsset->name ) == 0)", "%s\n\tCRC clash between %s and %s", "I_strcmp( g_physicsVFXEventAssets->getValue( it )->name, physicsVFXEventAsset->name ) == 0", g_physicsVFXEventAssets->m_elem[v10].val->name, physicsVFXEventAsset->name) )
          __debugbreak();
        break;
      }
    }
    while ( v15 );
    if ( g_physicsVFXEventAssets->m_elem[v10].val != physicsVFXEventAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7225, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets->getValue( it ) == physicsVFXEventAsset)", (const char *)&queryFormat, "g_physicsVFXEventAssets->getValue( it ) == physicsVFXEventAsset") )
      __debugbreak();
    v18 = g_physicsVFXEventAssets;
    m_elem = g_physicsVFXEventAssets->m_elem;
    --g_physicsVFXEventAssets->m_numElems;
    m_elem[v10].key = -1;
    v20 = v18->m_hashMod;
    v21 = v18->m_elem;
    v22 = v20 & (v20 + v10);
    if ( v18->m_elem[v22].key != -1 )
    {
      do
        v22 = v20 & (v20 + v22);
      while ( v21[v22].key != -1 );
    }
    v23 = v20 & (v10 + 1);
    v24 = v20 & (v22 + 1);
    v25 = v23;
    if ( v21[v25].key != -1 )
    {
      do
      {
        v26 = v20 & _byteswap_ulong(-1640531535 * v21[v25].key);
        if ( v23 < v24 || (v27 = v21, v26 <= v10) )
        {
          if ( v23 >= v10 || v26 <= v10 && v26 > v23 )
          {
            if ( v26 <= v10 || (v27 = v21, v26 >= v24) )
            {
              hkMemUtil::memCpy(&v21[v10], &v21[v25], 16i64);
              v10 = v23;
              v18->m_elem[v25].key = -1;
              v20 = v18->m_hashMod;
              v27 = v18->m_elem;
            }
          }
          else
          {
            v27 = v21;
          }
        }
        v21 = v27;
        v23 = v20 & (v23 + 1);
        v25 = v23;
      }
      while ( v27[v25].key != -1 );
    }
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
  return v7;
}

/*
==============
HavokPhysics_RemoveRigidBodiesFromWorld
==============
*/
void HavokPhysics_RemoveRigidBodiesFromWorld(Physics_WorldId worldId, hknpBodyId *bodyIds, int bodyCount, bool activate)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11218, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to remove rigid bodies from world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !bodyIds && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11219, ASSERT_TYPE_ASSERT, "(bodyIds)", (const char *)&queryFormat, "bodyIds") )
    __debugbreak();
  if ( bodyCount <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11220, ASSERT_TYPE_ASSERT, "(bodyCount > 0)", (const char *)&queryFormat, "bodyCount > 0") )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11224, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics RemoveRigidBodiesFromWorld %i: world is NULL", "havokPhysicsWorld->world", v9) )
      __debugbreak();
  }
  MutableWorld->world->removeBodies(&MutableWorld->world->hknpWorldWriter, bodyIds, bodyCount, (hknpWorldWriter::ActivationMode)!activate);
}

/*
==============
HavokPhysics_RemoveShapeList
==============
*/
void HavokPhysics_RemoveShapeList(char *rawShapeData, unsigned int rawShapeDataSize)
{
  ;
}

/*
==============
HavokPhysics_RenderDebug
==============
*/
void HavokPhysics_RenderDebug(GfxCmdBufContext *gfxContext, bool includeWorlds)
{
  int v3; 
  hkCriticalSection *p_critSection; 
  __int64 v5; 
  GfxCmdBufContext v6; 

  if ( includeWorlds )
  {
    v3 = 0;
    p_critSection = &g_havokPhysicsWorlds[0].critSection;
    do
    {
      if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 43, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tCan't access the mutable physics world within usermove workers", "!Sys_IsServerUserMoveWorker()") )
        __debugbreak();
      if ( (unsigned int)v3 > 7 )
      {
        LODWORD(v5) = v3;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 45, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to access invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v5) )
          __debugbreak();
      }
      EnterCriticalSection((LPCRITICAL_SECTION)p_critSection);
      if ( p_critSection[-4].m_section.SpinCount )
      {
        if ( !p_critSection[74].m_section.SpinCount )
        {
          LODWORD(v5) = v3;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17479, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->displayHandler)", "%s\n\tHavokPhysics: RenderDebug has invalid display handler for world %i", "havokPhysicsWorld->displayHandler", v5) )
            __debugbreak();
        }
        v6 = *gfxContext;
        HavokPhysicsDisplayHandler::render((HavokPhysicsDisplayHandler *)p_critSection[74].m_section.SpinCount, &v6);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)p_critSection);
      ++v3;
      p_critSection += 96;
    }
    while ( v3 < 8 );
  }
}

/*
==============
HavokPhysics_SetDebugCameras
==============
*/
void HavokPhysics_SetDebugCameras(const GfxViewInfo *viewInfo)
{
  unsigned __int64 clientIndex; 
  float v2; 
  unsigned __int64 v3; 

  clientIndex = viewInfo->clientIndex;
  if ( clientIndex >= 2 )
  {
    j___report_rangecheckfailure(viewInfo);
    JUMPOUT(0x141B5EEA9i64);
  }
  v2 = 0.03125 * viewInfo->viewParmsSet.frames[0].viewParms.camera.origin.v[0];
  v3 = clientIndex;
  s_havokPhysics_VdbCameraSet[clientIndex] = 1;
  s_havokPhysics_VdbCameraOrigin[v3].m_quad.m128_f32[0] = v2;
  s_havokPhysics_VdbCameraOrigin[v3].m_quad.m128_f32[1] = 0.03125 * viewInfo->viewParmsSet.frames[0].viewParms.camera.origin.v[1];
  s_havokPhysics_VdbCameraOrigin[v3].m_quad.m128_f32[2] = 0.03125 * viewInfo->viewParmsSet.frames[0].viewParms.camera.origin.v[2];
  s_havokPhysics_VdbCameraOrigin[v3].m_quad.m128_i32[3] = 0;
  _XMM2 = 0i64;
  __asm
  {
    vinsertps xmm2, xmm2, dword ptr [rcx+10Ch], 0
    vinsertps xmm2, xmm2, dword ptr [rcx+110h], 10h
    vinsertps xmm2, xmm2, dword ptr [rcx+114h], 20h ; ' '
  }
  _XMM1 = 0i64;
  s_havokPhysics_VdbCameraLookat[v3].m_quad = _mm128_add_ps(_mm128_mul_ps(_XMM2, (__m128)_xmm), s_havokPhysics_VdbCameraOrigin[clientIndex].m_quad);
  __asm
  {
    vinsertps xmm1, xmm1, dword ptr [rcx+124h], 0
    vinsertps xmm1, xmm1, dword ptr [rcx+128h], 10h
    vinsertps xmm1, xmm1, dword ptr [rcx+12Ch], 20h ; ' '
  }
  s_havokPhysics_VdbCameraUp[v3] = (hkVector4f)_XMM1.m_quad;
}

/*
==============
HavokPhysics_SetErrorString
==============
*/
void HavokPhysics_SetErrorString(const char *string)
{
  s_errorExtraString = string;
}

/*
==============
HavokPhysics_SetInstanceDetailModel
==============
*/
void HavokPhysics_SetInstanceDetailModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  const HavokPhysicsWorld *ConstWorld; 
  const XModel *DetailModel; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11018, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Instance detail model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11019, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to set detail model Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v9) )
      __debugbreak();
  }
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10954, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Instance detail Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v9) )
      __debugbreak();
  }
  if ( instanceId == -1 )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10955, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get detailInstance Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v9) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 10960, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics GetDetailModel %i: world is NULL", "havokPhysicsWorld->world", v9) )
      __debugbreak();
  }
  DetailModel = HavokPhysicsInstanceManager_GetDetailModel(&ConstWorld->instanceManager, instanceId);
  if ( !xModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9944, ASSERT_TYPE_ASSERT, "(detailModelA)", (const char *)&queryFormat, "detailModelA") )
    __debugbreak();
  if ( !DetailModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 9945, ASSERT_TYPE_ASSERT, "(detailModelB)", (const char *)&queryFormat, "detailModelB") )
    __debugbreak();
  if ( xModel->detailCollision != DetailModel->detailCollision || DetailModel->radius != xModel->radius )
  {
    LODWORD(v9) = instanceId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11020, ASSERT_TYPE_ASSERT, "(HavokPhysics_AreDetailModelsInterchangeable( xModel, HavokPhysics_GetInstanceDetailModel( worldId, instanceId ) ))", "%s\n\tHavok Physics: Trying to set detail model that is not interchangeable with the existing model at instance %i in world %i", "HavokPhysics_AreDetailModelsInterchangeable( xModel, HavokPhysics_GetInstanceDetailModel( worldId, instanceId ) )", v9, worldId) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11024, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetXModel %i: world is NULL", "havokPhysicsWorld->world", v9) )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_SetDetailModel(&MutableWorld->instanceManager, instanceId, xModel);
}

/*
==============
HavokPhysics_SetInstanceXModel
==============
*/
void HavokPhysics_SetInstanceXModel(Physics_WorldId worldId, unsigned int instanceId, const XModel *xModel)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11000, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Instance model Asset with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( instanceId == -1 )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11001, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to set model Asset with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v7) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11005, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetXModel %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  HavokPhysicsInstanceManager_SetXModel(&MutableWorld->instanceManager, instanceId, xModel);
}

/*
==============
HavokPhysics_SetMainShapeList
==============
*/
void HavokPhysics_SetMainShapeList(HavokPhysicsShapeList *shapeList)
{
  if ( !s_shapeTagCodec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7638, ASSERT_TYPE_ASSERT, "(s_shapeTagCodec)", (const char *)&queryFormat, "s_shapeTagCodec") )
    __debugbreak();
  HavokPhysics_LockAssetWrite();
  if ( shapeList )
    HavokPhysicsShapeTagCodec::SetData(s_shapeTagCodec, &shapeList->m_shapeTagData);
  else
    HavokPhysicsShapeTagCodec::Clear(s_shapeTagCodec);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SetMapLocalAllocatorBuffer
==============
*/
void HavokPhysics_SetMapLocalAllocatorBuffer(void *buffer, unsigned int size)
{
  *(_QWORD *)&s_mapLocalMemoryCapacity = size;
  if ( !s_havokPhysicsMapLocalLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2898, ASSERT_TYPE_ASSERT, "( s_havokPhysicsMapLocalLargeBlockAllocator ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_havokPhysicsMapLocalLargeBlockAllocator", "nullptr", NULL, NULL) )
    __debugbreak();
  HavokPhysicsLargeBlockAllocator::setBuffer(s_havokPhysicsMapLocalLargeBlockAllocator, buffer, size);
}

/*
==============
HavokPhysics_SetMassPropertiesCenterOfMass
==============
*/
void HavokPhysics_SetMassPropertiesCenterOfMass(hkMassProperties *massProperties, hkVector4f *centerOfMass)
{
  massProperties->m_centerOfMass = (hkVector4f)centerOfMass->m_quad;
}

/*
==============
HavokPhysics_SetMassPropertiesInertiaTensor
==============
*/
void HavokPhysics_SetMassPropertiesInertiaTensor(hkMassProperties *massProperties, hkVector4f *inertiaTensor)
{
  *(__m256i *)massProperties->m_inertiaTensor.m_col0.m_quad.m128_f32 = (__m256i)0i64;
  massProperties->m_inertiaTensor.m_col2 = 0i64;
  massProperties->m_inertiaTensor.m_col0.m_quad.m128_i32[0] = inertiaTensor->m_quad.m128_i32[0];
  massProperties->m_inertiaTensor.m_col1.m_quad.m128_i32[1] = inertiaTensor->m_quad.m128_i32[1];
  massProperties->m_inertiaTensor.m_col2.m_quad.m128_i32[2] = inertiaTensor->m_quad.m128_i32[2];
}

/*
==============
HavokPhysics_SetMassPropertiesMass
==============
*/
void HavokPhysics_SetMassPropertiesMass(hkMassProperties *massProperties, float mass)
{
  massProperties->m_mass = mass;
}

/*
==============
HavokPhysics_SetRigidBodyCenterOfMass
==============
*/
void HavokPhysics_SetRigidBodyCenterOfMass(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *centerOfMass)
{
  hknpWorld *world; 
  __int64 v7; 
  __int64 v8; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11770, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Rigid Body center of mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11771, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to set Rigid Body center of mass with invalid body id for world %i", "bodyId.isValid()", v8) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v8) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11776, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics SetRigidBodyCenterOfMass %i: world is NULL", "world", v8) )
      __debugbreak();
  }
  v7 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v7 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11779, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, const hkVector4f *))world->setMotionCenterOfMass)(&world->hknpWorldWriter, *(unsigned int *)(v7 + 64), centerOfMass);
}

/*
==============
HavokPhysics_SetRigidBodyContents
==============
*/
void HavokPhysics_SetRigidBodyContents(Physics_WorldId worldId, hknpBodyId bodyId, int contents, bool forceCacheRebuild)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 
  _BOOL8 v10; 
  __int64 v11; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11889, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody contents with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11890, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody contents with invalid body id for world %i", "bodyId.isValid()", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11895, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyContents %i: world is NULL", "havokPhysicsWorld->world", v11) )
      __debugbreak();
  }
  v9 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v10 = !forceCacheRebuild && (*(_BYTE *)(v9 + 68) & 9) == 0;
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, _BOOL8))MutableWorld->world->setBodyCollisionFilterInfo)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, (unsigned int)contents, v10);
}

/*
==============
HavokPhysics_SetRigidBodyDynamic
==============
*/
void HavokPhysics_SetRigidBodyDynamic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11997, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody Dynamic with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11998, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody Dynamic with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12003, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyDynamic %i: world is NULL", "havokPhysicsWorld->world", v5) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 2i64);
}

/*
==============
HavokPhysics_SetRigidBodyInverseInertiaLocal
==============
*/
void HavokPhysics_SetRigidBodyInverseInertiaLocal(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *invInertia)
{
  hknpWorld *world; 
  __int64 v8; 
  __int64 v16; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11788, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to set Rigid Body inverse inertia with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11789, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to set Rigid Body inverse inertia with invalid body id for world %i", "bodyId.isValid()", v16) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11794, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics SetRigidBodyCenterOfMass %i: world is NULL", "world", v16) )
      __debugbreak();
  }
  v8 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBody)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( *(_DWORD *)(v8 + 64) == 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11797, ASSERT_TYPE_ASSERT, "(body.m_motionId.isValid())", (const char *)&queryFormat, "body.m_motionId.isValid()") )
    __debugbreak();
  _XMM0 = invInertia->m_quad;
  __asm
  {
    vpxor   xmm1, xmm1, xmm1
    vpunpcklwd xmm3, xmm1, xmm2
    vblendps xmm2, xmm0, xmm3, 8
  }
  _XMM0 = _mm128_mul_ps(_XMM2, g_vectorfConstants[51]);
  __asm
  {
    vpsrad  xmm2, xmm0, 10h
    vpackssdw xmm1, xmm2, xmm2
  }
  *(double *)&world->m_motionManager.m_motions.m_objects.m_data[(unsigned __int64)*(unsigned int *)(v8 + 64)].m_pod.m_inverseInertia[0].m_value = *(double *)&_XMM1;
}

/*
==============
HavokPhysics_SetRigidBodyKeyframed
==============
*/
void HavokPhysics_SetRigidBodyKeyframed(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11957, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody keyframed with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( Physics_IsQueryWorld(worldId) )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11958, ASSERT_TYPE_ASSERT, "(!Physics_IsQueryWorld( worldId ))", "%s\n\tHavok Physics: Trying to Set RigidBody keyframed in query world %i", "!Physics_IsQueryWorld( worldId )", v5) )
      __debugbreak();
  }
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11959, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody keyframed with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11964, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyKeyframed %i: world is NULL", "havokPhysicsWorld->world", v5) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 1i64);
}

/*
==============
HavokPhysics_SetRigidBodyMass
==============
*/
void HavokPhysics_SetRigidBodyMass(Physics_WorldId worldId, hknpBodyId bodyId, float mass)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v6; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12015, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody Mass with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12016, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody Mass with invalid body id for world %i", "bodyId.isValid()", v7) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12020, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyMass %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64, _QWORD))MutableWorld->world->setBodyMass)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, v6, 0i64);
}

/*
==============
HavokPhysics_SetRigidBodyStatic
==============
*/
void HavokPhysics_SetRigidBodyStatic(Physics_WorldId worldId, hknpBodyId bodyId)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v5; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11978, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody static with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11979, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody static with invalid body id for world %i", "bodyId.isValid()", v5) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v5) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11984, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyStatic %i: world is NULL", "havokPhysicsWorld->world", v5) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, _QWORD, _QWORD))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 0i64, 0i64);
}

/*
==============
HavokPhysics_SetRigidBodyToDefault
==============
*/
void HavokPhysics_SetRigidBodyToDefault(Physics_WorldId worldId, hknpBodyId bodyId, const PhysicsAsset *asset, unsigned int assetIndex)
{
  __int128 v4; 
  __int64 v7; 
  HavokPhysicsWorld *MutableWorld; 
  __int64 v10; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  __int64 v12; 
  __int64 v13; 
  float v14; 
  bool v15; 
  hkRefCountedProperties *v16; 
  hkReferencedObject *v17; 
  __int64 v18; 
  __int64 v19; 
  signed int i; 
  hknpShape *v21; 
  const char *MapEntsShapeName; 
  __int64 v23; 
  hkDiagonalizedMassProperties props; 
  __int128 v25; 

  v7 = (int)assetIndex;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12033, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody Default with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12034, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody Default with invalid body id for world %i", "bodyId.isValid()", v23) )
      __debugbreak();
  }
  if ( !asset )
  {
    LODWORD(v23) = bodyId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12035, ASSERT_TYPE_ASSERT, "(asset)", "%s\n\tHavok Physics: Trying to Set RigidBody %i Default with invalid asset for world %i", "asset", v23, worldId) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v23) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12040, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyToDefault %i: world is NULL", "havokPhysicsWorld->world", v23) )
      __debugbreak();
  }
  v10 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(asset);
  if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12047, ASSERT_TYPE_ASSERT, "(havokAsset)", (const char *)&queryFormat, "havokAsset") )
    __debugbreak();
  if ( !HavokPhysicsAsset->m_physicsSystemData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12048, ASSERT_TYPE_ASSERT, "(havokAsset->m_physicsSystemData)", (const char *)&queryFormat, "havokAsset->m_physicsSystemData") )
    __debugbreak();
  if ( (int)v7 >= HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12049, ASSERT_TYPE_ASSERT, "((int)assetIndex < havokAsset->m_physicsSystemData->m_bodyCinfos.getSize())", (const char *)&queryFormat, "(int)assetIndex < havokAsset->m_physicsSystemData->m_bodyCinfos.getSize()") )
    __debugbreak();
  v13 = (__int64)&HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v7];
  if ( (*(_BYTE *)(v13 + 8) & 4) == 0 && (*(_BYTE *)(v10 + 68) & 4) != 0 )
  {
    v14 = *(float *)(v13 + 112);
    v25 = v4;
    v15 = v14 <= 0.0;
    if ( v14 < 0.0 )
    {
      v16 = *(hkRefCountedProperties **)(*(_QWORD *)v13 + 48i64);
      if ( v16 )
      {
        v17 = hkRefCountedProperties::accessProperty(v16, 0xF100u);
        if ( v17 )
          hkCompressedMassProperties::unpack((hkCompressedMassProperties *)&v17[1], &props);
      }
      v15 = props.m_mass <= 0.0;
    }
    if ( !v15 )
      ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64, _QWORD))MutableWorld->world->setBodyMass)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, v12, 0i64);
    ((void (__fastcall *)(hknpWorldWriter *, _QWORD, __int64))MutableWorld->world->setBodyMotionType)(&MutableWorld->world->hknpWorldWriter, bodyId.m_serialAndIndex, 2i64);
    v18 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBody)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
    v19 = *(_QWORD *)(v18 + 96);
    if ( *(_BYTE *)(v19 + 26) == 9 && *(int *)(v19 + 104) > 0 )
    {
      for ( i = 0; i < WorldCollision_GetMapEntsShapeCount(); ++i )
      {
        v21 = *(hknpShape **)(v18 + 96);
        if ( v21 == WorldCollision_GetMapEntsShape(i) )
          break;
      }
      if ( i >= WorldCollision_GetMapEntsShapeCount() )
      {
        Com_PrintWarning(16, "Physics: Setting a rigid body Dynamic using physicsasset %s with a collision-mesh (any terrain/patch or a brush with different contents/surface flags on some sides).  This will be slow and may result in CPU spikes and unwanted penetrations.\n", asset->name);
      }
      else
      {
        MapEntsShapeName = WorldCollision_GetMapEntsShapeName(i);
        Com_PrintWarning(16, "Physics: Setting a rigid body Dynamic using physicsasset %s with a collision-mesh from %s (any terrain/patch or a brush with different contents/surface flags on some sides).  This will be slow and may result in CPU spikes and unwanted penetrations.\n", asset->name, MapEntsShapeName);
      }
    }
  }
}

/*
==============
HavokPhysics_SetRigidBodyUserData
==============
*/
void HavokPhysics_SetRigidBodyUserData(Physics_WorldId worldId, hknpBodyId bodyId, unsigned __int64 userData)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v7; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11849, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Set RigidBody user data with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11850, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Set RigidBody user data with invalid body id for world %i", "bodyId.isValid()", v7) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v7) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 11855, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics SetRigidBodyContents %i: world is NULL", "havokPhysicsWorld->world", v7) )
      __debugbreak();
  }
  MutableWorld->world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod.m_userData = userData;
}

/*
==============
HavokPhysics_SetRigidBodyVelocity
==============
*/
void HavokPhysics_SetRigidBodyVelocity(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkLinVel, const hkVector4f *hkAngVel)
{
  hknpWorld *world; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12800, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12801, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Keyframe Rigid Body with invalid body id for world %i", "bodyId.isValid()", v9) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v9) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12806, ASSERT_TYPE_ASSERT, "(hkWorld)", "%s\n\tHavokPhysics SetRigidBodyVelocity %i: world is NULL", "hkWorld", v9) )
      __debugbreak();
  }
  ((void (__fastcall *)(hknpWorldWriter *, _QWORD, const hkVector4f *, const hkVector4f *, _DWORD))world->setBodyVelocity)(&world->hknpWorldWriter, bodyId.m_serialAndIndex, hkLinVel, hkAngVel, 0);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationGeneral
==============
*/
void HavokPhysics_SetThreadHeapAllocationGeneral(unsigned int threadId)
{
  __int64 v1; 
  hkMemoryRouter *v2; 
  hkMemoryRouter *v3; 

  v1 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2868, ASSERT_TYPE_ASSERT, "(unsigned)( threadId ) < (unsigned)( s_threadIdMax )", "threadId doesn't index s_threadIdMax\n\t%i not in [0, %i)", threadId, 28) )
    __debugbreak();
  v2 = s_threadMemoryRouters[v1];
  v3 = s_memoryRouter;
  if ( v2 )
    v3 = v2;
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2872, ASSERT_TYPE_ASSERT, "(memoryRouter)", (const char *)&queryFormat, "memoryRouter") )
    __debugbreak();
  HavokPhysicsFreeListMemorySystem::SetThreadHeapAllocationGeneral(s_havokPhysicsMemorySystem, v3);
}

/*
==============
HavokPhysics_SetThreadHeapAllocationMapLocal
==============
*/
void HavokPhysics_SetThreadHeapAllocationMapLocal(unsigned int threadId)
{
  __int64 v1; 
  hkMemoryRouter *v2; 
  hkMemoryRouter *v3; 

  v1 = threadId;
  if ( threadId >= 0x1C && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2882, ASSERT_TYPE_ASSERT, "(unsigned)( threadId ) < (unsigned)( s_threadIdMax )", "threadId doesn't index s_threadIdMax\n\t%i not in [0, %i)", threadId, 28) )
    __debugbreak();
  v2 = s_threadMemoryRouters[v1];
  v3 = s_memoryRouter;
  if ( v2 )
    v3 = v2;
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2886, ASSERT_TYPE_ASSERT, "(memoryRouter)", (const char *)&queryFormat, "memoryRouter") )
    __debugbreak();
  HavokPhysicsFreeListMemorySystem::SetThreadHeapAllocationMapLocal(s_havokPhysicsMemorySystem, v3);
}

/*
==============
HavokPhysics_Shapecast
==============
*/
void HavokPhysics_Shapecast(Physics_WorldId worldId, unsigned int numBodies, unsigned int *bodyIds, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  hknpCollisionQueryCollector *collector; 
  HavokPhysicsHitCollector *m_collector; 
  hknpCollisionQueryCollector *startCollector; 
  const HavokPhysicsWorld *ConstWorld; 
  float v21; 
  __int64 v22; 
  __int64 v23; 
  const hknpShape *v24; 
  hkVector4f v31; 
  hkMonitorStream *Value; 
  hkMonitorStream *v44; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  hkVector4f *v47; 
  hknpCollisionQueryContext queryContext; 
  float v49; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v51; 
  __int128 v52; 
  Physics_QueryPhaseSelection phaseSelection; 
  bool permitOutwardTrace; 
  hkQuaternionf *qi; 
  hknpShape *v56; 
  __int16 v57; 
  int contents; 
  float *v59; 
  __int64 v60; 
  hknpShapeCastQuery query; 
  hknpShapeQueryInfo queryShapeInfoIn; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v64[64]; 
  hknpInplaceTriangleShape v65; 

  v60 = -2i64;
  v56 = shape;
  v47 = (hkVector4f *)end;
  qi = (hkQuaternionf *)rotation;
  _XMM1 = 0i64;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v65, 0.0);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v65;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v65;
  queryContext.m_initialCastFractionHint = 0.0;
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfoIn.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfoIn.m_shapeKeyPath.m_size = 0;
  queryShapeInfoIn.m_body = NULL;
  queryShapeInfoIn.m_parentShape = NULL;
  queryShapeInfoIn.m_shapeKeyMask = NULL;
  queryShapeInfoIn.m_scalingInternals.m_isScaled = 0;
  queryShapeInfoIn.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  queryShapeInfoIn.m_scalingInternals.m_mode = 0;
  queryShapeInfoIn.m_scalingInternals.m_offset = 0i64;
  queryShapeInfoIn.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&targetShapeInfo.m_body = _XMM0;
  targetShapeInfo.m_parentShape = NULL;
  __asm { vpxor   xmm1, xmm1, xmm1 }
  *(_OWORD *)&targetShapeInfo.m_shapeToWorld = _XMM1;
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  targetShapeInfo.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  targetShapeInfo.m_scalingInternals.m_offset = 0i64;
  targetShapeInfo.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  v49 = 0.0;
  ignoreBodies = NULL;
  v51 = 1;
  v52 = _XMM0;
  phaseSelection = All;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  query.m_shapeTagCodec = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  query.m_shape = NULL;
  query.m_body = NULL;
  query.m_accuracy = FLOAT_0_001;
  query.m_startTolerance = 0.0;
  query.m_maxCastIterations = 256;
  query.m_extraRadius = 0.0;
  memset(&query.m_deltaAngleLocal, 0, 32);
  query.m_angularAccuracy = FLOAT_3_40282e38;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14953, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14954, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14955, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14956, ASSERT_TYPE_ASSERT, "(extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies without ignore bodies", "extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplifyStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14957, ASSERT_TYPE_ASSERT, "(!extendedData->simplifyStart)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with simplify start - not currently supported", "!extendedData->simplifyStart") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14958, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14959, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire shapecast with bodies with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetShapecastDataForModifiers(result->m_collector, start, v47, rotation, &query);
  collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( startResult && (m_collector = startResult->m_collector) != NULL )
    startCollector = HavokPhysicsHitCollector::GetCollector(m_collector);
  else
    startCollector = NULL;
  if ( !collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14966, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v49 = 0.03125 * extendedData->collisionBuffer;
  v52 = *(_OWORD *)&extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  permitOutwardTrace = extendedData->permitOutwardTrace;
  ignoreBodies = extendedData->ignoreBodies;
  v57 = -1;
  contents = extendedData->contents;
  v59 = &v49;
  queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
  *(__m256i *)v64 = *(__m256i *)g_vectorfConstants[32].m128_f32;
  *(__m256i *)&v64[32] = *(__m256i *)g_vectorfConstants[34].m128_f32;
  hkRotationImpl<float>::set((hkRotationImpl<float> *)v64, qi);
  *(hkVector4f *)&v64[48] = (hkVector4f)start->m_quad;
  queryShapeInfoIn.m_rootShape = v56;
  queryShapeInfoIn.m_shapeToWorld = (const hkTransformf *)v64;
  v21 = 0.03125 * extendedData->startTolerance;
  query.m_shape = v56;
  query.m_accuracy = 0.03125 * extendedData->accuracy;
  query.m_startTolerance = v21;
  query.m_body = NULL;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = ConstWorld->traceCollisionFilter;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v49;
  *(_DWORD *)query.m_levelOfDetail = 0;
  if ( numBodies )
  {
    v22 = numBodies;
    do
    {
      if ( (*bodyIds & 0xFFFFFF) == 0xFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 15012, ASSERT_TYPE_ASSERT, "(Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] ))", (const char *)&queryFormat, "Physics_IsRigidBodyIdValid( bodyIds[bodyIdx] )") )
        __debugbreak();
      v23 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, *bodyIds);
      v24 = *(const hknpShape **)(v23 + 96);
      if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, SHAPE_CAST, (const hknpQueryFilterData *)&v57, (const hknpBody *)v23) )
      {
        targetShapeInfo.m_body = (const hknpBody *)v23;
        targetShapeInfo.m_rootShape = *(const hknpShape **)(v23 + 96);
        targetShapeInfo.m_parentShape = NULL;
        targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
        targetShapeInfo.m_shapeKeyPath.m_size = 0;
        targetShapeInfo.m_shapeToWorld = (const hkTransformf *)v23;
        targetShapeInfo.m_shapeKeyMask = NULL;
        targetShapeFilterDataIn.m_materialId.m_value = *(_WORD *)(v23 + 106);
        targetShapeFilterDataIn.m_collisionFilterInfo = *(_DWORD *)(v23 + 108);
        targetShapeFilterDataIn.m_userData = *(_QWORD *)(v23 + 160);
        s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, (const hknpBody *)v23, v24, &targetShapeFilterDataIn);
        _mm128_sub_ps(start->m_quad, *(__m128 *)(v23 + 48));
        _XMM3 = *(_OWORD *)v23;
        _XMM4 = *(_OWORD *)(v23 + 16);
        _XMM6 = *(_OWORD *)(v23 + 32);
        __asm
        {
          vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
          vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
          vdpps   xmm1, xmm6, xmm1, 74h ; 't'
        }
        v31.m_quad = (__m128)(_XMM1 | _XMM0 | _XMM2);
        _mm128_sub_ps(v47->m_quad, *(__m128 *)(v23 + 48));
        __asm
        {
          vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
          vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
          vdpps   xmm1, xmm6, xmm1, 74h ; 't'
        }
        _XMM2 = _mm128_sub_ps((__m128)(_XMM1 | _XMM0 | _XMM2), v31.m_quad);
        __asm
        {
          vblendps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
          vcmpeqps xmm0, xmm3, xmm8
          vandnps xmm4, xmm0, xmm3
          vcmpeqps xmm0, xmm4, xmm8
          vrcpps  xmm3, xmm4
        }
        _XMM3 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM3, _XMM4.m_quad)), _XMM3);
        __asm { vblendvps xmm2, xmm3, xmm1, xmm0 }
        query.m_ray.m_direction = (hkVector4f)_XMM4.m_quad;
        query.m_ray.m_invDirection = (hkVector4f)_XMM2.m_quad;
        query.m_ray.m_origin = (hkVector4f)v31.m_quad;
        Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( Value )
          hkMonitorStream::timerBegin(Value, "TtShapecast_Body_HK");
        hknpShapeQueryInterface::castShape(&queryContext, &query, &queryShapeInfoIn, v24, &targetShapeFilterDataIn, &targetShapeInfo, collector, startCollector);
        v44 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
        if ( v44 )
          hkMonitorStream::timerEnd(v44, "Et");
      }
      ++bodyIds;
      --v22;
    }
    while ( v22 );
  }
  if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
}

/*
==============
HavokPhysics_Shapecast
==============
*/
void HavokPhysics_Shapecast(Physics_WorldId worldId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  float v15; 
  __m128 m_quad; 
  hknpCollisionQueryCollector *Collector; 
  HavokPhysicsHitCollector *m_collector; 
  hknpCollisionQueryCollector *v27; 
  hkMonitorStream *Value; 
  hkMonitorStream *v29; 
  unsigned int NumHits; 
  __int64 v31; 
  const hknpCollisionResult *Hits; 
  hkMemoryAllocator *v33; 
  int v34; 
  int v35; 
  hknpCollisionResult *v36; 
  __m256i *v37; 
  __int64 v38; 
  signed __int64 v39; 
  hknpBodyId *v40; 
  int Ref; 
  int v42; 
  unsigned int v43; 
  const hknpCollisionResult *Hit; 
  hkMemoryAllocator *v45; 
  __int64 v46; 
  __int64 v47; 
  HavokPhysicsWorld *array; 
  int v49; 
  int v50; 
  hkQuaternionf *qi; 
  float v52; 
  HavokPhysics_IgnoreBodies *ignoreBodies; 
  int v54; 
  __int128 v55; 
  Physics_QueryPhaseSelection phaseSelection; 
  bool permitOutwardTrace; 
  __int64 v58; 
  hknpShapeCastQuery query; 
  hkRotationImpl<float> v60; 

  v58 = -2i64;
  qi = (hkQuaternionf *)rotation;
  v52 = 0.0;
  ignoreBodies = NULL;
  v54 = 1;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v55 = _XMM0;
  phaseSelection = All;
  query.m_broadPhaseFilterMask = -5;
  query.m_maxCastIterations = 256;
  query.m_extraRadius = 0.0;
  _XMM8 = 0i64;
  memset(&query.m_deltaAngleLocal, 0, 32);
  query.m_angularAccuracy = FLOAT_3_40282e38;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14139, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14140, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14141, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid extended data", "extendedData") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14142, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid result", "result") )
    __debugbreak();
  array = (HavokPhysicsWorld *)HavokPhysics_GetConstWorld(worldId);
  v15 = extendedData->startTolerance * 0.03125;
  ignoreBodies = extendedData->ignoreBodies;
  v52 = extendedData->collisionBuffer * 0.03125;
  v55 = *(_OWORD *)&extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  permitOutwardTrace = extendedData->permitOutwardTrace;
  query.m_shape = shape;
  m_quad = start->m_quad;
  _XMM1 = _mm128_sub_ps(end->m_quad, start->m_quad);
  __asm
  {
    vblendps xmm2, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
    vcmpeqps xmm0, xmm8, xmm2
    vandnps xmm4, xmm0, xmm2
    vcmpeqps xmm0, xmm8, xmm4
    vrcpps  xmm3, xmm4
  }
  _XMM3 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM3, _XMM4.m_quad)), _XMM3);
  __asm { vblendvps xmm2, xmm3, xmm1, xmm0 }
  query.m_ray.m_direction = (hkVector4f)_XMM4.m_quad;
  query.m_ray.m_invDirection = (hkVector4f)_XMM2.m_quad;
  query.m_ray.m_origin.m_quad = m_quad;
  query.m_accuracy = extendedData->accuracy * 0.03125;
  query.m_startTolerance = v15;
  query.m_body = NULL;
  query.m_shapeTagCodec = s_shapeTagCodec;
  query.m_filter = array->traceCollisionFilter;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = extendedData->contents;
  query.m_filterData.m_userData = (unsigned __int64)&v52;
  *(_DWORD *)query.m_levelOfDetail = 0;
  hkRotationImpl<float>::set(&v60, qi);
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14174, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetShapecastDataForModifiers(result->m_collector, start, end, qi, &query);
  Collector = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( startResult && (m_collector = startResult->m_collector) != NULL )
    v27 = HavokPhysicsHitCollector::GetCollector(m_collector);
  else
    v27 = NULL;
  if ( !Collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14181, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid havok collector", "collector") )
    __debugbreak();
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtShapetrace_HK");
  array->world->castShape(&array->world->hknpWorldReader, &query, &v60, Collector, v27);
  v29 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v29 )
    hkMonitorStream::timerEnd(v29, "Et");
  if ( startResult )
    NumHits = HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
  else
    NumHits = 0;
  if ( extendedData->simplifyStart && NumHits )
  {
    array = NULL;
    v49 = 0;
    v50 = 0x80000000;
    v31 = (int)HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
    Hits = HavokPhysics_CollisionQueryResult::GetHits(startResult);
    v33 = hkMemHeapAllocator();
    v34 = 0;
    if ( (int)v31 > 0 )
    {
      v35 = v31;
      if ( (int)v31 < 0 )
        v35 = 0;
      hkArrayUtil::_reserve(v33, &array, v35, 112);
      v34 = v49;
    }
    v36 = (hknpCollisionResult *)array;
    v37 = (__m256i *)((char *)array + 112 * v34);
    v38 = v31;
    if ( (int)v31 > 0 )
    {
      v39 = (char *)Hits - (char *)v37;
      do
      {
        if ( v37 )
        {
          *v37 = *(__m256i *)((char *)v37 + v39);
          v37[1] = *(__m256i *)((char *)&v37[1] + v39);
          v37[2] = *(__m256i *)((char *)&v37[2] + v39);
          *(_OWORD *)v37[3].m256i_i8 = *(_OWORD *)&v37[3].m256i_i8[v39];
        }
        v37 = (__m256i *)((char *)v37 + 112);
        --v38;
      }
      while ( v38 );
      v36 = (hknpCollisionResult *)array;
    }
    v49 = v31;
    if ( (int)v31 > 1 )
      hkAlgorithm::quickSortRecursive<hknpCollisionResult,hkBool (*)(hknpCollisionResult &,hknpCollisionResult &)>(v36, 0, v31 - 1, HavokPhysics_QueryHitSort);
    v27->reset(v27);
    v40 = (hknpBodyId *)array;
    if ( array != (HavokPhysicsWorld *)((char *)array + 112 * v49) )
    {
      do
      {
        Ref = HavokPhysics_GetRef(startResult->m_worldId, v40[18]);
        v42 = HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
        v43 = 0;
        if ( v42 <= 0 )
        {
LABEL_51:
          v27->addHit(v27, (const hknpCollisionResult *)v40);
        }
        else
        {
          while ( 1 )
          {
            if ( v43 >= HavokPhysics_CollisionQueryResult::GetNumHits(startResult) )
            {
              LODWORD(v47) = HavokPhysics_CollisionQueryResult::GetNumHits(startResult);
              LODWORD(v46) = v43;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hitId ) < (unsigned)( GetNumHits() )", "hitId doesn't index GetNumHits()\n\t%i not in [0, %i)", v46, v47) )
                __debugbreak();
            }
            Hit = HavokPhysics_CollisionQueryResult::GetHit(startResult, v43);
            if ( HavokPhysics_GetRef(startResult->m_worldId, Hit->m_hitBodyInfo.m_bodyId) == Ref )
              break;
            if ( (int)++v43 >= v42 )
              goto LABEL_51;
          }
        }
        v40 += 28;
      }
      while ( v40 != (hknpBodyId *)((char *)array + 112 * v49) );
    }
    v45 = hkMemHeapAllocator();
    v49 = 0;
    if ( v50 >= 0 )
      hkMemoryAllocator::bufFree2(v45, array, 112, v50 & 0x3FFFFFFF);
  }
}

/*
==============
HavokPhysics_Shapecast
==============
*/
void HavokPhysics_Shapecast(Physics_WorldId worldId, hknpBodyId bodyId, hknpShape *shape, const hkVector4f *start, const hkVector4f *end, const hkQuaternionf *rotation, Physics_ShapecastExtendedData *extendedData, HavokPhysics_CollisionQueryResult *result, HavokPhysics_CollisionQueryResult *startResult)
{
  hknpCollisionQueryCollector *v17; 
  HavokPhysicsHitCollector *m_collector; 
  hknpCollisionQueryCollector *startCollector; 
  const HavokPhysicsWorld *ConstWorld; 
  __int64 v21; 
  const hknpShape *v22; 
  const hknpShape *v23; 
  float v24; 
  hkVector4f v31; 
  hkMonitorStream *Value; 
  hkMonitorStream *v44; 
  hknpCollisionQueryCollector *collector; 
  hknpQueryFilterData targetShapeFilterDataIn; 
  __int16 v47; 
  int contents; 
  float *v49; 
  hknpCollisionQueryContext queryContext; 
  hkQuaternionf *qi; 
  const hkVector4f *v52; 
  hkVector4f *v53; 
  hknpShape *v54; 
  float v55; 
  __int64 v56; 
  int v57; 
  __int128 v58; 
  Physics_QueryPhaseSelection phaseSelection; 
  bool permitOutwardTrace; 
  __int64 v61; 
  hknpShapeCastQuery query; 
  hknpShapeQueryInfo queryShapeInfoIn; 
  hknpShapeQueryInfo targetShapeInfo; 
  char v65[64]; 
  hknpInplaceTriangleShape v66; 

  v61 = -2i64;
  v52 = start;
  v54 = shape;
  v53 = (hkVector4f *)end;
  qi = (hkQuaternionf *)rotation;
  v47 = -1;
  contents = 0;
  v49 = NULL;
  _XMM1 = 0i64;
  hknpInplaceTriangleShape::hknpInplaceTriangleShape(&v66, 0.0);
  queryContext.m_dispatcher = NULL;
  queryContext.m_queryTriangle = (hknpTriangleShape *)&v66;
  queryContext.m_targetTriangle = (hknpTriangleShape *)&v66;
  queryContext.m_initialCastFractionHint = 0.0;
  queryContext.m_externallyAllocatedTriangles = 1;
  queryShapeInfoIn.m_shapeKeyPath.m_key.m_value = -1;
  queryShapeInfoIn.m_shapeKeyPath.m_size = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&queryShapeInfoIn.m_body = _XMM0;
  queryShapeInfoIn.m_parentShape = NULL;
  __asm { vpxor   xmm1, xmm1, xmm1 }
  *(_OWORD *)&queryShapeInfoIn.m_shapeToWorld = _XMM1;
  queryShapeInfoIn.m_scalingInternals.m_isScaled = 0;
  queryShapeInfoIn.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  queryShapeInfoIn.m_scalingInternals.m_mode = 0;
  queryShapeInfoIn.m_scalingInternals.m_offset = 0i64;
  queryShapeInfoIn.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeInfo.m_shapeKeyPath.m_key.m_value = -1;
  targetShapeInfo.m_shapeKeyPath.m_size = 0;
  *(_OWORD *)&targetShapeInfo.m_body = _XMM0;
  targetShapeInfo.m_parentShape = NULL;
  *(_OWORD *)&targetShapeInfo.m_shapeToWorld = _XMM1;
  targetShapeInfo.m_scalingInternals.m_isScaled = 0;
  targetShapeInfo.m_scalingInternals.m_scale = (hkVector4f)_xmm;
  targetShapeInfo.m_scalingInternals.m_mode = 0;
  targetShapeInfo.m_scalingInternals.m_offset = 0i64;
  targetShapeInfo.m_scalingInternals.m_convexRadius = 0.0;
  targetShapeFilterDataIn.m_materialId.m_value = -1;
  targetShapeFilterDataIn.m_collisionFilterInfo = 0;
  targetShapeFilterDataIn.m_userData = 0i64;
  v55 = 0.0;
  v56 = 0i64;
  v57 = 1;
  v58 = _XMM0;
  phaseSelection = All;
  query.m_filterData.m_materialId.m_value = -1;
  query.m_filterData.m_collisionFilterInfo = 0;
  query.m_filterData.m_userData = 0i64;
  query.m_filter = NULL;
  query.m_shapeTagCodec = NULL;
  *(_DWORD *)query.m_levelOfDetail = 2;
  query.m_broadPhaseFilterMask = -5;
  query.m_shape = NULL;
  query.m_body = NULL;
  query.m_accuracy = FLOAT_0_001;
  query.m_startTolerance = 0.0;
  query.m_maxCastIterations = 256;
  query.m_extraRadius = 0.0;
  memset(&query.m_deltaAngleLocal, 0, 32);
  query.m_angularAccuracy = FLOAT_3_40282e38;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14845, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(collector) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14846, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid body id %i", "bodyId.isValid()", collector) )
      __debugbreak();
  }
  if ( !shape && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14847, ASSERT_TYPE_ASSERT, "(shape)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid shape", "shape") )
    __debugbreak();
  if ( !extendedData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14848, ASSERT_TYPE_ASSERT, "(extendedData)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid extended data", "extendedData") )
    __debugbreak();
  if ( extendedData->ignoreBodies && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14849, ASSERT_TYPE_ASSERT, "(!extendedData->ignoreBodies)", "%s\n\tHavok Physics: Trying to fire shapecast with body with ignore bodies", "!extendedData->ignoreBodies") )
    __debugbreak();
  if ( extendedData->simplifyStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14850, ASSERT_TYPE_ASSERT, "(!extendedData->simplifyStart)", "%s\n\tHavok Physics: Trying to fire shapecast with body with simplify start - not currently supported", "!extendedData->simplifyStart") )
    __debugbreak();
  if ( !result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14851, ASSERT_TYPE_ASSERT, "(result)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid result", "result") )
    __debugbreak();
  if ( !result->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14852, ASSERT_TYPE_ASSERT, "(result->m_collector)", "%s\n\tHavok Physics: Trying to fire shapecast with body with invalid collector", "result->m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::SetShapecastDataForModifiers(result->m_collector, start, v53, qi, &query);
  v17 = HavokPhysicsHitCollector::GetCollector(result->m_collector);
  if ( startResult && (m_collector = startResult->m_collector) != NULL )
    startCollector = HavokPhysicsHitCollector::GetCollector(m_collector);
  else
    startCollector = NULL;
  if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 14859, ASSERT_TYPE_ASSERT, "(collector)", "%s\n\tHavok Physics: Trying to fire shapecast with invalid havok collector", "collector") )
    __debugbreak();
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v21 = ((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBody)(&ConstWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  v22 = *(const hknpShape **)(v21 + 96);
  v55 = extendedData->collisionBuffer * 0.03125;
  v58 = *(_OWORD *)&extendedData->nonBrushShape;
  phaseSelection = extendedData->phaseSelection;
  permitOutwardTrace = extendedData->permitOutwardTrace;
  v47 = -1;
  contents = extendedData->contents;
  v49 = &v55;
  if ( ConstWorld->traceCollisionFilter->isCollisionEnabled(ConstWorld->traceCollisionFilter, SHAPE_CAST, (const hknpQueryFilterData *)&v47, (const hknpBody *)v21) )
  {
    queryContext.m_dispatcher = ConstWorld->world->m_collisionQueryDispatcher;
    *(__m256i *)v65 = *(__m256i *)g_vectorfConstants[32].m128_f32;
    *(__m256i *)&v65[32] = *(__m256i *)g_vectorfConstants[34].m128_f32;
    hkRotationImpl<float>::set((hkRotationImpl<float> *)v65, qi);
    *(hkVector4f *)&v65[48] = (hkVector4f)v52->m_quad;
    v23 = v54;
    queryShapeInfoIn.m_rootShape = v54;
    queryShapeInfoIn.m_shapeToWorld = (const hkTransformf *)v65;
    targetShapeInfo.m_body = (const hknpBody *)v21;
    targetShapeInfo.m_rootShape = *(const hknpShape **)(v21 + 96);
    targetShapeInfo.m_shapeToWorld = (const hkTransformf *)v21;
    targetShapeFilterDataIn.m_materialId.m_value = *(_WORD *)(v21 + 106);
    targetShapeFilterDataIn.m_collisionFilterInfo = *(_DWORD *)(v21 + 108);
    targetShapeFilterDataIn.m_userData = *(_QWORD *)(v21 + 160);
    s_shapeTagCodec->overrideInitialFilterData(s_shapeTagCodec, SHAPE_CAST, (const hknpBody *)v21, v22, &targetShapeFilterDataIn);
    v24 = extendedData->startTolerance * 0.03125;
    query.m_shape = v23;
    _mm128_sub_ps(v52->m_quad, *(__m128 *)(v21 + 48));
    _XMM3 = *(_OWORD *)v21;
    _XMM4 = *(_OWORD *)(v21 + 16);
    _XMM6 = *(_OWORD *)(v21 + 32);
    __asm
    {
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
    }
    v31.m_quad = (__m128)(_XMM1 | _XMM0 | _XMM2);
    _mm128_sub_ps(v53->m_quad, *(__m128 *)(v21 + 48));
    __asm
    {
      vdpps   xmm2, xmm3, xmm1, 71h ; 'q'
      vdpps   xmm0, xmm4, xmm1, 72h ; 'r'
      vdpps   xmm1, xmm6, xmm1, 74h ; 't'
    }
    _XMM2 = _mm128_sub_ps((__m128)(_XMM1 | _XMM0 | _XMM2), v31.m_quad);
    __asm
    {
      vblendps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+60h, 8; __m128 const near * const g_vectorfConstants
      vcmpeqps xmm0, xmm3, xmm9
      vandnps xmm4, xmm0, xmm3
      vcmpeqps xmm0, xmm4, xmm9
      vrcpps  xmm3, xmm4
    }
    _XMM3 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM3, _XMM4.m_quad)), _XMM3);
    __asm { vblendvps xmm2, xmm3, xmm1, xmm0 }
    query.m_ray.m_direction = (hkVector4f)_XMM4.m_quad;
    query.m_ray.m_invDirection = (hkVector4f)_XMM2.m_quad;
    query.m_ray.m_origin = (hkVector4f)v31.m_quad;
    query.m_accuracy = extendedData->accuracy * 0.03125;
    query.m_startTolerance = v24;
    query.m_body = NULL;
    query.m_shapeTagCodec = s_shapeTagCodec;
    query.m_filter = ConstWorld->traceCollisionFilter;
    query.m_filterData.m_materialId.m_value = -1;
    query.m_filterData.m_collisionFilterInfo = extendedData->contents;
    query.m_filterData.m_userData = (unsigned __int64)&v55;
    *(_DWORD *)query.m_levelOfDetail = 0;
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( Value )
      hkMonitorStream::timerBegin(Value, "TtShapecast_Body_HK");
    hknpShapeQueryInterface::castShape(&queryContext, &query, &queryShapeInfoIn, v22, &targetShapeFilterDataIn, &targetShapeInfo, v17, startCollector);
    v44 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v44 )
      hkMonitorStream::timerEnd(v44, "Et");
    if ( !queryContext.m_externallyAllocatedTriangles )
    {
      hkReferencedObject::removeReference(queryContext.m_queryTriangle);
      hkReferencedObject::removeReference(queryContext.m_targetTriangle);
    }
  }
  else if ( !queryContext.m_externallyAllocatedTriangles )
  {
    hkReferencedObject::removeReference(queryContext.m_queryTriangle);
    hkReferencedObject::removeReference(queryContext.m_targetTriangle);
  }
}

/*
==============
HavokPhysics_Shutdown
==============
*/
void HavokPhysics_Shutdown(void)
{
  hkArray<XModel const *,hkContainerHeapAllocator> *v0; 
  hkMemoryAllocator *v1; 
  int m_capacityAndFlags; 
  hkMemoryRouter *Value; 
  HavokPhysicsShapeTagCodec *v4; 
  hkMemoryAllocator **v5; 
  __int64 v6; 
  hkMemoryAllocator *v7; 
  int v8; 
  hkPointerMap<unsigned int,hknpShape *,hkContainerHeapAllocator> **v9; 
  hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> *v10; 
  int v11; 
  __int64 v12; 
  __int64 m_hashMod; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  hkReferencedObject *val; 
  unsigned __int16 m_refCount; 
  __int64 v17; 
  __int64 v18; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v19; 
  hkMemoryRouter *v20; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v21; 
  hkMemoryAllocator *v22; 
  int v23; 
  int v24; 
  __int64 v25; 
  __int64 v26; 
  signed int v27; 
  hkMemoryRouter *v28; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v29; 
  hkMemoryAllocator *v30; 
  int v31; 
  int v32; 
  __int64 v33; 
  __int64 v34; 
  signed int v35; 
  hkMemoryRouter *v36; 
  hkArray<hkArray<HavokPhysicsXModelLOD::XModelCollisionTagData,hkContainerHeapAllocator>,hkContainerHeapAllocator> *v37; 
  hkMemoryAllocator *v38; 
  int v39; 
  __int64 v40; 
  int *p_m_capacityAndFlags; 
  hkMemoryAllocator *v42; 
  int v43; 
  hkMemoryRouter *v44; 
  hkPointerMap<unsigned int,unsigned int,hkContainerHeapAllocator> *v45; 
  hkMemoryRouter *v46; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v47; 
  int v48; 
  __int64 v49; 
  __int64 v50; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v51; 
  const char **key; 
  __int64 v53; 
  __int64 v54; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v55; 
  hkMemoryRouter *v56; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v57; 
  hkMemoryRouter *v58; 
  HavokPhysicsThreadPool *v59; 
  HavokPhysicsThreadPool *v60; 
  signed __int32 v61[8]; 
  __int64 v62; 
  __int64 v63; 
  __int64 v64; 
  char v65; 

  v64 = -2i64;
  if ( !s_havokPhysicsXModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2657, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModels)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel array is NULL", "s_havokPhysicsXModels") )
    __debugbreak();
  v0 = s_havokPhysicsXModels;
  if ( s_havokPhysicsXModels )
  {
    v1 = hkMemHeapAllocator();
    v0->m_size = 0;
    m_capacityAndFlags = v0->m_capacityAndFlags;
    if ( m_capacityAndFlags >= 0 )
      hkMemoryAllocator::bufFree2(v1, v0->m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
    v0->m_data = NULL;
    v0->m_capacityAndFlags = 0x80000000;
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    Value->m_heap->blockFree(Value->m_heap, v0, 16);
  }
  s_havokPhysicsXModels = NULL;
  v4 = s_shapeTagCodec;
  if ( s_shapeTagCodec )
    goto LABEL_14;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2663, ASSERT_TYPE_ASSERT, "( s_shapeTagCodec ) != ( nullptr )", "%s != %s\n\t%p, %p", "s_shapeTagCodec", "HK_NULL", NULL, NULL) )
    __debugbreak();
  v4 = s_shapeTagCodec;
  if ( s_shapeTagCodec )
LABEL_14:
    ((void (__fastcall *)(HavokPhysicsShapeTagCodec *, __int64))v4->~hkBaseObject)(v4, 1i64);
  s_shapeTagCodec = NULL;
  v5 = (hkMemoryAllocator **)s_threadMemoryRouters;
  v6 = 28i64;
  do
  {
    v7 = *v5;
    if ( *v5 )
    {
      ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, hkMemoryAllocator *, __int64))s_havokPhysicsMemorySystem->threadQuit)(s_havokPhysicsMemorySystem, v7, 3i64);
      *v5 = NULL;
      hkMemoryAllocator::~hkMemoryAllocator(v7);
    }
    ++v5;
    --v6;
  }
  while ( v6 );
  v8 = 27;
  v9 = &s_havokPhysicsShapeCaches[27];
  do
  {
    if ( !*v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2689, ASSERT_TYPE_ASSERT, "(s_havokPhysicsShapeCaches[threadId])", "%s\n\tHavokPhysics Shutdown: havok physics shape caches should be valid", "s_havokPhysicsShapeCaches[threadId]") )
      __debugbreak();
    v10 = (hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> *)*v9;
    v11 = 0;
    v12 = 0i64;
    m_hashMod = (*v9)->m_map.m_hashMod;
    if ( (int)m_hashMod >= 0 )
    {
      m_elem = v10->m_elem;
      do
      {
        if ( m_elem->key != -1i64 )
          break;
        ++v11;
        ++v12;
        ++m_elem;
      }
      while ( v12 <= m_hashMod );
    }
    if ( v11 <= (int)m_hashMod )
    {
      do
      {
        val = (hkReferencedObject *)v10->m_elem[v11].val;
        if ( !val || (_InterlockedOr(v61, 0), m_refCount = val->m_refCount, _InterlockedOr(v61, 0), m_refCount != 1) )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2695, ASSERT_TYPE_ASSERT, "(shape && shape->getReferenceCount() == 1)", "%s\n\tHavokPhysics Shutdown: havok physics shape cache entries should have a single reference only", "shape && shape->getReferenceCount() == 1") )
            __debugbreak();
        }
        hkReferencedObject::removeReference(val);
        v10 = (hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator> *)*v9;
        ++v11;
        v17 = (*v9)->m_map.m_hashMod;
        if ( v11 > (int)v17 )
          break;
        v18 = v11;
        v19 = &v10->m_elem[v11];
        do
        {
          if ( v19->key != -1i64 )
            break;
          ++v11;
          ++v18;
          ++v19;
        }
        while ( v18 <= v17 );
      }
      while ( v11 <= (int)v17 );
    }
    if ( v10 )
    {
      hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(v10);
      v20 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
      if ( !v20 )
        v20 = hkMemoryRouter::s_fallbackRouter;
      v20->m_heap->blockFree(v20->m_heap, v10, 16);
    }
    *v9-- = NULL;
    --v8;
  }
  while ( v8 >= 0 );
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2704, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", "%s\n\tHavokPhysics Shutdown: havok physics vfx event assets is NULL", "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( (g_physicsVFXEventAssets->m_numElems & 0x7FFFFFFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2705, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics vfx assets should be empty", "g_physicsVFXEventAssets->getSize() == 0") )
    __debugbreak();
  v21 = g_physicsVFXEventAssets;
  if ( g_physicsVFXEventAssets )
  {
    v22 = hkMemHeapAllocator();
    v23 = v21->m_hashMod;
    if ( v23 )
    {
      v24 = v23 + 1;
      v25 = v24;
      if ( v24 > 0 )
      {
        v26 = 0i64;
        do
        {
          if ( v21->m_elem[v26].key != -1 )
            v21->m_elem[v26].key = -1;
          ++v26;
          --v25;
        }
        while ( v25 );
      }
    }
    v27 = v21->m_numElems & 0x80000000;
    v21->m_numElems = v27;
    if ( v21->m_elem && v27 >= 0 )
      v22->blockFree(v22, v21->m_elem, 16 * (v21->m_hashMod + 1));
    v21->m_elem = NULL;
    v21->m_numElems = 0;
    v21->m_hashMod = -1;
    v28 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v28 )
      v28 = hkMemoryRouter::s_fallbackRouter;
    v28->m_heap->blockFree(v28->m_heap, v21, 16);
  }
  g_physicsVFXEventAssets = NULL;
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2709, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", "%s\n\tHavokPhysics Shutdown: havok physics sfx event assets is NULL", "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( (g_physicsSFXEventAssets->m_numElems & 0x7FFFFFFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2710, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics sfx assets should be empty", "g_physicsSFXEventAssets->getSize() == 0") )
    __debugbreak();
  v29 = g_physicsSFXEventAssets;
  if ( g_physicsSFXEventAssets )
  {
    v30 = hkMemHeapAllocator();
    v31 = v29->m_hashMod;
    if ( v31 )
    {
      v32 = v31 + 1;
      v33 = v32;
      if ( v32 > 0 )
      {
        v34 = 0i64;
        do
        {
          if ( v29->m_elem[v34].key != -1 )
            v29->m_elem[v34].key = -1;
          ++v34;
          --v33;
        }
        while ( v33 );
      }
    }
    v35 = v29->m_numElems & 0x80000000;
    v29->m_numElems = v35;
    if ( v29->m_elem && v35 >= 0 )
      v30->blockFree(v30, v29->m_elem, 16 * (v29->m_hashMod + 1));
    v29->m_elem = NULL;
    v29->m_numElems = 0;
    v29->m_hashMod = -1;
    v36 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v36 )
      v36 = hkMemoryRouter::s_fallbackRouter;
    v36->m_heap->blockFree(v36->m_heap, v29, 16);
  }
  g_physicsSFXEventAssets = NULL;
  if ( !g_havokPhysicsXModelLODShapeTagDatas && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2720, ASSERT_TYPE_ASSERT, "(g_havokPhysicsXModelLODShapeTagDatas)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel LODs shapetag datas is NULL", "g_havokPhysicsXModelLODShapeTagDatas") )
    __debugbreak();
  v37 = g_havokPhysicsXModelLODShapeTagDatas;
  if ( g_havokPhysicsXModelLODShapeTagDatas )
  {
    v38 = hkMemHeapAllocator();
    v39 = v37->m_size - 1;
    v40 = v39;
    if ( v39 >= 0 )
    {
      p_m_capacityAndFlags = &v37->m_data[v39].m_capacityAndFlags;
      do
      {
        v42 = hkMemHeapAllocator();
        *(p_m_capacityAndFlags - 1) = 0;
        if ( *p_m_capacityAndFlags >= 0 )
          hkMemoryAllocator::bufFree2(v42, *(void **)(p_m_capacityAndFlags - 3), 8, *p_m_capacityAndFlags & 0x3FFFFFFF);
        *(_QWORD *)(p_m_capacityAndFlags - 3) = 0i64;
        *p_m_capacityAndFlags = 0x80000000;
        p_m_capacityAndFlags -= 4;
        --v40;
      }
      while ( v40 >= 0 );
    }
    v37->m_size = 0;
    v43 = v37->m_capacityAndFlags;
    if ( v43 >= 0 )
      hkMemoryAllocator::bufFree2(v38, v37->m_data, 16, v43 & 0x3FFFFFFF);
    v37->m_data = NULL;
    v37->m_capacityAndFlags = 0x80000000;
    v44 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v44 )
      v44 = hkMemoryRouter::s_fallbackRouter;
    v44->m_heap->blockFree(v44->m_heap, v37, 16);
  }
  g_havokPhysicsXModelLODShapeTagDatas = NULL;
  v45 = s_havokPhysicsXModelLODShapeTagLookup;
  if ( s_havokPhysicsXModelLODShapeTagLookup )
    goto LABEL_98;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2724, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODShapeTagLookup)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel LODs shapetag lookup is NULL", "s_havokPhysicsXModelLODShapeTagLookup") )
    __debugbreak();
  v45 = s_havokPhysicsXModelLODShapeTagLookup;
  if ( s_havokPhysicsXModelLODShapeTagLookup )
  {
LABEL_98:
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(&v45->m_map);
    v46 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v46 )
      v46 = hkMemoryRouter::s_fallbackRouter;
    v46->m_heap->blockFree(v46->m_heap, v45, 16);
  }
  s_havokPhysicsXModelLODShapeTagLookup = NULL;
  v47 = s_havokPhysicsXModelLODs;
  if ( !s_havokPhysicsXModelLODs )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2729, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs)", "%s\n\tHavokPhysics Shutdown: havok physics xmodel LODs is NULL", "s_havokPhysicsXModelLODs") )
      __debugbreak();
    v47 = s_havokPhysicsXModelLODs;
  }
  if ( (v47->m_map.m_numElems & 0x7FFFFFFF) != 0 )
  {
    Com_PrintWarning(16, "%i did not unload their PhysicsLODs - or may not be unloaded themselves\n", v47->m_map.m_numElems & 0x7FFFFFFF);
    v48 = 0;
    v47 = s_havokPhysicsXModelLODs;
    v49 = s_havokPhysicsXModelLODs->m_map.m_hashMod;
    if ( (int)v49 >= 0 )
    {
      v50 = 0i64;
      v51 = s_havokPhysicsXModelLODs->m_map.m_elem;
      do
      {
        if ( v51->key != -1i64 )
          break;
        ++v48;
        ++v50;
        ++v51;
      }
      while ( v50 <= v49 );
    }
    if ( v48 <= (int)v49 )
    {
      do
      {
        key = (const char **)v47->m_map.m_elem[v48].key;
        if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2738, ASSERT_TYPE_ASSERT, "(detailCollision)", (const char *)&queryFormat, "detailCollision") )
          __debugbreak();
        Com_PrintWarning(16, " %s did not unload it's PhysicsLOD - or may not be unloaded itself\n", *key);
        ++v48;
        v47 = s_havokPhysicsXModelLODs;
        v53 = s_havokPhysicsXModelLODs->m_map.m_hashMod;
        if ( v48 > (int)v53 )
          break;
        v54 = v48;
        v55 = &s_havokPhysicsXModelLODs->m_map.m_elem[v48];
        do
        {
          if ( v55->key != -1i64 )
            break;
          ++v48;
          ++v54;
          ++v55;
        }
        while ( v54 <= v53 );
      }
      while ( v48 <= (int)v53 );
    }
  }
  if ( (v47->m_map.m_numElems & 0x7FFFFFFF) != 0 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2745, ASSERT_TYPE_ASSERT, "(s_havokPhysicsXModelLODs->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics LODs should be empty", "s_havokPhysicsXModelLODs->getSize() == 0") )
      __debugbreak();
    v47 = s_havokPhysicsXModelLODs;
  }
  if ( v47 )
  {
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(&v47->m_map);
    v56 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v56 )
      v56 = hkMemoryRouter::s_fallbackRouter;
    v56->m_heap->blockFree(v56->m_heap, v47, 16);
  }
  s_havokPhysicsXModelLODs = NULL;
  if ( !s_havokPhysicsAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2749, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tHavokPhysics Shutdown: havok physics assets is NULL", "s_havokPhysicsAssets") )
    __debugbreak();
  if ( (s_havokPhysicsAssets->m_map.m_numElems & 0x7FFFFFFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2750, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->getSize() == 0)", "%s\n\tHavokPhysics Shutdown: havok physics assets should be empty", "s_havokPhysicsAssets->getSize() == 0") )
    __debugbreak();
  v57 = s_havokPhysicsAssets;
  if ( s_havokPhysicsAssets )
  {
    hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>::~hkMap<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>,hkContainerHeapAllocator>(&s_havokPhysicsAssets->m_map);
    v58 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v58 )
      v58 = hkMemoryRouter::s_fallbackRouter;
    v58->m_heap->blockFree(v58->m_heap, v57, 16);
  }
  s_havokPhysicsAssets = NULL;
  if ( !g_havokPhysicsThreadPool && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2756, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics Shutdown: thread pool is NULL", "g_havokPhysicsThreadPool") )
    __debugbreak();
  v59 = g_havokPhysicsThreadPool;
  _InterlockedOr(v61, 0);
  LOWORD(v59) = v59->m_refCount;
  _InterlockedOr(v61, 0);
  if ( (_WORD)v59 != 1 )
  {
    v60 = g_havokPhysicsThreadPool;
    _InterlockedOr(v61, 0);
    LODWORD(v60) = v60->m_refCount;
    _InterlockedOr(v61, 0);
    LODWORD(v62) = (_DWORD)v60;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2757, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool->getReferenceCount() == 1)", "%s\n\tHavokPhysics Shutdown: threadpool has %i references - should be 1", "g_havokPhysicsThreadPool->getReferenceCount() == 1", v62) )
      __debugbreak();
  }
  hkReferencedObject::removeReference(g_havokPhysicsThreadPool);
  g_havokPhysicsThreadPool = NULL;
  if ( s_havokPhysicsGlobalTypeCompendiumData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2763, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumData ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumData", "nullptr", s_havokPhysicsGlobalTypeCompendiumData, NULL) )
    __debugbreak();
  if ( s_havokPhysicsGlobalTypeCompendiumTypes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2764, ASSERT_TYPE_ASSERT, "( s_havokPhysicsGlobalTypeCompendiumTypes ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsGlobalTypeCompendiumTypes", "nullptr", s_havokPhysicsGlobalTypeCompendiumTypes, NULL) )
    __debugbreak();
  if ( s_havokPhysicsInPlaceLoad && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2765, ASSERT_TYPE_ASSERT, "( s_havokPhysicsInPlaceLoad ) == ( nullptr )", "%s == %s\n\t%p, %p", "s_havokPhysicsInPlaceLoad", "nullptr", s_havokPhysicsInPlaceLoad, NULL) )
    __debugbreak();
  hkBaseSystem::quit();
  if ( !s_havokPhysicsGeneralLargeBlockAllocator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 2773, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralLargeBlockAllocator)", "%s\n\tHavokPhysics Shutdown: general memory allocator is NULL", "s_havokPhysicsGeneralLargeBlockAllocator") )
    __debugbreak();
  ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, char *, __int64))s_havokPhysicsMemorySystem->mainQuit)(s_havokPhysicsMemorySystem, &v65, 3i64);
  ((void (__fastcall *)(HavokPhysicsFreeListMemorySystem *, _QWORD))s_havokPhysicsMemorySystem->~hkMemorySystem)(s_havokPhysicsMemorySystem, 0i64);
  s_havokPhysicsMemorySystem = NULL;
  hkMemorySystem::replaceInstance(NULL);
  if ( s_memoryDebugRouter )
  {
    s_memoryDebugRouter = NULL;
    hkLargeBlockAllocator::freeAll(s_havokPhysicsDebugMemoryAllocator);
    ((void (__fastcall *)(HavokPhysicsLargeBlockAllocator *, _QWORD))s_havokPhysicsDebugMemoryAllocator->~hkMemoryAllocator)(s_havokPhysicsDebugMemoryAllocator, 0i64);
    s_havokPhysicsDebugMemoryAllocator = NULL;
  }
  s_memoryRouter = NULL;
  ((void (__fastcall *)(HavokPhysicsFreeListAllocator *, _QWORD))s_havokPhysicsMapLocalFreeListAllocator->~hkMemoryAllocator)(s_havokPhysicsMapLocalFreeListAllocator, 0i64);
  s_havokPhysicsMapLocalFreeListAllocator = NULL;
  hkLargeBlockAllocator::freeAll(s_havokPhysicsMapLocalLargeBlockAllocator);
  ((void (__fastcall *)(HavokPhysicsLargeBlockAllocator *, _QWORD))s_havokPhysicsMapLocalLargeBlockAllocator->~hkMemoryAllocator)(s_havokPhysicsMapLocalLargeBlockAllocator, 0i64);
  s_havokPhysicsMapLocalLargeBlockAllocator = NULL;
  ((void (__fastcall *)(HavokPhysicsFreeListAllocator *, _QWORD))s_havokPhysicsGeneralFreeListAllocator->~hkMemoryAllocator)(s_havokPhysicsGeneralFreeListAllocator, 0i64);
  s_havokPhysicsGeneralFreeListAllocator = NULL;
  hkLargeBlockAllocator::freeAll(s_havokPhysicsGeneralLargeBlockAllocator);
  ((void (__fastcall *)(HavokPhysicsLargeBlockAllocator *, _QWORD))s_havokPhysicsGeneralLargeBlockAllocator->~hkMemoryAllocator)(s_havokPhysicsGeneralLargeBlockAllocator, 0i64);
  s_havokPhysicsGeneralLargeBlockAllocator = NULL;
  s_havokPhysicsAssetLock.initialized = 0;
  if ( s_havokPhysicsAssetLock.acquireLock )
  {
    LODWORD(v63) = s_havokPhysicsAssetLock.acquireLock;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 138, ASSERT_TYPE_ASSERT, "( lock->acquireLock ) == ( 0 )", "%s == %s\n\t%i, %i", "lock->acquireLock", "0", v63, 0i64) )
      __debugbreak();
  }
  if ( s_havokPhysicsAssetLock.writeThreadId )
  {
    LODWORD(v63) = s_havokPhysicsAssetLock.writeThreadId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 139, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) == ( INVALID_THREAD_ID )", "%s == %s\n\t%i, %i", "lock->writeThreadId", "INVALID_THREAD_ID", v63, 0i64) )
      __debugbreak();
  }
}

/*
==============
HavokPhysics_SmoothTimeStep
==============
*/
void HavokPhysics_SmoothTimeStep(Physics_WorldId worldId, float timeStep)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v4; 
  double v5; 
  const dvar_t *v6; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5658, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to PreStepWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  MutableWorld->timeStepDebugLastRawTimeStep = timeStep;
  v4 = MutableWorld;
  v5 = I_fclamp(timeStep, 0.0016666667, 0.050000001);
  v4->timeStepHistory[v4->timeStepHistoryStart] = *(float *)&v5;
  v4->timeStepHistoryStart = (v4->timeStepHistoryStart + 1) % 20;
  if ( !Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING|0x100) || !Physics_IsAuthoritativeWorld(worldId) )
    goto LABEL_11;
  v6 = DVARBOOL_physics_killswitchEnableClientAuthWorldNoMeanTimeStepCalc;
  if ( !DVARBOOL_physics_killswitchEnableClientAuthWorldNoMeanTimeStepCalc && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_killswitchEnableClientAuthWorldNoMeanTimeStepCalc") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.enabled )
    v4->timeStep = timeStep;
  else
LABEL_11:
    v4->timeStep = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v4->timeStepHistory[1] + v4->timeStepHistory[0]) + v4->timeStepHistory[2]) + v4->timeStepHistory[3]) + v4->timeStepHistory[4]) + v4->timeStepHistory[5]) + v4->timeStepHistory[6]) + v4->timeStepHistory[7]) + v4->timeStepHistory[8]) + v4->timeStepHistory[9]) + v4->timeStepHistory[10]) + v4->timeStepHistory[11]) + v4->timeStepHistory[12]) + v4->timeStepHistory[13]) + v4->timeStepHistory[14]) + v4->timeStepHistory[15]) + v4->timeStepHistory[16]) + v4->timeStepHistory[17]) + v4->timeStepHistory[18]) + v4->timeStepHistory[19]) * 0.050000001;
}

/*
==============
HavokPhysics_StartDrawDebugWorld
==============
*/
void HavokPhysics_StartDrawDebugWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hknpProcessContext *visContext; 
  hkProcessContext *v6; 
  hkMemoryAllocator *v7; 
  int m_size; 
  hclClothContext *clothVisContext; 
  hkProcessContext *v10; 
  hkMemoryAllocator *v11; 
  int v12; 
  hkMemoryAllocator *v13; 
  int v14; 
  hkMemoryAllocator *v15; 
  int v16; 
  hkMemoryAllocator *v17; 
  int v18; 
  hkMemoryAllocator *v19; 
  int v20; 
  hkMemoryAllocator *v21; 
  int v22; 
  hkMemoryAllocator *v23; 
  int v24; 
  hkMemoryAllocator *v25; 
  int v26; 
  hkMemoryAllocator *v27; 
  int v28; 
  hkMemoryAllocator *v29; 
  int v30; 
  hkMemoryAllocator *v31; 
  int v32; 
  hkMemoryAllocator *v33; 
  int v34; 
  hkMemoryAllocator *v35; 
  int v36; 
  hkMemoryAllocator *v37; 
  int v38; 
  hkMemoryAllocator *v39; 
  int v40; 
  hkMemoryAllocator *v41; 
  int v42; 
  hkMemoryAllocator *v43; 
  int v44; 
  hkMemoryAllocator *v45; 
  int v46; 
  hkMemoryAllocator *v47; 
  int v48; 
  hkMemoryAllocator *v49; 
  int v50; 
  hkMemoryAllocator *v51; 
  int v52; 
  hkMemoryAllocator *v53; 
  int v54; 
  hkMemoryAllocator *v55; 
  int v56; 
  hkMemoryAllocator *v57; 
  int v58; 
  hkMemoryAllocator *v59; 
  int v60; 
  hkMemoryAllocator *v61; 
  int v62; 
  hkMemoryAllocator *v63; 
  int v64; 
  hkMemoryAllocator *v65; 
  int v66; 
  hkMemoryAllocator *v67; 
  int v68; 
  hkMemoryAllocator *v69; 
  int v70; 
  hkMemoryAllocator *v71; 
  int v72; 
  hkMemoryAllocator *v73; 
  int v74; 
  hkMemoryAllocator *v75; 
  int v76; 
  hkMemoryAllocator *v77; 
  int v78; 
  hkMemoryAllocator *v79; 
  int v80; 
  hkMemoryAllocator *v81; 
  int v82; 
  hkMemoryAllocator *v83; 
  int v84; 
  hkMemoryAllocator *v85; 
  int v86; 
  hkMemoryAllocator *v87; 
  int v88; 
  int v89; 
  __int64 v90; 
  hkProcess *v91; 
  HavokPhysicsDisplayHandler *displayHandler; 
  hkReferencedObject *m_ptr; 
  hkServerObjectHandler *serverObjectHandler; 
  hkReferencedObject *v95; 
  hkMemoryAllocator *v96; 
  int v97; 
  hkMemoryAllocator *v98; 
  hkMemoryAllocator *v99; 
  void *p; 
  int v101; 
  int v102; 
  hkArray<hkProcessContext *,hkContainerHeapAllocator> array; 
  hkReflect::Var v104; 

  array.m_data = NULL;
  array.m_size = 0;
  array.m_capacityAndFlags = 0x80000000;
  p = NULL;
  v101 = 0;
  v102 = 0x80000000;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17247, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StartDrawDebugWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  visContext = MutableWorld->visContext;
  v6 = &visContext->hkProcessContext;
  if ( !visContext )
    v6 = NULL;
  v7 = hkMemHeapAllocator();
  m_size = array.m_size;
  if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v7, &array, 8);
    m_size = array.m_size;
  }
  array.m_data[m_size] = v6;
  ++array.m_size;
  clothVisContext = MutableWorld->clothVisContext;
  if ( clothVisContext )
  {
    v10 = &clothVisContext->hkProcessContext;
    v11 = hkMemHeapAllocator();
    v12 = array.m_size;
    if ( array.m_size == (array.m_capacityAndFlags & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v11, &array, 8);
      v12 = array.m_size;
    }
    array.m_data[v12] = v10;
    ++array.m_size;
  }
  hkDebugDisplayProcess::registerProcess();
  v13 = hkMemHeapAllocator();
  v14 = v101;
  if ( v101 == (v102 & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v13, &p, 8);
    v14 = v101;
  }
  *((_QWORD *)p + v14) = "Debug Display";
  ++v101;
  if ( physics_debugVisualizeWorldBodyId->current.enabled )
  {
    v15 = hkMemHeapAllocator();
    v16 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v15, &p, 8);
      v16 = v101;
    }
    *((_QWORD *)p + v16) = "Physics/Rigid Bodies/Body IDs";
    ++v101;
  }
  if ( physics_debugVisualizeWorldBroadphase->current.enabled )
  {
    v17 = hkMemHeapAllocator();
    v18 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v17, &p, 8);
      v18 = v101;
    }
    *((_QWORD *)p + v18) = "Physics/Broad Phase";
    ++v101;
  }
  if ( physics_debugVisualizeWorldConstraint->current.enabled )
  {
    v19 = hkMemHeapAllocator();
    v20 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v19, &p, 8);
      v20 = v101;
    }
    *((_QWORD *)p + v20) = "Physics/Constraints";
    ++v101;
  }
  if ( physics_debugVisualizeWorldDeactivation->current.enabled )
  {
    v21 = hkMemHeapAllocator();
    v22 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v21, &p, 8);
      v22 = v101;
    }
    *((_QWORD *)p + v22) = "Physics/Rigid Bodies/Deactivation";
    ++v101;
  }
  if ( physics_debugVisualizeWorldManifold->current.enabled )
  {
    v23 = hkMemHeapAllocator();
    v24 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v23, &p, 8);
      v24 = v101;
    }
    *((_QWORD *)p + v24) = "Physics/Rigid Bodies/Manifolds";
    ++v101;
  }
  if ( physics_debugVisualizeWorldMassProperties->current.enabled )
  {
    v25 = hkMemHeapAllocator();
    v26 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v25, &p, 8);
      v26 = v101;
    }
    *((_QWORD *)p + v26) = "Physics/Rigid Bodies/Mass Properties";
    ++v101;
  }
  if ( physics_debugVisualizeWorldMotionId->current.enabled )
  {
    v27 = hkMemHeapAllocator();
    v28 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v27, &p, 8);
      v28 = v101;
    }
    *((_QWORD *)p + v28) = "Physics/Rigid Bodies/Motion IDs";
    ++v101;
  }
  if ( physics_debugVisualizeWorldShape->current.enabled )
  {
    v29 = hkMemHeapAllocator();
    v30 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v29, &p, 8);
      v30 = v101;
    }
    *((_QWORD *)p + v30) = "Physics/Rigid Bodies/Shapes";
    ++v101;
  }
  if ( physics_debugVisualizeWorldVehicles->current.enabled )
  {
    v31 = hkMemHeapAllocator();
    v32 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v31, &p, 8);
      v32 = v101;
    }
    *((_QWORD *)p + v32) = "Physics/Vehicles";
    ++v101;
  }
  if ( physics_debugVisualizeWorldCollisionHeatmap->current.enabled )
  {
    v33 = hkMemHeapAllocator();
    v34 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v33, &p, 8);
      v34 = v101;
    }
    *((_QWORD *)p + v34) = "IW World-Collision Heatmap";
    ++v101;
  }
  if ( physics_debugVisualizeWorldDebugDraw->current.enabled )
  {
    v35 = hkMemHeapAllocator();
    v36 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v35, &p, 8);
      v36 = v101;
    }
    *((_QWORD *)p + v36) = "IW World-Debug Draw";
    ++v101;
  }
  if ( physics_debugVisualizeWorldCollisionTile->current.enabled )
  {
    v37 = hkMemHeapAllocator();
    v38 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v37, &p, 8);
      v38 = v101;
    }
    *((_QWORD *)p + v38) = "IW Collision Tile Draw";
    ++v101;
  }
  if ( physics_debugVisualizeWorldRaycasts->current.enabled )
  {
    v39 = hkMemHeapAllocator();
    v40 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v39, &p, 8);
      v40 = v101;
    }
    *((_QWORD *)p + v40) = "Physics/Queries/Ray Casts";
    ++v101;
  }
  if ( physics_debugVisualizeWorldShapecasts->current.enabled )
  {
    v41 = hkMemHeapAllocator();
    v42 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v41, &p, 8);
      v42 = v101;
    }
    *((_QWORD *)p + v42) = "Physics/Queries/Shape Casts";
    ++v101;
  }
  if ( physics_debugVisualizeWorldAABBQuery->current.enabled )
  {
    v43 = hkMemHeapAllocator();
    v44 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v43, &p, 8);
      v44 = v101;
    }
    *((_QWORD *)p + v44) = "Physics/Queries/Aabb Queries";
    ++v101;
  }
  if ( physics_debugVisualizeWorldPointQuery->current.enabled )
  {
    v45 = hkMemHeapAllocator();
    v46 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v45, &p, 8);
      v46 = v101;
    }
    *((_QWORD *)p + v46) = "Physics/Queries/Point Queries";
    ++v101;
  }
  if ( physics_debugVisualizeWorldClosestPointsQuery->current.enabled )
  {
    v47 = hkMemHeapAllocator();
    v48 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v47, &p, 8);
      v48 = v101;
    }
    *((_QWORD *)p + v48) = "Physics/Queries/Closest Points Queries";
    ++v101;
  }
  if ( physics_debugVisualizeWorldIWShape->current.enabled )
  {
    v49 = hkMemHeapAllocator();
    v50 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v49, &p, 8);
      v50 = v101;
    }
    *((_QWORD *)p + v50) = "IW Shape Viewer";
    ++v101;
  }
  if ( physics_debugVisualizeWorldParticles->current.enabled )
  {
    v51 = hkMemHeapAllocator();
    v52 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v51, &p, 8);
      v52 = v101;
    }
    *((_QWORD *)p + v52) = "Physics/Particles/Shapes";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldGeometry->current.enabled )
  {
    v53 = hkMemHeapAllocator();
    v54 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v53, &p, 8);
      v54 = v101;
    }
    *((_QWORD *)p + v54) = "Cloth/Simulation/Geometry";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimParticlePosition->current.enabled )
  {
    v55 = hkMemHeapAllocator();
    v56 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v55, &p, 8);
      v56 = v101;
    }
    *((_QWORD *)p + v56) = "Cloth/Simulation/Particle/Position";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimNormals->current.enabled )
  {
    v57 = hkMemHeapAllocator();
    v58 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v57, &p, 8);
      v58 = v101;
    }
    *((_QWORD *)p + v58) = "Cloth/Simulation/Particle/Normal";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldParticleVelocity->current.enabled )
  {
    v59 = hkMemHeapAllocator();
    v60 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v59, &p, 8);
      v60 = v101;
    }
    *((_QWORD *)p + v60) = "Cloth/Simulation/Particle/Velocity";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldParticleId->current.enabled )
  {
    v61 = hkMemHeapAllocator();
    v62 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v61, &p, 8);
      v62 = v101;
    }
    *((_QWORD *)p + v62) = "Cloth/Simulation/Particle/Id";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimStandardLinks->current.enabled )
  {
    v63 = hkMemHeapAllocator();
    v64 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v63, &p, 8);
      v64 = v101;
    }
    *((_QWORD *)p + v64) = "Cloth/Simulation/Constraint/Standard Links";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimStretchLinks->current.enabled )
  {
    v65 = hkMemHeapAllocator();
    v66 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v65, &p, 8);
      v66 = v101;
    }
    *((_QWORD *)p + v66) = "Cloth/Simulation/Constraint/Stretch Links";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimBendLinks->current.enabled )
  {
    v67 = hkMemHeapAllocator();
    v68 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v67, &p, 8);
      v68 = v101;
    }
    *((_QWORD *)p + v68) = "Cloth/Simulation/Constraint/Stretch Links";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimBendStiffness->current.enabled )
  {
    v69 = hkMemHeapAllocator();
    v70 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v69, &p, 8);
      v70 = v101;
    }
    *((_QWORD *)p + v70) = "Cloth/Simulation/Constraint/Bend Stiffness";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldSimVolumeTransforms->current.enabled )
  {
    v71 = hkMemHeapAllocator();
    v72 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v71, &p, 8);
      v72 = v101;
    }
    *((_QWORD *)p + v72) = "Cloth/Simulation/Constraint/Volume";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldLocalRange->current.enabled )
  {
    v73 = hkMemHeapAllocator();
    v74 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v73, &p, 8);
      v74 = v101;
    }
    *((_QWORD *)p + v74) = "Cloth/Simulation/Constraint/Local Range";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldBonePlane->current.enabled )
  {
    v75 = hkMemHeapAllocator();
    v76 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v75, &p, 8);
      v76 = v101;
    }
    *((_QWORD *)p + v76) = "Cloth/Simulation/Constraint/Bone Plane";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldTransition->current.enabled )
  {
    v77 = hkMemHeapAllocator();
    v78 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v77, &p, 8);
      v78 = v101;
    }
    *((_QWORD *)p + v78) = "Cloth/Simulation/Constraint/Transition";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldCollidable->current.enabled )
  {
    v79 = hkMemHeapAllocator();
    v80 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v79, &p, 8);
      v80 = v101;
    }
    *((_QWORD *)p + v80) = "Cloth/Collidables/Collidables";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldParticleRadius->current.enabled )
  {
    v81 = hkMemHeapAllocator();
    v82 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v81, &p, 8);
      v82 = v101;
    }
    *((_QWORD *)p + v82) = "Cloth/Simulation/Particle/Radius";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldVirtualCollisionPoints->current.enabled )
  {
    v83 = hkMemHeapAllocator();
    v84 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v83, &p, 8);
      v84 = v101;
    }
    *((_QWORD *)p + v84) = "Cloth/Simulation/Particle/VCP";
    ++v101;
  }
  if ( cloth_debugVisualizeWorldVirtualCollisionPointsLandscape->current.enabled )
  {
    v85 = hkMemHeapAllocator();
    v86 = v101;
    if ( v101 == (v102 & 0x3FFFFFFF) )
    {
      hkArrayUtil::_reserveMore(v85, &p, 8);
      v86 = v101;
    }
    *((_QWORD *)p + v86) = "Cloth/Simulation/Landscape/VCP";
    ++v101;
  }
  v87 = hkMemHeapAllocator();
  v88 = v101;
  if ( v101 == (v102 & 0x3FFFFFFF) )
  {
    hkArrayUtil::_reserveMore(v87, &p, 8);
    v88 = v101;
  }
  *((_QWORD *)p + v88) = "Cloth/Simulation/Shared Geometry";
  ++v101;
  HavokPhysicsDisplayHandler::setShapeViewer(MutableWorld->displayHandler, NULL);
  v89 = 0;
  if ( v101 > 0 )
  {
    v90 = 0i64;
    do
    {
      __asm { vpxor   xmm0, xmm0, xmm0 }
      *(_OWORD *)&v104.m_addr = _XMM0;
      v104.m_impl.m_ptrAndInt = NULL;
      v91 = hkProcessFactory::createProcess(hkProcessFactory::singleton.m_ptr, *(const char **)((char *)p + v90), &array, &v104);
      if ( !v91 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17347, ASSERT_TYPE_ASSERT, "(process)", "%s\n\tHavokPhysics: StartDrawDebugWorld couldn't create a process", "process") )
        __debugbreak();
      if ( !strcmp_0(*(const char **)((char *)p + v90), "IW Shape Viewer") )
        HavokPhysicsDisplayHandler::setShapeViewer(MutableWorld->displayHandler, v91);
      displayHandler = MutableWorld->displayHandler;
      if ( displayHandler )
        hkReferencedObject::addReference(MutableWorld->displayHandler);
      m_ptr = v91->m_displayHandler.m_ptr;
      if ( m_ptr )
        hkReferencedObject::removeReference(m_ptr);
      v91->m_displayHandler.m_ptr = displayHandler;
      serverObjectHandler = MutableWorld->serverObjectHandler;
      if ( serverObjectHandler )
        hkReferencedObject::addReference(MutableWorld->serverObjectHandler);
      v95 = v91->m_objectHandler.m_ptr;
      if ( v95 )
        hkReferencedObject::removeReference(v95);
      v91->m_objectHandler.m_ptr = serverObjectHandler;
      v91->m_processHandler = MutableWorld->processHandler;
      v91->init(v91);
      v96 = hkMemHeapAllocator();
      v97 = MutableWorld->visProcesses.m_size;
      if ( v97 == (MutableWorld->visProcesses.m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v96, &MutableWorld->visProcesses, 8);
        v97 = MutableWorld->visProcesses.m_size;
      }
      MutableWorld->visProcesses.m_data[v97] = v91;
      ++MutableWorld->visProcesses.m_size;
      ++v89;
      v90 += 8i64;
    }
    while ( v89 < v101 );
    p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
  }
  LeaveCriticalSection(p_critSection);
  v98 = hkMemHeapAllocator();
  v101 = 0;
  if ( v102 >= 0 )
    hkMemoryAllocator::bufFree2(v98, p, 8, v102 & 0x3FFFFFFF);
  p = NULL;
  v102 = 0x80000000;
  v99 = hkMemHeapAllocator();
  array.m_size = 0;
  if ( array.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v99, array.m_data, 8, array.m_capacityAndFlags & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_StepVDB
==============
*/
void HavokPhysics_StepVDB(Physics_WorldId worldId, float time, bool updateStats)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v6; 
  hkMonitorStream *Value; 
  LocalClientNum_t LocalClientForWorld; 
  const char *v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v14; 
  int m_capacityAndFlags; 
  __int64 v16; 
  char v18[16]; 
  __int128 v19[3]; 
  float v20; 
  float v21; 
  float v22; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6365, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to lock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v6 = MutableWorld;
  if ( updateStats )
  {
    hkCommonProcessContext::syncTimers(MutableWorld->comContext, NULL);
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    hkMonitorStream::reset(Value);
  }
  if ( !v6->vdbServer )
  {
    LODWORD(v16) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6377, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics StepWorldEnd %i: vdb server is NULL", "havokPhysicsWorld->vdbServer", v16) )
      __debugbreak();
  }
  LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
  if ( LocalClientForWorld == LOCAL_CLIENT_INVALID )
    LocalClientForWorld = LOCAL_CLIENT_0;
  if ( s_havokPhysics_VdbCameraSet[LocalClientForWorld] && v6->vdbServer->m_clients.m_size >= 1 )
  {
    v9 = s_havokPhysics_VdbCameraNames[LocalClientForWorld];
    v10 = LocalClientForWorld;
    v20 = FLOAT_0_1;
    v22 = FLOAT_45_0;
    v19[0] = (__int128)s_havokPhysics_VdbCameraOrigin[v10];
    v19[1] = (__int128)s_havokPhysics_VdbCameraLookat[v10];
    v19[2] = (__int128)s_havokPhysics_VdbCameraUp[v10];
    v21 = FLOAT_10000_0;
    ((void (__fastcall *)(hkDebugDisplay *, char *, const char *, __int128 *))hkDebugDisplay::singleton.m_ptr->updateCamera)(hkDebugDisplay::singleton.m_ptr, v18, v9, v19);
  }
  hkCommonProcessContext::syncTimers(v6->comContext, NULL);
  LOBYTE(v11) = 5;
  ((void (__fastcall *)(hkVisualDebugger *, __int64, __int64))v6->vdbServer->step)(v6->vdbServer, v12, v11);
  debugLines = v6->debugLines;
  v14 = hkMemHeapAllocator();
  m_capacityAndFlags = debugLines->m_capacityAndFlags;
  debugLines->m_size = 0;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v14, debugLines->m_data, 48, m_capacityAndFlags & 0x3FFFFFFF);
  debugLines->m_capacityAndFlags = 0x80000000;
  debugLines->m_data = NULL;
}

/*
==============
HavokPhysics_StepWorldCollide
==============
*/
void HavokPhysics_StepWorldCollide(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v6; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream *Value; 
  hkMemoryAllocator *v9; 
  int m_size; 
  hkMonitorStream *v11; 
  hkTaskQueue *taskQueue; 
  hkTaskQueue *v13; 
  int v14; 
  hkMonitorStream *v15; 
  hkMonitorStream *v16; 
  int v17; 
  struct hkTaskQueue::_Handle *v18; 
  hkMonitorStream *v19; 
  hkMemoryAllocator *v20; 
  __int64 v21; 
  float v22; 
  float v23; 
  void *p; 
  int v25; 
  int v26; 
  __int64 v27; 
  hknpTaskGraph taskGraph; 

  v27 = -2i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5872, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldCollide with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v6 = MutableWorld;
  if ( MutableWorld->stepInput.m_deltaTime > 0.0 )
  {
    if ( MutableWorld->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      monitorStreams = v6->monitorStreams;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      v9 = hkMemHeapAllocator();
      m_size = monitorStreams->m_size;
      if ( m_size == (monitorStreams->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v9, monitorStreams, 8);
        m_size = monitorStreams->m_size;
      }
      monitorStreams->m_data[m_size] = Value;
      ++monitorStreams->m_size;
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
    v11 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v11 )
      hkMonitorStream::timerBegin(v11, "TtPhysics stepCollide");
    taskQueue = (hkTaskQueue *)v6->taskQueue;
    v13 = taskQueue + 3;
    if ( !taskQueue )
      v13 = NULL;
    if ( !g_havokPhysicsThreadPool )
    {
      LODWORD(v21) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5897, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics StepWorldCollide %i: threadpool is NULL", "g_havokPhysicsThreadPool", v21) )
        __debugbreak();
    }
    if ( v6->isMultithreaded && !v13 )
    {
      LODWORD(v21) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5898, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || taskQueue)", "%s\n\tHavokPhysics StepWorldCollide %i: taskQueue is NULL", "!havokPhysicsWorld->isMultithreaded || taskQueue", v21) )
        __debugbreak();
    }
    if ( !v6->world )
    {
      LODWORD(v21) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5899, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics StepWorldCollide %i: world is NULL", "havokPhysicsWorld->world", v21) )
        __debugbreak();
    }
    v14 = 623;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_SERVER_DETAIL )
      v14 = 626;
    Profile_Begin(v14);
    v15 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v16 = v15;
    if ( v15 )
      hkMonitorStream::timerBegin(v15, "TtPhysics");
    hknpTaskGraph::hknpTaskGraph(&taskGraph);
    Sys_ProfBeginNamedEvent(0xFFFF6347, "GenerateCollideTasks");
    hknpWorld::generateCollideTasks(v6->world, &v6->stepInput, &taskGraph);
    Sys_ProfEndNamedEvent();
    if ( v6->isMultithreaded )
    {
      Profile_Begin(611);
      if ( !Physics_RenderDebugEnabled() )
        HavokPhysicsThreadPool::setUsage(g_havokPhysicsThreadPool, HAVOKPHYSICS_THREADPOOL_USAGE_AUTHCOLLIDE);
      v17 = g_havokPhysicsThreadPool->getNumThreads(g_havokPhysicsThreadPool);
      HavokPhysicsThreadPool::startWorkerCommands(g_havokPhysicsThreadPool, worldId, v17);
      Profile_EndInternal(NULL);
    }
    if ( taskGraph.m_nodes.m_size || taskGraph.m_dependencies.m_size )
    {
      if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5939, ASSERT_TYPE_ASSERT, "(taskQueue != nullptr)", "%s\n\tNo task queue provided", "taskQueue != HK_NULL") )
        __debugbreak();
      v18 = hkTaskGraph::submitToTaskQueue(&taskGraph, v13, FIFO);
      if ( v16 )
        hkMonitorStream::timerEnd(v16, "Et");
      v23 = 0.0;
      v22 = 0.0;
      v6->taskQueue->processUntilFinished(&v6->taskQueue->hkTaskQueue, &v23, &v22, v18);
      if ( v16 )
        hkMonitorStream::timerBegin(v16, "TtPhysics");
      hkTaskGraph::freeTaskQueueHandles(&taskGraph, v13);
    }
    if ( v16 )
      hkMonitorStream::timerEnd(v16, "EtPhysics");
    hkTaskGraph::~hkTaskGraph(&taskGraph);
    Profile_EndInternal(NULL);
    if ( v6->isMultithreaded )
    {
      Profile_Begin(769);
      hkDefaultTaskQueue::close(v6->taskQueue);
      HavokPhysicsThreadPool::waitForCompletion(g_havokPhysicsThreadPool, v6->taskQueue);
      Profile_EndInternal(NULL);
      Profile_Begin(768);
      hkDefaultTaskQueue::reset(v6->taskQueue);
      Profile_EndInternal(NULL);
    }
    v19 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v19 )
      hkMonitorStream::timerEnd(v19, "Et");
    if ( v6->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      if ( !v6->visContext )
      {
        LODWORD(v21) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5978, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics StepWorldEnd %i: visualization constext is NULL", "havokPhysicsWorld->visContext", v21) )
          __debugbreak();
      }
      if ( v6->isMultithreaded )
      {
        p = NULL;
        v25 = 0;
        v26 = 0x80000000;
        g_havokPhysicsThreadPool->appendTimerData(g_havokPhysicsThreadPool, (hkArray<hkTimerData,hkContainerHeapAllocator> *)&p);
        v20 = hkMemHeapAllocator();
        v25 = 0;
        if ( v26 >= 0 )
          hkMemoryAllocator::bufFree2(v20, p, 16, v26 & 0x3FFFFFFF);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
  }
}

/*
==============
HavokPhysics_StepWorldDetail
==============
*/
void HavokPhysics_StepWorldDetail(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ;
}

/*
==============
HavokPhysics_StepWorldEnd
==============
*/
void HavokPhysics_StepWorldEnd(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned __int64 TickCounter; 
  unsigned __int64 v8; 
  unsigned __int64 v9; 
  LocalClientNum_t LocalClientForWorld; 
  const char *v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  hkVisualDebugger *vdbServer; 
  int v16; 
  hkArray<HavokPhysicsDebugLine,hkContainerHeapAllocator> *debugLines; 
  hkMemoryAllocator *v18; 
  int m_capacityAndFlags; 
  hkMonitorStream *Value; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream **i; 
  __int64 v23; 
  const dvar_t *v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 m_ticks_total; 
  __int128 v30; 
  __int128 v32; 
  __int64 stepCPUIndex; 
  __int64 v39; 
  char v41[16]; 
  __int128 v42[3]; 
  float v43; 
  float v44; 
  float v45; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6220, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldEnd with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
  TickCounter = hkStopwatch::getTickCounter();
  MutableWorld->stepStopWatch.m_running_flag.m_bool = 0;
  ++MutableWorld->stepStopWatch.m_num_timings;
  v8 = TickCounter;
  v9 = TickCounter - MutableWorld->stepStopWatch.m_ticks_at_split;
  MutableWorld->stepStopWatch.m_ticks_total += v8 - MutableWorld->stepStopWatch.m_ticks_at_start;
  MutableWorld->stepStopWatch.m_split_total += v9;
  if ( !MutableWorld->vdbServer )
  {
    LODWORD(v39) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6234, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics StepWorldEnd %i: vdb server is NULL", "havokPhysicsWorld->vdbServer", v39) )
      __debugbreak();
  }
  LocalClientForWorld = Physics_GetLocalClientForWorld(worldId);
  if ( LocalClientForWorld == LOCAL_CLIENT_INVALID )
    LocalClientForWorld = LOCAL_CLIENT_0;
  if ( s_havokPhysics_VdbCameraSet[LocalClientForWorld] && MutableWorld->vdbServer->m_clients.m_size >= 1 )
  {
    v11 = s_havokPhysics_VdbCameraNames[LocalClientForWorld];
    v12 = LocalClientForWorld;
    v43 = FLOAT_0_1;
    v45 = FLOAT_45_0;
    v42[0] = (__int128)s_havokPhysics_VdbCameraOrigin[v12];
    v42[1] = (__int128)s_havokPhysics_VdbCameraLookat[v12];
    v42[2] = (__int128)s_havokPhysics_VdbCameraUp[v12];
    v44 = FLOAT_10000_0;
    ((void (__fastcall *)(hkDebugDisplay *, char *, const char *, __int128 *))hkDebugDisplay::singleton.m_ptr->updateCamera)(hkDebugDisplay::singleton.m_ptr, v41, v11, v42);
  }
  hkCommonProcessContext::syncTimers(MutableWorld->comContext, NULL);
  if ( !MutableWorld->vdbServer )
  {
    LODWORD(v39) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6248, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->vdbServer)", "%s\n\tHavokPhysics StepWorldEnd %i: vdb server is NULL", "havokPhysicsWorld->vdbServer", v39) )
      __debugbreak();
  }
  vdbServer = MutableWorld->vdbServer;
  LOBYTE(v14) = 5;
  v41[8] = 5;
  ((void (__fastcall *)(hkVisualDebugger *, __int64, __int64))vdbServer->step)(vdbServer, v13, v14);
  v16 = numStepsPlanned - 1;
  if ( stepIndex == v16 )
  {
    debugLines = MutableWorld->debugLines;
    v18 = hkMemHeapAllocator();
    m_capacityAndFlags = debugLines->m_capacityAndFlags;
    debugLines->m_size = 0;
    if ( m_capacityAndFlags >= 0 )
      hkMemoryAllocator::bufFree2(v18, debugLines->m_data, 48, m_capacityAndFlags & 0x3FFFFFFF);
    debugLines->m_data = NULL;
    debugLines->m_capacityAndFlags = 0x80000000;
  }
  if ( MutableWorld->isMultithreaded || stepIndex == v16 )
  {
    Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    hkMonitorStream::reset(Value);
    monitorStreams = MutableWorld->monitorStreams;
    if ( MutableWorld->isMultithreaded )
    {
      for ( i = monitorStreams->m_data; i != &monitorStreams->m_data[monitorStreams->m_size]; ++i )
      {
        hkMonitorStream::reset(*i);
        monitorStreams = MutableWorld->monitorStreams;
      }
      monitorStreams->m_size = 0;
      g_havokPhysicsThreadPool->clearTimerData(g_havokPhysicsThreadPool);
    }
    else if ( monitorStreams->m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6274, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->monitorStreams->getSize() == 0)", (const char *)&queryFormat, "havokPhysicsWorld->monitorStreams->getSize() == 0") )
    {
      __debugbreak();
    }
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
  Profile_Begin(770);
  HavokPhysicsInstanceManager_PropagateAddedFlags(&MutableWorld->instanceManager);
  Profile_EndInternal(NULL);
  if ( stepIndex == v16 )
  {
    Profile_Begin(771);
    HavokPhysics_DoDeferredQueries(worldId);
    Profile_EndInternal(NULL);
  }
  if ( !MutableWorld->persistentStreamAllocator )
  {
    LODWORD(v39) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6297, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics StepWorldEnd %i: persistent stream allocator is NULL", "havokPhysicsWorld->persistentStreamAllocator", v39) )
      __debugbreak();
  }
  MutableWorld->persistentStreamAllocator->getMemoryStatistics(MutableWorld->persistentStreamAllocator, &MutableWorld->persistentMemoryStats.m_allocatorStats);
  if ( !s_havokPhysicsGeneralLargeBlockAllocator )
  {
    LODWORD(v39) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6301, ASSERT_TYPE_ASSERT, "(s_havokPhysicsGeneralLargeBlockAllocator)", "%s\n\tHavokPhysics StepWorldEnd %i: general memory allocator is NULL", "s_havokPhysicsGeneralLargeBlockAllocator", v39) )
      __debugbreak();
  }
  v23 = s_havokPhysicsGeneralLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsGeneralLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  if ( *(__int64 *)&s_generalMemoryPeakInUse > v23 )
    v23 = *(_QWORD *)&s_generalMemoryPeakInUse;
  *(_QWORD *)&s_generalMemoryPeakInUse = v23;
  if ( v23 > s_generalMemoryThreshold )
  {
    v24 = DVARBOOL_physics_disableSpammyWarnings;
    if ( !DVARBOOL_physics_disableSpammyWarnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_disableSpammyWarnings") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v24);
    if ( !v24->current.enabled )
      Com_PrintWarning(20, "Physics General Memory Buffer almost full - using %llu bytes with target max of %llu.  Turn this message off with dvar physics_disableSpammyWarnings\n", *(_QWORD *)&s_generalMemoryPeakInUse, s_generalMemoryThreshold);
  }
  v25 = s_havokPhysicsMapLocalLargeBlockAllocator->getApproxTotalAllocated(&s_havokPhysicsMapLocalLargeBlockAllocator->hkMemoryAllocator::ExtendedInterface);
  if ( *(__int64 *)&s_mapLocalMemoryPeakInUse > v25 )
    v25 = *(_QWORD *)&s_mapLocalMemoryPeakInUse;
  *(_QWORD *)&s_mapLocalMemoryPeakInUse = v25;
  if ( s_havokPhysicsDebugMemoryAllocator )
  {
    v26 = s_havokPhysicsDebugMemoryAllocator->getApproxTotalAllocated(&s_havokPhysicsDebugMemoryAllocator->hkMemoryAllocator::ExtendedInterface);
    if ( *(__int64 *)&s_debugMemoryPeakInUse > v26 )
      v26 = *(_QWORD *)&s_debugMemoryPeakInUse;
    *(_QWORD *)&s_debugMemoryPeakInUse = v26;
  }
  if ( MutableWorld->stepCPUIndex >= 6 )
  {
    LODWORD(v39) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6319, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->stepCPUIndex < PHYSICS_MAX_STEPS_PER_FRAME)", "%s\n\tHavokPhysics StepWorldEnd %i: too many steps captured", "havokPhysicsWorld->stepCPUIndex < PHYSICS_MAX_STEPS_PER_FRAME", v39) )
      __debugbreak();
  }
  m_ticks_total = MutableWorld->stepStopWatch.m_ticks_total;
  if ( MutableWorld->stepStopWatch.m_running_flag.m_bool )
    m_ticks_total += hkStopwatch::getTickCounter() - MutableWorld->stepStopWatch.m_ticks_at_start;
  _XMM0 = 0i64;
  __asm { vcvtsi2sd xmm0, xmm0, rdi }
  if ( m_ticks_total < 0 )
  {
    *((_QWORD *)&v30 + 1) = *((_QWORD *)&_XMM0 + 1);
    *(double *)&v30 = *(double *)&_XMM0 + 1.844674407370955e19;
    _XMM0 = v30;
  }
  *((_QWORD *)&v32 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v32 = *(double *)&_XMM0 * MutableWorld->stepStopWatch.m_inv_ticks_per_second;
  _XMM0 = v32;
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  MutableWorld->stepCPUTimes[MutableWorld->stepCPUIndex] = *(float *)&_XMM1 * 1000.0;
  stepCPUIndex = MutableWorld->stepCPUIndex;
  _XMM1 = LODWORD(MutableWorld->maxStepCPUTime);
  __asm { vmaxss  xmm2, xmm1, dword ptr [rbx+rcx*4+0ED8h] }
  _XMM1 = LODWORD(MutableWorld->maxFrameCPUTime);
  MutableWorld->maxStepCPUTime = *(float *)&_XMM2;
  *(float *)&v32 = MutableWorld->stepCPUTimes[stepCPUIndex] + MutableWorld->lastFrameCPUTime;
  __asm { vmaxss  xmm2, xmm1, xmm3 }
  MutableWorld->maxFrameCPUTime = *(float *)&_XMM2;
  MutableWorld->lastFrameCPUTime = *(float *)&v32;
  MutableWorld->stepCPUIndex = stepCPUIndex + 1;
}

/*
==============
HavokPhysics_StepWorldFX
==============
*/
void HavokPhysics_StepWorldFX(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v6; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream *Value; 
  hkMemoryAllocator *v9; 
  int m_size; 
  hkMonitorStream *v11; 
  hkMonitorStream *v12; 
  hkMemoryAllocator *v13; 
  __int64 v14; 
  void *p; 
  int v17; 
  int v18; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6129, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldFX with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v6 = MutableWorld;
  if ( MutableWorld->hasFXSupport )
  {
    if ( MutableWorld->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      monitorStreams = v6->monitorStreams;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      v9 = hkMemHeapAllocator();
      m_size = monitorStreams->m_size;
      if ( m_size == (monitorStreams->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v9, monitorStreams, 8);
        m_size = monitorStreams->m_size;
      }
      monitorStreams->m_data[m_size] = Value;
      ++monitorStreams->m_size;
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
    PhysicsFX_Lock(1);
    v11 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v11 )
      hkMonitorStream::timerBegin(v11, "TtFX Step");
    if ( !g_havokPhysicsThreadPool )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6156, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics StepWorldFX %i: threadpool is NULL", "g_havokPhysicsThreadPool", v14) )
        __debugbreak();
    }
    if ( v6->isMultithreaded && !v6->taskQueue )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6157, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics StepWorldFX %i: taskQueue is NULL", "!havokPhysicsWorld->isMultithreaded || havokPhysicsWorld->taskQueue", v14) )
        __debugbreak();
    }
    if ( !v6->world )
    {
      LODWORD(v14) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6158, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics StepWorldFX %i: world is NULL", "havokPhysicsWorld->world", v14) )
        __debugbreak();
    }
    if ( v6->hasFXSupport )
      PhysicsFX_StepWorld(worldId);
    if ( v6->isMultithreaded )
    {
      Profile_Begin(769);
      hkDefaultTaskQueue::close(v6->taskQueue);
      HavokPhysicsThreadPool::waitForCompletion(g_havokPhysicsThreadPool, v6->taskQueue);
      Profile_EndInternal(NULL);
      Profile_Begin(768);
      hkDefaultTaskQueue::reset(v6->taskQueue);
      Profile_EndInternal(NULL);
    }
    v12 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v12 )
      hkMonitorStream::timerEnd(v12, "Et");
    PhysicsFX_Lock(0);
    if ( v6->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      if ( !v6->visContext )
      {
        LODWORD(v14) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6188, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics StepWorldEnd %i: visualization constext is NULL", "havokPhysicsWorld->visContext", v14) )
          __debugbreak();
      }
      if ( v6->isMultithreaded )
      {
        p = NULL;
        v17 = 0;
        v18 = 0x80000000;
        g_havokPhysicsThreadPool->appendTimerData(g_havokPhysicsThreadPool, (hkArray<hkTimerData,hkContainerHeapAllocator> *)&p);
        v13 = hkMemHeapAllocator();
        v17 = 0;
        if ( v18 >= 0 )
          hkMemoryAllocator::bufFree2(v13, p, 16, v18 & 0x3FFFFFFF);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
  }
}

/*
==============
HavokPhysics_StepWorldPhysicsObjects
==============
*/
void HavokPhysics_StepWorldPhysicsObjects(Physics_WorldId worldId, int stepIndex, int numStepsPlanned)
{
  ;
}

/*
==============
HavokPhysics_StepWorldPrep
==============
*/

void __fastcall HavokPhysics_StepWorldPrep(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, double stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  __int128 v9; 
  Physics_WorldId v11; 

  _XMM6 = *(_OWORD *)&stepTimeOverride;
  Profile_Begin(610);
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v11 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5842, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldStep with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v11) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( *(float *)&stepTimeOverride <= 0.0 )
    _XMM6 = LODWORD(MutableWorld->timeStep);
  _XMM1 = LODWORD(MutableWorld->stepInput.m_followingStepMaxDeltaTime);
  MutableWorld->stepInput.m_deltaTime = *(float *)&_XMM6;
  if ( *(float *)&_XMM1 != 0.0 )
  {
    __asm { vminss  xmm6, xmm1, xmm6 }
    MutableWorld->stepInput.m_deltaTime = *(float *)&_XMM6;
  }
  v9 = _XMM6;
  *(float *)&v9 = *(float *)&_XMM6 * 1.2;
  _XMM0 = v9;
  __asm { vmaxss  xmm1, xmm0, xmm1 }
  MutableWorld->stepInput.m_followingStepMaxDeltaTime = *(float *)&_XMM1;
  Profile_EndInternal(NULL);
}

/*
==============
HavokPhysics_StepWorldSolve
==============
*/
void HavokPhysics_StepWorldSolve(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  HavokPhysicsWorld *v6; 
  hkArray<hkMonitorStream *,hkContainerHeapAllocator> *monitorStreams; 
  hkMonitorStream *Value; 
  hkMemoryAllocator *v9; 
  int m_size; 
  hkMonitorStream *v11; 
  hkTaskQueue *taskQueue; 
  hkTaskQueue *v13; 
  int v14; 
  hkMonitorStream *v15; 
  hkMonitorStream *v16; 
  int v17; 
  struct hkTaskQueue::_Handle *v18; 
  hkMonitorStream *v19; 
  hkMemoryAllocator *v20; 
  __int64 v21; 
  float v22; 
  float v23; 
  void *p; 
  int v25; 
  int v26; 
  __int64 v27; 
  hknpTaskGraph taskGraph; 

  v27 = -2i64;
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6003, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StepWorldSolve with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v6 = MutableWorld;
  if ( MutableWorld->stepInput.m_deltaTime > 0.0 )
  {
    if ( MutableWorld->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      monitorStreams = v6->monitorStreams;
      Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
      v9 = hkMemHeapAllocator();
      m_size = monitorStreams->m_size;
      if ( m_size == (monitorStreams->m_capacityAndFlags & 0x3FFFFFFF) )
      {
        hkArrayUtil::_reserveMore(v9, monitorStreams, 8);
        m_size = monitorStreams->m_size;
      }
      monitorStreams->m_data[m_size] = Value;
      ++monitorStreams->m_size;
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
    v11 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v11 )
      hkMonitorStream::timerBegin(v11, "TtPhysics stepSolve");
    taskQueue = (hkTaskQueue *)v6->taskQueue;
    v13 = taskQueue + 3;
    if ( !taskQueue )
      v13 = NULL;
    if ( !g_havokPhysicsThreadPool )
    {
      LODWORD(v21) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6029, ASSERT_TYPE_ASSERT, "(g_havokPhysicsThreadPool)", "%s\n\tHavokPhysics StepWorldSolve %i: threadpool is NULL", "g_havokPhysicsThreadPool", v21) )
        __debugbreak();
    }
    if ( v6->isMultithreaded && !v13 )
    {
      LODWORD(v21) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6030, ASSERT_TYPE_ASSERT, "(!havokPhysicsWorld->isMultithreaded || taskQueue)", "%s\n\tHavokPhysics StepWorldSolve %i: taskQueue is NULL", "!havokPhysicsWorld->isMultithreaded || taskQueue", v21) )
        __debugbreak();
    }
    if ( !v6->world )
    {
      LODWORD(v21) = worldId;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6031, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics StepWorldSolve %i: world is NULL", "havokPhysicsWorld->world", v21) )
        __debugbreak();
    }
    v14 = 624;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_SERVER_DETAIL )
      v14 = 627;
    Profile_Begin(v14);
    v15 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    v16 = v15;
    if ( v15 )
      hkMonitorStream::timerBegin(v15, "TtPhysics");
    hknpTaskGraph::hknpTaskGraph(&taskGraph);
    Sys_ProfBeginNamedEvent(0xFFFF6347, "GenerateSolveTasks");
    hknpWorld::generateSolveTasks(v6->world, &taskGraph);
    Sys_ProfEndNamedEvent();
    if ( v6->isMultithreaded )
    {
      Profile_Begin(611);
      if ( !Physics_RenderDebugEnabled() )
        HavokPhysicsThreadPool::setUsage(g_havokPhysicsThreadPool, HAVOKPHYSICS_THREADPOOL_USAGE_AUTHSOLVE);
      v17 = g_havokPhysicsThreadPool->getNumThreads(g_havokPhysicsThreadPool);
      HavokPhysicsThreadPool::startWorkerCommands(g_havokPhysicsThreadPool, worldId, v17);
      Profile_EndInternal(NULL);
    }
    if ( taskGraph.m_nodes.m_size || taskGraph.m_dependencies.m_size )
    {
      if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6071, ASSERT_TYPE_ASSERT, "(taskQueue != nullptr)", "%s\n\tNo task queue provided", "taskQueue != HK_NULL") )
        __debugbreak();
      v18 = hkTaskGraph::submitToTaskQueue(&taskGraph, v13, FIFO);
      if ( v16 )
        hkMonitorStream::timerEnd(v16, "Et");
      v23 = 0.0;
      v22 = 0.0;
      v6->taskQueue->processUntilFinished(&v6->taskQueue->hkTaskQueue, &v23, &v22, v18);
      if ( v16 )
        hkMonitorStream::timerBegin(v16, "TtPhysics");
      hkTaskGraph::freeTaskQueueHandles(&taskGraph, v13);
    }
    if ( v16 )
      hkMonitorStream::timerEnd(v16, "EtPhysics");
    hkTaskGraph::~hkTaskGraph(&taskGraph);
    Profile_EndInternal(NULL);
    if ( v6->isMultithreaded )
    {
      Profile_Begin(769);
      hkDefaultTaskQueue::close(v6->taskQueue);
      HavokPhysicsThreadPool::waitForCompletion(g_havokPhysicsThreadPool, v6->taskQueue);
      Profile_EndInternal(NULL);
      Profile_Begin(768);
      hkDefaultTaskQueue::reset(v6->taskQueue);
      Profile_EndInternal(NULL);
    }
    v19 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
    if ( v19 )
      hkMonitorStream::timerEnd(v19, "Et");
    if ( v6->isMultithreaded )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
      if ( !v6->visContext )
      {
        LODWORD(v21) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6110, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->visContext)", "%s\n\tHavokPhysics StepWorldEnd %i: visualization constext is NULL", "havokPhysicsWorld->visContext", v21) )
          __debugbreak();
      }
      if ( v6->isMultithreaded )
      {
        p = NULL;
        v25 = 0;
        v26 = 0x80000000;
        g_havokPhysicsThreadPool->appendTimerData(g_havokPhysicsThreadPool, (hkArray<hkTimerData,hkContainerHeapAllocator> *)&p);
        v20 = hkMemHeapAllocator();
        v25 = 0;
        if ( v26 >= 0 )
          hkMemoryAllocator::bufFree2(v20, p, 16, v26 & 0x3FFFFFFF);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&s_havokPhysics_VdbCritSection);
    }
  }
}

/*
==============
HavokPhysics_StepWorldStart
==============
*/
void HavokPhysics_StepWorldStart(Physics_WorldId worldId, int stepIndex, int numStepsPlanned, float stepTimeOverride)
{
  HavokPhysicsWorld *MutableWorld; 
  bool v6; 
  HavokPhysicsWorld *v7; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hkMemoryRouter *Value; 
  hkStreamWriter_vtbl *v10; 
  hknpWorldSnapshot *v11; 
  hknpWorldSnapshot *v12; 
  unsigned __int64 TickCounter; 
  hkBool result; 
  hkStreamWriter writer; 
  hkOstream v16; 

  writer.m_propertyBag.m_bag = (hkDefaultPropertyBag *)-2i64;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( s_havokPhysics_forceSnapshot )
  {
    s_havokPhysics_forceSnapshot = 0;
    v6 = s_havokPhysics_humanReadableSnapshot;
    if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24049, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Take Snapshot with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
      __debugbreak();
    v7 = HavokPhysics_GetMutableWorld(worldId);
    p_critSection = (_RTL_CRITICAL_SECTION *)&v7->critSection;
    *(_QWORD *)&writer.m_memSizeAndFlags = &v7->critSection;
    EnterCriticalSection((LPCRITICAL_SECTION)&v7->critSection);
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v10 = (hkStreamWriter_vtbl *)Value->m_heap->blockAlloc(Value->m_heap, 464i64);
    writer.__vftable = v10;
    if ( v10 )
    {
      hknpWorldSnapshot::hknpWorldSnapshot((hknpWorldSnapshot *)v10, v7->world, 0);
      v12 = v11;
    }
    else
    {
      v12 = NULL;
    }
    hkOstream::hkOstream(&v16, "HavokSnapshot.hkx");
    if ( hkOstream::isOk(&v16, &result)->m_bool )
    {
      if ( v6 )
        hknpWorldSnapshot::saveAsXml(v12, &writer);
      else
        hknpWorldSnapshot::saveAsBinary(v12, &writer);
    }
    hkReferencedObject::removeReference(v12);
    hkOstream::~hkOstream(&v16);
    LeaveCriticalSection(p_critSection);
  }
  MutableWorld->stepStopWatch.m_ticks_at_start = 0i64;
  MutableWorld->stepStopWatch.m_ticks_total = 0i64;
  MutableWorld->stepStopWatch.m_ticks_at_split = 0i64;
  MutableWorld->stepStopWatch.m_split_total = 0i64;
  MutableWorld->stepStopWatch.m_num_timings = 0;
  MutableWorld->stepStopWatch.m_running_flag.m_bool = 1;
  TickCounter = hkStopwatch::getTickCounter();
  MutableWorld->stepStopWatch.m_ticks_at_start = TickCounter;
  MutableWorld->stepStopWatch.m_ticks_at_split = TickCounter;
}

/*
==============
HavokPhysics_StopDrawDebugWorld
==============
*/
void HavokPhysics_StopDrawDebugWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 
  int v3; 
  __int64 v4; 
  hkProcess *v5; 
  hkMemoryAllocator *v6; 
  int m_capacityAndFlags; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 17379, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to StopDrawDebugWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  v3 = 0;
  if ( MutableWorld->visProcesses.m_size > 0 )
  {
    v4 = 0i64;
    do
    {
      v5 = MutableWorld->visProcesses.m_data[v4];
      if ( v5 )
        ((void (__fastcall *)(hkProcess *, __int64))v5->~hkProcess)(v5, 1i64);
      ++v3;
      ++v4;
    }
    while ( v3 < MutableWorld->visProcesses.m_size );
  }
  v6 = hkMemHeapAllocator();
  MutableWorld->visProcesses.m_size = 0;
  m_capacityAndFlags = MutableWorld->visProcesses.m_capacityAndFlags;
  if ( m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v6, MutableWorld->visProcesses.m_data, 8, m_capacityAndFlags & 0x3FFFFFFF);
  MutableWorld->visProcesses.m_data = NULL;
  MutableWorld->visProcesses.m_capacityAndFlags = 0x80000000;
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_SubscribeToEvent
==============
*/
void HavokPhysics_SubscribeToEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (*function)(const hknpEventHandlerInput *, const hknpEvent *), const char *name)
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int m_serialAndIndex; 
  hknpEventSignal *EventSignal; 
  __int64 v12; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 0x4000, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to SubscribeToEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v12) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16388, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics SubscribeToEvent %i: world is NULL", "physicsWorld->world", v12) )
      __debugbreak();
  }
  m_serialAndIndex = specificBodyId.m_serialAndIndex;
  if ( (specificBodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    m_serialAndIndex = 0xFFFFFF;
  EventSignal = hknpWorld::getEventSignal(MutableWorld->world, eventType, (hknpBodyId)m_serialAndIndex);
  hkSignal2<hknpEventHandlerInput const &,hknpEvent const &>::subscribe<void (*)(hknpEventHandlerInput const &,hknpEvent const &)>(EventSignal, function, name);
}

/*
==============
HavokPhysics_SwapPhysicsAsset
==============
*/
void HavokPhysics_SwapPhysicsAsset(PhysicsAsset *from, PhysicsAsset *to)
{
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v4; 
  int m_hashMod; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  Dummy *v9; 
  PhysicsAsset *key; 
  unsigned __int64 val; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v12; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  Dummy *v17; 
  PhysicsAsset *v18; 
  unsigned __int64 v19; 
  __m256i v20; 
  __m256i v21; 
  __int128 v22; 
  double v23; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v24; 
  int v25; 
  int v26; 
  int v27; 
  int v28; 
  unsigned __int32 v29; 
  unsigned __int32 v30; 
  int v31; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v33; 
  PhysicsAsset *v34; 
  __int64 v35; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v36; 
  hkPointerMap<PhysicsAsset *,HavokPhysicsAsset *,hkContainerHeapAllocator> *v37; 
  int v38; 
  int v39; 
  unsigned __int32 v40; 
  unsigned __int32 v41; 
  int v42; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v43; 
  unsigned int v44; 
  PhysicsAsset *v45; 
  __int64 v46; 
  hkMemoryAllocator alloc; 
  hkMemoryAllocator v48; 

  HavokPhysics_LockAssetWrite();
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7501, ASSERT_TYPE_ASSERT, "(from)", "%s\n\tTrying to clone a NULL Physics Asset", "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7502, ASSERT_TYPE_ASSERT, "(to)", "%s\n\tTrying to clone a NULL Physics Asset", "to") )
    __debugbreak();
  v4 = s_havokPhysicsAssets;
  if ( !s_havokPhysicsAssets )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7503, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets)", "%s\n\tTrying to Clone a physics asset but the pointermap is NULL", "s_havokPhysicsAssets") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  m_hashMod = v4->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v6 = _byteswap_ulong(-1640531535 * (_DWORD)from), v7 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v8 = m_hashMod & (v7 ^ ((v6 >> 2) + v6 + (v7 << 6) - 1640531527)), v9 = (Dummy *)v8, key = (PhysicsAsset *)v4->m_map.m_elem[v8].key, key == (PhysicsAsset *)-1i64) )
  {
LABEL_15:
    v9 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != from )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = (Dummy *)v8;
      key = (PhysicsAsset *)v4->m_map.m_elem[v8].key;
      if ( key == (PhysicsAsset *)-1i64 )
        goto LABEL_15;
    }
  }
  if ( (int)v9 > m_hashMod )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7506, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( fromIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( fromIt )") )
      __debugbreak();
    v4 = s_havokPhysicsAssets;
  }
  val = v4->m_map.m_elem[(int)v9].val;
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v4->m_map, v9);
  v12 = s_havokPhysicsAssets;
  v13 = s_havokPhysicsAssets->m_map.m_hashMod;
  if ( v13 <= 0 || (v14 = _byteswap_ulong(-1640531535 * (_DWORD)to), v15 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v16 = v13 & (v15 ^ ((v14 >> 2) + v14 + (v15 << 6) - 1640531527)), v17 = (Dummy *)v16, v18 = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v16].key, v18 == (PhysicsAsset *)-1i64) )
  {
LABEL_24:
    v17 = (Dummy *)(v13 + 1);
  }
  else
  {
    while ( v18 != to )
    {
      v16 = v13 & (v16 + 1);
      v17 = (Dummy *)v16;
      v18 = (PhysicsAsset *)s_havokPhysicsAssets->m_map.m_elem[v16].key;
      if ( v18 == (PhysicsAsset *)-1i64 )
        goto LABEL_24;
    }
  }
  if ( (int)v17 > v13 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7511, ASSERT_TYPE_ASSERT, "(s_havokPhysicsAssets->isValid( toIt ))", (const char *)&queryFormat, "s_havokPhysicsAssets->isValid( toIt )") )
      __debugbreak();
    v12 = s_havokPhysicsAssets;
  }
  v19 = v12->m_map.m_elem[(int)v17].val;
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v12->m_map, v17);
  v20 = *(__m256i *)&from->name;
  v21 = *(__m256i *)&from->simulationCategories;
  v22 = *(_OWORD *)&from->vfxEventAssets;
  v23 = *(double *)&from->usageCounter.dynEnt;
  v24 = s_havokPhysicsAssets;
  *(__m256i *)&from->name = *(__m256i *)&to->name;
  *(__m256i *)&from->simulationCategories = *(__m256i *)&to->simulationCategories;
  *(_OWORD *)&from->vfxEventAssets = *(_OWORD *)&to->vfxEventAssets;
  *(double *)&from->usageCounter.dynEnt = *(double *)&to->usageCounter.dynEnt;
  *(__m256i *)&to->name = v20;
  *(__m256i *)&to->simulationCategories = v21;
  *(_OWORD *)&to->vfxEventAssets = v22;
  *(double *)&to->usageCounter.dynEnt = v23;
  v25 = (unsigned int)hkMemHeapAllocator();
  v26 = v24->m_map.m_hashMod;
  if ( 2 * v24->m_map.m_numElems > v26 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v24->m_map, &alloc, v25);
    v26 = v24->m_map.m_hashMod;
  }
  v27 = 1;
  v28 = 1;
  v29 = _byteswap_ulong(-1640531535 * (_DWORD)to);
  v30 = _byteswap_ulong(-1640531535 * HIDWORD(to));
  v31 = v30 ^ ((v29 >> 2) + v29 + (v30 << 6) - 1640531527);
  m_elem = v24->m_map.m_elem;
  v33 = v26 & v31;
  v34 = (PhysicsAsset *)v24->m_map.m_elem[v33].key;
  if ( v34 != (PhysicsAsset *)-1i64 )
  {
    while ( v34 != to )
    {
      v33 = v24->m_map.m_hashMod & (v33 + 1);
      v34 = (PhysicsAsset *)m_elem[v33].key;
      if ( v34 == (PhysicsAsset *)-1i64 )
        goto LABEL_36;
    }
    v28 = 0;
  }
LABEL_36:
  v24->m_map.m_numElems += v28;
  v35 = (int)v33;
  m_elem[v35].key = (unsigned __int64)to;
  v36 = v24->m_map.m_elem;
  v37 = s_havokPhysicsAssets;
  v36[v35].val = val;
  v38 = (unsigned int)hkMemHeapAllocator();
  v39 = v37->m_map.m_hashMod;
  if ( 2 * v37->m_map.m_numElems > v39 )
  {
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v37->m_map, &v48, v38);
    v39 = v37->m_map.m_hashMod;
  }
  v40 = _byteswap_ulong(-1640531535 * (_DWORD)from);
  v41 = _byteswap_ulong(-1640531535 * HIDWORD(from));
  v42 = v41 ^ ((v40 >> 2) + v40 + (v41 << 6) - 1640531527);
  v43 = v37->m_map.m_elem;
  v44 = v39 & v42;
  v45 = (PhysicsAsset *)v37->m_map.m_elem[v44].key;
  if ( v45 != (PhysicsAsset *)-1i64 )
  {
    while ( v45 != from )
    {
      v44 = v37->m_map.m_hashMod & (v44 + 1);
      v45 = (PhysicsAsset *)v43[v44].key;
      if ( v45 == (PhysicsAsset *)-1i64 )
        goto LABEL_43;
    }
    v27 = 0;
  }
LABEL_43:
  v37->m_map.m_numElems += v27;
  v46 = (int)v44;
  v43[v46].key = (unsigned __int64)from;
  v37->m_map.m_elem[v46].val = v19;
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SwapPhysicsSFXEventAsset
==============
*/
void HavokPhysics_SwapPhysicsSFXEventAsset(PhysicsSFXEventAsset *from, PhysicsSFXEventAsset *to)
{
  unsigned int v4; 
  __m256i v5; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  hkMemoryAllocator *v8; 
  unsigned int key; 
  PhysicsSFXEventAsset *val; 

  val = to;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7092, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7093, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsSFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7094, ASSERT_TYPE_ASSERT, "(g_physicsSFXEventAssets)", (const char *)&queryFormat, "g_physicsSFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)from) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7097, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_SFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7098, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsSFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsSFXAssetInternal(to);
  v5 = *(__m256i *)from;
  *from = *to;
  *(__m256i *)to = v5;
  v6 = v4;
  HavokPhysics_LockAssetWrite();
  key = v6;
  v7 = g_physicsSFXEventAssets;
  v8 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsSFXEventAsset *,hkMapOperations<unsigned int>>::insert(v7, v8, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SwapPhysicsVFXEventAsset
==============
*/
void HavokPhysics_SwapPhysicsVFXEventAsset(PhysicsVFXEventAsset *from, PhysicsVFXEventAsset *to)
{
  unsigned int v4; 
  __m256i v5; 
  unsigned int v6; 
  hkMap<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>,hkContainerHeapAllocator> *v7; 
  hkMemoryAllocator *v8; 
  unsigned int key; 
  PhysicsVFXEventAsset *val; 

  val = to;
  if ( !from && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7256, ASSERT_TYPE_ASSERT, "(from)", (const char *)&queryFormat, "from") )
    __debugbreak();
  if ( !to && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7257, ASSERT_TYPE_ASSERT, "(to)", (const char *)&queryFormat, "to") )
    __debugbreak();
  if ( !g_physicsVFXEventAssets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7258, ASSERT_TYPE_ASSERT, "(g_physicsVFXEventAssets)", (const char *)&queryFormat, "g_physicsVFXEventAssets") )
    __debugbreak();
  if ( DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)from) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7261, ASSERT_TYPE_ASSERT, "(!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from ))", (const char *)&queryFormat, "!HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( from )") )
    __debugbreak();
  if ( !DB_IsLiveHeadAssetNonLocking(ASSET_TYPE_PHYSICS_VFX_EVENT_ASSET, (XAssetHeader)to) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 7262, ASSERT_TYPE_ASSERT, "(HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to ))", (const char *)&queryFormat, "HavokPhysics_IsPhysicsVFXEventLiveHeadAsset( to )") )
    __debugbreak();
  v4 = HavokPhysics_RemovePhysicsVFXAssetInternal(to);
  v5 = *(__m256i *)from;
  *from = *to;
  *(__m256i *)to = v5;
  v6 = v4;
  HavokPhysics_LockAssetWrite();
  key = v6;
  v7 = g_physicsVFXEventAssets;
  v8 = hkMemHeapAllocator();
  hkMapBase<unsigned int,PhysicsVFXEventAsset *,hkMapOperations<unsigned int>>::insert(v7, v8, &key, &val);
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_SwapXModelDetailCollisionAsset
==============
*/
void HavokPhysics_SwapXModelDetailCollisionAsset(XModelDetailCollision *from, XModelDetailCollision *to)
{
  unsigned __int64 val; 
  unsigned __int64 v5; 
  hkPointerMap<XModelDetailCollision *,HavokPhysicsXModelLOD *,hkContainerHeapAllocator> *v6; 
  int m_hashMod; 
  unsigned __int32 v8; 
  unsigned __int32 v9; 
  unsigned int v10; 
  Dummy *v11; 
  XModelDetailCollision *key; 
  int v13; 
  unsigned __int32 v14; 
  unsigned __int32 v15; 
  unsigned int v16; 
  Dummy *v17; 
  XModelDetailCollision *v18; 
  int v19; 
  int v20; 
  int v21; 
  int v22; 
  unsigned __int32 v23; 
  unsigned __int32 v24; 
  int v25; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned int v27; 
  XModelDetailCollision *v28; 
  __int64 v29; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v30; 
  int v31; 
  int v32; 
  unsigned __int32 v33; 
  unsigned __int32 v34; 
  int v35; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *v36; 
  unsigned int v37; 
  XModelDetailCollision *v38; 
  __int64 v39; 
  hkMemoryAllocator alloc; 
  hkMemoryAllocator v41; 

  val = 0i64;
  v5 = 0i64;
  HavokPhysics_LockAssetWrite();
  v6 = s_havokPhysicsXModelLODs;
  m_hashMod = s_havokPhysicsXModelLODs->m_map.m_hashMod;
  if ( m_hashMod <= 0 || (v8 = _byteswap_ulong(-1640531535 * HIDWORD(from)), v9 = _byteswap_ulong(-1640531535 * (_DWORD)from), v10 = m_hashMod & (v8 ^ ((v9 >> 2) + v9 + (v8 << 6) - 1640531527)), v11 = (Dummy *)v10, key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v10].key, key == (XModelDetailCollision *)-1i64) )
  {
LABEL_5:
    v11 = (Dummy *)(m_hashMod + 1);
  }
  else
  {
    while ( key != from )
    {
      v10 = m_hashMod & (v10 + 1);
      v11 = (Dummy *)v10;
      key = (XModelDetailCollision *)s_havokPhysicsXModelLODs->m_map.m_elem[v10].key;
      if ( key == (XModelDetailCollision *)-1i64 )
        goto LABEL_5;
    }
  }
  if ( (int)v11 <= m_hashMod )
  {
    val = s_havokPhysicsXModelLODs->m_map.m_elem[(int)v11].val;
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&s_havokPhysicsXModelLODs->m_map, v11);
    v6 = s_havokPhysicsXModelLODs;
  }
  v13 = v6->m_map.m_hashMod;
  if ( v13 <= 0 || (v14 = _byteswap_ulong(-1640531535 * HIDWORD(to)), v15 = _byteswap_ulong(-1640531535 * (_DWORD)to), v16 = v13 & (v14 ^ ((v15 >> 2) + v15 + (v14 << 6) - 1640531527)), v17 = (Dummy *)v16, v18 = (XModelDetailCollision *)v6->m_map.m_elem[v16].key, v18 == (XModelDetailCollision *)-1i64) )
  {
LABEL_12:
    v17 = (Dummy *)(v13 + 1);
  }
  else
  {
    while ( v18 != to )
    {
      v16 = v13 & (v16 + 1);
      v17 = (Dummy *)v16;
      v18 = (XModelDetailCollision *)v6->m_map.m_elem[v16].key;
      if ( v18 == (XModelDetailCollision *)-1i64 )
        goto LABEL_12;
    }
  }
  if ( (int)v17 <= v13 )
  {
    v5 = v6->m_map.m_elem[(int)v17].val;
    hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::remove(&v6->m_map, v17);
    v6 = s_havokPhysicsXModelLODs;
  }
  v19 = 1;
  if ( val )
  {
    v20 = (unsigned int)hkMemHeapAllocator();
    v21 = v6->m_map.m_hashMod;
    if ( 2 * v6->m_map.m_numElems > v21 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v6->m_map, &alloc, v20);
      v21 = v6->m_map.m_hashMod;
    }
    v22 = 1;
    v23 = _byteswap_ulong(-1640531535 * (_DWORD)to);
    v24 = _byteswap_ulong(-1640531535 * HIDWORD(to));
    v25 = v24 ^ ((v23 >> 2) + v23 + (v24 << 6) - 1640531527);
    m_elem = v6->m_map.m_elem;
    v27 = v21 & v25;
    v28 = (XModelDetailCollision *)v6->m_map.m_elem[v27].key;
    if ( v28 != (XModelDetailCollision *)-1i64 )
    {
      while ( v28 != to )
      {
        v27 = v6->m_map.m_hashMod & (v27 + 1);
        v28 = (XModelDetailCollision *)m_elem[v27].key;
        if ( v28 == (XModelDetailCollision *)-1i64 )
          goto LABEL_23;
      }
      v22 = 0;
    }
LABEL_23:
    v6->m_map.m_numElems += v22;
    v29 = (int)v27;
    m_elem[v29].key = (unsigned __int64)to;
    v30 = v6->m_map.m_elem;
    v6 = s_havokPhysicsXModelLODs;
    v30[v29].val = val;
  }
  if ( v5 )
  {
    v31 = (unsigned int)hkMemHeapAllocator();
    v32 = v6->m_map.m_hashMod;
    if ( 2 * v6->m_map.m_numElems > v32 )
    {
      hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64>>::resizeTable(&v6->m_map, &v41, v31);
      v32 = v6->m_map.m_hashMod;
    }
    v33 = _byteswap_ulong(-1640531535 * (_DWORD)from);
    v34 = _byteswap_ulong(-1640531535 * HIDWORD(from));
    v35 = v34 ^ ((v33 >> 2) + v33 + (v34 << 6) - 1640531527);
    v36 = v6->m_map.m_elem;
    v37 = v32 & v35;
    v38 = (XModelDetailCollision *)v6->m_map.m_elem[v37].key;
    if ( v38 != (XModelDetailCollision *)-1i64 )
    {
      while ( v38 != from )
      {
        v37 = v6->m_map.m_hashMod & (v37 + 1);
        v38 = (XModelDetailCollision *)v36[v37].key;
        if ( v38 == (XModelDetailCollision *)-1i64 )
          goto LABEL_32;
      }
      v19 = 0;
    }
LABEL_32:
    v6->m_map.m_numElems += v19;
    v39 = (int)v37;
    v36[v39].key = (unsigned __int64)from;
    v6->m_map.m_elem[v39].val = v5;
  }
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_TakeMemorySnapshot
==============
*/
void HavokPhysics_TakeMemorySnapshot(const char *filename)
{
  hkMemoryTrackerReportUtil::takeSnapshotsAndGenerateReport(hkMemoryTracker::s_singleton, filename);
}

/*
==============
HavokPhysics_TakeSnapshot
==============
*/
void HavokPhysics_TakeSnapshot(Physics_WorldId worldId, const char *filename, bool humanReadable)
{
  HavokPhysicsWorld *MutableWorld; 
  _RTL_CRITICAL_SECTION *p_critSection; 
  hkMemoryRouter *Value; 
  hknpWorldSnapshot *v9; 
  hknpWorldSnapshot *v10; 
  hknpWorldSnapshot *v11; 
  hkOstream v12; 
  hkStreamWriter result; 
  hkCriticalSection *v14; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 24049, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to Take Snapshot with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  p_critSection = (_RTL_CRITICAL_SECTION *)&MutableWorld->critSection;
  v14 = &MutableWorld->critSection;
  EnterCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
  Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
  if ( !Value )
    Value = hkMemoryRouter::s_fallbackRouter;
  v9 = (hknpWorldSnapshot *)Value->m_heap->blockAlloc(Value->m_heap, 464i64);
  if ( v9 )
  {
    hknpWorldSnapshot::hknpWorldSnapshot(v9, MutableWorld->world, 0);
    v11 = v10;
  }
  else
  {
    v11 = NULL;
  }
  hkOstream::hkOstream(&v12, filename);
  if ( hkOstream::isOk(&v12, (hkBool *)&result)->m_bool )
  {
    if ( humanReadable )
      hknpWorldSnapshot::saveAsXml(v11, &result);
    else
      hknpWorldSnapshot::saveAsBinary(v11, &result);
  }
  hkReferencedObject::removeReference(v11);
  hkOstream::~hkOstream(&v12);
  LeaveCriticalSection(p_critSection);
}

/*
==============
HavokPhysics_Task
==============
*/
void HavokPhysics_Task(Physics_WorldId worldId, int taskId)
{
  hkMonitorStream *Value; 
  HavokPhysicsWorld *MutableWorld; 
  hkMonitorStream *v6; 
  __int64 v7; 
  int v8; 
  __int64 v9; 
  Physics_WorldId v10; 
  float timeWaiting; 
  float timeTaken; 

  HavokPhysicsThreadPool::onWorkerCommandStart(g_havokPhysicsThreadPool, taskId);
  Value = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( Value )
    hkMonitorStream::timerBegin(Value, "TtThread Task");
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
  {
    v10 = worldId;
    v8 = taskId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6341, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to do a Task %i with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v8, v10) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->taskQueue )
  {
    LODWORD(v9) = worldId;
    LODWORD(v7) = taskId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6345, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->taskQueue)", "%s\n\tHavokPhysics: Trying to do a Task %i with invalid task queue for world %i", "havokPhysicsWorld->taskQueue", v7, v9) )
      __debugbreak();
  }
  timeTaken = 0.0;
  timeWaiting = 0.0;
  hkDefaultTaskQueue::process(MutableWorld->taskQueue, &timeTaken, &timeWaiting);
  v6 = (hkMonitorStream *)TlsGetValue(hkMonitorStream__m_instance.m_slotID);
  if ( v6 )
    hkMonitorStream::timerEnd(v6, "Et");
  HavokPhysicsThreadPool::onWorkerCommandEnd(g_havokPhysicsThreadPool, taskId, timeTaken, timeWaiting);
}

/*
==============
HavokPhysics_TightenConstraint
==============
*/
void HavokPhysics_TightenConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, PhysicsConstraintLooseningResult *values, float proportion)
{
  HavokPhysicsWorld *MutableWorld; 
  float *v7; 
  int v8; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v7 = *(float **)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, constraintId.m_value) + 8);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13518, ASSERT_TYPE_ASSERT, "(constraintData)", (const char *)&queryFormat, "constraintData") )
    __debugbreak();
  v8 = (*(__int64 (__fastcall **)(float *))(*(_QWORD *)v7 + 24i64))(v7);
  if ( v8 == 2 )
  {
    v7[63] = (float)((float)(1.0 - proportion) * values->before.ragdoll.planeMin) + (float)(proportion * values->after.ragdoll.planeMin);
    v7[62] = (float)((float)(1.0 - proportion) * values->before.ragdoll.cone) + (float)(proportion * values->after.ragdoll.cone);
  }
  else if ( v8 == 7 )
  {
    v7[87] = (float)((float)(1.0 - proportion) * values->before.ragdoll.cone) + (float)(proportion * values->after.ragdoll.cone);
    v7[95] = (float)((float)(1.0 - proportion) * values->before.ragdoll.planeMax) + (float)(proportion * values->after.ragdoll.planeMax);
    v7[94] = (float)((float)(1.0 - proportion) * values->before.ragdoll.planeMin) + (float)(proportion * values->after.ragdoll.planeMin);
    v7[79] = (float)((float)(1.0 - proportion) * values->before.ragdoll.twistMax) + (float)(proportion * values->after.ragdoll.twistMax);
    v7[78] = (float)((float)(1.0 - proportion) * values->before.ragdoll.twistMin) + (float)(proportion * values->after.ragdoll.twistMin);
  }
}

/*
==============
HavokPhysics_TransientZoneLoaded
==============
*/
void HavokPhysics_TransientZoneLoaded(unsigned int worldTransientIndex, bool fullLoad)
{
  const char *WorldTransientName; 
  char *fmt; 
  __int64 v6; 

  if ( worldTransientIndex )
  {
    if ( worldTransientIndex - 1 <= 0x1E )
      goto LABEL_7;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3937, ASSERT_TYPE_ASSERT, "(worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE)", (const char *)&queryFormat, "worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE") )
  {
    __debugbreak();
  }
  LODWORD(v6) = worldTransientIndex;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3938, ASSERT_TYPE_ASSERT, "( HAVOK_PHYSICS_TRANSIENT_ZONES_START ) <= ( worldTransientIndex ) && ( worldTransientIndex ) <= ( HAVOK_PHYSICS_MAX_ZONES - 1 )", "worldTransientIndex not in [HAVOK_PHYSICS_TRANSIENT_ZONES_START, HAVOK_PHYSICS_MAX_ZONES - 1]\n\t%i not in [%i, %i]", v6, 1, 31) )
    __debugbreak();
LABEL_7:
  WorldTransientName = DB_Transients_GetWorldTransientName(worldTransientIndex);
  LODWORD(fmt) = fullLoad;
  Com_Printf(10, "HavokPhysics_TransientZone: Loaded %u %s %d\n", worldTransientIndex, WorldTransientName, fmt);
}

/*
==============
HavokPhysics_TransientZoneUnloading
==============
*/
void HavokPhysics_TransientZoneUnloading(unsigned int worldTransientIndex, bool fullUnload)
{
  const char *WorldTransientName; 
  char *fmt; 
  __int64 v6; 

  if ( worldTransientIndex )
  {
    if ( worldTransientIndex - 1 <= 0x1E )
      goto LABEL_7;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3947, ASSERT_TYPE_ASSERT, "(worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE)", (const char *)&queryFormat, "worldTransientIndex != HAVOK_PHYSICS_MAIN_ZONE") )
  {
    __debugbreak();
  }
  LODWORD(v6) = worldTransientIndex;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 3948, ASSERT_TYPE_ASSERT, "( HAVOK_PHYSICS_TRANSIENT_ZONES_START ) <= ( worldTransientIndex ) && ( worldTransientIndex ) <= ( HAVOK_PHYSICS_MAX_ZONES - 1 )", "worldTransientIndex not in [HAVOK_PHYSICS_TRANSIENT_ZONES_START, HAVOK_PHYSICS_MAX_ZONES - 1]\n\t%i not in [%i, %i]", v6, 1, 31) )
    __debugbreak();
LABEL_7:
  WorldTransientName = DB_Transients_GetWorldTransientName(worldTransientIndex);
  LODWORD(fmt) = fullUnload;
  Com_Printf(10, "HavokPhysics_TransientZone: Unloading %u %s %d\n", worldTransientIndex, WorldTransientName, fmt);
}

/*
==============
HavokPhysics_UnlockAssetRead
==============
*/
void HavokPhysics_UnlockAssetRead(void)
{
  ReleaseSRWLockShared((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_UnlockAssetWrite
==============
*/
void HavokPhysics_UnlockAssetWrite(void)
{
  s_havokPhysicsAssetLock.writeThreadId = 0;
  ReleaseSRWLockExclusive((PSRWLOCK)&s_havokPhysicsAssetLock);
  Sys_CheckReleaseLock(&s_havokPhysicsAssetLock);
}

/*
==============
HavokPhysics_UnlockWorld
==============
*/
void HavokPhysics_UnlockWorld(Physics_WorldId worldId)
{
  HavokPhysicsWorld *MutableWorld; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6438, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to unlock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  LeaveCriticalSection((LPCRITICAL_SECTION)&MutableWorld->critSection);
}

/*
==============
HavokPhysics_UnsubscribeFromEvent
==============
*/
void HavokPhysics_UnsubscribeFromEvent(Physics_WorldId worldId, hknpEventType::Enum eventType, hknpBodyId specificBodyId, void (*function)(const hknpEventHandlerInput *, const hknpEvent *))
{
  HavokPhysicsWorld *MutableWorld; 
  unsigned int m_serialAndIndex; 
  hknpEventSignal *EventSignal; 
  __int64 v11; 
  void (__fastcall *method[5])(const hknpEventHandlerInput *, const hknpEvent *); 
  hkBool result; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16407, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to UnsubscribeFromEvent with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v11) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 16411, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics UnsubscribeFromEvent %i: world is NULL", "physicsWorld->world", v11) )
      __debugbreak();
  }
  m_serialAndIndex = specificBodyId.m_serialAndIndex;
  if ( (specificBodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
    m_serialAndIndex = 0xFFFFFF;
  EventSignal = hknpWorld::getEventSignal(MutableWorld->world, eventType, (hknpBodyId)m_serialAndIndex);
  method[0] = function;
  hkSignal::unsubscribeInternal(EventSignal, &result, NULL, method, 8);
}

/*
==============
HavokPhysics_UpdateBroadphase
==============
*/
void HavokPhysics_UpdateBroadphase(Physics_WorldId worldId, bool updateAll)
{
  hknpWorld *world; 
  unsigned __int8 v5; 
  hknpBroadPhase *UndecoratedBroadPhase; 
  int v7; 
  __int64 v8; 
  __int64 v9; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13109, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Update broadphase with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  v5 = 2;
  if ( updateAll )
    v5 = -1;
  world->m_broadPhase->update(world->m_broadPhase, v5);
  if ( Physics_IsQueryWorld(worldId) )
  {
    UndecoratedBroadPhase = hknpWorldUtil::getUndecoratedBroadPhase(world);
    if ( ((unsigned int (__fastcall *)(hknpBroadPhase *))UndecoratedBroadPhase->getType)(UndecoratedBroadPhase) == 2 )
    {
      v7 = 0;
      if ( UndecoratedBroadPhase[1].m_antilagBodies.m_storage.m_words.m_size > 0 )
      {
        v8 = 0i64;
        do
        {
          v9 = *(_QWORD *)&UndecoratedBroadPhase[1].m_antilagBodies.m_storage.m_words.m_data[v8];
          if ( v9 )
            *(_BYTE *)(v9 + 6620) = 0;
          ++v7;
          v8 += 2i64;
        }
        while ( v7 < UndecoratedBroadPhase[1].m_antilagBodies.m_storage.m_words.m_size );
      }
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13136, ASSERT_TYPE_ASSERT, "(false)", "%s\n\tUnexpected broadphase type!", "false") )
    {
      __debugbreak();
    }
  }
}

/*
==============
HavokPhysics_UpdateGravityScalar
==============
*/

void __fastcall HavokPhysics_UpdateGravityScalar(Physics_WorldId worldId, Physics_GravityType gravityType, double scalar)
{
  float v3; 
  HavokPhysicsWorld *MutableWorld; 
  unsigned int v6; 
  unsigned int m_size; 
  hknpWorld *world; 
  hknpMotionPropertiesId result; 
  hknpMotionProperties motionProperties; 

  v3 = *(float *)&scalar;
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5602, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", (const char *)&queryFormat, "havokPhysicsWorld->world") )
    __debugbreak();
  v6 = 0;
  m_size = s_havokPhysicsMotionPropertiesLibrary.list->m_motionPropertiesNameCRC32s.m_size;
  if ( m_size )
  {
    do
    {
      if ( (unsigned int)gravityType <= Physics_GravityType_Item )
      {
        HavokPhysics_GetMotionPropertiesIdForGravityPropertyIndex(&result, gravityType + 1, v6);
        world = MutableWorld->world;
        motionProperties = (hknpMotionProperties)world->m_motionPropertiesLibrary.m_ptr->m_motionProperties.m_objects.m_data[result.m_value];
        *(__m128 *)&scalar = _mm_shuffle_ps(*(__m128 *)&scalar, *(__m128 *)&scalar, 170);
        motionProperties.m_gravityFactor = *(float *)&scalar * v3;
        hknpMotionPropertiesLibrary::updateEntry(world->m_motionPropertiesLibrary.m_ptr, result, &motionProperties);
      }
      ++v6;
    }
    while ( v6 < m_size );
  }
}

/*
==============
HavokPhysics_UpdateLoosenedConstraint
==============
*/
char HavokPhysics_UpdateLoosenedConstraint(Physics_WorldId worldId, hkHandle<unsigned int,2147483647,hknpConstraintIdDiscriminant> constraintId, const hkTransformf *bodyATransform, const hkTransformf *bodyBTransform, PhysicsConstraintLooseningResult *result)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v9; 
  int v10; 

  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  v9 = *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getConstraint)(&MutableWorld->world->hknpWorldReader, constraintId.m_value) + 8);
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 13408, ASSERT_TYPE_ASSERT, "(constraintData)", (const char *)&queryFormat, "constraintData") )
    __debugbreak();
  *(_DWORD *)&result->coneChanged = 0;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24i64))(v9);
  if ( v10 == 2 )
  {
    HavokPhysics_LoosenHingeConstraint((hkpLimitedHingeConstraintData::Atoms *)(v9 + 32), bodyATransform, bodyBTransform, result);
  }
  else
  {
    if ( v10 != 7 )
      return 0;
    HavokPhysics_LoosenRagdollConstraint((hkpRagdollConstraintData::Atoms *)(v9 + 32), bodyATransform, bodyBTransform, result);
  }
  return 1;
}

/*
==============
HavokPhysics_UpdateWorld
==============
*/
void HavokPhysics_UpdateWorld(Physics_WorldId worldId, bool syncStats)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v4; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6403, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to lock world with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  HavokPhysicsInstanceManager_PropagateAddedFlags(&MutableWorld->instanceManager);
  if ( !MutableWorld->persistentStreamAllocator )
  {
    LODWORD(v4) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 6410, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->persistentStreamAllocator)", "%s\n\tHavokPhysics StepWorldEnd %i: persistent stream allocator is NULL", "havokPhysicsWorld->persistentStreamAllocator", v4) )
      __debugbreak();
  }
  MutableWorld->persistentStreamAllocator->getMemoryStatistics(MutableWorld->persistentStreamAllocator, &MutableWorld->persistentMemoryStats.m_allocatorStats);
}

/*
==============
HavokPhysics_ValidateWorld
==============
*/
void HavokPhysics_ValidateWorld(Physics_WorldId worldId)
{
  const HavokPhysicsWorld *ConstWorld; 
  Physics_WorldId v3; 

  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world )
  {
    v3 = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5320, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics ValidateWorld %i: world is NULL", "havokPhysicsWorld->world", v3) )
      __debugbreak();
  }
  EnterCriticalSection((LPCRITICAL_SECTION)&ConstWorld->critSection);
  hknpWorld::checkConsistency(ConstWorld->world);
  LeaveCriticalSection((LPCRITICAL_SECTION)&ConstWorld->critSection);
}

/*
==============
HavokPhysics_WarpDetailRigidBodyTo
==============
*/
__int64 HavokPhysics_WarpDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase)
{
  __int128 v5; 
  __int128 v7; 
  __int128 v8; 
  __int128 v9; 
  __int128 v10; 
  hknpWorld *world; 
  hknpWorldReader_vtbl *v19; 
  int v20; 
  const hkTransformf *v21; 
  __int64 v22; 
  __int64 v23; 
  __m128 m_quad; 
  __m128 v25; 
  __m128 v26; 
  __int64 v50; 
  float zero[4]; 
  hkQuaternionf qi; 
  __m128 v53[2]; 
  hkTransformf v54; 
  __int128 v55; 
  __int128 v56; 
  __int128 v57; 
  __int128 v58; 
  __int128 v59; 
  __int128 v60; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12109, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12110, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid body id for world %i", "bodyId.isValid()", v50) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v50) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12115, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics WarpRigidBodyTo %i: world is NULL", "world", v50) )
      __debugbreak();
  }
  _XMM5 = hkOrientation->m_vec.m_quad;
  __asm
  {
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
  }
  qi.m_vec.m_quad = _mm128_mul_ps(_mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM0, _XMM4), _XMM4)), _mm128_mul_ps(_XMM4, *(__m128 *)hkMath::hkSse_floatHalf)), hkOrientation->m_vec.m_quad);
  hkRotationImpl<float>::set(&v54.m_rotation, &qi);
  v54.m_translation = (hkVector4f)hkPosition->m_quad;
  v19 = world->hknpWorldReader::__vftable;
  v20 = 0;
  zero[0] = FLOAT_0_0000099999997;
  v21 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v19->getBodyTransform)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( !hkTransformf::isApproximatelyEqual(&v54, v21, zero) )
  {
    v60 = v5;
    v59 = _XMM7;
    v58 = v7;
    v57 = v8;
    v56 = v9;
    v55 = v10;
    v22 = (__int64)&world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF];
    hknpBody::setTransform((hknpBody *)v22, &v54);
    hknpBody::syncStaticMotionToBodyTransform((hknpBody *)v22);
    v23 = *(_QWORD *)(*(_QWORD *)(v22 + 152) + 8i64 * (*(_BYTE *)(v22 + 147) & 7));
    (*(void (__fastcall **)(__int64, __int64, __m128 *))(*(_QWORD *)v23 + 32i64))(v23, v22, v53);
    m_quad = world->m_intSpaceUtil.m_bitOffset24.m_quad;
    v25 = world->m_intSpaceUtil.m_bitScale24.m_quad;
    v26 = _mm128_mul_ps(g_vectorfConstants[21], world->m_solverInfo.m_collisionTolerance.m_real);
    _XMM1 = `hkIntVector::setConvertF32toS32'::`2'::two31;
    _XMM9 = _mm128_mul_ps(_mm128_add_ps(m_quad, _mm128_sub_ps(v53[0], v26)), v25);
    _XMM5.m_quad = (__m128i)world->m_intSpaceUtil.m_aabb24_16_24_iMax;
    _XMM10 = _mm128_mul_ps(_mm128_add_ps(m_quad, _mm128_add_ps(v26, v53[1])), v25);
    __asm
    {
      vcmpleps xmm4, xmm1, xmm9
      vcmpleps xmm8, xmm1, xmm10
      vcvttps2dq xmm0, xmm9
    }
    v20 = 1;
    __asm
    {
      vpxor   xmm1, xmm0, xmm4
      vpxor   xmm7, xmm7, xmm7
      vpmaxsd xmm2, xmm7, xmm1
      vpminsd xmm3, xmm5, xmm2
      vcvttps2dq xmm0, xmm10
      vpxor   xmm1, xmm0, xmm8
      vpmaxsd xmm2, xmm7, xmm1
      vpshufb xmm4, xmm3, xmm6
      vpminsd xmm3, xmm5, xmm2
      vpshufb xmm0, xmm3, xmm6
      vblendps xmm1, xmm0, xmm4, 3
    }
    *(_OWORD *)(v22 + 80) = _XMM1;
    _XMM1 = _mm128_mul_ps(v26, world->m_solverInfo.m_distanceToLinearTim.m_real);
    __asm
    {
      vmaxps  xmm2, xmm1, xmm0
      vminps  xmm2, xmm2, cs:__xmm@477fff00477fff00477fff00477fff00
      vcvttps2dq xmm0, xmm2
    }
    *(_WORD *)(v22 + 124) = _XMM0;
    *(_WORD *)(v22 + 126) = _XMM0;
  }
  if ( updateBroadphase )
    world->updateBroadPhase(&world->hknpWorldWriter);
  return (unsigned int)(2 * v20);
}

/*
==============
HavokPhysics_WarpInstanceTo
==============
*/
__int64 HavokPhysics_WarpInstanceTo(Physics_WorldId worldId, unsigned int instanceId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphaseIfNecessary)
{
  __int128 v5; 
  __int64 v9; 
  hknpWorld *world; 
  unsigned __int8 v11; 
  unsigned int v12; 
  int NumRigidBodys; 
  __int64 v14; 
  hknpWorldReader *v15; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  unsigned int m_serialAndIndex; 
  hkTransformf *v19; 
  hkTransformf *p_r; 
  hknpWorld *v21; 
  __int64 activate; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  hknpBodyId result; 
  float zero; 
  __int64 v29; 
  hkQuaternionf hkOrientationa; 
  hkTransformf r; 
  hkTransformf aTb; 
  hkTransformf bTc; 
  hkTransformf v34; 
  __int128 v35; 

  v9 = instanceId;
  if ( instanceId == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12198, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Warp Instance with invalid instance id for world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", worldId) )
    __debugbreak();
  world = HavokPhysics_GetConstWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v24) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12203, ASSERT_TYPE_ASSERT, "(hkWorld)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "hkWorld", v24) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&r.m_rotation, hkOrientation);
  r.m_translation = (hkVector4f)hkPosition->m_quad;
  if ( !hkTransformf::isOk(&r) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12207, ASSERT_TYPE_ASSERT, "(body0NewTransform.isOk())", (const char *)&queryFormat, "body0NewTransform.isOk()") )
    __debugbreak();
  v11 = 0;
  v12 = 0;
  NumRigidBodys = HavokPhysics_GetNumRigidBodys(worldId, v9);
  if ( NumRigidBodys > 0 )
  {
    v14 = 80 * v9;
    v15 = &world->hknpWorldReader;
    v35 = v5;
    v29 = 80 * v9;
    do
    {
      if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
      {
        LODWORD(v24) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 161, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v24) )
          __debugbreak();
      }
      if ( (_DWORD)v9 == -1 )
      {
        LODWORD(v24) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 162, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid index in world %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v24) )
          __debugbreak();
      }
      ConstWorld = HavokPhysics_GetConstWorld(worldId);
      if ( !ConstWorld->world )
      {
        LODWORD(v24) = worldId;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 166, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics Get rigid Body Id %i: world is NULL", "havokPhysicsWorld->world", v24) )
          __debugbreak();
      }
      p_instanceManager = &ConstWorld->instanceManager;
      if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 21, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
        __debugbreak();
      if ( (_DWORD)v9 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 22, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
        __debugbreak();
      if ( v12 >= *(int *)((char *)&p_instanceManager->buffer->bodies.m_size + v14) )
      {
        LODWORD(v25) = worldId;
        LODWORD(v24) = v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 167, ASSERT_TYPE_ASSERT, "(bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId ))", "%s\n\tHavok Physics: Trying to Get Rigid Body ID with invalid body index %i in world %i", "bodyIdx < HavokPhysicsInstanceManager_GetBodyCount( &havokPhysicsWorld->instanceManager, instanceId )", v24, v25) )
          __debugbreak();
      }
      HavokPhysicsInstanceManager_GetBodyId(&result, p_instanceManager, v9, v12);
      m_serialAndIndex = result.m_serialAndIndex;
      if ( (result.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
      {
        LODWORD(v26) = worldId;
        LODWORD(v25) = v9;
        LODWORD(v24) = v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12219, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Instance with invalid body id for body %i in instance %i world %i", "bodyId.isValid()", v24, v25, v26) )
          __debugbreak();
      }
      v19 = (hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v15->getBodyTransform)(v15, m_serialAndIndex);
      if ( !hkTransformf::isOk(v19) )
      {
        LODWORD(activate) = v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12223, ASSERT_TYPE_ASSERT, "( ( bodyOldTransform.isOk() ) )", "( bodyIt ) = %i", activate) )
          __debugbreak();
      }
      if ( v12 )
      {
        hkTransformf::setMul(&bTc, &aTb, v19);
        hkTransformf::setMul(&v34, &r, &bTc);
        p_r = &v34;
      }
      else
      {
        zero = FLOAT_0_001;
        if ( hkTransformf::isApproximatelyEqual(v19, &r, &zero) )
          break;
        hkTransformf::setInverse(&aTb, v19);
        p_r = &r;
      }
      hkQuaternionf::setAndNormalize(&hkOrientationa, &p_r->m_rotation);
      if ( HavokPhysics_WarpRigidBodyTo(worldId, (const hknpBodyId)m_serialAndIndex, &p_r->m_translation, &hkOrientationa, 0, 1) && ((unsigned int (__fastcall *)(hknpWorldReader *, _QWORD))v15->isBodyAdded)(v15, m_serialAndIndex) )
        v11 = 1;
      v14 = v29;
      ++v12;
    }
    while ( (int)v12 < NumRigidBodys );
  }
  if ( updateBroadphaseIfNecessary && v11 )
  {
    v21 = HavokPhysics_GetMutableWorld(worldId)->world;
    Sys_ProfBeginNamedEvent(0xFF6A5ACD, "HavokPhysics_WarpInstanceTo broadphase update");
    v21->updateBroadPhase(&v21->hknpWorldWriter);
    Sys_ProfEndNamedEvent();
  }
  return v11;
}

/*
==============
HavokPhysics_WarpLeafDetailRigidBodyTo
==============
*/
__int64 HavokPhysics_WarpLeafDetailRigidBodyTo(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkPosition, const hkQuaternionf *hkOrientation, bool updateBroadphase)
{
  hknpWorld *world; 
  hknpWorldReader_vtbl *v13; 
  int v14; 
  const hkTransformf *v15; 
  __int64 v17; 
  float zero[4]; 
  hkQuaternionf qi; 
  hkTransformf v20; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12158, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v17) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12159, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Rigid Body with invalid body id for world %i", "bodyId.isValid()", v17) )
      __debugbreak();
  }
  world = HavokPhysics_GetMutableWorld(worldId)->world;
  if ( !world )
  {
    LODWORD(v17) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12164, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics WarpRigidBodyTo %i: world is NULL", "world", v17) )
      __debugbreak();
  }
  _XMM5 = hkOrientation->m_vec.m_quad;
  __asm
  {
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
  }
  qi.m_vec.m_quad = _mm128_mul_ps(_mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM0, _XMM4), _XMM4)), _mm128_mul_ps(_XMM4, *(__m128 *)hkMath::hkSse_floatHalf)), hkOrientation->m_vec.m_quad);
  hkRotationImpl<float>::set(&v20.m_rotation, &qi);
  v20.m_translation = (hkVector4f)hkPosition->m_quad;
  v13 = world->hknpWorldReader::__vftable;
  v14 = 0;
  zero[0] = FLOAT_0_0000099999997;
  v15 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v13->getBodyTransform)(&world->hknpWorldReader, bodyId.m_serialAndIndex);
  if ( !hkTransformf::isApproximatelyEqual(&v20, v15, zero) )
  {
    hknpBody::setTransform(&world->m_bodyManager.m_bodies.m_objects.m_data[bodyId.m_serialAndIndex & 0xFFFFFF].m_pod, &v20);
    v14 = 1;
  }
  if ( updateBroadphase )
    world->updateBroadPhase(&world->hknpWorldWriter);
  return (unsigned int)(2 * v14);
}

/*
==============
HavokPhysics_WarpRigidBodyToRelative
==============
*/
void HavokPhysics_WarpRigidBodyToRelative(Physics_WorldId worldId, hknpBodyId bodyId, const hkVector4f *hkStartPosition, const hkQuaternionf *hkStartOrientation, const hkVector4f *hkEndPosition, const hkQuaternionf *hkEndOrientation)
{
  HavokPhysicsWorld *MutableWorld; 
  __int64 v14; 
  hkQuaternionf hkOrientation; 
  hkTransformf v16; 
  hkTransformf bTc; 
  hkTransformf v18; 
  hkTransformf v19; 
  hkTransformf aTb; 
  hkTransformf v21; 

  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12763, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Warp Rigid Body relative with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (bodyId.m_serialAndIndex & 0xFFFFFF) == 0xFFFFFF )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12764, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Warp Rigid Body relative with invalid body id for world %i", "bodyId.isValid()", v14) )
      __debugbreak();
  }
  MutableWorld = HavokPhysics_GetMutableWorld(worldId);
  if ( !MutableWorld->world )
  {
    LODWORD(v14) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 12769, ASSERT_TYPE_ASSERT, "(havokPhysicsWorld->world)", "%s\n\tHavokPhysics WarpRigidBodyTo %i: world is NULL", "havokPhysicsWorld->world", v14) )
      __debugbreak();
  }
  hkRotationImpl<float>::set(&v16.m_rotation, hkStartOrientation);
  v16.m_translation = (hkVector4f)hkStartPosition->m_quad;
  hkTransformf::setInverse(&aTb, &v16);
  hkRotationImpl<float>::set(&v18.m_rotation, hkEndOrientation);
  v18.m_translation = (hkVector4f)hkEndPosition->m_quad;
  bTc = *(hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))MutableWorld->world->getBodyTransform)(&MutableWorld->world->hknpWorldReader, bodyId.m_serialAndIndex);
  hkTransformf::setMul(&v21, &aTb, &bTc);
  hkTransformf::setMul(&v19, &v18, &v21);
  hkQuaternionf::set(&hkOrientation, &v19.m_rotation);
  _XMM5 = hkOrientation.m_vec.m_quad;
  __asm
  {
    vdpps   xmm0, xmm5, xmm5, 0FFh
    vrsqrtps xmm4, xmm0
  }
  hkOrientation.m_vec.m_quad = _mm128_mul_ps(_mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM0, _XMM4), _XMM4)), _mm128_mul_ps(_XMM4, *(__m128 *)hkMath::hkSse_floatHalf)), hkOrientation.m_vec.m_quad);
  HavokPhysics_WarpRigidBodyTo(worldId, bodyId, &v19.m_translation, &hkOrientation, 0, 1);
}

/*
==============
HavokPhysics_Write
==============
*/
void HavokPhysics_Write(MemoryFile *memFile)
{
  if ( !g_havokPhysicsWorlds[0].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5193, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld main is NULL", "world->world") )
    __debugbreak();
  HavokPhysicsInstanceManager_Write(memFile, &g_havokPhysicsWorlds[0].instanceManager);
  HavokPhysics_WriteSnapshot(memFile, PHYSICS_WORLD_ID_FIRST);
  if ( !g_havokPhysicsWorlds[1].world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 5203, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld detail is NULL", "world->world") )
    __debugbreak();
  HavokPhysicsInstanceManager_Write(memFile, &g_havokPhysicsWorlds[1].instanceManager);
  HavokPhysics_WriteSnapshot(memFile, PHYSICS_WORLD_ID_SERVER_DETAIL);
}

/*
==============
HavokPhysics_WriteConstraints
==============
*/
void HavokPhysics_WriteConstraints(MemoryFile *memFile, Physics_WorldId worldId)
{
  const HavokPhysicsWorld *ConstWorld; 
  int v4; 
  hknpWorld *world; 
  int v6; 
  unsigned int v7; 
  hknpConstraintManager *m_constraintManager; 
  hknpThreadSafeObjectPoolElement<hknpConstraint> *m_data; 
  unsigned int v10; 
  unsigned __int64 m_userData; 
  int p; 

  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  if ( !ConstWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4892, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld main is NULL", "world->world") )
    __debugbreak();
  p = ConstWorld->world->getNumConstraints(&ConstWorld->world->hknpWorldReader);
  v4 = p;
  MemFile_WriteData(memFile, 4ui64, &p);
  world = ConstWorld->world;
  v6 = 0;
  v7 = 0;
  m_constraintManager = world->m_constraintManager;
  m_data = m_constraintManager->m_constraints.m_objects.m_data;
  v10 = m_constraintManager->m_constraints.m_peakIndex + 1;
  if ( m_constraintManager->m_constraints.m_numAllocated )
  {
    if ( m_data->m_pod.m_id.m_value != 0x7FFFFFFF )
      goto LABEL_15;
    v7 = 1;
    if ( v10 > 1 )
    {
      while ( m_data[v7].m_pod.m_id.m_value == 0x7FFFFFFF )
      {
        if ( ++v7 >= v10 )
          goto LABEL_16;
      }
      if ( v7 != -1 )
      {
LABEL_15:
        do
        {
          m_userData = m_data[v7].m_pod.m_userData;
          p = m_data[v7].m_pod.m_id.m_value;
          MemFile_WriteData(memFile, 4ui64, &p);
          p = m_userData;
          MemFile_WriteData(memFile, 4ui64, &p);
          p = HIDWORD(m_userData);
          MemFile_WriteData(memFile, 4ui64, &p);
          ++v6;
          if ( ++v7 >= v10 )
            break;
          while ( m_data[v7].m_pod.m_id.m_value == 0x7FFFFFFF )
          {
            if ( ++v7 >= v10 )
              goto LABEL_16;
          }
        }
        while ( v7 != -1 );
      }
    }
  }
LABEL_16:
  if ( v4 != v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4910, ASSERT_TYPE_ASSERT, "(numConstraints == numWrittenConstraints)", (const char *)&queryFormat, "numConstraints == numWrittenConstraints") )
    __debugbreak();
}

/*
==============
HavokPhysics_WriteInstance
==============
*/
void HavokPhysics_WriteInstance(MemoryFile *memFile, Physics_WorldId worldId, unsigned int instanceId)
{
  __int64 v3; 
  const HavokPhysicsWorld *ConstWorld; 
  const HavokPhysicsInstanceManager *p_instanceManager; 
  const PhysicsAsset *PhysicsAsset; 
  const PhysicsAsset *PhysicsAssetAddendum; 
  const char *name; 
  const char *v11; 
  const XModel *DetailModel; 
  const char *v13; 
  const XModel *XModel; 
  const char *v15; 
  __int64 v16; 
  HavokPhysicsInstance *buffer; 
  int m_size; 
  int v19; 
  __int64 v20; 
  hknpBodyId v21; 
  __int64 v22; 
  __int64 v23; 
  hknpShape *v24; 
  hknpShape *m_ptr; 
  unsigned int v26; 
  float v27; 
  float v28; 
  __int64 v29; 
  __int64 v30; 
  hkRefCountedProperties *v31; 
  hkReferencedObject *v32; 
  int MapEntsShapeCount; 
  __int64 v34; 
  __int64 v35; 
  int v36; 
  int v37; 
  __int64 v38; 
  unsigned __int16 v39; 
  int v40; 
  __int64 v41; 
  int v42; 
  unsigned int v43; 
  float v44; 
  float v45; 
  float v46; 
  float v47; 
  int v48; 
  int v49; 
  hkPointerMap<hknpShape const *,float,hkContainerHeapAllocator> *capsuleRadii; 
  int m_hashMod; 
  unsigned __int32 v52; 
  unsigned __int32 v53; 
  unsigned int v54; 
  signed int v55; 
  hkMapBase<unsigned __int64,unsigned __int64,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int64 key; 
  float v58; 
  __int64 v59; 
  float v60; 
  float v61; 
  Physics_WorldId v62; 
  int v63; 
  Physics_RefSystem RefSystem; 
  unsigned __int8 RefSubSystem; 
  bool v66; 
  Physics_WorldId v67; 
  Physics_WorldId v68; 
  int Ref; 
  int v70; 
  HavokPhysicsInstance *v71; 
  __int64 v72; 
  __int64 v73; 
  __int64 v74; 
  __int64 v75; 
  __int64 v76; 
  __int64 v77; 
  unsigned int m_serialAndIndex; 
  char v79[8]; 
  char v80[8]; 
  int p; 
  Physics_WorldId worldIda; 
  int v83; 
  const HavokPhysicsAsset *v84; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  const HavokPhysicsWorld *v86; 
  int v87; 
  hknpBodyId *m_data; 
  __int64 v89; 
  const XModel *v90; 
  HavokPhysicsInstanceManager *v91; 
  __int64 v92; 
  __int64 v93; 
  int v94; 
  int v95; 
  __int64 v96; 
  __int128 v97; 
  __int128 v98; 

  v96 = -2i64;
  v3 = instanceId;
  worldIda = worldId;
  v93 = 0i64;
  v94 = 0;
  v95 = 0x80000000;
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4219, ASSERT_TYPE_ASSERT, "(memFile)", "%s\n\tHavokPhysics: WriteInstance has NULL memfile", "memFile") )
    __debugbreak();
  if ( (unsigned int)worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4220, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to WriteInstance with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", worldId) )
    __debugbreak();
  if ( (_DWORD)v3 == -1 )
  {
    LODWORD(v77) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4221, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", "%s\n\tHavokPhysics: Trying to WriteInstance with invalid instance id %i", "instanceId != HAVOKPHYSICSINSTANCEID_INVALID", v77) )
      __debugbreak();
  }
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v86 = ConstWorld;
  if ( !ConstWorld->world )
  {
    LODWORD(v77) = worldId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4225, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics WriteInstance %i: world is NULL", "physicsWorld->world", v77) )
      __debugbreak();
  }
  p_instanceManager = &ConstWorld->instanceManager;
  v91 = &ConstWorld->instanceManager;
  PhysicsAsset = HavokPhysicsInstanceManager_GetPhysicsAsset(&ConstWorld->instanceManager, v3);
  PhysicsAssetAddendum = HavokPhysicsInstanceManager_GetPhysicsAssetAddendum(p_instanceManager, v3);
  if ( PhysicsAsset )
    name = PhysicsAsset->name;
  else
    name = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, name);
  if ( PhysicsAssetAddendum )
    v11 = PhysicsAssetAddendum->name;
  else
    v11 = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, v11);
  if ( PhysicsAsset )
    HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(PhysicsAsset);
  else
    HavokPhysicsAsset = NULL;
  if ( PhysicsAssetAddendum )
    v84 = HavokPhysics_GetHavokPhysicsAsset(PhysicsAssetAddendum);
  else
    v84 = NULL;
  DetailModel = HavokPhysicsInstanceManager_GetDetailModel(p_instanceManager, v3);
  v90 = DetailModel;
  if ( DetailModel )
    v13 = DetailModel->name;
  else
    v13 = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, v13);
  XModel = HavokPhysicsInstanceManager_GetXModel(p_instanceManager, v3);
  if ( XModel )
    v15 = XModel->name;
  else
    v15 = (char *)&queryFormat.fmt + 3;
  MemFile_WriteCString(memFile, v15);
  HavokPhysicsInstanceManager_Write(memFile, p_instanceManager, v3);
  if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 36, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 37, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  v16 = 80 * v3;
  v92 = 80 * v3;
  buffer = p_instanceManager->buffer;
  m_data = p_instanceManager->buffer[v3].bodies.m_data;
  m_size = buffer[v3].bodies.m_size;
  v83 = m_size;
  p = m_size;
  MemFile_WriteData(memFile, 4ui64, &p);
  v19 = 0;
  p = 0;
  if ( m_size > 0 )
  {
    v20 = 0i64;
    *(_QWORD *)&v97 = 0i64;
    while ( 1 )
    {
      m_serialAndIndex = m_data[v20].m_serialAndIndex;
      v21.m_serialAndIndex = m_serialAndIndex;
      MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
      v22 = (__int64)v86;
      v89 = *(_QWORD *)(((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))v86->world->getBody)(&v86->world->hknpWorldReader, v21.m_serialAndIndex) + 160);
      MemFile_WriteData(memFile, 8ui64, &v89);
      MemFile_WriteCString(memFile, (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v22 + 24) + 192i64) + 8i64 * (v21.m_serialAndIndex & 0xFFFFFF)) & 0xFFFFFFFFFFFFFFFEui64));
      v23 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(*(_QWORD *)(v22 + 24) + 32i64) + 104i64))(*(_QWORD *)(v22 + 24) + 32i64, v21.m_serialAndIndex) + 96);
      v24 = NULL;
      if ( HavokPhysicsAsset )
        break;
      if ( v90 )
      {
        if ( v19 != v83 - 1 || v83 <= 1 )
          goto LABEL_168;
        if ( *(_BYTE *)(v23 + 26) != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4398, ASSERT_TYPE_ASSERT, "( bodyShape->getType() == hknpShapeType::SPHERE )", (const char *)&queryFormat, "bodyShape->getType() == hknpShapeType::SPHERE") )
          __debugbreak();
        v44 = *(float *)(v23 + 32);
        v97 = *(_OWORD *)(*(unsigned __int16 *)(v23 + 60) + v23 + 58);
        *(float *)&m_serialAndIndex = v44;
        if ( (LODWORD(v44) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4402, ASSERT_TYPE_SANITY, "( !IS_NAN( radius ) )", (const char *)&queryFormat, "!IS_NAN( radius )") )
          __debugbreak();
        v45 = *(float *)&v97;
        m_serialAndIndex = v97;
        if ( (v97 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4403, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 0 ) )") )
          __debugbreak();
        v46 = *((float *)&v97 + 1);
        m_serialAndIndex = DWORD1(v97);
        if ( (DWORD1(v97) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4404, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 1 ) )") )
          __debugbreak();
        v47 = *((float *)&v97 + 2);
        m_serialAndIndex = DWORD2(v97);
        if ( (DWORD2(v97) & 0x7F800000) == 2139095040 )
        {
          v48 = 4405;
LABEL_119:
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", v48, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 2 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 2 ) )") )
            __debugbreak();
        }
      }
      else
      {
        v49 = *(unsigned __int8 *)(v23 + 26);
        m_serialAndIndex = v49;
        MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
        switch ( v49 )
        {
          case 1:
            v67 = worldIda;
            if ( G_PhysicsCoverWall_InstanceIdIsCoverWallPlayerClip(worldIda, v3, NULL) )
            {
              *(float *)&m_serialAndIndex = 0.0;
              MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
              PhysicsCoverWall_WriteShapeData_PlayerClip(memFile, v67, v3);
              goto LABEL_168;
            }
            v66 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4492, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_WriteInstance: Unsupported CONVEX shape");
            goto LABEL_166;
          case 2:
            v44 = *(float *)(v23 + 32);
            v97 = *(_OWORD *)(*(unsigned __int16 *)(v23 + 60) + v23 + 58);
            *(float *)&m_serialAndIndex = v44;
            if ( (LODWORD(v44) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4424, ASSERT_TYPE_SANITY, "( !IS_NAN( radius ) )", (const char *)&queryFormat, "!IS_NAN( radius )") )
              __debugbreak();
            v45 = *(float *)&v97;
            m_serialAndIndex = v97;
            if ( (v97 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4425, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 0 ) )") )
              __debugbreak();
            v46 = *((float *)&v97 + 1);
            m_serialAndIndex = DWORD1(v97);
            if ( (DWORD1(v97) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4426, ASSERT_TYPE_SANITY, "( !IS_NAN( center( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( center( 1 ) )") )
              __debugbreak();
            v47 = *((float *)&v97 + 2);
            m_serialAndIndex = DWORD2(v97);
            if ( (DWORD2(v97) & 0x7F800000) != 2139095040 )
              goto LABEL_121;
            v48 = 4427;
            goto LABEL_119;
          case 3:
            capsuleRadii = v86->capsuleRadii;
            m_hashMod = capsuleRadii->m_map.m_hashMod;
            if ( m_hashMod <= 0 )
              goto LABEL_126;
            v52 = _byteswap_ulong(-1640531535 * v23);
            v53 = _byteswap_ulong(-1640531535 * HIDWORD(v23));
            v54 = m_hashMod & (v53 ^ ((v52 >> 2) + v52 + (v53 << 6) - 1640531527));
            v55 = v54;
            m_elem = capsuleRadii->m_map.m_elem;
            key = capsuleRadii->m_map.m_elem[v54].key;
            if ( key == -1i64 )
              goto LABEL_126;
            break;
          case 9:
            v68 = worldIda;
            Ref = HavokPhysics_GetRef(worldIda, v21);
            if ( Physics_GetRefSystem(Ref) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4500, ASSERT_TYPE_ASSERT, "(Physics_GetRefSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_RefSystem_WorldGeo)", (const char *)&queryFormat, "Physics_GetRefSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_RefSystem_WorldGeo") )
              __debugbreak();
            v70 = HavokPhysics_GetRef(v68, v21);
            if ( !Physics_GetRefSubSystem(v70) )
              goto LABEL_168;
            v66 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4501, ASSERT_TYPE_ASSERT, "(Physics_GetRefSubSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_WorldGeometrySubSystem_WorldGeo)", (const char *)&queryFormat, "Physics_GetRefSubSystem( HavokPhysics_GetRef( worldId, bodyId ) ) == Physics_WorldGeometrySubSystem_WorldGeo");
            goto LABEL_166;
          case 12:
          case 22:
            v62 = worldIda;
            v63 = HavokPhysics_GetRef(worldIda, v21);
            RefSystem = Physics_GetRefSystem(v63);
            RefSubSystem = Physics_GetRefSubSystem(v63);
            if ( RefSystem )
              goto LABEL_154;
            if ( RefSubSystem == 1 )
            {
              *(float *)&m_serialAndIndex = 0.0;
              goto LABEL_89;
            }
            if ( RefSubSystem == 2 )
            {
              m_serialAndIndex = 2;
              goto LABEL_89;
            }
LABEL_154:
            if ( G_PhysicsCoverWall_InstanceIdIsCoverWall(v62, v3, NULL) )
            {
              m_serialAndIndex = 1;
              MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
              PhysicsCoverWall_WriteShapeData(memFile, v62, v3);
            }
            else
            {
              v66 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4479, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_WriteInstance: Unsupported COMPOUND/USER_0 shape");
LABEL_166:
              if ( v66 )
                __debugbreak();
            }
            goto LABEL_168;
          default:
            v66 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4506, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "HavokPhysics_WriteInstance: Unsupported shape");
            goto LABEL_166;
        }
        while ( key != v23 )
        {
          v54 = m_hashMod & (v54 + 1);
          v55 = v54;
          key = m_elem[v54].key;
          if ( key == -1i64 )
          {
LABEL_126:
            v55 = m_hashMod + 1;
            m_elem = capsuleRadii->m_map.m_elem;
            break;
          }
        }
        m_serialAndIndex = m_elem[v55].val;
        v58 = *(float *)&m_serialAndIndex;
        v59 = *(unsigned __int16 *)(v23 + 60);
        v97 = *(_OWORD *)(v59 + v23 + 58);
        v98 = *(_OWORD *)(v59 + v23 + 74);
        if ( (m_serialAndIndex & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4441, ASSERT_TYPE_SANITY, "( !IS_NAN( radius ) )", (const char *)&queryFormat, "!IS_NAN( radius )") )
          __debugbreak();
        v60 = *(float *)&v97;
        m_serialAndIndex = v97;
        if ( (v97 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4442, ASSERT_TYPE_SANITY, "( !IS_NAN( a( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( a( 0 ) )") )
          __debugbreak();
        v61 = *((float *)&v97 + 1);
        m_serialAndIndex = DWORD1(v97);
        if ( (DWORD1(v97) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4443, ASSERT_TYPE_SANITY, "( !IS_NAN( a( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( a( 1 ) )") )
          __debugbreak();
        v44 = *((float *)&v97 + 2);
        m_serialAndIndex = DWORD2(v97);
        if ( (DWORD2(v97) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4444, ASSERT_TYPE_SANITY, "( !IS_NAN( a( 2 ) ) )", (const char *)&queryFormat, "!IS_NAN( a( 2 ) )") )
          __debugbreak();
        v45 = *(float *)&v98;
        m_serialAndIndex = v98;
        if ( (v98 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4445, ASSERT_TYPE_SANITY, "( !IS_NAN( b( 0 ) ) )", (const char *)&queryFormat, "!IS_NAN( b( 0 ) )") )
          __debugbreak();
        v46 = *((float *)&v98 + 1);
        m_serialAndIndex = DWORD1(v98);
        if ( (DWORD1(v98) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4446, ASSERT_TYPE_SANITY, "( !IS_NAN( b( 1 ) ) )", (const char *)&queryFormat, "!IS_NAN( b( 1 ) )") )
          __debugbreak();
        v47 = *((float *)&v98 + 2);
        m_serialAndIndex = DWORD2(v98);
        if ( (DWORD2(v98) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4447, ASSERT_TYPE_SANITY, "( !IS_NAN( b( 2 ) ) )", (const char *)&queryFormat, "!IS_NAN( b( 2 ) )") )
          __debugbreak();
        MemFile_WriteFloat(memFile, v58);
        MemFile_WriteFloat(memFile, v60);
        MemFile_WriteFloat(memFile, v61);
      }
LABEL_121:
      MemFile_WriteFloat(memFile, v44);
      MemFile_WriteFloat(memFile, v45);
      MemFile_WriteFloat(memFile, v46);
      MemFile_WriteFloat(memFile, v47);
LABEL_168:
      ++p;
      *(_QWORD *)&v97 = ++v20;
      v19 = p;
      if ( v20 >= v83 )
      {
        p_instanceManager = v91;
        v16 = v92;
        goto LABEL_170;
      }
    }
    m_ptr = (hknpShape *)HavokPhysicsAsset->m_physicsSystemData->m_bodyCinfos.m_data[v20].m_shape.m_ptr;
    *(float *)&v26 = NAN;
    v27 = 0.0;
    v28 = 0.0;
    v29 = 0i64;
    if ( !(_QWORD)v97 && v84 )
    {
      v30 = *(_QWORD *)(v23 + 72);
      v23 = *(_QWORD *)(v30 + 80);
      v24 = *(hknpShape **)(v30 + 192);
    }
    if ( (hknpShape *)v23 != m_ptr )
    {
      if ( *(_BYTE *)(v23 + 26) == 2 )
      {
        v27 = *(float *)(v23 + 32);
      }
      else
      {
        v31 = *(hkRefCountedProperties **)(v23 + 48);
        if ( v31 && (v32 = hkRefCountedProperties::accessProperty(v31, 1u)) != NULL )
        {
          v27 = *(float *)&v32[1].__vftable;
          v28 = *((float *)&v32[1].__vftable + 1);
        }
        else if ( m_ptr->m_type.m_storage == 12 && m_ptr->getMutationSignals(m_ptr) )
        {
          if ( *(_BYTE *)(v23 + 26) != 18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4304, ASSERT_TYPE_ASSERT, "(bodyShape->getType() == hknpShapeType::MASKED)", (const char *)&queryFormat, "bodyShape->getType() == hknpShapeType::MASKED") )
            __debugbreak();
          v29 = v23;
        }
        else
        {
          MapEntsShapeCount = WorldCollision_GetMapEntsShapeCount();
          *(float *)&v26 = 0.0;
          if ( MapEntsShapeCount > 0 )
          {
            do
            {
              if ( WorldCollision_GetMapEntsShape(v26) == (hknpShape *)v23 )
                break;
              ++v26;
            }
            while ( (int)v26 < MapEntsShapeCount );
          }
          if ( v26 >= MapEntsShapeCount )
          {
            LODWORD(v77) = MapEntsShapeCount;
            LODWORD(v76) = v26;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4320, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( numShapes )", "shapeIdx doesn't index numShapes\n\t%i not in [0, %i)", v76, v77) )
              __debugbreak();
          }
        }
      }
    }
    v79[0] = v29 != 0;
    MemFile_WriteData(memFile, 1ui64, v79);
    if ( v29 )
    {
      v34 = *(_QWORD *)(v29 + 64);
      v35 = *(_QWORD *)(v29 + 56);
      if ( *(_BYTE *)(v35 + 26) != 12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4337, ASSERT_TYPE_ASSERT, "(coreShape->getType() == hknpShapeType::COMPOUND)", (const char *)&queryFormat, "coreShape->getType() == hknpShapeType::COMPOUND") )
        __debugbreak();
      v36 = *(_DWORD *)(v35 + 80);
      v37 = 0;
      v87 = 0;
      if ( v36 > 0 )
      {
        v38 = *(_QWORD *)(v35 + 72);
        while ( 1 )
        {
          v39 = v87;
          if ( !*(_BYTE *)(112i64 * (unsigned __int16)v87 + v38 + 92) )
            break;
          v87 = ++v37;
          if ( v37 >= v36 )
            goto LABEL_77;
        }
        while ( v37 != -1 )
        {
          v80[0] = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v34 + 32i64))(v34, (0xFFFFFFFF >> *(_BYTE *)(v35 + 27)) | (v39 << (32 - *(_BYTE *)(v35 + 27))));
          MemFile_WriteData(memFile, 1ui64, v80);
          v40 = *(_DWORD *)(v35 + 80);
          v87 = ++v37;
          if ( v37 >= v40 )
            break;
          v41 = *(_QWORD *)(v35 + 72);
          while ( 1 )
          {
            v39 = v87;
            if ( !*(_BYTE *)(112i64 * (unsigned __int16)v87 + v41 + 92) )
              break;
            v87 = ++v37;
            if ( v37 >= v40 )
              goto LABEL_77;
          }
        }
      }
    }
    else
    {
      m_serialAndIndex = v26;
      MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
      MemFile_WriteFloat(memFile, v27);
      MemFile_WriteFloat(memFile, v28);
    }
LABEL_77:
    v20 = v97;
    if ( (_QWORD)v97 || !v84 )
    {
      *(float *)&m_serialAndIndex = NAN;
      goto LABEL_89;
    }
    if ( v24 == v84->m_physicsSystemData->m_bodyCinfos.m_data->m_shape.m_ptr )
    {
      *(float *)&v43 = NAN;
    }
    else
    {
      v42 = WorldCollision_GetMapEntsShapeCount();
      *(float *)&v43 = 0.0;
      if ( v42 > 0 )
      {
        do
        {
          if ( WorldCollision_GetMapEntsShape(v43) == v24 )
            break;
          ++v43;
        }
        while ( (int)v43 < v42 );
      }
      if ( v43 >= v42 )
      {
        LODWORD(v77) = v42;
        LODWORD(v76) = v43;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4377, ASSERT_TYPE_ASSERT, "(unsigned)( shapeIdx ) < (unsigned)( numShapes )", "shapeIdx doesn't index numShapes\n\t%i not in [0, %i)", v76, v77) )
        {
          __debugbreak();
          m_serialAndIndex = v43;
LABEL_89:
          MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
          goto LABEL_168;
        }
      }
    }
    m_serialAndIndex = v43;
    goto LABEL_89;
  }
LABEL_170:
  if ( !p_instanceManager && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 79, ASSERT_TYPE_ASSERT, "(manager)", (const char *)&queryFormat, "manager") )
    __debugbreak();
  if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsinstancemanager.inl", 80, ASSERT_TYPE_ASSERT, "(instanceId != 0xFFFFFFFF)", (const char *)&queryFormat, "instanceId != HAVOKPHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  v71 = p_instanceManager->buffer;
  v72 = *(__int64 *)((char *)&p_instanceManager->buffer->constraints.m_data + v16);
  v73 = *(int *)((char *)&v71->constraints.m_size + v16);
  m_serialAndIndex = v73;
  MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
  v74 = v73;
  if ( (int)v73 > 0 )
  {
    v75 = 0i64;
    do
    {
      m_serialAndIndex = *(unsigned int *)(v72 + 4 * v75);
      MemFile_WriteData(memFile, 4ui64, &m_serialAndIndex);
      ++v75;
    }
    while ( v75 < v74 );
  }
  hkMemHeapAllocator();
}

/*
==============
HavokPhysics_WriteSnapshot
==============
*/
void HavokPhysics_WriteSnapshot(MemoryFile *memFile, Physics_WorldId worldId)
{
  Physics_WorldId v2; 
  const HavokPhysicsWorld *ConstWorld; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  char v8; 
  const char *WorldTransientName; 
  bool IsGameSystemTransientLoaded; 
  int v11; 
  unsigned int i; 
  __int64 v13; 
  hkMemoryAllocator *v14; 
  __int64 v15; 
  hkArray<char,hkContainerHeapAllocator> buf; 
  hkOstream v17; 
  bool p; 
  Physics_WorldId numAllocatedInstances; 
  unsigned int WorldTransientCount; 
  const HavokPhysicsWorld *v21; 

  numAllocatedInstances = worldId;
  v2 = worldId;
  buf.m_data = NULL;
  buf.m_size = 0;
  buf.m_capacityAndFlags = 0x80000000;
  ConstWorld = HavokPhysics_GetConstWorld(worldId);
  v21 = ConstWorld;
  if ( !ConstWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4961, ASSERT_TYPE_ASSERT, "(world->world)", "%s\n\tHavokPhysics: Write serverworld main is NULL", "world->world") )
    __debugbreak();
  hknpWorld::checkConsistency(ConstWorld->world);
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "HavokPhysics_WriteWorld");
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4097, ASSERT_TYPE_ASSERT, "(memFile)", "%s\n\tHavokPhysics: WriteWorld has NULL memfile", "memFile") )
    __debugbreak();
  if ( (unsigned int)v2 > PHYSICS_WORLD_ID_CLIENT1_DETAIL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4098, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavokPhysics: Trying to WriteWorld with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v2) )
    __debugbreak();
  if ( !HavokPhysics_GetConstWorld(v2)->world )
  {
    LODWORD(v15) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4102, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics WriteWorld %i: world is NULL", "physicsWorld->world", v15) )
      __debugbreak();
  }
  v5 = 0;
  WorldTransientCount = 1;
  p = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_OFFHAND_END|0x80);
  if ( p )
  {
    v5 = 32;
    WorldTransientCount = DB_Transients_GetWorldTransientCount();
  }
  v6 = 0;
  if ( v5 )
  {
    v7 = WorldTransientCount;
    v8 = p;
    do
    {
      if ( v8 && v6 < v7 )
      {
        WorldTransientName = DB_Transients_GetWorldTransientName(v6);
        if ( !WorldTransientName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4128, ASSERT_TYPE_ASSERT, "(zoneName)", (const char *)&queryFormat, "zoneName") )
          __debugbreak();
        IsGameSystemTransientLoaded = CL_TransientsSP_IsGameSystemTransientLoaded(v6);
        p = 1;
        MemFile_WriteData(memFile, 1ui64, &p);
        MemFile_WriteCString(memFile, WorldTransientName);
        p = IsGameSystemTransientLoaded;
        MemFile_WriteData(memFile, 1ui64, &p);
      }
      else
      {
        p = 0;
        MemFile_WriteData(memFile, 1ui64, &p);
      }
      ++v6;
    }
    while ( v6 < v5 );
    ConstWorld = v21;
    v2 = numAllocatedInstances;
  }
  Sys_ProfEndNamedEvent();
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "HavokPhysics_WriteConstraints");
  HavokPhysics_WriteConstraints(memFile, v2);
  Sys_ProfEndNamedEvent();
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "HavokPhysics_WriteInstances");
  numAllocatedInstances = ConstWorld->instanceManager.numAllocatedInstances;
  MemFile_WriteData(memFile, 4ui64, &numAllocatedInstances);
  v11 = 0;
  for ( i = 0; i < ConstWorld->instanceManager.capacity; ++i )
  {
    if ( HavokPhysicsInstanceManager_IsInstanceInUse(&ConstWorld->instanceManager, i) )
    {
      numAllocatedInstances = i;
      MemFile_WriteData(memFile, 4ui64, &numAllocatedInstances);
      HavokPhysics_WriteInstance(memFile, v2, i);
      ++v11;
    }
  }
  Sys_ProfEndNamedEvent();
  if ( v11 != ConstWorld->instanceManager.numAllocatedInstances && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4987, ASSERT_TYPE_ASSERT, "(numInstancesWritten == world->instanceManager.numAllocatedInstances)", (const char *)&queryFormat, "numInstancesWritten == world->instanceManager.numAllocatedInstances") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFFFE4C4, "exportSimulationState");
  hknpWorld::checkConsistency(ConstWorld->world);
  hkOstream::hkOstream(&v17, &buf);
  NpSimulationSnapshot::exportSimulationState(ConstWorld->world, *(hkStreamWriter **)(v13 + 24));
  hkOstream::~hkOstream(&v17);
  hknpWorld::checkConsistency(ConstWorld->world);
  numAllocatedInstances = buf.m_size;
  MemFile_WriteData(memFile, 4ui64, &numAllocatedInstances);
  MemFile_WriteData(memFile, buf.m_size, buf.m_data);
  Sys_ProfEndNamedEvent();
  v14 = hkMemHeapAllocator();
  buf.m_size = 0;
  if ( buf.m_capacityAndFlags >= 0 )
    hkMemoryAllocator::bufFree2(v14, buf.m_data, 1, buf.m_capacityAndFlags & 0x3FFFFFFF);
}

/*
==============
HavokPhysics_XModelsSortByDetailBodyCount
==============
*/
hkBool *HavokPhysics_XModelsSortByDetailBodyCount(hkBool *result, const XModel *a, const XModel *b)
{
  int m_size; 
  XModelDetailCollision *detailCollision; 
  int v8; 
  const HavokPhysicsXModelLOD *HavokPhysicsXModelLODFromDetailCol; 
  PhysicsAsset *physicsAsset; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  XModelDetailCollision *v12; 
  const HavokPhysicsXModelLOD *v13; 
  PhysicsAsset *v14; 
  const HavokPhysicsAsset *v15; 
  bool v16; 

  m_size = 0;
  detailCollision = a->detailCollision;
  v8 = 0;
  if ( detailCollision )
  {
    HavokPhysicsXModelLODFromDetailCol = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(detailCollision);
    if ( !HavokPhysicsXModelLODFromDetailCol && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18204, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
      __debugbreak();
    m_size = HavokPhysicsXModelLODFromDetailCol->m_bodyNames.m_size;
    if ( m_size == 1 )
      m_size = 2;
  }
  else
  {
    physicsAsset = a->physicsAsset;
    if ( physicsAsset )
    {
      HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(physicsAsset);
      if ( !HavokPhysicsAsset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18211, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
        __debugbreak();
      m_size = HavokPhysicsAsset->m_bodyServerUsage.m_size;
    }
  }
  v12 = b->detailCollision;
  if ( v12 )
  {
    v13 = HavokPhysics_GetHavokPhysicsXModelLODFromDetailCol(v12);
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18218, ASSERT_TYPE_ASSERT, "(havokPhysicsXModelLOD)", (const char *)&queryFormat, "havokPhysicsXModelLOD") )
      __debugbreak();
    v8 = v13->m_bodyNames.m_size;
    if ( v8 == 1 )
      v8 = 2;
  }
  else
  {
    v14 = b->physicsAsset;
    if ( v14 )
    {
      v15 = HavokPhysics_GetHavokPhysicsAsset(v14);
      if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 18225, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
        __debugbreak();
      v8 = v15->m_bodyServerUsage.m_size;
    }
  }
  if ( m_size == v8 )
    v16 = I_stricmp(a->name, b->name) < 0;
  else
    v16 = m_size > v8;
  result->m_bool = v16;
  return result;
}

/*
==============
HavokPhysics_XModelsSortByMemory
==============
*/
hkBool *HavokPhysics_XModelsSortByMemory(hkBool *result, const XModel *a, const XModel *b)
{
  result->m_bool = a->detailCollision->physicsLODDataSize > b->detailCollision->physicsLODDataSize;
  return result;
}

/*
==============
HavokPhysics_XModelsSortByName
==============
*/
hkBool *HavokPhysics_XModelsSortByName(hkBool *result, const XModel *a, const XModel *b)
{
  result->m_bool = I_stricmp(a->name, b->name) < 0;
  return result;
}

/*
==============
HavokPhysics_BroadphaseCollisionQueryResult::Reset
==============
*/
void HavokPhysics_BroadphaseCollisionQueryResult::Reset(HavokPhysics_BroadphaseCollisionQueryResult *this)
{
  this->m_hits.m_size = 0;
}

/*
==============
HavokPhysics_CollisionQueryResult::Reset
==============
*/
void HavokPhysics_CollisionQueryResult::Reset(HavokPhysics_CollisionQueryResult *this, bool clearModifiers)
{
  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 890, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  HavokPhysicsHitCollector::Reset(this->m_collector, clearModifiers);
}

/*
==============
HavokPhysics_IgnoreBodies::Reset
==============
*/
void HavokPhysics_IgnoreBodies::Reset(HavokPhysics_IgnoreBodies *this)
{
  this->m_ignoreRefs = 0;
  this->m_ignoreEntities.m_size = 0;
  this->m_ignoreBodies.m_size = 0;
  this->m_ignoreTeamCharacters = TEAM_ZERO;
  this->m_ignoreTransparentVolumes = 0;
  this->m_ignoreLayers = 32;
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreBody
==============
*/
void HavokPhysics_IgnoreBodies::SetIgnoreBody(HavokPhysics_IgnoreBodies *this, int index, unsigned int bodyId)
{
  __int64 v4; 
  int m_size; 

  v4 = index;
  if ( (unsigned int)index >= this->m_ignoreBodies.m_size )
  {
    m_size = this->m_ignoreBodies.m_size;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 794, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( m_ignoreBodies.getSize() )", "index doesn't index m_ignoreBodies.getSize()\n\t%i not in [0, %i)", index, m_size) )
      __debugbreak();
  }
  this->m_ignoreBodies.m_data[v4].m_serialAndIndex = bodyId;
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreEntity
==============
*/
void HavokPhysics_IgnoreBodies::SetIgnoreEntity(HavokPhysics_IgnoreBodies *this, int index, int svEntNum, bool self, bool children, bool parent, bool siblings, bool linked)
{
  __int64 v9; 
  HavokPhysics_IgnoreBodies::IgnoreEntity *m_data; 
  int m_size; 

  v9 = index;
  if ( (unsigned int)index >= this->m_ignoreEntities.m_size )
  {
    m_size = this->m_ignoreEntities.m_size;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 801, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( m_ignoreEntities.getSize() )", "index doesn't index m_ignoreEntities.getSize()\n\t%i not in [0, %i)", index, m_size) )
      __debugbreak();
  }
  if ( svEntNum != 2047 )
  {
    m_data = this->m_ignoreEntities.m_data;
    *((_BYTE *)&m_data[v9] + 4) &= ~1u;
    m_data[v9].svEntNum = svEntNum;
    *((_BYTE *)&m_data[v9] + 4) = (self | *((_BYTE *)&m_data[v9] + 4)) & 0xE1 | (2 * (children & 0xF1 | (2 * (parent & 0xF9 | (2 * ((2 * linked) | siblings & 0xFD))))));
  }
}

/*
==============
HavokPhysics_IgnoreBodies::SetIgnoreRefs
==============
*/
void HavokPhysics_IgnoreBodies::SetIgnoreRefs(HavokPhysics_IgnoreBodies *this, int refFlags)
{
  this->m_ignoreRefs = refFlags;
}

/*
==============
HavokPhysics_IgnoreBodies::SetIsClutter
==============
*/
void HavokPhysics_IgnoreBodies::SetIsClutter(HavokPhysics_IgnoreBodies *this, bool isClutter)
{
  this->m_isClutter = isClutter;
}

/*
==============
HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly
==============
*/
void HavokPhysics_IgnoreBodies::SetSimulationBodiesOnly(HavokPhysics_IgnoreBodies *this, bool simulationBodiesOnly)
{
  int v2; 

  v2 = this->m_ignoreLayers | 2;
  if ( !simulationBodiesOnly )
    v2 = this->m_ignoreLayers & 0xFFFFFFFD;
  this->m_ignoreLayers = v2;
}

/*
==============
HavokPhysics_CollisionQueryResult::SortResults
==============
*/
void HavokPhysics_CollisionQueryResult::SortResults(HavokPhysics_CollisionQueryResult *this)
{
  hknpAllHitsCollector *Collector; 

  if ( !this->m_collector && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 897, ASSERT_TYPE_ASSERT, "(m_collector)", (const char *)&queryFormat, "m_collector") )
    __debugbreak();
  if ( HavokPhysicsHitCollector::GetCollectorType(this->m_collector) != PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 898, ASSERT_TYPE_ASSERT, "(m_collector->GetCollectorType() == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL)", (const char *)&queryFormat, "m_collector->GetCollectorType() == PHYSICS_COLLISIONQUERY_COLLECTION_TYPE_ALL") )
    __debugbreak();
  Collector = (hknpAllHitsCollector *)HavokPhysicsHitCollector::GetCollector(this->m_collector);
  if ( !Collector )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 901, ASSERT_TYPE_ASSERT, "(collector)", (const char *)&queryFormat, "collector") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 903, ASSERT_TYPE_ASSERT, "(allHitsCollector)", (const char *)&queryFormat, "allHitsCollector") )
      __debugbreak();
  }
  hknpAllHitsCollector::sortHits(Collector);
}

/*
==============
HavokPhysics_SnapshotFixup::Validate
==============
*/
void HavokPhysics_SnapshotFixup::Validate(HavokPhysics_SnapshotFixup *this, HavokPhysicsWorld *world)
{
  __int64 m_hashMod; 
  int v3; 
  HavokPhysicsWorld *v4; 
  int v6; 
  __int64 v7; 
  __int64 v8; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  __int64 v10; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *v11; 
  unsigned __int64 key; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *p_val; 
  _OWORD *v14; 
  __int64 v15; 
  __int128 v16; 
  _WORD *v17; 
  __int64 v18; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *v19; 
  __int64 v20; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *v21; 
  unsigned int capacity; 
  __int64 *v23; 
  __int64 v24; 
  int v25; 
  __int64 v26; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *v27; 
  signed __int32 v28[8]; 
  __int64 v29; 
  __int64 v30; 
  __int64 v31; 
  HavokPhysicsWorld *v32; 
  _WORD *v33; 
  char v34[256]; 

  m_hashMod = this->bodyData.m_hashMod;
  v3 = 0;
  v32 = world;
  v4 = world;
  v6 = 0;
  if ( (int)m_hashMod >= 0 )
  {
    v7 = m_hashMod;
    v8 = 0i64;
    m_elem = this->bodyData.m_elem;
    do
    {
      if ( m_elem->key != -1i64 )
        break;
      ++v6;
      ++v8;
      ++m_elem;
    }
    while ( v8 <= v7 );
  }
  if ( v6 <= this->bodyData.m_hashMod )
  {
    do
    {
      v10 = v6;
      v11 = this->bodyData.m_elem;
      key = v11[v10].key;
      p_val = &v11[v10].val;
      v14 = &v33;
      v15 = 2i64;
      do
      {
        v14 += 8;
        v16 = *(_OWORD *)&p_val->shape;
        p_val = (HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *)((char *)p_val + 128);
        *(v14 - 8) = v16;
        *(v14 - 7) = *(_OWORD *)&p_val[-1].name[144];
        *(v14 - 6) = *(_OWORD *)&p_val[-1].name[160];
        *(v14 - 5) = *(_OWORD *)&p_val[-1].name[176];
        *(v14 - 4) = *(_OWORD *)&p_val[-1].name[192];
        *(v14 - 3) = *(_OWORD *)&p_val[-1].name[208];
        *(v14 - 2) = *(_OWORD *)&p_val[-1].name[224];
        *(v14 - 1) = *(_OWORD *)&p_val[-1].name[240];
        --v15;
      }
      while ( v15 );
      *v14 = *(_OWORD *)&p_val->shape;
      (*(void (__fastcall **)(_WORD *))(*(_QWORD *)v33 + 24i64))(v33);
      if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4019, ASSERT_TYPE_ASSERT, "(data.shape != 0)", "%s\n\tInvalid shape for body %s with id %llu", "data.shape != NULL", v34, key) )
        __debugbreak();
      v17 = v33;
      _InterlockedOr(v28, 0);
      LOWORD(v17) = v17[9];
      _InterlockedOr(v28, 0);
      if ( !(_WORD)v17 && v33[8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4020, ASSERT_TYPE_ASSERT, "(data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0)", "%s\n\tNo references for Shape for body %s wiki id %llu", "data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0", v34, key) )
        __debugbreak();
      if ( ++v6 <= this->bodyData.m_hashMod )
      {
        v18 = v6;
        v19 = &this->bodyData.m_elem[v6];
        do
        {
          if ( v19->key != -1i64 )
            break;
          ++v6;
          ++v18;
          ++v19;
        }
        while ( v18 <= this->bodyData.m_hashMod );
      }
    }
    while ( v6 <= this->bodyData.m_hashMod );
    v4 = v32;
  }
  if ( this->constraintData.m_hashMod >= 0 )
  {
    v20 = 0i64;
    v21 = this->constraintData.m_elem;
    do
    {
      if ( v21->key != -1i64 )
        break;
      ++v3;
      ++v20;
      ++v21;
    }
    while ( v20 <= this->constraintData.m_hashMod );
  }
  if ( v3 <= this->constraintData.m_hashMod )
  {
    do
    {
      capacity = v4->instanceManager.capacity;
      v23 = (__int64 *)&this->constraintData.m_elem[v3];
      v24 = v23[1];
      if ( HIDWORD(v24) >= capacity )
      {
        v31 = *v23;
        LODWORD(v30) = capacity;
        LODWORD(v29) = HIDWORD(v24);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4026, ASSERT_TYPE_ASSERT, "(data.instanceId < world->instanceManager.capacity)", "%s\n\tInstanceID %d out of range of %d for body %llu.", "data.instanceId < world->instanceManager.capacity", v29, v30, v31) )
          __debugbreak();
      }
      v25 = v3 + 1;
      if ( v3 + 1 <= this->constraintData.m_hashMod )
      {
        v26 = v25;
        v27 = &this->constraintData.m_elem[v25];
        do
        {
          if ( v27->key != -1i64 )
            break;
          ++v25;
          ++v26;
          ++v27;
        }
        while ( v26 <= this->constraintData.m_hashMod );
      }
      v3 = v25;
    }
    while ( v25 <= this->constraintData.m_hashMod );
  }
}

/*
==============
HavokPhysics_SnapshotFixup::getConstraintDataForConstraint
==============
*/
hkpConstraintData *HavokPhysics_SnapshotFixup::getConstraintDataForConstraint(HavokPhysics_SnapshotFixup *this, hknpConstraint *constraint)
{
  int m_hashMod; 
  __int64 m_value; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int32 v6; 
  unsigned __int32 v7; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned __int64 key; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupConstraint val; 
  const HavokPhysicsWorld *ConstWorld; 
  const PhysicsAsset *PhysicsAsset; 
  const HavokPhysicsAsset *HavokPhysicsAsset; 
  hknpConstraintCinfo *v15; 
  hkpConstraintData *v16; 
  const hkTransformf *v17; 
  hkTransformf pivot; 
  hkTransformf v20; 

  m_hashMod = this->constraintData.m_hashMod;
  m_value = constraint->m_id.m_value;
  if ( m_hashMod <= 0 || (m_elem = this->constraintData.m_elem, v6 = _byteswap_ulong(0), v7 = _byteswap_ulong(-1640531535 * m_value), v8 = m_hashMod & (v6 ^ ((v7 >> 2) + v7 + (v6 << 6) - 1640531527)), v9 = v8, key = m_elem[v8].key, key == -1i64) )
  {
LABEL_5:
    m_elem = this->constraintData.m_elem;
    v9 = m_hashMod + 1;
  }
  else
  {
    while ( key != m_value )
    {
      v8 = m_hashMod & (v8 + 1);
      v9 = v8;
      key = m_elem[v8].key;
      if ( key == -1i64 )
        goto LABEL_5;
    }
  }
  val = m_elem[v9].val;
  ConstWorld = HavokPhysics_GetConstWorld(this->worldId);
  if ( !ConstWorld->world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4049, ASSERT_TYPE_ASSERT, "(physicsWorld->world)", "%s\n\tHavokPhysics %i: world is NULL", "physicsWorld->world", this->worldId) )
    __debugbreak();
  PhysicsAsset = HavokPhysicsInstanceManager_GetPhysicsAsset(&ConstWorld->instanceManager, val.instanceId);
  if ( PhysicsAsset )
  {
    HavokPhysicsAsset = HavokPhysics_GetHavokPhysicsAsset(PhysicsAsset);
    if ( HavokPhysicsAsset )
      goto LABEL_15;
  }
  else
  {
    HavokPhysicsAsset = NULL;
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4055, ASSERT_TYPE_ASSERT, "(havokPhysicsAsset)", (const char *)&queryFormat, "havokPhysicsAsset") )
    __debugbreak();
LABEL_15:
  v15 = &HavokPhysicsAsset->m_physicsSystemData->m_constraintCinfos.m_data[val.constraintIdx];
  if ( (v15->m_bodyB.m_serialAndIndex & 0xFFFFFF) != 0xFFFFFF )
    return v15->m_constraintData.m_ptr;
  v16 = hkpConstraintDataUtils::deepClone(v15->m_constraintData.m_ptr);
  v17 = (const hkTransformf *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))ConstWorld->world->getBodyTransform)(&ConstWorld->world->hknpWorldReader, v15->m_bodyA.m_serialAndIndex);
  hkpConstraintDataUtils::getPivotTransform(v15->m_constraintData.m_ptr, 1, &pivot);
  hkTransformf::setMul(&v20, v17, &pivot);
  hkpConstraintDataUtils::setPivotTransform(v16, &v20, 1);
  return v16;
}

/*
==============
HavokPhysics_SnapshotFixup::getShapeForBody
==============
*/
const hknpShape *HavokPhysics_SnapshotFixup::getShapeForBody(HavokPhysics_SnapshotFixup *this, hknpBody *body)
{
  int m_hashMod; 
  __int64 m_serialAndIndex; 
  hkMapBase<unsigned __int64,HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData,hkMapOperations<unsigned __int64> >::Pair *m_elem; 
  unsigned __int32 v7; 
  unsigned __int32 v8; 
  unsigned int v9; 
  unsigned int v10; 
  unsigned __int64 key; 
  const hknpShape **v12; 
  HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *p_val; 
  __int64 v14; 
  __int128 v15; 
  const hknpShape *v16; 
  bool v17; 
  const hknpShape *result; 
  signed __int32 v19[8]; 
  __int64 v20; 
  const hknpShape *v21; 
  char v22[256]; 

  m_hashMod = this->bodyData.m_hashMod;
  m_serialAndIndex = body->m_id.m_serialAndIndex;
  if ( m_hashMod <= 0 || (m_elem = this->bodyData.m_elem, v7 = _byteswap_ulong(0), v8 = _byteswap_ulong(-1640531535 * m_serialAndIndex), v9 = m_hashMod & (v7 ^ ((v8 >> 2) + v8 + (v7 << 6) - 1640531527)), v10 = v9, key = m_elem[v9].key, key == -1i64) )
  {
LABEL_5:
    m_elem = this->bodyData.m_elem;
    v10 = m_hashMod + 1;
  }
  else
  {
    while ( key != m_serialAndIndex )
    {
      v9 = m_hashMod & (v9 + 1);
      v10 = v9;
      key = m_elem[v9].key;
      if ( key == -1i64 )
        goto LABEL_5;
    }
  }
  v12 = &v21;
  p_val = &m_elem[v10].val;
  v14 = 2i64;
  do
  {
    v12 += 16;
    v15 = *(_OWORD *)&p_val->shape;
    p_val = (HavokPhysics_SnapshotFixup::HavokPhysics_SnapshotFixupData *)((char *)p_val + 128);
    *((_OWORD *)v12 - 8) = v15;
    *((_OWORD *)v12 - 7) = *(_OWORD *)&p_val[-1].name[144];
    *((_OWORD *)v12 - 6) = *(_OWORD *)&p_val[-1].name[160];
    *((_OWORD *)v12 - 5) = *(_OWORD *)&p_val[-1].name[176];
    *((_OWORD *)v12 - 4) = *(_OWORD *)&p_val[-1].name[192];
    *((_OWORD *)v12 - 3) = *(_OWORD *)&p_val[-1].name[208];
    *((_OWORD *)v12 - 2) = *(_OWORD *)&p_val[-1].name[224];
    *((_OWORD *)v12 - 1) = *(_OWORD *)&p_val[-1].name[240];
    --v14;
  }
  while ( v14 );
  *(_OWORD *)v12 = *(_OWORD *)&p_val->shape;
  if ( !v21 )
  {
    LODWORD(v20) = m_serialAndIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4035, ASSERT_TYPE_ASSERT, "(data.shape != 0)", "%s\n\tInvalid shape for body %s with id %d", "data.shape != NULL", v22, v20) )
      __debugbreak();
  }
  v16 = v21;
  _InterlockedOr(v19, 0);
  LOWORD(v16) = v16->m_refCount;
  _InterlockedOr(v19, 0);
  v17 = (_WORD)v16 == 0;
  result = v21;
  if ( v17 && v21->m_memSizeAndFlags )
  {
    LODWORD(v20) = body->m_id.m_serialAndIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysics.cpp", 4036, ASSERT_TYPE_ASSERT, "(data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0)", "%s\n\tNo references for Shape for body %s wiki id %d", "data.shape->getReferenceCount() || data.shape->getMemorySizeAndFlags() == 0", v22, v20) )
      __debugbreak();
    return v21;
  }
  return result;
}

/*
==============
hkKeycodeManager::setKeycodes
==============
*/
__int64 hkKeycodeManager::setKeycodes()
{
  const dvar_t *v0; 
  const dvar_t *v1; 
  const char *string; 
  const char *v3; 
  hkResult v4; 
  unsigned int v5; 
  int v6; 
  hkResult v7; 
  unsigned int v8; 
  hkStringView v10; 

  v0 = DVARSTR_physics_HavokPhysicsLicense;
  if ( !DVARSTR_physics_HavokPhysicsLicense && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_HavokPhysicsLicense") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  v1 = DVARSTR_physics_HavokClothLicense;
  string = v0->current.string;
  if ( !DVARSTR_physics_HavokClothLicense && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "physics_HavokClothLicense") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  v3 = v1->current.string;
  v10 = (hkStringView)(unsigned __int64)string;
  if ( string )
    v10.m_end = &string[hkString::strLen(string)];
  v4.m_code = hkKeycodeManager::setKeycode(PHYSICS, &v10).m_code;
  v10 = (hkStringView)(unsigned __int64)v3;
  v5 = -2147220992;
  v6 = -2147220992;
  if ( v4.m_code >= 0 )
    v6 = 0;
  if ( v3 )
    v10.m_end = &v3[hkString::strLen(v3)];
  v7.m_code = hkKeycodeManager::setKeycode(CLOTH, &v10).m_code;
  v8 = -2147220992;
  v10.m_begin = (char *)&queryFormat.fmt + 3;
  if ( v7.m_code >= 0 )
    v8 = v6;
  v10.m_end = (char *)&queryFormat.fmt + hkString::strLen((const char *)&queryFormat.fmt + 3) + 3;
  if ( hkKeycodeManager::setKeycode(ANIMATION, &v10).m_code >= 0 )
    return v8;
  return v5;
}

/*
==============
setKeycodes
==============
*/
__int64 setKeycodes(void *__formal)
{
  int i; 
  unsigned int v3; 
  __int64 v4; 
  char *v5; 
  char *v6; 
  hkLog::Message v7; 
  const char *ProductName; 

  if ( hkKeycodeDataBase::singleton.m_ptr )
  {
    if ( hkKeycodeManager::setKeycodes().m_code >= 0 )
    {
      for ( i = 0; i < 10; ++i )
      {
        v3 = hkKeycodeData::s_linkedProducts;
        if ( _bittest((const int *)&v3, (unsigned __int8)i) )
        {
          v4 = 257i64 * (unsigned __int8)i;
          v5 = (char *)&hkKeycodeDataBase::singleton.m_ptr[1] + v4;
          v6 = NULL;
          if ( (hkKeycodeDataBase *)((char *)hkKeycodeDataBase::singleton.m_ptr + v4) != (hkKeycodeDataBase *)-24i64 )
            v6 = &v5[hkString::strLen((const char *)&hkKeycodeDataBase::singleton.m_ptr[1] + v4)];
          if ( v5 == v6 )
          {
            ProductName = hkKeycodeManager::getProductName((hkKeycodeManager::Products)i);
            hkLog::Message::Message(&v7, &s_keycodeLogOrigin, Canceled);
            hkLog::Message::setText(&v7, "  [ERROR: MISSING KEY] Product license key for Havok {} is missing.", (const hkVarArgs::Detail::VarArgsTypeArray<0> *)&hkVarArgs::Detail::VarArgsTypesOf<void,char const *>::typesArray, &ProductName, 0i64);
            hkLog::AutoMessage::~AutoMessage((hkLog::AutoMessage *)&v7);
          }
        }
      }
    }
    return 0i64;
  }
  else
  {
    return 2147746304i64;
  }
}

