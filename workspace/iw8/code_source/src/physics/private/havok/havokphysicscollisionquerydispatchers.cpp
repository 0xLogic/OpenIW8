/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?compoundVsShape@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<0>
==============
*/

void __fastcall unwrapMaskedShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapMaskedShape@$0A@@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsCompressedMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsCompound@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsHeightField@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<2>
==============
*/

void __fastcall unwrapMaskedShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapMaskedShape@$01@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<2>
==============
*/

void __fastcall unwrapLodShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapLodShape@$01@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<1>
==============
*/

void __fastcall unwrapScaledConvex<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapScaledConvex@$00@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsExternMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<2>
==============
*/

void __fastcall unwrapScaledConvex<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapScaledConvex@$01@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?externMeshVsShape@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher
==============
*/

void __fastcall HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher(HavokPhysics_CollisionQueryDispatcher *this)
{
  ??0HavokPhysics_CollisionQueryDispatcher@@QEAA@XZ(this);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsParticleSystem@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?compressedMeshVsCompressedMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable
==============
*/

void __fastcall HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable(HavokPhysics_CollisionQueryDispatcher *this, unsigned int shapeMask)
{
  ?initIWGetClosestPointsTable@HavokPhysics_CollisionQueryDispatcher@@AEAAXI@Z(this, shapeMask);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?particlesVsShape@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?heightFieldVsCompressedMesh@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<0>
==============
*/

void __fastcall unwrapLodShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapLodShape@$0A@@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?heightFieldVsHeightfield@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<1>
==============
*/

void __fastcall unwrapLodShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapLodShape@$00@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?convexVsConvex@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<0>
==============
*/

void __fastcall unwrapScaledConvex<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapScaledConvex@$0A@@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound
==============
*/

void __fastcall HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ?compoundVsCompound@HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<1>
==============
*/

void __fastcall unwrapMaskedShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  ??$unwrapMaskedShape@$00@@YAXPEAUhknpCollisionQueryContext@@AEBUhknpClosestPointsQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::castShapeConvex
==============
*/

void __fastcall HavokPhysics_CollisionQueryDispatcher::castShapeConvex(hknpCollisionQueryContext *queryContext, const hknpShapeCastQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *targetTquery, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector, hknpCollisionQueryCollector *startCollector)
{
  ?castShapeConvex@HavokPhysics_CollisionQueryDispatcher@@CAXPEAUhknpCollisionQueryContext@@AEBUhknpShapeCastQuery@@AEBUhknpShapeQueryInfo@@PEBVhknpShape@@AEBUhknpQueryFilterData@@2AEBVhkTransformf@@_NPEAVhknpCollisionQueryCollector@@7@Z(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, targetTquery, queryAndTargetSwapped, collector, startCollector);
}

/*
==============
unwrapLodShape<1>
==============
*/
void unwrapLodShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v11; 
  __m256i v12; 
  __int64 m_size; 
  unsigned int m_mode; 
  const hknpShape *v16; 
  __m256i v17; 
  const hkTransformf *v18; 
  float m_convexRadius; 
  __int64 v20; 
  __m256i v21; 
  unsigned int v22; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  __int64 v24; 
  __int64 v25; 
  const hknpCollisionQueryDispatcher *v27; 
  unsigned __int16 v28[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v31; 
  const hknpShape *v32; 
  const hknpShape *v33; 
  unsigned int v34; 
  __int64 v35; 
  __int16 v36[2]; 
  int v37; 
  __int64 v38; 
  const hknpBody *v39; 
  const hknpShape *v40; 
  const hknpShape *v41; 
  unsigned int m_value; 
  __int64 v43; 
  __m256i v44; 
  __m256i v45; 
  __int64 v46[3]; 
  unsigned int v47; 
  int v48; 
  const hkTransformf *v49; 
  __int64 v50; 
  char v51; 
  unsigned int v52; 
  float v53; 
  __m256i v54; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v60; 
  bool m_isScaled; 
  unsigned int v62; 
  float v63; 
  __m256i v64; 

  v11 = *(__m256i *)query->m_levelOfDetail;
  v12 = *(__m256i *)&query->m_shapeTagCodec;
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  m_shapeKeyPath = queryShapeInfo->m_shapeKeyPath;
  m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v60 = 0i64;
  v50 = 0i64;
  v62 = m_mode;
  v46[0] = (__int64)targetShapeInfo->m_body;
  v46[1] = (__int64)targetShapeInfo->m_rootShape;
  v16 = targetShapeInfo->m_parentShape;
  v45 = v11;
  v17 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v46[2] = (__int64)v16;
  v18 = targetShapeInfo->m_shapeToWorld;
  v64 = v17;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  v20 = *(int *)query->m_levelOfDetail;
  v49 = v18;
  LOBYTE(v18) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v63 = m_convexRadius;
  v21 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v51 = (char)v18;
  v22 = targetShapeInfo->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((((_DWORD)v20 + 1) << (32 - (m_size + 3))) - 1);
  v52 = targetShapeInfo->m_scalingInternals.m_mode;
  m_dispatcher = queryContext->m_dispatcher;
  v24 = *((_BYTE *)&targetShape[2].m_propertyBag.m_bag + v20) & 7;
  v54 = v21;
  v53 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  v44 = v12;
  v47 = v22;
  v48 = m_size + 3;
  v25 = *((_QWORD *)&targetShape[1].__vftable + v24);
  __asm { vpextrq rcx, xmm2, 1 }
  v27 = m_dispatcher;
  if ( !_RCX )
    goto LABEL_3;
  v36[0] = v44.m256i_i16[8];
  v37 = v44.m256i_i32[5];
  v38 = v44.m256i_i64[3];
  v39 = m_body;
  v40 = m_rootShape;
  v41 = m_parentShape;
  m_value = m_shapeKeyPath.m_key.m_value;
  v43 = v45.m256i_i64[1];
  v28[0] = targetShapeFilterData->m_materialId.m_value;
  m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
  m_userData = targetShapeFilterData->m_userData;
  v31 = targetShapeInfo->m_body;
  v32 = targetShapeInfo->m_rootShape;
  v33 = targetShapeInfo->m_parentShape;
  v34 = v22;
  v35 = v25;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v36, v28) )
LABEL_3:
    v27->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v45.m256i_i64[1] + 26)][*(unsigned __int8 *)(v25 + 26)](queryContext, (const hknpClosestPointsQuery *)&v44, (const hknpShapeQueryInfo *)&m_body, (const hknpShape *)v25, targetShapeFilterData, (const hknpShapeQueryInfo *)v46, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<2>
==============
*/
void unwrapLodShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v11; 
  __m256i v12; 
  __m256i v13; 
  __int64 m_size; 
  const hknpBody *v18; 
  __m256i v19; 
  __int64 v20; 
  unsigned int m_value; 
  float v22; 
  __int64 v23; 
  unsigned int v24; 
  __int64 v26; 
  unsigned int v27; 
  __int64 v28; 
  __int64 v29; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  __int64 v32; 
  const hknpShape *v33; 
  const hknpShape *v34; 
  unsigned __int16 v35[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  __int64 v38; 
  const hknpShape *v39; 
  const hknpShape *v40; 
  unsigned int v41; 
  __int64 v42; 
  __int16 v43[2]; 
  int v44; 
  __int64 v45; 
  const hknpBody *v46; 
  const hknpShape *v47; 
  const hknpShape *v48; 
  unsigned int v49; 
  __int64 v50; 
  __m256i v51; 
  __m256i v52; 
  _QWORD v53[3]; 
  unsigned int v54; 
  int v55; 
  const hkTransformf *v56; 
  __int64 v57; 
  bool v58; 
  int v59; 
  float v60; 
  __m256i v61; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  unsigned int v65; 
  int v66; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v68; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float m_convexRadius; 
  __m256i v72; 

  v11 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v12 = *(__m256i *)query->m_levelOfDetail;
  v13 = *(__m256i *)&query->m_shapeTagCodec;
  m_size = queryShapeInfo->m_shapeKeyPath.m_size;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v18 = targetShapeInfo->m_body;
  v72 = v11;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  v68 = 0i64;
  v52 = v12;
  v51 = v13;
  v32 = (__int64)v18;
  v53[0] = v18;
  v33 = targetShapeInfo->m_rootShape;
  v53[1] = v33;
  v34 = targetShapeInfo->m_parentShape;
  v19 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v20 = targetShapeInfo->m_shapeKeyPath.m_size;
  v53[2] = v34;
  m_value = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  v56 = targetShapeInfo->m_shapeToWorld;
  v58 = targetShapeInfo->m_scalingInternals.m_isScaled;
  LODWORD(v18) = targetShapeInfo->m_scalingInternals.m_mode;
  v57 = 0i64;
  v59 = (int)v18;
  v61 = v19;
  v22 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  v66 = m_size + 3;
  v23 = *(int *)query->m_levelOfDetail;
  v54 = m_value;
  v24 = queryShapeInfo->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((((_DWORD)_XMM2 + 1) << (32 - (m_size + 3))) - 1);
  __asm { vpextrq rcx, xmm2, 1 }
  v52.m256i_i64[1] = _RCX;
  v60 = v22;
  v65 = v24;
  v26 = *(_QWORD *)(_RCX + 8i64 * (*(_BYTE *)((int)_XMM2 + _RCX + 120) & 7) + 56);
  v52.m256i_i64[1] = v26;
  v55 = v20 + 3;
  v27 = m_value & hknpShapeKeyPath_usedBitsMaskTable[v20] | ((((_DWORD)v23 + 1) << (32 - (v20 + 3))) - 1);
  v28 = *((_BYTE *)&targetShape[2].m_propertyBag.m_bag + v23) & 7;
  v54 = v27;
  v29 = *((_QWORD *)&targetShape[1].__vftable + v28);
  m_dispatcher = queryContext->m_dispatcher;
  __asm { vpextrq rcx, xmm3, 1 }
  if ( _RCX )
  {
    v43[0] = v51.m256i_i16[8];
    v44 = v51.m256i_i32[5];
    v45 = v51.m256i_i64[3];
    v46 = m_body;
    v47 = m_rootShape;
    v48 = m_parentShape;
    v35[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v38 = v32;
    v39 = v33;
    v50 = v26;
    v40 = v34;
    v49 = v24;
    v41 = v27;
    v42 = v29;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v43, v35) )
      return;
    v26 = v52.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v26 + 26)][*(unsigned __int8 *)(v29 + 26)](queryContext, (const hknpClosestPointsQuery *)&v51, (const hknpShapeQueryInfo *)&m_body, (const hknpShape *)v29, targetShapeFilterData, (const hknpShapeQueryInfo *)v53, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapLodShape<0>
==============
*/
void unwrapLodShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v11; 
  __m256i v12; 
  __m256i v13; 
  __int64 m_size; 
  float m_convexRadius; 
  const hknpShape *m_parentShape; 
  __m256i v19; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  float v21; 
  unsigned int v22; 
  __int64 v24; 
  __int64 v26; 
  unsigned __int16 v27[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v30; 
  const hknpShape *v31; 
  __int64 v32; 
  unsigned int m_value; 
  const hknpShape *v34; 
  __int16 v35[2]; 
  int v36; 
  __int64 v37; 
  const hknpBody *v38; 
  const hknpShape *v39; 
  const hknpShape *v40; 
  unsigned int v41; 
  __int64 v42; 
  __m256i v43; 
  __m256i v44; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *v47; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *v49; 
  __int64 v50; 
  char v51; 
  unsigned int v52; 
  float v53; 
  __m256i v54; 
  _QWORD v55[3]; 
  unsigned int v56; 
  int v57; 
  const hkTransformf *m_shapeToWorld; 
  __int64 v59; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float v62; 
  __m256i v63; 

  v11 = *(__m256i *)&query->m_shapeTagCodec;
  v12 = *(__m256i *)query->m_levelOfDetail;
  v13 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  m_size = queryShapeInfo->m_shapeKeyPath.m_size;
  v55[0] = queryShapeInfo->m_body;
  v55[1] = queryShapeInfo->m_rootShape;
  v55[2] = queryShapeInfo->m_parentShape;
  m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  m_body = targetShapeInfo->m_body;
  v63 = v13;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  m_rootShape = targetShapeInfo->m_rootShape;
  v62 = m_convexRadius;
  m_parentShape = targetShapeInfo->m_parentShape;
  v59 = 0i64;
  v44 = v12;
  v43 = v11;
  v26 = (__int64)m_parentShape;
  v19 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  m_dispatcher = queryContext->m_dispatcher;
  v47 = m_parentShape;
  m_shapeKeyPath = targetShapeInfo->m_shapeKeyPath;
  v49 = targetShapeInfo->m_shapeToWorld;
  LOBYTE(m_parentShape) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v50 = 0i64;
  v51 = (char)m_parentShape;
  v52 = targetShapeInfo->m_scalingInternals.m_mode;
  v54 = v19;
  v21 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  v57 = m_size + 3;
  v22 = queryShapeInfo->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((((_DWORD)_XMM2 + 1) << (32 - (m_size + 3))) - 1);
  __asm { vpextrq rcx, xmm2, 1 }
  v44.m256i_i64[1] = _RCX;
  v53 = v21;
  v56 = v22;
  v24 = *(_QWORD *)(_RCX + 8i64 * (*(_BYTE *)((int)_XMM2 + _RCX + 120) & 7) + 56);
  __asm { vpextrq rcx, xmm3, 1 }
  v44.m256i_i64[1] = v24;
  if ( _RCX )
  {
    v35[0] = v43.m256i_i16[8];
    v36 = v43.m256i_i32[5];
    v37 = v43.m256i_i64[3];
    v38 = queryShapeInfo->m_body;
    v39 = queryShapeInfo->m_rootShape;
    v40 = queryShapeInfo->m_parentShape;
    v27[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v30 = m_body;
    v31 = m_rootShape;
    v42 = v24;
    v32 = v26;
    m_value = m_shapeKeyPath.m_key.m_value;
    v41 = v22;
    v34 = targetShape;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v35, v27) )
      return;
    v24 = v44.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v24 + 26)][targetShape->m_type.m_storage](queryContext, (const hknpClosestPointsQuery *)&v43, (const hknpShapeQueryInfo *)v55, targetShape, targetShapeFilterData, (const hknpShapeQueryInfo *)&m_body, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<1>
==============
*/
void unwrapMaskedShape<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v11; 
  __m256i v12; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  hknpShape_vtbl *v16; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  int m_size; 
  __m256i v19; 
  const hkTransformf *m_shapeToWorld; 
  float m_convexRadius; 
  __m256i v22; 
  float v23; 
  unsigned int m_value; 
  const hknpBody *v26; 
  const hknpShape *v27; 
  const hknpShape *v28; 
  unsigned __int16 v29[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v32; 
  const hknpShape *v33; 
  const hknpShape *v34; 
  unsigned int v35; 
  hknpShape_vtbl *v36; 
  __int16 v37[2]; 
  int v38; 
  __int64 v39; 
  const hknpBody *v40; 
  const hknpShape *v41; 
  const hknpShape *v42; 
  unsigned int v43; 
  __int64 v44; 
  __m256i v45; 
  __m256i v46; 
  __int64 v47[3]; 
  unsigned int v48; 
  int v49; 
  const hkTransformf *v50; 
  hkDefaultPropertyBag *m_bag; 
  char v52; 
  int v53; 
  float v54; 
  __m256i v55; 
  __int64 v56[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float v59; 
  __m256i v60; 

  v11 = *(__m256i *)query->m_levelOfDetail;
  v12 = *(__m256i *)&query->m_shapeTagCodec;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  v16 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  v56[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v56[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v26 = targetShapeInfo->m_body;
  v47[0] = (__int64)targetShapeInfo->m_body;
  v27 = targetShapeInfo->m_rootShape;
  v47[1] = (__int64)v27;
  v28 = targetShapeInfo->m_parentShape;
  v47[2] = (__int64)v28;
  m_value = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  v48 = m_value;
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  v46 = v11;
  v19 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v49 = m_size;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  v60 = v19;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  v50 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v59 = m_convexRadius;
  v22 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v52 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  v55 = v22;
  v23 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  v53 = (int)m_shapeToWorld;
  __asm { vpextrq rcx, xmm2, 1 }
  m_bag = targetShape[1].m_propertyBag.m_bag;
  v56[0] = (__int64)m_body;
  v56[1] = (__int64)m_rootShape;
  v56[2] = (__int64)m_parentShape;
  v56[5] = 0i64;
  v54 = v23;
  v45 = v12;
  if ( !_RCX )
    goto LABEL_3;
  v37[0] = v45.m256i_i16[8];
  v38 = v45.m256i_i32[5];
  v39 = v45.m256i_i64[3];
  v43 = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
  v44 = v46.m256i_i64[1];
  v29[0] = targetShapeFilterData->m_materialId.m_value;
  m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
  m_userData = targetShapeFilterData->m_userData;
  v32 = v26;
  v33 = v27;
  v40 = m_body;
  v34 = v28;
  v35 = m_value;
  v41 = m_rootShape;
  v42 = m_parentShape;
  v36 = v16;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v37, v29) )
LABEL_3:
    m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v46.m256i_i64[1] + 26)][BYTE2(v16->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v45, (const hknpShapeQueryInfo *)v56, (const hknpShape *)v16, targetShapeFilterData, (const hknpShapeQueryInfo *)v47, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<2>
==============
*/
void unwrapMaskedShape<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v12; 
  __m256i v13; 
  __m256i v14; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  hknpShape_vtbl *v17; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  const hkTransformf *m_shapeToWorld; 
  float m_convexRadius; 
  __m256i v21; 
  float v22; 
  __int64 v24; 
  hkDefaultPropertyBag *m_bag; 
  unsigned __int16 v27[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v30; 
  const hknpShape *v31; 
  const hknpShape *v32; 
  unsigned int v33; 
  hknpShape_vtbl *v34; 
  __int16 v35[2]; 
  int v36; 
  __int64 v37; 
  const hknpBody *v38; 
  const hknpShape *v39; 
  const hknpShape *v40; 
  unsigned int m_value; 
  __int64 v42; 
  __m256i v43; 
  __m256i v44; 
  const hknpBody *v45; 
  const hknpShape *v46; 
  const hknpShape *m_parentShape; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *v49; 
  hkDefaultPropertyBag *v50; 
  char v51; 
  int v52; 
  float v53; 
  __m256i v54; 
  __int64 v55[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float v58; 
  __m256i v59; 

  v12 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v13 = *(__m256i *)query->m_levelOfDetail;
  v14 = *(__m256i *)&query->m_shapeTagCodec;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  v17 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  v55[2] = (__int64)queryShapeInfo->m_parentShape;
  v55[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v55[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v45 = targetShapeInfo->m_body;
  v46 = targetShapeInfo->m_rootShape;
  m_parentShape = targetShapeInfo->m_parentShape;
  m_shapeKeyPath = targetShapeInfo->m_shapeKeyPath;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  v59 = v12;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  v49 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v58 = m_convexRadius;
  v21 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v51 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  v54 = v21;
  v22 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  __asm { vpextrq rcx, xmm2, 1 }
  v44 = v13;
  v44.m256i_i64[1] = _RCX;
  v52 = (int)m_shapeToWorld;
  v53 = v22;
  v43 = v14;
  v55[0] = (__int64)m_body;
  v55[1] = (__int64)m_rootShape;
  v55[5] = *(_QWORD *)(_RCX + 64);
  v24 = *(_QWORD *)(_RCX + 56);
  m_bag = targetShape[1].m_propertyBag.m_bag;
  __asm { vpextrq rcx, xmm3, 1 }
  v44.m256i_i64[1] = v24;
  v50 = m_bag;
  if ( _RCX )
  {
    v35[0] = v43.m256i_i16[8];
    v36 = v43.m256i_i32[5];
    v37 = v43.m256i_i64[3];
    v40 = queryShapeInfo->m_parentShape;
    m_value = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
    v27[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v30 = v45;
    v31 = v46;
    v42 = v24;
    v32 = m_parentShape;
    v33 = m_shapeKeyPath.m_key.m_value;
    v38 = m_body;
    v39 = m_rootShape;
    v34 = v17;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v35, v27) )
      return;
    v24 = v44.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v24 + 26)][BYTE2(v17->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v43, (const hknpShapeQueryInfo *)v55, (const hknpShape *)v17, targetShapeFilterData, (const hknpShapeQueryInfo *)&v45, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapMaskedShape<0>
==============
*/
void unwrapMaskedShape<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v13; 
  __m256i v14; 
  __m256i v15; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  const hkTransformf *m_shapeToWorld; 
  float m_convexRadius; 
  __m256i v22; 
  float v23; 
  __int64 v25; 
  unsigned __int16 v27[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v30; 
  const hknpShape *v31; 
  const hknpShape *v32; 
  unsigned int v33; 
  const hknpShape *v34; 
  __int16 v35[2]; 
  int v36; 
  __int64 v37; 
  const hknpBody *v38; 
  const hknpShape *v39; 
  const hknpShape *v40; 
  unsigned int m_value; 
  __int64 v42; 
  __m256i v43; 
  __m256i v44; 
  const hknpBody *v45; 
  const hknpShape *v46; 
  const hknpShape *v47; 
  hknpShapeKeyPath m_shapeKeyPath; 
  const hkTransformf *v49; 
  __int64 v50; 
  char v51; 
  int v52; 
  float v53; 
  __m256i v54; 
  __int64 v55[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float v58; 
  __m256i v59; 

  v13 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v14 = *(__m256i *)query->m_levelOfDetail;
  v15 = *(__m256i *)&query->m_shapeTagCodec;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  m_dispatcher = queryContext->m_dispatcher;
  v55[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v55[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v45 = targetShapeInfo->m_body;
  v46 = targetShapeInfo->m_rootShape;
  v47 = targetShapeInfo->m_parentShape;
  m_shapeKeyPath = targetShapeInfo->m_shapeKeyPath;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  v59 = v13;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  v49 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v58 = m_convexRadius;
  v22 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v51 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  v54 = v22;
  v23 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  __asm { vpextrq rcx, xmm2, 1 }
  v44 = v14;
  v44.m256i_i64[1] = _RCX;
  v53 = v23;
  v43 = v15;
  v55[0] = (__int64)m_body;
  v55[1] = (__int64)m_rootShape;
  v55[2] = (__int64)m_parentShape;
  v50 = 0i64;
  v52 = (int)m_shapeToWorld;
  v55[5] = *(_QWORD *)(_RCX + 64);
  v25 = *(_QWORD *)(_RCX + 56);
  __asm { vpextrq rcx, xmm3, 1 }
  v44.m256i_i64[1] = v25;
  if ( _RCX )
  {
    v35[0] = v43.m256i_i16[8];
    v36 = v43.m256i_i32[5];
    v37 = v43.m256i_i64[3];
    m_value = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
    v27[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v30 = v45;
    v31 = v46;
    v42 = v25;
    v32 = v47;
    v38 = m_body;
    v33 = m_shapeKeyPath.m_key.m_value;
    v39 = m_rootShape;
    v40 = m_parentShape;
    v34 = targetShape;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)_RCX + 32i64))(_RCX, 4i64, !queryAndTargetSwapped, v35, v27) )
      return;
    v25 = v44.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v25 + 26)][targetShape->m_type.m_storage](queryContext, (const hknpClosestPointsQuery *)&v43, (const hknpShapeQueryInfo *)v55, targetShape, targetShapeFilterData, (const hknpShapeQueryInfo *)&v45, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<1>
==============
*/
void unwrapScaledConvex<1>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v9; 
  __m256i v10; 
  __m128 v11; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  const hknpShape *v16; 
  __m256i v17; 
  const hknpShape *v18; 
  float m_convexRadius; 
  __m256i v20; 
  float v21; 
  const hkTransformf *m_shapeToWorld; 
  __int128 v32; 
  hknpShape_vtbl *v33; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  int v35; 
  const hknpBody *v36; 
  __int64 v37; 
  __int64 v38; 
  unsigned __int16 v39[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v42; 
  __int64 v43; 
  __int64 v44; 
  int v45; 
  hknpShape_vtbl *v46; 
  __int16 v47[2]; 
  int v48; 
  __int64 v49; 
  const hknpBody *v50; 
  const hknpShape *v51; 
  const hknpShape *v52; 
  unsigned int m_value; 
  __int64 v54; 
  __m256i v55; 
  __m256i v56; 
  __int64 v57[3]; 
  int v58; 
  int v59; 
  const hkTransformf *v60; 
  __int64 v61; 
  bool v62; 
  unsigned int v63; 
  float v64; 
  __m256i v65; 
  __int64 v66[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float v69; 
  __m256i v70; 

  v9 = *(__m256i *)&query->m_shapeTagCodec;
  v10 = *(__m256i *)query->m_levelOfDetail;
  v11 = *(__m128 *)&targetShape[1].m_propertyBag.m_bag;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  v66[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v66[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v36 = targetShapeInfo->m_body;
  v57[0] = (__int64)targetShapeInfo->m_body;
  v16 = targetShapeInfo->m_rootShape;
  v55 = v9;
  v17 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v37 = (__int64)v16;
  v57[1] = (__int64)v16;
  v18 = targetShapeInfo->m_parentShape;
  v70 = v17;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  v38 = (__int64)v18;
  v57[2] = (__int64)v18;
  LODWORD(v18) = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  v69 = m_convexRadius;
  v20 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v56 = v10;
  _mm128_sub_ps(v11, g_vectorfConstants[6]);
  v35 = (int)v18;
  v58 = (int)v18;
  LODWORD(v18) = targetShapeInfo->m_shapeKeyPath.m_size;
  v65 = v20;
  v21 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  v59 = (int)v18;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  v64 = v21;
  _XMM0 = *(_OWORD *)hkMath::hkSse_signMask;
  __asm
  {
    vandnps xmm1, xmm0, xmm1
    vcmpleps xmm3, xmm1, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
    vpxor   xmm0, xmm0, xmm0
    vpcmpeqd xmm1, xmm0, xmm0
  }
  v60 = m_shapeToWorld;
  __asm
  {
    vblendps xmm2, xmm0, xmm1, 7
    vpand   xmm1, xmm3, xmm2
    vptest  xmm1, xmm2
  }
  v62 = targetShapeInfo->m_scalingInternals.m_isScaled;
  v63 = targetShapeInfo->m_scalingInternals.m_mode;
  v66[0] = (__int64)m_body;
  v66[1] = (__int64)m_rootShape;
  v66[2] = (__int64)m_parentShape;
  v66[5] = 0i64;
  v61 = 0i64;
  if ( !_CF )
  {
    v32 = *(_OWORD *)&targetShape[1].m_flags.m_storage;
    v64 = targetShape->m_convexRadius;
    *(_OWORD *)&v65.m256i_u64[2] = v32;
    v62 = 1;
    *(__m128 *)v65.m256i_i8 = v11;
  }
  v33 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  if ( !v55.m256i_i64[1] )
    goto LABEL_5;
  v47[0] = v55.m256i_i16[8];
  v48 = v55.m256i_i32[5];
  v49 = v55.m256i_i64[3];
  m_value = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
  v54 = v56.m256i_i64[1];
  v39[0] = targetShapeFilterData->m_materialId.m_value;
  m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
  m_userData = targetShapeFilterData->m_userData;
  v42 = v36;
  v43 = v37;
  v50 = m_body;
  v44 = v38;
  v45 = v35;
  v51 = m_rootShape;
  v52 = m_parentShape;
  v46 = v33;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)v55.m256i_i64[1] + 32i64))(v55.m256i_i64[1], 4i64, !queryAndTargetSwapped, v47, v39) )
LABEL_5:
    m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v56.m256i_i64[1] + 26)][BYTE2(v33->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v55, (const hknpShapeQueryInfo *)v66, (const hknpShape *)v33, targetShapeFilterData, (const hknpShapeQueryInfo *)v57, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<2>
==============
*/
void unwrapScaledConvex<2>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v10; 
  __m256i v11; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  __m256i v16; 
  float m_convexRadius; 
  __m256i v18; 
  const hkTransformf *m_shapeToWorld; 
  float v20; 
  __m128 v31; 
  __int64 v32; 
  __int128 v36; 
  hknpShape_vtbl *v37; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  unsigned __int16 v39[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v42; 
  const hknpShape *v43; 
  const hknpShape *v44; 
  unsigned int v45; 
  hknpShape_vtbl *v46; 
  __int16 v47[2]; 
  int v48; 
  __int64 v49; 
  const hknpBody *v50; 
  const hknpShape *v51; 
  const hknpShape *v52; 
  unsigned int v53; 
  __int64 v54; 
  __m256i v55; 
  __m256i v56; 
  const hknpBody *v57; 
  const hknpShape *v58; 
  const hknpShape *m_parentShape; 
  unsigned int m_value; 
  int m_size; 
  const hkTransformf *v62; 
  __int64 v63; 
  char v64; 
  int v65; 
  float v66; 
  __m256i v67; 
  __int64 v68[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float v71; 
  __m256i v72; 

  v10 = *(__m256i *)query->m_levelOfDetail;
  v11 = *(__m256i *)&query->m_shapeTagCodec;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  _XMM6 = *(_OWORD *)hkMath::hkSse_signMask;
  v68[2] = (__int64)queryShapeInfo->m_parentShape;
  v68[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v68[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v57 = targetShapeInfo->m_body;
  v58 = targetShapeInfo->m_rootShape;
  v55 = v11;
  v16 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  m_parentShape = targetShapeInfo->m_parentShape;
  v72 = v16;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  m_value = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  v71 = m_convexRadius;
  v18 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  v67 = v18;
  v20 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  v62 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v56 = v10;
  v66 = v20;
  v64 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  __asm { vpextrq rcx, xmm2, 1 }
  v68[0] = (__int64)m_body;
  v68[1] = (__int64)m_rootShape;
  v68[5] = 0i64;
  v63 = 0i64;
  v65 = (int)m_shapeToWorld;
  v56.m256i_i64[1] = _RCX;
  _XMM0 = *(__m128 *)(_RCX + 64);
  _mm128_sub_ps(_XMM0, g_vectorfConstants[6]);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vandnps xmm2, xmm6, xmm1
    vpcmpeqd xmm1, xmm0, xmm0
    vblendps xmm4, xmm0, xmm1, 7
    vcmpleps xmm3, xmm2, xmm7
    vpand   xmm0, xmm3, xmm4
    vptest  xmm0, xmm4
  }
  if ( !_CF )
  {
    m_isScaled = 1;
    v72 = *(__m256i *)(_RCX + 64);
    v71 = *(float *)(_RCX + 32);
  }
  v31 = *(__m128 *)&targetShape[1].m_propertyBag.m_bag;
  v32 = *(_QWORD *)(_RCX + 56);
  _mm128_sub_ps(v31, g_vectorfConstants[6]);
  __asm
  {
    vandnps xmm1, xmm6, xmm0
    vcmpleps xmm2, xmm1, xmm7
    vpand   xmm0, xmm2, xmm4
    vptest  xmm0, xmm4
  }
  v56.m256i_i64[1] = v32;
  if ( !_CF )
  {
    v36 = *(_OWORD *)&targetShape[1].m_flags.m_storage;
    v66 = targetShape->m_convexRadius;
    *(_OWORD *)&v67.m256i_u64[2] = v36;
    v64 = 1;
    *(__m128 *)v67.m256i_i8 = v31;
  }
  v37 = targetShape[1].__vftable;
  m_dispatcher = queryContext->m_dispatcher;
  if ( v55.m256i_i64[1] )
  {
    v47[0] = v55.m256i_i16[8];
    v48 = v55.m256i_i32[5];
    v49 = v55.m256i_i64[3];
    v52 = queryShapeInfo->m_parentShape;
    v53 = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
    v39[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v42 = v57;
    v43 = v58;
    v54 = v32;
    v44 = m_parentShape;
    v50 = m_body;
    v45 = m_value;
    v51 = m_rootShape;
    v46 = v37;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)v55.m256i_i64[1] + 32i64))(v55.m256i_i64[1], 4i64, !queryAndTargetSwapped, v47, v39) )
      return;
    v32 = v56.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v32 + 26)][BYTE2(v37->getMutationSignals)](queryContext, (const hknpClosestPointsQuery *)&v55, (const hknpShapeQueryInfo *)v68, (const hknpShape *)v37, targetShapeFilterData, (const hknpShapeQueryInfo *)&v57, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
unwrapScaledConvex<0>
==============
*/
void unwrapScaledConvex<0>(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m256i v10; 
  __m256i v11; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  const hknpShape *m_parentShape; 
  __m256i v18; 
  float m_convexRadius; 
  const hkTransformf *m_shapeToWorld; 
  __m256i v21; 
  float v22; 
  __int64 v33; 
  const hknpCollisionQueryDispatcher *m_dispatcher; 
  unsigned __int16 v35[2]; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  const hknpBody *v38; 
  const hknpShape *v39; 
  const hknpShape *v40; 
  unsigned int v41; 
  const hknpShape *v42; 
  __int16 v43[2]; 
  int v44; 
  __int64 v45; 
  const hknpBody *v46; 
  const hknpShape *v47; 
  const hknpShape *v48; 
  unsigned int v49; 
  __int64 v50; 
  __m256i v51; 
  __m256i v52; 
  __int64 v53[6]; 
  bool m_isScaled; 
  unsigned int m_mode; 
  float v56; 
  __m256i v57; 
  const hknpBody *v58; 
  const hknpShape *v59; 
  const hknpShape *v60; 
  unsigned int m_value; 
  int m_size; 
  const hkTransformf *v63; 
  __int64 v64; 
  char v65; 
  int v66; 
  float v67; 
  __m256i v68; 

  v10 = *(__m256i *)query->m_levelOfDetail;
  v11 = *(__m256i *)&query->m_shapeTagCodec;
  _XMM1 = *(_OWORD *)hkMath::hkSse_signMask;
  m_body = queryShapeInfo->m_body;
  m_rootShape = queryShapeInfo->m_rootShape;
  m_parentShape = queryShapeInfo->m_parentShape;
  v53[3] = (__int64)queryShapeInfo->m_shapeKeyPath;
  v53[4] = (__int64)queryShapeInfo->m_shapeToWorld;
  m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
  m_mode = queryShapeInfo->m_scalingInternals.m_mode;
  v58 = targetShapeInfo->m_body;
  v59 = targetShapeInfo->m_rootShape;
  v60 = targetShapeInfo->m_parentShape;
  v51 = v11;
  v18 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  m_value = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
  v57 = v18;
  m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
  v52 = v10;
  m_size = targetShapeInfo->m_shapeKeyPath.m_size;
  m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
  v56 = m_convexRadius;
  v21 = *(__m256i *)targetShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
  v63 = m_shapeToWorld;
  LOBYTE(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_isScaled;
  v68 = v21;
  v22 = targetShapeInfo->m_scalingInternals.m_convexRadius;
  v65 = (char)m_shapeToWorld;
  LODWORD(m_shapeToWorld) = targetShapeInfo->m_scalingInternals.m_mode;
  __asm { vpextrq rcx, xmm2, 1 }
  v67 = v22;
  v53[0] = (__int64)m_body;
  v53[1] = (__int64)m_rootShape;
  v53[2] = (__int64)m_parentShape;
  v53[5] = 0i64;
  v64 = 0i64;
  v66 = (int)m_shapeToWorld;
  v52.m256i_i64[1] = _RCX;
  _XMM0 = *(__m128 *)(_RCX + 64);
  _mm128_sub_ps(_XMM0, g_vectorfConstants[6]);
  __asm
  {
    vandnps xmm2, xmm1, xmm2
    vcmpleps xmm3, xmm2, xmmword ptr cs:?g_vectorfConstants@@3QBT__m128@@B+260h; __m128 const near * const g_vectorfConstants
    vpxor   xmm0, xmm0, xmm0
    vpcmpeqd xmm1, xmm0, xmm0
    vblendps xmm2, xmm0, xmm1, 7
    vpand   xmm1, xmm3, xmm2
    vptest  xmm1, xmm2
  }
  if ( !_CF )
  {
    m_isScaled = 1;
    v57 = *(__m256i *)(_RCX + 64);
    v56 = *(float *)(_RCX + 32);
  }
  v33 = *(_QWORD *)(_RCX + 56);
  m_dispatcher = queryContext->m_dispatcher;
  v52.m256i_i64[1] = v33;
  if ( v51.m256i_i64[1] )
  {
    v43[0] = v51.m256i_i16[8];
    v44 = v51.m256i_i32[5];
    v45 = v51.m256i_i64[3];
    v49 = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
    v35[0] = targetShapeFilterData->m_materialId.m_value;
    m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
    m_userData = targetShapeFilterData->m_userData;
    v38 = v58;
    v39 = v59;
    v50 = v33;
    v40 = v60;
    v46 = m_body;
    v47 = m_rootShape;
    v41 = m_value;
    v48 = m_parentShape;
    v42 = targetShape;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, bool, __int16 *, unsigned __int16 *))(*(_QWORD *)v51.m256i_i64[1] + 32i64))(v51.m256i_i64[1], 4i64, !queryAndTargetSwapped, v43, v35) )
      return;
    v33 = v52.m256i_i64[1];
  }
  m_dispatcher->m_closestPointsDispatchTable.m_dispatchTable[*(unsigned __int8 *)(v33 + 26)][targetShape->m_type.m_storage](queryContext, (const hknpClosestPointsQuery *)&v51, (const hknpShapeQueryInfo *)v53, targetShape, targetShapeFilterData, (const hknpShapeQueryInfo *)&v58, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher
==============
*/
void HavokPhysics_CollisionQueryDispatcher::HavokPhysics_CollisionQueryDispatcher(HavokPhysics_CollisionQueryDispatcher *this)
{
  hknpCollisionQueryDispatcher::DispatchTable<void (__cdecl*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)> *p_m_shapeCastDispatchTable; 
  int v3; 
  int i; 
  int j; 
  int v6; 
  __int64 v7; 
  const hknpShapeType::Enum *m_baseTypeMap; 
  int v9; 
  __int64 v10; 
  const hknpShapeType::Enum *v11; 
  int v12; 
  __int64 v13; 
  const hknpShapeType::Enum *v14; 
  int v15; 
  __int64 v16; 
  const hknpShapeType::Enum *v17; 
  int v18; 
  __int64 v19; 
  const hknpShapeType::Enum *v20; 
  int v21; 
  __int64 v22; 
  const hknpShapeType::Enum *v23; 
  int v24; 
  __int64 v25; 
  int v26; 
  __int64 v27; 
  const hknpShapeType::Enum *v28; 
  __int64 v29; 
  const hknpShapeType::Enum *v30; 

  hknpCollisionQueryDispatcher::hknpCollisionQueryDispatcher(this, INITIALIZE_TABLES);
  this->__vftable = (HavokPhysics_CollisionQueryDispatcher_vtbl *)&HavokPhysics_CollisionQueryDispatcher::`vftable';
  HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable(this, 0xFFFFFFFF);
  p_m_shapeCastDispatchTable = &this->m_shapeCastDispatchTable;
  this->m_defaultShapeCastFunc = this->m_shapeCastDispatchTable.m_dispatchTable[1][0];
  v3 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 7; ++j )
      hknpCollisionQueryDispatcher::setShapeCastFunction(this, (hknpShapeType::Enum)i, (hknpShapeType::Enum)j, HavokPhysics_CollisionQueryDispatcher::castShapeConvex, "IW castShapeConvex", 0xFFFFFFFF);
  }
  this->m_preScaledCvxClosestPointTable[2][3] = hknpConvexShapeUtil::getClosestPointsGsk;
  v6 = 0;
  v7 = 0i64;
  do
  {
    m_baseTypeMap = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( m_baseTypeMap[v7] == NOP )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v6, USER_7|DISTANCE_FIELD, HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile, "HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile", 0xFFFFFFFF, 1);
      m_baseTypeMap = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( m_baseTypeMap[v7] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, NOP, (hknpShapeType::Enum)v6, HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile, "HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile", 0xFFFFFFFF, 1);
    ++v6;
    ++v7;
  }
  while ( v6 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[0][22] = HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile;
  v9 = 0;
  v10 = 0i64;
  do
  {
    v11 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v11[v10] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v9, NOP, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile>", 0xFFFFFFFF, 1);
      v11 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v11[v10] == NOP )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v9, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile>", 0xFFFFFFFF, 1);
    ++v9;
    ++v10;
  }
  while ( v9 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[22][0] = HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile_;
  v12 = 0;
  v13 = 0i64;
  do
  {
    v14 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v14[v13] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v12, SHAPE_KEY_ARRAY, HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape, "HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape", 0xFFFFFFFF, 1);
      v14 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v14[v13] == SHAPE_KEY_ARRAY )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v12, HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape, "HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape", 0xFFFFFFFF, 1);
    ++v12;
    ++v13;
  }
  while ( v12 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[22][8] = HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape;
  v15 = 0;
  v16 = 0i64;
  do
  {
    v17 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v17[v16] == SHAPE_KEY_ARRAY )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v15, USER_7|DISTANCE_FIELD, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape>", 0xFFFFFFFF, 1);
      v17 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v17[v16] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, (hknpShapeType::Enum)v15, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape>", 0xFFFFFFFF, 1);
    ++v15;
    ++v16;
  }
  while ( v15 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[8][22] = HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape_;
  v18 = 0;
  v19 = 0i64;
  do
  {
    v20 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v20[v19] == USER_7 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v18, USER_7|DISTANCE_FIELD, HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape, "HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape", 0xFFFFFFFF, 1);
      v20 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v20[v19] == (USER_7|DISTANCE_FIELD) )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7, (hknpShapeType::Enum)v18, HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape, "HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape", 0xFFFFFFFF, 1);
    ++v18;
    ++v19;
  }
  while ( v18 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[16][22] = HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape;
  v21 = 0;
  v22 = 0i64;
  do
  {
    v23 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    if ( v23[v22] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, (hknpShapeType::Enum)v21, USER_7, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape>", 0xFFFFFFFF, 1);
      v23 = this->m_closestPointsDispatchTable.hknpCollisionQueryDispatcher::m_baseTypeMap;
    }
    if ( v23[v22] == USER_7 )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v21, HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape_, "HavokPhysics_CollisionQueryDispatcher_flip<HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape>", 0xFFFFFFFF, 1);
    ++v21;
    ++v22;
  }
  while ( v21 < 30 );
  this->m_closestPointsDispatchTable.m_dispatchTable[22][16] = HavokPhysics_CollisionQueryDispatcher_flip__HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape_;
  v24 = 0;
  v25 = 0i64;
  do
  {
    v26 = 0;
    v27 = 0i64;
    do
    {
      v28 = p_m_shapeCastDispatchTable->m_baseTypeMap;
      if ( p_m_shapeCastDispatchTable->m_baseTypeMap[v27] == v24 )
      {
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, (hknpShapeType::Enum)v26, USER_7|DISTANCE_FIELD, hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>, "castShapeFunc<StaticModels_HavokShape>", 0xFFFFFFFF, 1);
        v28 = p_m_shapeCastDispatchTable->m_baseTypeMap;
      }
      if ( v28[v27] == (USER_7|DISTANCE_FIELD) )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, (hknpShapeType::Enum)v24, (hknpShapeType::Enum)v26, hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>, "castShapeFunc<StaticModels_HavokShape>", 0xFFFFFFFF, 1);
      ++v26;
      ++v27;
    }
    while ( v26 < 30 );
    p_m_shapeCastDispatchTable->m_dispatchTable[v25][22] = hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>;
    ++v24;
    ++v25;
  }
  while ( v24 < 30 );
  v29 = 0i64;
  do
  {
    v30 = p_m_shapeCastDispatchTable->m_baseTypeMap;
    if ( p_m_shapeCastDispatchTable->m_baseTypeMap[v29] == (USER_7|DISTANCE_FIELD) )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, (hknpShapeType::Enum)v3, NOP, hknpShapeCastFuncs::flip<&void hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>, "flip<castShapeFunc<StaticModels_HavokShape> >", 0xFFFFFFFF, 1);
      v30 = p_m_shapeCastDispatchTable->m_baseTypeMap;
    }
    if ( v30[v29] == NOP )
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>::_registerImpl(p_m_shapeCastDispatchTable, USER_7|DISTANCE_FIELD, (hknpShapeType::Enum)v3, hknpShapeCastFuncs::flip<&void hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>, "flip<castShapeFunc<StaticModels_HavokShape> >", 0xFFFFFFFF, 1);
    ++v3;
    ++v29;
  }
  while ( v3 < 30 );
  this->m_shapeCastDispatchTable.m_dispatchTable[22][0] = hknpShapeCastFuncs::flip<&void hknpShapeCastFuncs::castShapeFunc<StaticModels_HavokShape>(hknpCollisionQueryContext *,hknpShapeCastQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *,hknpCollisionQueryCollector *)>;
}

/*
==============
HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile
==============
*/
void HavokPhysics_CollisionQueryDispatcher_ConvexVsStaticModelsTile(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  StaticModels_HavokShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const StaticModels_HavokShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape
==============
*/
void HavokPhysics_CollisionQueryDispatcher_ParticlesVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __int64 v11; 
  __int64 v12; 
  const hknpShape *v13; 
  __int64 v14; 
  signed int v15; 
  __int64 v16; 
  signed int v17; 
  int v18; 
  __int64 v19; 
  int v20; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  hkTransformf v25; 
  void (__fastcall *const *v26)(); 
  __int64 v27; 
  hknpSphereShape *v28; 
  int v29; 
  hknpSphereShape v30[2]; 
  hkTransformf v31; 

  v11 = *(_QWORD *)&query->m_shape[1].m_memSizeAndFlags;
  if ( *(_BYTE *)(v11 + 5504) )
  {
    v12 = 0i64;
    v27 = 0i64;
    v28 = v30;
    v29 = 128;
    v26 = hknpInplaceShapeBuffer<128>::`vftable';
    v13 = NULL;
    if ( *(_DWORD *)query->m_levelOfDetail == 3 )
    {
      hknpSphereShape::hknpSphereShape(v30, (const hkVector4f *)&g_vectorfConstants[5], 0.0);
      v12 = v14;
      *(_WORD *)(v14 + 16) = 0;
      v27 = v14;
      v13 = (const hknpShape *)v14;
    }
    v15 = 0;
    v20 = *(_DWORD *)(v11 + 5492);
    if ( v20 )
    {
      v16 = 0i64;
      do
      {
        if ( *(_BYTE *)(v11 + 5696) )
          v17 = *(_DWORD *)(v16 + *(_QWORD *)(v11 + 5728));
        else
          v17 = v15;
        v25.m_translation = *(hkVector4f *)(*(_QWORD *)(v11 + 304) + 32i64 * v17);
        if ( *(_BYTE *)(v11 + 5500) )
          hkRotationImpl<float>::set(&v25.m_rotation, (const hkQuaternionf *)(*(_QWORD *)(v11 + 320) + 16i64 * v17));
        else
          v25.m_rotation = *(hkRotationImpl<float> *)g_vectorfConstants[32].m128_f32;
        queryShapeInfoa.m_body = queryShapeInfo->m_body;
        queryShapeInfoa.m_rootShape = queryShapeInfo->m_rootShape;
        queryShapeInfoa.m_shapeKeyMask = NULL;
        queryShapeInfoa.m_scalingInternals.m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
        queryShapeInfoa.m_scalingInternals.m_mode = queryShapeInfo->m_scalingInternals.m_mode;
        *(__m256i *)queryShapeInfoa.m_scalingInternals.m_scale.m_quad.m128_f32 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
        queryShapeInfoa.m_scalingInternals.m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
        queryShapeInfoa.m_parentShape = query->m_shape;
        queryShapeInfoa.m_shapeToWorld = &v25;
        queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v17;
        queryShapeInfoa.m_shapeKeyPath.m_size = 32;
        hkTransformf::setMul(&v31, queryToTarget, &v25);
        querya = *query;
        if ( *(_DWORD *)query->m_levelOfDetail == 3 )
        {
          if ( *(_DWORD *)(v11 + 48) )
            v18 = *(_DWORD *)(v17 * *(_DWORD *)(v11 + 52) + *(_QWORD *)(v11 + 40));
          else
            v18 = *(_DWORD *)(v11 + 32);
          v13->m_convexRadius = COERCE_FLOAT(*(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 24) + 24i64) + 8i64 * v18) + 32i64));
          querya.m_shape = v13;
        }
        else
        {
          if ( *(_DWORD *)(v11 + 48) )
            v19 = *(int *)(v17 * *(_DWORD *)(v11 + 52) + *(_QWORD *)(v11 + 40));
          else
            v19 = *(int *)(v11 + 32);
          querya.m_shape = *(const hknpShape **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 24) + 24i64) + 8 * v19) + 240i64);
        }
        hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v31, queryAndTargetSwapped, collector);
        ++v15;
        v16 += 4i64;
      }
      while ( v15 != v20 );
      v12 = v27;
    }
    v26 = hknpShapeBuffer::`vftable';
    if ( v12 )
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v12 + 8i64))(v12, 0i64);
  }
}

/*
==============
HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape
==============
*/
void HavokPhysics_CollisionQueryDispatcher_StaticModelsTileVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m128 v9; 
  const hknpShape *m_shape; 
  int v11; 
  unsigned int v13; 
  __m256i v14; 
  __int64 v15; 
  bool m_isScaled; 
  __m128 m_convexRadius_low; 
  __int64 v18; 
  hkVector4f v19; 
  double CollisionTileModelInstanceScale; 
  bool v21; 
  hkVector4f v22; 
  double v23; 
  hknpShape::ScaleMode m_mode; 
  float *v25; 
  const hkTransformf *m_shapeToWorld; 
  __m128 m_quad; 
  const hknpShape *CollisionTileModelShape; 
  __int64 m_size; 
  const hknpShape *v32; 
  unsigned int v33; 
  __m256i v34; 
  const hknpShapeTagCodec *m_shapeTagCodec; 
  const hknpShape *m_rootShape; 
  const hknpBody *m_body; 
  void (__fastcall *decode)(hknpShapeTagCodec *, unsigned __int16, hknpCollisionQueryType::Enum, const hknpBody *, const hknpShape *, const hknpShape *, hkHandle<unsigned int,4294967295,hknpShapeKeyDiscriminant>, const hknpShape *, hknpQueryFilterData *); 
  unsigned __int16 CollisionTileModelShapeTag; 
  unsigned int v40; 
  int v41; 
  const hknpShape *v42; 
  const hknpShape *v44; 
  const hknpShapeTagCodec *v45; 
  hknpQueryFilterData m_filterData; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  vec3_t origin; 
  hkTransformf v52; 
  vec4_t orientationAsQuat; 
  hkQuaternionf qi; 
  __int128 v55[3]; 
  __m128 v56; 
  hkTransformf v57; 
  __m128 v58; 

  m_shape = query->m_shape;
  v11 = 0;
  v13 = *(_DWORD *)&m_shape[1].m_memSizeAndFlags;
  v42 = m_shape;
  if ( SLODWORD(m_shape[1].m_convexRadius) > 0 )
  {
    v58 = v9;
    while ( 1 )
    {
      v14 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
      v15 = *(_QWORD *)&m_shape[1].m_flags.m_storage;
      queryShapeInfoa.m_body = queryShapeInfo->m_body;
      queryShapeInfoa.m_rootShape = queryShapeInfo->m_rootShape;
      queryShapeInfoa.m_parentShape = queryShapeInfo->m_parentShape;
      queryShapeInfoa.m_shapeKeyPath = queryShapeInfo->m_shapeKeyPath;
      queryShapeInfoa.m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
      m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
      *(__m256i *)queryShapeInfoa.m_scalingInternals.m_scale.m_quad.m128_f32 = v14;
      m_convexRadius_low = (__m128)LODWORD(queryShapeInfo->m_scalingInternals.m_convexRadius);
      queryShapeInfoa.m_scalingInternals.m_isScaled = m_isScaled;
      queryShapeInfoa.m_scalingInternals.m_mode = queryShapeInfo->m_scalingInternals.m_mode;
      queryShapeInfoa.m_scalingInternals.m_convexRadius = m_convexRadius_low.m128_f32[0];
      queryShapeInfoa.m_shapeKeyMask = NULL;
      v18 = (unsigned __int16)v11;
      *(double *)m_convexRadius_low.m128_u64 = StaticModels_GetCollisionTileModelInstanceScale(v13, *(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x3FFF, *(unsigned __int16 *)(v15 + 4i64 * (unsigned __int16)v11 + 2));
      v19.m_quad = _mm_shuffle_ps(m_convexRadius_low, m_convexRadius_low, 0);
      CollisionTileModelInstanceScale = StaticModels_GetCollisionTileModelInstanceScale(v13, *(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x3FFF, *(unsigned __int16 *)(v15 + 4i64 * (unsigned __int16)v11 + 2));
      StaticModels_GetCollisionTileModelInstanceTransform(v13, *(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x3FFF, *(unsigned __int16 *)(v15 + 4i64 * (unsigned __int16)v11 + 2), &origin, &orientationAsQuat);
      *(__m256i *)v52.m_rotation.m_col0.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[32].m128_f32;
      *(__m256i *)v52.m_rotation.m_col2.m_quad.m128_f32 = *(__m256i *)g_vectorfConstants[34].m128_f32;
      qi.m_vec.m_quad = (__m128)orientationAsQuat;
      hkRotationImpl<float>::set(&v52.m_rotation, &qi);
      v21 = !queryShapeInfo->m_scalingInternals.m_isScaled;
      v52.m_translation.m_quad.m128_f32[0] = 0.03125 * origin.v[0];
      v52.m_translation.m_quad.m128_f32[1] = 0.03125 * origin.v[1];
      v52.m_translation.m_quad.m128_f32[2] = 0.03125 * origin.v[2];
      v52.m_translation.m_quad.m128_f32[3] = 0.0;
      if ( !v21 )
        break;
      if ( *(float *)&CollisionTileModelInstanceScale != 1.0 )
        goto LABEL_6;
LABEL_11:
      hkTransformf::setMul(&v57, queryToTarget, &v52);
      m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
      _YMM8 = *(__m256i *)m_shapeToWorld->m_rotation.m_col0.m_quad.m128_f32;
      m_quad = m_shapeToWorld->m_rotation.m_col2.m_quad;
      __asm { vextractf128 xmm7, ymm8, 1 }
      v55[2] = (__int128)_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col2.m_quad, v52.m_rotation.m_col2.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col2.m_quad, v52.m_rotation.m_col2.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col2.m_quad, v52.m_rotation.m_col2.m_quad, 170), m_quad));
      v55[1] = (__int128)_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col1.m_quad, v52.m_rotation.m_col1.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col1.m_quad, v52.m_rotation.m_col1.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col1.m_quad, v52.m_rotation.m_col1.m_quad, 170), m_quad));
      v56 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v52.m_translation.m_quad, v52.m_translation.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(v52.m_translation.m_quad, v52.m_translation.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(v52.m_translation.m_quad, v52.m_translation.m_quad, 170), m_quad));
      v55[0] = (__int128)_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col0.m_quad, v52.m_rotation.m_col0.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col0.m_quad, v52.m_rotation.m_col0.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(v52.m_rotation.m_col0.m_quad, v52.m_rotation.m_col0.m_quad, 170), m_quad));
      v56 = _mm128_add_ps(v56, m_shapeToWorld->m_translation.m_quad);
      CollisionTileModelShape = (const hknpShape *)StaticModels_GetCollisionTileModelShape((*(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x4000) != 0, v13, *(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x3FFF);
      m_size = queryShapeInfoa.m_shapeKeyPath.m_size;
      v32 = CollisionTileModelShape;
      v44 = CollisionTileModelShape;
      ++v11;
      queryShapeInfoa.m_shapeKeyPath.m_size += m_shape->m_numShapeKeyBits;
      v41 = v11;
      v33 = queryShapeInfoa.m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((v11 << (32 - LOBYTE(queryShapeInfoa.m_shapeKeyPath.m_size))) - 1);
      queryShapeInfoa.m_shapeToWorld = (const hkTransformf *)v55;
      v40 = v33;
      queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v33;
      v34 = *(__m256i *)&query->m_shapeTagCodec;
      m_shapeTagCodec = query->m_shapeTagCodec;
      v45 = m_shapeTagCodec;
      *(__m256i *)querya.m_levelOfDetail = *(__m256i *)query->m_levelOfDetail;
      querya.m_shape = v32;
      *(__m256i *)&querya.m_shapeTagCodec = v34;
      if ( m_shapeTagCodec )
      {
        m_rootShape = queryShapeInfo->m_rootShape;
        m_body = queryShapeInfo->m_body;
        m_filterData = querya.m_filterData;
        decode = m_shapeTagCodec->decode;
        CollisionTileModelShapeTag = StaticModels_GetCollisionTileModelShapeTag((*(_WORD *)(v15 + 4 * v18) & 0x4000) != 0, v13, *(_WORD *)(v15 + 4 * v18) & 0x3FFF);
        ((void (__fastcall *)(const hknpShapeTagCodec *, _QWORD, __int64, const hknpBody *, const hknpShape *, const hknpShape *, unsigned int, const hknpShape *, hknpQueryFilterData *))decode)(v45, CollisionTileModelShapeTag, 4i64, m_body, m_rootShape, v42, v40, v44, &m_filterData);
        m_shape = v42;
        v11 = v41;
        querya.m_filterData.m_collisionFilterInfo = m_filterData.m_collisionFilterInfo;
        querya.m_filterData.m_materialId.m_value = m_filterData.m_materialId.m_value;
      }
      hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v57, queryAndTargetSwapped, collector);
      if ( v11 >= SLODWORD(m_shape[1].m_convexRadius) )
        return;
    }
    v22.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_scale;
    v19.m_quad = _mm128_mul_ps(v19.m_quad, v22.m_quad);
    v52.m_translation.m_quad = _mm128_mul_ps(v22.m_quad, v52.m_translation.m_quad);
LABEL_6:
    queryShapeInfoa.m_scalingInternals.m_isScaled = 1;
    queryShapeInfoa.m_scalingInternals.m_scale = (hkVector4f)v19.m_quad;
    queryShapeInfoa.m_scalingInternals.m_offset = 0i64;
    v23 = StaticModels_GetCollisionTileModelInstanceScale(v13, *(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x3FFF, *(unsigned __int16 *)(v15 + 4i64 * (unsigned __int16)v11 + 2));
    if ( *(float *)&v23 == 1.0 )
      m_mode = queryShapeInfo->m_scalingInternals.m_mode;
    else
      m_mode = SCALE_SURFACE;
    queryShapeInfoa.m_scalingInternals.m_mode = m_mode;
    v25 = (float *)StaticModels_GetCollisionTileModelShape((*(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x4000) != 0, v13, *(_WORD *)(v15 + 4i64 * (unsigned __int16)v11) & 0x3FFF);
    queryShapeInfoa.m_scalingInternals.m_convexRadius = v25[8];
    if ( ((_BYTE)v25[6] & 1) != 0 )
      hknpShapeUtil::calcScalingParameters((hknpShapeType::Enum)*((unsigned __int8 *)v25 + 26), (const hkcdVertex *)((char *)v25 + *((unsigned __int16 *)v25 + 30) + 58), *((unsigned __int16 *)v25 + 29), m_mode, &queryShapeInfoa.m_scalingInternals.m_scale, &queryShapeInfoa.m_scalingInternals.m_convexRadius, &queryShapeInfoa.m_scalingInternals.m_offset);
    goto LABEL_11;
  }
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::castShapeConvex
==============
*/
void HavokPhysics_CollisionQueryDispatcher::castShapeConvex(hknpCollisionQueryContext *queryContext, const hknpShapeCastQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *targetTquery, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector, hknpCollisionQueryCollector *startCollector)
{
  unsigned int *m_userData; 
  const hknpCollisionFilter *m_filter; 
  char v13; 
  __int64 m_shape; 
  _BYTE *v15; 
  hkMemoryRouter *Value; 
  __int64 v17; 
  _OWORD *m_cur; 
  char *v19; 
  hkVector4f v20; 
  hkVector4f v21; 
  __int64 v22; 
  _OWORD *v23; 
  signed __int64 v24; 
  const hkcdVertex *v27; 
  int v28; 
  hkMemoryRouter *v29; 
  __int64 v30; 
  _OWORD *v31; 
  char *v32; 
  hkVector4f v33; 
  hkVector4f v34; 
  __int64 v35; 
  _OWORD *v36; 
  signed __int64 v37; 
  int Ref; 
  bool RefDetailFlag; 
  __m128 v43; 
  bool v44; 
  unsigned __int8 v49; 
  int v52; 
  unsigned int v53; 
  __m128 v55; 
  __m128 v62; 
  const hkTransformf *m_shapeToWorld; 
  unsigned int m_serialAndIndex; 
  unsigned int v66; 
  const hkTransformf *v70; 
  unsigned int v71; 
  int m_numVertices; 
  hkcdVertex *m_vertices; 
  hkMemoryRouter *v74; 
  signed int v75; 
  int v76; 
  int v77; 
  char *v78; 
  hkMemoryRouter *v79; 
  signed int v80; 
  int v81; 
  bool v82; 
  int v83; 
  int v84; 
  hknpConvexShape *queryShape; 
  __m128 v89; 
  __m128 v90; 
  float v91; 
  unsigned int v92; 
  __int64 v93; 
  unsigned __int16 m_value; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 v96; 
  unsigned int v97; 
  __int64 v98; 
  unsigned __int16 v99; 
  unsigned int v100; 
  unsigned __int64 v101; 
  __int64 v102; 
  int m_storage; 
  void *p; 
  int v105; 
  float m_convexRadius; 
  __int64 v107; 
  char v108; 
  hknpScaledConvexVertexShape targetVerts; 
  __m128 v110; 
  __m128 v111; 
  __m128 v112; 
  __m256i v113; 
  __m256i v114; 

  _RDI = query;
  m_userData = NULL;
  m_filter = query->m_filter;
  if ( m_filter && m_filter->m_type.m_storage == 6 && (m_userData = (unsigned int *)query->m_filterData.m_userData) != NULL && *((_QWORD *)m_userData + 3) && !Physics_GetBrushBasisFromUserData(targetShapeFilterData->m_userData) )
  {
    v13 = 1;
  }
  else
  {
    v13 = 0;
    if ( m_userData && *((_QWORD *)m_userData + 4) )
    {
      queryShape = (hknpConvexShape *)_RDI->m_shape;
      goto LABEL_8;
    }
  }
  queryShape = NULL;
LABEL_8:
  if ( !m_userData || (m_shape = *((_QWORD *)m_userData + 4)) == 0 )
    m_shape = (__int64)_RDI->m_shape;
  if ( v13 )
    m_shape = *((_QWORD *)m_userData + 3);
  m_storage = hknpConvexDispatch::s_shapeTypeToCvxDispatch[*(unsigned __int8 *)(m_shape + 26)].m_disptach.m_storage;
  m_convexRadius = *(float *)(m_shape + 32);
  v107 = m_shape;
  v108 = 0;
  v15 = (_BYTE *)(m_shape + 58 + *(unsigned __int16 *)(m_shape + 60));
  v83 = *(unsigned __int16 *)(m_shape + 58);
  if ( queryShapeInfo->m_scalingInternals.m_isScaled )
  {
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v17 = (16 * v83 + 127) & 0xFFFFFF80;
    m_cur = Value->m_stack.m_cur;
    v19 = (char *)m_cur + v17;
    if ( (int)v17 > Value->m_stack.m_slabSize || v19 > Value->m_stack.m_end )
      m_cur = hkLifoAllocator::allocateFromNewSlab(&Value->m_stack, v17);
    else
      Value->m_stack.m_cur = v19;
    v20.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_offset;
    v21.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_scale;
    v22 = v83;
    if ( v83 )
    {
      v23 = m_cur;
      v24 = v15 - (_BYTE *)m_cur;
      do
      {
        _XMM1 = _mm128_add_ps(_mm128_mul_ps(v21.m_quad, *(__m128 *)((char *)v23 + v24)), v20.m_quad);
        __asm { vblendps xmm0, xmm1, xmmword ptr [rsi+rcx], 8 }
        *v23++ = _XMM0;
        --v22;
      }
      while ( v22 );
    }
    v15 = m_cur;
    m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
    v108 = 1;
  }
  p = v15;
  v105 = v83;
  targetVerts.m_type = hknpConvexDispatch::s_shapeTypeToCvxDispatch[targetShape->m_type.m_storage].m_disptach.m_storage;
  targetVerts.m_convexRadius = targetShape->m_convexRadius;
  targetVerts.m_shape = (const hknpConvexShape *)targetShape;
  targetVerts.m_isScaled = 0;
  v27 = (const hkcdVertex *)((char *)&targetShape[1].__vftable + WORD2(targetShape[1].__vftable) + 2);
  v28 = WORD1(targetShape[1].__vftable);
  v84 = v28;
  if ( targetShapeInfo->m_scalingInternals.m_isScaled )
  {
    v29 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v29 )
      v29 = hkMemoryRouter::s_fallbackRouter;
    v30 = (16 * v84 + 127) & 0xFFFFFF80;
    v31 = v29->m_stack.m_cur;
    v32 = (char *)v31 + v30;
    if ( (int)v30 > v29->m_stack.m_slabSize || v32 > v29->m_stack.m_end )
      v31 = hkLifoAllocator::allocateFromNewSlab(&v29->m_stack, v30);
    else
      v29->m_stack.m_cur = v32;
    v33.m_quad = (__m128)targetShapeInfo->m_scalingInternals.m_offset;
    v34.m_quad = (__m128)targetShapeInfo->m_scalingInternals.m_scale;
    v35 = v84;
    if ( v84 )
    {
      v36 = v31;
      v37 = (char *)v27 - (char *)v31;
      do
      {
        _XMM1 = _mm128_add_ps(_mm128_mul_ps(v34.m_quad, *(__m128 *)((char *)v36 + v37)), v33.m_quad);
        __asm { vblendps xmm0, xmm1, xmmword ptr [rsi+rcx], 8 }
        *v36++ = _XMM0;
        --v35;
      }
      while ( v35 );
    }
    v27 = (const hkcdVertex *)v31;
    targetVerts.m_convexRadius = targetShapeInfo->m_scalingInternals.m_convexRadius;
    targetVerts.m_isScaled = 1;
    v28 = v84;
  }
  targetVerts.m_vertices = v27;
  targetVerts.m_numVertices = v28;
  if ( targetShapeInfo->m_body )
    Ref = HavokPhysics_GetRef(targetShapeInfo->m_body);
  else
    Ref = 0;
  RefDetailFlag = Physics_GetRefDetailFlag(Ref);
  _XMM1 = 0i64;
  if ( m_userData )
  {
    v43 = (__m128)*m_userData;
    if ( *((_BYTE *)m_userData + 44) && !RefDetailFlag )
    {
      v44 = 1;
      goto LABEL_47;
    }
  }
  else
  {
    v43 = 0i64;
  }
  v44 = 0;
LABEL_47:
  v82 = v44;
  __asm
  {
    vcmpltss xmm0, xmm1, dword ptr [r15+20h]
    vblendvps xmm2, xmm1, xmm10, xmm0
  }
  m_convexRadius = *(float *)&_XMM2 + m_convexRadius;
  _R8 = queryContext;
  if ( startCollector )
    _XMM9 = 0i64;
  else
    __asm { vbroadcastss xmm9, dword ptr [r8+18h] }
  v49 = collector->m_hints.m_storage;
  v112 = g_vectorfConstants[36];
  __asm
  {
    vbroadcastss xmm13, dword ptr [rdi+60h]
    vbroadcastss xmm14, dword ptr [rdi+68h]
  }
  v113 = *(__m256i *)targetTquery->m_rotation.m_col0.m_quad.m128_f32;
  v114 = *(__m256i *)targetTquery->m_rotation.m_col2.m_quad.m128_f32;
  *(__m128 *)&v114.m256i_u64[2] = _mm128_add_ps(_mm128_mul_ps(_XMM9, _RDI->m_ray.m_direction.m_quad), targetTquery->m_translation.m_quad);
  if ( !queryShape || castShapeConvexFirstPass(v44, queryShape, queryContext, _RDI, queryShapeInfo, &targetVerts, targetShapeFilterData, targetShapeInfo, targetTquery, queryAndTargetSwapped, collector, startCollector) )
  {
    v52 = 0;
    v53 = 0xFFFFFF;
    while ( ((unsigned __int8 (__fastcall *)(int *, hknpScaledConvexVertexShape *, __m256i *, _QWORD, __m128 *))queryContext->m_dispatcher->m_preScaledCvxClosestPointTable[m_storage][targetVerts.m_type])(&m_storage, &targetVerts, &v113, v49, &v110) )
    {
      __asm { vbroadcastss xmm3, dword ptr [rdi+64h] }
      v55 = _mm128_sub_ps(v112, _XMM3);
      _XMM4 = _RDI->m_ray.m_direction.m_quad;
      __asm
      {
        vdpps   xmm0, xmm4, xmm4, 7Fh
        vcmpleps xmm3, xmm0, xmm11
        vrsqrtps xmm1, xmm0
      }
      _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_XMM1, _mm128_mul_ps(_XMM1, _XMM0))), _mm128_mul_ps(_XMM1, *(__m128 *)hkMath::hkSse_floatHalf));
      __asm { vandnps xmm0, xmm3, xmm2 }
      _XMM1 = _mm128_mul_ps(_XMM4, _XMM0);
      v62 = v111;
      __asm { vdpps   xmm2, xmm1, xmm7, 7Fh }
      if ( (v82 || v55.m128_f32[0] >= _mm_shuffle_ps((__m128)(*(_OWORD *)&v43 ^ (unsigned int)_xmm), (__m128)(*(_OWORD *)&v43 ^ (unsigned int)_xmm), 0).m128_f32[0]) && *(float *)&_XMM2 >= -0.000001 )
        break;
      if ( !queryShape && !v52 && startCollector && _mm128_sub_ps(_XMM14, _mm_shuffle_ps(v43, v43, 0)).m128_f32[0] >= v55.m128_f32[0] )
      {
        v89 = 0i64;
        v90 = 0i64;
        v91 = FLOAT_3_40282e38;
        v92 = 0xFFFFFF;
        v93 = -1i64;
        m_value = -1;
        m_collisionFilterInfo = 0;
        v96 = 0i64;
        v97 = 0xFFFFFF;
        v98 = -1i64;
        v99 = -1;
        v100 = 0;
        v101 = 0i64;
        v102 = 4i64;
        m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
        v89 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v110, v110, 170), m_shapeToWorld->m_rotation.m_col2.m_quad), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v110, v110, 85), m_shapeToWorld->m_rotation.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v110, v110, 0), m_shapeToWorld->m_rotation.m_col0.m_quad))), m_shapeToWorld->m_translation.m_quad);
        v90 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v111, v111, 170), m_shapeToWorld->m_rotation.m_col2.m_quad), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v111, v111, 85), m_shapeToWorld->m_rotation.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v111, v111, 0), m_shapeToWorld->m_rotation.m_col0.m_quad)));
        v91 = v55.m128_f32[0] + v43.m128_f32[0];
        if ( queryShapeInfo->m_body )
          m_serialAndIndex = queryShapeInfo->m_body->m_id.m_serialAndIndex;
        else
          m_serialAndIndex = 0xFFFFFF;
        v92 = m_serialAndIndex;
        LODWORD(v93) = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
        m_value = _RDI->m_filterData.m_materialId.m_value;
        m_collisionFilterInfo = _RDI->m_filterData.m_collisionFilterInfo;
        v96 = _RDI->m_filterData.m_userData;
        if ( targetShapeInfo->m_body )
          v66 = targetShapeInfo->m_body->m_id.m_serialAndIndex;
        else
          v66 = 0xFFFFFF;
        v97 = v66;
        LODWORD(v98) = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
        v99 = targetShapeFilterData->m_materialId.m_value;
        v100 = targetShapeFilterData->m_collisionFilterInfo;
        v101 = targetShapeFilterData->m_userData;
        HIDWORD(v98) = *(_DWORD *)_RDI->m_levelOfDetail;
        startCollector->addHit(startCollector, (const hknpCollisionResult *)&v89);
        v62 = v111;
      }
      if ( *(float *)&_XMM13 >= v55.m128_f32[0] )
      {
        v102 = 2i64;
        v70 = targetShapeInfo->m_shapeToWorld;
        v89 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v110, v110, 170), v70->m_rotation.m_col2.m_quad), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v110, v110, 85), v70->m_rotation.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v110, v110, 0), v70->m_rotation.m_col0.m_quad))), v70->m_translation.m_quad);
        v90 = _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v62, v62, 170), v70->m_rotation.m_col2.m_quad), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v62, v62, 85), v70->m_rotation.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v62, v62, 0), v70->m_rotation.m_col0.m_quad)));
        v91 = _XMM9.m128_f32[0];
        if ( queryShapeInfo->m_body )
          v71 = queryShapeInfo->m_body->m_id.m_serialAndIndex;
        else
          v71 = 0xFFFFFF;
        v92 = v71;
        LODWORD(v93) = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
        m_value = _RDI->m_filterData.m_materialId.m_value;
        m_collisionFilterInfo = _RDI->m_filterData.m_collisionFilterInfo;
        v96 = _RDI->m_filterData.m_userData;
        HIDWORD(v93) = -1;
        if ( targetShapeInfo->m_body )
          v53 = targetShapeInfo->m_body->m_id.m_serialAndIndex;
        v97 = v53;
        LODWORD(v98) = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
        v99 = targetShapeFilterData->m_materialId.m_value;
        v100 = targetShapeFilterData->m_collisionFilterInfo;
        v101 = targetShapeFilterData->m_userData;
        HIDWORD(v98) = *(_DWORD *)_RDI->m_levelOfDetail;
        collector->addHit(collector, (const hknpCollisionResult *)&v89);
        break;
      }
      _XMM3 = _RDI->m_ray.m_direction.m_quad;
      __asm { vdpps   xmm0, xmm3, xmm7, 7Fh }
      if ( _XMM0.m128_f32[0] < 0.0 )
      {
        __asm { vrcpps  xmm2, xmm0 }
        _XMM9 = _mm128_sub_ps(_XMM9, _mm128_mul_ps(_mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM2, _XMM0)), _XMM2), v55));
        if ( COERCE_FLOAT(*(_OWORD *)&collector->m_earlyOutThreshold) >= _XMM9.m128_f32[0] )
        {
          *(__m128 *)&v114.m256i_u64[2] = _mm128_add_ps(_mm128_mul_ps(_XMM9, _XMM3), targetTquery->m_translation.m_quad);
          if ( ++v52 < 256 )
            continue;
        }
      }
      break;
    }
  }
  if ( targetVerts.m_isScaled )
  {
    m_numVertices = targetVerts.m_numVertices;
    m_vertices = (hkcdVertex *)targetVerts.m_vertices;
    v74 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v74 )
      v74 = hkMemoryRouter::s_fallbackRouter;
    v75 = (16 * m_numVertices + 127) & 0xFFFFFF80;
    v76 = (v75 + 15) & 0xFFFFFFF0;
    if ( v75 > v74->m_stack.m_slabSize || (char *)m_vertices + v76 != v74->m_stack.m_cur || v74->m_stack.m_firstNonLifoEnd == m_vertices )
      hkLifoAllocator::slowBlockFree(&v74->m_stack, m_vertices, v76);
    else
      v74->m_stack.m_cur = m_vertices;
  }
  if ( v108 )
  {
    v77 = v105;
    v78 = (char *)p;
    v79 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v79 )
      v79 = hkMemoryRouter::s_fallbackRouter;
    v80 = (16 * v77 + 127) & 0xFFFFFF80;
    v81 = (v80 + 15) & 0xFFFFFFF0;
    if ( v80 > v79->m_stack.m_slabSize || &v78[v81] != v79->m_stack.m_cur || v79->m_stack.m_firstNonLifoEnd == v78 )
      hkLifoAllocator::slowBlockFree(&v79->m_stack, v78, v81);
    else
      v79->m_stack.m_cur = v78;
  }
}

/*
==============
castShapeConvexFirstPass
==============
*/
__int64 castShapeConvexFirstPass(const bool permitOutwardTrace, const hknpConvexShape *queryShape, hknpCollisionQueryContext *queryContext, const hknpShapeCastQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpScaledConvexVertexShape *targetVerts, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *targetTquery, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector, hknpCollisionQueryCollector *startCollector)
{
  const hknpScaledConvexVertexShape *v13; 
  const hkTransformf *v14; 
  hknpCollisionQueryCollector *v15; 
  float *v16; 
  unsigned __int64 v17; 
  char *v18; 
  __int64 m_size; 
  hkMemoryRouter *Value; 
  __int64 v21; 
  _OWORD *m_cur; 
  char *v23; 
  hkVector4f v24; 
  hkVector4f v25; 
  __int64 v26; 
  _OWORD *v27; 
  __int64 v28; 
  __m128 v31; 
  unsigned __int8 v33; 
  int v36; 
  __m128 v38; 
  const hkTransformf *m_shapeToWorld; 
  unsigned int m_serialAndIndex; 
  unsigned int v48; 
  __m128 v52; 
  __m128 v53; 
  unsigned __int8 v54; 
  int v55; 
  char *v56; 
  hkMemoryRouter *v57; 
  signed int v58; 
  int v59; 
  float v62; 
  hknpCollisionQueryContext *v63; 
  __m128 v64; 
  __m128 v65; 
  float v66; 
  unsigned int v67; 
  __int64 v68; 
  __int16 v69; 
  int v70; 
  __int64 v71; 
  unsigned int v72; 
  __int64 v73; 
  unsigned __int16 m_value; 
  unsigned int m_collisionFilterInfo; 
  unsigned __int64 m_userData; 
  __int64 v77; 
  int m_storage; 
  void *p; 
  int v80; 
  float m_convexRadius; 
  const hknpConvexShape *v82; 
  char v83; 
  __m128 v84; 
  __m128 v85; 
  __m128 v86; 
  __m256i v87; 
  __m256i v88; 

  _RDI = (__m128 *)query;
  v63 = queryContext;
  v13 = targetVerts;
  v14 = targetTquery;
  v15 = collector;
  v16 = NULL;
  v17 = _RDI->m128_u64[1];
  if ( v17 && *(_BYTE *)(v17 + 24) == 6 )
    v16 = (float *)_RDI[1].m128_u64[1];
  m_storage = hknpConvexDispatch::s_shapeTypeToCvxDispatch[queryShape->m_type.m_storage].m_disptach.m_storage;
  m_convexRadius = queryShape->m_convexRadius;
  v82 = queryShape;
  v83 = 0;
  v18 = (char *)&queryShape->m_vertices + queryShape->m_vertices.m_offset;
  m_size = queryShape->m_vertices.m_size;
  if ( queryShapeInfo->m_scalingInternals.m_isScaled )
  {
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v21 = (16 * (_DWORD)m_size + 127) & 0xFFFFFF80;
    m_cur = Value->m_stack.m_cur;
    v23 = (char *)m_cur + v21;
    if ( (int)v21 > Value->m_stack.m_slabSize || v23 > Value->m_stack.m_end )
      m_cur = hkLifoAllocator::allocateFromNewSlab(&Value->m_stack, v21);
    else
      Value->m_stack.m_cur = v23;
    v24.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_offset;
    v25.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_scale;
    v26 = m_size;
    if ( (_DWORD)m_size )
    {
      v27 = m_cur;
      v28 = v18 - (char *)m_cur;
      do
      {
        _XMM1 = _mm128_add_ps(v24.m_quad, _mm128_mul_ps(v25.m_quad, *(__m128 *)((char *)v27 + v28)));
        __asm { vblendps xmm0, xmm1, xmmword ptr [rbx+rcx], 8 }
        *v27++ = _XMM0;
        --v26;
      }
      while ( v26 );
    }
    v18 = (char *)m_cur;
    m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
    v83 = 1;
    v13 = targetVerts;
    v14 = targetTquery;
    queryContext = v63;
    v15 = collector;
  }
  p = v18;
  v80 = m_size;
  v31 = (__m128)*(unsigned int *)v16;
  v62 = *v16;
  if ( startCollector )
    _XMM9 = 0i64;
  else
    __asm { vbroadcastss xmm9, dword ptr [r8+18h] }
  v33 = v15->m_hints.m_storage;
  v86 = g_vectorfConstants[36];
  __asm
  {
    vbroadcastss xmm12, dword ptr [rdi+60h]
    vbroadcastss xmm13, dword ptr [rdi+68h]
  }
  v87 = *(__m256i *)v14->m_rotation.m_col0.m_quad.m128_f32;
  v88 = *(__m256i *)v14->m_rotation.m_col2.m_quad.m128_f32;
  *(__m128 *)&v88.m256i_u64[2] = _mm128_add_ps(_mm128_mul_ps(_XMM9, _RDI[4]), v14->m_translation.m_quad);
  v36 = 0;
  while ( 1 )
  {
    if ( !((unsigned __int8 (__fastcall *)(int *, const hknpScaledConvexVertexShape *, __m256i *, _QWORD, __m128 *))queryContext->m_dispatcher->m_preScaledCvxClosestPointTable[m_storage][v13->m_type])(&m_storage, v13, &v87, v33, &v84) )
      goto LABEL_37;
    __asm { vbroadcastss xmm3, dword ptr [rdi+64h] }
    v38 = _mm128_sub_ps(v86, _XMM3);
    _XMM4 = _RDI[4];
    __asm
    {
      vdpps   xmm0, xmm4, xmm4, 7Fh
      vcmpleps xmm3, xmm0, xmm11
      vrsqrtps xmm1, xmm0
    }
    _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM1, _XMM0), _XMM1)), _mm128_mul_ps(_XMM1, *(__m128 *)hkMath::hkSse_floatHalf));
    __asm { vandnps xmm0, xmm3, xmm2 }
    _XMM1 = _mm128_mul_ps(_XMM4, _XMM0);
    __asm { vdpps   xmm2, xmm1, xmm8, 7Fh }
    if ( (permitOutwardTrace || v38.m128_f32[0] >= _mm_shuffle_ps((__m128)(*(_OWORD *)&v31 ^ (unsigned int)_xmm), (__m128)(*(_OWORD *)&v31 ^ (unsigned int)_xmm), 0).m128_f32[0]) && *(float *)&_XMM2 >= -0.000001 )
    {
LABEL_37:
      v54 = 0;
      goto LABEL_38;
    }
    if ( !v36 && startCollector && _mm128_sub_ps(_XMM13, _mm_shuffle_ps(v31, v31, 0)).m128_f32[0] >= v38.m128_f32[0] )
    {
      v64 = 0i64;
      v65 = 0i64;
      v66 = FLOAT_3_40282e38;
      v67 = 0xFFFFFF;
      v68 = -1i64;
      v69 = -1;
      v70 = 0;
      v71 = 0i64;
      v72 = 0xFFFFFF;
      v73 = -1i64;
      m_value = -1;
      m_collisionFilterInfo = 0;
      m_userData = 0i64;
      v77 = 4i64;
      m_shapeToWorld = targetShapeInfo->m_shapeToWorld;
      v64 = _mm128_add_ps(_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v84, v84, 85), m_shapeToWorld->m_rotation.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v84, v84, 0), m_shapeToWorld->m_rotation.m_col0.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v84, v84, 170), m_shapeToWorld->m_rotation.m_col2.m_quad)), m_shapeToWorld->m_translation.m_quad);
      v65 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(v85, v85, 85), m_shapeToWorld->m_rotation.m_col1.m_quad), _mm128_mul_ps(_mm_shuffle_ps(v85, v85, 0), m_shapeToWorld->m_rotation.m_col0.m_quad)), _mm128_mul_ps(_mm_shuffle_ps(v85, v85, 170), m_shapeToWorld->m_rotation.m_col2.m_quad));
      v66 = v38.m128_f32[0] + v31.m128_f32[0];
      if ( queryShapeInfo->m_body )
        m_serialAndIndex = queryShapeInfo->m_body->m_id.m_serialAndIndex;
      else
        m_serialAndIndex = 0xFFFFFF;
      v67 = m_serialAndIndex;
      LODWORD(v68) = queryShapeInfo->m_shapeKeyPath.m_key.m_value;
      v69 = _RDI[1].m128_i16[0];
      v70 = _RDI[1].m128_i32[1];
      v71 = _RDI[1].m128_i64[1];
      if ( targetShapeInfo->m_body )
        v48 = targetShapeInfo->m_body->m_id.m_serialAndIndex;
      else
        v48 = 0xFFFFFF;
      v72 = v48;
      LODWORD(v73) = targetShapeInfo->m_shapeKeyPath.m_key.m_value;
      m_value = targetShapeFilterData->m_materialId.m_value;
      m_collisionFilterInfo = targetShapeFilterData->m_collisionFilterInfo;
      m_userData = targetShapeFilterData->m_userData;
      HIDWORD(v73) = _RDI[2].m128_i32[0];
      startCollector->addHit(startCollector, (const hknpCollisionResult *)&v64);
    }
    if ( *(float *)&_XMM12 >= v38.m128_f32[0] )
      break;
    _XMM4 = _RDI[4];
    __asm { vdpps   xmm0, xmm4, xmm8, 7Fh }
    if ( _XMM0.m128_f32[0] < 0.0 )
    {
      __asm { vrcpps  xmm2, xmm0 }
      v52 = _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatTwo, _mm128_mul_ps(_XMM2, _XMM0)), _XMM2);
      _XMM9 = _mm128_sub_ps(_XMM9, _mm128_mul_ps(v38, v52));
      v53 = 0i64;
      v53.m128_f32[0] = v62;
      if ( _mm128_sub_ps(collector->m_earlyOutThreshold.m_real, _mm128_mul_ps(_mm_shuffle_ps(v53, v53, 0), v52)).m128_f32[0] >= _XMM9.m128_f32[0] )
      {
        *(__m128 *)&v88.m256i_u64[2] = _mm128_add_ps(_mm128_mul_ps(_XMM4, _XMM9), targetTquery->m_translation.m_quad);
        ++v36;
        v13 = targetVerts;
        queryContext = v63;
        if ( v36 < 256 )
          continue;
      }
    }
    goto LABEL_37;
  }
  v54 = 1;
LABEL_38:
  if ( v83 )
  {
    v55 = v80;
    v56 = (char *)p;
    v57 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v57 )
      v57 = hkMemoryRouter::s_fallbackRouter;
    v58 = (16 * v55 + 127) & 0xFFFFFF80;
    v59 = (v58 + 15) & 0xFFFFFFF0;
    if ( v58 > v57->m_stack.m_slabSize || &v56[v59] != v57->m_stack.m_cur || v57->m_stack.m_firstNonLifoEnd == v56 )
      hkLifoAllocator::slowBlockFree(&v57->m_stack, v56, v59);
    else
      v57->m_stack.m_cur = v56;
  }
  return v54;
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  if ( query->m_shape->m_numShapeKeyBits <= targetShape->m_numShapeKeyBits )
    HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
  else
    HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>(queryContext, query, queryShapeInfo, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __m128 v9; 
  int v10; 
  const hknpShape *m_shape; 
  int v14; 
  unsigned __int16 v15; 
  hkVector4f v16; 
  __m128 m_quad; 
  unsigned int m_mode; 
  __int64 v19; 
  int v20; 
  hkVector4f v21; 
  hkVector4f v22; 
  int v23; 
  BOOL v24; 
  __int64 v25; 
  const hkTransformf *m_shapeToWorld; 
  __m128 v28; 
  int m_numShapeKeyBits; 
  int v31; 
  unsigned int v32; 
  int v33; 
  const hknpShape *v34; 
  const hknpShapeTagCodec *m_shapeTagCodec; 
  __m256i v36; 
  __int64 v37; 
  const hknpShape *m_rootShape; 
  const hknpBody *m_body; 
  int v40; 
  int offsetOut; 
  unsigned __int16 v42; 
  unsigned __int16 v43; 
  hknpQueryFilterData m_filterData; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  hkTransformf bTc; 
  __int128 v50[3]; 
  __m128 v51; 
  hkTransformf v52; 
  __m128 v53; 

  v10 = 0;
  m_shape = query->m_shape;
  v14 = *(_DWORD *)&m_shape[1].m_flags.m_storage;
  v42 = 0;
  if ( v14 > 0 )
  {
    while ( 1 )
    {
      v15 = v42;
      if ( !*(_BYTE *)(112i64 * v42 + *(_QWORD *)&m_shape[1].m_memSizeAndFlags + 92) )
        break;
      v42 = ++v10;
      if ( v10 >= v14 )
        return;
    }
    if ( v10 != -1 )
    {
      v53 = v9;
      while ( 1 )
      {
        v16.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_offset;
        m_quad = queryShapeInfo->m_scalingInternals.m_scale.m_quad;
        m_mode = queryShapeInfo->m_scalingInternals.m_mode;
        queryShapeInfoa.m_scalingInternals.m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
        queryShapeInfoa.m_shapeKeyMask = NULL;
        queryShapeInfoa.m_scalingInternals.m_mode = m_mode;
        queryShapeInfoa.m_scalingInternals.m_scale.m_quad = m_quad;
        queryShapeInfoa.m_scalingInternals.m_offset = (hkVector4f)v16.m_quad;
        v19 = *(_QWORD *)&m_shape[1].m_memSizeAndFlags + 112i64 * v15;
        queryShapeInfoa.m_body = queryShapeInfo->m_body;
        queryShapeInfoa.m_rootShape = queryShapeInfo->m_rootShape;
        queryShapeInfoa.m_parentShape = queryShapeInfo->m_parentShape;
        queryShapeInfoa.m_shapeKeyPath = queryShapeInfo->m_shapeKeyPath;
        queryShapeInfoa.m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
        queryShapeInfoa.m_scalingInternals.m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
        v20 = *(_DWORD *)(v19 + 12);
        v21.m_quad = *(__m128 *)(v19 + 64);
        bTc.m_rotation.m_col0 = *(hkVector4f *)v19;
        bTc.m_rotation.m_col1 = *(hkVector4f *)(v19 + 16);
        bTc.m_rotation.m_col2 = *(hkVector4f *)(v19 + 32);
        v22.m_quad = *(__m128 *)(v19 + 48);
        v23 = v20 & 8;
        bTc.m_translation = (hkVector4f)v22.m_quad;
        if ( queryShapeInfoa.m_scalingInternals.m_isScaled )
          break;
        if ( v23 )
          goto LABEL_10;
LABEL_15:
        hkTransformf::setMul(&v52, queryToTarget, &bTc);
        m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
        _YMM8 = *(__m256i *)m_shapeToWorld->m_rotation.m_col0.m_quad.m128_f32;
        v28 = m_shapeToWorld->m_rotation.m_col2.m_quad;
        m_numShapeKeyBits = m_shape->m_numShapeKeyBits;
        __asm { vextractf128 xmm7, ymm8, 1 }
        v50[2] = (__int128)_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col2.m_quad, bTc.m_rotation.m_col2.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col2.m_quad, bTc.m_rotation.m_col2.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col2.m_quad, bTc.m_rotation.m_col2.m_quad, 170), v28));
        v50[1] = (__int128)_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col1.m_quad, bTc.m_rotation.m_col1.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col1.m_quad, bTc.m_rotation.m_col1.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col1.m_quad, bTc.m_rotation.m_col1.m_quad, 170), v28));
        v31 = queryShapeInfoa.m_shapeKeyPath.m_size + m_numShapeKeyBits;
        v32 = queryShapeInfoa.m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[queryShapeInfoa.m_shapeKeyPath.m_size];
        v51 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(bTc.m_translation.m_quad, bTc.m_translation.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_translation.m_quad, bTc.m_translation.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_translation.m_quad, bTc.m_translation.m_quad, 170), v28));
        v33 = v32 | (((v15 + 1) << (32 - v31)) - 1);
        v50[0] = (__int128)_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col0.m_quad, bTc.m_rotation.m_col0.m_quad, 85), _XMM7), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col0.m_quad, bTc.m_rotation.m_col0.m_quad, 0), v9)), _mm128_mul_ps(_mm_shuffle_ps(bTc.m_rotation.m_col0.m_quad, bTc.m_rotation.m_col0.m_quad, 170), v28));
        v51 = _mm128_add_ps(v51, m_shapeToWorld->m_translation.m_quad);
        v34 = *(const hknpShape **)(v19 + 80);
        queryShapeInfoa.m_shapeToWorld = (const hkTransformf *)v50;
        queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v33;
        queryShapeInfoa.m_shapeKeyPath.m_size = v31;
        m_shapeTagCodec = query->m_shapeTagCodec;
        v36 = *(__m256i *)&query->m_shapeTagCodec;
        *(__m256i *)querya.m_levelOfDetail = *(__m256i *)query->m_levelOfDetail;
        querya.m_shape = v34;
        *(__m256i *)&querya.m_shapeTagCodec = v36;
        if ( m_shapeTagCodec )
        {
          v37 = *(unsigned __int16 *)(v19 + 88);
          m_rootShape = queryShapeInfo->m_rootShape;
          offsetOut = v33;
          m_body = queryShapeInfo->m_body;
          m_filterData = querya.m_filterData;
          ((void (__fastcall *)(const hknpShapeTagCodec *, __int64, __int64, const hknpBody *, const hknpShape *, const hknpShape *, int, const hknpShape *, hknpQueryFilterData *))m_shapeTagCodec->decode)(m_shapeTagCodec, v37, 4i64, m_body, m_rootShape, m_shape, offsetOut, v34, &m_filterData);
          querya.m_filterData.m_collisionFilterInfo = m_filterData.m_collisionFilterInfo;
          querya.m_filterData.m_materialId.m_value = m_filterData.m_materialId.m_value;
        }
        hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v52, queryAndTargetSwapped, collector);
        v40 = *(_DWORD *)&m_shape[1].m_flags.m_storage;
        v43 = ++v10;
        if ( v10 >= v40 )
        {
LABEL_20:
          v10 = -1;
          v15 = -1;
        }
        else
        {
          while ( 1 )
          {
            v15 = v43;
            if ( !*(_BYTE *)(112i64 * v43 + *(_QWORD *)&m_shape[1].m_memSizeAndFlags + 92) )
              break;
            v43 = ++v10;
            if ( v10 >= v40 )
              goto LABEL_20;
          }
        }
        if ( v10 == -1 )
          return;
      }
      bTc.m_translation.m_quad = _mm128_mul_ps(m_quad, v22.m_quad);
      v21.m_quad = _mm128_mul_ps(m_quad, v21.m_quad);
LABEL_10:
      queryShapeInfoa.m_scalingInternals.m_offset = 0i64;
      queryShapeInfoa.m_scalingInternals.m_isScaled = 1;
      queryShapeInfoa.m_scalingInternals.m_scale = (hkVector4f)v21.m_quad;
      if ( (*(_DWORD *)(v19 + 12) & 8) != 0 )
        v24 = (*(_DWORD *)(v19 + 12) & 0x20) == 0;
      else
        v24 = m_mode;
      queryShapeInfoa.m_scalingInternals.m_mode = v24;
      v25 = *(_QWORD *)(v19 + 80);
      queryShapeInfoa.m_scalingInternals.m_convexRadius = *(float *)(v25 + 32);
      if ( (*(_BYTE *)(v25 + 24) & 1) != 0 )
        hknpShapeUtil::calcScalingParameters((hknpShapeType::Enum)*(unsigned __int8 *)(v25 + 26), (const hkcdVertex *)(v25 + 58 + *(unsigned __int16 *)(v25 + 60)), *(unsigned __int16 *)(v25 + 58), (hknpShape::ScaleMode)v24, &queryShapeInfoa.m_scalingInternals.m_scale, &queryShapeInfoa.m_scalingInternals.m_convexRadius, &queryShapeInfoa.m_scalingInternals.m_offset);
      goto LABEL_15;
    }
  }
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompressedMeshShapeUtil::getClosestPointsToCompressedMesh(queryContext, query, queryShapeInfo, (const hknpCompressedMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompoundShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const hknpCompoundShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompressedMeshShapeUtil::getClosestPointsToConvex(queryContext, query, queryShapeInfo, (const hknpCompressedMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  const hknpConvexShape *v9; 
  const hknpShape *m_shape; 
  const hkcdVertex *v13; 
  __int64 v14; 
  hkMemoryRouter *Value; 
  __int64 v16; 
  _OWORD *m_cur; 
  char *v18; 
  hkVector4f v19; 
  hkVector4f v20; 
  __int64 v21; 
  _OWORD *v22; 
  signed __int64 v23; 
  const hkcdVertex *v26; 
  __int64 m_size; 
  hkMemoryRouter *v28; 
  __int64 v29; 
  _OWORD *v30; 
  char *v31; 
  hkVector4f v32; 
  hkVector4f v33; 
  __int64 v34; 
  _OWORD *v35; 
  signed __int64 v36; 
  hknpCollisionQueryDispatcher *m_dispatcher; 
  int m_numVertices; 
  hkcdVertex *m_vertices; 
  hkMemoryRouter *v42; 
  signed int v43; 
  int v44; 
  int v45; 
  hkcdVertex *v46; 
  hkMemoryRouter *v47; 
  signed int v48; 
  int v49; 
  hknpConvexVertexShape target; 
  char v52; 
  hknpConvexVertexShape querya; 
  char v54; 

  v9 = (const hknpConvexShape *)targetShape;
  m_shape = query->m_shape;
  if ( (m_shape->m_flags.m_storage & 1) == 0 )
    m_shape = NULL;
  if ( (targetShape->m_flags.m_storage & 1) == 0 )
    v9 = NULL;
  querya.m_type = hknpConvexDispatch::s_shapeTypeToCvxDispatch[m_shape->m_type.m_storage].m_disptach.m_storage;
  querya.m_convexRadius = m_shape->m_convexRadius;
  querya.m_shape = (const hknpConvexShape *)m_shape;
  v54 = 0;
  v13 = (const hkcdVertex *)((char *)&m_shape[1].__vftable + WORD2(m_shape[1].__vftable) + 2);
  v14 = WORD1(m_shape[1].__vftable);
  if ( queryShapeInfo->m_scalingInternals.m_isScaled )
  {
    Value = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !Value )
      Value = hkMemoryRouter::s_fallbackRouter;
    v16 = (16 * (_DWORD)v14 + 127) & 0xFFFFFF80;
    m_cur = Value->m_stack.m_cur;
    v18 = (char *)m_cur + v16;
    if ( (int)v16 > Value->m_stack.m_slabSize || v18 > Value->m_stack.m_end )
      m_cur = hkLifoAllocator::allocateFromNewSlab(&Value->m_stack, v16);
    else
      Value->m_stack.m_cur = v18;
    v19.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_offset;
    v20.m_quad = (__m128)queryShapeInfo->m_scalingInternals.m_scale;
    v21 = v14;
    if ( (_DWORD)v14 )
    {
      v22 = m_cur;
      v23 = (char *)v13 - (char *)m_cur;
      do
      {
        _XMM1 = _mm128_add_ps(v19.m_quad, _mm128_mul_ps(v20.m_quad, *(__m128 *)((char *)v22 + v23)));
        __asm { vblendps xmm0, xmm1, xmmword ptr [rbx+rcx], 8 }
        *v22++ = _XMM0;
        --v21;
      }
      while ( v21 );
    }
    v13 = (const hkcdVertex *)m_cur;
    querya.m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
    v54 = 1;
  }
  querya.m_vertices = v13;
  querya.m_numVertices = v14;
  target.m_type = hknpConvexDispatch::s_shapeTypeToCvxDispatch[v9->m_type.m_storage].m_disptach.m_storage;
  target.m_convexRadius = v9->m_convexRadius;
  target.m_shape = v9;
  v52 = 0;
  v26 = (const hkcdVertex *)((char *)&v9->m_vertices + v9->m_vertices.m_offset);
  m_size = v9->m_vertices.m_size;
  if ( targetShapeInfo->m_scalingInternals.m_isScaled )
  {
    v28 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v28 )
      v28 = hkMemoryRouter::s_fallbackRouter;
    v29 = (16 * (_DWORD)m_size + 127) & 0xFFFFFF80;
    v30 = v28->m_stack.m_cur;
    v31 = (char *)v30 + v29;
    if ( (int)v29 > v28->m_stack.m_slabSize || v31 > v28->m_stack.m_end )
      v30 = hkLifoAllocator::allocateFromNewSlab(&v28->m_stack, v29);
    else
      v28->m_stack.m_cur = v31;
    v32.m_quad = (__m128)targetShapeInfo->m_scalingInternals.m_offset;
    v33.m_quad = (__m128)targetShapeInfo->m_scalingInternals.m_scale;
    v34 = m_size;
    if ( (_DWORD)m_size )
    {
      v35 = v30;
      v36 = (char *)v26 - (char *)v30;
      do
      {
        _XMM1 = _mm128_add_ps(v32.m_quad, _mm128_mul_ps(v33.m_quad, *(__m128 *)((char *)v35 + v36)));
        __asm { vblendps xmm0, xmm1, xmmword ptr [rbx+rcx], 8 }
        *v35++ = _XMM0;
        --v34;
      }
      while ( v34 );
    }
    v26 = (const hkcdVertex *)v30;
    target.m_convexRadius = targetShapeInfo->m_scalingInternals.m_convexRadius;
    v52 = 1;
  }
  target.m_vertices = v26;
  target.m_numVertices = m_size;
  m_dispatcher = (hknpCollisionQueryDispatcher *)queryContext->m_dispatcher;
  if ( (collector->m_hints.m_storage & 2) != 0 )
    collector->processClosestPointsCvxCvx(collector, m_dispatcher, query, &querya, &query->m_filterData, queryShapeInfo, &target, targetShapeFilterData, targetShapeInfo, queryToTarget);
  else
    hknpCollisionQueryDispatcher::_getClosestPointsCvxCvxPreScaledImpl<hknpCollisionQueryCollector,hknpClosestPointsQuery,hknpCollisionResult>(m_dispatcher, query, &querya, &query->m_filterData, queryShapeInfo, &target, targetShapeFilterData, targetShapeInfo, queryToTarget, collector);
  if ( v52 )
  {
    m_numVertices = target.m_numVertices;
    m_vertices = (hkcdVertex *)target.m_vertices;
    v42 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v42 )
      v42 = hkMemoryRouter::s_fallbackRouter;
    v43 = (16 * m_numVertices + 127) & 0xFFFFFF80;
    v44 = (v43 + 15) & 0xFFFFFFF0;
    if ( v43 > v42->m_stack.m_slabSize || (char *)m_vertices + v44 != v42->m_stack.m_cur || v42->m_stack.m_firstNonLifoEnd == m_vertices )
      hkLifoAllocator::slowBlockFree(&v42->m_stack, m_vertices, v44);
    else
      v42->m_stack.m_cur = m_vertices;
  }
  if ( v54 )
  {
    v45 = querya.m_numVertices;
    v46 = (hkcdVertex *)querya.m_vertices;
    v47 = (hkMemoryRouter *)TlsGetValue(hkMemoryRouter::s_memoryRouter.m_slotID);
    if ( !v47 )
      v47 = hkMemoryRouter::s_fallbackRouter;
    v48 = (16 * v45 + 127) & 0xFFFFFF80;
    v49 = (v48 + 15) & 0xFFFFFFF0;
    if ( v48 > v47->m_stack.m_slabSize || (char *)v46 + v49 != v47->m_stack.m_cur || v47->m_stack.m_firstNonLifoEnd == v46 )
      hkLifoAllocator::slowBlockFree(&v47->m_stack, v46, v49);
    else
      v47->m_stack.m_cur = v46;
  }
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpExternMeshShapeUtil::getClosestPointsToConvex(queryContext, query, queryShapeInfo, (const hknpExternMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpHeightFieldShape::getClosestPointsImpl(queryContext, query, queryShapeInfo, (const hknpHeightFieldShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpParticlesColliderShape::getClosestPointsFromConvex(queryContext, query, queryShapeInfo, (const hknpParticlesColliderShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCollisionQueryContext *v10; 
  __int64 v13; 
  unsigned int v14; 
  bool v18; 
  __int64 v19; 
  int v20; 
  const hknpShape *v21; 
  __m128 *v22; 
  hknpTriangleShape *m_targetTriangle; 
  int v24; 
  unsigned __int16 v25; 
  int v26; 
  __m256i v27; 
  bool m_isScaled; 
  float m_convexRadius; 
  __int64 m_size; 
  char v31; 
  __int64 m_offset; 
  __int64 v33; 
  __m128 v34; 
  __m128 v35; 
  __m128 v36; 
  __m128 v44; 
  __int64 v46; 
  __m128 v47; 
  __m128 v48; 
  __m128 v49; 
  __int64 v57; 
  const hknpShapeTagCodec *m_shapeTagCodec; 
  __m256i v60; 
  unsigned __int16 v61; 
  const hknpBody *m_body; 
  const hknpShape *m_rootShape; 
  bool v64; 
  unsigned __int16 v65; 
  signed int v66; 
  int v67; 
  const hknpShape *m_shape; 
  __m128 *v69; 
  hknpQueryFilterData m_filterData; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  __m128 v75; 
  __m128 v76; 
  __m128 v77[2]; 

  v10 = queryContext;
  m_shape = query->m_shape;
  v13 = *(_QWORD *)&m_shape[1].m_flags.m_storage;
  v67 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 88i64))(v13);
  v14 = 0;
  v66 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 24i64))(v13);
  if ( v67 > 0 )
  {
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vpinsrw xmm0, xmm0, eax, 1
      vpshufd xmm10, xmm0, 0
    }
    do
    {
      (*(void (__fastcall **)(__int64, _QWORD, __m128 *))(*(_QWORD *)v13 + 96i64))(v13, v14, &v75);
      v18 = 0;
      v19 = 1i64;
      v64 = 0;
      if ( (int)v14 >= v66 )
      {
        v20 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 112i64))(v13, v14) & 7;
        v18 = v20 == 7;
        if ( v20 != 7 )
          v19 = 2i64;
        v64 = v20 == 7;
      }
      v21 = m_shape;
      v22 = v77;
      m_targetTriangle = v10->m_targetTriangle;
      v24 = 2 * v14;
      v69 = v77;
      v25 = 0;
      v65 = 0;
      v26 = 0;
      m_targetTriangle->m_convexRadius = m_shape->m_convexRadius;
      v27 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
      queryShapeInfoa.m_body = queryShapeInfo->m_body;
      queryShapeInfoa.m_rootShape = queryShapeInfo->m_rootShape;
      queryShapeInfoa.m_parentShape = queryShapeInfo->m_parentShape;
      queryShapeInfoa.m_shapeToWorld = queryShapeInfo->m_shapeToWorld;
      m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
      *(__m256i *)queryShapeInfoa.m_scalingInternals.m_scale.m_quad.m128_f32 = v27;
      m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
      queryShapeInfoa.m_scalingInternals.m_isScaled = m_isScaled;
      queryShapeInfoa.m_scalingInternals.m_mode = queryShapeInfo->m_scalingInternals.m_mode;
      queryShapeInfoa.m_scalingInternals.m_convexRadius = m_convexRadius;
      queryShapeInfoa.m_shapeKeyMask = NULL;
      do
      {
        m_size = queryShapeInfo->m_shapeKeyPath.m_size;
        v31 = m_size + v21->m_numShapeKeyBits;
        queryShapeInfoa.m_shapeKeyPath.m_size = 32;
        queryShapeInfoa.m_shapeKeyPath.m_key.m_value = queryShapeInfo->m_shapeKeyPath.m_key.m_value & hknpShapeKeyPath_usedBitsMaskTable[m_size] | ((((v26 | v24) + 1) << (32 - v31)) - 1);
        m_offset = m_targetTriangle->m_vertices.m_offset;
        v33 = m_targetTriangle->m_planes.m_offset;
        if ( v18 )
        {
          v34 = _mm128_sub_ps(v76, v75);
          v35 = _mm128_sub_ps(v77[0], v75);
          v36 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v35, v35, 201), v34), _mm128_mul_ps(_mm_shuffle_ps(v34, v34, 201), v35));
          _XMM7 = _mm_shuffle_ps(v36, v36, 201);
          __asm
          {
            vdpps   xmm1, xmm7, xmm7, 7Fh
            vrsqrtps xmm5, xmm1
            vcmpleps xmm4, xmm1, xmm9
          }
          *(__m128 *)((char *)&m_targetTriangle->m_vertices.m_size + m_offset) = v75;
          _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM5, _XMM1), _XMM5)), _mm128_mul_ps(_XMM5, *(__m128 *)hkMath::hkSse_floatHalf));
          __asm { vdpps   xmm6, xmm7, xmm8, 7Fh }
          _mm128_sub_ps((__m128)0i64, _XMM6);
          __asm
          {
            vblendps xmm0, xmm7, xmm1, 8
            vandnps xmm4, xmm4, xmm2
          }
          v44 = _mm128_mul_ps(_XMM4, _XMM0);
          _YMM2 = (__m256i)(unsigned __int128)v44;
          *(__m128 *)((char *)&m_targetTriangle->m_indices.m_offset + m_offset) = v76;
          *(__m128 *)((char *)&m_targetTriangle[1].__vftable + m_offset + 2) = v77[0];
          *(__m128 *)((char *)&m_targetTriangle[1].m_refCount + m_offset) = v77[1];
          *(_DWORD *)((char *)&m_targetTriangle->m_faces.m_offset + m_offset) = 1056964608;
          *(_DWORD *)((char *)&m_targetTriangle->m_connectivity.m_ptr + m_offset + 6) = 1056964609;
          *(_DWORD *)((char *)&m_targetTriangle[1].m_propertyBag.m_bag + m_offset + 6) = 1056964610;
          *(_DWORD *)(&m_targetTriangle[1].m_dispatchType + m_offset + 2) = 1056964611;
          m_targetTriangle->m_vertices.m_size = 4;
          v46 = m_targetTriangle->m_indices.m_offset;
          *((_BYTE *)&m_targetTriangle->m_indices.m_offset + v46 + 1) = 3;
          *((_BYTE *)&m_targetTriangle->m_indices + v46 + 7) = 3;
        }
        else
        {
          v47 = _mm128_sub_ps(v22[-1], v75);
          v48 = _mm128_sub_ps(*v22, v75);
          v49 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v48, v48, 201), v47), _mm128_mul_ps(_mm_shuffle_ps(v47, v47, 201), v48));
          _XMM7 = _mm_shuffle_ps(v49, v49, 201);
          __asm
          {
            vdpps   xmm0, xmm7, xmm7, 7Fh
            vrsqrtps xmm5, xmm0
            vcmpleps xmm4, xmm0, xmm9
          }
          *(__m128 *)((char *)&m_targetTriangle->m_vertices.m_size + m_offset) = v75;
          _mm128_mul_ps(_mm128_sub_ps(*(__m128 *)hkMath::hkSse_floatThree, _mm128_mul_ps(_mm128_mul_ps(_XMM5, _XMM0), _XMM5)), _mm128_mul_ps(_XMM5, *(__m128 *)hkMath::hkSse_floatHalf));
          __asm { vdpps   xmm6, xmm7, xmm8, 7Fh }
          _mm128_sub_ps((__m128)0i64, _XMM6);
          __asm
          {
            vblendps xmm0, xmm7, xmm1, 8
            vandnps xmm4, xmm4, xmm2
          }
          v44 = _mm128_mul_ps(_XMM4, _XMM0);
          _YMM2 = (__m256i)(unsigned __int128)v44;
          *(__m128 *)((char *)&m_targetTriangle->m_indices.m_offset + m_offset) = v22[-1];
          *(__m128 *)((char *)&m_targetTriangle[1].__vftable + m_offset + 2) = *v22;
          *(__m128 *)((char *)&m_targetTriangle[1].m_refCount + m_offset) = *v22;
          *(_DWORD *)((char *)&m_targetTriangle->m_faces.m_offset + m_offset) = 1056964608;
          *(_DWORD *)((char *)&m_targetTriangle->m_connectivity.m_ptr + m_offset + 6) = 1056964609;
          *(_DWORD *)((char *)&m_targetTriangle[1].m_propertyBag.m_bag + m_offset + 6) = 1056964610;
          *(_DWORD *)(&m_targetTriangle[1].m_dispatchType + m_offset + 2) = 1056964610;
          m_targetTriangle->m_vertices.m_size = 3;
          v57 = m_targetTriangle->m_indices.m_offset;
          *((_BYTE *)&m_targetTriangle->m_indices.m_offset + v57 + 1) = 0;
          *((_BYTE *)&m_targetTriangle->m_indices + v57 + 7) = 0;
        }
        __asm { vinsertf128 ymm2, ymm2, xmm2, 1 }
        *(__m128 *)((char *)&m_targetTriangle->m_planes.m_size + v33) = v44;
        *(_OWORD *)((char *)&m_targetTriangle->m_connectivity.m_ptr + v33) = *(_OWORD *)&v44 ^ _XMM10;
        *(__m256i *)((char *)&m_targetTriangle[1].m_propertyBag.m_bag + v33) = _YMM2;
        m_shapeTagCodec = query->m_shapeTagCodec;
        v60 = *(__m256i *)&query->m_shapeTagCodec;
        *(__m256i *)querya.m_levelOfDetail = *(__m256i *)query->m_levelOfDetail;
        querya.m_shape = m_targetTriangle;
        *(__m256i *)&querya.m_shapeTagCodec = v60;
        if ( m_shapeTagCodec )
        {
          if ( !v26 )
          {
            v61 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 104i64))(v13, v14);
            m_shapeTagCodec = query->m_shapeTagCodec;
            v25 = v61;
            v65 = v61;
          }
          m_body = queryShapeInfo->m_body;
          m_rootShape = queryShapeInfo->m_rootShape;
          m_filterData = querya.m_filterData;
          ((void (__fastcall *)(const hknpShapeTagCodec *, _QWORD, __int64, const hknpBody *, const hknpShape *, const hknpShape *, unsigned int, hknpTriangleShape *, hknpQueryFilterData *))m_shapeTagCodec->decode)(m_shapeTagCodec, v25, 4i64, m_body, m_rootShape, m_shape, queryShapeInfoa.m_shapeKeyPath.m_key.m_value, m_targetTriangle, &m_filterData);
          querya.m_filterData.m_collisionFilterInfo = m_filterData.m_collisionFilterInfo;
          querya.m_filterData.m_materialId.m_value = m_filterData.m_materialId.m_value;
        }
        hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
        v24 = 2 * v14;
        v25 = v65;
        v22 = v69 + 1;
        v21 = m_shape;
        ++v26;
        v18 = v64;
        ++v69;
        --v19;
      }
      while ( v19 );
      v10 = queryContext;
      ++v14;
    }
    while ( (int)v14 < v67 );
  }
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpCompressedMeshShapeUtil::getClosestPointsToHeightfield(queryContext, query, queryShapeInfo, (const hknpCompressedMeshShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  hknpHeightFieldShape::getClosestPointsToHeightfieldImpl(queryContext, query, queryShapeInfo, (const hknpHeightFieldShape *)targetShape, targetShapeFilterData, targetShapeInfo, queryToTarget, queryAndTargetSwapped, collector);
}

/*
==============
HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable
==============
*/
void HavokPhysics_CollisionQueryDispatcher::initIWGetClosestPointsTable(HavokPhysics_CollisionQueryDispatcher *this, unsigned int shapeMask)
{
  int v2; 
  hknpCollisionQueryDispatcher::DispatchTable<void (__cdecl*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)> *p_m_closestPointsDispatchTable; 
  int v5; 
  int v6; 
  int v7; 

  v2 = 0;
  p_m_closestPointsDispatchTable = &this->m_closestPointsDispatchTable;
  if ( (shapeMask & 1) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(&this->m_closestPointsDispatchTable, NOP, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsConvex, "convexVsConvex", shapeMask, 0);
  if ( (shapeMask & 0x201) == 513 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_0, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh, "convexVsCompressedMesh", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_0, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompressedMesh(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsCompressedMesh>", shapeMask, 0);
  }
  if ( (shapeMask & 0x401) == 1025 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_1, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh, "convexVsExternMesh", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_1, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsExternMesh(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsExternMesh>", shapeMask, 0);
  }
  if ( (shapeMask & 0x1001) == 4097 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound, "convexVsCompound", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsCompound(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsCompound>", shapeMask, 0);
  }
  if ( (shapeMask & 0x4001) == 16385 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_5, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField, "convexVsHeightField", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_5, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsHeightField(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsHeightField>", shapeMask, 0);
  }
  if ( (shapeMask & 0x10001) == 65537 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NOP, USER_7, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem, "convexVsParticleSystem", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7, NOP, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::convexVsParticleSystem(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<convexVsParticleSystem>", shapeMask, 0);
  }
  if ( (shapeMask & 0x500) == 1280 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_1, SHAPE_KEY_ARRAY, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape, "externMeshVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, USER_1, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<externMeshVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x8400) == 33792 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_1, USER_6, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape, "externMeshVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_6, USER_1, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::externMeshVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<externMeshVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x200) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_0, USER_0, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compressedMeshVsCompressedMesh, "compressedMeshVsCompressedMesh", shapeMask, 0);
  if ( (shapeMask & 0x4000) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_5, USER_5, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsHeightfield, "heightFieldVsHeightfield", shapeMask, 0);
  if ( (shapeMask & 0x4200) == 16896 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_5, USER_0, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh, "heightFieldVsCompressedMesh", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_0, USER_5, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::heightFieldVsCompressedMesh(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<heightFieldVsCompressedMesh>", shapeMask, 0);
  }
  if ( (shapeMask & 0x1100) == 4352 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, SHAPE_KEY_ARRAY, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape, "compoundVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<compoundVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x1000) != 0 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::compoundVsCompound, "compoundVsCompound", shapeMask, 0);
  if ( (shapeMask & 0x10100) == 65792 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7, SHAPE_KEY_ARRAY, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape, "particlesVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, SHAPE_KEY_ARRAY, USER_7, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<particlesVsShape>", shapeMask, 0);
  }
  if ( (shapeMask & 0x11000) == 69632 )
  {
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7, USER_3, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape, "particlesVsShape", shapeMask, 0);
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_3, USER_7, HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::flip<&void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>, "flip<particlesVsShape>", shapeMask, 0);
  }
  do
  {
    v5 = (1 << v2) | 0x20000;
    if ( (shapeMask & v5) == v5 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NUM_TYPES, (hknpShapeType::Enum)v2, unwrapScaledConvex<0>, "ScaledQuery", shapeMask, 0);
      if ( (shapeMask & v5) == v5 )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, (hknpShapeType::Enum)v2, NUM_TYPES, unwrapScaledConvex<1>, "ScaledTarget", shapeMask, 0);
    }
    v6 = (1 << v2) | 0x40000;
    if ( (shapeMask & v6) == v6 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|GSK, (hknpShapeType::Enum)v2, unwrapMaskedShape<0>, "UnwrapMaskedQuery", shapeMask, 0);
      if ( (shapeMask & v6) == v6 )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, (hknpShapeType::Enum)v2, USER_7|GSK, unwrapMaskedShape<1>, "UnwrapMaskedTarget", shapeMask, 0);
    }
    v7 = (1 << v2) | 0x100000;
    if ( (shapeMask & v7) == v7 )
    {
      hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|CONVEX_COMPOSITE, (hknpShapeType::Enum)v2, unwrapLodShape<0>, "LodQuery", shapeMask, 0);
      if ( (shapeMask & v7) == v7 )
        hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, (hknpShapeType::Enum)v2, USER_7|CONVEX_COMPOSITE, unwrapLodShape<1>, "LodTarget", shapeMask, 0);
    }
    ++v2;
  }
  while ( v2 < 30 );
  if ( (shapeMask & 0x40000) == 0x40000 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|GSK, USER_7|GSK, unwrapMaskedShape<2>, "UnwrapQueryAndTarget", shapeMask, 0);
  if ( (shapeMask & 0x100000) == 0x100000 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, USER_7|CONVEX_COMPOSITE, USER_7|CONVEX_COMPOSITE, unwrapLodShape<2>, "LodQueryAndTarget", shapeMask, 0);
  if ( (shapeMask & 0x20000) == 0x20000 )
    hknpCollisionQueryDispatcher::DispatchTable<void (*)(hknpCollisionQueryContext *,hknpClosestPointsQuery const &,hknpShapeQueryInfo const &,hknpShape const *,hknpQueryFilterData const &,hknpShapeQueryInfo const &,hkTransformf const &,bool,hknpCollisionQueryCollector *)>::_registerImpl(p_m_closestPointsDispatchTable, NUM_TYPES, NUM_TYPES, unwrapScaledConvex<2>, "ScaleQueryAndTarget", shapeMask, 0);
}

/*
==============
HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape
==============
*/
void HavokPhysicsCollisionQueryDispatchers_ClosestPointsFuncs::particlesVsShape(hknpCollisionQueryContext *queryContext, const hknpClosestPointsQuery *query, const hknpShapeQueryInfo *queryShapeInfo, const hknpShape *targetShape, const hknpQueryFilterData *targetShapeFilterData, const hknpShapeQueryInfo *targetShapeInfo, const hkTransformf *queryToTarget, bool queryAndTargetSwapped, hknpCollisionQueryCollector *collector)
{
  __int64 v11; 
  __int64 v12; 
  const hknpShape *v13; 
  __int64 v14; 
  signed int v15; 
  __int64 v16; 
  signed int v17; 
  int v18; 
  __int64 v19; 
  int v20; 
  hknpClosestPointsQuery querya; 
  hknpShapeQueryInfo queryShapeInfoa; 
  hkTransformf v25; 
  void (__fastcall *const *v26)(); 
  __int64 v27; 
  hknpSphereShape *v28; 
  int v29; 
  hknpSphereShape v30[2]; 
  hkTransformf v31; 

  v11 = *(_QWORD *)&query->m_shape[1].m_memSizeAndFlags;
  if ( *(_BYTE *)(v11 + 5504) )
  {
    v12 = 0i64;
    v27 = 0i64;
    v28 = v30;
    v29 = 128;
    v26 = hknpInplaceShapeBuffer<128>::`vftable';
    v13 = NULL;
    if ( *(_DWORD *)query->m_levelOfDetail == 3 )
    {
      hknpSphereShape::hknpSphereShape(v30, (const hkVector4f *)&g_vectorfConstants[5], 0.0);
      v12 = v14;
      *(_WORD *)(v14 + 16) = 0;
      v27 = v14;
      v13 = (const hknpShape *)v14;
    }
    v15 = 0;
    v20 = *(_DWORD *)(v11 + 5492);
    if ( v20 )
    {
      v16 = 0i64;
      do
      {
        if ( *(_BYTE *)(v11 + 5696) )
          v17 = *(_DWORD *)(v16 + *(_QWORD *)(v11 + 5728));
        else
          v17 = v15;
        v25.m_translation = *(hkVector4f *)(*(_QWORD *)(v11 + 304) + 32i64 * v17);
        if ( *(_BYTE *)(v11 + 5500) )
          hkRotationImpl<float>::set(&v25.m_rotation, (const hkQuaternionf *)(*(_QWORD *)(v11 + 320) + 16i64 * v17));
        else
          v25.m_rotation = *(hkRotationImpl<float> *)g_vectorfConstants[32].m128_f32;
        queryShapeInfoa.m_body = queryShapeInfo->m_body;
        queryShapeInfoa.m_rootShape = queryShapeInfo->m_rootShape;
        queryShapeInfoa.m_shapeKeyMask = NULL;
        queryShapeInfoa.m_scalingInternals.m_isScaled = queryShapeInfo->m_scalingInternals.m_isScaled;
        queryShapeInfoa.m_scalingInternals.m_mode = queryShapeInfo->m_scalingInternals.m_mode;
        *(__m256i *)queryShapeInfoa.m_scalingInternals.m_scale.m_quad.m128_f32 = *(__m256i *)queryShapeInfo->m_scalingInternals.m_scale.m_quad.m128_f32;
        queryShapeInfoa.m_scalingInternals.m_convexRadius = queryShapeInfo->m_scalingInternals.m_convexRadius;
        queryShapeInfoa.m_parentShape = query->m_shape;
        queryShapeInfoa.m_shapeToWorld = &v25;
        queryShapeInfoa.m_shapeKeyPath.m_key.m_value = v17;
        queryShapeInfoa.m_shapeKeyPath.m_size = 32;
        hkTransformf::setMul(&v31, queryToTarget, &v25);
        querya = *query;
        if ( *(_DWORD *)query->m_levelOfDetail == 3 )
        {
          if ( *(_DWORD *)(v11 + 48) )
            v18 = *(_DWORD *)(v17 * *(_DWORD *)(v11 + 52) + *(_QWORD *)(v11 + 40));
          else
            v18 = *(_DWORD *)(v11 + 32);
          v13->m_convexRadius = COERCE_FLOAT(*(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 24) + 24i64) + 8i64 * v18) + 32i64));
          querya.m_shape = v13;
        }
        else
        {
          if ( *(_DWORD *)(v11 + 48) )
            v19 = *(int *)(v17 * *(_DWORD *)(v11 + 52) + *(_QWORD *)(v11 + 40));
          else
            v19 = *(int *)(v11 + 32);
          querya.m_shape = *(const hknpShape **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 24) + 24i64) + 8 * v19) + 240i64);
        }
        hknpCollisionQueryDispatcher::getClosestPoints((hknpCollisionQueryDispatcher *)queryContext->m_dispatcher, queryContext, &querya, &queryShapeInfoa, targetShape, targetShapeFilterData, targetShapeInfo, &v31, queryAndTargetSwapped, collector);
        ++v15;
        v16 += 4i64;
      }
      while ( v15 != v20 );
      v12 = v27;
    }
    v26 = hknpShapeBuffer::`vftable';
    if ( v12 )
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v12 + 8i64))(v12, 0i64);
  }
}

