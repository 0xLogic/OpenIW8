/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage
==============
*/

const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  return ?GetPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEBAAEBUPage@1@G@Z(this, pageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage
==============
*/

const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  return ?GetPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEBAAEBUPage@1@G@Z(this, pageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/

void __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  ?UnlockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAAXAEAUPage@1@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/

unsigned __int16 __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  return ?AllocPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@QEAAGXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  return ?InsertIntoLockedPageWithOverflow@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@AEAA_NAEAUPage@1@AEAUCgDistanceCacheMpKey@@@Z(this, page, inOutKey);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$07UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  return ?LockNextPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEAU21@AEAG@Z(this, page, outNextPageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  return ?AddKey@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@QEAA_NAEBUCgDistanceCacheMpKey@@@Z(this, key);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage
==============
*/

OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  return ?LockPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEAAAEAUPage@1@AEBU21@@Z(this, page);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage
==============
*/

const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *__fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  return ?GetPage@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@AEBAAEBUPage@1@G@Z(this, pageIndex);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0DA@UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0HAI@UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate
==============
*/

bool __fastcall OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  return ?Validate@?$OneLevelSkipList@UCgDistanceCacheMpKey@@$04$0MI@UCgDistanceCacheMpCompareKey@@@@QEAA_NXZ(this);
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  int v5; 
  int v6; 

  if ( pageIndex >= 0x21u )
  {
    v6 = 33;
    v5 = pageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  return &this->m_pages[pageIndex];
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  int v5; 
  int v6; 

  if ( pageIndex >= 6u )
  {
    v6 = 6;
    v5 = pageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  return &this->m_pages[pageIndex];
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  CgDistanceCacheMpKey *m_linkKeys; 
  __int64 v5; 
  float distanceSq; 
  __int64 v7; 
  float v8; 
  unsigned __int16 v9; 
  __int64 v10; 
  float v11; 
  float v12; 
  unsigned __int16 nextPageIndex; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v14; 
  __int64 v15; 
  unsigned __int8 keyCount; 
  float v17; 
  float v18; 
  signed __int32 lock; 
  unsigned __int8 v20; 
  float v21; 
  float v22; 
  signed __int32 v23; 
  signed __int32 v24; 
  signed __int32 v25; 
  signed __int32 v26; 
  signed __int32 v27; 
  unsigned __int16 v28; 
  CgDistanceCacheMpKey v29; 
  CgDistanceCacheMpKey *keys; 
  __int64 v31; 
  __int64 v32; 
  float v33; 
  unsigned __int16 v34; 
  unsigned __int16 v35; 
  __int64 v36; 
  CgDistanceCacheMpKey v37; 
  __int64 v38; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v39; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *Page; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v41; 
  __int64 v43; 
  __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  unsigned __int16 outNextPageIndex; 
  CgDistanceCacheMpKey v48; 
  CgDistanceCacheMpKey v49; 

  m_linkKeys = this->m_linkKeys;
  v5 = 5i64;
  distanceSq = key->distanceSq;
  do
  {
    v7 = v5 >> 1;
    v8 = m_linkKeys[v5 >> 1].distanceSq;
    if ( v8 < distanceSq || v8 == distanceSq && m_linkKeys[v7].index < key->index )
    {
      m_linkKeys += v7 + 1;
      v5 += -1 - v7;
    }
    else
    {
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v9 = truncate_cast<unsigned short,__int64>(((char *)m_linkKeys - (char *)this - 364) >> 3);
  LOWORD(v10) = v9;
  if ( v9 == 5 )
    return 0;
  if ( v9 >= 5u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v9, 5) )
    __debugbreak();
  v11 = key->distanceSq;
  v10 = (unsigned __int16)v10;
  v12 = this->m_linkKeys[(unsigned __int16)v10].distanceSq;
  if ( v11 >= v12 && (v11 != v12 || key->index >= this->m_linkKeys[v10].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
    __debugbreak();
  nextPageIndex = this->m_linkPageIndices[v10];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 6 )
  {
    LODWORD(v46) = 6;
    LODWORD(v45) = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14 = NULL;
  if ( nextPageIndex == 6 )
    goto LABEL_78;
  while ( 1 )
  {
    if ( nextPageIndex >= 6u )
    {
      LODWORD(v44) = 6;
      LODWORD(v43) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v43, v44) )
        __debugbreak();
    }
    v15 = nextPageIndex;
    keyCount = this->m_pages[v15].meta.keyCount;
    v14 = &this->m_pages[v15];
    if ( keyCount < 7u || (v17 = key->distanceSq, v18 = *((float *)&v14->lock + 2 * keyCount), v17 < v18) || v17 == v18 && key->index < *(volatile int *)((char *)&this->m_nextFreePage + 8 * keyCount + v15 * 60) )
    {
      while ( 1 )
      {
        lock = v14->lock;
        if ( (v14->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v14, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v20 = v14->meta.keyCount;
      if ( v20 < 7u )
        goto LABEL_77;
      v21 = key->distanceSq;
      v22 = *((float *)&v14->lock + 2 * v20);
      if ( v21 < v22 || v21 == v22 && key->index < *((_DWORD *)v14 + 2 * v20 - 1) )
        goto LABEL_77;
      v23 = v14->lock;
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      v24 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v23 & 0xFFFFFF, v23);
      if ( v23 != v24 )
      {
        LODWORD(v46) = v23;
        LODWORD(v45) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
          __debugbreak();
      }
    }
    nextPageIndex = v14->meta.nextPageIndex;
    if ( v14->meta.nextPageIndex == 6 )
      break;
LABEL_71:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 6 )
    {
      v14 = NULL;
      goto LABEL_78;
    }
  }
  while ( 1 )
  {
    v25 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      if ( v25 == _InterlockedCompareExchange((volatile signed __int32 *)v14, v25 | 0xFF000000, v25) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( v14->meta.nextPageIndex != 6 )
  {
    v26 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
      __debugbreak();
    v27 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v26 & 0xFFFFFF, v26);
    if ( v26 != v27 )
    {
      LODWORD(v46) = v26;
      LODWORD(v45) = v27;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
        __debugbreak();
    }
    nextPageIndex = v14->meta.nextPageIndex;
    goto LABEL_71;
  }
  v28 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage(this);
  if ( v28 == 6 )
  {
    LODWORD(v46) = 6;
    LODWORD(v45) = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14->meta.nextPageIndex = v28;
  v14 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage(this, v14, &outNextPageIndex);
LABEL_77:
  if ( v14 )
    goto LABEL_81;
LABEL_78:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_81:
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v29 = *key;
  v48 = *key;
  while ( 1 )
  {
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keys = v14->keys;
    v31 = (8i64 * v14->meta.keyCount) >> 3;
    while ( v31 > 0 )
    {
      v32 = v31 >> 1;
      v33 = keys[v31 >> 1].distanceSq;
      if ( v33 < v48.distanceSq || v33 == v48.distanceSq && keys[v32].index < v29.index )
      {
        keys += v32 + 1;
        v31 += -1 - v32;
      }
      else
      {
        v31 >>= 1;
      }
    }
    v34 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)v14 - 4) >> 3);
    v35 = v14->meta.keyCount;
    v49 = v29;
    if ( v34 < v35 )
    {
      do
      {
        v36 = v34;
        v37 = v29;
        ++v34;
        v29 = v14->keys[v36];
        v14->keys[v36] = v37;
        v35 = v14->meta.keyCount;
      }
      while ( v34 < v35 );
      v49 = v29;
    }
    if ( v34 < 7u )
      break;
    v48 = v29;
    if ( (_BYTE)v35 == 7 && v14->meta.nextPageIndex == 6 )
    {
      if ( this->m_nextFreePage == 6 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
        __debugbreak();
      v38 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
      v39 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v38]);
      v39->meta.nextPageIndex = 6;
      v39->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v39);
      if ( (_DWORD)v38 == 6 )
      {
        LODWORD(v46) = 6;
        LODWORD(v45) = 6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      if ( v14->meta.nextPageIndex != 6 )
      {
        LODWORD(v46) = 6;
        LODWORD(v45) = v14->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      v14->meta.nextPageIndex = v38;
    }
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( v14->meta.nextPageIndex == 6 )
    {
      LODWORD(v46) = 6;
      LODWORD(v45) = 6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
        __debugbreak();
    }
    outNextPageIndex = v14->meta.nextPageIndex;
    Page = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(this, outNextPageIndex);
    v41 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(this, Page);
    OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
    v14 = v41;
  }
  v14->keys[(unsigned __int8)v35] = v29;
  ++v14->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  CgDistanceCacheMpKey *m_linkKeys; 
  __int64 v5; 
  float distanceSq; 
  __int64 v7; 
  float v8; 
  unsigned __int16 v9; 
  __int64 v10; 
  float v11; 
  float v12; 
  unsigned __int16 nextPageIndex; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v14; 
  __int64 v15; 
  unsigned __int8 keyCount; 
  float v17; 
  float v18; 
  signed __int32 lock; 
  unsigned __int8 v20; 
  float v21; 
  float v22; 
  signed __int32 v23; 
  signed __int32 v24; 
  signed __int32 v25; 
  signed __int32 v26; 
  signed __int32 v27; 
  unsigned __int16 v28; 
  CgDistanceCacheMpKey v29; 
  CgDistanceCacheMpKey *keys; 
  __int64 v31; 
  __int64 v32; 
  float v33; 
  unsigned __int16 v34; 
  unsigned __int16 v35; 
  __int64 v36; 
  CgDistanceCacheMpKey v37; 
  __int64 v38; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v39; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *Page; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v41; 
  __int64 v43; 
  __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  unsigned __int16 outNextPageIndex; 
  CgDistanceCacheMpKey v48; 
  CgDistanceCacheMpKey v49; 

  m_linkKeys = this->m_linkKeys;
  v5 = 5i64;
  distanceSq = key->distanceSq;
  do
  {
    v7 = v5 >> 1;
    v8 = m_linkKeys[v5 >> 1].distanceSq;
    if ( v8 < distanceSq || v8 == distanceSq && m_linkKeys[v7].index < key->index )
    {
      m_linkKeys += v7 + 1;
      v5 += -1 - v7;
    }
    else
    {
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v9 = truncate_cast<unsigned short,__int64>(((char *)m_linkKeys - (char *)this - 664) >> 3);
  LOWORD(v10) = v9;
  if ( v9 == 5 )
    return 0;
  if ( v9 >= 5u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v9, 5) )
    __debugbreak();
  v11 = key->distanceSq;
  v10 = (unsigned __int16)v10;
  v12 = this->m_linkKeys[(unsigned __int16)v10].distanceSq;
  if ( v11 >= v12 && (v11 != v12 || key->index >= this->m_linkKeys[v10].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
    __debugbreak();
  nextPageIndex = this->m_linkPageIndices[v10];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 11 )
  {
    LODWORD(v46) = 11;
    LODWORD(v45) = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14 = NULL;
  if ( nextPageIndex == 11 )
    goto LABEL_78;
  while ( 1 )
  {
    if ( nextPageIndex >= 0xBu )
    {
      LODWORD(v44) = 11;
      LODWORD(v43) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v43, v44) )
        __debugbreak();
    }
    v15 = nextPageIndex;
    keyCount = this->m_pages[v15].meta.keyCount;
    v14 = &this->m_pages[v15];
    if ( keyCount < 7u || (v17 = key->distanceSq, v18 = *((float *)&v14->lock + 2 * keyCount), v17 < v18) || v17 == v18 && key->index < *(volatile int *)((char *)&this->m_nextFreePage + 8 * keyCount + v15 * 60) )
    {
      while ( 1 )
      {
        lock = v14->lock;
        if ( (v14->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v14, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v20 = v14->meta.keyCount;
      if ( v20 < 7u )
        goto LABEL_77;
      v21 = key->distanceSq;
      v22 = *((float *)&v14->lock + 2 * v20);
      if ( v21 < v22 || v21 == v22 && key->index < *((_DWORD *)v14 + 2 * v20 - 1) )
        goto LABEL_77;
      v23 = v14->lock;
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      v24 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v23 & 0xFFFFFF, v23);
      if ( v23 != v24 )
      {
        LODWORD(v46) = v23;
        LODWORD(v45) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
          __debugbreak();
      }
    }
    nextPageIndex = v14->meta.nextPageIndex;
    if ( v14->meta.nextPageIndex == 11 )
      break;
LABEL_71:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 11 )
    {
      v14 = NULL;
      goto LABEL_78;
    }
  }
  while ( 1 )
  {
    v25 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      if ( v25 == _InterlockedCompareExchange((volatile signed __int32 *)v14, v25 | 0xFF000000, v25) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( v14->meta.nextPageIndex != 11 )
  {
    v26 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
      __debugbreak();
    v27 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v26 & 0xFFFFFF, v26);
    if ( v26 != v27 )
    {
      LODWORD(v46) = v26;
      LODWORD(v45) = v27;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
        __debugbreak();
    }
    nextPageIndex = v14->meta.nextPageIndex;
    goto LABEL_71;
  }
  v28 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage(this);
  if ( v28 == 11 )
  {
    LODWORD(v46) = 11;
    LODWORD(v45) = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14->meta.nextPageIndex = v28;
  v14 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage(this, v14, &outNextPageIndex);
LABEL_77:
  if ( v14 )
    goto LABEL_81;
LABEL_78:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_81:
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v29 = *key;
  v48 = *key;
  while ( 1 )
  {
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keys = v14->keys;
    v31 = (8i64 * v14->meta.keyCount) >> 3;
    while ( v31 > 0 )
    {
      v32 = v31 >> 1;
      v33 = keys[v31 >> 1].distanceSq;
      if ( v33 < v48.distanceSq || v33 == v48.distanceSq && keys[v32].index < v29.index )
      {
        keys += v32 + 1;
        v31 += -1 - v32;
      }
      else
      {
        v31 >>= 1;
      }
    }
    v34 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)v14 - 4) >> 3);
    v35 = v14->meta.keyCount;
    v49 = v29;
    if ( v34 < v35 )
    {
      do
      {
        v36 = v34;
        v37 = v29;
        ++v34;
        v29 = v14->keys[v36];
        v14->keys[v36] = v37;
        v35 = v14->meta.keyCount;
      }
      while ( v34 < v35 );
      v49 = v29;
    }
    if ( v34 < 7u )
      break;
    v48 = v29;
    if ( (_BYTE)v35 == 7 && v14->meta.nextPageIndex == 11 )
    {
      if ( this->m_nextFreePage == 11 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
        __debugbreak();
      v38 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
      v39 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v38]);
      v39->meta.nextPageIndex = 11;
      v39->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v39);
      if ( (_DWORD)v38 == 11 )
      {
        LODWORD(v46) = 11;
        LODWORD(v45) = 11;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      if ( v14->meta.nextPageIndex != 11 )
      {
        LODWORD(v46) = 11;
        LODWORD(v45) = v14->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      v14->meta.nextPageIndex = v38;
    }
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( v14->meta.nextPageIndex == 11 )
    {
      LODWORD(v46) = 11;
      LODWORD(v45) = 11;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
        __debugbreak();
    }
    outNextPageIndex = v14->meta.nextPageIndex;
    Page = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(this, outNextPageIndex);
    v41 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(this, Page);
    OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
    v14 = v41;
  }
  v14->keys[(unsigned __int8)v35] = v29;
  ++v14->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  CgDistanceCacheMpKey *m_linkKeys; 
  __int64 v5; 
  float distanceSq; 
  float v7; 
  CgDistanceCacheMpKey *v8; 
  unsigned __int16 v9; 
  __int64 v10; 
  float v11; 
  float v12; 
  unsigned __int16 nextPageIndex; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v14; 
  __int64 v15; 
  unsigned __int8 keyCount; 
  float v17; 
  float v18; 
  signed __int32 lock; 
  unsigned __int8 v20; 
  float v21; 
  float v22; 
  signed __int32 v23; 
  signed __int32 v24; 
  signed __int32 v25; 
  signed __int32 v26; 
  signed __int32 v27; 
  unsigned __int16 v28; 
  CgDistanceCacheMpKey v29; 
  CgDistanceCacheMpKey *keys; 
  __int64 v31; 
  __int64 v32; 
  float v33; 
  unsigned __int16 v34; 
  unsigned __int16 v35; 
  __int64 v36; 
  CgDistanceCacheMpKey v37; 
  __int64 v38; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v39; 
  unsigned __int16 v40; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v41; 
  __int64 v43; 
  __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  unsigned __int16 outNextPageIndex; 
  CgDistanceCacheMpKey v48; 
  CgDistanceCacheMpKey v49; 

  m_linkKeys = this->m_linkKeys;
  v5 = 5i64;
  distanceSq = key->distanceSq;
  do
  {
    v7 = m_linkKeys[v5 >> 1].distanceSq;
    v8 = &m_linkKeys[v5 >> 1];
    if ( v7 < distanceSq || v7 == distanceSq && v8->index < key->index )
    {
      m_linkKeys = v8 + 1;
      v5 += -1 - (v5 >> 1);
    }
    else
    {
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v9 = truncate_cast<unsigned short,__int64>(((char *)m_linkKeys - (char *)this - 15724) >> 3);
  LOWORD(v10) = v9;
  if ( v9 == 5 )
    return 0;
  if ( v9 >= 5u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v9, 5) )
    __debugbreak();
  v11 = key->distanceSq;
  v10 = (unsigned __int16)v10;
  v12 = this->m_linkKeys[(unsigned __int16)v10].distanceSq;
  if ( v11 >= v12 && (v11 != v12 || key->index >= this->m_linkKeys[v10].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
    __debugbreak();
  nextPageIndex = this->m_linkPageIndices[v10];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 262 )
  {
    LODWORD(v46) = 262;
    LODWORD(v45) = 262;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14 = NULL;
  if ( nextPageIndex == 262 )
    goto LABEL_78;
  while ( 1 )
  {
    if ( nextPageIndex >= 0x106u )
    {
      LODWORD(v44) = 262;
      LODWORD(v43) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v43, v44) )
        __debugbreak();
    }
    v15 = nextPageIndex;
    keyCount = this->m_pages[v15].meta.keyCount;
    v14 = &this->m_pages[v15];
    if ( keyCount < 7u || (v17 = key->distanceSq, v18 = *((float *)&v14->lock + 2 * keyCount), v17 < v18) || v17 == v18 && key->index < *(volatile int *)((char *)&this->m_nextFreePage + 8 * keyCount + v15 * 60) )
    {
      while ( 1 )
      {
        lock = v14->lock;
        if ( (v14->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v14, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v20 = v14->meta.keyCount;
      if ( v20 < 7u )
        goto LABEL_77;
      v21 = key->distanceSq;
      v22 = *((float *)&v14->lock + 2 * v20);
      if ( v21 < v22 || v21 == v22 && key->index < *((_DWORD *)v14 + 2 * v20 - 1) )
        goto LABEL_77;
      v23 = v14->lock;
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      v24 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v23 & 0xFFFFFF, v23);
      if ( v23 != v24 )
      {
        LODWORD(v46) = v23;
        LODWORD(v45) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
          __debugbreak();
      }
    }
    nextPageIndex = v14->meta.nextPageIndex;
    if ( v14->meta.nextPageIndex == 262 )
      break;
LABEL_71:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 262 )
    {
      v14 = NULL;
      goto LABEL_78;
    }
  }
  while ( 1 )
  {
    v25 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      if ( v25 == _InterlockedCompareExchange((volatile signed __int32 *)v14, v25 | 0xFF000000, v25) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( v14->meta.nextPageIndex != 262 )
  {
    v26 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
      __debugbreak();
    v27 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v26 & 0xFFFFFF, v26);
    if ( v26 != v27 )
    {
      LODWORD(v46) = v26;
      LODWORD(v45) = v27;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
        __debugbreak();
    }
    nextPageIndex = v14->meta.nextPageIndex;
    goto LABEL_71;
  }
  v28 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage(this);
  if ( v28 == 262 )
  {
    LODWORD(v46) = 262;
    LODWORD(v45) = 262;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14->meta.nextPageIndex = v28;
  v14 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage(this, v14, &outNextPageIndex);
LABEL_77:
  if ( v14 )
    goto LABEL_81;
LABEL_78:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_81:
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v29 = *key;
  v48 = *key;
  while ( 1 )
  {
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keys = v14->keys;
    v31 = (8i64 * v14->meta.keyCount) >> 3;
    while ( v31 > 0 )
    {
      v32 = v31 >> 1;
      v33 = keys[v31 >> 1].distanceSq;
      if ( v33 < v48.distanceSq || v33 == v48.distanceSq && keys[v32].index < v29.index )
      {
        keys += v32 + 1;
        v31 += -1 - v32;
      }
      else
      {
        v31 >>= 1;
      }
    }
    v34 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)v14 - 4) >> 3);
    v35 = v14->meta.keyCount;
    v49 = v29;
    if ( v34 < v35 )
    {
      do
      {
        v36 = v34;
        v37 = v29;
        ++v34;
        v29 = v14->keys[v36];
        v14->keys[v36] = v37;
        v35 = v14->meta.keyCount;
      }
      while ( v34 < v35 );
      v49 = v29;
    }
    if ( v34 < 7u )
      break;
    v48 = v29;
    if ( (_BYTE)v35 == 7 && v14->meta.nextPageIndex == 262 )
    {
      if ( this->m_nextFreePage == 262 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
        __debugbreak();
      v38 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
      v39 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v38]);
      v39->meta.nextPageIndex = 262;
      v39->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v39);
      if ( (_WORD)v38 == 262 )
      {
        LODWORD(v46) = 262;
        LODWORD(v45) = 262;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      if ( v14->meta.nextPageIndex != 262 )
      {
        LODWORD(v46) = 262;
        LODWORD(v45) = v14->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      v14->meta.nextPageIndex = v38;
    }
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( v14->meta.nextPageIndex == 262 )
    {
      LODWORD(v46) = 262;
      LODWORD(v45) = 262;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
        __debugbreak();
    }
    v40 = v14->meta.nextPageIndex;
    outNextPageIndex = v40;
    if ( v40 >= 0x106u )
    {
      LODWORD(v44) = 262;
      LODWORD(v43) = v40;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v43, v44) )
        __debugbreak();
    }
    v41 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v40]);
    OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
    v14 = v41;
  }
  v14->keys[(unsigned __int8)v35] = v29;
  ++v14->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AddKey(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const CgDistanceCacheMpKey *key)
{
  CgDistanceCacheMpKey *m_linkKeys; 
  __int64 v5; 
  float distanceSq; 
  __int64 v7; 
  float v8; 
  unsigned __int16 v9; 
  __int64 v10; 
  float v11; 
  float v12; 
  unsigned __int16 nextPageIndex; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v14; 
  __int64 v15; 
  unsigned __int8 keyCount; 
  float v17; 
  float v18; 
  signed __int32 lock; 
  unsigned __int8 v20; 
  float v21; 
  float v22; 
  signed __int32 v23; 
  signed __int32 v24; 
  signed __int32 v25; 
  signed __int32 v26; 
  signed __int32 v27; 
  unsigned __int16 v28; 
  CgDistanceCacheMpKey v29; 
  CgDistanceCacheMpKey *keys; 
  __int64 v31; 
  __int64 v32; 
  float v33; 
  unsigned __int16 v34; 
  unsigned __int16 v35; 
  __int64 v36; 
  CgDistanceCacheMpKey v37; 
  __int64 v38; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v39; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *Page; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v41; 
  __int64 v43; 
  __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  unsigned __int16 outNextPageIndex; 
  CgDistanceCacheMpKey v48; 
  CgDistanceCacheMpKey v49; 

  m_linkKeys = this->m_linkKeys;
  v5 = 5i64;
  distanceSq = key->distanceSq;
  do
  {
    v7 = v5 >> 1;
    v8 = m_linkKeys[v5 >> 1].distanceSq;
    if ( v8 < distanceSq || v8 == distanceSq && m_linkKeys[v7].index < key->index )
    {
      m_linkKeys += v7 + 1;
      v5 += -1 - v7;
    }
    else
    {
      v5 >>= 1;
    }
  }
  while ( v5 > 0 );
  v9 = truncate_cast<unsigned short,__int64>(((char *)m_linkKeys - (char *)this - 1984) >> 3);
  LOWORD(v10) = v9;
  if ( v9 == 5 )
    return 0;
  if ( v9 >= 5u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 223, ASSERT_TYPE_ASSERT, "( linkIndex ) < ( LINK_COUNT )", "%s < %s\n\t%i, %i", "linkIndex", "LINK_COUNT", v9, 5) )
    __debugbreak();
  v11 = key->distanceSq;
  v10 = (unsigned __int16)v10;
  v12 = this->m_linkKeys[(unsigned __int16)v10].distanceSq;
  if ( v11 >= v12 && (v11 != v12 || key->index >= this->m_linkKeys[v10].index) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 224, ASSERT_TYPE_ASSERT, "(m_compare( key, m_linkKeys[linkIndex] ))", (const char *)&queryFormat, "m_compare( key, m_linkKeys[linkIndex] )") )
    __debugbreak();
  nextPageIndex = this->m_linkPageIndices[v10];
  outNextPageIndex = nextPageIndex;
  if ( nextPageIndex == 33 )
  {
    LODWORD(v46) = 33;
    LODWORD(v45) = 33;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 229, ASSERT_TYPE_ASSERT, "( pageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "pageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14 = NULL;
  if ( nextPageIndex == 33 )
    goto LABEL_78;
  while ( 1 )
  {
    if ( nextPageIndex >= 0x21u )
    {
      LODWORD(v44) = 33;
      LODWORD(v43) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v43, v44) )
        __debugbreak();
    }
    v15 = nextPageIndex;
    keyCount = this->m_pages[v15].meta.keyCount;
    v14 = &this->m_pages[v15];
    if ( keyCount < 7u || (v17 = key->distanceSq, v18 = *((float *)&v14->lock + 2 * keyCount), v17 < v18) || v17 == v18 && key->index < *(volatile int *)((char *)&this->m_nextFreePage + 8 * keyCount + v15 * 60) )
    {
      while ( 1 )
      {
        lock = v14->lock;
        if ( (v14->lock & 0xFF000000) == 0 )
        {
          if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
            __debugbreak();
          if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v14, lock | 0xFF000000, lock) )
            break;
        }
        Sys_Sleep(0);
      }
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
        __debugbreak();
      v20 = v14->meta.keyCount;
      if ( v20 < 7u )
        goto LABEL_77;
      v21 = key->distanceSq;
      v22 = *((float *)&v14->lock + 2 * v20);
      if ( v21 < v22 || v21 == v22 && key->index < *((_DWORD *)v14 + 2 * v20 - 1) )
        goto LABEL_77;
      v23 = v14->lock;
      if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
        __debugbreak();
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      v24 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v23 & 0xFFFFFF, v23);
      if ( v23 != v24 )
      {
        LODWORD(v46) = v23;
        LODWORD(v45) = v24;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
          __debugbreak();
      }
    }
    nextPageIndex = v14->meta.nextPageIndex;
    if ( v14->meta.nextPageIndex == 33 )
      break;
LABEL_71:
    outNextPageIndex = nextPageIndex;
    if ( nextPageIndex == 33 )
    {
      v14 = NULL;
      goto LABEL_78;
    }
  }
  while ( 1 )
  {
    v25 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
        __debugbreak();
      if ( v25 == _InterlockedCompareExchange((volatile signed __int32 *)v14, v25 | 0xFF000000, v25) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( v14->meta.nextPageIndex != 33 )
  {
    v26 = v14->lock;
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v14 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v14) )
      __debugbreak();
    v27 = _InterlockedCompareExchange((volatile signed __int32 *)v14, v26 & 0xFFFFFF, v26);
    if ( v26 != v27 )
    {
      LODWORD(v46) = v26;
      LODWORD(v45) = v27;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v45, v46) )
        __debugbreak();
    }
    nextPageIndex = v14->meta.nextPageIndex;
    goto LABEL_71;
  }
  v28 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage(this);
  if ( v28 == 33 )
  {
    LODWORD(v46) = 33;
    LODWORD(v45) = 33;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 255, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
      __debugbreak();
  }
  v14->meta.nextPageIndex = v28;
  v14 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage(this, v14, &outNextPageIndex);
LABEL_77:
  if ( v14 )
    goto LABEL_81;
LABEL_78:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 269, ASSERT_TYPE_ASSERT, "(mutablePage)", (const char *)&queryFormat, "mutablePage") )
    __debugbreak();
LABEL_81:
  if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 270, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  v29 = *key;
  v48 = *key;
  while ( 1 )
  {
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keys = v14->keys;
    v31 = (8i64 * v14->meta.keyCount) >> 3;
    while ( v31 > 0 )
    {
      v32 = v31 >> 1;
      v33 = keys[v31 >> 1].distanceSq;
      if ( v33 < v48.distanceSq || v33 == v48.distanceSq && keys[v32].index < v29.index )
      {
        keys += v32 + 1;
        v31 += -1 - v32;
      }
      else
      {
        v31 >>= 1;
      }
    }
    v34 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)v14 - 4) >> 3);
    v35 = v14->meta.keyCount;
    v49 = v29;
    if ( v34 < v35 )
    {
      do
      {
        v36 = v34;
        v37 = v29;
        ++v34;
        v29 = v14->keys[v36];
        v14->keys[v36] = v37;
        v35 = v14->meta.keyCount;
      }
      while ( v34 < v35 );
      v49 = v29;
    }
    if ( v34 < 7u )
      break;
    v48 = v29;
    if ( (_BYTE)v35 == 7 && v14->meta.nextPageIndex == 33 )
    {
      if ( this->m_nextFreePage == 33 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
      if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
        __debugbreak();
      v38 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
      v39 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v38]);
      v39->meta.nextPageIndex = 33;
      v39->meta.keyCount = 0;
      OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v39);
      if ( (_DWORD)v38 == 33 )
      {
        LODWORD(v46) = 33;
        LODWORD(v45) = 33;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 278, ASSERT_TYPE_ASSERT, "( newPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "newPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      if ( v14->meta.nextPageIndex != 33 )
      {
        LODWORD(v46) = 33;
        LODWORD(v45) = v14->meta.nextPageIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 279, ASSERT_TYPE_ASSERT, "( mutablePage->meta.nextPageIndex ) == ( PAGE_COUNT )", "%s == %s\n\t%i, %i", "mutablePage->meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
          __debugbreak();
      }
      v14->meta.nextPageIndex = v38;
    }
    if ( (v14->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( v14->meta.nextPageIndex == 33 )
    {
      LODWORD(v46) = 33;
      LODWORD(v45) = 33;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v45, v46) )
        __debugbreak();
    }
    outNextPageIndex = v14->meta.nextPageIndex;
    Page = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(this, outNextPageIndex);
    v41 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(this, Page);
    OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
    v14 = v41;
  }
  v14->keys[(unsigned __int8)v35] = v29;
  ++v14->meta.keyCount;
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v14);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 6 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.nextPageIndex = 6;
  v3->meta.keyCount = 0;
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 11 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.nextPageIndex = 11;
  v3->meta.keyCount = 0;
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 262 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.keyCount = 0;
  v3->meta.nextPageIndex = 262;
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage
==============
*/
__int64 OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::AllocPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  unsigned __int16 v2; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v3; 

  if ( this->m_nextFreePage == 33 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CFEBF0, 5843i64);
  if ( ((unsigned __int8)this & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", this) )
    __debugbreak();
  v2 = truncate_cast<unsigned short,int>(_InterlockedExchangeAdd(&this->m_nextFreePage, 1u));
  v3 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[v2]);
  v3->meta.nextPageIndex = 33;
  v3->meta.keyCount = 0;
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v3);
  return v2;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, unsigned __int16 pageIndex)
{
  int v5; 
  int v6; 

  if ( pageIndex >= 0xBu )
  {
    v6 = 11;
    v5 = pageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  return &this->m_pages[pageIndex];
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  CgDistanceCacheMpKey *keys; 
  __int64 v6; 
  float distanceSq; 
  __int64 v8; 
  float v9; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  keys = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    distanceSq = inOutKey->distanceSq;
    do
    {
      v8 = v6 >> 1;
      v9 = keys[v6 >> 1].distanceSq;
      if ( v9 < distanceSq || v9 == distanceSq && keys[v8].index < inOutKey->index )
      {
        keys += v8 + 1;
        v6 += -1 - v8;
      }
      else
      {
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)page - 4) >> 3);
  v11 = *inOutKey;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *inOutKey = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  CgDistanceCacheMpKey *keys; 
  __int64 v6; 
  float distanceSq; 
  __int64 v8; 
  float v9; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  keys = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    distanceSq = inOutKey->distanceSq;
    do
    {
      v8 = v6 >> 1;
      v9 = keys[v6 >> 1].distanceSq;
      if ( v9 < distanceSq || v9 == distanceSq && keys[v8].index < inOutKey->index )
      {
        keys += v8 + 1;
        v6 += -1 - v8;
      }
      else
      {
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)page - 4) >> 3);
  v11 = *inOutKey;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *inOutKey = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  CgDistanceCacheMpKey *keys; 
  __int64 v6; 
  float distanceSq; 
  __int64 v8; 
  float v9; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  keys = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    distanceSq = inOutKey->distanceSq;
    do
    {
      v8 = v6 >> 1;
      v9 = keys[v6 >> 1].distanceSq;
      if ( v9 < distanceSq || v9 == distanceSq && keys[v8].index < inOutKey->index )
      {
        keys += v8 + 1;
        v6 += -1 - v8;
      }
      else
      {
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)page - 4) >> 3);
  v11 = *inOutKey;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *inOutKey = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow
==============
*/
bool OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::InsertIntoLockedPageWithOverflow(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, CgDistanceCacheMpKey *inOutKey)
{
  CgDistanceCacheMpKey *keys; 
  __int64 v6; 
  float distanceSq; 
  __int64 v8; 
  float v9; 
  unsigned __int8 v10; 
  CgDistanceCacheMpKey v11; 
  unsigned __int16 v12; 
  unsigned __int16 i; 
  __int64 v14; 
  CgDistanceCacheMpKey v15; 
  bool result; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 352, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  keys = page->keys;
  v6 = (8i64 * page->meta.keyCount) >> 3;
  if ( v6 > 0 )
  {
    distanceSq = inOutKey->distanceSq;
    do
    {
      v8 = v6 >> 1;
      v9 = keys[v6 >> 1].distanceSq;
      if ( v9 < distanceSq || v9 == distanceSq && keys[v8].index < inOutKey->index )
      {
        keys += v8 + 1;
        v6 += -1 - v8;
      }
      else
      {
        v6 >>= 1;
      }
    }
    while ( v6 > 0 );
  }
  v10 = truncate_cast<unsigned char,__int64>(((char *)keys - (char *)page - 4) >> 3);
  v11 = *inOutKey;
  v12 = v10;
  for ( i = page->meta.keyCount; v12 < i; i = page->meta.keyCount )
  {
    v14 = v12;
    v15 = v11;
    ++v12;
    v11 = page->keys[v14];
    page->keys[v14] = v15;
  }
  if ( v12 >= 7u )
  {
    result = 1;
    *inOutKey = v11;
  }
  else
  {
    page->keys[(unsigned __int8)i] = v11;
    ++page->meta.keyCount;
    return 0;
  }
  return result;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v7; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v8; 
  int v10; 
  int v11; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 6 )
  {
    v11 = 6;
    v10 = 6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v10, v11) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::GetPage(this, nextPageIndex);
  v8 = OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(this, v7);
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v8;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v7; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v8; 
  int v10; 
  int v11; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 11 )
  {
    v11 = 11;
    v10 = 11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v10, v11) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::GetPage(this, nextPageIndex);
  v8 = OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(this, v7);
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v8;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v7; 
  __int64 v9; 
  __int64 v10; 
  int v11; 
  int v12; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 262 )
  {
    v12 = 262;
    v11 = 262;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v11, v12) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  if ( nextPageIndex >= 0x106u )
  {
    LODWORD(v10) = 262;
    LODWORD(v9) = nextPageIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v9, v10) )
      __debugbreak();
  }
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(this, &this->m_pages[nextPageIndex]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v7;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockNextPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page, unsigned __int16 *outNextPageIndex)
{
  unsigned __int16 nextPageIndex; 
  const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v7; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v8; 
  int v10; 
  int v11; 

  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 336, ASSERT_TYPE_ASSERT, "(page.lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "page.lock & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( page->meta.nextPageIndex == 33 )
  {
    v11 = 33;
    v10 = 33;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 337, ASSERT_TYPE_ASSERT, "( page.meta.nextPageIndex ) != ( PAGE_COUNT )", "%s != %s\n\t%i, %i", "page.meta.nextPageIndex", "PAGE_COUNT", v10, v11) )
      __debugbreak();
  }
  nextPageIndex = page->meta.nextPageIndex;
  *outNextPageIndex = page->meta.nextPageIndex;
  v7 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::GetPage(this, nextPageIndex);
  v8 = OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(this, v7);
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, page);
  return v8;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage
==============
*/
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::LockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, const OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 

  while ( 1 )
  {
    lock = page->lock;
    if ( (page->lock & 0xFF000000) == 0 )
    {
      if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
        __debugbreak();
      if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)page, lock | 0xFF000000, lock) )
        break;
    }
    Sys_Sleep(0);
  }
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
    __debugbreak();
  return (OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *)page;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage
==============
*/
void OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this, OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *page)
{
  signed __int32 lock; 
  signed __int32 v4; 
  signed __int32 v5; 
  signed __int32 v6; 

  lock = page->lock;
  if ( (page->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
    __debugbreak();
  if ( ((unsigned __int8)page & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", page) )
    __debugbreak();
  v4 = _InterlockedCompareExchange((volatile signed __int32 *)page, lock & 0xFFFFFF, lock);
  if ( lock != v4 )
  {
    v6 = lock;
    v5 = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v5, v6) )
      __debugbreak();
  }
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey> *this)
{
  float *v1; 
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  float distanceSq; 
  CgDistanceCacheMpKey *v11; 
  float v12; 
  float v13; 
  signed __int32 v14; 
  signed __int32 v15; 
  char *fmt; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  v1 = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 6u;
    if ( nextPageIndex != 6 )
      break;
LABEL_37:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v19) = 6;
      LODWORD(v18) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_27:
    v14 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v15 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v14 & 0xFFFFFF, v14);
    if ( v14 != v15 )
    {
      LODWORD(v21) = v14;
      LODWORD(v20) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v20, v21) )
        __debugbreak();
    }
    v5 = nextPageIndex < 6u;
    if ( nextPageIndex == 6 )
      goto LABEL_37;
  }
  v9 = 0;
  distanceSq = this->m_linkKeys[v3].distanceSq;
  while ( 1 )
  {
    v11 = &v6->keys[v9];
    v12 = v6->keys[v9].distanceSq;
    if ( v12 >= distanceSq && (v12 != distanceSq || v11->index >= this->m_linkKeys[v3].index) )
    {
      Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    if ( v1 )
    {
      v13 = v1[1];
      if ( v13 >= v12 && (v13 != v12 || *(_DWORD *)v1 >= v11->index) )
        break;
    }
    ++v9;
    v1 = (float *)v11;
    if ( v9 >= keyCount )
      goto LABEL_27;
  }
  LODWORD(v18) = v9;
  LODWORD(fmt) = nextPageIndex;
  Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", v1, v3, fmt, v18, &v6->keys[v9]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,8,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey> *this)
{
  float *v1; 
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  float distanceSq; 
  CgDistanceCacheMpKey *v11; 
  float v12; 
  float v13; 
  signed __int32 v14; 
  signed __int32 v15; 
  char *fmt; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  v1 = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 0xBu;
    if ( nextPageIndex != 11 )
      break;
LABEL_37:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v19) = 11;
      LODWORD(v18) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_27:
    v14 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v15 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v14 & 0xFFFFFF, v14);
    if ( v14 != v15 )
    {
      LODWORD(v21) = v14;
      LODWORD(v20) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v20, v21) )
        __debugbreak();
    }
    v5 = nextPageIndex < 0xBu;
    if ( nextPageIndex == 11 )
      goto LABEL_37;
  }
  v9 = 0;
  distanceSq = this->m_linkKeys[v3].distanceSq;
  while ( 1 )
  {
    v11 = &v6->keys[v9];
    v12 = v6->keys[v9].distanceSq;
    if ( v12 >= distanceSq && (v12 != distanceSq || v11->index >= this->m_linkKeys[v3].index) )
    {
      Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    if ( v1 )
    {
      v13 = v1[1];
      if ( v13 >= v12 && (v13 != v12 || *(_DWORD *)v1 >= v11->index) )
        break;
    }
    ++v9;
    v1 = (float *)v11;
    if ( v9 >= keyCount )
      goto LABEL_27;
  }
  LODWORD(v18) = v9;
  LODWORD(fmt) = nextPageIndex;
  Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", v1, v3, fmt, v18, &v6->keys[v9]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,48,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey> *this)
{
  float *v1; 
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  float distanceSq; 
  CgDistanceCacheMpKey *v11; 
  float v12; 
  float v13; 
  signed __int32 v14; 
  signed __int32 v15; 
  char *fmt; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  v1 = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 0x106u;
    if ( nextPageIndex != 262 )
      break;
LABEL_37:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v19) = 262;
      LODWORD(v18) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_27:
    v14 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v15 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v14 & 0xFFFFFF, v14);
    if ( v14 != v15 )
    {
      LODWORD(v21) = v14;
      LODWORD(v20) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v20, v21) )
        __debugbreak();
    }
    v5 = nextPageIndex < 0x106u;
    if ( nextPageIndex == 262 )
      goto LABEL_37;
  }
  v9 = 0;
  distanceSq = this->m_linkKeys[v3].distanceSq;
  while ( 1 )
  {
    v11 = &v6->keys[v9];
    v12 = v6->keys[v9].distanceSq;
    if ( v12 >= distanceSq && (v12 != distanceSq || v11->index >= this->m_linkKeys[v3].index) )
    {
      Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    if ( v1 )
    {
      v13 = v1[1];
      if ( v13 >= v12 && (v13 != v12 || *(_DWORD *)v1 >= v11->index) )
        break;
    }
    ++v9;
    v1 = (float *)v11;
    if ( v9 >= keyCount )
      goto LABEL_27;
  }
  LODWORD(v18) = v9;
  LODWORD(fmt) = nextPageIndex;
  Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", v1, v3, fmt, v18, &v6->keys[v9]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,1800,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

/*
==============
OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate
==============
*/
char OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Validate(OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey> *this)
{
  float *v1; 
  unsigned __int16 v3; 
  unsigned __int16 nextPageIndex; 
  bool v5; 
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::Page *v6; 
  signed __int32 lock; 
  unsigned __int8 keyCount; 
  unsigned __int8 v9; 
  float distanceSq; 
  CgDistanceCacheMpKey *v11; 
  float v12; 
  float v13; 
  signed __int32 v14; 
  signed __int32 v15; 
  char *fmt; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  v1 = NULL;
  v3 = 0;
  while ( 1 )
  {
    nextPageIndex = this->m_linkPageIndices[v3];
    v5 = nextPageIndex < 0x21u;
    if ( nextPageIndex != 33 )
      break;
LABEL_37:
    if ( ++v3 >= 5u )
      return 1;
  }
  while ( 1 )
  {
    if ( !v5 )
    {
      LODWORD(v19) = 33;
      LODWORD(v18) = nextPageIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 293, ASSERT_TYPE_ASSERT, "(unsigned)( pageIndex ) < (unsigned)( PAGE_COUNT )", "pageIndex doesn't index PAGE_COUNT\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    v6 = &this->m_pages[nextPageIndex];
    while ( 1 )
    {
      lock = v6->lock;
      if ( (v6->lock & 0xFF000000) == 0 )
      {
        if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
          __debugbreak();
        if ( lock == _InterlockedCompareExchange((volatile signed __int32 *)v6, lock | 0xFF000000, lock) )
          break;
      }
      Sys_Sleep(0);
    }
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 308, ASSERT_TYPE_ASSERT, "(mutablePage->lock & PAGE_LOCK_MASK)", (const char *)&queryFormat, "mutablePage->lock & PAGE_LOCK_MASK") )
      __debugbreak();
    keyCount = this->m_pages[nextPageIndex].meta.keyCount;
    if ( keyCount )
      break;
LABEL_27:
    v14 = v6->lock;
    nextPageIndex = v6->meta.nextPageIndex;
    if ( (v6->lock & 0xFF000000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 322, ASSERT_TYPE_ASSERT, "(value & PAGE_LOCK_MASK)", (const char *)&queryFormat, "value & PAGE_LOCK_MASK") )
      __debugbreak();
    if ( ((unsigned __int8)v6 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", v6) )
      __debugbreak();
    v15 = _InterlockedCompareExchange((volatile signed __int32 *)v6, v14 & 0xFFFFFF, v14);
    if ( v14 != v15 )
    {
      LODWORD(v21) = v14;
      LODWORD(v20) = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_one_level_skip_list.h", 329, ASSERT_TYPE_ASSERT, "( returnedValue ) == ( value )", "%s == %s\n\t%i, %i", "returnedValue", (const char *)&stru_143CE7590, v20, v21) )
        __debugbreak();
    }
    v5 = nextPageIndex < 0x21u;
    if ( nextPageIndex == 33 )
      goto LABEL_37;
  }
  v9 = 0;
  distanceSq = this->m_linkKeys[v3].distanceSq;
  while ( 1 )
  {
    v11 = &v6->keys[v9];
    v12 = v6->keys[v9].distanceSq;
    if ( v12 >= distanceSq && (v12 != distanceSq || v11->index >= this->m_linkKeys[v3].index) )
    {
      Com_PrintError(1, "key at 0x%p >= link key [%d] (0x%p)\n", &v6->keys[v9], v3, &this->m_linkKeys[v3]);
      OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
      return 0;
    }
    if ( v1 )
    {
      v13 = v1[1];
      if ( v13 >= v12 && (v13 != v12 || *(_DWORD *)v1 >= v11->index) )
        break;
    }
    ++v9;
    v1 = (float *)v11;
    if ( v9 >= keyCount )
      goto LABEL_27;
  }
  LODWORD(v18) = v9;
  LODWORD(fmt) = nextPageIndex;
  Com_PrintError(1, "key at 0x%p >= link[%d], page [%d], key [%d] (0x%p)\n", v1, v3, fmt, v18, &v6->keys[v9]);
  OneLevelSkipList<CgDistanceCacheMpKey,5,200,CgDistanceCacheMpCompareKey>::UnlockPage(this, v6);
  return 0;
}

