/*
==============
AIActorInterface::ScrShouldTeleport_Strict
==============
*/

bool __fastcall AIActorInterface::ScrShouldTeleport_Strict(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, float distFromPosSq, float checkDistSq)
{
  return ?ScrShouldTeleport_Strict@AIActorInterface@@UEBA_NAEAUscrContext_t@@AEBTvec3_t@@MM@Z(this, scrContext, teleportPos, distFromPosSq, checkDistSq);
}

/*
==============
AIActorInterface::OnScrCmd_StartScriptedAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_StartScriptedAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartScriptedAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleNotSolid
==============
*/

void __fastcall AIActorInterface::OnScrCmd_VisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_VisibleNotSolid@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetPupilDiameter
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetPupilDiameter(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetPupilDiameter@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_Teleport
==============
*/

void __fastcall AIActorInterface::OnScrCmd_Teleport(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_Teleport@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AnimCustom
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AnimCustom(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AnimCustom@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetTalkToSpecies
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetTalkToSpecies(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetTalkToSpecies@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_CodeMoveAnimRate
==============
*/

void __fastcall AIActorInterface::OnScrCmd_CodeMoveAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CodeMoveAnimRate@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AIClearAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AIClearAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIClearAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetTurretAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetTurretAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetTurretAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimTime
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimTime(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimTime@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::ScrTeleport
==============
*/

void __fastcall AIScriptedInterface::ScrTeleport(AIScriptedInterface *this, scrContext_t *scrContext, TeleportCheckMode checkMode)
{
  ?ScrTeleport@AIScriptedInterface@@IEBAXAEAUscrContext_t@@W4TeleportCheckMode@@@Z(this, scrContext, checkMode);
}

/*
==============
AIActorInterface::ScrShouldTeleport_Reset
==============
*/

bool __fastcall AIActorInterface::ScrShouldTeleport_Reset(AIActorInterface *this, const vec3_t *teleportPos, float distFromPosSq)
{
  return ?ScrShouldTeleport_Reset@AIActorInterface@@UEBA_NAEBTvec3_t@@M@Z(this, teleportPos, distFromPosSq);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimBlendCurve
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimBlendCurve(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimBlendCurve@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_InitRiotshieldHealth
==============
*/

void __fastcall AIActorInterface::OnScrCmd_InitRiotshieldHealth(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_InitRiotshieldHealth@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnob
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimKnob@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_CheckProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_CheckProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CheckProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_GetTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_GetTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetLaserFlag
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetLaserFlag(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetLaserFlag@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_StopUseTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_StopUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StopUseTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOn
==============
*/

void __fastcall AIActorInterface::OnScrCmd_LaserAltOn(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_LaserAltOn@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_EnterProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_EnterProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_EnterProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOff
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AimAssistOff(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AimAssistOff@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobLimited
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimKnobLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimKnobLimited@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_UpdateProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_UpdateProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_UseTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_UseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UseTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::SetAnimKnobInternal
==============
*/

void __fastcall AIActorInterface::SetAnimKnobInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  ?SetAnimKnobInternal@AIActorInterface@@CAXAEAUscrContext_t@@PEAUgentity_s@@I@Z(scrContext, ent, flags);
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOn
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AimAssistOn(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AimAssistOn@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::SetAnimInternal
==============
*/

void __fastcall AIActorInterface::SetAnimInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  ?SetAnimInternal@AIActorInterface@@CAXAEAUscrContext_t@@PEAUgentity_s@@I@Z(scrContext, ent, flags);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimRate
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimRate@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceTeleport
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ForceTeleport@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetProneAnimNodes
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetProneAnimNodes(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetProneAnimNodes@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ShouldPlayMeleeDeathAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SafeTeleport
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SafeTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SafeTeleport@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleSolid
==============
*/

void __fastcall AIActorInterface::OnScrCmd_VisibleSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_VisibleSolid@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_InvisibleNotSolid
==============
*/

void __fastcall AIActorInterface::OnScrCmd_InvisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_InvisibleNotSolid@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_ExitProne
==============
*/

void __fastcall AIActorInterface::OnScrCmd_ExitProne(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ExitProne@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::ScrShouldTeleport_Safe
==============
*/

bool __fastcall AIActorInterface::ScrShouldTeleport_Safe(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, float distFromPosSq)
{
  return ?ScrShouldTeleport_Safe@AIActorInterface@@UEBA_NAEAUscrContext_t@@AEBTvec3_t@@M@Z(this, scrContext, teleportPos, distFromPosSq);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnim
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnim@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOff
==============
*/

void __fastcall AIActorInterface::OnScrCmd_LaserAltOff(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_LaserAltOff@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_CanUseTurret
==============
*/

void __fastcall AIActorInterface::OnScrCmd_CanUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanUseTurret@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimLimited
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimLimited@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_SetMoveAnimKnob
==============
*/

void __fastcall AIActorInterface::OnScrCmd_SetMoveAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetMoveAnimKnob@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobRestart
==============
*/

void __fastcall AIActorInterface::OnScrCmd_AISetAnimKnobRestart(AIActorInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISetAnimKnobRestart@AIActorInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_AIClearAnim
==============
*/
void AIActorInterface::OnScrCmd_AIClearAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  XAnimTree *EntAnimTree; 
  scr_string_t AnimsetName; 
  scr_string_t ConstString; 
  int Int; 
  double Float; 
  const char *v10; 
  const char *String; 
  const char *v12; 
  unsigned int v13; 
  const XAnim_s *SubTreeAnims; 
  XAnimCurveID curveID; 
  DObj *ServerDObjForEnt; 
  unsigned int pOutAnimIndex; 
  int pOutStateIndex; 
  float weight; 
  AnimsetState *outState; 
  XAnimCurveID pOutAnimCurveID; 
  XAnimSubTreeID pOutAnimSubtreeID; 

  pOutAnimCurveID = LINEAR;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1568, scrContext, "AnimScripted entities are not supported in this game mode");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    v4 = this->GetEntity(this);
    EntAnimTree = GScr_GetEntAnimTree(v4);
    AnimsetName = BG_AnimationState_GetAnimsetName(&v4->s);
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    Float = Scr_GetFloat(scrContext, 2u);
    outState = NULL;
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    if ( !outState )
    {
      v10 = SL_ConvertToString(AnimsetName);
      String = Scr_GetString(scrContext, 0);
      v12 = j_va("Unable to find state %s in animset %s", String, v10);
      Scr_Error(COM_ERR_1569, scrContext, v12);
    }
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, Int, &pOutAnimIndex, (unsigned int *)&weight, &pOutAnimSubtreeID, &pOutAnimCurveID);
    if ( ShouldDumpAnimCommand(scrContext, v4->s.number, 3u) )
    {
      v13 = pOutAnimIndex;
      SubTreeAnims = XAnimGetSubTreeAnims(EntAnimTree, pOutAnimSubtreeID);
      DumpAnimCommandInternal("ClearAnim", SubTreeAnims, v13, -1, 0.0, *(float *)&Float, 1.0);
    }
    curveID = pOutAnimCurveID;
    ServerDObjForEnt = Com_GetServerDObjForEnt(v4);
    XAnimClearTreeGoalWeights(EntAnimTree, LODWORD(weight), pOutAnimSubtreeID, pOutAnimIndex, *(float *)&Float, 1, ServerDObjForEnt, curveID);
  }
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnim
==============
*/
void AIActorInterface::OnScrCmd_AISetAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  const gentity_s *v4; 
  float v5; 
  unsigned int v6; 
  double Float; 
  int Int; 
  scr_string_t ConstString; 
  actor_s *m_pAI; 
  scr_string_t AnimsetName; 
  const Animset *v12; 
  const char *name; 
  const char *String; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  int pOutStateIndex; 
  AnimsetState *outState; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1561, scrContext, "AnimScripted entities are not supported int this game mode");
  v4 = this->GetEntity(this);
  if ( !Com_GetServerDObjForEnt(v4) )
    Scr_ObjectError(COM_ERR_1562, scrContext, "No model exists.");
  v5 = FLOAT_1_0;
  v6 = Scr_GetNumParam(scrContext) - 2;
  if ( v6 )
  {
    if ( v6 != 1 )
      Scr_Error(COM_ERR_1563, scrContext, "incorrect number of parameters");
    Float = Scr_GetFloat(scrContext, 2u);
    v5 = *(float *)&Float;
    if ( *(float *)&Float < 0.0 )
      Scr_ParamError(COM_ERR_1564, scrContext, 4u, "must set nonnegative rate for flagged anims");
  }
  Int = Scr_GetInt(scrContext, 1u);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Scr_GetType(scrContext, 1u) != VAR_INTEGER )
    Scr_ParamError(COM_ERR_1565, scrContext, 1u, "Expecting int");
  m_pAI = this->m_pAI;
  outState = NULL;
  AnimsetName = BG_AnimationState_GetAnimsetName(&m_pAI->ent->s);
  v12 = Animset_Find(AnimsetName);
  BG_Animset_GetStateInfoByName(v12, ConstString, &outState, &pOutStateIndex);
  if ( !outState )
  {
    name = v12->name;
    String = Scr_GetString(scrContext, 0);
    v15 = j_va("Unable to find state %s in animset %s", String, name);
    Scr_ParamError(COM_ERR_1566, scrContext, 0, v15);
  }
  if ( Int < 0 )
  {
    v16 = Scr_GetString(scrContext, 0);
    v17 = j_va("invalid entry index %d for animset %s state %s", (unsigned int)Int, v12->name, v16);
    Scr_ParamError(COM_ERR_1567, scrContext, 1u, v17);
  }
  ((void (__fastcall *)(AIActorInterface *, const Animset *, _QWORD, _QWORD, _DWORD))this->SetAnim)(this, v12, (unsigned int)pOutStateIndex, (unsigned int)Int, LODWORD(v5));
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimBlendCurve
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimBlendCurve(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  XAnimTree *v5; 
  unsigned int v6; 
  scr_string_t ConstString; 
  XAnimCurveID ID; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  unsigned int v12; 
  const char *v13; 
  const XAnim_s *SubTreeAnims; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int animIndex; 
  unsigned int outGraftAnimIndex; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1572, scrContext, "AnimScripted entities are not supported in this game mode");
  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetNumParam(scrContext) > 4 )
    Scr_Error(COM_ERR_1573, scrContext, "incorrect number of parameters");
  v4 = this->GetEntity(this);
  v5 = this->GetAnimTree(this);
  animIndex = Scr_GetAnim(scrContext, 0, v5).index;
  v6 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 2u, &outGraftAnimIndex, &outSubTreeID, &animIndex, NULL);
  ConstString = Scr_GetConstString(scrContext, 1u);
  ID = XAnimCurve_GetID(ConstString);
  if ( ID == CURVE_ASSET_END )
  {
    v9 = SL_ConvertToString(ConstString);
    v10 = j_va("AISetAnimBlendCurve: could not find curve '%s'\n", v9);
    Scr_Error(COM_ERR_1574, scrContext, v10);
  }
  XAnimSetAnimCurve(v5, outGraftAnimIndex, outSubTreeID, animIndex, ID);
  if ( ShouldDumpAnimCommand(scrContext, v4->s.number, v6 + 2) )
  {
    v11 = SL_ConvertToString(ConstString);
    v12 = animIndex;
    v13 = v11;
    SubTreeAnims = XAnimGetSubTreeAnims(v5, outSubTreeID);
    DumpAnimSetCurveCommand("SetAnimCurve", SubTreeAnims, v12, -1, v13);
  }
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnob
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimKnobInternal(scrContext, v3, 1u);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobLimited
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimKnobLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimKnobInternal(scrContext, v3, 0);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimKnobRestart
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimKnobRestart(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimKnobInternal(scrContext, v3, 3u);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimLimited
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimLimited(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v3; 

  v3 = this->GetEntity(this);
  AIActorInterface::SetAnimInternal(scrContext, v3, 0);
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimRate
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  XAnimTree *v5; 
  scr_string_t AnimsetName; 
  unsigned int v7; 
  scr_string_t ConstString; 
  int Int; 
  double Float; 
  float v11; 
  const char *v12; 
  const char *String; 
  const char *v14; 
  double v15; 
  unsigned int v16; 
  const XAnim_s *SubTreeAnims; 
  int pOutStateIndex; 
  AnimsetState *outState; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int pOutAnimIndex; 
  unsigned int outGraftAnimIndex; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1570, scrContext, "AnimScripted entities are not supported in this game mode");
  v4 = this->GetEntity(this);
  v5 = this->GetAnimTree(this);
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    AnimsetName = BG_AnimationState_GetAnimsetName(&v4->s);
    v7 = 1;
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    Float = Scr_GetFloat(scrContext, 2u);
    outState = NULL;
    v11 = *(float *)&Float;
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    if ( !outState )
    {
      v12 = SL_ConvertToString(AnimsetName);
      String = Scr_GetString(scrContext, 0);
      v14 = j_va("Unable to find state %s in animset %s", String, v12);
      Scr_Error(COM_ERR_1571, scrContext, v14);
    }
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, Int, &pOutAnimIndex, &outGraftAnimIndex, &outSubTreeID, NULL);
  }
  else
  {
    v15 = Scr_GetFloat(scrContext, 1u);
    v11 = *(float *)&v15;
    pOutAnimIndex = Scr_GetAnim(scrContext, 0, v5).index;
    v7 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 2u, &outGraftAnimIndex, &outSubTreeID, &pOutAnimIndex, NULL);
  }
  XAnimSetAnimRate(v5, outGraftAnimIndex, outSubTreeID, pOutAnimIndex, v11);
  if ( ShouldDumpAnimCommand(scrContext, v4->s.number, v7 + 2) )
  {
    v16 = pOutAnimIndex;
    SubTreeAnims = XAnimGetSubTreeAnims(v5, outSubTreeID);
    DumpAnimSetRateCommand("SetAnimRate", SubTreeAnims, v16, -1, v11);
  }
}

/*
==============
AIActorInterface::OnScrCmd_AISetAnimTime
==============
*/
void AIActorInterface::OnScrCmd_AISetAnimTime(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  float v5; 
  XAnimTree *v6; 
  unsigned int NumParam; 
  double Float; 
  const char *v9; 
  ComErrorCode v10; 
  unsigned int v11; 
  const XAnim_s *SubTreeAnims; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int animIndex; 
  unsigned int outGraftAnimIndex; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1575, scrContext, "AnimScripted entities are not supported in this game mode");
  v4 = this->GetEntity(this);
  v5 = 0.0;
  v6 = this->GetAnimTree(this);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam - 2 > 2 )
      Scr_Error(COM_ERR_1576, scrContext, "too many parameters");
    Float = Scr_GetFloat(scrContext, 1u);
    v5 = *(float *)&Float;
    if ( *(float *)&Float >= 0.0 )
    {
      if ( *(float *)&Float <= 1.0 )
        goto LABEL_11;
      v5 = FLOAT_1_0;
      v9 = "must be < 1";
      v10 = COM_ERR_1578;
    }
    else
    {
      v5 = 0.0;
      v9 = "must be > 0";
      v10 = COM_ERR_1577;
    }
    Scr_ParamError(v10, scrContext, 1u, v9);
  }
LABEL_11:
  animIndex = Scr_GetAnim(scrContext, 0, v6).index;
  v11 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 2u, &outGraftAnimIndex, &outSubTreeID, &animIndex, NULL);
  SubTreeAnims = XAnimGetSubTreeAnims(v6, outSubTreeID);
  if ( !XAnimIsLeafNode(SubTreeAnims, animIndex) )
    Scr_ParamError(COM_ERR_1579, scrContext, 0, "not a leaf animation");
  if ( v5 == 1.0 && XAnimIsLooped(SubTreeAnims, animIndex) )
    Scr_ParamError(COM_ERR_1580, scrContext, 1u, "cannot set time 1 on looping animation");
  XAnimSetTime(v6, outGraftAnimIndex, outSubTreeID, animIndex, v5);
  G_FlagAnimForUpdate(v4);
  if ( ShouldDumpAnimCommand(scrContext, v4->s.number, v11 + 2) )
    DumpAnimSetTimeCommand("SetAnimTime", SubTreeAnims, animIndex, -1, v5);
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOff
==============
*/
void AIActorInterface::OnScrCmd_AimAssistOff(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel |= 4u;
}

/*
==============
AIActorInterface::OnScrCmd_AimAssistOn
==============
*/
void AIActorInterface::OnScrCmd_AimAssistOn(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel &= ~4u;
}

/*
==============
AIActorInterface::OnScrCmd_AnimCustom
==============
*/
void AIActorInterface::OnScrCmd_AnimCustom(AIActorInterface *this, scrContext_t *scrContext)
{
  actor_s *m_pAI; 
  int Func; 
  int v6; 

  m_pAI = this->m_pAI;
  if ( m_pAI->isTransitioningStates )
  {
    Com_PrintWarning(18, "WARNING: AnimCustom() called while transitioning states for AI #%i. The call will be ignored! Please report to code.\n", (unsigned int)m_pAI->ent->s.number);
  }
  else if ( AIScriptedInterface::PushState(this, AIS_CUSTOMANIM) )
  {
    Func = Scr_GetFunc(scrContext, 0);
    if ( Scr_GetNumParam(scrContext) <= 1 )
      v6 = 0;
    else
      v6 = Scr_GetFunc(scrContext, 1u);
    AIScriptedInterface::KillAnimScript(this);
    this->m_pAI->AnimScriptSpecific.func = Func;
    this->m_pAI->AnimScriptSpecific.endFunc = v6;
    Scr_SetString(&this->m_pAI->AnimScriptSpecific.name, scr_const._custom);
  }
}

/*
==============
AIActorInterface::OnScrCmd_CanUseTurret
==============
*/
void AIActorInterface::OnScrCmd_CanUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  bool CanUse; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_ParamError(COM_ERR_1557, scrContext, 0, "can only use a turret");
  CanUse = G_TurretSP_ActorCanUse(this->m_pAI, Entity);
  Scr_AddBool(scrContext, CanUse);
}

/*
==============
AIActorInterface::OnScrCmd_CheckProne
==============
*/
void AIActorInterface::OnScrCmd_CheckProne(AIActorInterface *this, scrContext_t *scrContext)
{
  double Float; 
  float v5; 
  unsigned int Int; 
  GHandler *handler; 
  gentity_s *v8; 
  bool v13; 
  vec3_t vPos; 

  Scr_GetVector(scrContext, 0, &vPos);
  Float = Scr_GetFloat(scrContext, 1u);
  v5 = *(float *)&Float;
  Int = Scr_GetInt(scrContext, 2u);
  handler = GHandler::getHandler();
  v8 = this->GetEntity(this);
  _XMM0 = Int;
  __asm { vpcmpeqd xmm3, xmm0, xmm1 }
  _XMM1 = LODWORD(FLOAT_50_0);
  __asm { vblendvps xmm0, xmm1, xmm2, xmm3 }
  v13 = BG_CheckProneValid(v8->s.number, &vPos, 15.0, 48.0, v5, NULL, NULL, Int != 0, 1, 1, handler, PHYSICS_WORLD_ID_FIRST, PCT_ACTOR, *(float *)&_XMM0, FEETDIR_BACK, NULL, NULL);
  Scr_AddBool(scrContext, v13);
}

/*
==============
AIActorInterface::OnScrCmd_CodeMoveAnimRate
==============
*/
void AIActorInterface::OnScrCmd_CodeMoveAnimRate(AIActorInterface *this, scrContext_t *scrContext)
{
  double Float; 

  Float = Scr_GetFloat(scrContext, 0);
  this->m_pAI->movePlaybackRate = *(float *)&Float;
}

/*
==============
AIActorInterface::OnScrCmd_EnterProne
==============
*/
void AIActorInterface::OnScrCmd_EnterProne(AIActorInterface *this, scrContext_t *scrContext)
{
  actor_s *m_pAI; 
  double Float; 
  BOOL v6; 
  int v7; 
  const dvar_t *v8; 
  actor_s *v9; 
  unsigned int animProneLow; 
  float time; 
  XAnimTree *v12; 
  unsigned int animProneLevel; 
  XAnimTree *v14; 
  unsigned int animProneHigh; 
  XAnimTree *v16; 

  m_pAI = this->m_pAI;
  if ( m_pAI->prone.fInvProneAnimLowPitch == 0.0 && m_pAI->prone.fInvProneAnimHighPitch == 0.0 || !m_pAI->prone.animProneLow || !m_pAI->prone.animProneLevel || !m_pAI->prone.animProneHigh )
    Scr_Error(COM_ERR_1553, scrContext, "Must call SetProneAnimNodes before calling EnterProne");
  Float = Scr_GetFloat(scrContext, 0);
  v6 = 1;
  v7 = (int)(float)(*(float *)&Float * 1000.0);
  if ( Scr_GetNumParam(scrContext) > 1 )
    v6 = Scr_GetInt(scrContext, 1u) == 0;
  AIScriptedInterface::EnterProne(this, v7, (FeetDirection)v6);
  v8 = DVARINT_g_dumpAnimsCommands;
  if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  v9 = this->m_pAI;
  if ( v8->current.integer == v9->ent->s.number )
  {
    if ( v9->prone.animProneLevel )
    {
      animProneLow = v9->prone.animProneLow;
      time = (float)v7 * 0.001;
      v12 = this->GetAnimTree(this);
      DumpAnimCommand("EnterProne", v12, animProneLow, -1, 1.0, time, 1.0);
      animProneLevel = this->m_pAI->prone.animProneLevel;
      v14 = this->GetAnimTree(this);
      DumpAnimCommand("EnterProne", v14, animProneLevel, -1, 1.0, time, 1.0);
      animProneHigh = this->m_pAI->prone.animProneHigh;
      v16 = this->GetAnimTree(this);
      DumpAnimCommand("EnterProne", v16, animProneHigh, -1, 1.0, time, 1.0);
    }
  }
}

/*
==============
AIActorInterface::OnScrCmd_ExitProne
==============
*/
void AIActorInterface::OnScrCmd_ExitProne(AIActorInterface *this, scrContext_t *scrContext)
{
  double Float; 
  const dvar_t *v4; 
  actor_s *m_pAI; 
  unsigned int animProneLow; 
  float time; 
  XAnimTree *v8; 
  unsigned int animProneLevel; 
  XAnimTree *v10; 
  unsigned int animProneHigh; 
  XAnimTree *v12; 

  Float = Scr_GetFloat(scrContext, 0);
  AIScriptedInterface::ExitProne(this, (int)(float)(*(float *)&Float * 1000.0));
  v4 = DVARINT_g_dumpAnimsCommands;
  if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  m_pAI = this->m_pAI;
  if ( v4->current.integer == m_pAI->ent->s.number )
  {
    if ( m_pAI->prone.animProneLevel )
    {
      animProneLow = m_pAI->prone.animProneLow;
      time = (float)(int)(float)(*(float *)&Float * 1000.0) * 0.001;
      v8 = this->GetAnimTree(this);
      DumpAnimCommand("ExitProne", v8, animProneLow, -1, 0.0, time, 1.0);
      animProneLevel = this->m_pAI->prone.animProneLevel;
      v10 = this->GetAnimTree(this);
      DumpAnimCommand("ExitProne", v10, animProneLevel, -1, 0.0, time, 1.0);
      animProneHigh = this->m_pAI->prone.animProneHigh;
      v12 = this->GetAnimTree(this);
      DumpAnimCommand("ExitProne", v12, animProneHigh, -1, 0.0, time, 1.0);
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceTeleport
==============
*/
void AIScriptedInterface::OnScrCmd_ForceTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ScrTeleport(this, scrContext, TELEPORT_CHECK_NONE);
}

/*
==============
AIActorInterface::OnScrCmd_GetTurret
==============
*/
void AIActorInterface::OnScrCmd_GetTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  if ( AICommonInterface::IsUsingTurret(this) )
  {
    if ( !this->m_pAI->turret.pTurret && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 890, ASSERT_TYPE_ASSERT, "(m_pAI->turret.pTurret)", (const char *)&queryFormat, "m_pAI->turret.pTurret") )
      __debugbreak();
    GScr_AddEntity(this->m_pAI->turret.pTurret);
  }
}

/*
==============
AIActorInterface::OnScrCmd_InitRiotshieldHealth
==============
*/
void AIActorInterface::OnScrCmd_InitRiotshieldHealth(AIActorInterface *this, scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  bool v5; 
  WeaponDef **v6; 
  int riotShieldHealth; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    if ( BG_IsRiotShield(&outWeapon, 0) )
    {
      weaponIdx = outWeapon.weaponIdx;
      if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
        __debugbreak();
      v5 = bg_weaponDefs[weaponIdx] == NULL;
      v6 = &bg_weaponDefs[weaponIdx];
      if ( v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      if ( (*v6)->riotShieldEnableDamage )
        riotShieldHealth = (*v6)->riotShieldHealth;
      else
        riotShieldHealth = 1;
      this->m_pAI->shieldHealth = riotShieldHealth;
      this->m_pAI->shieldWeapon = outWeapon;
    }
  }
  else
  {
    Scr_Error(COM_ERR_1558, scrContext, "Can't find specified weapon");
  }
}

/*
==============
AIActorInterface::OnScrCmd_InvisibleNotSolid
==============
*/
void AIActorInterface::OnScrCmd_InvisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->clipmask = 0;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0xCu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0);
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOff
==============
*/
void AIActorInterface::OnScrCmd_LaserAltOff(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel &= ~2u;
}

/*
==============
AIActorInterface::OnScrCmd_LaserAltOn
==============
*/
void AIActorInterface::OnScrCmd_LaserAltOn(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->s.un.vehicleXModel |= 2u;
}

/*
==============
AIScriptedInterface::OnScrCmd_SafeTeleport
==============
*/
void AIScriptedInterface::OnScrCmd_SafeTeleport(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ScrTeleport(this, scrContext, TELEPORT_CHECK_STRICT);
}

/*
==============
AIActorInterface::OnScrCmd_SetLaserFlag
==============
*/
void AIActorInterface::OnScrCmd_SetLaserFlag(AIActorInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  gentity_s *ent; 
  unsigned __int8 flags; 

  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( ConstLowercaseString == scr_const.none )
  {
    ent = this->m_pAI->ent;
    flags = ent->s.lerp.u.actor.flags;
    if ( (flags & 0x10) != 0 )
    {
      *(_QWORD *)&ent->s.lerp.u.scriptMover.animIndex = 0i64;
      ent->s.lerp.u.anonymous.data[5] = 0;
      flags = ent->s.lerp.u.actor.flags;
    }
    ent->s.lerp.u.actor.flags = flags & 0xE3;
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xAFu;
  }
  else if ( ConstLowercaseString == scr_const.interpolate )
  {
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xE3u;
    this->m_pAI->ent->s.lerp.u.actor.flags |= 8u;
  }
  else if ( ConstLowercaseString == scr_const.lock )
  {
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xE3u;
    this->m_pAI->ent->s.lerp.u.actor.flags |= 4u;
  }
  else if ( ConstLowercaseString == scr_const.target )
  {
    if ( Scr_GetNumParam(scrContext) < 2 )
      Scr_Error(COM_ERR_1559, scrContext, "Laser flag 'target' requires a target pos.");
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xE3u;
    this->m_pAI->ent->s.lerp.u.actor.flags &= 0xAFu;
    this->m_pAI->ent->s.lerp.u.actor.flags |= 0x10u;
    Scr_GetVector(scrContext, 1u, &this->m_pAI->ent->s.lerp.u.actor.impactVector);
  }
  else
  {
    Scr_Error(COM_ERR_1560, scrContext, "SetLaserFlag: Invalid parameter. Must be one of: (none,interpolate,lock,target)");
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetMoveAnimKnob
==============
*/
void AIActorInterface::OnScrCmd_SetMoveAnimKnob(AIActorInterface *this, scrContext_t *scrContext)
{
  XAnimTree *v4; 

  v4 = this->GetAnimTree(this);
  this->m_pAI->moveAnimKnob = Scr_GetAnim(scrContext, 0, v4).index;
}

/*
==============
AIActorInterface::OnScrCmd_SetProneAnimNodes
==============
*/
void AIActorInterface::OnScrCmd_SetProneAnimNodes(AIActorInterface *this, scrContext_t *scrContext)
{
  double Float; 
  float v5; 
  double v6; 
  XAnimTree *v7; 
  const dvar_t *v8; 
  actor_s *m_pAI; 

  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  v6 = Scr_GetFloat(scrContext, 1u);
  v7 = this->GetAnimTree(this);
  if ( v5 >= 0.0 )
    Scr_Error(COM_ERR_1554, scrContext, "Down angle (parameter 1) must be set to be less than 0.");
  if ( *(float *)&v6 <= 0.0 )
    Scr_Error(COM_ERR_1555, scrContext, "Up angle (parameter 2) must be set to be greater than 0.");
  this->m_pAI->prone.fInvProneAnimLowPitch = 1.0 / v5;
  this->m_pAI->prone.fInvProneAnimHighPitch = 1.0 / *(float *)&v6;
  this->m_pAI->prone.animProneLow = Scr_GetAnim(scrContext, 2u, v7).index;
  this->m_pAI->prone.animProneLevel = Scr_GetAnim(scrContext, 3u, v7).index;
  this->m_pAI->prone.animProneHigh = Scr_GetAnim(scrContext, 4u, v7).index;
  v8 = DVARINT_g_dumpAnimsCommands;
  if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  m_pAI = this->m_pAI;
  if ( v8->current.integer == m_pAI->ent->s.number )
  {
    DumpAnimCommand("SetProneAnimNodes", v7, m_pAI->prone.animProneLow, -1, 1.0, 0.0, 1.0);
    DumpAnimCommand("SetProneAnimNodes", v7, this->m_pAI->prone.animProneLevel, -1, 1.0, 0.0, 1.0);
    DumpAnimCommand("SetProneAnimNodes", v7, this->m_pAI->prone.animProneHigh, -1, 1.0, 0.0, 1.0);
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetPupilDiameter
==============
*/
void AIActorInterface::OnScrCmd_SetPupilDiameter(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 
  double Float; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_5796, scrContext, "incorrect number of parameters");
  v4 = this->GetEntity(this);
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float >= 2.0 || *(float *)&Float == 0.0 )
  {
    if ( *(float *)&Float <= 8.0 )
    {
      v4->s.lerp.u.actor.pupilDiameter = *(float *)&Float;
    }
    else
    {
      Scr_ParamError(COM_ERR_5798, scrContext, 0, "must be <= 8");
      v4->s.lerp.u.actor.pupilDiameter = FLOAT_8_0;
    }
  }
  else
  {
    Scr_ParamError(COM_ERR_5797, scrContext, 0, "must be >= 2 or equal to 0");
    v4->s.lerp.u.actor.pupilDiameter = FLOAT_2_0;
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetTalkToSpecies
==============
*/
void AIActorInterface::OnScrCmd_SetTalkToSpecies(AIActorInterface *this, scrContext_t *scrContext)
{
  int v4; 
  int v5; 
  scr_string_t ConstString; 
  char v7; 
  const scr_string_t **v8; 

  v4 = 0;
  v5 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    while ( 1 )
    {
      ConstString = Scr_GetConstString(scrContext, 0);
      if ( ConstString == scr_const.all )
        break;
      v7 = 0;
      v8 = g_AISpeciesNames;
      while ( ConstString != **v8 )
      {
        ++v7;
        if ( (__int64)++v8 >= (__int64)&RDBG_WELCOME_RAW_502 )
          goto LABEL_8;
      }
      v4 |= 1 << v7;
LABEL_8:
      if ( ++v5 >= Scr_GetNumParam(scrContext) )
        goto LABEL_9;
    }
    this->m_pAI->talkToSpecies = -1;
  }
  else
  {
LABEL_9:
    this->m_pAI->talkToSpecies = v4;
  }
}

/*
==============
AIActorInterface::OnScrCmd_SetTurretAnim
==============
*/
void AIActorInterface::OnScrCmd_SetTurretAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  XAnimTree *v4; 

  v4 = this->GetAnimTree(this);
  this->m_pAI->turret.turretAnim = Scr_GetAnim(scrContext, 0, v4).index;
  this->m_pAI->turret.turretAnimSet = 1;
}

/*
==============
AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim
==============
*/
void AIActorInterface::OnScrCmd_ShouldPlayMeleeDeathAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  int number; 
  const gentity_s *Entity; 
  int ShouldPlayMeleeChargeDeathAnim; 

  number = this->GetEntity(this)->s.number;
  Entity = GScr_GetEntity(0);
  ShouldPlayMeleeChargeDeathAnim = G_Weapon_ShouldPlayMeleeChargeDeathAnim(this->m_pAI->painDeath.damageMOD, Entity, number);
  Scr_AddBool(scrContext, ShouldPlayMeleeChargeDeathAnim);
}

/*
==============
AIActorInterface::OnScrCmd_StartScriptedAnim
==============
*/
void AIActorInterface::OnScrCmd_StartScriptedAnim(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *v4; 

  if ( Scr_GetNumParam(scrContext) > 8 )
    Scr_Error(COM_ERR_1551, scrContext, "too many parameters");
  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_1552, scrContext, "too few parameters");
  v4 = this->GetEntity(this);
  ScrCmd_animscriptedInternal(scrContext, v4, 0);
}

/*
==============
AIActorInterface::OnScrCmd_StopUseTurret
==============
*/
void AIActorInterface::OnScrCmd_StopUseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  ((void (__fastcall *)(AIActorInterface *, scrContext_t *))this->StopUseTurret)(this, scrContext);
}

/*
==============
AIActorInterface::OnScrCmd_Teleport
==============
*/
void AIActorInterface::OnScrCmd_Teleport(AIActorInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ScrTeleport(this, scrContext, TELEPORT_CHECK_NORMAL);
}

/*
==============
AIActorInterface::OnScrCmd_UpdateProne
==============
*/
void AIActorInterface::OnScrCmd_UpdateProne(AIActorInterface *this, scrContext_t *scrContext)
{
  actor_s *m_pAI; 
  trajectory_t_secure *p_pos; 
  XAnimTree *v6; 
  unsigned int index; 
  unsigned int v8; 
  double Float; 
  float v10; 
  double v11; 
  float goalTime; 
  double rate; 
  const DObj *ServerDObjForEnt; 
  const dvar_t *v15; 

  if ( BG_ActorIsProne(&this->m_pAI->ProneInfo, level.time) )
  {
    m_pAI = this->m_pAI;
    p_pos = &m_pAI->ent->s.lerp.pos;
    if ( m_pAI->ent == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 2263, ASSERT_TYPE_ASSERT, "(trajectory)", (const char *)&queryFormat, "trajectory") )
      __debugbreak();
    if ( (unsigned int)(p_pos->trType - 23) > 5 )
    {
      v6 = this->GetAnimTree(this);
      index = Scr_GetAnim(scrContext, 0, v6).index;
      v8 = Scr_GetAnim(scrContext, 1u, v6).index;
      Float = Scr_GetFloat(scrContext, 2u);
      v10 = *(float *)&Float;
      v11 = Scr_GetFloat(scrContext, 3u);
      goalTime = *(float *)&v11;
      rate = Scr_GetFloat(scrContext, 4u);
      ServerDObjForEnt = Com_GetServerDObjForEnt(this->m_pAI->ent);
      XAnimSetCompleteGoalWeight(ServerDObjForEnt, 0, XANIM_SUBTREE_DEFAULT, index, v10, goalTime, *(float *)&rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      XAnimSetCompleteGoalWeight(ServerDObjForEnt, 0, XANIM_SUBTREE_DEFAULT, v8, v10, goalTime, *(float *)&rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      this->UpdateProneInformation(this, 0);
      v15 = DVARINT_g_dumpAnimsCommands;
      if ( !DVARINT_g_dumpAnimsCommands && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_dumpAnimsCommands") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v15);
      if ( v15->current.integer == this->m_pAI->ent->s.number )
      {
        DumpAnimCommand("UpdateProne", v6, index, -1, v10, goalTime, *(float *)&rate);
        DumpAnimCommand("UpdateProne", v6, v8, -1, v10, goalTime, *(float *)&rate);
      }
    }
  }
}

/*
==============
AIActorInterface::OnScrCmd_UseTurret
==============
*/
void AIActorInterface::OnScrCmd_UseTurret(AIActorInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int v5; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_ParamError(COM_ERR_6619, scrContext, 0, "can only use a turret");
  v5 = this->UseTurret(this, Entity);
  Scr_AddBool(scrContext, v5);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleNotSolid
==============
*/
void AIActorInterface::OnScrCmd_VisibleNotSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->clipmask = 0;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0xCu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0);
}

/*
==============
AIActorInterface::OnScrCmd_VisibleSolid
==============
*/
void AIActorInterface::OnScrCmd_VisibleSolid(AIActorInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ent->clipmask = 33685521;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0xCu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&this->m_pAI->ent->s.lerp.eFlags, ACTIVE, 0);
}

/*
==============
AIActorInterface::ScrShouldTeleport_Reset
==============
*/
bool AIActorInterface::ScrShouldTeleport_Reset(AIActorInterface *this, const vec3_t *teleportPos, float distFromPosSq)
{
  return level.loading || distFromPosSq > 100.0;
}

/*
==============
AIActorInterface::ScrShouldTeleport_Safe
==============
*/
char AIActorInterface::ScrShouldTeleport_Safe(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, float distFromPosSq)
{
  actor_s *v7; 
  gentity_s *v8; 
  gentity_s *ent; 
  int v10; 
  unsigned int number; 
  scrContext_t *v12; 
  actor_s *m_pAI; 
  vec3_t vEyePosOut; 

  if ( level.loading == LOADING_DONE )
  {
    if ( distFromPosSq <= 100.0 )
    {
      if ( AICommonInterface::HasPath(this) )
      {
        m_pAI = this->m_pAI;
        if ( m_pAI->iPathEndTime )
        {
          Com_DPrintf(18, "Teleport failed because actor (%i) in mid-stopping.\n", (unsigned int)m_pAI->ent->s.number);
          Scr_AddBool(scrContext, 0);
          return 0;
        }
      }
    }
    else
    {
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities->r.isInUse != *g_entityIsInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !*g_entityIsInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 575, ASSERT_TYPE_ASSERT, "( G_IsEntityInUse( 0 ) )", (const char *)&queryFormat, "G_IsEntityInUse( 0 )") )
        __debugbreak();
      v7 = this->m_pAI;
      v8 = g_entities;
      ent = v7->ent;
      if ( g_entities->classname != scr_const.player && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 527, ASSERT_TYPE_ASSERT, "(player->classname == scr_const.player)", (const char *)&queryFormat, "player->classname == scr_const.player") )
        __debugbreak();
      if ( !v8->sentient && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 528, ASSERT_TYPE_ASSERT, "(player->sentient)", (const char *)&queryFormat, "player->sentient") )
        __debugbreak();
      Sentient_GetEyePosition(v8->sentient, &vEyePosOut);
      v10 = G_ActorSP_PointCouldSeeSpawn(&vEyePosOut, teleportPos, v8->s.number, ent->s.number);
      number = ent->s.number;
      if ( v10 )
      {
        Com_DPrintf(18, "Teleport (of actor %i) failed because player could see goal pos.\n", number);
LABEL_22:
        v12 = ScriptContext_Server();
        Scr_AddInt(v12, 0);
        return 0;
      }
      if ( G_ActorSP_PointCouldSeeSpawn(&vEyePosOut, &ent->r.currentOrigin, v8->s.number, number) )
      {
        Com_DPrintf(18, "Teleport failed because player could see actor (%i).\n", (unsigned int)ent->s.number);
        goto LABEL_22;
      }
    }
  }
  return 1;
}

/*
==============
AIActorInterface::ScrShouldTeleport_Strict
==============
*/
char AIActorInterface::ScrShouldTeleport_Strict(AIActorInterface *this, scrContext_t *scrContext, const vec3_t *teleportPos, float distFromPosSq, float checkDistSq)
{
  if ( level.loading || distFromPosSq <= checkDistSq )
    return 1;
  Com_DPrintf(18, "SafeTeleport (of actor %i) failed.\n", (unsigned int)this->m_pAI->ent->s.number);
  Scr_AddBool(scrContext, 0);
  return 0;
}

/*
==============
AIScriptedInterface::ScrTeleport
==============
*/
void AIScriptedInterface::ScrTeleport(AIScriptedInterface *this, scrContext_t *scrContext, TeleportCheckMode checkMode)
{
  vec3_t *v6; 
  gentity_s *v7; 
  bool v8; 
  float v9; 
  AIScriptedInterface_vtbl *v10; 
  bool v11; 
  AIScriptedInterface_vtbl *v12; 
  bool v13; 
  ai_scripted_t *m_pAI; 
  ai_scripted_t *v15; 
  char v16; 
  int number; 
  Ai_Asm *v18; 
  ASM_Instance *Instance; 
  scr_string_t m_Name; 
  Ai_Asm *v21; 
  vec3_t vectorValue; 
  vec3_t v23; 

  Sys_ProfBeginNamedEvent(0xFFFF0000, "AI_ScrTeleport");
  v6 = NULL;
  v7 = this->GetEntity(this);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) == VAR_VECTOR )
  {
    Scr_GetVector(scrContext, 1u, &v23);
    v6 = &v23;
  }
  if ( Scr_GetNumParam(scrContext) > 2 )
    Scr_GetFloat(scrContext, 2u);
  v8 = Scr_GetNumParam(scrContext) > 3 && Scr_GetInt(scrContext, 3u);
  v9 = (float)((float)((float)(v7->r.currentOrigin.v[1] - vectorValue.v[1]) * (float)(v7->r.currentOrigin.v[1] - vectorValue.v[1])) + (float)((float)(v7->r.currentOrigin.v[0] - vectorValue.v[0]) * (float)(v7->r.currentOrigin.v[0] - vectorValue.v[0]))) + (float)((float)(v7->r.currentOrigin.v[2] - vectorValue.v[2]) * (float)(v7->r.currentOrigin.v[2] - vectorValue.v[2]));
  if ( checkMode == TELEPORT_CHECK_STRICT )
  {
    if ( !((unsigned __int8 (__fastcall *)(AIScriptedInterface *, scrContext_t *, vec3_t *))this->ScrShouldTeleport_Strict)(this, scrContext, &vectorValue) )
      goto LABEL_42;
    goto LABEL_14;
  }
  if ( checkMode != TELEPORT_CHECK_NONE )
  {
LABEL_14:
    if ( !((unsigned __int8 (__fastcall *)(AIScriptedInterface *, scrContext_t *, vec3_t *))this->ScrShouldTeleport_Safe)(this, scrContext, &vectorValue) )
      goto LABEL_42;
  }
  G_MotionWarp_Cancel(v7->s.number);
  if ( v6 )
  {
    G_SetOriginAndAngle(v7, &vectorValue, v6, 1, 1);
    v10 = this->__vftable;
    v11 = this->Is3D(this);
    v10->SetDesiredBodyAngles(this, &this->m_pAI->CodeOrient, &v7->r.currentAngles, v11);
    if ( (unsigned int)(this->m_pAI->ScriptOrient.eMode - 1) <= 1 )
    {
      v12 = this->__vftable;
      v13 = this->Is3D(this);
      v12->SetDesiredBodyAngles(this, &this->m_pAI->ScriptOrient, &v7->r.currentAngles, v13);
    }
    AIScriptedInterface::SetLookAngles(this, v7->r.currentAngles.v[0], v7->r.currentAngles.v[1]);
  }
  else
  {
    G_SetOrigin(v7, &vectorValue, 1, 1);
  }
  m_pAI = this->m_pAI;
  *(_QWORD *)m_pAI->Physics.vVelocity.v = 0i64;
  m_pAI->Physics.vVelocity.v[2] = 0.0;
  v15 = this->m_pAI;
  *(_QWORD *)v15->Physics.vWishDelta.v = 0i64;
  v15->Physics.vWishDelta.v[2] = 0.0;
  AIScriptedInterface::Physics_HandleMovingPlatformTeleport(this);
  v16 = ((__int64 (__fastcall *)(AIScriptedInterface *, vec3_t *))this->ScrShouldTeleport_Reset)(this, &vectorValue);
  if ( this->UseEnemyGoal(this) && (v16 || !AICommonInterface::PointAtGoal(this, &vectorValue, &this->m_pAI->codeGoal)) )
    AIScriptedInterface::ClearUseEnemyGoal(this);
  if ( v7->tagInfo )
  {
    v7->s.lerp.eFlags.m_flags[0] ^= 4u;
  }
  else if ( v16 )
  {
    Sentient_InvalidateNearestNode(this->m_pAI->sentient);
    this->ClearPath(this);
    Sentient_InvalidateNearestTacPoint(this->m_pAI->sentient);
    if ( v9 > 16384.0 )
      v7->s.lerp.eFlags.m_flags[0] ^= 4u;
    if ( checkMode == TELEPORT_CHECK_NONE )
    {
      if ( !this->InScriptedState(this) )
        AIScriptedInterface::KillAnimScript(this);
      if ( v8 && this->IsAlive(this) )
      {
        number = v7->s.number;
        v18 = Ai_Asm::Singleton();
        Instance = Ai_Asm::GetInstance(v18, NULL, number);
        if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 713, ASSERT_TYPE_ASSERT, "( pInst )", (const char *)&queryFormat, "pInst") )
          __debugbreak();
        m_Name = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_pASM->m_StartState)->m_Name;
        v21 = Ai_Asm::Singleton();
        if ( Common_Asm::SetState(v21, NULL, Instance, m_Name, 0, NULL) )
          Scr_Error(COM_ERR_5754, scrContext, "Failed to reset ASM state in ForceTeleport()");
        if ( this->m_pAI->eState[this->m_pAI->stateLevel] != AIS_BEHAVE )
          AIScriptedInterface::ForceState(this, AIS_BEHAVE);
      }
    }
  }
  Nav_Teleport(this->m_pAI->pNavigator, &vectorValue);
  Scr_AddInt(scrContext, 1);
LABEL_42:
  Sys_ProfEndNamedEvent();
}

/*
==============
AIActorInterface::SetAnimInternal
==============
*/
void AIActorInterface::SetAnimInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  __int128 v3; 
  float v7; 
  float v8; 
  float v9; 
  XAnimTree *EntAnimTree; 
  unsigned int NumParam; 
  double Float; 
  double v13; 
  double v14; 
  unsigned int v15; 
  const char *v16; 
  unsigned int v17; 
  const XAnim_s *SubTreeAnims; 
  const DObj *ServerDObjForEnt; 
  int bRestart; 
  int v21; 
  unsigned int outGraftAnimIndex[4]; 
  __int128 v23; 
  XAnimSubTreeID outSubTreeID; 
  XAnimCurveID outBlendCurveID; 
  unsigned int anim; 

  outBlendCurveID = LINEAR;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1546, scrContext, "AnimScripted entities are not supported in this game mode");
  v7 = FLOAT_1_0;
  v8 = FLOAT_0_2;
  v9 = FLOAT_1_0;
  EntAnimTree = GScr_GetEntAnimTree(ent);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    v23 = v3;
    if ( NumParam != 2 )
    {
      if ( NumParam != 3 )
      {
        if ( NumParam - 4 > 3 )
          Scr_Error(COM_ERR_1547, scrContext, "too many parameters");
        Float = Scr_GetFloat(scrContext, 3u);
        v7 = *(float *)&Float;
      }
      v13 = Scr_GetFloat(scrContext, 2u);
      v8 = *(float *)&v13;
      if ( *(float *)&v13 < 0.0 )
        Scr_ParamError(COM_ERR_1548, scrContext, 2u, "must set nonnegative goal time");
    }
    v14 = Scr_GetFloat(scrContext, 1u);
    v9 = *(float *)&v14;
    if ( *(float *)&v14 < 0.0 )
      Scr_ParamError(COM_ERR_1549, scrContext, 1u, "must set nonnegative weight");
  }
  anim = Scr_GetAnim(scrContext, 0, EntAnimTree).index;
  v15 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 4u, outGraftAnimIndex, &outSubTreeID, &anim, &outBlendCurveID);
  if ( ShouldDumpAnimCommand(scrContext, ent->s.number, v15 + 4) )
  {
    switch ( flags )
    {
      case 1u:
        v16 = "SetAnim";
        break;
      case 2u:
        v16 = "SetAnimLimitedRestart";
        break;
      case 3u:
        v16 = "SetAnimRestart";
        break;
      default:
        if ( flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 255, ASSERT_TYPE_ASSERT, "(flags == 0)", (const char *)&queryFormat, "flags == 0") )
          __debugbreak();
        v16 = "SetAnimLimited";
        break;
    }
    v17 = anim;
    SubTreeAnims = XAnimGetSubTreeAnims(EntAnimTree, outSubTreeID);
    DumpAnimCommandInternal(v16, SubTreeAnims, v17, -1, v9, v8, v7);
  }
  ServerDObjForEnt = Com_GetServerDObjForEnt(ent);
  if ( !ServerDObjForEnt )
    Scr_ObjectError(COM_ERR_1550, scrContext, "No model exists.");
  bRestart = (flags >> 1) & 1;
  if ( (flags & 1) != 0 )
    v21 = XAnimSetCompleteGoalWeight(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, v9, v8, v7, (scr_string_t)0, 0, bRestart, outBlendCurveID, NULL);
  else
    v21 = XAnimSetGoalWeight(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, v9, v8, v7, (scr_string_t)0, 0, bRestart, outBlendCurveID, NULL);
  if ( v21 )
    GScr_HandleAnimError(scrContext, v21);
  else
    G_FlagAnimForUpdate(ent);
}

/*
==============
AIActorInterface::SetAnimKnobInternal
==============
*/
void AIActorInterface::SetAnimKnobInternal(scrContext_t *scrContext, gentity_s *ent, unsigned int flags)
{
  __int128 v3; 
  float v7; 
  float v8; 
  float v9; 
  XAnimTree *EntAnimTree; 
  unsigned int NumParam; 
  double Float; 
  double v13; 
  double v14; 
  unsigned int v15; 
  const char *v16; 
  unsigned int v17; 
  const XAnim_s *SubTreeAnims; 
  const DObj *ServerDObjForEnt; 
  int bRestart; 
  int v21; 
  unsigned int outGraftAnimIndex[4]; 
  __int128 v23; 
  XAnimSubTreeID outSubTreeID; 
  XAnimCurveID outBlendCurveID; 
  unsigned int anim; 

  outBlendCurveID = LINEAR;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_1541, scrContext, "AnimScripted entities are not supported in this game mode");
  v7 = FLOAT_1_0;
  v8 = FLOAT_0_2;
  v9 = FLOAT_1_0;
  EntAnimTree = GScr_GetEntAnimTree(ent);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    v23 = v3;
    if ( NumParam != 2 )
    {
      if ( NumParam != 3 )
      {
        if ( NumParam - 4 > 3 )
          Scr_Error(COM_ERR_1542, scrContext, "too many parameters");
        Float = Scr_GetFloat(scrContext, 3u);
        v7 = *(float *)&Float;
      }
      v13 = Scr_GetFloat(scrContext, 2u);
      v8 = *(float *)&v13;
      if ( *(float *)&v13 < 0.0 )
        Scr_ParamError(COM_ERR_1543, scrContext, 2u, "must set nonnegative goal time");
    }
    v14 = Scr_GetFloat(scrContext, 1u);
    v9 = *(float *)&v14;
    if ( *(float *)&v14 < 0.0 )
      Scr_ParamError(COM_ERR_1544, scrContext, 1u, "must set nonnegative weight");
  }
  anim = Scr_GetAnim(scrContext, 0, EntAnimTree).index;
  v15 = AIScriptedInterface::FixupExtraAnimParams(scrContext, 4u, outGraftAnimIndex, &outSubTreeID, &anim, &outBlendCurveID);
  if ( ShouldDumpAnimCommand(scrContext, ent->s.number, v15 + 4) )
  {
    switch ( flags )
    {
      case 1u:
        v16 = "SetAnimKnob";
        break;
      case 2u:
        v16 = "SetAnimKnobLimitedRestart";
        break;
      case 3u:
        v16 = "SetAnimKnobRestart";
        break;
      default:
        if ( flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_sp\\actor_script_cmd.cpp", 141, ASSERT_TYPE_ASSERT, "(flags == 0)", (const char *)&queryFormat, "flags == 0") )
          __debugbreak();
        v16 = "SetAnimKnobLimited";
        break;
    }
    v17 = anim;
    SubTreeAnims = XAnimGetSubTreeAnims(EntAnimTree, outSubTreeID);
    DumpAnimCommandInternal(v16, SubTreeAnims, v17, -1, v9, v8, v7);
  }
  ServerDObjForEnt = Com_GetServerDObjForEnt(ent);
  if ( !ServerDObjForEnt )
    Scr_ObjectError(COM_ERR_1545, scrContext, "No model exists.");
  bRestart = (flags >> 1) & 1;
  if ( (flags & 1) != 0 )
    v21 = XAnimSetCompleteGoalWeightKnob(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, v9, v8, v7, (scr_string_t)0, 0, bRestart, outBlendCurveID);
  else
    v21 = XAnimSetGoalWeightKnob(ServerDObjForEnt, outGraftAnimIndex[0], outSubTreeID, anim, v9, v8, v7, (scr_string_t)0, bRestart, outBlendCurveID);
  if ( v21 )
    GScr_HandleAnimError(scrContext, v21);
  else
    G_FlagAnimForUpdate(ent);
}

