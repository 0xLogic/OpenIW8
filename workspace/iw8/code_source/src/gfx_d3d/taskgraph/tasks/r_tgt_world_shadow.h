/*
==============
RBT_SunShadow_BlitCache
==============
*/

void __fastcall RBT_SunShadow_BlitCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_BlitCache@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_GenerateCompressedSunShadow_Compress@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_SunShadow_ExtractCssClippingPlanes
==============
*/

void __fastcall RBT_SunShadow_ExtractCssClippingPlanes(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_ExtractCssClippingPlanes@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_SunShadow_CreateVisibilityIndirectBuffers@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_SunShadow_ClearTranslucentAsync
==============
*/

void __fastcall RBT_SunShadow_ClearTranslucentAsync(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_ClearTranslucentAsync@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DrawCascade
==============
*/

void __fastcall RBT_SunShadow_DrawCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DrawCascade@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  return ??$cRBT_SunShadow_GenerateVisibilityPrepass@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
RBT_SunShadow_CopyDepth
==============
*/

void __fastcall RBT_SunShadow_CopyDepth(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_CopyDepth@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DrawCache
==============
*/

void __fastcall RBT_SunShadow_DrawCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DrawCache@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass_Internal
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityPrepass_Internal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool vrsWavePacking)
{
  ?RBT_SunShadow_GenerateVisibilityPrepass_Internal@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@_N@Z(computeState, taskInfo, viewInfo, data, vrsWavePacking);
}

/*
==============
cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_SunShadow_DrawCache@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_SunShadow_ClearCascade@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_SunShadow_DepthReadBarrier@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>)
{
  return ??$cRBT_SunShadow_DownsamplePass1@UR_TG_Handle@@H@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@AEBH@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_GenerateCompressedSunShadow_Compress
==============
*/

void __fastcall RBT_GenerateCompressedSunShadow_Compress(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_GenerateCompressedSunShadow_Compress@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DrawTranslucent
==============
*/

void __fastcall RBT_SunShadow_DrawTranslucent(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DrawTranslucent@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA
==============
*/

void __fastcall RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
R_TG_CompressSunShadowCascades
==============
*/

void __fastcall R_TG_CompressSunShadowCascades(R_TG_Script *pScript, R_TG_Handle *sunshadowCascades, R_TG_Handle *sunshadowCascadesBackface, R_TG_Handle *compressedCascades, unsigned int cascadesCount, R_TG_Handle nullBuffer)
{
  ?R_TG_CompressSunShadowCascades@@YAXPEAUR_TG_Script@@QEAUR_TG_Handle@@11IU2@@Z(pScript, sunshadowCascades, sunshadowCascadesBackface, compressedCascades, cascadesCount, nullBuffer);
}

/*
==============
cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>)
{
  return ??$cRBT_SunShadow_DownsamplePass0@UR_TG_Handle@@U1@HU1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1AEBH1@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
RBT_SunShadow_DepthReadBarrier
==============
*/

void __fastcall RBT_SunShadow_DepthReadBarrier(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DepthReadBarrier@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_CompressSunShadow_Main
==============
*/

void __fastcall RBT_CompressSunShadow_Main(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_CompressSunShadow_Main@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>)
{
  return ??$cRBT_SunShadow_GenerateVisibilityInlineResolve@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>);
}

/*
==============
RT_SunShadow_DrawCascadeSetup
==============
*/

void __fastcall RT_SunShadow_DrawCascadeSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_SunShadow_DrawCascadeSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibilityPrepass@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  return ??$cRBTD_Shadow_Overlay@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
RT_SunShadow_DrawCacheSetup
==============
*/

void __fastcall RT_SunShadow_DrawCacheSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_SunShadow_DrawCacheSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_SunShadow_BlitCache_CS
==============
*/

void __fastcall RBT_SunShadow_BlitCache_CS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_BlitCache_CS@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_CreateVisibilityIndirectBuffers
==============
*/

void __fastcall RBT_SunShadow_CreateVisibilityIndirectBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_CreateVisibilityIndirectBuffers@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DownsamplePass1
==============
*/

void __fastcall RBT_SunShadow_DownsamplePass1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DownsamplePass1@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  return ??$cRBT_SunShadow_CopyDepth@UR_TG_Handle@@U1@HU1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1AEBH11@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>);
}

/*
==============
RT_SunShadow_DrawTranslucentSetup
==============
*/

void __fastcall RT_SunShadow_DrawTranslucentSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_SunShadow_DrawTranslucentSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>)
{
  return ??$cRBT_SunShadow_GenerateVisibilityPrepassVRS@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>);
}

/*
==============
RBT_SunShadow_GenerateVisibilityInlineResolve
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibilityInlineResolve@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBTD_Shadow_Overlay
==============
*/

void __fastcall RBTD_Shadow_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_Shadow_Overlay@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cRBT_SunShadow_Resolve@UR_TG_Handle@@HU1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@AEBH1@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepassVRS
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibilityPrepassVRS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibilityPrepassVRS@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_SunShadow_ClearTranslucentAsync@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMask
==============
*/

void __fastcall RBT_Sunshadow_GenerateTransShadowMask(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_Sunshadow_GenerateTransShadowMask@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_DownsamplePass0
==============
*/

void __fastcall RBT_SunShadow_DownsamplePass0(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_DownsamplePass0@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_ClearCascade
==============
*/

void __fastcall RBT_SunShadow_ClearCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_ClearCascade@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>)
{
  return ??$cRBT_SunShadow_GenerateVisibility@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>);
}

/*
==============
RBT_SunShadow_Resolve
==============
*/

void __fastcall RBT_SunShadow_Resolve(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_Resolve@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SunShadow_GenerateVisibility
==============
*/

void __fastcall RBT_SunShadow_GenerateVisibility(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SunShadow_GenerateVisibility@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_Sunshadow_GenerateTransShadowMask@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_Shadow_Overlay<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBTD_Shadow_Overlay.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>);
}

/*
==============
cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_GenerateCompressedSunShadow_Compress<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_GenerateCompressedSunShadow_Compress.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_ClearCascade<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SunShadow_ClearCascade.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_ClearTranslucentAsync<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_SunShadow_ClearTranslucentAsync.m_index, &stack);
}

/*
==============
cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_CopyDepth<R_TG_Handle,R_TG_Handle,int,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  int v12; 
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  m_index = g_R_TG_Def_RBT_SunShadow_CopyDepth.m_index;
  handleArgCount = arguments.handleArgCount + 1;
  arguments.handleArgs[0] = &<args_0>->index;
  arguments.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = arguments.handleArgCount;
  }
  v12 = *<args_2>;
  arguments.handleArgs[handleArgCount] = &<args_1>->index;
  ++arguments.handleArgCount;
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle>(context, m_index, &arguments, v12, <args_3>, <args_4>);
}

/*
==============
cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_CreateVisibilityIndirectBuffers<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SunShadow_CreateVisibilityIndirectBuffers.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_DepthReadBarrier<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_SunShadow_DepthReadBarrier.m_index, &stack);
}

/*
==============
cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_DownsamplePass0<R_TG_Handle,R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const int *<args_2>, const R_TG_Handle *<args_3>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  ++arguments.handleArgCount;
  arguments.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask<int,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_DownsamplePass0.m_index, &arguments, <args_1>, <args_2>, <args_3>);
}

/*
==============
cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>
==============
*/
unsigned int cRBT_SunShadow_DownsamplePass1<R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>)
{
  int v6; 
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  v6 = *<args_1>;
  ++arguments.handleArgCount;
  arguments.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask<>(context, g_R_TG_Def_RBT_SunShadow_DownsamplePass1.m_index, &arguments, v6);
}

/*
==============
cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_DrawCache<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SunShadow_DrawCache.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibility<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibility.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibilityInlineResolve<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibilityInlineResolve.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibilityPrepass<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibilityPrepass.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>);
}

/*
==============
cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_GenerateVisibilityPrepassVRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_GenerateVisibilityPrepassVRS.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>);
}

/*
==============
cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>
==============
*/
unsigned int cRBT_SunShadow_Resolve<R_TG_Handle,int,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const int *<args_1>, const R_TG_Handle *<args_2>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<int,R_TG_Handle>(context, g_R_TG_Def_RBT_SunShadow_Resolve.m_index, &arguments, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Sunshadow_GenerateTransShadowMask<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Sunshadow_GenerateTransShadowMask.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBTD_Shadow_Overlay
==============
*/
void RBTD_Shadow_Overlay(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v6; 
  unsigned int v10; 
  __int64 v11; 
  R_RT_Handle *attachments; 
  unsigned __int16 m_surfaceID; 
  R_RT_Handle *v14; 
  R_RT_Handle v15; 
  R_RT_Handle *v17; 
  R_RT_Handle v18; 
  bool v20; 
  R_RT_Handle *v21; 
  R_RT_Handle v22; 
  bool v24; 
  R_RT_BufferHandle *v25; 
  int v27; 
  R_RT_Handle v30; 
  bool v32; 
  R_RT_Handle *v33; 
  GfxCmdBufContext v34; 
  R_RT_Handle v35; 
  int integer; 
  R_RT_Handle v37; 
  R_RT_Handle v38; 
  R_RT_Handle v39; 
  __m256i v40; 
  R_RT_Handle v41; 
  R_RT_BufferHandle v42[3]; 
  R_RT_Handle v43[3]; 

  v6 = 0;
  v10 = 0;
  v11 = 0i64;
  integer = sm_showOverlay->current.integer;
  attachments = taskInfo->attachments;
  do
  {
    m_surfaceID = attachments[v11].m_surfaceID;
    v14 = &attachments[v11];
    if ( m_surfaceID )
    {
      R_RT_Handle::GetSurface(v14);
    }
    else if ( v14->m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    attachments = taskInfo->attachments;
    if ( !m_surfaceID )
      break;
    v43[v11] = attachments[v11];
    ++v11;
    ++v6;
    ++v10;
  }
  while ( v10 < 3 );
  v15 = attachments[6];
  v37 = v15;
  v35 = v15;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v15 = v35;
    }
    else
    {
      v15 = v35;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v15 = v37;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  v17 = taskInfo->attachments;
  v42[0] = (R_RT_BufferHandle)v15;
  v18 = v17[7];
  v37 = v18;
  v35 = v18;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v18 = v35;
    }
    else
    {
      v18 = v35;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v18 = v37;
      if ( v20 )
        __debugbreak();
    }
  }
  v21 = taskInfo->attachments;
  v42[1] = (R_RT_BufferHandle)v18;
  v22 = v21[8];
  v37 = v22;
  v35 = v22;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v22 = v35;
    }
    else
    {
      v22 = v35;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v24 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v22 = v37;
      if ( v24 )
        __debugbreak();
    }
  }
  v25 = (R_RT_BufferHandle *)taskInfo->attachments;
  v42[2] = (R_RT_BufferHandle)v22;
  v39 = v25[9].R_RT_Handle;
  v35 = v39;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v39 = v35;
    }
    else
    {
      v39 = v35;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  v27 = integer;
  if ( integer )
  {
    v38 = taskInfo->attachments[10];
    v35 = v38;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v35);
      if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v38 = v35;
        __debugbreak();
      }
      else
      {
        v38 = v35;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v37 = taskInfo->attachments[5];
    v35 = v37;
    if ( (_WORD)_XMM1 )
    {
      R_RT_Handle::GetSurface(&v35);
      if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v37 = v35;
      }
      else
      {
        v37 = v35;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v30 = taskInfo->attachments[4];
    v40 = (__m256i)v30;
    v35 = v30;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v35);
      if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v30 = v35;
        __debugbreak();
      }
      else
      {
        v30 = v35;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v32 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v30 = (R_RT_Handle)v40;
        if ( v32 )
          __debugbreak();
      }
    }
    v33 = taskInfo->attachments;
    v40 = (__m256i)v38;
    v38 = v30;
    v34 = *gfxContext;
    v41 = v33[3];
    *(GfxCmdBufContext *)&v35.m_surfaceID = v34;
    R_Shadow_DrawOverlay((GfxCmdBufContext *)&v35, viewInfo, v27, v43, v6, &v41, (const R_RT_ColorHandle *)&v38, (const R_RT_DepthHandle *)&v37, v42, (R_RT_BufferHandle *)&v39, (const R_RT_ColorHandle *)&v40);
  }
  R_CompressedSunShadow_DrawOverlay(gfxContext, viewInfo);
}

/*
==============
RBT_CompressSunShadow_Main
==============
*/
void RBT_CompressSunShadow_Main(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v10; 
  bool v12; 
  R_RT_Handle *attachments; 
  R_RT_Handle v14; 
  bool v16; 
  const unsigned int *pTaskData; 
  __int64 v18; 
  ID3D12Resource **ConstantBuffers; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v21; 
  R_RT_Handle v22; 
  R_RT_Handle v23; 
  R_RT_Handle v24; 
  R_RT_Handle v25; 
  R_RT_Handle v26; 
  R_RT_Handle v27; 

  v25 = *taskInfo->attachments;
  v22 = v25;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v22);
    if ( (R_RT_Handle::GetSurface(&v22)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
    {
      v25 = v22;
    }
    else
    {
      v25 = v22;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  v26 = taskInfo->attachments[1];
  v22 = v26;
  if ( (_WORD)_XMM1 )
  {
    R_RT_Handle::GetSurface(&v22);
    if ( (R_RT_Handle::GetSurface(&v22)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
    {
      v26 = v22;
    }
    else
    {
      v26 = v22;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm1, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
  }
  v10 = taskInfo->attachments[2];
  v22 = v10;
  v23 = v10;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v23);
    if ( (R_RT_Handle::GetSurface(&v23)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v10 = v23;
      v22 = v23;
    }
    else
    {
      v10 = v23;
      v22 = v23;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v10 = v22;
      if ( v12 )
        __debugbreak();
    }
  }
  attachments = taskInfo->attachments;
  v27 = v10;
  v14 = attachments[3];
  v24 = v14;
  v23 = v14;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v23);
    if ( (R_RT_Handle::GetSurface(&v23)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v14 = v23;
    }
    else
    {
      v14 = v23;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v14 = v24;
      if ( v16 )
        __debugbreak();
    }
  }
  pTaskData = taskInfo->pTaskData;
  v24 = v14;
  v18 = *pTaskData;
  ConstantBuffers = R_CompressSunShadow_GetConstantBuffers();
  Surface = R_RT_Handle::GetSurface(&v27);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  R_ClearBuffer_Uint(computeState, (const GfxWrappedRWBuffer *)&Surface->1080, 0, 1, PIPE_FLUSH_PARTIAL);
  v21 = R_RT_Handle::GetSurface(&v24);
  if ( (v21->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 589, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  if ( (v21->m_rtFlags & 0x1000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 590, ASSERT_TYPE_ASSERT, "(surface->m_rtFlags & R_RT_Flag_RWView)", (const char *)&queryFormat, "surface->m_rtFlags & R_RT_Flag_RWView") )
    __debugbreak();
  v27 = v22;
  v24 = v26;
  R_CompressSunShadow(computeState, &ConstantBuffers[v18], (R_RT_DepthHandle *)&v25, (R_RT_DepthHandle *)&v24, (R_RT_BufferHandle *)&v27, &v21->m_buffer.m_wrappedBuffer.rwView);
}

/*
==============
RBT_GenerateCompressedSunShadow_Compress
==============
*/
void RBT_GenerateCompressedSunShadow_Compress(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_SunShadow_BlitCache
==============
*/
void RBT_SunShadow_BlitCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v8; 
  R_RT_Handle v9; 
  R_RT_Handle v11; 
  __m256i v12; 

  v8 = *taskInfo->pTaskData;
  if ( v8 < data->sunShadow.opaqueCascadeCount )
  {
    if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 && viewInfo->useCachedSunShadow && data->sunShadow.firstCachedSunShadowPartition <= v8 && v8 <= data->sunShadow.lastCachedSunShadowPartition && R_GetSunShadowPartitionCache(&data->sunShadow, v8)->gfxCachedSunShadowOverlapCount )
    {
      v9 = *taskInfo->attachments;
      v12 = (__m256i)v9;
      v11 = v9;
      if ( (_WORD)_XMM0 )
      {
        R_RT_Handle::GetSurface(&v11);
        if ( (R_RT_Handle::GetSurface(&v11)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
        {
          v9 = v11;
        }
        else
        {
          v9 = v11;
          __debugbreak();
        }
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX )
        {
          v9 = (R_RT_Handle)v12;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
            __debugbreak();
        }
      }
      v12 = (__m256i)v9;
      *(GfxCmdBufContext *)&v11.m_surfaceID = *gfxContext;
      R_DrawSunshadow_BlitCache(data, (GfxCmdBufContext *)&v11, v8, (R_RT_DepthHandle *)&v12);
    }
    else if ( (R_RT_Handle::GetSurface(&taskInfo->rtGroup.m_depthRt)->m_rtFlags & 0x100) == 0 )
    {
      R_ClearScreen(gfxContext->state, 0x10u, 0);
    }
  }
}

/*
==============
RBT_SunShadow_BlitCache_CS
==============
*/
void RBT_SunShadow_BlitCache_CS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int128 v5; 
  const unsigned int *pTaskData; 
  ComputeCmdBufState *v10; 
  unsigned int v11; 
  R_RT_Handle v12; 
  R_RT_Handle *attachments; 
  GfxSunShadow *p_sunShadow; 
  const GfxSunShadowPartitionCache *SunShadowPartitionCache; 
  const dvar_t *v18; 
  const GfxSunShadowPartitionCache *v19; 
  __int64 gfxCachedSunShadowOverlapCount; 
  float *p_x; 
  __int64 v22; 
  int MapSize; 
  int v24; 
  int v25; 
  int v26; 
  signed int v27; 
  float v28; 
  int v29; 
  int v30; 
  int v31; 
  signed int v32; 
  unsigned int v33; 
  signed int v34; 
  int v35; 
  unsigned int v36; 
  unsigned int v37; 
  float v38; 
  float v39; 
  char v40; 
  bool v41; 
  const R_RT_Surface *v42; 
  const unsigned __int8 *v43; 
  const unsigned __int8 *v44; 
  const R_RT_Surface *v45; 
  __int64 v46; 
  __int64 m_textureSize; 
  const R_RT_Surface *Surface; 
  float m_clearDepth; 
  unsigned int v50; 
  const R_RT_Surface *BaseSurface; 
  const unsigned __int8 *ResidentPixels; 
  const R_RT_Surface *v53; 
  __int64 v54; 
  __int64 v55; 
  bool v56; 
  char v57; 
  int v58; 
  unsigned int v59; 
  unsigned int v60; 
  float outBias; 
  float outScale; 
  unsigned int v63; 
  R_RT_Handle v64; 
  ComputeCmdBufState *v65; 
  __int64 v66; 
  GfxSunShadow *sunShadow; 
  R_RT_Handle v68; 
  R_RT_Handle v69; 
  R_RT_Handle v70; 
  ID3D12Resource *m_floatTexture; 
  int v72; 
  unsigned int m_subresourceToTransition; 
  R_RT_Handle v74; 
  R_RT_Handle v75; 
  char v76[56]; 
  char v77[56]; 
  __int128 v78; 

  pTaskData = taskInfo->pTaskData;
  v65 = computeState;
  v10 = computeState;
  v11 = *pTaskData;
  if ( *pTaskData < data->sunShadow.opaqueCascadeCount )
  {
    v12 = *taskInfo->attachments;
    v68 = v12;
    v64 = v12;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v64);
      if ( (R_RT_Handle::GetSurface(&v64)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v12 = v64;
        v68 = v64;
      }
      else
      {
        v12 = v64;
        v68 = v64;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v12 = v68;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    attachments = taskInfo->attachments;
    v64 = v12;
    v70 = attachments[1];
    v74 = v70;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v74);
      if ( (R_RT_Handle::GetSurface(&v74)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v70 = v74;
      }
      else
      {
        v70 = v74;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) == 0 || !viewInfo->useCachedSunShadow || data->sunShadow.firstCachedSunShadowPartition > v11 || v11 > data->sunShadow.lastCachedSunShadowPartition || (p_sunShadow = &data->sunShadow, sunShadow = p_sunShadow, !R_GetSunShadowPartitionCache(p_sunShadow, v11)->gfxCachedSunShadowOverlapCount) )
    {
      if ( (R_RT_Handle::GetSurface(&v64)->m_rtFlags & 0x100) == 0 )
        return;
      Surface = R_RT_Handle::GetSurface(&v64);
      if ( (Surface->m_rtFlagsInternal & 0x10) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 400, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth") )
        __debugbreak();
      m_clearDepth = Surface->m_depth.m_clearDepth;
      v63 = LODWORD(m_clearDepth);
      if ( R_RT_Handle::GetSurface(&v64)->m_image.m_base.format == GFX_PF_D16 )
        v50 = 65537 * (int)(float)(m_clearDepth * 65535.0);
      else
        v50 = v63;
      BaseSurface = R_RT_Handle::GetBaseSurface(&v64);
      ResidentPixels = R_Image_GetResidentPixels(&BaseSurface->m_image.m_base);
      v44 = &ResidentPixels[R_RT_Handle::GetSurface(&v64)->m_textureOffset];
      v53 = R_RT_Handle::GetSurface(&v64);
      v46 = v50;
      m_textureSize = v53->m_textureSize;
      goto LABEL_102;
    }
    v78 = v5;
    SunShadowPartitionCache = R_GetSunShadowPartitionCache(p_sunShadow, v11);
    v18 = DCONST_DVARBOOL_r_resolveSunCacheFinal;
    v19 = SunShadowPartitionCache;
    v57 = 0;
    gfxCachedSunShadowOverlapCount = SunShadowPartitionCache->gfxCachedSunShadowOverlapCount;
    outBias = 0.0;
    outScale = FLOAT_1_0;
    if ( !DCONST_DVARBOOL_r_resolveSunCacheFinal && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_resolveSunCacheFinal") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v18);
    v56 = !v18->current.enabled || (R_RT_Handle::GetSurface(&v64)->m_rtFlags & 0x100) == 0 && Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_sm_sunCascadeHtileUseCacheHiZ, "sm_sunCascadeHtileUseCacheHiZ");
    if ( (_DWORD)gfxCachedSunShadowOverlapCount )
    {
      p_x = &v19->gfxCachedSunShadowOverlap[0].x;
      v66 = gfxCachedSunShadowOverlapCount;
      do
      {
        v22 = *(_QWORD *)(p_x - 11);
        v74 = v70;
        R_SunShadowCache_GetDepthRt((R_RT_DepthHandle *)&v75, *(unsigned __int16 *)(v22 + 502), (R_RT_DepthHandle *)&v74);
        MapSize = R_SunShadow_GetMapSize();
        v24 = MapSize;
        v25 = (int)*p_x;
        v26 = (int)p_x[1];
        if ( MapSize < 0 )
        {
          LODWORD(v55) = MapSize;
          LODWORD(v54) = 0;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v54, v55) )
            __debugbreak();
        }
        v27 = v25;
        if ( v24 < v25 )
          v27 = v24;
        if ( v27 < 0 )
          v27 = 0;
        if ( v24 < 0 )
        {
          LODWORD(v55) = v24;
          LODWORD(v54) = 0;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v54, v55) )
            __debugbreak();
        }
        v28 = p_x[2] + *p_x;
        v29 = v26;
        if ( v24 < v26 )
          v29 = v24;
        if ( v29 < 0 )
          v29 = 0;
        v63 = v27 - v25;
        v60 = v29;
        v58 = v29 - v26;
        v30 = (int)v28;
        if ( v24 < 0 )
        {
          LODWORD(v55) = v24;
          LODWORD(v54) = 0;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v54, v55) )
            __debugbreak();
        }
        v31 = (int)(float)(p_x[3] + p_x[1]);
        if ( v24 < v30 )
          v30 = v24;
        if ( v30 < 0 )
          v30 = 0;
        v32 = v30 - v27;
        if ( v24 < 0 )
        {
          LODWORD(v55) = v24;
          LODWORD(v54) = 0;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 799, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%i, %i", v54, v55) )
            __debugbreak();
        }
        v33 = v60;
        if ( v24 < v31 )
          v31 = v24;
        if ( v31 < 0 )
          v31 = 0;
        v34 = v31 - v60;
        v35 = v34;
        if ( v32 < v34 )
          v35 = v32;
        if ( v35 <= 0 )
        {
          v10 = v65;
        }
        else
        {
          v36 = *(_DWORD *)(v22 + 508) + v58;
          v37 = *(_DWORD *)(v22 + 504) + v63;
          v59 = v36;
          if ( rg.useCompressedSunShadowClipPlanes )
          {
            R_CompressedSunShadow_GetClipPlanesScaleBias(sunShadow, p_x[5], p_x[6], &outScale, &outBias);
            v38 = outScale;
            v39 = outBias;
            if ( outScale == 1.0 && outBias == 0.0 )
            {
              v36 = v59;
              v40 = 0;
              v33 = v60;
              v57 = 0;
            }
            else
            {
              v36 = v59;
              v40 = 1;
              v33 = v60;
              v57 = 1;
            }
          }
          else
          {
            v39 = outBias;
            v38 = outScale;
            v40 = v57;
          }
          v41 = v56 || v40;
          v56 = v41;
          if ( v41 )
          {
            v10 = v65;
            v74 = v68;
            v69 = v75;
            R_CopyCompressedDepthRect(v65, (R_RT_DepthHandle *)&v69, &v74, v37, v36, v27, v33, v32, v34, v39, v38, 0);
          }
          else
          {
            if ( v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 199, ASSERT_TYPE_ASSERT, "( !useScaleBias )", "xbox todo: uncompressed depth copy with scale+bias") )
              __debugbreak();
            *(_DWORD *)&v74.m_surfaceID = v37;
            *(&v74.m_tracking.m_allocCounter + 1) = v32 + v37;
            *((_DWORD *)&v74.m_surfaceID + 1) = v59;
            LODWORD(v74.m_tracking.m_name) = v34 + v59;
            v74.m_tracking.m_allocCounter = 0;
            HIDWORD(v74.m_tracking.m_name) = 1;
            *(_QWORD *)&v69.m_surfaceID = R_RT_Handle::GetSurface(&v75)->m_depth.m_floatTexture;
            v69.m_tracking.m_allocCounter = 0;
            if ( R_RT_Handle::GetSurface(&v75)->m_subresourceToTransition == -1 )
              LODWORD(v69.m_tracking.m_name) = 0;
            else
              LODWORD(v69.m_tracking.m_name) = R_RT_Handle::GetSurface(&v75)->m_subresourceToTransition;
            (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)&v69.m_surfaceID + 80i64))(*(_QWORD *)&v69.m_surfaceID, v76);
            m_floatTexture = R_RT_Handle::GetSurface(&v64)->m_depth.m_floatTexture;
            v72 = 0;
            if ( R_RT_Handle::GetSurface(&v64)->m_subresourceToTransition == -1 )
              m_subresourceToTransition = 0;
            else
              m_subresourceToTransition = R_RT_Handle::GetSurface(&v64)->m_subresourceToTransition;
            ((void (__fastcall *)(ID3D12Resource *, char *))m_floatTexture->m_pFunction[3].AddRef)(m_floatTexture, v77);
            v10 = v65;
            ((void (__fastcall *)(GfxDevice *, ID3D12Resource **, _QWORD, _QWORD, _DWORD, R_RT_Handle *, R_RT_Handle *, _DWORD))v65->device->m_pFunction[27].Release)(v65->device, &m_floatTexture, (unsigned int)v27, v60, 0, &v69, &v74, 0);
          }
        }
        p_x += 216;
        --v66;
      }
      while ( v66 );
    }
    if ( (R_RT_Handle::GetSurface(&v64)->m_rtFlags & 0x100) == 0 && !v56 )
    {
      if ( (R_RT_Handle::GetSurface(&v64)->m_rtFlags & 0x80) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 258, ASSERT_TYPE_ASSERT, "( !sunshadowCascade.HTile_EncodesStencil() )", "need default hiZ value for hiS") )
        __debugbreak();
      v42 = R_RT_Handle::GetBaseSurface(&v64);
      v43 = R_Image_GetResidentPixels(&v42->m_image.m_base);
      v44 = &v43[R_RT_Handle::GetSurface(&v64)->m_htileOffset];
      v45 = R_RT_Handle::GetSurface(&v64);
      v46 = 4294705167i64;
      m_textureSize = v45->m_htileSize;
LABEL_102:
      ((void (__fastcall *)(GfxDevice *, const unsigned __int8 *, __int64, __int64, _DWORD))v10->device->m_pFunction[20].AddRef)(v10->device, v44, m_textureSize, v46, 0);
    }
  }
}

/*
==============
RBT_SunShadow_ClearCascade
==============
*/
void RBT_SunShadow_ClearCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_SunShadow_ClearTranslucentAsync
==============
*/
void RBT_SunShadow_ClearTranslucentAsync(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v7; 
  R_RT_Handle v8; 

  if ( rg.useTransSunShadow && (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 && data->transShadowBoundsCountPrevFrame )
  {
    v8 = *taskInfo->attachments;
    R_RT_ColorHandle::Cast((R_RT_ColorHandle *)&v7, &v8);
    if ( (R_RT_Handle::GetSurface(&v7)->m_rtFlags & 9) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 510, ASSERT_TYPE_ASSERT, "((colorRt.GetFlags() & (R_RT_Flag_FastClear | R_RT_Flag_Dcc)) == 0)", "%s\n\tclear not possible for rts with meta data", "(colorRt.GetFlags() & (R_RT_Flag_FastClear | R_RT_Flag_Dcc)) == 0") )
      __debugbreak();
    v8 = v7;
    R_Sunshadow_ClearTranslucent(computeState, viewInfo, data, (R_RT_ColorHandle *)&v8);
  }
}

/*
==============
RBT_SunShadow_CopyDepth
==============
*/
void RBT_SunShadow_CopyDepth(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v5; 
  unsigned int v9; 
  unsigned int MapSize; 
  unsigned int v11; 
  const char *v12; 
  int v13; 
  int v14; 
  int v15; 
  int v16; 
  unsigned int v17; 
  int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  R_RT_Handle *attachments; 
  const dvar_t *v24; 
  const dvar_t *v25; 
  R_RT_Handle *ViewInternal; 
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  unsigned int v29; 
  const GfxTexture *v30; 
  unsigned int outX; 
  unsigned int outY; 
  unsigned int outSizeX; 
  unsigned int outSizeY; 
  R_RT_Handle v35; 
  const GfxTaskInfo *v36; 
  R_RT_Handle v37; 
  R_RT_Handle v38; 

  v5 = (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) == 0;
  v36 = taskInfo;
  if ( !v5 )
  {
    v9 = *taskInfo->pTaskData;
    MapSize = R_SunShadow_GetMapSize();
    v11 = MapSize;
    if ( v9 )
    {
      _XMM0 = *(_OWORD *)viewInfo->sunShadowAndDepthHackSurfBounds[32].midPoint.v;
      v12 = *(const char **)&viewInfo->sunShadowAndDepthHackSurfBounds[32].halfSize.y;
      *(_OWORD *)&v38.m_surfaceID = _XMM0;
      v38.m_tracking.m_name = v12;
      Bounds_OverlapProjectionGrid((const Bounds *)&v38, &data->sunShadow.lookupMatrix.m, MapSize >> 3, &outX, &outY, &outSizeX, &outSizeY);
      v13 = 8 * outX;
      v14 = 8 * outY;
      v15 = I_clamp(8 * outX + 8 * outSizeX, 0, v11);
      v16 = I_clamp(v14 + 8 * outSizeY, 0, v11);
      v17 = I_clamp(v13, 0, v11);
      v18 = I_clamp(v14, 0, v11);
      v19 = v15 - v17;
      v20 = v16 - v18;
      outX = v19;
      v21 = v18;
      if ( !v19 || !v20 )
        return;
    }
    else
    {
      v21 = 0;
      outX = MapSize;
      v17 = 0;
      v20 = MapSize;
      v19 = MapSize;
    }
    attachments = v36->attachments;
    v37 = *attachments;
    v35 = attachments[1];
    v38 = v35;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v38);
      if ( (R_RT_Handle::GetSurface(&v38)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v35 = v38;
      }
      else
      {
        v35 = v38;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v24 = DCONST_DVARBOOL_sm_sunCompressedCopy;
    if ( !DCONST_DVARBOOL_sm_sunCompressedCopy && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunCompressedCopy") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v24);
    if ( v24->current.enabled )
    {
      v38 = v37;
      R_CopyCompressedDepthRect(computeState, (R_RT_DepthHandle *)&v35, &v38, v17, v21, v17, v21, v19, v20, 0.0, 1.0, 1);
    }
    else
    {
      v38 = v37;
      R_CopyTextureRect(computeState, &v38, &v35, v17, v21, 0, 0, v17, v21, 0, 0, v19, v20);
    }
    v25 = DCONST_DVARBOOL_sm_sunSafeCopy;
    if ( !DCONST_DVARBOOL_sm_sunSafeCopy && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunSafeCopy") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v25);
    if ( v25->current.enabled )
    {
      ViewInternal = R_RT_GetViewInternal(&v35, &v37, 0, 0);
      Surface = R_RT_Handle::GetSurface(ViewInternal);
      Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
      v29 = v21 + v20;
      v30 = Resident;
      if ( v21 )
        R_SetTextureRect(computeState, Resident, &colorBlack, 0, 0, v11, v21);
      if ( v17 )
        R_SetTextureRect(computeState, v30, &colorBlack, 0, v21, v17, v20);
      if ( v17 + outX < v11 )
        R_SetTextureRect(computeState, v30, &colorBlack, v17 + outX, v21, v11 - (v17 + outX), v20);
      if ( v29 < v11 )
        R_SetTextureRect(computeState, v30, &colorBlack, 0, v21 + v20, v11, v11 - v29);
    }
  }
}

/*
==============
RBT_SunShadow_CreateVisibilityIndirectBuffers
==============
*/
void RBT_SunShadow_CreateVisibilityIndirectBuffers(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int16 v4; 
  GfxShaderBufferRWView *p_rwView; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v9; 
  GfxShaderBufferRWView *views; 

  R_SetComputeShader(computeState, rgp.csmPrepassInitIndirectArgs);
  v9 = *taskInfo->attachments;
  if ( v4 )
  {
    R_RT_Handle::GetSurface(&v9);
    Surface = R_RT_Handle::GetSurface(&v9);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v9.m_surfaceID) )
      __debugbreak();
    p_rwView = &Surface->m_buffer.m_wrappedBuffer.rwView;
  }
  else
  {
    if ( v9.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v9.m_surfaceID) )
      __debugbreak();
    p_rwView = &gfxBuf.dummyRWBuffer.rwView;
  }
  views = p_rwView;
  R_SetComputeRWViewsWithCounters(computeState, 1, 1, (const GfxShaderBufferRWView *const *)&views, NULL);
  R_Dispatch(computeState, 1u, 1u, 1u);
}

/*
==============
RBT_SunShadow_DepthReadBarrier
==============
*/
void RBT_SunShadow_DepthReadBarrier(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

/*
==============
RBT_SunShadow_DownsamplePass0
==============
*/
void RBT_SunShadow_DownsamplePass0(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v7; 
  R_RT_Handle *attachments; 
  __int64 width; 
  const R_RT_Surface *Surface; 
  __int64 height; 
  bool v13; 
  const R_RT_Surface *v14; 
  R_RT_Handle v15; 
  bool v17; 
  const R_RT_Surface *v18; 
  R_RT_Handle v19; 
  bool v21; 
  const R_RT_Surface *v22; 
  R_RT_Handle v23; 
  bool v25; 
  const R_RT_Surface *v26; 
  R_RT_Handle v27; 
  bool v29; 
  const R_RT_Surface *v30; 
  float v31; 
  float v32; 
  __int64 v33; 
  __int64 v34; 
  GfxShaderTextureRWView *views; 
  _QWORD v36[5]; 
  R_RT_Handle v37; 
  R_RT_Handle v38; 
  R_RT_Handle v39; 
  R_RT_Handle v40; 
  int dataa[4]; 

  if ( *taskInfo->pTaskData >= data->sunShadow.opaqueCascadeCount )
    return;
  v7 = *taskInfo->attachments;
  v38 = v7;
  v40 = v7;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v40);
    if ( (R_RT_Handle::GetSurface(&v40)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v7 = v40;
      v38 = v40;
      __debugbreak();
    }
    else
    {
      v7 = v40;
      v38 = v40;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v7 = v38;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  attachments = taskInfo->attachments;
  v37 = v7;
  *(R_RT_Handle *)&v36[1] = attachments[1];
  v40 = *(R_RT_Handle *)&v36[1];
  width = R_RT_Handle::GetSurface(&v40)->m_image.m_base.width;
  Surface = R_RT_Handle::GetSurface(&v40);
  height = Surface->m_image.m_base.height;
  if ( (_DWORD)width != (_DWORD)height && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 811, ASSERT_TYPE_ASSERT, "( width ) == ( height )", "%s == %s\n\t%i, %i", "width", "height", width, Surface->m_image.m_base.height) )
    __debugbreak();
  if ( (_BYTE)width )
  {
    LODWORD(v33) = (unsigned __int8)width;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 812, ASSERT_TYPE_ASSERT, "( width % 256 ) == ( 0 )", "%s == %s\n\t%i, %i", "width % 256", "0", v33, 0i64) )
      __debugbreak();
  }
  if ( R_RT_Handle::GetSurface(&v37)->m_image.m_base.levelCount != 8 )
  {
    LODWORD(v34) = 8;
    LODWORD(v33) = R_RT_Handle::GetSurface(&v37)->m_image.m_base.levelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 813, ASSERT_TYPE_ASSERT, "( sunshadowMin.GetMipCount() ) == ( 8 )", "%s == %s\n\t%i, %i", "sunshadowMin.GetMipCount()", "SUN_MIN_DEPTH_MIP_LIMIT", v33, v34) )
      __debugbreak();
  }
  if ( (R_RT_Handle::GetSurface(&v40)->m_rtFlagsInternal & 0x10) == 0 )
  {
    v14 = R_RT_Handle::GetSurface(&v40);
    views = (GfxShaderTextureRWView *)R_Texture_GetResident(v14->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 4, 1, (const GfxTexture *const *)&views);
    goto LABEL_29;
  }
  v37 = *(R_RT_Handle *)&v36[1];
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v37);
    if ( (R_RT_Handle::GetSurface(&v37)->m_rtFlagsInternal & 0x10) == 0 )
    {
      v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()");
LABEL_25:
      if ( v13 )
        __debugbreak();
    }
  }
  else if ( v40.m_tracking.m_allocCounter )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_XMM0 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
    goto LABEL_25;
  }
  *(R_RT_Handle *)&v36[1] = v37;
  views = R_RT_GetDepthRWView((GfxShaderTextureRWView *)&v40, (R_RT_DepthHandle *)&v36[1]);
  R_SetComputeTextureRWViews(computeState, 4, 1, (const GfxShaderTextureRWView *const *)&views);
LABEL_29:
  *(R_RT_Handle *)&v36[1] = v38;
  v15 = *R_RT_GetViewInternal(&v39, (R_RT_Handle *)&v36[1], 0, 0);
  v37 = v15;
  v40 = v15;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v40);
    if ( (R_RT_Handle::GetSurface(&v40)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v15 = v40;
      __debugbreak();
    }
    else
    {
      v15 = v40;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v15 = v37;
      if ( v17 )
        __debugbreak();
    }
  }
  *(R_RT_Handle *)&v36[1] = v15;
  v18 = R_RT_Handle::GetSurface((R_RT_Handle *)&v36[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v18->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)&views);
  *(R_RT_Handle *)&v36[1] = v38;
  v19 = *R_RT_GetViewInternal(&v39, (R_RT_Handle *)&v36[1], 0, 1);
  v37 = v19;
  v40 = v19;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v40);
    if ( (R_RT_Handle::GetSurface(&v40)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v19 = v40;
      __debugbreak();
    }
    else
    {
      v19 = v40;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v19 = v37;
      if ( v21 )
        __debugbreak();
    }
  }
  *(R_RT_Handle *)&v36[1] = v19;
  v22 = R_RT_Handle::GetSurface((R_RT_Handle *)&v36[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v22->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 1, 1, (const GfxTexture *const *)&views);
  *(R_RT_Handle *)&v36[1] = v38;
  v23 = *R_RT_GetViewInternal(&v39, (R_RT_Handle *)&v36[1], 0, 2);
  v37 = v23;
  v40 = v23;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v40);
    if ( (R_RT_Handle::GetSurface(&v40)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v23 = v40;
      __debugbreak();
    }
    else
    {
      v23 = v40;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v23 = v37;
      if ( v25 )
        __debugbreak();
    }
  }
  *(R_RT_Handle *)&v36[1] = v23;
  v26 = R_RT_Handle::GetSurface((R_RT_Handle *)&v36[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v26->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 2, 1, (const GfxTexture *const *)&views);
  *(R_RT_Handle *)&v36[1] = v38;
  v27 = *R_RT_GetViewInternal(&v39, (R_RT_Handle *)&v36[1], 0, 3);
  v37 = v27;
  v38 = v27;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v38);
    if ( (R_RT_Handle::GetSurface(&v38)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v27 = v38;
      __debugbreak();
    }
    else
    {
      v27 = v38;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v29 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v27 = v37;
      if ( v29 )
        __debugbreak();
    }
  }
  *(R_RT_Handle *)&v36[1] = v27;
  v30 = R_RT_Handle::GetSurface((R_RT_Handle *)&v36[1]);
  views = (GfxShaderTextureRWView *)R_Texture_GetResident(v30->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 3, 1, (const GfxTexture *const *)&views);
  R_SetComputeShader(computeState, rgp.sunshadowDownsample);
  v31 = (float)width;
  v32 = (float)height;
  *(float *)dataa = v31;
  *(float *)&dataa[3] = 1.0 / v32;
  *(float *)&dataa[1] = v32;
  *(float *)&dataa[2] = 1.0 / v31;
  R_UploadAndSetComputeConstants(computeState, 0, dataa, 0x10u, NULL);
  R_Dispatch(computeState, (unsigned int)(width + 15) >> 4, (unsigned int)(height + 15) >> 4, 1u);
}

/*
==============
RBT_SunShadow_DownsamplePass1
==============
*/
void RBT_SunShadow_DownsamplePass1(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v6; 
  unsigned int v8; 
  unsigned int v9; 
  R_RT_Handle v10; 
  bool v12; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v14; 
  bool v16; 
  const R_RT_Surface *v17; 
  R_RT_Handle v18; 
  bool v20; 
  const R_RT_Surface *v21; 
  R_RT_Handle v22; 
  bool v24; 
  const R_RT_Surface *v25; 
  R_RT_Handle v26; 
  bool v28; 
  const R_RT_Surface *v29; 
  float v30; 
  float v31; 
  GfxTexture *textures[2]; 
  R_RT_Handle v33; 
  R_RT_Handle v34; 
  R_RT_Handle v35; 
  R_RT_Handle v36; 
  int dataa[4]; 

  if ( *taskInfo->pTaskData < data->sunShadow.opaqueCascadeCount )
  {
    v6 = *taskInfo->attachments;
    v35 = v6;
    v34 = v6;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v34);
      if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v6 = v34;
        v35 = v34;
        __debugbreak();
      }
      else
      {
        v6 = v34;
        v35 = v34;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v6 = v35;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    v34 = v6;
    v8 = R_RT_Handle::GetSurface(&v34)->m_image.m_base.width >> 3;
    v9 = R_RT_Handle::GetSurface(&v34)->m_image.m_base.height >> 3;
    v33 = v35;
    v10 = *R_RT_GetViewInternal(&v36, &v33, 0, 3);
    v33 = v10;
    v34 = v10;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v34);
      if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v10 = v34;
        __debugbreak();
      }
      else
      {
        v10 = v34;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v10 = v33;
        if ( v12 )
          __debugbreak();
      }
    }
    v33 = v10;
    Surface = R_RT_Handle::GetSurface(&v33);
    textures[0] = (GfxTexture *)R_Texture_GetResident(Surface->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 4, 1, (const GfxTexture *const *)textures);
    v33 = v35;
    v14 = *R_RT_GetViewInternal(&v36, &v33, 0, 4);
    v33 = v14;
    v34 = v14;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v34);
      if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v14 = v34;
        __debugbreak();
      }
      else
      {
        v14 = v34;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v14 = v33;
        if ( v16 )
          __debugbreak();
      }
    }
    v33 = v14;
    v17 = R_RT_Handle::GetSurface(&v33);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v17->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)textures);
    v33 = v35;
    v18 = *R_RT_GetViewInternal(&v36, &v33, 0, 5);
    v33 = v18;
    v34 = v18;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v34);
      if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v18 = v34;
        __debugbreak();
      }
      else
      {
        v18 = v34;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v18 = v33;
        if ( v20 )
          __debugbreak();
      }
    }
    v33 = v18;
    v21 = R_RT_Handle::GetSurface(&v33);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v21->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 1, 1, (const GfxTexture *const *)textures);
    v33 = v35;
    v22 = *R_RT_GetViewInternal(&v36, &v33, 0, 6);
    v33 = v22;
    v34 = v22;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v34);
      if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v22 = v34;
        __debugbreak();
      }
      else
      {
        v22 = v34;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v24 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v22 = v33;
        if ( v24 )
          __debugbreak();
      }
    }
    v33 = v22;
    v25 = R_RT_Handle::GetSurface(&v33);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v25->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 2, 1, (const GfxTexture *const *)textures);
    v33 = v35;
    v26 = *R_RT_GetViewInternal(&v36, &v33, 0, 7);
    v33 = v26;
    v34 = v26;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v34);
      if ( (R_RT_Handle::GetSurface(&v34)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v26 = v34;
        __debugbreak();
      }
      else
      {
        v26 = v34;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v26 = v33;
        if ( v28 )
          __debugbreak();
      }
    }
    v33 = v26;
    v29 = R_RT_Handle::GetSurface(&v33);
    textures[0] = (GfxTexture *)R_Texture_GetResident(v29->m_image.m_base.textureId);
    R_SetComputeRWTextures(computeState, 3, 1, (const GfxTexture *const *)textures);
    R_SetComputeShader(computeState, rgp.sunshadowDownsample);
    v30 = (float)v8;
    v31 = (float)v9;
    *(float *)dataa = v30;
    *(float *)&dataa[3] = 1.0 / v31;
    *(float *)&dataa[1] = v31;
    *(float *)&dataa[2] = 1.0 / v30;
    R_UploadAndSetComputeConstants(computeState, 0, dataa, 0x10u, NULL);
    R_Dispatch(computeState, (v8 + 15) >> 4, (v9 + 15) >> 4, 1u);
  }
}

/*
==============
RBT_SunShadow_DrawCache
==============
*/
void RBT_SunShadow_DrawCache(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v11; 
  bool v13; 
  R_RT_Handle v14; 
  R_RT_Handle v15; 
  __m256i v16; 

  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v15 = taskInfo->attachments[3];
    v14 = v15;
    if ( (_WORD)_XMM1 )
    {
      R_RT_Handle::GetSurface(&v14);
      if ( (R_RT_Handle::GetSurface(&v14)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v15 = v14;
      }
      else
      {
        v15 = v14;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v11 = taskInfo->attachments[4];
    v16 = (__m256i)v11;
    v14 = v11;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v14);
      if ( (R_RT_Handle::GetSurface(&v14)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v11 = v14;
      }
      else
      {
        v11 = v14;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v11 = (R_RT_Handle)v16;
        if ( v13 )
          __debugbreak();
      }
    }
    v16 = (__m256i)v11;
    *(GfxCmdBufContext *)&v14.m_surfaceID = *gfxContext;
    R_DrawSunshadow_DrawCacheForAllCascades((GfxCmdBufContext *)&v14, data, viewInfo, (R_RT_DepthHandle *)&v15, (R_RT_DepthHandle *)&v16, D3D12XBOX_RESOURCE_STATE_PRESERVE_COMPRESSED_DEPTH|D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_DEPTH_READ);
  }
}

/*
==============
RBT_SunShadow_DrawCascade
==============
*/
void RBT_SunShadow_DrawCascade(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const unsigned int *pTaskData; 
  int v8; 
  MaterialTechniqueType v9; 
  R_RT_DepthHandle m_depthRt; 
  GfxDrawCallOutput drawOutput; 

  pTaskData = taskInfo->pTaskData;
  v8 = *pTaskData;
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v9 = pTaskData[1];
    if ( !data->sunShadow.opaqueCascadeCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 458, ASSERT_TYPE_ASSERT, "(data->sunShadow.opaqueCascadeCount > 0)", (const char *)&queryFormat, "data->sunShadow.opaqueCascadeCount > 0") )
      __debugbreak();
    if ( (v8 > 26 || v8 <= data->sunShadow.opaqueCascadeCount + 23) && (viewInfo->useDynamicSunShadows || !viewInfo->useCachedSunShadow) && R_RunDrawListCommandBuffer(data, (const GfxDrawListType)v8) )
    {
      R_GPU_BeginRunDrawListTimer((const GfxDrawListType)v8);
      R_InitDrawCallOutput(data, &drawOutput);
      m_depthRt = taskInfo->rtGroup.m_depthRt;
      R_DrawSunshadow_DrawCascade(viewInfo, (GfxDrawListType)v8, &m_depthRt, v9, &drawOutput);
      R_GPU_EndTimer();
    }
  }
}

/*
==============
RBT_SunShadow_DrawTranslucent
==============
*/
void RBT_SunShadow_DrawTranslucent(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext state; 
  GfxDrawCallOutput drawOutput; 

  state = *gfxContext;
  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    if ( (unsigned __int16)(viewInfo->input.data->sunShadow.opaqueCascadeCount - 1) > 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 596, ASSERT_TYPE_ASSERT, "(viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT)", (const char *)&queryFormat, "viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT", state) )
      __debugbreak();
    if ( *taskInfo->pTaskData == viewInfo->input.data->sunShadow.opaqueCascadeCount - 1 )
    {
      if ( (taskInfo->pGraphInfo->taskFlags & 0x200) == 0 )
        R_ClearRtGroup(state.state, &taskInfo->rtGroup, 0xFu, 0, PIPE_FLUSH_FULL);
      if ( R_RunDrawListCommandBuffer(data, DRAWLIST_SUNSHADOW_END) )
      {
        R_GPU_BeginRunDrawListTimer(DRAWLIST_SUNSHADOW_END);
        R_InitDrawCallOutput(data, &drawOutput);
        R_DrawSunshadow_DrawTranslucent(viewInfo, &viewInfo->drawList[27], &taskInfo->rtGroup, &drawOutput);
        R_GPU_EndTimer();
      }
    }
  }
}

/*
==============
RBT_SunShadow_ExtractCssClippingPlanes
==============
*/
void RBT_SunShadow_ExtractCssClippingPlanes(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v6; 
  R_RT_Handle v8; 
  __m256i v9; 

  v6 = *taskInfo->attachments;
  v9 = (__m256i)v6;
  v8 = v6;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v8);
    if ( (R_RT_Handle::GetSurface(&v8)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      v6 = v8;
    }
    else
    {
      v6 = v8;
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v6 = (R_RT_Handle)v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  v9 = (__m256i)v6;
  R_CompressedSunShadow_ExtractClipPlanes(computeState, (R_RT_BufferHandle *)&v9);
}

/*
==============
RBT_SunShadow_GenerateVisibility
==============
*/
void RBT_SunShadow_GenerateVisibility(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibility_Internal(computeState, taskInfo, viewInfo, data, 0);
}

/*
==============
RBT_SunShadow_GenerateVisibilityInlineResolve
==============
*/
void RBT_SunShadow_GenerateVisibilityInlineResolve(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibility_Internal(computeState, taskInfo, viewInfo, data, 1);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass
==============
*/
void RBT_SunShadow_GenerateVisibilityPrepass(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibilityPrepass_Internal(computeState, taskInfo, viewInfo, data, 0);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepassVRS
==============
*/
void RBT_SunShadow_GenerateVisibilityPrepassVRS(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RBT_SunShadow_GenerateVisibilityPrepass_Internal(computeState, taskInfo, viewInfo, data, 1);
}

/*
==============
RBT_SunShadow_GenerateVisibilityPrepass_Internal
==============
*/
void RBT_SunShadow_GenerateVisibilityPrepass_Internal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool vrsWavePacking)
{
  unsigned __int16 v5; 
  ComputeShader *csmPrepass; 
  R_RT_Image *blackImage; 
  GfxTexture *Resident; 
  R_RT_Image *p_m_image; 
  GfxTexture *v14; 
  R_RT_Image *v15; 
  GfxTexture *v16; 
  R_RT_Image *v17; 
  GfxTexture *v18; 
  R_RT_Image *v19; 
  GfxTexture *v20; 
  R_RT_Image *v21; 
  GfxTexture *v22; 
  R_RT_Image *v23; 
  ID3D12Resource *p_m_tracking; 
  const R_RT_Surface *Surface; 
  ID3D12Resource *p_rwView; 
  ID3D12Resource *v27; 
  const R_RT_Surface *v28; 
  ID3D12Resource *v29; 
  const R_RT_Surface *v30; 
  const R_RT_Surface *v31; 
  const dvar_t *v32; 
  float value; 
  const dvar_t *v34; 
  bool v35; 
  const dvar_t *v36; 
  const dvar_t *v37; 
  ID3D12Resource *buffers[2]; 
  R_RT_Handle v39; 
  int dataa[3]; 
  int v41; 
  GfxTexture *textures[7]; 

  csmPrepass = rgp.csmPrepass;
  if ( vrsWavePacking )
    csmPrepass = rgp.csmPrepassVRS;
  R_SetComputeShader(computeState, csmPrepass);
  buffers[0] = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, buffers);
  blackImage = (R_RT_Image *)rgp.blackImage;
  v39 = *taskInfo->attachments;
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    blackImage = &R_RT_Handle::GetSurface(&v39)->m_image;
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v5 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  Resident = (GfxTexture *)R_Texture_GetResident(blackImage->m_base.textureId);
  p_m_image = (R_RT_Image *)rgp.blackImage;
  textures[0] = Resident;
  v39 = taskInfo->attachments[1];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    p_m_image = &R_RT_Handle::GetSurface(&v39)->m_image;
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v14 = (GfxTexture *)R_Texture_GetResident(p_m_image->m_base.textureId);
  v15 = (R_RT_Image *)rgp.blackImage;
  textures[1] = v14;
  v39 = taskInfo->attachments[2];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    v15 = &R_RT_Handle::GetSurface(&v39)->m_image;
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v16 = (GfxTexture *)R_Texture_GetResident(v15->m_base.textureId);
  v17 = (R_RT_Image *)rgp.blackImage;
  textures[2] = v16;
  v39 = taskInfo->attachments[3];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    v17 = &R_RT_Handle::GetSurface(&v39)->m_image;
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v18 = (GfxTexture *)R_Texture_GetResident(v17->m_base.textureId);
  v19 = (R_RT_Image *)rgp.blackImage;
  textures[3] = v18;
  v39 = taskInfo->attachments[4];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    v19 = &R_RT_Handle::GetSurface(&v39)->m_image;
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v20 = (GfxTexture *)R_Texture_GetResident(v19->m_base.textureId);
  v21 = (R_RT_Image *)rgp.blackImage;
  textures[4] = v20;
  v39 = taskInfo->attachments[5];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    v21 = &R_RT_Handle::GetSurface(&v39)->m_image;
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v22 = (GfxTexture *)R_Texture_GetResident(v21->m_base.textureId);
  v23 = (R_RT_Image *)rgp.blackImage;
  textures[5] = v22;
  v39 = taskInfo->attachments[10];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    if ( vrsWavePacking )
      v23 = &R_RT_Handle::GetSurface(&v39)->m_image;
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  textures[6] = (GfxTexture *)R_Texture_GetResident(v23->m_base.textureId);
  R_SetComputeTextures(computeState, 0, 7, (const GfxTexture *const *)textures);
  buffers[0] = (ID3D12Resource *)&R_CompressedSunShadow_GetBuffer()->view;
  R_SetComputeViews(computeState, 7, 1, (const GfxShaderBufferView *const *)buffers);
  v39 = taskInfo->attachments[6];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    Surface = R_RT_Handle::GetSurface(&v39);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    p_m_tracking = (ID3D12Resource *)&Surface->m_array.m_handles[0].m_tracking;
  }
  else
  {
    if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    p_m_tracking = (ID3D12Resource *)&gfxBuf.dummyBuffer.view;
  }
  buffers[0] = p_m_tracking;
  R_SetComputeViews(computeState, 8, 1, (const GfxShaderBufferView *const *)buffers);
  p_rwView = (ID3D12Resource *)&gfxBuf.dummyRWBuffer.rwView;
  v39 = taskInfo->attachments[7];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    v28 = R_RT_Handle::GetSurface(&v39);
    if ( (v28->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    v27 = (ID3D12Resource *)&v28->m_array.m_handles[1];
  }
  else
  {
    if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    v27 = (ID3D12Resource *)&gfxBuf.dummyRWBuffer.rwView;
  }
  buffers[0] = v27;
  R_SetComputeRWViewsWithCounters(computeState, 0, 1, (const GfxShaderBufferRWView *const *)buffers, NULL);
  v39 = taskInfo->attachments[8];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    v30 = R_RT_Handle::GetSurface(&v39);
    if ( (v30->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    v29 = (ID3D12Resource *)&v30->m_array.m_handles[1];
  }
  else
  {
    if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    v29 = (ID3D12Resource *)&gfxBuf.dummyRWBuffer.rwView;
  }
  buffers[0] = v29;
  R_SetComputeRWViewsWithCounters(computeState, 1, 1, (const GfxShaderBufferRWView *const *)buffers, NULL);
  v39 = taskInfo->attachments[9];
  if ( v5 )
  {
    R_RT_Handle::GetSurface(&v39);
    v31 = R_RT_Handle::GetSurface(&v39);
    if ( (v31->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
      __debugbreak();
    p_rwView = (ID3D12Resource *)&v31->m_array.m_handles[1];
  }
  else if ( v39.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  buffers[0] = p_rwView;
  R_SetComputeRWViewsWithCounters(computeState, 2, 1, (const GfxShaderBufferRWView *const *)buffers, NULL);
  v32 = DCONST_DVARFLT_sm_sunvisPrepassGlobalTileRangeLimit;
  if ( !DCONST_DVARFLT_sm_sunvisPrepassGlobalTileRangeLimit && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassGlobalTileRangeLimit") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v32);
  value = v32->current.value;
  v34 = DCONST_DVARBOOL_sm_sunvisPrepass;
  dataa[0] = data->sunShadow.opaqueCascadeCount - 1;
  *(float *)buffers = value;
  *(float *)&dataa[1] = value;
  if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v34);
  v35 = !v34->current.enabled;
  v36 = DCONST_DVARBOOL_sm_sunvisPrepass;
  dataa[2] = !v35;
  if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v36);
  if ( !v36->current.enabled )
    goto LABEL_88;
  v37 = DCONST_DVARBOOL_sm_sunvisPrepassIndirect;
  if ( !DCONST_DVARBOOL_sm_sunvisPrepassIndirect && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassIndirect") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v37);
  v35 = !v37->current.enabled;
  v41 = 1;
  if ( v35 )
LABEL_88:
    v41 = 0;
  R_UploadAndSetComputeConstants(computeState, 0, dataa, 0x10u, NULL);
  R_Dispatch(computeState, ((((unsigned __int64)viewInfo->sceneViewport.width + 15) >> 4) + 7) >> 3, ((((unsigned __int64)viewInfo->sceneViewport.height + 15) >> 4) + 7) >> 3, 1u);
}

/*
==============
RBT_SunShadow_GenerateVisibility_Internal
==============
*/
void RBT_SunShadow_GenerateVisibility_Internal(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool vrsInlineResolve)
{
  int v9; 
  bool IsValid; 
  __int64 v11; 
  GfxConstantBufferDesc *v12; 
  float sunViewmodelScreenSpaceshadowTraceDelta; 
  float sunViewmodelScreenSpaceshadowTraceDistance; 
  GfxConstantBufferDesc v15; 
  char *bufferData; 
  GfxViewParms *DepthHackViewParms; 
  char *v18; 
  __int64 v19; 
  vec4_t v20; 
  __int128 v21; 
  const dvar_t *v22; 
  const dvar_t *v23; 
  R_RT_Image *blackShadowImage; 
  bool v25; 
  GfxTexture *Resident; 
  int v27; 
  R_RT_Image *p_m_image; 
  bool v29; 
  GfxTexture *v30; 
  int v31; 
  R_RT_Image *v32; 
  bool v33; 
  GfxTexture *v34; 
  int v35; 
  R_RT_Image *v36; 
  bool v37; 
  GfxTexture *v38; 
  bool v39; 
  GfxImage *blackImage; 
  GfxTexture *v41; 
  R_RT_Image *v42; 
  bool v43; 
  GfxTexture *v44; 
  R_RT_Image *v45; 
  bool v46; 
  GfxTexture *v47; 
  R_RT_Image *v48; 
  GfxTexture *v49; 
  R_RT_Image *v50; 
  R_RT_ColorHandle *v51; 
  GfxTextureId textureId; 
  R_RT_Image *v53; 
  GfxShaderBufferView *p_view; 
  GfxShaderBufferView *v55; 
  const R_RT_Surface *Surface; 
  GfxShaderBufferView *v57; 
  GfxShaderBufferView *v58; 
  const R_RT_Surface *v59; 
  GfxShaderBufferView *v60; 
  const R_RT_Surface *v61; 
  const R_RT_Surface *v62; 
  const R_RT_Surface *v63; 
  R_RT_Image *whiteImage; 
  const dvar_t *v65; 
  const dvar_t *v66; 
  const R_RT_Surface *v67; 
  R_RT_Handle buffers_8; 
  GfxConstantBufferDesc cbDesc_8; 
  R_RT_ColorHandle v70; 
  GfxViewParms result; 
  char v72; 
  tmat44_t<vec4_t> in; 
  GfxTexture *textures[10]; 

  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v9 = 0;
    if ( !rg.useTransSunShadow || (IsValid = R_RT_Handle::IsValid(taskInfo->attachments + 4), v11 = 1i64, !IsValid) )
      v11 = 0i64;
    R_SetComputeShader(computeState, rgp.sunvis[v11][vrsInlineResolve]);
    *(_QWORD *)&buffers_8.m_surfaceID = data->globalSceneConstantBuffer->buffer;
    R_SetComputeConstantBuffers(computeState, 7, 1, (ID3D12Resource *const *const)&buffers_8);
    v12 = R_BeginComputeConstants((GfxConstantBufferDesc *)&buffers_8, computeState, 1, 0xB0u);
    sunViewmodelScreenSpaceshadowTraceDelta = viewInfo->screenSpaceShadows.sunViewmodelScreenSpaceshadowTraceDelta;
    sunViewmodelScreenSpaceshadowTraceDistance = viewInfo->screenSpaceShadows.sunViewmodelScreenSpaceshadowTraceDistance;
    v15 = *v12;
    *(float *)&v12 = viewInfo->screenSpaceShadows.sunSceneScreenSpaceShadowTraceDistance;
    bufferData = (char *)v15.bufferData;
    cbDesc_8 = v15;
    *(float *)&v15.bufferData = viewInfo->screenSpaceShadows.sunSceneScreenSpaceShadowTraceDelta;
    *(_DWORD *)bufferData = (_DWORD)v12;
    *((float *)bufferData + 1) = *(float *)&v15.bufferData;
    *((float *)bufferData + 2) = sunViewmodelScreenSpaceshadowTraceDistance;
    *((float *)bufferData + 3) = sunViewmodelScreenSpaceshadowTraceDelta;
    if ( vrsInlineResolve )
      *((base_vec4_t<unsigned int> *)bufferData + 1) = *R_VRSGetPixelsToSamplesUint((base_vec4_t<unsigned int> *)&buffers_8, viewInfo->input.data->frameCount, rg.vrsEmissiveOnly);
    MatrixTranspose44(&viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m, (tmat44_t<vec4_t> *)(bufferData + 32));
    DepthHackViewParms = R_GetDepthHackViewParms(&result, (const GfxViewParms *)viewInfo);
    v18 = &v72;
    v19 = 3i64;
    do
    {
      v18 += 128;
      v20 = DepthHackViewParms->viewMatrix.m.m[0];
      DepthHackViewParms = (GfxViewParms *)((char *)DepthHackViewParms + 128);
      *((vec4_t *)v18 - 8) = v20;
      *((_OWORD *)v18 - 7) = *(_OWORD *)&DepthHackViewParms[-1].camera.axis.row0.y;
      *((_OWORD *)v18 - 6) = *(_OWORD *)&DepthHackViewParms[-1].camera.axis.row1.z;
      *((_OWORD *)v18 - 5) = *(_OWORD *)&DepthHackViewParms[-1].camera.tanHalfFovX;
      *((_OWORD *)v18 - 4) = *(_OWORD *)DepthHackViewParms[-1].camera.zPlanes;
      *((_OWORD *)v18 - 3) = *(_OWORD *)&DepthHackViewParms[-1].camera.focalLength;
      v21 = *(_OWORD *)&DepthHackViewParms[-1].camera.visibilityQueryDistance;
      *((_OWORD *)v18 - 2) = v21;
      *((_OWORD *)v18 - 1) = *(_OWORD *)&DepthHackViewParms[-1].cameraMotion;
      --v19;
    }
    while ( v19 );
    MatrixTranspose44(&in, (tmat44_t<vec4_t> *)(bufferData + 96));
    v22 = DCONST_DVARBOOL_sm_sunvisPrepass;
    if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v22);
    if ( v22->current.enabled )
    {
      v23 = DCONST_DVARBOOL_sm_sunvisPrepassIndirect;
      if ( !DCONST_DVARBOOL_sm_sunvisPrepassIndirect && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassIndirect") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v23);
      if ( v23->current.enabled )
        v9 = 1;
    }
    *((_DWORD *)bufferData + 40) = v9;
    R_EndComputeConstants(computeState, &cbDesc_8);
    blackShadowImage = (R_RT_Image *)rgp.blackShadowImage;
    v25 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 4) != 0;
    buffers_8 = *taskInfo->attachments;
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v25 )
        blackShadowImage = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)v21 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    Resident = (GfxTexture *)R_Texture_GetResident(blackShadowImage->m_base.textureId);
    v27 = *((_DWORD *)&viewInfo->viewportFeatures + 11);
    p_m_image = (R_RT_Image *)rgp.blackShadowImage;
    textures[0] = Resident;
    v29 = (v27 & 4) != 0;
    buffers_8 = taskInfo->attachments[1];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v29 )
        p_m_image = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v30 = (GfxTexture *)R_Texture_GetResident(p_m_image->m_base.textureId);
    v31 = *((_DWORD *)&viewInfo->viewportFeatures + 11);
    v32 = (R_RT_Image *)rgp.blackShadowImage;
    textures[1] = v30;
    v33 = (v31 & 4) != 0;
    buffers_8 = taskInfo->attachments[2];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v33 )
        v32 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v34 = (GfxTexture *)R_Texture_GetResident(v32->m_base.textureId);
    v35 = *((_DWORD *)&viewInfo->viewportFeatures + 11);
    v36 = (R_RT_Image *)rgp.blackShadowImage;
    textures[2] = v34;
    v37 = (v35 & 4) != 0;
    buffers_8 = taskInfo->attachments[3];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v37 )
        v36 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v38 = (GfxTexture *)R_Texture_GetResident(v36->m_base.textureId);
    v39 = (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) == 0;
    textures[3] = v38;
    blackImage = rgp.blackImage;
    if ( !v39 )
      blackImage = rgp.cloudNoiseImage;
    v41 = (GfxTexture *)R_Texture_GetResident(blackImage->textureId);
    v42 = (R_RT_Image *)rgp.blackImage;
    textures[4] = v41;
    v43 = R_SunShadow_TranslucentEnabled(viewInfo);
    buffers_8 = taskInfo->attachments[4];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v43 )
        v42 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)v21 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v44 = (GfxTexture *)R_Texture_GetResident(v42->m_base.textureId);
    v45 = (R_RT_Image *)rgp.blackImage;
    textures[5] = v44;
    v46 = R_SunShadow_TranslucentEnabled(viewInfo);
    buffers_8 = taskInfo->attachments[5];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      if ( v46 )
        v45 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)v21 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v47 = (GfxTexture *)R_Texture_GetResident(v45->m_base.textureId);
    v48 = (R_RT_Image *)rgp.blackImage;
    textures[6] = v47;
    buffers_8 = taskInfo->attachments[6];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      v48 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    v49 = (GfxTexture *)R_Texture_GetResident(v48->m_base.textureId);
    v50 = (R_RT_Image *)rgp.blackImage;
    textures[7] = v49;
    buffers_8 = taskInfo->attachments[7];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      v50 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    textures[8] = (GfxTexture *)R_Texture_GetResident(v50->m_base.textureId);
    R_SetComputeTextures(computeState, 0, 9, (const GfxTexture *const *)textures);
    if ( vrsInlineResolve )
    {
      if ( R_RT_Handle::IsValid(taskInfo->attachments + 7) )
      {
        buffers_8 = taskInfo->attachments[7];
        v51 = R_RT_ColorHandle::Cast(&v70, &buffers_8);
        textureId = R_RT_Handle::GetSurface(v51)->m_color.m_fmaskImage.m_base.textureId;
      }
      else
      {
        textureId = rgp.blackImage->textureId;
      }
      *(_QWORD *)&buffers_8.m_surfaceID = R_Texture_GetResident(textureId);
      R_SetComputeTextures(computeState, 14, 1, (const GfxTexture *const *)&buffers_8);
      v53 = (R_RT_Image *)rgp.blackImage;
      buffers_8 = taskInfo->attachments[15];
      if ( (_WORD)v21 )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v53 = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
      }
      else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      {
        __debugbreak();
      }
      *(_QWORD *)&buffers_8.m_surfaceID = R_Texture_GetResident(v53->m_base.textureId);
      R_SetComputeTextures(computeState, 15, 1, (const GfxTexture *const *)&buffers_8);
    }
    p_view = &gfxBuf.dummyBuffer.view;
    buffers_8 = taskInfo->attachments[9];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      Surface = R_RT_Handle::GetSurface(&buffers_8);
      if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
        __debugbreak();
      v55 = &Surface->m_buffer.m_wrappedBuffer.view;
    }
    else
    {
      if ( buffers_8.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      v55 = &gfxBuf.dummyBuffer.view;
    }
    *(_QWORD *)&buffers_8.m_surfaceID = v55;
    R_SetComputeViews(computeState, 12, 1, (const GfxShaderBufferView *const *)&buffers_8);
    if ( rg.useCompressedSunShadow == 3 )
    {
      v57 = &gfxBuf.dummyRWBuffer.view;
      buffers_8 = taskInfo->attachments[12];
      if ( (_WORD)v21 )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v59 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v59->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        v58 = &v59->m_buffer.m_wrappedBuffer.view;
      }
      else
      {
        if ( buffers_8.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        v58 = &gfxBuf.dummyRWBuffer.view;
      }
      *(_QWORD *)&buffers_8.m_surfaceID = v58;
      R_SetComputeViews(computeState, 9, 1, (const GfxShaderBufferView *const *)&buffers_8);
      buffers_8 = taskInfo->attachments[13];
      if ( (_WORD)v21 )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v61 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v61->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        v60 = &v61->m_buffer.m_wrappedBuffer.view;
      }
      else
      {
        if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        v60 = &gfxBuf.dummyRWBuffer.view;
      }
      *(_QWORD *)&buffers_8.m_surfaceID = v60;
      R_SetComputeViews(computeState, 10, 1, (const GfxShaderBufferView *const *)&buffers_8);
      buffers_8 = taskInfo->attachments[14];
      if ( (_WORD)v21 )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v62 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v62->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        v57 = &v62->m_buffer.m_wrappedBuffer.view;
      }
      else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      {
        __debugbreak();
      }
      *(_QWORD *)&buffers_8.m_surfaceID = v57;
      R_SetComputeViews(computeState, 11, 1, (const GfxShaderBufferView *const *)&buffers_8);
    }
    else
    {
      *(_QWORD *)&buffers_8.m_surfaceID = &R_CompressedSunShadow_GetBuffer()->view;
      R_SetComputeViews(computeState, 9, 1, (const GfxShaderBufferView *const *)&buffers_8);
      *(_QWORD *)&buffers_8.m_surfaceID = &gfxBuf.dummyBuffer.view;
      R_SetComputeViews(computeState, 10, 1, (const GfxShaderBufferView *const *)&buffers_8);
      *(_QWORD *)&buffers_8.m_surfaceID = &gfxBuf.dummyBuffer.view;
      R_SetComputeViews(computeState, 11, 1, (const GfxShaderBufferView *const *)&buffers_8);
    }
    buffers_8 = taskInfo->attachments[11];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      v63 = R_RT_Handle::GetSurface(&buffers_8);
      if ( (v63->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
        __debugbreak();
      p_view = &v63->m_buffer.m_wrappedBuffer.view;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    *(_QWORD *)&buffers_8.m_surfaceID = p_view;
    R_SetComputeViews(computeState, 13, 1, (const GfxShaderBufferView *const *)&buffers_8);
    whiteImage = (R_RT_Image *)rgp.whiteImage;
    buffers_8 = taskInfo->attachments[8];
    if ( (_WORD)v21 )
    {
      R_RT_Handle::GetSurface(&buffers_8);
      whiteImage = &R_RT_Handle::GetSurface(&buffers_8)->m_image;
    }
    else if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
    {
      __debugbreak();
    }
    *(_QWORD *)&buffers_8.m_surfaceID = R_Texture_GetResident(whiteImage->m_base.textureId);
    R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)&buffers_8);
    v65 = DCONST_DVARBOOL_sm_sunvisPrepass;
    if ( !DCONST_DVARBOOL_sm_sunvisPrepass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepass") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v65);
    if ( !v65->current.enabled )
      goto LABEL_144;
    v66 = DCONST_DVARBOOL_sm_sunvisPrepassIndirect;
    if ( !DCONST_DVARBOOL_sm_sunvisPrepassIndirect && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "sm_sunvisPrepassIndirect") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v66);
    if ( v66->current.enabled )
    {
      buffers_8 = taskInfo->attachments[10];
      if ( (_WORD)v21 )
      {
        R_RT_Handle::GetSurface(&buffers_8);
        v67 = R_RT_Handle::GetSurface(&buffers_8);
        if ( (v67->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
          __debugbreak();
        R_DispatchIndirect(computeState, v67->m_buffer.m_wrappedBuffer.buffer, 0);
      }
      else
      {
        if ( buffers_8.m_tracking.m_allocCounter != (unsigned __int16)v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        R_DispatchIndirect(computeState, gfxBuf.dummyIndirectBuffer.buffer, 0);
      }
    }
    else
    {
LABEL_144:
      R_Dispatch(computeState, ((unsigned __int64)viewInfo->sceneViewport.width + 15) >> 4, ((unsigned __int64)viewInfo->sceneViewport.height + 15) >> 4, 1u);
    }
  }
}

/*
==============
RBT_SunShadow_Resolve
==============
*/
void RBT_SunShadow_Resolve(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 
  const dvar_t *v6; 
  const dvar_t *v7; 
  GfxCmdBufContext v8; 
  R_RT_DepthHandle m_depthRt; 

  if ( *taskInfo->pTaskData < data->sunShadow.opaqueCascadeCount )
  {
    v5 = *gfxContext;
    m_depthRt = taskInfo->rtGroup.m_depthRt;
    v8 = v5;
    R_SetRenderTargetsInternal_DepthOnly(&v8, &m_depthRt, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h(658)");
    v6 = DCONST_DVARBOOL_r_resummarizeSunCascadeCustom;
    if ( !DCONST_DVARBOOL_r_resummarizeSunCascadeCustom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_resummarizeSunCascadeCustom") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    if ( v6->current.enabled )
    {
      v8 = *gfxContext;
      R_ResummarizeDepth(&v8);
    }
    v7 = DCONST_DVARBOOL_r_resolveSunCascadeCustom;
    if ( !DCONST_DVARBOOL_r_resolveSunCascadeCustom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_resolveSunCascadeCustom") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    if ( v7->current.enabled )
    {
      v8 = *gfxContext;
      R_ResolveDepth(&v8);
    }
  }
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMask
==============
*/
void RBT_Sunshadow_GenerateTransShadowMask(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v9; 
  R_RT_Handle v11; 
  __m256i v12; 

  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    v9 = *taskInfo->attachments;
    v12 = (__m256i)v9;
    v11 = v9;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v11);
      if ( (R_RT_Handle::GetSurface(&v11)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v9 = v11;
        __debugbreak();
      }
      else
      {
        v9 = v11;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v9 = (R_RT_Handle)v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    v12 = (__m256i)v9;
    R_Sunshadow_GenerateTransShadowMask(computeState, viewInfo, data, (R_RT_ColorHandle *)&v12);
  }
}

/*
==============
RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA
==============
*/
void RBT_Sunshadow_GenerateTransShadowMaskDilationAndTAA(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v12; 
  bool v14; 
  R_RT_Handle v15; 
  R_RT_Handle v16; 
  R_RT_Handle v17; 
  __m256i v18; 

  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    v16 = *taskInfo->attachments;
    v15 = v16;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v15);
      if ( (R_RT_Handle::GetSurface(&v15)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v16 = v15;
        __debugbreak();
      }
      else
      {
        v16 = v15;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v17 = taskInfo->attachments[1];
    v15 = v17;
    if ( (_WORD)_XMM1 )
    {
      R_RT_Handle::GetSurface(&v15);
      if ( (R_RT_Handle::GetSurface(&v15)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v17 = v15;
        __debugbreak();
      }
      else
      {
        v17 = v15;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v12 = taskInfo->attachments[2];
    v18 = (__m256i)v12;
    v15 = v12;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v15);
      if ( (R_RT_Handle::GetSurface(&v15)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v12 = v15;
        __debugbreak();
      }
      else
      {
        v12 = v15;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v12 = (R_RT_Handle)v18;
        if ( v14 )
          __debugbreak();
      }
    }
    v18 = (__m256i)v16;
    v16 = v12;
    R_Sunshadow_GenerateTransShadowMaskDilationAndTAA(computeState, viewInfo, data, (R_RT_ColorHandle *)&v16, (R_RT_ColorHandle *)&v17, (R_RT_ColorHandle *)&v18);
  }
}

/*
==============
RT_SunShadow_DrawCacheSetup
==============
*/
void RT_SunShadow_DrawCacheSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Handle v7; 
  bool v9; 
  R_RT_Handle v10; 
  R_RT_Handle v11; 
  R_RT_Handle v12; 
  R_RT_Group v13; 

  if ( !viewInfo->taskGraphViewInfo.frameCount )
    R_SunShadowCache_Flush();
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    if ( r_sunshadowmap_cmdbuf_worker->current.enabled )
    {
      v10 = *taskInfo->attachments;
      R_SetInputCodeBuffer(&viewInfo->input, 6u, &v10);
      v10 = taskInfo->attachments[1];
      R_SetInputCodeBuffer(&viewInfo->input, 9u, &v10);
      v10 = taskInfo->attachments[2];
      R_SetInputCodePersistentBuffer(&viewInfo->input, 0x17u, &v10);
    }
    v12 = taskInfo->attachments[3];
    v11 = v12;
    if ( (_WORD)_XMM1 )
    {
      R_RT_Handle::GetSurface(&v11);
      if ( (R_RT_Handle::GetSurface(&v11)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v12 = v11;
      }
      else
      {
        v12 = v11;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm1, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v7 = taskInfo->attachments[4];
    v10 = v7;
    v11 = v7;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v11);
      if ( (R_RT_Handle::GetSurface(&v11)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v7 = v11;
      }
      else
      {
        v7 = v11;
        __debugbreak();
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v7 = v10;
        if ( v9 )
          __debugbreak();
      }
    }
    v13.m_colorRtCount = 0;
    v13.m_depthRt.m_surfaceID = 0;
    v13.m_depthRt.m_tracking.m_allocCounter = 0;
    memset(&v13.m_depthRt.m_tracking.m_name, 0, 18);
    v13.m_vrsRt.m_tracking.m_allocCounter = 0;
    v13.m_vrsRt.m_tracking.m_name = NULL;
    v13.m_vrsRt.m_tracking.m_location = NULL;
    v10 = v7;
    R_GenerateSortedSunShadowCacheSurfs(viewInfo, &v13, (R_RT_DepthHandle *)&v12, (R_RT_DepthHandle *)&v10, D3D12XBOX_RESOURCE_STATE_PRESERVE_COMPRESSED_DEPTH|D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_DEPTH_READ);
  }
}

/*
==============
RT_SunShadow_DrawCascadeSetup
==============
*/
void RT_SunShadow_DrawCascadeSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  signed int v4; 
  R_RT_Handle v5; 

  if ( r_sunshadowmap_cmdbuf_worker->current.enabled && (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 && rg.useCompressedSunShadow != 3 )
  {
    v4 = *taskInfo->pTaskData;
    if ( !viewInfo->input.data->sunShadow.opaqueCascadeCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 426, ASSERT_TYPE_ASSERT, "(viewInfo->input.data->sunShadow.opaqueCascadeCount > 0)", (const char *)&queryFormat, "viewInfo->input.data->sunShadow.opaqueCascadeCount > 0") )
      __debugbreak();
    if ( v4 > 26 || v4 <= viewInfo->input.data->sunShadow.opaqueCascadeCount + 23 )
    {
      v5 = *taskInfo->attachments;
      R_SetInputCodeBuffer(&viewInfo->input, 6u, &v5);
      v5 = taskInfo->attachments[1];
      R_SetInputCodeBuffer(&viewInfo->input, 9u, &v5);
      v5 = taskInfo->attachments[2];
      R_SetInputCodePersistentBuffer(&viewInfo->input, 0x17u, &v5);
      if ( viewInfo->useDynamicSunShadows || !viewInfo->useCachedSunShadow )
        R_AddDrawCall(viewInfo, &taskInfo->rtGroup, (GfxDrawListType)v4, 0x5Du);
    }
  }
}

/*
==============
RT_SunShadow_DrawTranslucentSetup
==============
*/
void RT_SunShadow_DrawTranslucentSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  __int16 v2; 
  R_RT_Image *blackImage; 
  unsigned int v6; 
  R_RT_Handle v7; 

  if ( R_SunShadow_TranslucentEnabled(viewInfo) )
  {
    if ( (unsigned __int16)(viewInfo->input.data->sunShadow.opaqueCascadeCount - 1) > 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 571, ASSERT_TYPE_ASSERT, "(viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT)", (const char *)&queryFormat, "viewInfo->input.data->sunShadow.opaqueCascadeCount > 0 && viewInfo->input.data->sunShadow.opaqueCascadeCount <= R_SUNSHADOW_OPAQUE_PARTITION_COUNT") )
      __debugbreak();
    blackImage = (R_RT_Image *)rgp.blackImage;
    v6 = *taskInfo->pTaskData;
    v7 = *taskInfo->attachments;
    if ( v2 )
    {
      R_RT_Handle::GetSurface(&v7);
      blackImage = &R_RT_Handle::GetSurface(&v7)->m_image;
    }
    else if ( v7.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v7.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    viewInfo->input.codePersistentImages[6] = &blackImage->m_base;
    if ( v6 == viewInfo->input.data->sunShadow.opaqueCascadeCount - 1 )
    {
      v7 = *taskInfo->attachments;
      R_SetInputCodeBuffer(&viewInfo->input, 6u, &v7);
      v7 = taskInfo->attachments[1];
      R_SetInputCodeBuffer(&viewInfo->input, 9u, &v7);
      v7 = taskInfo->attachments[2];
      R_SetInputCodePersistentBuffer(&viewInfo->input, 0x17u, &v7);
      R_AddDrawCall(viewInfo, &taskInfo->rtGroup, DRAWLIST_SUNSHADOW_END, 0x5Du);
    }
  }
}

/*
==============
R_TG_CompressSunShadowCascades
==============
*/
void R_TG_CompressSunShadowCascades(R_TG_Script *pScript, R_TG_Handle *sunshadowCascades, R_TG_Handle *sunshadowCascadesBackface, R_TG_Handle *compressedCascades, unsigned int cascadesCount, R_TG_Handle nullBuffer)
{
  R_TG_Handle *v8; 
  unsigned int v9; 
  const GfxCompressedSunShadowSetup *Setup; 
  int v11; 
  unsigned int v12; 
  unsigned int m_index; 
  __int64 handleArgCount; 
  unsigned int v15; 
  R_TG_Script *v16; 
  R_TG_Script *v17; 
  unsigned int v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  R_TG_Handle *v22; 
  __int64 i; 
  int v24; 
  R_TG_Script *pScripta; 
  __int64 v26; 
  __int64 v27; 
  R_TG_Handle *v28; 
  R_TG_AddTaskStack v29; 
  R_TG_AddTaskStack stack; 

  pScripta = pScript;
  v28 = sunshadowCascades;
  v8 = sunshadowCascades;
  if ( !cascadesCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 1078, ASSERT_TYPE_ASSERT, "(cascadesCount > 0)", (const char *)&queryFormat, "cascadesCount > 0") )
    __debugbreak();
  if ( cascadesCount > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_shadow.h", 1079, ASSERT_TYPE_ASSERT, "(cascadesCount <= 3)", (const char *)&queryFormat, "cascadesCount <= 3") )
    __debugbreak();
  v9 = 0;
  Setup = R_CompressedSunShadow_GetSetup();
  v11 = Setup->m_layersCount + Setup->m_totalNodesCount;
  if ( cascadesCount )
  {
    v27 = (char *)sunshadowCascadesBackface - (char *)compressedCascades;
    v26 = (char *)v8 - (char *)compressedCascades;
    do
    {
      v12 = Setup->m_compressedShadowMapMaxSize >> 2;
      v24 = -1;
      memset_0(&stack, 0, sizeof(stack));
      m_index = g_R_TG_Def_RBT_CompressSunShadow_CreateBuffers.m_index;
      stack.handleArgs[0] = (unsigned int *)&v24;
      handleArgCount = stack.handleArgCount + 1;
      stack.handleArgCount = handleArgCount;
      if ( (unsigned int)handleArgCount >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        handleArgCount = stack.handleArgCount;
      }
      stack.handleArgs[handleArgCount] = &compressedCascades->index;
      if ( ++stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      stack.paramArgs[stack.paramArgCount++] = v11;
      if ( stack.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v15 = m_index;
      v16 = pScripta;
      v17 = pScripta;
      stack.paramArgs[stack.paramArgCount++] = v12;
      R_TG_AddTask(v17, v15, &stack);
      memset_0(&v29, 0, sizeof(v29));
      v18 = g_R_TG_Def_RBT_CompressSunShadow_Main.m_index;
      v29.handleArgs[0] = (unsigned int *)((char *)&compressedCascades->index + v26);
      v19 = v29.handleArgCount + 1;
      v29.handleArgCount = v19;
      if ( (unsigned int)v19 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v19 = v29.handleArgCount;
      }
      v29.handleArgs[v19] = (unsigned int *)((char *)&compressedCascades->index + v27);
      v20 = v29.handleArgCount + 1;
      v29.handleArgCount = v20;
      if ( (unsigned int)v20 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v20 = v29.handleArgCount;
      }
      v29.handleArgs[v20] = (unsigned int *)&v24;
      v21 = v29.handleArgCount + 1;
      v29.handleArgCount = v21;
      if ( (unsigned int)v21 >= 0x1E )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
          __debugbreak();
        v21 = v29.handleArgCount;
      }
      v29.handleArgs[v21] = &compressedCascades->index;
      if ( ++v29.handleArgCount >= 0x1E && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 131, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
        __debugbreak();
      v29.paramArgs[v29.paramArgCount++] = v9;
      R_TG_AddTask(v16, v18, &v29);
      ++v9;
      ++compressedCascades;
    }
    while ( v9 < cascadesCount );
    v8 = v28;
  }
  if ( cascadesCount < 3 )
  {
    v22 = &v8[cascadesCount];
    for ( i = 3 - cascadesCount; i; --i )
    {
      v22->index = nullBuffer.index;
      ++v22;
    }
  }
}

